<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2025 (Released January 1, 2025) -->
<HTML lang="en">
<HEAD>
<TITLE>4 Infrastructure: Fields and Grids</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2025">

<LINK REL="STYLESHEET" HREF="ESMC_crefdoc.css">

<LINK REL="next" HREF="node6.html">
<LINK REL="previous" HREF="node4.html">
<LINK REL="next" HREF="node6.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="ESMC_crefdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html402"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A
 HREF="ESMC_crefdoc.html">ESMC_crefdoc</A>
<B> Previous:</B> <A
 HREF="node4.html">3 Superstructure</A>
 &nbsp; <B>  <A ID="tex2html403"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><A ID="tex2html404"
  HREF="node5.html#SECTION05010000000000000000"><SPAN CLASS="arabic">15</SPAN> Overview of Infrastructure Data Handling</A>
<UL>
<LI><A ID="tex2html405"
  HREF="node5.html#SECTION05011000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Infrastructure Data Classes</A>
<LI><A ID="tex2html406"
  HREF="node5.html#SECTION05012000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">2</SPAN> Design and Implementation Notes</A>
</UL>
<LI><A ID="tex2html407"
  HREF="node5.html#SECTION05020000000000000000"><SPAN CLASS="arabic">16</SPAN> Field Class</A>
<UL>
<LI><A ID="tex2html408"
  HREF="node5.html#SECTION05021000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html409"
  HREF="node5.html#SECTION05022000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html410"
  HREF="node5.html#SECTION05022100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_REGRIDMETHOD</A>
</UL>
<LI><A ID="tex2html411"
  HREF="node5.html#SECTION05023000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A ID="tex2html412"
  HREF="node5.html#SECTION05023100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field create and destroy</A>
</UL>
<LI><A ID="tex2html413"
  HREF="node5.html#SECTION05024000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html414"
  HREF="node5.html#SECTION05030000000000000000"><SPAN CLASS="arabic">17</SPAN> Array Class</A>
<UL>
<LI><A ID="tex2html415"
  HREF="node5.html#SECTION05031000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html416"
  HREF="node5.html#SECTION05032000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html417"
  HREF="node5.html#SECTION05040000000000000000"><SPAN CLASS="arabic">18</SPAN> ArraySpec Class</A>
<UL>
<LI><A ID="tex2html418"
  HREF="node5.html#SECTION05041000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html419"
  HREF="node5.html#SECTION05042000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html420"
  HREF="node5.html#SECTION05050000000000000000"><SPAN CLASS="arabic">19</SPAN> Grid Class</A>
<UL>
<LI><A ID="tex2html421"
  HREF="node5.html#SECTION05051000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A ID="tex2html422"
  HREF="node5.html#SECTION05051100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Representation in ESMF</A>
<LI><A ID="tex2html423"
  HREF="node5.html#SECTION05051200000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Grids</A>
<LI><A ID="tex2html424"
  HREF="node5.html#SECTION05051300000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Grid Topologies and Periodicity</A>
<LI><A ID="tex2html425"
  HREF="node5.html#SECTION05051400000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Grid Distribution</A>
<LI><A ID="tex2html426"
  HREF="node5.html#SECTION05051500000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Coordinates</A>
<LI><A ID="tex2html427"
  HREF="node5.html#SECTION05051600000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Coordinate Specification and Generation</A>
<LI><A ID="tex2html428"
  HREF="node5.html#SECTION05051700000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> Staggering</A>
<LI><A ID="tex2html429"
  HREF="node5.html#SECTION05051800000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> Masking</A>
</UL>
<LI><A ID="tex2html430"
  HREF="node5.html#SECTION05052000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html431"
  HREF="node5.html#SECTION05052100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_COORDSYS</A>
<LI><A ID="tex2html432"
  HREF="node5.html#SECTION05052200000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_GRIDITEM</A>
<LI><A ID="tex2html433"
  HREF="node5.html#SECTION05052300000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_GRIDSTATUS</A>
<LI><A ID="tex2html434"
  HREF="node5.html#SECTION05052400000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_POLEKIND</A>
<LI><A ID="tex2html435"
  HREF="node5.html#SECTION05052500000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_STAGGERLOC</A>
<LI><A ID="tex2html436"
  HREF="node5.html#SECTION05052600000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_FILEFORMAT</A>
</UL>
<LI><A ID="tex2html437"
  HREF="node5.html#SECTION05053000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html438"
  HREF="node5.html#SECTION05054000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<UL>
<LI><A ID="tex2html439"
  HREF="node5.html#SECTION05054100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Topology</A>
</UL>
<LI><A ID="tex2html440"
  HREF="node5.html#SECTION05055000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API: General Grid Methods</A>
</UL>
<LI><A ID="tex2html441"
  HREF="node5.html#SECTION05060000000000000000"><SPAN CLASS="arabic">20</SPAN> Mesh Class</A>
<UL>
<LI><A ID="tex2html442"
  HREF="node5.html#SECTION05061000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A ID="tex2html443"
  HREF="node5.html#SECTION05061100000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh Representation in ESMF</A>
<LI><A ID="tex2html444"
  HREF="node5.html#SECTION05061200000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Meshes</A>
</UL>
<LI><A ID="tex2html445"
  HREF="node5.html#SECTION05062000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html446"
  HREF="node5.html#SECTION05062100000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_MESHELEMTYPE</A>
<LI><A ID="tex2html447"
  HREF="node5.html#SECTION05062200000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_FILEFORMAT</A>
</UL>
<LI><A ID="tex2html448"
  HREF="node5.html#SECTION05063000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html449"
  HREF="node5.html#SECTION05070000000000000000"><SPAN CLASS="arabic">21</SPAN> XGrid Class</A>
<UL>
<LI><A ID="tex2html450"
  HREF="node5.html#SECTION05071000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html451"
  HREF="node5.html#SECTION05072000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN> Restrictions and Future Work</A>
<UL>
<LI><A ID="tex2html452"
  HREF="node5.html#SECTION05072100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Restrictions and Future Work</A>
</UL>
<LI><A ID="tex2html453"
  HREF="node5.html#SECTION05073000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html454"
  HREF="node5.html#SECTION05074000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html455"
  HREF="node5.html#SECTION05080000000000000000"><SPAN CLASS="arabic">22</SPAN> DistGrid Class</A>
<UL>
<LI><A ID="tex2html456"
  HREF="node5.html#SECTION05081000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html457"
  HREF="node5.html#SECTION05082000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html458"
  HREF="node5.html#SECTION05090000000000000000"><SPAN CLASS="arabic">23</SPAN> RouteHandle Class</A>
<UL>
<LI><A ID="tex2html459"
  HREF="node5.html#SECTION05091000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html460"
  HREF="node5.html#SECTION05092000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html461"
  HREF="node5.html#SECTION05093000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html462"
  HREF="node5.html#SECTION05094000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html463"
  HREF="node5.html#SECTION05095000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION05000000000000000000">
<SPAN CLASS="arabic">4</SPAN> Infrastructure: Fields and Grids</A>
</H1>
<P>

<H1><A ID="SECTION05010000000000000000">
<SPAN CLASS="arabic">15</SPAN> Overview of Infrastructure Data Handling</A>
</H1>

<P>
The ESMF infrastructure data classes are part of the framework's 
hierarchy of structures for handling Earth system model data and 
metadata on parallel platforms.  The hierarchy is in complexity; the 
simplest data class in the infrastructure represents a distributed data
array and the most complex data class represents a bundle of physical 
fields that are discretized on the same grid.  However, the current C API 
does not support bundled data structures yet. Array and Field are the two
data classes offered by the ESMF C language binding.  Data class methods 
are called both from user-written code and from other classes 
internal to the framework. 

<P>
Data classes are distributed over <B>DE</B>s, or <B>Decomposition Elements</B>.  
A DE represents a piece of a decomposition.  A DELayout is a collection
of DEs with some associated connectivity that describes a specific 
distribution.  For example, the distribution of a grid divided 
into four segments in the x-dimension would be expressed in ESMF as
a DELayout with four DEs lying along an x-axis. This abstract concept 
enables a data decomposition to be defined in 
terms of threads, MPI processes, virtual decomposition elements, or
combinations of these without changes to user code.  This is a
primary strategy for ensuring optimal performance and portability
for codes using the ESMF for communications.

<P>
ESMF data classes provide a standard,
convenient way for developers to collect together information 
related to model or observational data.  The information assembled 
in a data class includes a data pointer, a set of attributes 
(e.g. units, although attributes can also be user-defined), and a 
description of an associated grid.  The same set of information within 
an ESMF data object can be used by the framework to arrange 
intercomponent data transfers, to perform I/O, for communications
such as gathers and scatters, for simplification of interfaces 
within user code, for debugging, and for other functions.  
This unifies and organizes codes overall so that the user need not
define different representations of metadata for the same field 
for I/O and for component coupling.  

<P>
Since it is critical that users be able to introduce ESMF into their
codes easily and incrementally, ESMF data classes can be created based 
on native Fortran pointers.  Likewise, there are methods for retrieving 
native Fortran pointers from within ESMF data objects.  This allows
the user to perform allocations using ESMF, and to retrieve Fortran
arrays later for optimized model calculations.  The ESMF data classes 
do not have associated differential operators or other mathematical 
methods.

<P>
For flexibility, it is not necessary to build an ESMF data object 
all at once.  For example, it's possible to create a 
field but to defer allocation of the associated field data until 
a later time.

<P>
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=553>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Hierarchy of data structures designed specifically for the Earth 
system domain and high performance, parallel computing.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Multi-use ESMF structures simplify user code overall.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Data objects support incremental construction and deferred allocation.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Native Fortran arrays can be associated with or retrieved from ESMF data
objects, for ease of adoption, convenience, and performance.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION05011000000000000000">
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Infrastructure Data Classes</A>
</H2>

<P>
The main classes that are used for model and observational data manipulation
are as follows:

<P>

<UL>
<LI><B>Array</B>  An ESMF Array contains a data pointer, 
information about its associated datatype, precision, and 
dimension.  

<P>
Data elements in Arrays are partitioned into categories 
defined by the role the data element plays in distributed halo 
operations.  Haloing - sometimes called ghosting - is the 
practice of copying portions of array data to multiple memory 
locations to ensure that data dependencies can be satisfied 
quickly when performing a calculation.  ESMF Arrays contain 
an <B>exclusive</B> domain, which contains data elements
updated exclusively and definitively by a given DE; a 
<B>computational</B> domain, which contains all data elements
with values that are updated by the DE in computations; and 
a <B>total</B> domain, which includes both the computational 
domain and data elements from other DEs which may be read 
but are not updated in computations.

<P>
</LI>
<LI><B>Field</B>  A Field holds model and/or observational 
data together with its underlying grid or set of spatial 
locations.  It provides methods for configuration, 
initialization, setting and retrieving data values, 
data I/O, data regridding, and manipulation of attributes.

<P>
</LI>
</UL>

<P>

<H2><A ID="SECTION05012000000000000000">
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">2</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>In communication methods such as Regrid, Redist, Scatter, etc. 
the Field code cascades down through the Array code, so 
that the actual implementation exist in only one place in the source.

<P>
</LI>
</OL>

<H1><A ID="SECTION05020000000000000000">
<SPAN CLASS="arabic">16</SPAN> Field Class</A>
</H1>

<H2><A ID="SECTION05021000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
An ESMF Field represents a physical field, such as temperature.
The motivation for including Fields in ESMF is that bundles of 
Fields are the entities that are normally exchanged when coupling
Components.  

<P>
The ESMF Field class contains distributed and discretized field data, a reference 
to its associated grid, and metadata.  The Field class stores the grid <I>staggering</I>
for that physical field.
This is the relationship of how the data array of a field maps onto a grid 
(e.g. one item per
cell located at the cell center, one item per cell located at the NW
corner,  one item per cell vertex, etc.).  This means that different Fields
which are on the same underlying ESMF Grid but have different
staggerings can share the same Grid object without needing to replicate
it multiple times. 

<P>
Fields can be added to States for use in inter-Component
data communications.

<P>
Field communication capabilities include: data redistribution, regridding, scatter,
gather, sparse-matrix multiplication, and halo update.  These are discussed
in more detail in the documentation for the specific method calls.  
ESMF does not currently support vector fields, so the components of 
a vector field must be stored as separate Field objects.  

<H2><A ID="SECTION05022000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION05022100000000000000"></A>
<A ID="opt:cregridmethod"></A>
<BR>
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_REGRIDMETHOD
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>  
Specify which interpolation method to use during regridding. 

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMC_RegridMethod_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_REGRIDMETHOD_BILINEAR</STRONG></DT>
<DD>Bilinear interpolation. Destination value is a linear combination of the source values in the cell which contains the destination point. The weights for the linear combination are based on the distance of destination point from each source value. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_PATCH</STRONG></DT>
<DD>Higher-order patch recovery interpolation. Destination value is a weighted average of 2D polynomial patches constructed from cells surrounding the source cell which contains the destination point. This method typically results in better approximations to values and derivatives than bilinear. However, because of its larger stencil, it also results in a much larger interpolation matrix (and thus routeHandle) than the bilinear. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_NEAREST_STOD</STRONG></DT>
<DD>In this version of nearest neighbor interpolation each destination point is mapped to the closest source point. A given source point may go to multiple destination points, but no destination point will receive input from more than one source point. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_NEAREST_DTOS</STRONG></DT>
<DD>In this version of nearest neighbor interpolation each source point is mapped to the closest destination point. A given destination point may receive input from multiple source points, but no source point will go to more than one destination point. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_CONSERVE</STRONG></DT>
<DD>First-order conservative interpolation. The main purpose of this method is to preserve the integral of the field between the source and destination. 
      Will typically give a less accurate approximation to the individual field values than the bilinear or patch methods. The value of a destination cell is calculated as the weighted sum of the values of the source cells that it overlaps. The weights are determined by the amount the source cell overlaps the destination cell. Needs corner coordinate values to be provided in the Grid. Currently only works for Fields created on the Grid center stagger or the Mesh element location. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_CONSERVE_2ND</STRONG></DT>
<DD>Second-order conservative interpolation. As with first-order, preserves the integral of the value between the source and destination. However, typically produces a smoother more accurate result than first-order. Also like first-order, the value of a destination cell is calculated as the weighted sum of the values of the source cells that it overlaps. However, second-order also includes additional terms to take into account the gradient of the field across the source cell. Needs corner coordinate values to be provided in the Grid. Currently only works for Fields created on the Grid center stagger or the Mesh element location. 
</DD>
</DL>
<H2><A ID="SECTION05023000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
A Field serves as an annotator of data, since it carries 
a description of the grid it is associated with and metadata 
such as name and units.  Fields can be used in this capacity
alone, as convenient, descriptive containers into which arrays 
can be placed and retrieved.  However, for most codes the primary 
use of Fields is in the context of import and export States,
which are the objects that carry coupling information between 
Components.  Fields enable data to be self-describing, and a
State holding ESMF Fields contains data in a standard format
that can be queried and manipulated.  

<P>
The sections below go into more detail about Field usage.

<P>

<H3><A ID="SECTION05023100000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field create and destroy</A>
</H3>

<P>
Fields can be created and destroyed at any time during 
application execution.  However, these Field methods require 
some time to complete.  We do not recommend that the user
create or destroy Fields inside performance-critical 
computational loops.

<P>
All versions of the <SPAN style="font-family:monospace">ESMC_FieldCreate()</SPAN> 
routines require a Mesh object as input.
The Mesh contains the information needed to know which 
Decomposition Elements (DEs) are participating in 
the processing of this Field, and which subsets of the data
are local to a particular DE.

<P>
The details of how the create process happens depend
on which of the variants of the <SPAN style="font-family:monospace">ESMC_FieldCreate()</SPAN> 
call is used.

<P>
When finished with an <SPAN style="font-family:monospace">ESMC_Field</SPAN>, the <SPAN style="font-family:monospace">ESMC_FieldDestroy</SPAN> method
removes it.  However, the objects inside the <SPAN style="font-family:monospace">ESMC_Field</SPAN>
created externally should be destroyed separately, 
since objects can be added to
more than one <SPAN style="font-family:monospace">ESMC_Field</SPAN>.  For example, the same <SPAN style="font-family:monospace">ESMF_Mesh</SPAN>
can be referenced by multiple <SPAN style="font-family:monospace">ESMC_Field</SPAN>s.  In this case the
internal Mesh is not deleted by the <SPAN style="font-family:monospace">ESMC_FieldDestroy</SPAN> call.

<H2><A ID="SECTION05024000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05030000000000000000">
<SPAN CLASS="arabic">17</SPAN> Array Class</A>
</H1>

<H2><A ID="SECTION05031000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The Array class is an alternative to the Field class for representing 
distributed, structured data.  Unlike Fields, which are built to carry 
grid coordinate information, Arrays can only carry information about the 
<I>indices</I> associated with grid cells.  Since they do not have coordinate 
information, Arrays cannot be used to calculate interpolation weights.  
However, if the user can supply interpolation weights, the Array sparse 
matrix multiply operation can be used to apply the weights and transfer 
data to the new grid.  Arrays can also perform redistribution, scatter, 
and gather communication operations.

<P>
Like Fields, Arrays can be added to a State and used in inter-Component 
data communications.

<P>
From a technical standpoint, the ESMF Array class is an index space 
based, distributed data storage class. It provides DE-local memory allocations 
within DE-centric index regions and defines the relationship to the index 
space described by the ESMF DistGrid. The Array class offers common 
communication patterns within the index space formalism.

<H2><A ID="SECTION05032000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05040000000000000000">
<SPAN CLASS="arabic">18</SPAN> ArraySpec Class</A>
</H1>

<H2><A ID="SECTION05041000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
An ArraySpec is a very simple class that contains type, kind, and
rank information about an Array.  This information is stored in two
parameters.  <B>TypeKind</B> describes the data type of the elements
in the Array and their precision.  <B>Rank</B> is the number of dimensions
in the Array.

<P>
The only methods that are associated with the ArraySpec class are those 
that allow you to set and retrieve this information.

<P>

<H2><A ID="SECTION05042000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05050000000000000000">
<SPAN CLASS="arabic">19</SPAN> Grid Class</A>
</H1>

<H2><A ID="SECTION05051000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF Grid class is used to describe the geometry and discretization
of logically rectangular physical grids.  It also contains the
description of the grid's underlying topology and the decomposition
of the physical grid across the available computational resources.
The most frequent use of the Grid class is to describe physical grids
in user code so that sufficient information is available to perform ESMF
methods such as regridding.  

<P>
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=553>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Representation of grids formed by logically rectangular regions,
including uniform and rectilinear grids (e.g. lat-lon grids),
curvilinear grids (e.g. displaced pole grids), and grids formed
by connected logically rectangular regions (e.g. cubed sphere grids).</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Support for 1D, 2D, 3D, and higher dimension grids.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Distribution of grids across computational resources for parallel
operations - users set which grid dimensions are distributed.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Grids can be created already distributed, so that no single
resource needs global information during the creation process.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Options to define periodicity and other edge connectivities either 
explicitly or implicitly via shape shortcuts.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Options for users to define grid coordinates themselves or call
prefabricated coordinate generation routines for standard grids
[NO GENERATION ROUTINES YET].</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Options for incremental construction of grids.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Options for using a set of pre-defined stagger locations or for setting
custom stagger locations.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A ID="SECTION05051100000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Representation in ESMF</A>
</H3>

<P>
ESMF Grids are based on the concepts described in <I>A Standard
Description of Grids Used in Earth System Models</I> [Balaji 2006].  In this document
Balaji introduces the mosaic concept as a means of describing
a wide variety of Earth system model grids.  A <B>mosaic</B> is
composed of grid tiles connected at their edges.  Mosaic grids
includes simple, single tile grids as a special case.  

<P>
The ESMF Grid class is a representation of a mosaic grid.  Each ESMF
Grid is constructed of one or more logically rectangular <B>Tiles</B>.
A Tile will usually have some physical significance (e.g. the region
of the world covered by one face of a cubed sphere grid).

<P>
The piece of a Tile that resides on one DE (for simple cases, a DE
can be thought of as a processor - see section on the DELayout)
is called a <B>LocalTile</B>.  For example, the six faces of a cubed
sphere grid are each Tiles, and each Tile can be divided into many
LocalTiles.  

<P>
Every ESMF Grid contains a DistGrid object, which defines the Grid's
index space, topology, distribution, and connectivities.  It enables
the user to define the complex edge relationships of tripole and other
grids.  The DistGrid can be created explicitly and passed into a Grid
creation routine, or it can be created implicitly if the user takes
a Grid creation shortcut. The DistGrid used
in Grid creation describes the properties of the Grid cells. In addition
to this one, the Grid internally creates DistGrids for each stagger location. 
These stagger DistGrids are related to the original DistGrid, but may 
contain extra padding to represent the extent of the index space of
the stagger. These DistGrids are what are used when a Field is created 
on a Grid. 

<P>

<H3><A ID="SECTION05051200000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Grids</A>
</H3>

<P>
The range of supported grids in ESMF can be defined by:

<UL>
<LI>Types of topologies and shapes supported.  ESMF supports one or
more logically rectangular grid Tiles with connectivities specified
between cells.  For more details see section <A HREF="#sec:ShapeShortcut">19.1.3</A>.
</LI>
<LI>Types of distributions supported.  ESMF supports  regular,
irregular, or arbitrary distributions of data.  
For more details see section <A HREF="#sec:desc:dist">19.1.4</A>.
</LI>
<LI>Types of coordinates supported.  ESMF supports uniform, rectilinear,
and curvilinear coordinates.  For more details see section <A HREF="#sec:coordspec">19.1.5</A>.
</LI>
</UL>

<P>

<H3><A ID="SECTION05051300000000000000"></A>
<A ID="sec:ShapeShortcut"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Grid Topologies and Periodicity
</H3>

ESMF has shortcuts for the creation of standard Grid topologies 
or <B>shapes</B> up to 3D.  In many cases, these enable the user to
bypass the step of creating a DistGrid before creating the Grid. 
There are two sets of methods which allow the user to do this. These two sets of methods cover the same set of topologies, but
allow the user to specify them in different ways.

<P>
The first set of these are a group of overloaded
calls broken up by the number of periodic dimensions they specify. With these the user can pick 
the method which creates a Grid with the number of periodic dimensions they need, and then specify other connectivity 
options via arguments to the method. The following is a description of these methods:

<P>

<P>
<BR>

<P>
<DL>
<DT><STRONG>ESMF_GridCreateNoPeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with no edge connections, for example, a regional Grid with closed boundaries.

<P>
</DD>
<DT><STRONG>ESMF_GridCreate1PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 1 periodic dimension and supports a range of options for what to do at the pole (see&nbsp;Section&nbsp;<A HREF="#const:cpolekind">19.2.4</A>. Some examples of Grids which can be created here are tripole spheres, bipole spheres, cylinders with open poles. 

<P>
</DD>
<DT><STRONG>ESMF_GridCreate2PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 2 periodic dimensions, for example a torus, or a regional Grid with
doubly periodic boundaries. 
</DD>
</DL>

<P>
More detailed information can be found in the API description of each.

<P>

<P>
<BR>

<P>
The second set of shortcut methods is a set of methods overloaded under the name <SPAN style="font-family:monospace">ESMF_GridCreate()</SPAN>. These methods
allow the user to specify the connectivites at the end of each dimension, by using the ESMF_GridConn_Flag flag. The table below shows the ESMF_GridConn_Flag settings used to create 
standard shapes in 2D using the ESMF_GridCreate() call.  Two values
are specified for each dimension, one for the low end and one for 
the high end of the dimension's index values.

<P>

<P>
<BR>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">2D Shape</TD>
<TD CLASS="CENTER"><B>connflagDim1(1)</B></TD>
<TD CLASS="CENTER"><B>connflagDim1(2)</B></TD>
<TD CLASS="CENTER"><B>connflagDim2(1)</B></TD>
<TD CLASS="CENTER"><B>connflagDim2(2)</B></TD>
</TR>
<TR><TD CLASS="LEFT"><B>Rectangle</B></TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">NONE</TD>
</TR>
<TR><TD CLASS="LEFT"><B>Bipole Sphere</B></TD>
<TD CLASS="CENTER">POLE</TD>
<TD CLASS="CENTER">POLE</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
</TR>
<TR><TD CLASS="LEFT"><B>Tripole Sphere</B></TD>
<TD CLASS="CENTER">POLE</TD>
<TD CLASS="CENTER">BIPOLE</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
</TR>
<TR><TD CLASS="LEFT"><B>Cylinder</B></TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
</TR>
<TR><TD CLASS="LEFT"><B>Torus</B></TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
</TR>
</TABLE>

<P>
<BR>

<P>
If the user's grid shape is too complex for an ESMF shortcut routine,
or involves more than three dimensions, a DistGrid can be created
to specify the shape in detail.  This DistGrid is then passed
into a Grid create call.

<P>

<H3><A ID="SECTION05051400000000000000"></A>
<A ID="sec:desc:dist"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Grid Distribution
</H3>

<P>
ESMF Grids have several options for data distribution (also referred to
as decomposition).  As ESMF Grids are cell based, these 
options are all specified  in terms of how the cells in the Grid
are broken up between DEs. 

<P>
The main distribution options are regular, irregular, and arbitrary.
A <B>regular</B> distribution is one in which the same number of
contiguous grid cells are assigned to each DE in the
distributed dimension.  An <B>irregular</B> distribution is one in which
unequal numbers of contiguous grid cells are assigned to each
DE in the distributed dimension.  An <B>arbitrary</B> distribution is
one in which any grid cell can be assigned to any DE.  Any of these
distribution options can be applied to any of the grid shapes (i.e.,
rectangle) or types (i.e., rectilinear).  Support for arbitrary distribution 
is limited in the current version of ESMF.

<P>
Figure <A HREF="#fig:GridDecomps">7</A> illustrates options for distribution.

<DIV class="CENTER"><A ID="fig:GridDecomps"></A><A ID="1085"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 7:</STRONG>
Examples of regular and irregular decomposition of
a grid <B>a</B> that is 6x6, and an arbitrary decomposition of
a grid <B>b</B> that is 6x3.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{GridDecomps}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img8.svg"
 ALT="\scalebox{0.9}{\includegraphics{GridDecomps}}"></TD></TR>
</TABLE>
</DIV>

<P>
A distribution can also be specified using the DistGrid, by passing
object into a Grid create call.

<P>

<H3><A ID="SECTION05051500000000000000"></A>
<A ID="sec:coordspec"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Coordinates
</H3>
Grid Tiles can have uniform, rectilinear, or curvilinear
coordinates.  The coordinates of <B>uniform</B> grids are equally spaced along
their axes, and can be fully specified by the coordinates of the two opposing points
that define the grid's physical span.  The coordinates of <B>rectilinear</B> grids
are unequally spaced along their axes, and can be fully specified by giving
the spacing of grid points along each axis.  The coordinates of <B>curvilinear 
grids</B> must be specified by giving the explicit set of coordinates for each
grid point.  Curvilinear grids are often uniform or rectilinear grids that 
have been warped; for example, to place a pole over a land mass so that it
does not affect the computations performed on an ocean model grid.  Figure
<A HREF="#fig:LogRectGrids">8</A> shows examples of each type of grid.

<P>

<DIV class="CENTER"><A ID="fig:LogRectGrids"></A><A ID="553"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 8:</STRONG>
Types of logically rectangular grid tiles.  Red circles show the
values needed to specify grid coordinates for each type.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{LogRectGrids}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img9.svg"
 ALT="\scalebox{0.9}{\includegraphics{LogRectGrids}}"></TD></TR>
</TABLE>
</DIV>

<P>
Each of these coordinate types can be set for each of the standard grid shapes
described in section <A HREF="#sec:ShapeShortcut">19.1.3</A>.  

<P>
The table below shows how examples of common single Tile grids fall 
into this shape and coordinate taxonomy.  Note that any
of the grids in the table can have a regular or arbitrary distribution.

<P>

<P>
<BR>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=74>&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=147><B>Uniform</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=147><B>Rectilinear</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=147><B>Curvilinear</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=74><B>Sphere</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Global uniform lat-lon grid</TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Gaussian grid</TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Displaced pole grid</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=74><B>Rectangle</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Regional uniform lat-lon grid</TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Gaussian grid section</TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Polar stereographic grid section</TD>
</TR>
</TABLE>

<P>

<H3><A ID="SECTION05051600000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Coordinate Specification and Generation</A>
</H3>

<P>
There are two ways of specifying coordinates in ESMF.  The
first way is for the user to <B>set</B> the coordinates.  The second 
way is to take a shortcut and have the framework <B>generate</B>
the coordinates.  

<P>
No ESMF generation routines are currently available.

<P>

<H3><A ID="SECTION05051700000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> Staggering</A>
</H3>

<P>
<B>Staggering</B> is a finite difference technique in which the values 
of different physical quantities are placed at different locations
within a grid cell. 

<P>
The ESMF Grid class supports a variety of stagger locations, including
cell centers, corners, and edge centers. The default stagger location in 
ESMF is the cell center, and cell counts in Grid are based on this assumption.
Combinations of the 2D ESMF stagger locations are sufficient to specify any of the
Arakawa staggers.  ESMF also supports staggering in 3D and higher dimensions.
There are shortcuts for standard staggers, and interfaces through which users 
can create custom staggers.  

<P>
As a default the ESMF Grid class provides symmetric staggering, so
that cell centers are enclosed by cell perimeter (e.g. corner) 
stagger locations. This means the coordinate arrays for stagger
locations other than the center will have an additional element of 
padding in order to enclose the cell center locations.
However, to achieve other types of staggering, the user may alter 
or eliminate this padding by using the appropriate options when adding
coordinates to a Grid. 

<P>

<H3><A ID="SECTION05051800000000000000"></A>
<A ID="sec:usage:items"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> Masking
</H3>

<P>
Masking is the process whereby parts of a grid can be marked to be
ignored during an operation, such as regridding.  Masking can be
used on a source grid to indicate that certain portions of the grid
should not be used to generate regridded data.  This is useful, for
example, if a portion of the source grid contains unusable values.
Masking can also be used on a destination grid to indicate that the
portion of the field built on that part of the Grid should not
receive regridded data.  This is useful, for example, when part of
the grid isn't being used (e.g. the land portion of an ocean grid).

<P>
ESMF regrid currently supports masking for Fields built on
structured Grids and element masking for Fields built on
unstructured Meshes. The user may mask out points in the source
Field or destination Field or both. To do masking the user sets
mask information in the Grid 
or Mesh 
upon which the Fields passed into the
<SPAN style="font-family:monospace">ESMC_FieldRegridStore()</SPAN> call are built. The <SPAN style="font-family:monospace">srcMaskValues</SPAN> 
and <SPAN style="font-family:monospace">dstMaskValues</SPAN> arguments to that
call can then be used to specify which values in that mask
information indicate that a location should be masked out. For
example, if <SPAN style="font-family:monospace">dstMaskValues</SPAN> is set to (/1,2/), then any location that
has a value of 1 or 2 in the mask information of the Grid or Mesh
upon which the destination Field is built will be masked out.

<P>
Masking behavior differs slightly between regridding methods. For
non-conservative regridding methods (e.g. bilinear or high-order
patch), masking is done on points. For these methods, masking a
destination point means that that point won't participate in
regridding (e.g. won't be interpolated to). For these methods,
masking a source point means that the entire source cell using
that point is masked out. In other words, if any corner point
making up a source cell is masked then the cell is masked. For
conservative regridding methods (e.g. first-order conservative)
masking is done on cells. Masking a destination cell means that
the cell won't participate in regridding (e.g. won't be
interpolated to). Similarly, masking a source cell means that the
cell won't participate in regridding (e.g. won't be interpolated
from).  For any type of interpolation method (conservative or
non-conservative) the masking is set on the location upon
which the Fields passed into the regridding call are built.
For example, if Fields built on  <SPAN style="font-family:monospace">ESMC_STAGGERLOC_CENTER</SPAN> are
passed into the <SPAN style="font-family:monospace">ESMC_FieldRegridStore()</SPAN> call then the masking
should also be set on <SPAN style="font-family:monospace">ESMC_STAGGERLOC_CENTER</SPAN>.

<H2><A ID="SECTION05052000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION05052100000000000000"></A>
<A ID="const:ccoordsys"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_COORDSYS
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
 A set of values which indicates in which system the coordinates in the Grid are. This value is useful both to indicate to 
other users the type of the coordinates, but also to control how the coordinates are interpreted in regridding methods 
(e.g. <SPAN style="font-family:monospace">ESMC_FieldRegridStore()</SPAN>).

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMC_CoordSys_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_COORDSYS_CART</STRONG></DT>
<DD>Cartesian coordinate system. In this system, the cartesian coordinates are mapped to the Grid coordinate dimensions in the following order: x,y,z. (E.g. using <SPAN style="font-family:monospace">coordDim=2</SPAN> in ESMC_GridGetCoord() references the y dimension) 

<P>
</DD>
<DT><STRONG>ESMC_COORDSYS_SPH_DEG</STRONG></DT>
<DD>Spherical coordinates in degrees. In this system, the spherical coordinates are mapped to the Grid coordinate dimensions in the following order: longitude, latitude, radius. (E.g. using <SPAN style="font-family:monospace">coordDim=2</SPAN> in ESMC_GridGetCoord() references the latitude dimension) Note, however, that ESMC_FieldRegridStore() currently just supports longitude and latitude (i.e. with this system, only Grids of dimension 2 are supported in the regridding).

<P>
</DD>
<DT><STRONG>ESMC_COORDSYS_SPH_RAD</STRONG></DT>
<DD>Spherical coordinates in radians. In this system, the spherical coordinates are mapped to the Grid coordinate dimensions in the following order: longitude, latitude, radius. (E.g. using <SPAN style="font-family:monospace">coordDim=2</SPAN> in ESMC_GridGetCoord() references the latitude dimension) Note, however, that ESMC_FieldRegridStore() currently just supports longitude and latitude (i.e. with this system, only Grids of dimension 2 are supported in the regridding).

<P>
</DD>
</DL>

<P>

<H3><A ID="SECTION05052200000000000000"></A>
<A ID="const:cgriditem"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_GRIDITEM
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
The ESMC Grid can contain other kinds of data besides coordinates. 
This data is referred to as Grid &ldquo;items&rdquo;. Some items may be used
by ESMC for calculations involving the Grid. The following
are the valid values of ESMC_GridItem_Flag.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMC_GridItem_Flag)</SPAN>

<P>
The valid values are:
<BR><TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Item Label</TD>
<TD CLASS="CENTER"><B>Type Restriction</B></TD>
<TD CLASS="CENTER"><B>Type Default</B></TD>
<TD CLASS="CENTER"><B>ESMC Uses</B></TD>
<TD CLASS="CENTER"><B>Controls</B></TD>
</TR>
<TR><TD CLASS="LEFT"><B>ESMC_GRIDITEM_MASK</B></TD>
<TD CLASS="CENTER">ESMC_TYPEKIND_I4</TD>
<TD CLASS="CENTER">ESMC_TYPEKIND_I4</TD>
<TD CLASS="CENTER">YES</TD>
<TD CLASS="CENTER">Masking in Regrid</TD>
</TR>
<TR><TD CLASS="LEFT"><B>ESMC_GRIDITEM_AREA</B></TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">ESMC_TYPEKIND_R8</TD>
<TD CLASS="CENTER">YES</TD>
<TD CLASS="CENTER">Conservation in Regrid</TD>
</TR>
</TABLE>

<P>

<H3><A ID="SECTION05052300000000000000"></A>
<A ID="const:cgridstatus"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_GRIDSTATUS
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
The ESMC Grid class can exist in two states. These states are
present so that the library code can detect if a Grid has been
appropriately setup for the task at hand. The following
are the valid values of ESMC_GRIDSTATUS.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMC_GridStatus_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_GRIDSTATUS_EMPTY:</STRONG></DT>
<DD>Status after a Grid has been created with 
      <SPAN style="font-family:monospace">ESMC_GridEmptyCreate</SPAN>.  A Grid object container is allocated but
      space for internal objects is not.  Topology information and coordinate
      information is incomplete.  This object can be used in <SPAN style="font-family:monospace">ESMC_GridEmptyComplete()</SPAN>
      methods in which additional information is added to the Grid.
</DD>
<DT><STRONG>ESMC_GRIDSTATUS_COMPLETE:</STRONG></DT>
<DD>The Grid has a specific topology and
      distribution, but incomplete coordinate arrays.  The Grid can be used
      as the basis for allocating a Field, and coordinates can be added
      via <SPAN style="font-family:monospace">ESMC_GridCoordAdd()</SPAN> to allow other functionality. 
</DD>
</DL>

<P>

<H3><A ID="SECTION05052400000000000000"></A>
<A ID="const:cpolekind"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_POLEKIND
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
This type describes the type of connection that occurs at the pole when a Grid is 
created with <SPAN style="font-family:monospace">ESMC_GridCreate1PeriodicDim()</SPAN>.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMC_PoleKind_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_POLEKIND_NONE</STRONG></DT>
<DD>No connection at pole.

<P>
</DD>
<DT><STRONG>ESMC_POLEKIND_MONOPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element i+n/2.

<P>
</DD>
<DT><STRONG>ESMC_POLEKIND_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i+1.
</DD>
</DL>

<P>

<H3><A ID="SECTION05052500000000000000"></A>
<A ID="const:cstaggerloc"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_STAGGERLOC
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
 In the ESMC Grid class, data can be located at different positions in a
 Grid cell.  When setting or retrieving coordinate data the stagger location is
 specified to tell the Grid method  from where in the cell to get the data. 
 Although the user may define their own custom stagger locations, 
 ESMC provides a set of predefined locations for ease of use. The
following are the valid predefined stagger locations. 

<P>

<P>
<BR>

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:gridstaggerloc2d"></A><A ID="629"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 9:</STRONG>
2D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}$
 -->
<IMG
 STYLE="height: 12.22ex; vertical-align: -0.11ex; " SRC="img10.svg"
 ALT="\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
The 2D predefined stagger locations (illustrated in figure&nbsp;<A HREF="#fig:gridstaggerloc2d">9</A>) are:
<BR><DL>
<DT><STRONG>ESMC_STAGGERLOC_CENTER:</STRONG></DT>
<DD>The center of the cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_CORNER:</STRONG></DT>
<DD>The corners of the cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE1:</STRONG></DT>
<DD>The edges offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE2:</STRONG></DT>
<DD>The edges offset from the center in the 2nd dimension.
</DD>
</DL>

<P>

<P>
<BR>

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:gridstaggerloc3d"></A><A ID="640"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 10:</STRONG>
3D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}$
 -->
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img11.svg"
 ALT="\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
The 3D predefined stagger locations (illustrated in figure&nbsp;<A HREF="#fig:gridstaggerloc3d">10</A>) are:
<BR><DL>
<DT><STRONG>ESMC_STAGGERLOC_CENTER_VCENTER:</STRONG></DT>
<DD>The center of the 3D cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_CORNER_VCENTER:</STRONG></DT>
<DD>Half way up the vertical edges of the cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE1_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 1 and the vertical dimension.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE2_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 2 and the vertical dimension. 
</DD>
<DT><STRONG>ESMC_STAGGERLOC_CORNER_VFACE:</STRONG></DT>
<DD>The corners of the 3D cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE1_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE2_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 2nd dimension.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_CENTER_VFACE:</STRONG></DT>
<DD>The center of the top and bottom face. The face bounded by the 1st and 2nd dimensions. 
</DD>
</DL>

<P>

<H3><A ID="SECTION05052600000000000000"></A>
<A ID="const:cfileformat"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_FILEFORMAT
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
This option is used by <SPAN style="font-family:monospace">ESMC_GridCreateFromFile</SPAN> to specify the type of the input grid file.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMC_FileFormat_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_FILEFORMAT_SCRIP</STRONG></DT>
<DD>SCRIP format grid file. The SCRIP format is the format accepted by the SCRIP regridding tool&nbsp;[<A
 HREF="node8.html#ref:SCRIP">1</A>].   For Grid creation, files of this type only work when the <SPAN style="font-family:monospace">grid_rank</SPAN> in the file is equal to 2.

<P>
</DD>
<DT><STRONG>ESMC_FILEFORMAT_GRIDSPEC</STRONG></DT>
<DD>a single tile grid file comforming with the proposed CF-GRIDSPEC conventions.
</DD>
</DL>
<H2><A ID="SECTION05053000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Grids with factorized coordinates can only be redisted when they are 2D.</B>
Using the ESMF_GridCreate() interface that allows the user to create a copy of an existing Grid with a new distribution will give incorrect results when used on a Grid with 3 or more dimensions and whose coordinate arrays are less than the full dimension of the Grid (i.e. it contains factorized coordinates).

<P>
</LI>
<LI><B>7D limit.</B>  Only grids up to 7D will be supported.

<P>
</LI>
<LI><B>Future adaptation.</B>  Currently Grids
are created and then remain unchanged. In the future, it would
be useful to provide support for the various forms of grid
adaptation. This would allow the grids to dynamically change
their resolution to more closely match what is needed at a particular
time and position during a computation for front tracking or adaptive meshes.

<P>
</LI>
<LI><B>Future Grid generation.</B> This class for now only contains
the basic functionality for operating on the grid. In the future
methods will be added to enable the automatic generation of various types of
grids. 

<P>
</LI>
</UL>

<P>

<H2><A ID="SECTION05054000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<H3><A ID="SECTION05054100000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Topology</A>
</H3> 

<P>
The <SPAN style="font-family:monospace">ESMF_Grid</SPAN> class depends upon the <SPAN style="font-family:monospace">ESMF_DistGrid</SPAN> class
for the specification of its topology. That is, when 
creating a Grid, first an <SPAN style="font-family:monospace">ESMF_DistGrid</SPAN> is created to describe the 
appropriate index space topology. This decision was
made because it seemed redundant to have a system for doing this
in both classes. It also seems most appropriate for
the machinary for topology creation to be located at the lowest
level possible so that it can be used by other
classes (e.g. the <SPAN style="font-family:monospace">ESMF_Array</SPAN> class). Because of this, however,
the authors recommend that as a natural part of the 
implementation of subroutines to generate standard grid shapes
(e.g. <SPAN style="font-family:monospace">ESMF_GridGenSphere</SPAN>) a set of standard
topology generation subroutines be implemented (e.g. <SPAN style="font-family:monospace">ESMF_DistGridGenSphere</SPAN>) for users who want to create a standard topology, but a custom geometry.

<P>

<H2><A ID="SECTION05055000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API: General Grid Methods</A>
</H2>

<H1><A ID="SECTION05060000000000000000">
<SPAN CLASS="arabic">20</SPAN> Mesh Class</A>
</H1>

<H2><A ID="SECTION05061000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
Unstructured grids are commonly used in the computational solution of Partial Differential equations.  These are especially useful for problems that involve complex geometry, where using the less flexible structured grids can
result in grid representation of regions where no computation is needed.  Finite
element and finite volume methods map naturally to unstructured grids and are used commonly
in hydrology, ocean modeling, and many other applications.

<P>
In order to provide support for application codes using unstructured grids, the ESMF library provides a class for representing 
unstructured grids called the <B>Mesh</B>. Fields can be created on a Mesh to hold data. In Fortran, Fields created on a Mesh can also be used 
as either the source or destination or both of an interpolation (i.e. an <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call). This capability is currently
not supported with the C interface, however, if the C Field is passed via a State to a component written in Fortran then the regridding
can be performed there. The rest of this section describes the Mesh class and how to create and use them in ESMF. 

<P>

<H3><A ID="SECTION05061100000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh Representation in ESMF</A>
</H3>

<P>
A Mesh in ESMF is described in terms of <B>nodes</B> and <B>elements</B>. A node is a point in space which represents where the coordinate 
information in a Mesh is located. An element is a higher dimensional shape constructed of nodes. Elements give a Mesh its shape and define the relationship of the nodes to one another. Field data may be located on a Mesh's nodes. 

<P>

<H3><A ID="SECTION05061200000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Meshes</A>
</H3>

<P>
The range of Meshes supported by ESMF are defined by several factors: dimension, element types, and distribution.

<P>
ESMF currently only supports Meshes whose number of coordinate dimensions (spatial dimension) is 2 or 3. The dimension of the elements in a Mesh
(parametric dimension) must be less than or equal to the spatial dimension, but also must be either 2 or 3. This means that an ESMF mesh may be
either 2D elements in 2D space, 3D elements in 3D space, or a manifold constructed of 2D elements embedded in 3D space. 

<P>
ESMF currently supports two types of elements for each Mesh parametric dimension. For a parametric dimension of 2 the 
supported element types are triangles or quadrilaterals. For a parametric dimension of 3 the supported element types are tetrahedrons
and hexahedrons. See Section&nbsp;<A HREF="#const:cmeshelemtype">20.2.1</A> for diagrams of these. The Mesh supports any combination of element types within a particular
dimension, but types from different dimensions may not be mixed, for example, a Mesh cannot be constructed of both quadrilaterals and tetrahedra.

<P>
ESMF currently only supports distributions where every node on a PET must be a part of an element on that PET. In other words, there 
must not be nodes without an element on a PET. 

<P>

<H2><A ID="SECTION05062000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION05062100000000000000"></A>
<A ID="const:cmeshelemtype"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_MESHELEMTYPE
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
 An ESMF Mesh can be constructed from a combination of different elements. The type of elements that can
be used in a Mesh depends on the Mesh's parametric dimension, which is set during Mesh creation. The
following are the valid Mesh element types for each valid Mesh parametric dimension (2D or 3D) .

<P>

<P>
<BR>

<P>
<PRE>
                     3                          4 ---------- 3
                    / \                         |            |  
                   /   \                        |            |
                  /     \                       |            |
                 /       \                      |            |
                /         \                     |            |
               1 --------- 2                    1 ---------- 2

           ESMC_MESHELEMTYPE_TRI            ESMC_MESHELEMTYPE_QUAD

2D element types (numbers are the order for elementConn during 
                  Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 2 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Element Type</TD>
<TD CLASS="CENTER">Number of Nodes</TD>
<TD CLASS="LEFT">Description</TD>
</TR>
<TR><TD CLASS="LEFT">ESMC_MESHELEMTYPE_TRI</TD>
<TD CLASS="CENTER">3</TD>
<TD CLASS="LEFT">A triangle</TD>
</TR>
<TR><TD CLASS="LEFT">ESMC_MESHELEMTYPE_QUAD</TD>
<TD CLASS="CENTER">4</TD>
<TD CLASS="LEFT">A quadrilateral (e.g. a rectangle)</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<BR>

<P>
<PRE>
                                            
                 3                               8---------------7
                /|\                             /|              /|
               / | \                           / |             / |
              /  |  \                         /  |            /  |
             /   |   \                       /   |           /   |
            /    |    \                     5---------------6    |
           4-----|-----2                    |    |          |    |
            \    |    /                     |    4----------|----3
             \   |   /                      |   /           |   /
              \  |  /                       |  /            |  /
               \ | /                        | /             | /
                \|/                         |/              |/
                 1                          1---------------2

       ESMC_MESHELEMTYPE_TETRA             ESMC_MESHELEMTYPE_HEX  

3D element types (numbers are the order for elementConn during 
                  Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 3 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Element Type</TD>
<TD CLASS="CENTER">Number of Nodes</TD>
<TD CLASS="LEFT">Description</TD>
</TR>
<TR><TD CLASS="LEFT">ESMC_MESHELEMTYPE_TETRA</TD>
<TD CLASS="CENTER">4</TD>
<TD CLASS="LEFT">A tetrahedron (CAN'T BE USED IN REGRID)</TD>
</TR>
<TR><TD CLASS="LEFT">ESMC_MESHELEMTYPE_HEX</TD>
<TD CLASS="CENTER">8</TD>
<TD CLASS="LEFT">A hexahedron (e.g. a cube)</TD>
</TR>
</TABLE>

<P>

<H3><A ID="SECTION05062200000000000000"></A>
<A ID="const:mesh:cfileformat"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_FILEFORMAT
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
This option is used by <SPAN style="font-family:monospace">ESMF_MeshCreate</SPAN> to specify the type of the input grid file.  

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_FileFormat_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_FILEFORMAT_SCRIP</STRONG></DT>
<DD>SCRIP format grid file. The SCRIP format is the format accepted by the SCRIP regridding tool&nbsp;[<A
 HREF="node8.html#ref:SCRIP">1</A>].   For Mesh creation, files of this type only work when the <SPAN style="font-family:monospace">grid_rank</SPAN> in the file is equal to 1.

<P>
</DD>
<DT><STRONG>ESMF_FILEFORMAT_ESMFMESH</STRONG></DT>
<DD>ESMF unstructured grid file format. This format was developed by the ESMF team to match the capabilities of the Mesh class and to be efficient to convert to that class. 

<P>
</DD>
<DT><STRONG>ESMF_FILEFORMAT_UGRID</STRONG></DT>
<DD>CF-convention unstructured grid file format. This format is a proposed extension to the 
CF-conventions for unstructured grid data model. Currently, only the 2D flexible mesh topology is supported in ESMF.
</DD>
</DL>
<H2><A ID="SECTION05063000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05070000000000000000">
<SPAN CLASS="arabic">21</SPAN> XGrid Class</A>
</H1>

<H2><A ID="SECTION05071000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:xgrid:desc"></A>An exchange grid represents the 2D boundary layer usually between the
atmosphere on one side and ocean and land on the other in an Earth
system model. There are dynamical and thermodynamical processes on
either side of the boundary layer and on the boundary layer itself.
The boundary layer exchanges fluxes from either side and adjusts
boundary conditions for the model components involved. For climate modeling,
it is critical that the fluxes transferred by the boundary layer are
conservative.

<P>
The ESMF exchange grid is implemented as the <SPAN style="font-family:monospace">ESMC_XGrid</SPAN> class. 
Internally it's represented by a collection of the intersected cells
between atmosphere and ocean/land[<A
 HREF="node8.html#BalajiXGrid">2</A>] grids. 
These polygonal cells can have irregular shapes
and can be broken down into triangles facilitating a finite element
approach. 

<P>
Through the C API there is one way to create an <SPAN style="font-family:monospace">ESMC_XGrid</SPAN> object from
user supplied information. The <SPAN style="font-family:monospace">ESMC_XGrid</SPAN> takes
two lists of <SPAN style="font-family:monospace">ESMC_Grid</SPAN> or <SPAN style="font-family:monospace">ESMC_Mesh</SPAN> that represent the model component grids on
either side of the exchange grid. From the two lists of <SPAN style="font-family:monospace">ESMC_Grid</SPAN> or <SPAN style="font-family:monospace">ESMC_Mesh</SPAN>,
information required for flux exchange calculation between any pair of the 
model components from either side of the exchange grid is computed. In addition, the
internal representation of the <SPAN style="font-family:monospace">ESMC_XGrid</SPAN> is computed and can be optionally stored
as an <SPAN style="font-family:monospace">ESMC_Mesh</SPAN>. This internal representation is the collection of the intersected
polygonal cells as a result of merged <SPAN style="font-family:monospace">ESMC_Mesh</SPAN>es from both sides of the exchange grid.
<SPAN style="font-family:monospace">ESMC_Field</SPAN> can be created on the <SPAN style="font-family:monospace">ESMC_XGrid</SPAN> and used for weight generation
and regridding as the internal representation in the <SPAN style="font-family:monospace">ESMC_XGrid</SPAN> has
a complete geometrical description of the exchange grid.

<P>
Once an <SPAN style="font-family:monospace">ESMC_XGrid</SPAN> has been created, information describing it (e.g. cell areas, mesh representation, etc.)
can be retrieved from the object using a set of get calls (e.g. <SPAN style="font-family:monospace">ESMC_XGridGetElementArea()</SPAN>). The full extent of these
can be found in the API section below.  

<H2><A ID="SECTION05072000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<H3><A ID="SECTION05072100000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Restrictions and Future Work</A>
</H3>

<P>

<OL>
<A ID="XGrid:rest"></A>
<LI><B>CAUTION:</B> Any Grid or Mesh pair picked from the A side and B side of the XGrid 
cannot point to the same Grid or Mesh in memory on a local PET. This prevents Regrid from
selecting the right source and destination grid automatically to calculate the regridding routehandle.
It's okay for the Grid and Mesh to have identical topological and geographical properties as long
as they are stored in different memory.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION05073000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>The XGrid class is implemented in Fortran, and as such is
defined inside the framework by a XGrid derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The XGrid class contains information needed to create Grid, Field, and
communication routehandle.

<P>
</LI>
<LI>XGrid follows the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same XGrids at the same point in their execution. 
In addition to the unison rule, XGrid creation also performs inter-PET
communication within the current executing VM. 
</LI>
</OL>
<H2><A ID="SECTION05074000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05080000000000000000">
<SPAN CLASS="arabic">22</SPAN> DistGrid Class</A>
</H1>

<H2><A ID="SECTION05081000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:DistGrid"></A>The ESMF DistGrid class sits on top of the DELayout class (not currently
directly accessible through the ESMF C API) and holds domain
information in index space. 
A DistGrid object captures the index space topology
and describes its decomposition in terms of DEs. Combined with DELayout and VM
the DistGrid defines the data distribution of a domain decomposition across the
computational resources of an ESMF Component.

<P>
The global domain is defined as the union of logically
rectangular (LR) sub-domains or <EM>tiles</EM>. The DistGrid create methods allow
the specification of such a multi-tile global domain and its decomposition into
exclusive, DE-local LR regions according to various degrees of user specified
constraints. Complex index space topologies can be constructed by specifying
connection relationships between tiles during creation.

<P>
The DistGrid class holds domain information for all DEs. Each DE is associated
with a local LR region. No overlap of the regions is allowed. The DistGrid
offers query methods that allow DE-local topology information to be extracted,
e.g. for the construction of halos by higher classes.

<P>
A DistGrid object only contains decomposable dimensions. The minimum rank for a
DistGrid object is 1. A maximum rank does not exist for DistGrid objects, 
however, ranks greater than 7 may lead to difficulties with respect to the
Fortran API of higher classes based on DistGrid. The rank of a DELayout object
contained within a DistGrid object must be equal to the DistGrid rank. Higher
class objects that use the DistGrid, such as an Array object, may be of
different rank than the associated DistGrid object. The higher class object
will hold the mapping information between its dimensions and the DistGrid
dimensions.

<H2><A ID="SECTION05082000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05090000000000000000">
<SPAN CLASS="arabic">23</SPAN> RouteHandle Class</A>
</H1>

<H2><A ID="SECTION05091000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:RHandle"></A>
<P>
The ESMF RouteHandle class provides a unified interface for all route-based communication methods across the Field, FieldBundle, Array, and ArrayBundle classes. All route-based communication methods implement a pre-computation step, returning a RouteHandle, an execution step, and a release step. Typically the pre-computation, or Store() step will be a lot more expensive (both in memory and time) than the execution step. The idea is that once precomputed, a RouteHandle will be executed many times over during a model run, making the execution time a very performance critical piece of code. In ESMF, Regridding, Redisting, and Haloing are implemented as route-based communication methods. The following sections discuss the RouteHandle concepts that apply uniformly to all route-based communication methods, across all of the above mentioned classes.

<P>

<H2><A ID="SECTION05092000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The user interacts with the RouteHandle class through the route-based communication methods of Field, FieldBundle, Array, and ArrayBundle. The usage of these methods are described in detail under their respective class documentation section. The following examples focus on the RouteHandle aspects common across classes and methods.

<H2><A ID="SECTION05093000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Non-blocking</B> communication via the <SPAN style="font-family:monospace">routesyncflag</SPAN> option is implemented for Fields and Arrays. It is <EM>not</EM> available for FieldBundles and ArrayBundles. The user is advised to use the VMEpoch approach for all cases to achive asynchronicity.

<P>
</LI>
<LI>The <B>dynamic masking</B> feature currently has the following limitations:

<P>

<UL>
<LI>Only available for <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN> and <SPAN style="font-family:monospace">ESMF_TYPEKIND_R4</SPAN> Fields and Arrays.

<P>
</LI>
<LI>Only available through the <SPAN style="font-family:monospace">ESMF_FieldRegrid()</SPAN> and <SPAN style="font-family:monospace">ESMF_ArraySMM()</SPAN> methods.

<P>
</LI>
<LI>Destination objects that have undistributed dimensions <EM>after</EM> any distributed dimension are not supported.

<P>
</LI>
<LI>No check is implemented that ensure the user-provided RouteHandle object is suitable for dynamic masking.

<P>
</LI>
</UL>

<P>
</LI>
</UL>
<H2><A ID="SECTION05094000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
Internally all route-based communication calls are implemented as sparse matrix multiplications. The precompute step for all of the supported communication methods can be broken up into three steps:

<OL>
<LI>Construction of the sparse matrix for the specific communication method.
</LI>
<LI>Generation of the communication pattern according to the sparse matrix.
</LI>
<LI>Encoding of the communication pattern for each participating PET in form of an XXE stream.
</LI>
</OL>
<H2><A ID="SECTION05095000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="ESMC_crefdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html402"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A
 HREF="ESMC_crefdoc.html">ESMC_crefdoc</A>
<B> Previous:</B> <A
 HREF="node4.html">3 Superstructure</A>
 &nbsp; <B>  <A ID="tex2html403"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
