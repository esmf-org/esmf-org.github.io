<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2025 (Released January 1, 2025) -->
<HTML lang="en">
<HEAD>
<TITLE>3 Superstructure</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2025">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html941"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node5.html">4 Infrastructure: Fields and Grids</A>
<B> Up:</B> <A
 HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A
 HREF="node3.html">2 Command Line Tools</A>
 &nbsp; <B>  <A ID="tex2html942"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><A ID="tex2html943"
  HREF="node4.html#SECTION04010000000000000000"><SPAN CLASS="arabic">15</SPAN> Overview of Superstructure</A>
<UL>
<LI><A ID="tex2html944"
  HREF="node4.html#SECTION04011000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Superstructure Classes</A>
<LI><A ID="tex2html945"
  HREF="node4.html#SECTION04012000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">2</SPAN> Hierarchical Creation of Components</A>
<LI><A ID="tex2html946"
  HREF="node4.html#SECTION04013000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sequential and Concurrent Execution of Components</A>
<LI><A ID="tex2html947"
  HREF="node4.html#SECTION04014000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">4</SPAN> Intra-Component Communication</A>
<LI><A ID="tex2html948"
  HREF="node4.html#SECTION04015000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">5</SPAN> Data Distribution and Scoping in Components</A>
<LI><A ID="tex2html949"
  HREF="node4.html#SECTION04016000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">6</SPAN> Performance</A>
<LI><A ID="tex2html950"
  HREF="node4.html#SECTION04017000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">7</SPAN> Object Model</A>
</UL>
<LI><A ID="tex2html951"
  HREF="node4.html#SECTION04020000000000000000"><SPAN CLASS="arabic">16</SPAN> Application Driver and Required ESMF Methods</A>
<UL>
<LI><A ID="tex2html952"
  HREF="node4.html#SECTION04021000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html953"
  HREF="node4.html#SECTION04022000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html954"
  HREF="node4.html#SECTION04022100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_END</A>
</UL>
<LI><A ID="tex2html955"
  HREF="node4.html#SECTION04023000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html956"
  HREF="node4.html#SECTION04024000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Required ESMF Methods</A>
<UL>
<LI><A ID="tex2html957"
  HREF="node4.html#SECTION04024100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> User-code <SPAN style="font-family:monospace">SetServices</SPAN> method</A>
<LI><A ID="tex2html958"
  HREF="node4.html#SECTION04024200000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> User-code <SPAN style="font-family:monospace">Initialize</SPAN>, <SPAN style="font-family:monospace">Run</SPAN>, and <SPAN style="font-family:monospace">Finalize</SPAN> methods</A>
<LI><A ID="tex2html959"
  HREF="node4.html#SECTION04024300000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> User-code <SPAN style="font-family:monospace">SetVM</SPAN> method</A>
<LI><A ID="tex2html960"
  HREF="node4.html#SECTION04024400000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> Use of <SPAN style="font-family:monospace">internal procedures</SPAN> as user-provided procedures</A>
</UL>
</UL>
<LI><A ID="tex2html961"
  HREF="node4.html#SECTION04030000000000000000"><SPAN CLASS="arabic">17</SPAN> GridComp Class</A>
<UL>
<LI><A ID="tex2html962"
  HREF="node4.html#SECTION04031000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html963"
  HREF="node4.html#SECTION04032000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html964"
  HREF="node4.html#SECTION04033000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html965"
  HREF="node4.html#SECTION04034000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html966"
  HREF="node4.html#SECTION04040000000000000000"><SPAN CLASS="arabic">18</SPAN> CplComp Class</A>
<UL>
<LI><A ID="tex2html967"
  HREF="node4.html#SECTION04041000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html968"
  HREF="node4.html#SECTION04042000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html969"
  HREF="node4.html#SECTION04043000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html970"
  HREF="node4.html#SECTION04044000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html971"
  HREF="node4.html#SECTION04050000000000000000"><SPAN CLASS="arabic">19</SPAN> SciComp Class</A>
<UL>
<LI><A ID="tex2html972"
  HREF="node4.html#SECTION04051000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html973"
  HREF="node4.html#SECTION04052000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html974"
  HREF="node4.html#SECTION04053000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html975"
  HREF="node4.html#SECTION04054000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html976"
  HREF="node4.html#SECTION04060000000000000000"><SPAN CLASS="arabic">20</SPAN> Fault-tolerant Component Tunnel</A>
<UL>
<LI><A ID="tex2html977"
  HREF="node4.html#SECTION04061000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html978"
  HREF="node4.html#SECTION04062000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html979"
  HREF="node4.html#SECTION04063000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</UL>
<LI><A ID="tex2html980"
  HREF="node4.html#SECTION04070000000000000000"><SPAN CLASS="arabic">21</SPAN> State Class</A>
<UL>
<LI><A ID="tex2html981"
  HREF="node4.html#SECTION04071000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html982"
  HREF="node4.html#SECTION04072000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html983"
  HREF="node4.html#SECTION04072100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_STATEINTENT</A>
<LI><A ID="tex2html984"
  HREF="node4.html#SECTION04072200000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_STATEITEM</A>
</UL>
<LI><A ID="tex2html985"
  HREF="node4.html#SECTION04073000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html986"
  HREF="node4.html#SECTION04074000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html987"
  HREF="node4.html#SECTION04075000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html988"
  HREF="node4.html#SECTION04076000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
<LI><A ID="tex2html989"
  HREF="node4.html#SECTION04077000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html990"
  HREF="node4.html#SECTION04080000000000000000"><SPAN CLASS="arabic">22</SPAN> Attachable Methods</A>
<UL>
<LI><A ID="tex2html991"
  HREF="node4.html#SECTION04081000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html992"
  HREF="node4.html#SECTION04082000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html993"
  HREF="node4.html#SECTION04083000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html994"
  HREF="node4.html#SECTION04084000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html995"
  HREF="node4.html#SECTION04090000000000000000"><SPAN CLASS="arabic">23</SPAN> Web Services</A>
<UL>
<LI><A ID="tex2html996"
  HREF="node4.html#SECTION04091000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A ID="tex2html997"
  HREF="node4.html#SECTION04091100000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating a Service around a Component</A>
<LI><A ID="tex2html998"
  HREF="node4.html#SECTION04091200000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Code Modifications</A>
<LI><A ID="tex2html999"
  HREF="node4.html#SECTION04091300000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Accessing the Service</A>
<LI><A ID="tex2html1000"
  HREF="node4.html#SECTION04091400000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Client Application via C++ API</A>
<LI><A ID="tex2html1001"
  HREF="node4.html#SECTION04091500000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Process Controller</A>
<LI><A ID="tex2html1002"
  HREF="node4.html#SECTION04091600000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Tomcat/Axis2</A>
</UL>
<LI><A ID="tex2html1003"
  HREF="node4.html#SECTION04092000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1004"
  HREF="node4.html#SECTION04093000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1005"
  HREF="node4.html#SECTION04094000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION04000000000000000000"></A>
<A ID="part:Superstructure"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN> Superstructure
</H1>
<P>

<H1><A ID="SECTION04010000000000000000">
<SPAN CLASS="arabic">15</SPAN> Overview of Superstructure</A>
</H1>

<P>
ESMF superstructure classes define an architecture for assembling
Earth system applications from modeling <B>components</B>.  A component
may be defined in terms of the physical domain that it represents,
such as an atmosphere or sea ice model.  It may also be defined in terms
of a computational function, such as a data assimilation system.
Earth system research often requires that such components be <B>coupled</B> 
together to create an application.  By coupling we mean the data 
transformations and, on parallel computing systems, data transfers, 
that are necessary to allow data from one component to be utilized by 
another.  ESMF offers regridding methods and other tools to simplify 
the organization and execution of inter-component data exchanges.  

<P>
In addition to components defined at the level of major physical 
domains and computational functions, components may be defined that 
represent smaller computational functions within larger components, 
such as the transformation of data between the physics and dynamics 
in a spectral atmosphere model, 
or the creation of nested higher resolution regions 
within a coarser grid.  The objective is to couple components at varying 
scales both flexibly and efficiently.  ESMF encourages a hierarchical
application structure, in which large components branch into 
smaller sub-components (see Figure <A HREF="#fig:GEOS5">2</A>).  ESMF also makes 
it easier for the same component to be used in multiple contexts 
without changes to its source code.

<P>
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=553>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Modular, component-based architecture.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Hierarchical assembly of components into applications.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Use of components in multiple contexts without modification.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Sequential or concurrent component execution.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Single program, multiple datastream (SPMD) applications for 
maximum portability and reconfigurability.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Multiple program, multiple datastream (MPMD) option for 
flexibility.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION04011000000000000000">
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Superstructure Classes</A>
</H2>

<P>
There are a small number of classes in the ESMF superstructure:

<P>

<UL>
<LI><B>Component</B>  An ESMF component has two parts, one that is 
supplied by ESMF and one that is supplied by the user.  The
part that is supplied by the framework is an ESMF derived type that
is either a Gridded Component (<B>GridComp</B>) or a Coupler 
Component (<B>CplComp</B>).  A Gridded Component typically represents
a physical domain in which data is associated with one or more 
grids - for example, a sea ice model.  A Coupler Component 
arranges and executes data transformations and transfers between
one or more Gridded Components. Gridded Components and Coupler 
Components have standard methods, which include initialize, run,
and finalize.  These methods can be multi-phase.

<P>
The second part of an ESMF Component is user code, such as a
model or data assimilation system.  Users set entry points 
within their code so that it is callable by the framework.  
In practice, setting entry points means that within user code 
there are calls to ESMF methods that associate the name of a 
Fortran subroutine with a corresponding standard ESMF operation.  
For example, a user-written initialization routine called 
<SPAN style="font-family:monospace">myOceanInit</SPAN> might be associated with the standard 
initialize routine of an ESMF Gridded Component named &ldquo;myOcean&rdquo; 
that represents an ocean model.

<P>
</LI>
<LI><B>State</B>  ESMF Components exchange information with other 
Components only through States.  A State is an ESMF derived
type that can contain Fields, FieldBundles, Arrays, ArrayBundles,
and other States.  A Component is associated with two States, an 
<B>Import State</B> and an <B>Export State</B>.  Its Import State 
holds the data that it receives from other Components.  
Its Export State contains data that it makes available to 
other Components. 

<P>
</LI>
</UL>

<P>
An ESMF coupled application typically involves a parent Gridded Component, 
two or more child Gridded Components and one or more Coupler 
Components. 

<P>
The parent Gridded Component is responsible for creating the child 
Gridded Components that are exchanging data, for creating the Coupler, 
for creating the necessary Import and Export States, and for 
setting up the desired sequencing.  The application's &ldquo;main&rdquo; routine
calls the parent Gridded Component's initialize, run, and finalize 
methods in order to execute the application.  For each of these
standard methods, the parent Gridded Component in turn calls the 
corresponding methods in the child Gridded Components and the 
Coupler Component.  For example, consider a simple coupled 
ocean/atmosphere simulation.  When the initialize method of the 
parent Gridded Component is called by the application, it in turn 
calls the initialize methods of its child atmosphere and ocean 
Gridded Components, and the initialize method of an 
ocean-to-atmosphere Coupler Component.  Figure <A HREF="#fig:appunit">3</A>
shows this schematically.

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:GEOS5"></A><A ID="985"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 2:</STRONG>
ESMF enables applications such as the atmospheric general
circulation model GEOS-5 to be structured hierarchically, and 
reconfigured and extended easily.  Each box in this diagram is an
ESMF Gridded Component.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{ESMF_GEOS5}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img12.svg"
 ALT="\scalebox{0.9}{\includegraphics{ESMF_GEOS5}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>

<H2><A ID="SECTION04012000000000000000"></A>
<A ID="sec:hierarchy"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">2</SPAN> Hierarchical Creation of Components
</H2>

<P>
Components are allocated computational resources in the form of
<B>Persistent Execution Threads</B>, or <B>PET</B>s.  A list of a Component's
PETs is contained in a structure called a <B>Virtual Machine</B>,
or <B>VM</B>.  The VM also contains information about the topology and
characteristics of the underlying computer.
Components are created hierarchically, with parent Components creating
child Components and allocating some or all of their PETs to each one.
By default ESMF creates a new VM for each child Component, which 
allows Components to tailor their VM resources to match their needs.
In some cases, a child may want to share its parent's VM - ESMF
supports this, too.

<P>
A Gridded Component may exist across all the PETs in an application. 
A Gridded Component may also reside on a subset of PETs in an
application.  These PETs may wholly coincide with, be wholly contained
within, or wholly contain another Component.

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:appunit"></A><A ID="999"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 3:</STRONG>
A call to a standard ESMF initialize (run, finalize) method
by a parent component triggers calls to initialize (run, finalize)
all of its child components.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_appunit}}$
 -->
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img13.svg"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_appunit}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>

<H2><A ID="SECTION04013000000000000000"></A>
<A ID="sec:concurrency"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sequential and Concurrent Execution of Components
</H2>

<P>
When a set of Gridded Components and a Coupler runs in sequence
on the same set of PETs the application is executing in a <B>sequential</B>
mode. When Gridded Components are created and run on mutually exclusive
sets of PETs, and are coupled by a Coupler Component that extends over
the union of these sets, the mode of execution is <B>concurrent</B>.

<P>
Figure <A HREF="#fig:serial">4</A> illustrates a typical configuration for 
a simple coupled sequential
application, and Figure <A HREF="#fig:concurrent">5</A> shows a possible 
configuration for the same application running in a concurrent mode.

<P>
Parent Components can select if and when to wait for concurrently
executing child Components, synchronizing only when required.

<P>
It is possible for ESMF applications to contain some Component sets
that are executing sequentially and others that are executing concurrently.
We might have, for example, atmosphere and land Components created
on the same subset of PETs, ocean and sea ice Components created on
the remainder of PETs, and a Coupler created across all the PETs in
the application.

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:serial"></A><A ID="1013"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 4:</STRONG>
Schematic of the run method of a coupled application, with an
&ldquo;Atmosphere&rdquo; and an &ldquo;Ocean&rdquo; Gridded Component running sequentially with 
an &ldquo;Atm-Ocean Coupler.&rdquo;  The top-level &ldquo;Hurricane Model&rdquo; 
Gridded Component contains the sequencing information and time 
advancement loop.  The application driver, Coupler, and all Gridded Components 
are distributed over nine PETs.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_serial}}$
 -->
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img14.svg"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_serial}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:concurrent"></A><A ID="1021"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 5:</STRONG>
Schematic of the run method of a coupled application, with an
&ldquo;Atmosphere&rdquo; and an &ldquo;Ocean&rdquo; Gridded Component running concurrently with 
an &ldquo;Atm-Ocean Coupler.&rdquo;  The top-level &ldquo;Hurricane Model&rdquo; 
Gridded Component contains the sequencing information and time 
advancement loop.  The application driver, Coupler, and top-level &ldquo;Hurricane
Model&rdquo; Gridded Component are distributed over nine PETs.  The
&ldquo;Atmosphere&rdquo; Gridded Component is distributed over three PETs and
the &ldquo;Ocean&rdquo; Gridded Component is distributed over six PETs.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_concurrent}}$
 -->
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img15.svg"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_concurrent}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>

<H2><A ID="SECTION04014000000000000000"></A>
<A ID="sec:localcomm"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">4</SPAN> Intra-Component Communication
</H2>

<P>
All data transfers within an ESMF application occur <I>within</I> a
component.  For example, a Gridded Component may contain halo updates.
Another example is that a Coupler Component may redistribute
data between two Gridded Components.  As a result,
the architecture of ESMF does not depend on any particular data
communication mechanism, and new communication schemes can be
introduced without affecting the overall structure of the application.

<P>
Since all data communication happens within a component, a Coupler
Component must be created on the union of the PETs of all
the Gridded Components that it couples.  

<P>

<H2><A ID="SECTION04015000000000000000"></A>
<A ID="sec:scoping"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">5</SPAN> Data Distribution and Scoping in Components
</H2>

<P>
The scope of distributed objects is the VM of the currently 
executing Component.  For this reason, all
PETs in the current VM must make the same distributed object
creation calls.   When a Coupler Component running on a superset
of a Gridded Component's PETs needs to make communication calls
involving objects created by the Gridded Component,
an ESMF-supplied function called <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN> creates proxy
objects for those PETs that had no previous information about the
distributed objects.  Proxy objects contain no local data but
can be used in communication calls (such as regrid or redistribute)
to describe the remote source for data being moved to the current PET,
or to describe the remote destination for data being moved from the local PET.
Figure <A HREF="#fig:reconcile">6</A> is a simple schematic that shows the 
sequence of events in a reconcile call.

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:reconcile"></A><A ID="3696"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 6:</STRONG>
An <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN> call creates proxy 
objects for use in subsequent communication calls.  The reconcile 
call would normally be made during Coupler initialization.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_reconcile}}$
 -->
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img16.svg"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_reconcile}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>

<H2><A ID="SECTION04016000000000000000"></A>
<A ID="sec:performance"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">6</SPAN> Performance
</H2>

<P>
The ESMF design enables the user to configure ESMF
applications so that data is transferred directly from one component 
to another, without requiring that it be copied or sent to a different data
buffer as an interim step.  This is likely to be the most efficient way 
of performing inter-component coupling.  However, if desired, an 
application can also be configured so that data from a source component 
is sent to a distinct set of Coupler Component PETs for processing 
before being sent to its destination.

<P>
The ability to overlap computation with communication is essential for
performance.  When running with ESMF the user can initiate data 
sends during Gridded Component execution, as soon as the data is ready.
Computations can then proceed simultaneously with the data transfer.

<P>

<H2><A ID="SECTION04017000000000000000">
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">7</SPAN> Object Model</A>
</H2>

<P>
The following is a simplified Unified Modeling Language (UML) diagram showing the relationships among
ESMF superstructure classes.  See Appendix A, <I>A Brief Introduction 
to UML</I>, for a translation table that lists the symbols in the diagram 
and their meaning.

<P>
<DIV class="CENTER">
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img17.svg"
 ALT="\includegraphics{Comp_obj}">   

</DIV>

<P>

<H1><A ID="SECTION04020000000000000000">
<SPAN CLASS="arabic">16</SPAN> Application Driver and Required ESMF Methods</A>
</H1>

<H2><A ID="SECTION04021000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
Every ESMF application needs a driver code. Typically the driver layer is
implemented as the "main" of the application, although this is not strictly an
ESMF requirement. For most ESMF applications the task of the application driver
will be very generic: Initialize ESMF, create a top-level Component and call its
Initialize, Run and Finalize methods, before destroying the top-level Component
again and calling ESMF Finalize.

<P>
ESMF provides a number of different application driver templates in the
<SPAN style="font-family:monospace">$ESMF_DIR/src/Superstructure/AppDriver</SPAN> directory. An appropriate one 
can be chosen depending on how the application is to be structured:

<P>
<DL>
<DT><STRONG>Sequential vs. Concurrent Execution</STRONG></DT>
<DD><P>
In a sequential execution model, every Component executes
on all PETs, with each Component completing execution before
the next Component begins.  This has the appeal of 
simplicity of data consumption and production: when a Gridded 
Component starts, all required data is available for use, and when
a Gridded Component finishes, all data produced is ready for consumption
by the next Gridded Component.  This approach also has
the possibility of less data movement if the grid and
data decomposition is done such that each processor's memory contains
the data needed by the next Component.

<P>
In a concurrent execution model, subgroups of PETs run
Gridded Components and multiple Gridded Components are active at the 
same time.  Data exchange must be coordinated between Gridded 
Components so that data deadlock does not occur.  This strategy 
has the advantage of allowing coupling to other Gridded Components 
at any time during the computational process, including not 
having to return to the calling level of code before making 
data available.  

<P>
</DD>
<DT><STRONG>Pairwise vs. Hub and Spoke</STRONG></DT>
<DD><P>
Coupler Components are responsible for taking data from one
Gridded Component and putting it into the form expected by another 
Gridded Component.  This might include regridding, change of units, 
averaging, or binning.

<P>
Coupler Components can be written for <I>pairwise</I> data exchange: 
the Coupler Component takes data from a single Component and transforms 
it for use by another single Gridded Component.  This simplifies the 
structure of the Coupler Component code.

<P>
Couplers can also be written using a <I>hub and spoke</I> model where a
single Coupler accepts data from all other Components, can do data
merging or splitting, and formats data for all other Components.

<P>
Multiple Couplers, using either of the above two models or some mixture of
these approaches, are also possible.

<P>
</DD>
<DT><STRONG>Implementation Language</STRONG></DT>
<DD><P>
The ESMF framework currently has Fortran interfaces for all public functions. 
Some functions also have C interfaces, and the number of these is expected to 
increase over time. 

<P>
</DD>
<DT><STRONG>Number of Executables</STRONG></DT>
<DD><P>
The simplest way to run an application
is to run the same executable program on all PETs.  Different Components
can still be run on mutually exclusive PETs by using branching
(e.g., if this is PET 1, 2, or 3, run Component A, if it is
PET 4, 5, or 6 run Component B).  This is a <B>SPMD</B> model, 
Single Program Multiple Data.  

<P>
The alternative is to start a different executable program on different
PETs.  This is a <B>MPMD</B> model, Multiple Program Multiple Data.
There are complications with many job control systems on multiprocessor
machines in getting the different executables started, and getting
inter-process communications established.  ESMF currently has some
support for MPMD: different Components can run as separate executables,
but the Coupler that transfers data between the Components must still
run on the union of their PETs. This means that the Coupler Component
must be linked into all of the executables.

<P>
</DD>
</DL>

<P>

<H2><A ID="SECTION04022000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION04022100000000000000"></A>
<A ID="const:endflag"></A>
<BR>
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_END
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
The <SPAN style="font-family:monospace">ESMF_End_Flag</SPAN> determines how an ESMF application is shut down.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_End_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_END_ABORT</STRONG></DT>
<DD>Global abort of the ESMF application. There is no guarantee 
         that all PETs will shut down cleanly during an abort. However, all
         attempts are made to prevent the application from hanging and the
         LogErr of at least one PET will be completely flushed during the abort.
         This option should only be used if a condition is detected that
         prevents normal continuation or termination of the application.
         Typical conditions that warrant the use of <SPAN style="font-family:monospace">ESMF_END_ABORT</SPAN> 
         are those that occur on a per PET basis where other PETs may be blocked
         in communication calls, unable to reach the normal termination point.
         An aborted application returns to the parent process with a system
         dependent indication that a failure occurred during execution.
   
</DD>
<DT><STRONG>ESMF_END_NORMAL</STRONG></DT>
<DD>Normal termination of the ESMF application. Wait for all PETs of the
         global VM to reach 
	<SPAN style="font-family:monospace">ESMF_Finalize()</SPAN> before termination. This is
         the clean way of terminating an application. <SPAN style="font-family:monospace">MPI_Finalize()</SPAN> will
         be called in case of MPI applications.

</DD>
<DT><STRONG>ESMF_END_KEEPMPI</STRONG></DT>
<DD>Same as <SPAN style="font-family:monospace">ESMF_END_NORMAL</SPAN> but <SPAN style="font-family:monospace">MPI_Finalize()</SPAN> will <EM>not</EM>
         be called. It is the user code's responsibility to shut down MPI
         cleanly if necessary.
</DD>
</DL>
<H2><A ID="SECTION04023000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
ESMF encourages application organization in which there is a single 
top-level Gridded Component.  This provides a simple, clear sequence
of operations at the highest level, and also enables the entire 
application to be treated as a sub-Component of another, larger 
application if desired.  When a simple application is organized in this fashion 
the standard AppDriver can probably be used without much modification.  

<P>
Examples of program organization using the AppDriver can be found in the 
<SPAN style="font-family:monospace">src/Superstructure/AppDriver</SPAN> directory.  A set of subdirectories 
within the AppDriver directory follows the naming convention:

<PRE>
&lt;seq|concur&gt;_&lt;pairwise|hub&gt;_&lt;f|c&gt;driver_&lt;spmd|mpmd&gt;
</PRE>

<P>
The example that is currently implemented is
<SPAN style="font-family:monospace">seq_pairwise_fdriver_spmd</SPAN>, which
has sequential component execution, a pairwise coupler, a main program
in Fortran, and all processors launching the same executable.
It is also copied automatically into a top-level 
<SPAN style="font-family:monospace">quick_start</SPAN> directory at compilation time.  

<P>
The user can copy the AppDriver files into
their own local directory. Some of the files can be used unchanged.
Others are template files which have the rough outline of the code but
need additional application-specific code added in order to perform a
meaningful function.  The <SPAN style="font-family:monospace">README</SPAN> file in the AppDriver 
subdirectory or <SPAN style="font-family:monospace">quick_start</SPAN> directory contains instructions about 
which files to change.

<P>
Examples of concurrent component execution can be found in the
system tests that are bundled with the ESMF distribution.

<P>

<H2><A ID="SECTION04024000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Required ESMF Methods</A>
</H2>

<P>
There are a few methods that every ESMF application must contain. First,
<SPAN style="font-family:monospace">ESMF_Initialize()</SPAN> and <SPAN style="font-family:monospace">ESMF_Finalize()</SPAN> are in complete analogy 
to <SPAN style="font-family:monospace">MPI_Init()</SPAN> and <SPAN style="font-family:monospace">MPI_Finalize()</SPAN> known from MPI. All ESMF
programs, serial or parallel, must initialize the ESMF system at the beginning,
and finalize it at the end of execution. The behavior of calling any
ESMF method before <SPAN style="font-family:monospace">ESMF_Initialize()</SPAN>, or after <SPAN style="font-family:monospace">ESMF_Finalize()</SPAN>
is undefined.

<P>
Second, every ESMF Component that is accessed by an ESMF application requires
that its set services routine is called through
<SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN>. The Component must implement
one public entry point, its set services routine, that can be called
through the <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN> library routine. The
Component set services routine is responsible for setting entry points
for the standard ESMF Component methods Initialize, Run, and Finalize.

<P>
Finally, the Component can optionally call <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetVM()</SPAN>
<EM>before</EM> calling
<SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN>. Similar to 
<SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN>, the 
<SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetVM()</SPAN>
call requires a public entry point into the Component. It allows the Component
to adjust certain aspects of its execution environment, i.e. its own VM, before
it is started up.

<P>
The following sections discuss the above mentioned aspects in more detail.

<P>

<H3><A ID="SECTION04024100000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> User-code <SPAN style="font-family:monospace">SetServices</SPAN> method</A>
</H3>

<P>
Many programs call some library routines.  The library
documentation must explain what the routine name is, what arguments 
are required and what are optional, and what the code does.  

<P>
In contrast, all ESMF components must be written to <I>be called</I>
by another part of the program; in effect, an ESMF component takes the 
place of a library.  The interface is prescribed by the framework,
and the component writer must provide specific subroutines which 
have standard argument lists and perform specific operations.
For technical reasons <EM>none</EM> of the arguments in user-provided subroutines
must be declared as <EM>optional</EM>.

<P>
The only <EM>required</EM> public interface of a Component is its
SetServices method.  This subroutine must have an
externally accessible name (be a public symbol), take a component
as the first argument, and an integer return code as the second. 
Both arguments are required and must <EM>not</EM> be declared as 
<SPAN style="font-family:monospace">optional</SPAN>. If an intent is specified in the interface it must be 
<SPAN style="font-family:monospace">intent(inout)</SPAN> for the first and <SPAN style="font-family:monospace">intent(out)</SPAN> for the 
second argument. The subroutine name is not predefined, it is set by the
component writer, but must be provided as part of the component 
documentation.

<P>
The required function that the SetServices subroutine must provide is to
specify the user-code entry points for the standard ESMF Component methods. To
this end the user-written SetServices routine calls the 

<P>
<SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetEntryPoint()</SPAN> method to set each 
Component entry point.

<P>
See sections <A HREF="#sec:GridSetServ"><IMG  ALT="[*]" SRC="crossref.png"></A> and <A HREF="#sec:CplSetServ"><IMG  ALT="[*]" SRC="crossref.png"></A> for examples of
how to write a user-code SetServices routine.

<P>
Note that a component does not call its own SetServices routine;
the AppDriver or parent component code, which is creating a component, 
will first call <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompCreate()</SPAN> to create a component object, and then must call into <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN>, supplying the user-code SetServices routine as an argument. The framework then calls into the user-code SetServices, after the Component's VM has been started up.

<P>
It is good practice to package the user-code implementing a component into a Fortran module, with the user-code SetService routine being the only public module method. ESMF supports three mechanisms for accessing the user-code SetServices routine from the calling AppDriver or parent component.

<P>

<UL>
<LI><B>Fortran USE association</B>: The AppDriver or parent component utilizes the standard Fortran USE statement on the component module to make all public entities available. The user-code SetServices routine can then be passed directly into the <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN> interface documented in <A HREF="#GridComp:SetServices"><IMG  ALT="[*]" SRC="crossref.png"></A> and <A HREF="#CplComp:SetServices"><IMG  ALT="[*]" SRC="crossref.png"></A>, respectively.

<P>
<EM>Pros</EM>: Standard Fortran module use: name mangling and interface checking is handled by the Fortran compiler.

<P>
<EM>Cons</EM>: Fortran 90/95 has no mechanism to implement a "smart" dependency scheme through USE association. Any change in a lower level component module (even just adding or changing a comment!) will trigger a complete recompilation of all of the higher level components throughout the component hierarchy. This situation is particularly annoying for ESMF componentized code, where the prescribed ESMF component interfaces, in principle, remove all interdependencies between components that would require recompilation.

<P>
Fortran <EM>submodules</EM>, introduced as an extension to Fortran 2003, and now part for the Fortran 2008 standard, are designed to avoid this "false" dependency issue. A code change to an ESMF component that keeps the actual implementation within a submodule, will not trigger a recompilation of the components further up in the component hierarchy. Unfortunately, as of mid-2015, only two compiler vendors support submodules.

<P>
</LI>
<LI><B>External routine</B>: The AppDriver or parent component provides an explicit interface block for an external routine that implements (or calls) the user-code SetServices routine. This routine can then be passed directly into the <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN> interface documented in <A HREF="#GridComp:SetServices"><IMG  ALT="[*]" SRC="crossref.png"></A> and <A HREF="#CplComp:SetServices"><IMG  ALT="[*]" SRC="crossref.png"></A>, respectively. (In practice this can be implemented by the component as an external subroutine that simply calls into the user-code SetServices module routine.)

<P>
<EM>Pros</EM>: Avoids Fortran USE dependencies: a change to lower level component code will not trigger a complete recompilation of all of the higher level components throughout the component hierarchy. Name mangling is handled by the Fortran compiler.

<P>
<EM>Cons</EM>: The user-code SetServices interface is not checked by the compiler. The user must ensure uniqueness of the external routine name across the entire application.

<P>

</LI>
<LI><B>Name lookup</B>: The AppDriver or parent component specifies the user-code SetServices routine by name. The actual lookup and code association does not occur until runtime. The name string is passed into the <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN> interface documented in <A HREF="#GridComp:SetServicesShObj"><IMG  ALT="[*]" SRC="crossref.png"></A> and <A HREF="#CplComp:SetServicesShObj"><IMG  ALT="[*]" SRC="crossref.png"></A>, respectively.

<P>
<EM>Pros</EM>: Avoids Fortran USE dependencies: a change to lower level component code will not trigger a complete recompilation of all of the higher level components throughout the component hierarchy. The component code does not have to be accessible until runtime and may be located in a shared object, thus avoiding relinking of the application.

<P>
<EM>Cons</EM>: The user-code SetServices interface is not checked by the compiler. The user must explicitly deal with all of the Fortran name mangling issues: 1) Accessing a module routine requires precise knowledge of the name mangling rules of the specific compiler. Alternatively, the user-code SetServices routine may be implemented as an external routine, avoiding the module name mangling. 2) Even then, Fortran compilers typically append one or two underscores on a symbol name. This must be considered when passing the name into the <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN> method.

<P>
</LI>
</UL>

<P>

<H3><A ID="SECTION04024200000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> User-code <SPAN style="font-family:monospace">Initialize</SPAN>, <SPAN style="font-family:monospace">Run</SPAN>, and <SPAN style="font-family:monospace">Finalize</SPAN> methods</A>
</H3>

<P>
The required standard ESMF Component methods, for which user-code entry
points must be set, are Initialize, Run, and Finalize. Currently optional,
a Component may also set entry points for the WriteRestart and
ReadRestart methods.

<P>
Sections <A HREF="#sec:GridSetServ"><IMG  ALT="[*]" SRC="crossref.png"></A> and <A HREF="#sec:CplSetServ"><IMG  ALT="[*]" SRC="crossref.png"></A> provide examples
of how the entry points for Initialize, Run, and Finalize are set during
the user-code SetServices routine, using the 
<SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetEntryPoint()</SPAN> library call.

<P>
All standard user-code methods must abide <EM>exactly</EM> to the prescribed
interfaces. <EM>None</EM> of the arguments must be declared as <EM>optional</EM>.

<P>
The names of the Initialize, Run, and Finalize user-code subroutines do
not need to be public; in fact it is far better for them to be private to
lower the chances of public symbol clashes between different components.

<P>
See sections <A HREF="#sec:GridInitialize"><IMG  ALT="[*]" SRC="crossref.png"></A>, <A HREF="#sec:GridRun"><IMG  ALT="[*]" SRC="crossref.png"></A>,
<A HREF="#sec:GridFinalize"><IMG  ALT="[*]" SRC="crossref.png"></A>, and <A HREF="#sec:CplInitialize"><IMG  ALT="[*]" SRC="crossref.png"></A>, <A HREF="#sec:CplRun"><IMG  ALT="[*]" SRC="crossref.png"></A>,
<A HREF="#sec:CplFinalize"><IMG  ALT="[*]" SRC="crossref.png"></A> for examples of how to write entry points for the 
standard ESMF Component methods.

<P>

<H3><A ID="SECTION04024300000000000000"></A>
<A ID="sec:AppDriverSetVM"></A>
<BR>
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> User-code <SPAN style="font-family:monospace">SetVM</SPAN> method
</H3>

<P>
When the AppDriver or parent component code calls
<SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompCreate()</SPAN> it has the option to specify a 
<SPAN style="font-family:monospace">petList</SPAN> argument. All of the parent PETs contained in this list become
resources of the child component. By default, without the <SPAN style="font-family:monospace">petList</SPAN> argument, all of the parent PETs are provided to the child component.

<P>
Typically each component has its own virtual machine (VM) object. However, using the optional <SPAN style="font-family:monospace">contextflag</SPAN> argument during <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompCreate()</SPAN> a child component can inherit its parent component's VM. Unless a child component inherits the parent VM, it has the option to set certain aspects of how its VM utilizes the provided resources. The resources provided via the parent PETs are the associated processing elements (PEs) and virtual address spaces (VASs).

<P>
The optional user-written SetVM routine is called from the parent for the child through the <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetVM()</SPAN> method. This is the only place where the child component can set aspects of its own VM before it is started up. The child component's VM must be running before the SetServices routine can be called, and thus the parent must call the optional <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetVM()</SPAN> method <EM>before</EM> <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN>.

<P>
Inside the user-code called by the SetVM routine, the component has the option to specify how the PETs share the provided parent PEs. Further, PETs on the same single system image (SSI) can be set to run multi-threaded within a reduced number of virtual address spaces (VAS), allowing a component to leverage shared memory concepts.

<P>
Sections <A HREF="#sec:GridSetVM"><IMG  ALT="[*]" SRC="crossref.png"></A> and <A HREF="#sec:CplSetVM"><IMG  ALT="[*]" SRC="crossref.png"></A> provide examples for
simple user-written SetVM routines.

<P>
One common use of the SetVM approach is to implement hybrid parallelism based on MPI+OpenMP. Under ESMF, each component can use its own hybrid parallelism implementation. Different components, even if running on the same PE resources, do not have to agree on the number of MPI processes (i.e. PETs), or the number of OpenMP threads launched under each PET. Hybrid and non-hybrid components can be mixed within the same application. Coupling between components of any flavor is supported under ESMF.

<P>
In order to obtain best performance when using SetVM based resource control for hybrid parallelism, it is <EM>strongly recommended</EM> to set <SPAN style="font-family:monospace">OMP_WAIT_POLICY=PASSIVE</SPAN> in the environment. This is one of the standard OpenMP environment variables. The <SPAN style="font-family:monospace">PASSIVE</SPAN> setting ensures that OpenMP threads relinquish the PEs as soon as they have completed their work. Without that setting ESMF resource control threads can be delayed, and context switching between components becomes more expensive.

<P>

<H3><A ID="SECTION04024400000000000000"></A>
<A ID="sec:AppDriverIntProc"></A>
<BR>
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> Use of <SPAN style="font-family:monospace">internal procedures</SPAN> as user-provided procedures
</H3>

<P>
Internal procedures are nested within a surrounding procedure, and only local to the surrounding procedure.
They are specified by using the CONTAINS statement.

<P>
Prior to Fortran-2008 an internal procedure could not be used as a user-provided callback procedure.
In Fortran-2008 this restriction was lifted.  It is important to note that if ESMF is passed an internal
procedure, that the surrounding procedure be active whenever ESMF calls it.  This helps ensure that
local variables at the surrounding procedures scope are properly initialized.

<P>
When internal procedures contained within a main program unit are used for callbacks, there is no problem.
This is because the main program unit is always active.  However when internal procedures are used within
other program units, initialization could become a problem.  The following outlines the issue:

<P>
<PRE>
  module my_procs_mod
    use ESMF
    implicit none

  contains

    subroutine my_procs (...)
      integer :: my_setting
      :
      call ESMF_GridCompSetEntryPoint(gridcomp, methodflag=ESMF_METHOD_INITIALIZE, &amp;
          userRoutine=my_grid_proc_init, rc=localrc)
      :
      my_setting = 42

    contains

      subroutine my_grid_proc_init (gridcomp, importState, exportState, clock, rc)
        :
      ! my_setting is possibly uninitialized when my_grid_proc_init is used as a call-back
        something = my_setting
        :
      end subroutine my_grid_proc_init
    end subroutine my_procs
  end module my_procs_mod
</PRE>

<P>
The Fortran standard does not specify whether variable <I>my_setting</I> is statically or
automatically allocated, unless it is explicitly given the SAVE attribute.  Thus there is no
guarantee that its value will persist after <I>my_procs</I> has finished.  The SAVE attribute
is usually given to a variable via specifying a SAVE attribute in its delaration.  However it can
also be inferred by initializing the variable in its declaration:

<P>
<PRE>
      :
      integer, save : my_setting
      :
</PRE>

<P>
or,

<P>
<PRE>
      :
      integer :: my_setting = 42
      :
</PRE>

<P>
Because of the potential initialization issues, it is recommended that internal procedures
only be used as ESMF callbacks when the surrounding procedure is also active.

<P>

<H1><A ID="SECTION04030000000000000000">
<SPAN CLASS="arabic">17</SPAN> GridComp Class</A>
</H1>

<H2><A ID="SECTION04031000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:GridComp"></A>
<P>
In Earth system modeling, the most natural way to think about an ESMF 
Gridded Component, or <SPAN style="font-family:monospace">ESMF_GridComp</SPAN>, is as a piece of code 
representing a particular physical domain, such as an atmospheric 
model or an ocean model.  Gridded Components may also represent individual
processes, such as radiation or chemistry.  It's up to the application
writer to decide how deeply to &ldquo;componentize.&rdquo;

<P>
Earth system software components tend to share a number of basic 
features.  Most ingest and produce a variety of physical fields, refer to 
a (possibly noncontiguous) spatial region and a grid that is 
partitioned across a set of computational resources, and require 
a clock for things like stepping a governing set of PDEs forward in time.  
Most can also be divided into distinct initialize, run, and finalize 
computational phases.  These common characteristics are used 
within ESMF to define a Gridded Component data structure that 
is tailored for Earth system modeling and yet is still flexible
enough to represent a variety of domains.

<P>
A well designed Gridded Component does not store information 
internally about how it couples to other Gridded Components.  That
allows it to be used in different contexts without changes to source
code.  The idea here is to avoid situations in which slightly
different versions of the same model source are maintained for use in 
different contexts - standalone vs. coupled versions, for example.
Data is passed in and out of Gridded Components using an ESMF State,
this is described in Section&nbsp;<A HREF="#sec:State">21.1</A>.

<P>
An ESMF Gridded Component has two parts, one which is user-written
and another which is part of the framework.  The user-written
part is software that represents a physical domain or performs some
other computational function.  It forms the body of the Gridded 
Component.  It may be a piece of legacy code, or it may be developed 
expressly for use with ESMF.  It must contain routines with
standard ESMF interfaces that can be called to initialize, run, and
finalize the Gridded Component.  These routines can have separate 
callable phases, such as distinct first and second initialization steps.

<P>
ESMF provides the Gridded Component derived type, 
<SPAN style="font-family:monospace">ESMF_GridComp</SPAN>.  An <SPAN style="font-family:monospace">ESMF_GridComp</SPAN> must be created 
for every portion of the application that will be represented 
as a separate component.  For example, in a climate model, there may 
be Gridded Components representing the land, ocean, sea ice, and 
atmosphere.  If the application contains an ensemble of identical 
Gridded Components, every one has its own associated <SPAN style="font-family:monospace">ESMF_GridComp</SPAN>.
Each Gridded Component has its own name and is allocated
a set of computational resources, in the form of an ESMF Virtual
Machine, or <SPAN style="font-family:monospace">VM</SPAN>.

<P>
The user-written part of a Gridded Component is associated with an
<SPAN style="font-family:monospace">ESMF_GridComp</SPAN> derived type through a routine called 
<SPAN style="font-family:monospace">ESMF_SetServices()</SPAN>.
This is a routine that the user must write, and declare public.
Inside the SetServices routine the user must call  
<SPAN style="font-family:monospace">ESMF_SetEntryPoint()</SPAN> methods that associate a standard ESMF 
operation with the name of the corresponding Fortran subroutine 
in their user code.

<H2><A ID="SECTION04032000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A Gridded Component is a computational entity which consumes and produces data. It uses a State object to exchange data between itself and other Components. It uses a Clock object to manage time, and a VM to describe its own and its child components' computational resources.

<P>
This section shows how to create Gridded Components.  For demonstrations
of the use of Gridded Components, see the system tests that are bundled with the ESMF software
distribution.  These can be found in the directory <SPAN style="font-family:monospace">esmf/src/system_tests</SPAN>.

<P>

<H2><A ID="SECTION04033000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No optional arguments.</B> User-written routines called by SetServices,
and registered for Initialize, Run and Finalize, <EM>must not</EM> declare any
of the arguments as optional.

<P>
</LI>
<LI><B>Namespace isolation.</B>
If possible, Gridded Components should attempt to make 
all data private, so public names do not interfere with data 
in other components.

<P>
</LI>
<LI><B>Single execution mode.</B>
It is not expected that a single Gridded Component be able 
to function in both sequential and concurrent modes, although 
Gridded Components of different types can be nested. For example,
a concurrently called Gridded Component can contain several nested 
sequential Gridded Components. 

<P>
</LI>
</OL>
<H2><A ID="SECTION04034000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION04040000000000000000">
<SPAN CLASS="arabic">18</SPAN> CplComp Class</A>
</H1>

<H2><A ID="SECTION04041000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:CplComp"></A>
<P>
In a large, multi-component application such as a weather 
forecasting or climate prediction system running within ESMF, 
physical domains and major system functions are represented 
as Gridded Components 
(see Section <A HREF="#sec:GridComp">17.1</A>).  A Coupler Component, or 
<SPAN style="font-family:monospace">ESMF_CplComp</SPAN>, arranges and executes the data 
transformations between the Gridded Components.  Ideally, 
Coupler Components should contain all the information 
about inter-component communication for an application.
This enables the Gridded Components in the application to be 
used in multiple contexts; that is, used in different coupled 
configurations without changes to their source code. 
For example, the same atmosphere might in one case be coupled 
to an ocean in a hurricane prediction model, and to a 
data assimilation system for numerical weather prediction in
another.  A single Coupler Component can couple 
two or more Gridded Components.

<P>
Like Gridded Components, Coupler Components have two parts, one
that is provided by the user and another that is part of the 
framework.  The user-written portion of the software is the coupling
code necessary for a particular exchange between Gridded Components.  
This portion of the Coupler Component code must be divided into 
separately callable initialize, run, and finalize methods.  The 
interfaces for these methods are prescribed by ESMF.

<P>
The term &ldquo;user-written&rdquo; is somewhat misleading here, since within 
a Coupler Component the user can leverage ESMF infrastructure 
software for regridding, redistribution, lower-level communications, 
calendar management, and other functions.  However, ESMF is unlikely 
to offer all the software necessary to customize a data transfer
between Gridded Components.  For instance, ESMF does not currently 
offer tools for unit tranformations or time averaging operations, 
so users must manage those operations themselves.

<P>
The second part of a Coupler Component is the <SPAN style="font-family:monospace">ESMF_CplComp</SPAN>
derived type within ESMF.  The user must create one of these types
to represent a specific coupling function, such as the regular
transfer of data between a data assimilation system and an 
atmospheric model.  <A ID="tex2html21"
  HREF="footnode.html#foot3702"><SUP><SPAN CLASS="arabic">2</SPAN></SUP></A>

<P>
The user-written part of a Coupler Component is associated with an
<SPAN style="font-family:monospace">ESMF_CplComp</SPAN> derived type through a routine called 
<SPAN style="font-family:monospace">ESMF_SetServices()</SPAN>.
This is a routine that the user must write and declare public.
Inside the <SPAN style="font-family:monospace">ESMF_SetServices()</SPAN> routine the user must call 
<SPAN style="font-family:monospace">ESMF_SetEntryPoint()</SPAN> methods that associate a standard ESMF 
operation with the name of the corresponding Fortran subroutine in 
their user code.  For example, a user routine called &ldquo;couplerInit&rdquo;
might be associated with the standard initialize routine in a 
Coupler Component.

<H2><A ID="SECTION04042000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A Coupler Component manages the transformation of data between Components.
It contains a list of State objects and the operations needed to
make them compatible, including such things as regridding and unit conversion.
Coupler Components are user-written, following prescribed ESMF interfaces
and, wherever desired, using ESMF infrastructure tools.

<H2><A ID="SECTION04043000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No optional arguments.</B> User-written routines called by SetServices,
and registered for Initialize, Run and Finalize, <EM>must not</EM> declare any
of the arguments as optional.

<P>
</LI>
<LI><B>No Transforms.</B>  Components must exchange data through 
<SPAN style="font-family:monospace">ESMF_State</SPAN> objects.  The input data are available at the time 
the component code is called, and data to be returned to another 
component are available when that code returns.  

<P>
</LI>
<LI><B>No automatic unit conversions.</B>  The ESMF framework does not 
currently contain tools for performing unit conversions, operations that 
are fairly standard within Coupler Components.

<P>
</LI>
<LI><B>No accumulator.</B>  The ESMF does not have an accumulator tool, to
perform time averaging of fields for coupling.  This is likely to be developed
in the near term.

<P>
</LI>
</OL>
<H2><A ID="SECTION04044000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION04050000000000000000">
<SPAN CLASS="arabic">19</SPAN> SciComp Class</A>
</H1>

<H2><A ID="SECTION04051000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:SciComp"></A>
<P>
In Earth system modeling, a particular piece of code representing a physical 
domain, such as an atmospheric model or an ocean model, is typically 
implemented as an ESMF Gridded Component, or <SPAN style="font-family:monospace">ESMC_GridComp</SPAN>.  
However, there are times when physical domains, or realms, need to be 
represented, but aren't actual pieces of code, or software.  These domains 
can be implemented as ESMF Science Components, or <SPAN style="font-family:monospace">ESMC_SciComp</SPAN>.

<P>
Unlike Gridded and Coupler Components, Science Components are not associated 
with software; they don't include execution routines such as initialize, 
run and finalize.  The main purpose of a Science Component 
is to provide a container for Attributes within a Component hierarchy. 

<H2><A ID="SECTION04052000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A Science Component is a container object intended to represent scientific
domains, or realms, in an Earth Science Model.  It's primary purpose is to 
provide a means for representing Component metadata within a hierarchy of
Components, and it does this by being a container for Attributes as well 
as other Components.

<P>

<H2><A ID="SECTION04053000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>None.</B> 

<P>
</LI>
</OL>
<H2><A ID="SECTION04054000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION04060000000000000000">
<SPAN CLASS="arabic">20</SPAN> Fault-tolerant Component Tunnel</A>
</H1>

<H2><A ID="SECTION04061000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:CompTunnel"></A>
<P>
For ensemble runs with many ensemble members, fault-tolerance becomes an issue of very critical practical impact. The meaning of <EM>fault-tolerance</EM> in this context refers to the ability of an ensemble application to continue with normal execution after one or more ensemble members have experienced catastrophic conditions, from which they cannot recover. ESMF implements this type of fault-tolerance on the Component level via a <B>timeout</B> paradigm: A timeout parameter is specified for all interactions that need to be fault-tolerant. When a connection to a component times out, maybe because it has become inaccessible due to some catastrophic condition, the driver application can react to this condition, for example by not further interacting with the component during the otherwise normal continuation of the model execution.

<P>
The fault-tolerant connection between a driver application and a Component is established through a <B>Component Tunnel</B>. There are two sides to a Component Tunnel: the "actual" side is where the component is actually executing, and the "dual" side is the portal through which the Component becomes accessible on the driver side. Both the actual and the dual side of a Component Tunnel are implemented in form of a regular ESMF Gridded or Coupler Component.

<P>
Component Tunnels between Components can be based on a number of low level implementations. The only implementation that currently provides fault-tolerance is <EM>socket</EM> based. In this case an actual Component typically runs as a separate executable, listening to a specific port for connections from the driver application. The dual Component is created on the driver side. It connects to the actual Component during the SetServices() call.

<P>

<H2><A ID="SECTION04062000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A Component Tunnel connects a <EM>dual</EM> Component to an <EM>actual</EM> Component. This connection can be based on a number of different low level implementations, e.g. VM-based or socket-based. VM-based Component Tunnels require that both dual and actual Components run within the same application (i.e. execute under the same MPI_COMM_WORLD). Fault-tolerant Component Tunnels require that dual and actual Components run in separate applications, under different MPI_COMM_WORLD communicators. This mode is implemented in the socket-based Component Tunnels.

<H2><A ID="SECTION04063000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No data flow through States.</B> The current implementation does not support data flow (Fields, FieldBundles, etc.) between actual and dual Components. The current work-around is to employ user controlled, file based transfer methods. The next implementation phase will offer transparent data flow through the Component Tunnel, where the user code interacts with the States on the actual and dual side in the same way as if they were the same Component.

<P>
</LI>
</OL>

<H1><A ID="SECTION04070000000000000000">
<SPAN CLASS="arabic">21</SPAN> State Class</A>
</H1>

<H2><A ID="SECTION04071000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:State"></A>
<P>
A State contains the data and metadata to be transferred between 
ESMF Components.  It is an important class, because it defines a 
standard for how data is represented in data transfers between Earth
science components.  The 
State construct is a rational compromise between a fully prescribed 
interface - one that would dictate what specific fields should be 
transferred between components - and an interface in which data structures
are completely ad hoc.

<P>
There are two types of States, import and export.
An import State contains data that is necessary for a Gridded Component
or Coupler Component to execute, and an export State contains the data
that a Gridded Component or Coupler Component can make available.

<P>
States can contain Arrays, ArrayBundles, Fields, FieldBundles, 
and other States.  They cannot directly contain native language arrays
(i.e. Fortran or C style arrays).  Objects in a State must span
the VM on which they are running.  For sequentially executing components
which run on the same set of PETs this happens by calling the object
create methods on each PET, creating the object in unison.   For
concurrently executing components which are running on subsets of PETs,
an additional method, called <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN>, is provided by
ESMF to broadcast information
about objects which were created in sub-components.

<P>
State methods include creation and deletion, adding and retrieving 
data items, adding and retrieving attributes, and performing queries.  

<P>

<H2><A ID="SECTION04072000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION04072100000000000000"></A>
<A ID="const:stateintent"></A>
<BR>
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_STATEINTENT
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Specifies whether a <SPAN style="font-family:monospace">ESMF_State</SPAN> contains data to be imported
into a component or exported from a component.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_StateIntent_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_STATEINTENT_IMPORT</STRONG></DT>
<DD>Contains data to be imported into a component.
   
</DD>
<DT><STRONG>ESMF_STATEINTENT_EXPORT</STRONG></DT>
<DD>Contains data to be exported out of a component.
   
</DD>
<DT><STRONG>ESMF_STATEINTENT_INTERNAL</STRONG></DT>
<DD>Contains data that is not exposed outside of a component.
   
</DD>
<DT><STRONG>ESMF_STATEINTENT_UNSPECIFIED</STRONG></DT>
<DD>The intent has not been specified.
</DD>
</DL>

<P>

<H3><A ID="SECTION04072200000000000000"></A>
<A ID="const:stateitem"></A>
<BR>
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_STATEITEM
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Specifies the type of object being added to or retrieved from an
ESMF_State.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_StateItem_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_STATEITEM_ARRAY</STRONG></DT>
<DD>Refers to an <SPAN style="font-family:monospace">ESMF_Array</SPAN> within an <SPAN style="font-family:monospace">ESMF_State</SPAN>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_ARRAYBUNDLE</STRONG></DT>
<DD>Refers to an <SPAN style="font-family:monospace">ESMF_Array</SPAN> within an <SPAN style="font-family:monospace">ESMF_State</SPAN>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_FIELD</STRONG></DT>
<DD>Refers to a <SPAN style="font-family:monospace">ESMF_Field</SPAN> within an <SPAN style="font-family:monospace">ESMF_State</SPAN>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_FIELDBUNDLE</STRONG></DT>
<DD>Refers to a <SPAN style="font-family:monospace">ESMF_FieldBundle</SPAN> within an <SPAN style="font-family:monospace">ESMF_State</SPAN>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_ROUTEHANDLE</STRONG></DT>
<DD>Refers to a <SPAN style="font-family:monospace">ESMF_RouteHandle</SPAN> within an <SPAN style="font-family:monospace">ESMF_State</SPAN>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_STATE</STRONG></DT>
<DD>Refers to a <SPAN style="font-family:monospace">ESMF_State</SPAN> within an <SPAN style="font-family:monospace">ESMF_State</SPAN>.
</DD>
</DL>

<P>

<H2><A ID="SECTION04073000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
A Gridded Component generally has one associated import 
State and one export State.  Generally the States 
associated with a Gridded Component will be created by 
the Gridded Component's parent component.
In many cases, the States will be created containing 
no data.  Both the empty States and the
newly created Gridded Component are passed
by the parent component into the Gridded Component's initialize 
method.  This is where the States get prepared for use 
and the import State is first filled with data.

<P>
States can be filled with data items that do not yet 
have data allocated.  Fields, FieldBundles, Arrays, and ArrayBundles each have 
methods that support their creation without actual data 
allocation - the Grid and Attributes are set up but no
Fortran array of data values is allocated.  In this approach, 
when a State is passed into its associated Gridded Component's 
initialize method, the incomplete Arrays, Fields, FieldBundles,
and ArrayBundles within the State can allocate or reference data 
inside the initialize method.

<P>
States are passed through the interfaces of the Gridded 
and Coupler Components' run methods in order to carry data 
between the components.  While we expect
a Gridded Component's import State to be filled with data 
during initialization, its export State will typically be
filled over the course of its run method.  At the end of
a Gridded Component's run method, the filled export State 
is passed out through the argument list into a Coupler 
Component's run method.  We recommend the convention that 
it enters the Coupler Component as the Coupler Component's
import State.  Here the data is transformed into a form
that another Gridded Component requires, and passed out
of the Coupler Component as its export State.  It can then
be passed into the run method of a recipient Gridded Component
as that component's import State.

<P>
While the above sounds complicated, the rule is simple:
a State going into a component is an import State, and a 
State leaving a component is an export State.

<P>
Objects inside States are normally created in <I>unison</I> where
each PET executing a component makes the same object create call.
If the object contains data, like a Field, each PET may have a
different local chunk of the entire dataset but each Field has
the same name and is logically one part of a single distributed 
object.   As States are passed between components, if any object
in a State was not created in unison on all the current PETs 
then some PETs have no object to pass into a
communication method (e.g. regrid or data redistribution).
The <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN> method must be called to broadcast 
information about these objects to all PETs in a component;
after which all PETs have a single uniform view of all objects and metadata.  

<P>
If components are running in sequential mode on all available PETs
and States are being passed between them there is no need to call 
<SPAN style="font-family:monospace">ESMF_StateReconcile</SPAN> since all PETs have a uniform view of the objects.
However, if components are running on a subset of the PETs, as is
usually the case when running in concurrent mode, then when States
are passed into components which contain a superset of those PETs,
for example, a Coupler Component, all PETs must call <SPAN style="font-family:monospace">ESMF_StateReconcile</SPAN>
on the States before using them in any ESMF communication methods.
The reconciliation process broadcasts information about objects
which exist only on a subset of the PETs.  On PETs missing those
objects it creates a <I>proxy</I> object which contains any
qualities of the original object plus enough information for it
to be a data source or destination for a regrid or data redistribution
operation.

<H2><A ID="SECTION04074000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No synchronization of object IDs at object create time - Unison Rule:</B>
Object IDs are used during the reconcile process to identify objects
which are unknown to some subset of the PETs in the currently running VM.
Object IDs are assigned in sequential order at object create time across the
context of the current VM without communication. This design was requested by
the user community during ESMF object design to reduce communication and
synchronization overhead when creating distributed ESMF objects.
As a consequence it is required to create distributed ESMF objects in
<B>unison</B> across all PETs of the current VM in order to keep the ESMF object
identification in sync.

<P>
Violation of the unison rule will lead to undefined behavior when reconciling
a State that contains objects with inconsistent object IDs.

<P>
</LI>
<LI><B>Info keys on top level State not reconciled without actual objects
present from the relevant sub-context.</B> One of the actions of the
<SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN> method is to reconcile the Info keys of the
State object itself. The endresult is that the reconciled State has the
same Info <EM>keys</EM> on all of the PETs of the VM across which it was
reconciled &ndash; albeit with potentially different values across PETs
(see the <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN> API doc for more details). An edge case
for which <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN> does <B>not</B> provide Info key
reconcilation is when keys were added under a component executing on a subset
of PETs (compared to the reconciling VM), but no actual object
(Field, FieldBundle, Array, ArrayBundle, or nested State) was added under the
VM of that sub-context.

<P>
The situation of unreconciled Info keys across PETs for an ESMF State is not an
error condition per-se, however, it can lead to unexpected behavior in
downstream code. Specifically if such code expects to find consistent Info keys
across all PETs. If this is the case, care should be taken to ensure actual
objects are added to the top level State on the sub-context PETs where new Info
keys are added.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION04075000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>States contain the name of the associated Component, a flag for Import
or Export, and a list of data objects, which can be a combination of
FieldBundles, Fields, and/or Arrays.  The objects must be named and have
the proper attributes so they can be identified by the receiver of
the data.  For example, units and other detailed information
may need to be associated with the data as an Attribute.  

<P>
</LI>
<LI>Data contained in States must be created in unison on each
PET of the current VM.  This allows the creation process to avoid
doing communications since each PET can compute any information
it needs to know about any remote PET (for example, the grid
distribute method can compute the decomposition of the grid on
not only the local PET but also the remote PETs since it knows
each PET is making the identical call).  For all PETs to have a
consistent view of the data this means objects must be given
unique names when created, or all objects must be created in
the same order on all PETs so ESMF can generate consistent
default names for the objects.

<P>
When running components on subsets of the original VM all the
PETs can create consistent objects but then when they are put
into a State and passed to a component with a different VM and
a different set of PETs, a communication call (reconcile) must be 
made to communicate the missing information to the PETs which were 
not involved in the original object creation.  The reconcile call
broadcasts object lists; those PETs which are missing any objects
in the total list can receive enough information to
reconstruct a proxy object which contains all necessary information
about that object, with no local data, on that PET.  These proxy
objects can be queried by ESMF routines to determine the amount
of data and what PETs contain data which is destined to be moved
to the local PET (for receiving data) and conversely, can determine
which other PETs are going to receive data and how much (for
sending data).

<P>
For example, the FieldExcl system test creates 2 Gridded Components
on separate subsets of PETs.  They use the option of mapping
particular, non-monotonic PETs to DEs.  The following figures 
illustrate how the DEs are mapped in each of the Gridded Components
in that test:

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:excl_source"></A><A ID="3704"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 7:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the source grid created by <SPAN style="font-family:monospace">user_model1.F90</SPAN>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_src_grid}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img18.svg"
 ALT="\scalebox{0.9}{\includegraphics{Excl_src_grid}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:excl_destination"></A><A ID="3706"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 8:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the destination grid created by <SPAN style="font-family:monospace">user_model2.F90</SPAN>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_dst_grid}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img19.svg"
 ALT="\scalebox{0.9}{\includegraphics{Excl_dst_grid}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
In the coupler code, all PETs must make the reconcile call before
accessing data in the State.  On PETs which already contain data,
the objects are unchanged.  On PETs which were not involved during
the creation of the FieldBundles or Fields, the reconcile call adds an
object to the State which contains all the same metadata associated
with the object, but creates a slightly different Grid object,
called a Proxy Grid. These PETs contain no local data, so the
Array object is empty, and the DELayout for the Grid is like this:

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:excl_source_cpl"></A><A ID="3708"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 9:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the source grid after the reconcile call in <SPAN style="font-family:monospace">user_coupler.F90</SPAN>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_src_grid_cpl}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img20.svg"
 ALT="\scalebox{0.9}{\includegraphics{Excl_src_grid_cpl}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:excl_destination_cpl"></A><A ID="3710"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 10:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the destination grid after the reconcile call in <SPAN style="font-family:monospace">user_coupler.F90</SPAN>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_dst_grid_cpl}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img21.svg"
 ALT="\scalebox{0.9}{\includegraphics{Excl_dst_grid_cpl}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
</LI>
</OL>

<H2><A ID="SECTION04076000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
State class.  States can contain FieldBundles, Fields, Arrays, or nested
States.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV class="CENTER">
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img22.svg"
 ALT="\includegraphics{State_obj}">   

</DIV>
<H2><A ID="SECTION04077000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION04080000000000000000">
<SPAN CLASS="arabic">22</SPAN> Attachable Methods</A>
</H1>

<H2><A ID="SECTION04081000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
ESMF allows user methods to be attached to Components and States. Providing
this capability supports a more object oriented way of model design. 

<P>
Attachable methods on Components can be used to implement the concept of
generic Components where the specialization requires attaching methods with
well defined names. This methods are then called by the generic Component 
code.

<P>
Attaching methods to States can be used to supply data operations along with
the data objects inside of a State object. This can be useful where a producer
Component not only supplies a data set, but also the associated processing
functionality. This can be more efficient than providing all of the possible
sets of derived data.

<H2><A ID="SECTION04082000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how a producer Component attaches a
user defined method to a State, and how it implements the method. The attached
method is then executed by the consumer Component.

<H2><A ID="SECTION04083000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Not reconciled.</B>
Attachable Methods are PET-local settings on an object. Currently Attachable
Methods cannot be reconciled (i.e. ignored during <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN>).
</LI>
<LI><B>No copy nor move.</B>
Currently Attachable Methods cannot be copied or moved between objects.
</LI>
</OL>

<P>

<H2><A ID="SECTION04084000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION04090000000000000000">
<SPAN CLASS="arabic">23</SPAN> Web Services</A>
</H1>

<H2><A ID="SECTION04091000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The goal of the ESMF Web Services is to provide the tools to allow ESMF Users to make 
their Components available via a web service.  The first step is to make the Component 
a service, and then make it accessible via the Web.  

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:webservices_fig"></A><A ID="1360"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 11:</STRONG>
The diagram describes the ESMF Web Services software architecture. The architecture
defines a multi-tiered set of applications that provide a flexible approach for accessing
model components.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.5}{\includegraphics{webservices}}$
 -->
<IMG
 STYLE="height: 8.22ex; vertical-align: -0.11ex; " SRC="img23.svg"
 ALT="\scalebox{0.5}{\includegraphics{webservices}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
At the heart of this architecture is the Component Service; this is the 
application that does the model work.  The ESMF Web Services part provides a way to make 
the model accessible via a network API (Application Programming Interface). ESMF provides 
the tools to turn a model component into a service as well as the tools to access the 
service from the network. 

<P>
The Process Controller is a stand-alone application that provides a control mechanism between 
the end user and the Component Service.  The Process Controller is responsible for managing 
client information as well as restricting client access to a Component Service.  
(The role of the Process Controller is expected to expand in the future.)

<P>
The tomcat/axis2 application provides the access via the Web using standard SOAP 
protocols. Part of this application includes the SOAP interface definition 
(using a WSDL file) as well as some java code that provides the access to the Process 
Controller application.

<P>
Finally, the Registrar maintains a list of Component Services that are currently 
available;  Component Services register themselves with the Registrar when they 
startup, and unregister themselves when they shutdown.  The list of available services 
is maintained in an XML file and is accessible from the Registrar using its network API.

<P>

<H3><A ID="SECTION04091100000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating a Service around a Component</A>
</H3>

<H3><A ID="SECTION04091200000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Code Modifications</A>
</H3>
One of the goals in providing the tools to make Components into services was to make 
the process as simple and easy as possible.  Any model component that has been 
implemented using the ESMF Component Framework can easily be turned into a 
Component Services with just a minor change to the Application 
driver code.  (For details on the ESMF Framework, see the ESMF Developers Documentation.)

<P>
The primary function in ESMF Web Services is the ESMF_WebServicesLoop routine.  This 
function registers the Component Service with the Registrar and then sets up a 
network socket service that listens for requests from a client.  It starts a loop 
that waits for incoming requests and manages the routing of these requests to 
all PETs.  It is also responsible for making sure the appropriate ESMF 
routine (ESMF_Initialize, ESMF_Run or ESMF_Finalize) is called based on the incoming 
request. When the client has completed its interaction with the Component Service, 
the loop will be terminated and it will unregister the Component Service from the Registrar. 

<P>
To make all of this happen, the Application Driver just needs to replace its calls to 
ESMF_Initialize, ESMF_Run, and ESMF_Finalize with a single call to ESMF_WebServicesLoop. 

<P>
<PRE>
	use ESMF_WebServMod
	....

	call ESMF_WebServicesLoop(gridComponent, portNumber, returnCode)
</PRE>

<P>
That's all there is to turning an ESMF Component into a network-accessible 
ESMF Component Service.  For a detailed example of an ESMF Component turned into 
an ESMF Component Service, see the Examples in the Web Services section of the 
Developer' Guide.

<P>

<H3><A ID="SECTION04091300000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Accessing the Service</A>
</H3>
Now that the Component is available as a service, it can be accessed remotely by any client 
that can communicate via TCP sockets.  The ESMF library, in addition to providing the 
service tools, also provides the classes to create C++ clients to access the Component 
Service via the socket interface.

<P>
However, the goal of ESMF Web Services is to make an ESMF Component accessible through 
a standard web service, which is accomplished through the Process Controller and the 
Tomcat/Axis2 applications

<P>

<H3><A ID="SECTION04091400000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Client Application via C++ API</A>
</H3>

<P>
Interfacing to a Component service is fairly simple using the ESMF library.  The following 
code is a simple example of how to interface to a Component Service in C++ and request 
the initialize operation (the entire sample client can be found in the Web Services examples 
section of the ESMF Distribution):

<P>
<PRE>
	#include "ESMCI_WebServCompSvrClient.h"

	int  main(int  argc, char*  argv[])
	{
   	    int    portNum = 27060;
      	    int    clientId = 101;
   	    int    rc = ESMF_SUCCESS;

   	    ESMCI::ESMCI_WebServCompSvrClient   
                         client("localhost", portNum, clientId);

   	    rc = client.init();
   	    printf("Initialize return code: %d\n", rc);
	}
</PRE>

<P>
To see a complete description of the NetEsmfClient class, refer to the netesmf library 
section of the Web Services Reference Manual.

<P>

<H3><A ID="SECTION04091500000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Process Controller</A>
</H3>

<P>
The Process Controller is basically just a instance of a C++ client application. It manages 
client access to the Component Service (only 1 client can access the service at a time), 
and will eventually be responsible for starting up and shutting down instances of 
Component Services (planned for a future release). The Process Controller application is 
built with the ESMF library and is included in the apps section of the distribution.

<P>

<H3><A ID="SECTION04091600000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Tomcat/Axis2</A>
</H3>

<P>
The Tomcat/Axis2 "application" is essentially the Apache Tomcat server using 
the Apache Axis2 servlet to  implement web services using SOAP protocols. The web 
interface is defined by a WSDL file, and its implementation is handled by the Component 
Connector java code.  Tomcat and Axis2 are both open source projects that should be 
downloaded from the Apache web site, but the WSDL file, the Component Connector java 
code, and all required software for supporting the interface can be found next to the 
ESMF distribution in the web_services_server directory. This code is not included with 
the ESMF distribution because they can be distributed and installed independent of each other.

<H2><A ID="SECTION04092000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to use ESMF Web Services.

<H2><A ID="SECTION04093000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Manual Control of Process.</B>
Currently, the Component Service must be manually started and stopped.  Future plans include having the Process Controller be responsible for controlling the Component Service processes.
</LI>
<LI><B>Data Streaming.</B>
While data can be streamed from the web server to the client, it is not yet getting the data directly from the Component Service.  Instead, the Component Service exports the data to a file which the Process Controller can read and return across the network interface.  The data streaming capabilities will be a major component of future improvements to the Web Services architecture.
</LI>
</OL>

<P>

<H2><A ID="SECTION04094000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html941"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node5.html">4 Infrastructure: Fields and Grids</A>
<B> Up:</B> <A
 HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A
 HREF="node3.html">2 Command Line Tools</A>
 &nbsp; <B>  <A ID="tex2html942"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
