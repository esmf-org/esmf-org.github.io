<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>3 Superstructure</TITLE>
<META NAME="description" CONTENT="3 Superstructure">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html1931"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1927"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1921"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1929"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1932"
  HREF="node5.html">4 Infrastructure: Fields and</A>
<B> Up:</B> <A NAME="tex2html1928"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1922"
  HREF="node3.html">2 Command Line Tools</A>
 &nbsp; <B>  <A NAME="tex2html1930"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><A NAME="tex2html1933"
  HREF="node4.html#SECTION04010000000000000000"><SPAN CLASS="arabic">15</SPAN> Overview of Superstructure</A>
<UL>
<LI><A NAME="tex2html1934"
  HREF="node4.html#SECTION04011000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Superstructure Classes</A>
<LI><A NAME="tex2html1935"
  HREF="node4.html#SECTION04012000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">2</SPAN> Hierarchical Creation of Components</A>
<LI><A NAME="tex2html1936"
  HREF="node4.html#SECTION04013000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sequential and Concurrent Execution of Components</A>
<LI><A NAME="tex2html1937"
  HREF="node4.html#SECTION04014000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">4</SPAN> Intra-Component Communication</A>
<LI><A NAME="tex2html1938"
  HREF="node4.html#SECTION04015000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">5</SPAN> Data Distribution and Scoping in Components</A>
<LI><A NAME="tex2html1939"
  HREF="node4.html#SECTION04016000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">6</SPAN> Performance</A>
<LI><A NAME="tex2html1940"
  HREF="node4.html#SECTION04017000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">7</SPAN> Object Model</A>
</UL>
<LI><A NAME="tex2html1941"
  HREF="node4.html#SECTION04020000000000000000"><SPAN CLASS="arabic">16</SPAN> Application Driver and Required ESMF Methods</A>
<UL>
<LI><A NAME="tex2html1942"
  HREF="node4.html#SECTION04021000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html1943"
  HREF="node4.html#SECTION04022000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html1944"
  HREF="node4.html#SECTION04022100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_END</A>
</UL>
<LI><A NAME="tex2html1945"
  HREF="node4.html#SECTION04023000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A NAME="tex2html1946"
  HREF="node4.html#SECTION04024000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Required ESMF Methods</A>
<UL>
<LI><A NAME="tex2html1947"
  HREF="node4.html#SECTION04024100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_Initialize</A>
<LI><A NAME="tex2html1948"
  HREF="node4.html#SECTION04024200000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_InitializePreMPI</A>
<LI><A NAME="tex2html1949"
  HREF="node4.html#SECTION04024300000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_IsInitialized</A>
<LI><A NAME="tex2html1950"
  HREF="node4.html#SECTION04024400000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_IsFinalized</A>
<LI><A NAME="tex2html1951"
  HREF="node4.html#SECTION04024500000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_Finalize</A>
<LI><A NAME="tex2html1952"
  HREF="node4.html#SECTION04024600000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> User-code <TT>SetServices</TT> method</A>
<LI><A NAME="tex2html1953"
  HREF="node4.html#SECTION04024700000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> User-code <TT>Initialize</TT>, <TT>Run</TT>, and <TT>Finalize</TT> methods</A>
<LI><A NAME="tex2html1954"
  HREF="node4.html#SECTION04024800000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> User-code <TT>SetVM</TT> method</A>
<LI><A NAME="tex2html1955"
  HREF="node4.html#SECTION04024900000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> Use of <TT>internal procedures</TT> as user-provided procedures</A>
</UL>
</UL>
<LI><A NAME="tex2html1956"
  HREF="node4.html#SECTION04030000000000000000"><SPAN CLASS="arabic">17</SPAN> GridComp Class</A>
<UL>
<LI><A NAME="tex2html1957"
  HREF="node4.html#SECTION04031000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html1958"
  HREF="node4.html#SECTION04032000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html1959"
  HREF="node4.html#SECTION04032100000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Implement a user-code <TT>SetServices</TT> routine</A>
<LI><A NAME="tex2html1960"
  HREF="node4.html#SECTION04032200000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Implement a user-code <TT>Initialize</TT> routine</A>
<LI><A NAME="tex2html1961"
  HREF="node4.html#SECTION04032300000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Implement a user-code <TT>Run</TT> routine</A>
<LI><A NAME="tex2html1962"
  HREF="node4.html#SECTION04032400000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Implement a user-code <TT>Finalize</TT> routine</A>
<LI><A NAME="tex2html1963"
  HREF="node4.html#SECTION04032500000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Implement a user-code <TT>SetVM</TT> routine</A>
<LI><A NAME="tex2html1964"
  HREF="node4.html#SECTION04032600000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Set and Get the Internal State</A>
</UL>
<LI><A NAME="tex2html1965"
  HREF="node4.html#SECTION04033000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html1966"
  HREF="node4.html#SECTION04034000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html1967"
  HREF="node4.html#SECTION04034100000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GridCompAssignment(=)</A>
<LI><A NAME="tex2html1968"
  HREF="node4.html#SECTION04034200000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GridCompOperator(==)</A>
<LI><A NAME="tex2html1969"
  HREF="node4.html#SECTION04034300000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GridCompOperator(/=)</A>
<LI><A NAME="tex2html1970"
  HREF="node4.html#SECTION04034400000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GridCompCreate</A>
<LI><A NAME="tex2html1971"
  HREF="node4.html#SECTION04034500000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_GridCompDestroy</A>
<LI><A NAME="tex2html1972"
  HREF="node4.html#SECTION04034600000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_GridCompFinalize</A>
<LI><A NAME="tex2html1973"
  HREF="node4.html#SECTION04034700000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_GridCompGet</A>
<LI><A NAME="tex2html1974"
  HREF="node4.html#SECTION04034800000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_GridCompGetInternalState</A>
<LI><A NAME="tex2html1975"
  HREF="node4.html#SECTION04034900000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_GridCompInitialize</A>
<LI><A NAME="tex2html1976"
  HREF="node4.html#SECTION040341000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_GridCompIsCreated</A>
<LI><A NAME="tex2html1977"
  HREF="node4.html#SECTION040341100000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_GridCompIsPetLocal</A>
<LI><A NAME="tex2html1978"
  HREF="node4.html#SECTION040341200000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_GridCompPrint</A>
<LI><A NAME="tex2html1979"
  HREF="node4.html#SECTION040341300000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_GridCompReadRestart</A>
<LI><A NAME="tex2html1980"
  HREF="node4.html#SECTION040341400000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_GridCompRun</A>
<LI><A NAME="tex2html1981"
  HREF="node4.html#SECTION040341500000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_GridCompServiceLoop</A>
<LI><A NAME="tex2html1982"
  HREF="node4.html#SECTION040341600000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_GridCompSet</A>
<LI><A NAME="tex2html1983"
  HREF="node4.html#SECTION040341700000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_GridCompSetEntryPoint</A>
<LI><A NAME="tex2html1984"
  HREF="node4.html#SECTION040341800000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_GridCompSetInternalState</A>
<LI><A NAME="tex2html1985"
  HREF="node4.html#SECTION040341900000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_GridCompSetServices</A>
<LI><A NAME="tex2html1986"
  HREF="node4.html#SECTION040342000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_GridCompSetServices</A>
<LI><A NAME="tex2html1987"
  HREF="node4.html#SECTION040342100000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_GridCompSetServices</A>
<LI><A NAME="tex2html1988"
  HREF="node4.html#SECTION040342200000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_GridCompSetServices</A>
<LI><A NAME="tex2html1989"
  HREF="node4.html#SECTION040342300000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_GridCompSetVM</A>
<LI><A NAME="tex2html1990"
  HREF="node4.html#SECTION040342400000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_GridCompSetVM</A>
<LI><A NAME="tex2html1991"
  HREF="node4.html#SECTION040342500000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_GridCompSetVMMaxPEs</A>
<LI><A NAME="tex2html1992"
  HREF="node4.html#SECTION040342600000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_GridCompSetVMMaxThreads</A>
<LI><A NAME="tex2html1993"
  HREF="node4.html#SECTION040342700000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_GridCompSetVMMinThreads</A>
<LI><A NAME="tex2html1994"
  HREF="node4.html#SECTION040342800000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_GridCompValidate</A>
<LI><A NAME="tex2html1995"
  HREF="node4.html#SECTION040342900000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_GridCompWait</A>
<LI><A NAME="tex2html1996"
  HREF="node4.html#SECTION040343000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_GridCompWriteRestart</A>
</UL>
</UL>
<LI><A NAME="tex2html1997"
  HREF="node4.html#SECTION04040000000000000000"><SPAN CLASS="arabic">18</SPAN> CplComp Class</A>
<UL>
<LI><A NAME="tex2html1998"
  HREF="node4.html#SECTION04041000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html1999"
  HREF="node4.html#SECTION04042000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2000"
  HREF="node4.html#SECTION04042100000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Implement a user-code <TT>SetServices</TT> routine</A>
<LI><A NAME="tex2html2001"
  HREF="node4.html#SECTION04042200000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Implement a user-code <TT>Initialize</TT> routine</A>
<LI><A NAME="tex2html2002"
  HREF="node4.html#SECTION04042300000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Implement a user-code <TT>Run</TT> routine</A>
<LI><A NAME="tex2html2003"
  HREF="node4.html#SECTION04042400000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Implement a user-code <TT>Finalize</TT> routine</A>
<LI><A NAME="tex2html2004"
  HREF="node4.html#SECTION04042500000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Implement a user-code <TT>SetVM</TT> routine</A>
</UL>
<LI><A NAME="tex2html2005"
  HREF="node4.html#SECTION04043000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2006"
  HREF="node4.html#SECTION04044000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2007"
  HREF="node4.html#SECTION04044100000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_CplCompAssignment(=)</A>
<LI><A NAME="tex2html2008"
  HREF="node4.html#SECTION04044200000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_CplCompOperator(==)</A>
<LI><A NAME="tex2html2009"
  HREF="node4.html#SECTION04044300000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_CplCompOperator(/=)</A>
<LI><A NAME="tex2html2010"
  HREF="node4.html#SECTION04044400000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_CplCompCreate</A>
<LI><A NAME="tex2html2011"
  HREF="node4.html#SECTION04044500000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_CplCompDestroy</A>
<LI><A NAME="tex2html2012"
  HREF="node4.html#SECTION04044600000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_CplCompFinalize</A>
<LI><A NAME="tex2html2013"
  HREF="node4.html#SECTION04044700000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_CplCompGet</A>
<LI><A NAME="tex2html2014"
  HREF="node4.html#SECTION04044800000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_CplCompGetInternalState</A>
<LI><A NAME="tex2html2015"
  HREF="node4.html#SECTION04044900000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_CplCompInitialize</A>
<LI><A NAME="tex2html2016"
  HREF="node4.html#SECTION040441000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_CplCompIsCreated</A>
<LI><A NAME="tex2html2017"
  HREF="node4.html#SECTION040441100000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_CplCompIsPetLocal</A>
<LI><A NAME="tex2html2018"
  HREF="node4.html#SECTION040441200000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_CplCompPrint</A>
<LI><A NAME="tex2html2019"
  HREF="node4.html#SECTION040441300000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_CplCompReadRestart</A>
<LI><A NAME="tex2html2020"
  HREF="node4.html#SECTION040441400000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_CplCompRun</A>
<LI><A NAME="tex2html2021"
  HREF="node4.html#SECTION040441500000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_CplCompServiceLoop</A>
<LI><A NAME="tex2html2022"
  HREF="node4.html#SECTION040441600000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_CplCompSet</A>
<LI><A NAME="tex2html2023"
  HREF="node4.html#SECTION040441700000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_CplCompSetEntryPoint</A>
<LI><A NAME="tex2html2024"
  HREF="node4.html#SECTION040441800000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_CplCompSetInternalState</A>
<LI><A NAME="tex2html2025"
  HREF="node4.html#SECTION040441900000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_CplCompSetServices</A>
<LI><A NAME="tex2html2026"
  HREF="node4.html#SECTION040442000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_CplCompSetServices</A>
<LI><A NAME="tex2html2027"
  HREF="node4.html#SECTION040442100000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_CplCompSetServices</A>
<LI><A NAME="tex2html2028"
  HREF="node4.html#SECTION040442200000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_CplCompSetServices</A>
<LI><A NAME="tex2html2029"
  HREF="node4.html#SECTION040442300000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_CplCompSetVM</A>
<LI><A NAME="tex2html2030"
  HREF="node4.html#SECTION040442400000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_CplCompSetVM</A>
<LI><A NAME="tex2html2031"
  HREF="node4.html#SECTION040442500000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_CplCompSetVMMaxPEs</A>
<LI><A NAME="tex2html2032"
  HREF="node4.html#SECTION040442600000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_CplCompSetVMMaxThreads</A>
<LI><A NAME="tex2html2033"
  HREF="node4.html#SECTION040442700000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_CplCompSetVMMinThreads</A>
<LI><A NAME="tex2html2034"
  HREF="node4.html#SECTION040442800000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_CplCompValidate</A>
<LI><A NAME="tex2html2035"
  HREF="node4.html#SECTION040442900000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_CplCompWait</A>
<LI><A NAME="tex2html2036"
  HREF="node4.html#SECTION040443000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_CplCompWriteRestart</A>
</UL>
</UL>
<LI><A NAME="tex2html2037"
  HREF="node4.html#SECTION04050000000000000000"><SPAN CLASS="arabic">19</SPAN> SciComp Class</A>
<UL>
<LI><A NAME="tex2html2038"
  HREF="node4.html#SECTION04051000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2039"
  HREF="node4.html#SECTION04052000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2040"
  HREF="node4.html#SECTION04052100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Use ESMF_SciComp and Attach Attributes</A>
</UL>
<LI><A NAME="tex2html2041"
  HREF="node4.html#SECTION04053000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2042"
  HREF="node4.html#SECTION04054000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2043"
  HREF="node4.html#SECTION04054100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_SciCompAssignment(=)</A>
<LI><A NAME="tex2html2044"
  HREF="node4.html#SECTION04054200000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_SciCompOperator(==)</A>
<LI><A NAME="tex2html2045"
  HREF="node4.html#SECTION04054300000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_SciCompOperator(/=)</A>
<LI><A NAME="tex2html2046"
  HREF="node4.html#SECTION04054400000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_SciCompCreate</A>
<LI><A NAME="tex2html2047"
  HREF="node4.html#SECTION04054500000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_SciCompDestroy</A>
<LI><A NAME="tex2html2048"
  HREF="node4.html#SECTION04054600000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_SciCompGet</A>
<LI><A NAME="tex2html2049"
  HREF="node4.html#SECTION04054700000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_SciCompIsCreated</A>
<LI><A NAME="tex2html2050"
  HREF="node4.html#SECTION04054800000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_SciCompPrint</A>
<LI><A NAME="tex2html2051"
  HREF="node4.html#SECTION04054900000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_SciCompSet</A>
<LI><A NAME="tex2html2052"
  HREF="node4.html#SECTION040541000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_SciCompValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2053"
  HREF="node4.html#SECTION04060000000000000000"><SPAN CLASS="arabic">20</SPAN> Fault-tolerant Component Tunnel</A>
<UL>
<LI><A NAME="tex2html2054"
  HREF="node4.html#SECTION04061000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2055"
  HREF="node4.html#SECTION04062000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2056"
  HREF="node4.html#SECTION04062100000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating an <EM>actual</EM> Component</A>
<LI><A NAME="tex2html2057"
  HREF="node4.html#SECTION04062200000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Creating a <EM>dual</EM> Component</A>
<LI><A NAME="tex2html2058"
  HREF="node4.html#SECTION04062300000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Setting up the <EM>actual</EM> side of a Component Tunnel</A>
<LI><A NAME="tex2html2059"
  HREF="node4.html#SECTION04062400000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Setting up the <EM>dual</EM> side of a Component Tunnel</A>
<LI><A NAME="tex2html2060"
  HREF="node4.html#SECTION04062500000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Invoking standard Component methods through a Component Tunnel</A>
<LI><A NAME="tex2html2061"
  HREF="node4.html#SECTION04062600000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> The non-blocking option to invoke standard Component methods through a Component Tunnel</A>
<LI><A NAME="tex2html2062"
  HREF="node4.html#SECTION04062700000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Destroying a connected <EM>dual</EM> Component</A>
<LI><A NAME="tex2html2063"
  HREF="node4.html#SECTION04062800000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Destroying a connected <EM>actual</EM> Component</A>
</UL>
<LI><A NAME="tex2html2064"
  HREF="node4.html#SECTION04063000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</UL>
<LI><A NAME="tex2html2065"
  HREF="node4.html#SECTION04070000000000000000"><SPAN CLASS="arabic">21</SPAN> State Class</A>
<UL>
<LI><A NAME="tex2html2066"
  HREF="node4.html#SECTION04071000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2067"
  HREF="node4.html#SECTION04072000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html2068"
  HREF="node4.html#SECTION04072100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_STATEINTENT</A>
<LI><A NAME="tex2html2069"
  HREF="node4.html#SECTION04072200000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_STATEITEM</A>
</UL>
<LI><A NAME="tex2html2070"
  HREF="node4.html#SECTION04073000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2071"
  HREF="node4.html#SECTION04073100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> State create and destroy</A>
<LI><A NAME="tex2html2072"
  HREF="node4.html#SECTION04073200000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Add items to a State</A>
<LI><A NAME="tex2html2073"
  HREF="node4.html#SECTION04073300000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Add placeholders to a State</A>
<LI><A NAME="tex2html2074"
  HREF="node4.html#SECTION04073400000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Mark an item <TT>NEEDED</TT></A>
<LI><A NAME="tex2html2075"
  HREF="node4.html#SECTION04073500000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Create a <TT>NEEDED</TT> item</A>
<LI><A NAME="tex2html2076"
  HREF="node4.html#SECTION04073600000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> <TT>ESMF_StateReconcile()</TT> usage</A>
<LI><A NAME="tex2html2077"
  HREF="node4.html#SECTION04073700000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Read Arrays from a NetCDF file and add to a State</A>
<LI><A NAME="tex2html2078"
  HREF="node4.html#SECTION04073800000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Print Array data from a State</A>
<LI><A NAME="tex2html2079"
  HREF="node4.html#SECTION04073900000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Write Array data within a State to a NetCDF file</A>
</UL>
<LI><A NAME="tex2html2080"
  HREF="node4.html#SECTION04074000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2081"
  HREF="node4.html#SECTION04075000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2082"
  HREF="node4.html#SECTION04076000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
<LI><A NAME="tex2html2083"
  HREF="node4.html#SECTION04077000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2084"
  HREF="node4.html#SECTION04077100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_StateAssignment(=)</A>
<LI><A NAME="tex2html2085"
  HREF="node4.html#SECTION04077200000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_StateOperator(==)</A>
<LI><A NAME="tex2html2086"
  HREF="node4.html#SECTION04077300000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_StateOperator(/=)</A>
<LI><A NAME="tex2html2087"
  HREF="node4.html#SECTION04077400000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_StateAdd</A>
<LI><A NAME="tex2html2088"
  HREF="node4.html#SECTION04077500000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_StateAddReplace</A>
<LI><A NAME="tex2html2089"
  HREF="node4.html#SECTION04077600000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_StateCreate</A>
<LI><A NAME="tex2html2090"
  HREF="node4.html#SECTION04077700000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_StateDestroy</A>
<LI><A NAME="tex2html2091"
  HREF="node4.html#SECTION04077800000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_StateGet</A>
<LI><A NAME="tex2html2092"
  HREF="node4.html#SECTION04077900000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_StateGet</A>
<LI><A NAME="tex2html2093"
  HREF="node4.html#SECTION040771000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_StateGet</A>
<LI><A NAME="tex2html2094"
  HREF="node4.html#SECTION040771100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_StateIsCreated</A>
<LI><A NAME="tex2html2095"
  HREF="node4.html#SECTION040771200000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_StatePrint</A>
<LI><A NAME="tex2html2096"
  HREF="node4.html#SECTION040771300000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_StateRead</A>
<LI><A NAME="tex2html2097"
  HREF="node4.html#SECTION040771400000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_StateReconcile</A>
<LI><A NAME="tex2html2098"
  HREF="node4.html#SECTION040771500000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_StateRemove</A>
<LI><A NAME="tex2html2099"
  HREF="node4.html#SECTION040771600000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_StateRemove</A>
<LI><A NAME="tex2html2100"
  HREF="node4.html#SECTION040771700000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_StateReplace</A>
<LI><A NAME="tex2html2101"
  HREF="node4.html#SECTION040771800000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_StateSet</A>
<LI><A NAME="tex2html2102"
  HREF="node4.html#SECTION040771900000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_StateValidate</A>
<LI><A NAME="tex2html2103"
  HREF="node4.html#SECTION040772000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_StateWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html2104"
  HREF="node4.html#SECTION04080000000000000000"><SPAN CLASS="arabic">22</SPAN> Attachable Methods</A>
<UL>
<LI><A NAME="tex2html2105"
  HREF="node4.html#SECTION04081000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2106"
  HREF="node4.html#SECTION04082000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2107"
  HREF="node4.html#SECTION04082100000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Producer Component attaches user defined method</A>
<LI><A NAME="tex2html2108"
  HREF="node4.html#SECTION04082200000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Producer Component implements user defined method</A>
<LI><A NAME="tex2html2109"
  HREF="node4.html#SECTION04082300000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Consumer Component executes user defined method</A>
</UL>
<LI><A NAME="tex2html2110"
  HREF="node4.html#SECTION04083000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2111"
  HREF="node4.html#SECTION04084000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2112"
  HREF="node4.html#SECTION04084100000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_MethodAdd</A>
<LI><A NAME="tex2html2113"
  HREF="node4.html#SECTION04084200000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_MethodAdd</A>
<LI><A NAME="tex2html2114"
  HREF="node4.html#SECTION04084300000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_MethodAdd</A>
<LI><A NAME="tex2html2115"
  HREF="node4.html#SECTION04084400000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_MethodAdd</A>
<LI><A NAME="tex2html2116"
  HREF="node4.html#SECTION04084500000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_MethodAdd</A>
<LI><A NAME="tex2html2117"
  HREF="node4.html#SECTION04084600000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_MethodAdd</A>
<LI><A NAME="tex2html2118"
  HREF="node4.html#SECTION04084700000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_MethodAddReplace</A>
<LI><A NAME="tex2html2119"
  HREF="node4.html#SECTION04084800000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_MethodAddReplace</A>
<LI><A NAME="tex2html2120"
  HREF="node4.html#SECTION04084900000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_MethodAddReplace</A>
<LI><A NAME="tex2html2121"
  HREF="node4.html#SECTION040841000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_MethodAddReplace</A>
<LI><A NAME="tex2html2122"
  HREF="node4.html#SECTION040841100000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_MethodAddReplace</A>
<LI><A NAME="tex2html2123"
  HREF="node4.html#SECTION040841200000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_MethodAddReplace</A>
<LI><A NAME="tex2html2124"
  HREF="node4.html#SECTION040841300000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_MethodExecute</A>
<LI><A NAME="tex2html2125"
  HREF="node4.html#SECTION040841400000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_MethodExecute</A>
<LI><A NAME="tex2html2126"
  HREF="node4.html#SECTION040841500000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_MethodExecute</A>
<LI><A NAME="tex2html2127"
  HREF="node4.html#SECTION040841600000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_MethodGet</A>
<LI><A NAME="tex2html2128"
  HREF="node4.html#SECTION040841700000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_MethodGet</A>
<LI><A NAME="tex2html2129"
  HREF="node4.html#SECTION040841800000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_MethodGet</A>
<LI><A NAME="tex2html2130"
  HREF="node4.html#SECTION040841900000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_MethodGet</A>
<LI><A NAME="tex2html2131"
  HREF="node4.html#SECTION040842000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_MethodGet</A>
<LI><A NAME="tex2html2132"
  HREF="node4.html#SECTION040842100000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_MethodGet</A>
<LI><A NAME="tex2html2133"
  HREF="node4.html#SECTION040842200000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_MethodRemove</A>
<LI><A NAME="tex2html2134"
  HREF="node4.html#SECTION040842300000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_MethodRemove</A>
<LI><A NAME="tex2html2135"
  HREF="node4.html#SECTION040842400000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_MethodRemove</A>
</UL>
</UL>
<LI><A NAME="tex2html2136"
  HREF="node4.html#SECTION04090000000000000000"><SPAN CLASS="arabic">23</SPAN> Web Services</A>
<UL>
<LI><A NAME="tex2html2137"
  HREF="node4.html#SECTION04091000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A NAME="tex2html2138"
  HREF="node4.html#SECTION04091100000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating a Service around a Component</A>
<LI><A NAME="tex2html2139"
  HREF="node4.html#SECTION04091200000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Code Modifications</A>
<LI><A NAME="tex2html2140"
  HREF="node4.html#SECTION04091300000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Accessing the Service</A>
<LI><A NAME="tex2html2141"
  HREF="node4.html#SECTION04091400000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Client Application via C++ API</A>
<LI><A NAME="tex2html2142"
  HREF="node4.html#SECTION04091500000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Process Controller</A>
<LI><A NAME="tex2html2143"
  HREF="node4.html#SECTION04091600000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Tomcat/Axis2</A>
</UL>
<LI><A NAME="tex2html2144"
  HREF="node4.html#SECTION04092000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2145"
  HREF="node4.html#SECTION04092100000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Making a Component available through ESMF Web Services</A>
</UL>
<LI><A NAME="tex2html2146"
  HREF="node4.html#SECTION04093000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2147"
  HREF="node4.html#SECTION04094000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2148"
  HREF="node4.html#SECTION04094100000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_WebServicesLoop</A>
<LI><A NAME="tex2html2149"
  HREF="node4.html#SECTION04094200000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_WebServicesCplCompLoop</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04000000000000000000"></A>
<A NAME="part:Superstructure"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN> Superstructure
</H1>


<P>

<H1><A NAME="SECTION04010000000000000000">
<SPAN CLASS="arabic">15</SPAN> Overview of Superstructure</A>
</H1>

<P>
ESMF superstructure classes define an architecture for assembling
Earth system applications from modeling <B>components</B>.  A component
may be defined in terms of the physical domain that it represents,
such as an atmosphere or sea ice model.  It may also be defined in terms
of a computational function, such as a data assimilation system.
Earth system research often requires that such components be <B>coupled</B> 
together to create an application.  By coupling we mean the data 
transformations and, on parallel computing systems, data transfers, 
that are necessary to allow data from one component to be utilized by 
another.  ESMF offers regridding methods and other tools to simplify 
the organization and execution of inter-component data exchanges.  

<P>
In addition to components defined at the level of major physical 
domains and computational functions, components may be defined that 
represent smaller computational functions within larger components, 
such as the transformation of data between the physics and dynamics 
in a spectral atmosphere model, 
or the creation of nested higher resolution regions 
within a coarser grid.  The objective is to couple components at varying 
scales both flexibly and efficiently.  ESMF encourages a hierarchical
application structure, in which large components branch into 
smaller sub-components (see Figure <A HREF="#fig:GEOS5">2</A>).  ESMF also makes 
it easier for the same component to be used in multiple contexts 
without changes to its source code.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Modular, component-based architecture.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchical assembly of components into applications.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Use of components in multiple contexts without modification.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Sequential or concurrent component execution.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Single program, multiple datastream (SPMD) applications for 
maximum portability and reconfigurability.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multiple program, multiple datastream (MPMD) option for 
flexibility.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION04011000000000000000">
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Superstructure Classes</A>
</H2>

<P>
There are a small number of classes in the ESMF superstructure:

<P>

<UL>
<LI><B>Component</B>  An ESMF component has two parts, one that is 
supplied by ESMF and one that is supplied by the user.  The
part that is supplied by the framework is an ESMF derived type that
is either a Gridded Component (<B>GridComp</B>) or a Coupler 
Component (<B>CplComp</B>).  A Gridded Component typically represents
a physical domain in which data is associated with one or more 
grids - for example, a sea ice model.  A Coupler Component 
arranges and executes data transformations and transfers between
one or more Gridded Components. Gridded Components and Coupler 
Components have standard methods, which include initialize, run,
and finalize.  These methods can be multi-phase.

<P>
The second part of an ESMF Component is user code, such as a
model or data assimilation system.  Users set entry points 
within their code so that it is callable by the framework.  
In practice, setting entry points means that within user code 
there are calls to ESMF methods that associate the name of a 
Fortran subroutine with a corresponding standard ESMF operation.  
For example, a user-written initialization routine called 
<TT>myOceanInit</TT> might be associated with the standard 
initialize routine of an ESMF Gridded Component named &ldquo;myOcean&rdquo; 
that represents an ocean model.

<P>
</LI>
<LI><B>State</B>  ESMF Components exchange information with other 
Components only through States.  A State is an ESMF derived
type that can contain Fields, FieldBundles, Arrays, ArrayBundles,
and other States.  A Component is associated with two States, an 
<B>Import State</B> and an <B>Export State</B>.  Its Import State 
holds the data that it receives from other Components.  
Its Export State contains data that it makes available to 
other Components. 

<P>
</LI>
</UL>

<P>
An ESMF coupled application typically involves a parent Gridded Component, 
two or more child Gridded Components and one or more Coupler 
Components. 

<P>
The parent Gridded Component is responsible for creating the child 
Gridded Components that are exchanging data, for creating the Coupler, 
for creating the necessary Import and Export States, and for 
setting up the desired sequencing.  The application's &ldquo;main&rdquo; routine
calls the parent Gridded Component's initialize, run, and finalize 
methods in order to execute the application.  For each of these
standard methods, the parent Gridded Component in turn calls the 
corresponding methods in the child Gridded Components and the 
Coupler Component.  For example, consider a simple coupled 
ocean/atmosphere simulation.  When the initialize method of the 
parent Gridded Component is called by the application, it in turn 
calls the initialize methods of its child atmosphere and ocean 
Gridded Components, and the initialize method of an 
ocean-to-atmosphere Coupler Component.  Figure <A HREF="#fig:appunit">3</A>
shows this schematically.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:GEOS5"></A><A NAME="2949"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
ESMF enables applications such as the atmospheric general
circulation model GEOS-5 to be structured hierarchically, and 
reconfigured and extended easily.  Each box in this diagram is an
ESMF Gridded Component.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{ESMF_GEOS5}}$
 -->
<IMG
 WIDTH="708" HEIGHT="395" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="\scalebox{0.9}{\includegraphics{ESMF_GEOS5}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION04012000000000000000"></A>
<A NAME="sec:hierarchy"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">2</SPAN> Hierarchical Creation of Components
</H2>

<P>
Components are allocated computational resources in the form of
<B>Persistent Execution Threads</B>, or <B>PET</B>s.  A list of a Component's
PETs is contained in a structure called a <B>Virtual Machine</B>,
or <B>VM</B>.  The VM also contains information about the topology and
characteristics of the underlying computer.
Components are created hierarchically, with parent Components creating
child Components and allocating some or all of their PETs to each one.
By default ESMF creates a new VM for each child Component, which 
allows Components to tailor their VM resources to match their needs.
In some cases, a child may want to share its parent's VM - ESMF
supports this, too.

<P>
A Gridded Component may exist across all the PETs in an application. 
A Gridded Component may also reside on a subset of PETs in an
application.  These PETs may wholly coincide with, be wholly contained
within, or wholly contain another Component.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:appunit"></A><A NAME="2963"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
A call to a standard ESMF initialize (run, finalize) method
by a parent component triggers calls to initialize (run, finalize)
all of its child components.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_appunit}}$
 -->
<IMG
 WIDTH="723" HEIGHT="498" ALIGN="BOTTOM" BORDER="0"
 SRC="img13.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_appunit}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION04013000000000000000"></A>
<A NAME="sec:concurrency"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sequential and Concurrent Execution of Components
</H2>

<P>
When a set of Gridded Components and a Coupler runs in sequence
on the same set of PETs the application is executing in a <B>sequential</B>
mode. When Gridded Components are created and run on mutually exclusive
sets of PETs, and are coupled by a Coupler Component that extends over
the union of these sets, the mode of execution is <B>concurrent</B>.

<P>
Figure <A HREF="#fig:serial">4</A> illustrates a typical configuration for 
a simple coupled sequential
application, and Figure <A HREF="#fig:concurrent">5</A> shows a possible 
configuration for the same application running in a concurrent mode.

<P>
Parent Components can select if and when to wait for concurrently
executing child Components, synchronizing only when required.

<P>
It is possible for ESMF applications to contain some Component sets
that are executing sequentially and others that are executing concurrently.
We might have, for example, atmosphere and land Components created
on the same subset of PETs, ocean and sea ice Components created on
the remainder of PETs, and a Coupler created across all the PETs in
the application.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:serial"></A><A NAME="2977"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
Schematic of the run method of a coupled application, with an
&ldquo;Atmosphere&rdquo; and an &ldquo;Ocean&rdquo; Gridded Component running sequentially with 
an &ldquo;Atm-Ocean Coupler.&rdquo;  The top-level &ldquo;Hurricane Model&rdquo; 
Gridded Component contains the sequencing information and time 
advancement loop.  The application driver, Coupler, and all Gridded Components 
are distributed over nine PETs.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_serial}}$
 -->
<IMG
 WIDTH="587" HEIGHT="677" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_serial}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:concurrent"></A><A NAME="2985"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Schematic of the run method of a coupled application, with an
&ldquo;Atmosphere&rdquo; and an &ldquo;Ocean&rdquo; Gridded Component running concurrently with 
an &ldquo;Atm-Ocean Coupler.&rdquo;  The top-level &ldquo;Hurricane Model&rdquo; 
Gridded Component contains the sequencing information and time 
advancement loop.  The application driver, Coupler, and top-level &ldquo;Hurricane
Model&rdquo; Gridded Component are distributed over nine PETs.  The
&ldquo;Atmosphere&rdquo; Gridded Component is distributed over three PETs and
the &ldquo;Ocean&rdquo; Gridded Component is distributed over six PETs.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_concurrent}}$
 -->
<IMG
 WIDTH="587" HEIGHT="576" ALIGN="BOTTOM" BORDER="0"
 SRC="img15.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_concurrent}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION04014000000000000000"></A>
<A NAME="sec:localcomm"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">4</SPAN> Intra-Component Communication
</H2>

<P>
All data transfers within an ESMF application occur <I>within</I> a
component.  For example, a Gridded Component may contain halo updates.
Another example is that a Coupler Component may redistribute
data between two Gridded Components.  As a result,
the architecture of ESMF does not depend on any particular data
communication mechanism, and new communication schemes can be
introduced without affecting the overall structure of the application.

<P>
Since all data communication happens within a component, a Coupler
Component must be created on the union of the PETs of all
the Gridded Components that it couples.  

<P>

<H2><A NAME="SECTION04015000000000000000"></A>
<A NAME="sec:scoping"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">5</SPAN> Data Distribution and Scoping in Components
</H2>

<P>
The scope of distributed objects is the VM of the currently 
executing Component.  For this reason, all
PETs in the current VM must make the same distributed object
creation calls.   When a Coupler Component running on a superset
of a Gridded Component's PETs needs to make communication calls
involving objects created by the Gridded Component,
an ESMF-supplied function called <TT>ESMF_StateReconcile()</TT> creates proxy
objects for those PETs that had no previous information about the
distributed objects.  Proxy objects contain no local data but
can be used in communication calls (such as regrid or redistribute)
to describe the remote source for data being moved to the current PET,
or to describe the remote destination for data being moved from the local PET.
Figure <A HREF="#fig:reconcile">6</A> is a simple schematic that shows the 
sequence of events in a reconcile call.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:reconcile"></A><A NAME="3021"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 6:</STRONG>
An <TT>ESMF_StateReconcile()</TT> call creates proxy 
objects for use in subsequent communication calls.  The reconcile 
call would normally be made during Coupler initialization.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_reconcile}}$
 -->
<IMG
 WIDTH="585" HEIGHT="627" ALIGN="BOTTOM" BORDER="0"
 SRC="img16.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_reconcile}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION04016000000000000000"></A>
<A NAME="sec:performance"></A>
<BR>
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">6</SPAN> Performance
</H2>

<P>
The ESMF design enables the user to configure ESMF
applications so that data is transferred directly from one component 
to another, without requiring that it be copied or sent to a different data
buffer as an interim step.  This is likely to be the most efficient way 
of performing inter-component coupling.  However, if desired, an 
application can also be configured so that data from a source component 
is sent to a distinct set of Coupler Component PETs for processing 
before being sent to its destination.

<P>
The ability to overlap computation with communication is essential for
performance.  When running with ESMF the user can initiate data 
sends during Gridded Component execution, as soon as the data is ready.
Computations can then proceed simultaneously with the data transfer.

<P>

<H2><A NAME="SECTION04017000000000000000">
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">7</SPAN> Object Model</A>
</H2>

<P>
The following is a simplified Unified Modeling Language (UML) diagram showing the relationships among
ESMF superstructure classes.  See Appendix A, <I>A Brief Introduction 
to UML</I>, for a translation table that lists the symbols in the diagram 
and their meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="623" HEIGHT="191" ALIGN="BOTTOM" BORDER="0"
 SRC="img17.png"
 ALT="\includegraphics{Comp_obj}">   

</DIV>

<P>

<H1><A NAME="SECTION04020000000000000000">
<SPAN CLASS="arabic">16</SPAN> Application Driver and Required ESMF Methods</A>
</H1>

<H2><A NAME="SECTION04021000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
Every ESMF application needs a driver code. Typically the driver layer is
implemented as the "main" of the application, although this is not strictly an
ESMF requirement. For most ESMF applications the task of the application driver
will be very generic: Initialize ESMF, create a top-level Component and call its
Initialize, Run and Finalize methods, before destroying the top-level Component
again and calling ESMF Finalize.

<P>
ESMF provides a number of different application driver templates in the
<TT>$ESMF_DIR/src/Superstructure/AppDriver</TT> directory. An appropriate one 
can be chosen depending on how the application is to be structured:

<P>
<DL>
<DT><STRONG>Sequential vs. Concurrent Execution</STRONG></DT>
<DD><P>
In a sequential execution model, every Component executes
on all PETs, with each Component completing execution before
the next Component begins.  This has the appeal of 
simplicity of data consumption and production: when a Gridded 
Component starts, all required data is available for use, and when
a Gridded Component finishes, all data produced is ready for consumption
by the next Gridded Component.  This approach also has
the possibility of less data movement if the grid and
data decomposition is done such that each processor's memory contains
the data needed by the next Component.

<P>
In a concurrent execution model, subgroups of PETs run
Gridded Components and multiple Gridded Components are active at the 
same time.  Data exchange must be coordinated between Gridded 
Components so that data deadlock does not occur.  This strategy 
has the advantage of allowing coupling to other Gridded Components 
at any time during the computational process, including not 
having to return to the calling level of code before making 
data available.  

<P>
</DD>
<DT><STRONG>Pairwise vs. Hub and Spoke</STRONG></DT>
<DD><P>
Coupler Components are responsible for taking data from one
Gridded Component and putting it into the form expected by another 
Gridded Component.  This might include regridding, change of units, 
averaging, or binning.

<P>
Coupler Components can be written for <I>pairwise</I> data exchange: 
the Coupler Component takes data from a single Component and transforms 
it for use by another single Gridded Component.  This simplifies the 
structure of the Coupler Component code.

<P>
Couplers can also be written using a <I>hub and spoke</I> model where a
single Coupler accepts data from all other Components, can do data
merging or splitting, and formats data for all other Components.

<P>
Multiple Couplers, using either of the above two models or some mixture of
these approaches, are also possible.

<P>
</DD>
<DT><STRONG>Implementation Language</STRONG></DT>
<DD><P>
The ESMF framework currently has Fortran interfaces for all public functions. 
Some functions also have C interfaces, and the number of these is expected to 
increase over time. 

<P>
</DD>
<DT><STRONG>Number of Executables</STRONG></DT>
<DD><P>
The simplest way to run an application
is to run the same executable program on all PETs.  Different Components
can still be run on mutually exclusive PETs by using branching
(e.g., if this is PET 1, 2, or 3, run Component A, if it is
PET 4, 5, or 6 run Component B).  This is a <B>SPMD</B> model, 
Single Program Multiple Data.  

<P>
The alternative is to start a different executable program on different
PETs.  This is a <B>MPMD</B> model, Multiple Program Multiple Data.
There are complications with many job control systems on multiprocessor
machines in getting the different executables started, and getting
inter-process communications established.  ESMF currently has some
support for MPMD: different Components can run as separate executables,
but the Coupler that transfers data between the Components must still
run on the union of their PETs. This means that the Coupler Component
must be linked into all of the executables.

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION04022000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION04022100000000000000"></A>
<A NAME="const:endflag"></A>
<BR>
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_END
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
The <TT>ESMF_End_Flag</TT> determines how an ESMF application is shut down.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_End_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_END_ABORT</STRONG></DT>
<DD>Global abort of the ESMF application. There is no guarantee 
         that all PETs will shut down cleanly during an abort. However, all
         attempts are made to prevent the application from hanging and the
         LogErr of at least one PET will be completely flushed during the abort.
         This option should only be used if a condition is detected that
         prevents normal continuation or termination of the application.
         Typical conditions that warrant the use of <TT>ESMF_END_ABORT</TT> 
         are those that occur on a per PET basis where other PETs may be blocked
         in communication calls, unable to reach the normal termination point.
         An aborted application returns to the parent process with a system
         dependent indication that a failure occurred during execution.
   
</DD>
<DT><STRONG>ESMF_END_NORMAL</STRONG></DT>
<DD>Normal termination of the ESMF application. Wait for all PETs of the
         global VM to reach 
	<TT>ESMF_Finalize()</TT> before termination. This is
         the clean way of terminating an application. <TT>MPI_Finalize()</TT> will
         be called in case of MPI applications.

</DD>
<DT><STRONG>ESMF_END_KEEPMPI</STRONG></DT>
<DD>Same as <TT>ESMF_END_NORMAL</TT> but <TT>MPI_Finalize()</TT> will <EM>not</EM>
         be called. It is the user code's responsibility to shut down MPI
         cleanly if necessary.
</DD>
</DL>

<H2><A NAME="SECTION04023000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
ESMF encourages application organization in which there is a single 
top-level Gridded Component.  This provides a simple, clear sequence
of operations at the highest level, and also enables the entire 
application to be treated as a sub-Component of another, larger 
application if desired.  When a simple application is organized in this fashion 
the standard AppDriver can probably be used without much modification.  

<P>
Examples of program organization using the AppDriver can be found in the 
<TT>src/Superstructure/AppDriver</TT> directory.  A set of subdirectories 
within the AppDriver directory follows the naming convention:

<PRE>
&lt;seq|concur&gt;_&lt;pairwise|hub&gt;_&lt;f|c&gt;driver_&lt;spmd|mpmd&gt;
</PRE>

<P>
The example that is currently implemented is
<TT>seq_pairwise_fdriver_spmd</TT>, which
has sequential component execution, a pairwise coupler, a main program
in Fortran, and all processors launching the same executable.
It is also copied automatically into a top-level 
<TT>quick_start</TT> directory at compilation time.  

<P>
The user can copy the AppDriver files into
their own local directory. Some of the files can be used unchanged.
Others are template files which have the rough outline of the code but
need additional application-specific code added in order to perform a
meaningful function.  The <TT>README</TT> file in the AppDriver 
subdirectory or <TT>quick_start</TT> directory contains instructions about 
which files to change.

<P>
Examples of concurrent component execution can be found in the
system tests that are bundled with the ESMF distribution.

<P>

<P>

<P>

<P>
<PRE>
 
  ---------------------------------------------------------------------------
  ---------------------------------------------------------------------------
   EXAMPLE:  This is an AppDriver.F90 file for a sequential ESMF application.
  ---------------------------------------------------------------------------
  ---------------------------------------------------------------------------
  
    The ChangeMe.F90 file that's included below contains a number of
    definitions that are used by the AppDriver, such as the name of the
    application's main configuration file and the name of the application's
    SetServices routine.  This file is in the same directory as the
    AppDriver.F90 file.
  ---------------------------------------------------------------------------
 
 #include "ChangeMe.F90"
 
     program ESMF_AppDriver
 #define ESMF_METHOD "program ESMF_AppDriver"
 
 #include "ESMF.h"
 
     ! ESMF module, defines all ESMF data types and procedures
     use ESMF
 
     ! Gridded Component registration routines.  Defined in "ChangeMe.F90"
     use USER_APP_Mod, only : SetServices =&gt; USER_APP_SetServices
 
     implicit none
 
  ---------------------------------------------------------------------------
    Define local variables
  ---------------------------------------------------------------------------
 
     ! Components and States
     type(ESMF_GridComp) :: compGridded
     type(ESMF_State) :: defaultstate
 
     ! Configuration information
     type(ESMF_Config) :: config
 
     ! A common Grid
     type(ESMF_Grid) :: grid
 
     ! A Clock, a Calendar, and timesteps
     type(ESMF_Clock) :: clock
     type(ESMF_TimeInterval) :: timeStep
     type(ESMF_Time) :: startTime
     type(ESMF_Time) :: stopTime
 
     ! Variables related to the Grid
     integer :: i_max, j_max
 
     ! Return codes for error checks
     integer :: rc, localrc
 
  ---------------------------------------------------------------------------
    Initialize ESMF.  Note that an output Log is created by default.
  ---------------------------------------------------------------------------
 
     call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
     call ESMF_LogWrite("ESMF AppDriver start", ESMF_LOGMSG_INFO)
 
  ---------------------------------------------------------------------------
    Create and load a configuration file.
    The USER_CONFIG_FILE is set to sample.rc in the ChangeMe.F90 file.
    The sample.rc file is also included in the directory with the
    AppDriver.F90 file.
  ---------------------------------------------------------------------------
 
     config = ESMF_ConfigCreate(rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
     call ESMF_ConfigLoadFile(config, USER_CONFIG_FILE, rc = localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ---------------------------------------------------------------------------
    Get configuration information.
  
    A configuration file like sample.rc might include:
    - size and coordinate information needed to create the default Grid.
    - the default start time, stop time, and running intervals
      for the main time loop.
  ---------------------------------------------------------------------------
 
     call ESMF_ConfigGetAttribute(config, i_max, label='I Counts:', &amp;
       default=10, rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
     call ESMF_ConfigGetAttribute(config, j_max, label='J Counts:', &amp;
       default=40, rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ---------------------------------------------------------------------------
    Create the top Gridded Component.
  ---------------------------------------------------------------------------
 
     compGridded = ESMF_GridCompCreate(name="ESMF Gridded Component", &amp;
         rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
     call ESMF_LogWrite("Component Create finished", ESMF_LOGMSG_INFO)
 
  ----------------------------------------------------------------------------
    Register the set services method for the top Gridded Component.
  ----------------------------------------------------------------------------
 
     call ESMF_GridCompSetServices(compGridded, userRoutine=SetServices, rc=rc)
     if (ESMF_LogFoundError(rc, msg="Registration failed", rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Create and initialize a Clock.
  ----------------------------------------------------------------------------
 
       call ESMF_TimeIntervalSet(timeStep, s=2, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_TimeSet(startTime, yy=2004, mm=9, dd=25, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_TimeSet(stopTime, yy=2004, mm=9, dd=26, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       clock = ESMF_ClockCreate(timeStep, startTime, stopTime=stopTime, &amp;
                 name="Application Clock", rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Create and initialize a Grid.
  
    The default lower indices for the Grid are (/1,1/).
    The upper indices for the Grid are read in from the sample.rc file,
    where they are set to (/10,40/).  This means a Grid will be
    created with 10 grid cells in the x direction and 40 grid cells in the
    y direction.  The Grid section in the Reference Manual shows how to set
    coordinates.
  ----------------------------------------------------------------------------
 
       grid = ESMF_GridCreateNoPeriDim(maxIndex=(/i_max, j_max/), &amp;
                              name="source grid", rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       ! Attach the grid to the Component
       call ESMF_GridCompSet(compGridded, grid=grid, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Create and initialize a State to use for both import and export.
    In a real code, separate import and export States would normally be
    created.
  ----------------------------------------------------------------------------
 
       defaultstate = ESMF_StateCreate(name="Default State", rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Call the initialize, run, and finalize methods of the top component.
    When the initialize method of the top component is called, it will in
    turn call the initialize methods of all its child components, they
    will initialize their children, and so on.  The same is true of the
    run and finalize methods.
  ----------------------------------------------------------------------------
 
       call ESMF_GridCompInitialize(compGridded, importState=defaultstate, &amp;
         exportState=defaultstate, clock=clock, rc=localrc)
       if (ESMF_LogFoundError(rc, msg="Initialize failed", rcToReturn=rc)) &amp;
           call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_GridCompRun(compGridded, importState=defaultstate, &amp;
         exportState=defaultstate, clock=clock, rc=localrc)
       if (ESMF_LogFoundError(rc, msg="Run failed", rcToReturn=rc)) &amp;
           call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_GridCompFinalize(compGridded, importState=defaultstate, &amp;
         exportState=defaultstate, clock=clock, rc=localrc)
       if (ESMF_LogFoundError(rc, msg="Finalize failed", rcToReturn=rc)) &amp;
           call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
 
  ----------------------------------------------------------------------------
    Destroy objects.
  ----------------------------------------------------------------------------
 
       call ESMF_ClockDestroy(clock, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_StateDestroy(defaultstate, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_GridCompDestroy(compGridded, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Finalize and clean up.
  ----------------------------------------------------------------------------
 
     call ESMF_Finalize()
 
     end program ESMF_AppDriver
</PRE>


<H2><A NAME="SECTION04024000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Required ESMF Methods</A>
</H2>

<P>
There are a few methods that every ESMF application must contain. First,
<TT>ESMF_Initialize()</TT> and <TT>ESMF_Finalize()</TT> are in complete analogy 
to <TT>MPI_Init()</TT> and <TT>MPI_Finalize()</TT> known from MPI. All ESMF
programs, serial or parallel, must initialize the ESMF system at the beginning,
and finalize it at the end of execution. The behavior of calling any
ESMF method before <TT>ESMF_Initialize()</TT>, or after <TT>ESMF_Finalize()</TT>
is undefined.

<P>
Second, every ESMF Component that is accessed by an ESMF application requires
that its set services routine is called through
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>. The Component must implement
one public entry point, its set services routine, that can be called
through the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT> library routine. The
Component set services routine is responsible for setting entry points
for the standard ESMF Component methods Initialize, Run, and Finalize.

<P>
Finally, the Component can optionally call <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT>
<EM>before</EM> calling
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>. Similar to 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, the 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT>
call requires a public entry point into the Component. It allows the Component
to adjust certain aspects of its execution environment, i.e. its own VM, before
it is started up.

<P>
The following sections discuss the above mentioned aspects in more detail.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04024100000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_Initialize - Initialize ESMF</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_Initialize(configFilename, &amp;
         defaultCalKind, defaultDefaultLogFilename, defaultLogFilename, &amp;
         defaultLogAppendFlag, logAppendFlag, defaultLogKindFlag, logKindFlag, &amp;
         mpiCommunicator,  ioUnitLBound, ioUnitUBound, &amp;
         defaultGlobalResourceControl, globalResourceControl, config, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),        intent(in),  optional :: configFilename
       type(ESMF_CalKind_Flag), intent(in),  optional :: defaultCalKind
       character(len=*),        intent(in),  optional :: defaultDefaultLogFilename
       character(len=*),        intent(in),  optional :: defaultLogFilename
       logical,                 intent(in),  optional :: defaultLogAppendFlag
       logical,                 intent(in),  optional :: logAppendFlag
       type(ESMF_LogKind_Flag), intent(in),  optional :: defaultLogKindFlag
       type(ESMF_LogKind_Flag), intent(in),  optional :: logKindFlag
       integer,                 intent(in),  optional :: mpiCommunicator
       integer,                 intent(in),  optional :: ioUnitLBound
       integer,                 intent(in),  optional :: ioUnitUBound
       logical,                 intent(in),  optional :: defaultGlobalResourceControl
       logical,                 intent(in),  optional :: globalResourceControl
       type(ESMF_Config),       intent(out), optional :: config
       type(ESMF_VM),           intent(out), optional :: vm
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>logAppendFlag</TT> to allow specifying that the existing
                log files will be overwritten.
   
</DD>
<DT><STRONG>8.2.0</STRONG></DT>
<DD>Added argument <TT>globalResourceControl</TT> to support ESMF-aware
                threading and resource control on the global VM level.
<BR>
Added argument <TT>config</TT> to return default handle to the
                defaultConfig.
<BR>
Renamed argument <TT>defaultConfigFilename</TT> to
                <TT>configFilename</TT>, in order to clarify that provided settings
                in the Config file are <EM>not</EM> defaults, but final
                overrides.
<BR>
Introduce <TT>default</TT> prefixed arguments:
                <TT>defaultDefaultLogFilename</TT>,
                <TT>defaultLogAppendFlag</TT>, <TT>defaultLogKindFlag</TT>,
                <TT>defaultGlobalResourceControl</TT>. These arguments allow
                specification of defaults for the associated settings. This
                default can be overridden via the associated argument, without
                the extra <TT>default</TT> prefix, either specified in the call, or
                within the specified Config file.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method must be called once on each PET before
       any other ESMF methods are used.  The method contains a
       barrier before returning, ensuring that all processes
       made it successfully through initialization.

<P>
Typically <TT>ESMF_Initialize()</TT> will call <TT>MPI_Init()</TT> 
       internally unless MPI has been initialized by the user code before
       initializing the framework. If the MPI initialization is left to
       <TT>ESMF_Initialize()</TT> it inherits all of the MPI implementation 
       dependent limitations of what may or may not be done before 
       <TT>MPI_Init()</TT>. For instance, it is unsafe for some MPI
       implementations, such as MPICH1, to do I/O before the MPI environment
       is initialized. Please consult the documentation of your MPI
       implementation for details.

<P>
Note that when using MPICH1 as the MPI library, ESMF needs to use
       the application command line arguments for <TT>MPI_Init()</TT>. However,
       ESMF acquires these arguments internally and the user does not need
       to worry about providing them. Also, note that ESMF does not alter
       the command line arguments, so that if the user obtains them they will
       be as specified on the command line (including those which MPICH1 would
       normally strip out).

<P>
<TT>ESMF_Initialize()</TT> supports running ESMF inside a user MPI program.
       Details of this feature are discussed under the VM example 
       <A HREF="node6.html#vm_inside_user_mpi"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>. It is not necessary that all MPI ranks are
       handed to ESMF. Section <A HREF="node6.html#vm_nesting_esmf"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> shows how an MPI
       communicator can be used to execute ESMF on a subset of MPI ranks.
       <TT>ESMF_Initialize()</TT> supports running multiple concurrent
       instances of ESMF under the same user MPI program. This feature is
       discussed under <A HREF="node6.html#vm_multi_instance_esmf"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.

<P>
In order to use any of the advanced resource management functions that
       ESMF provides via the <TT>ESMF_*CompSetVM*()</TT> methods, the MPI
       environment must be thread-safe. <TT>ESMF_Initialize()</TT> handles this
       automatically if it is in charge of initializing MPI. However, if the
       user code initializes MPI before calling into <TT>ESMF_Initialize()</TT>,
       it must do so via <TT>MPI_Init_thread()</TT>, specifying
       <TT>MPI_THREAD_SERIALIZED</TT> or above for the required level of thread
       support.

<P>
In cases where <TT>ESMF_*CompSetVM*()</TT> methods are used to move
       processing elements (PEs), i.e. CPU cores, between persistent execution
       threads (PETs), ESMF uses POSIX signals between PETs. In order to do so
       safely, the proper signal handlers must be installed <EM>before</EM> MPI is
       initialized. <TT>ESMF_Initialize()</TT> handles this automatically if it is
       in charge of initializing MPI. If, however, MPI is explicitly initialized
       by user code, then to ensure correct signal handling it is necessary to
       call <TT>ESMF_InitializePreMPI()</TT> from the user code prior to the MPI
       initialization.

<P>
By default, <TT>ESMF_Initialize()</TT> will open multiple error log files,
       one per processor.  This is very useful for debugging purpose.  However,
       when running the application on a large number of processors, opening a
       large number of log files and writing log messages from all the processors
       could become a performance bottleneck.  Therefore, it is recommended
       to turn the Error Log feature off in these situations by setting
       <TT>logKindFlag</TT> to ESMF_LOGKIND_NONE.

<P>
When integrating ESMF with applications where Fortran unit number conflicts
       exist, the optional <TT>ioUnitLBound</TT> and <TT>ioUnitUBound</TT> arguments may be
       used to specify an alternate unit number range.  See section <A HREF="node6.html#fio:unitnumbers"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
       for more information on how ESMF uses Fortran unit numbers.

<P>
Before exiting the application the user must call <TT>ESMF_Finalize()</TT>
       to release resources and clean up ESMF gracefully. See the
       <TT>ESMF_Finalize()</TT> documentation about details relating to the MPI
       environment.

<P>
The arguments are:
       <DL>
<DT><STRONG>[configFilename]</STRONG></DT>
<DD>Name of the configuration file for the entire application.
             If this argument is specified, the configuration file must exist,
             and its content is read during <TT>ESMF_Initialize()</TT>.
             If any of the following labels are found in the specified
             configuration file, their values are used to set the associated
             <TT>ESMF_Initialize()</TT> argument, overriding any defaults.
             If the same argument is also specified in the
             <TT>ESMF_Initialize()</TT> call directly, an error is returned,
             and ESMF is not initialized.
             The supported config labels are:
             
<UL>
<LI><TT>defaultLogFilename:</TT>
</LI>
<LI><TT>logAppendFlag:</TT>
</LI>
<LI><TT>logKindFlag:</TT>
</LI>
<LI><TT>globalResourceControl:</TT>
             
</LI>
</UL>
       
</DD>
<DT><STRONG>[defaultCalKind]</STRONG></DT>
<DD>Sets the default calendar to be used by ESMF Time Manager.
             See section <A HREF="node6.html#const:calkindflag"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for a list of valid options.
             If not specified, defaults to <TT>ESMF_CALKIND_NOCALENDAR</TT>.
       
</DD>
<DT><STRONG>[defaultDefaultLogFilename]</STRONG></DT>
<DD>Default value for argument <TT>defaultLogFilename</TT>, the name of
             the default log file for warning and error messages.
             If not specified, the default is <TT>ESMF_LogFile</TT>.
       
</DD>
<DT><STRONG>[defaultLogFilename]</STRONG></DT>
<DD>Name of the default log file for warning and error messages.
             If not specified,
             defaults according to <TT>defaultDefaultLogFilename</TT>.
       
</DD>
<DT><STRONG>[defaultLogAppendFlag]</STRONG></DT>
<DD>Default value for argument <TT>logAppendFlag</TT>, indicating the
             overwrite behavior in case the default log file already exists.
             If not specified, the default is <TT>.true.</TT>.
       
</DD>
<DT><STRONG>[logAppendFlag]</STRONG></DT>
<DD>If the default log file already exists, a value of <TT>.false.</TT>
             will set the file position to the beginning of the file.  A value
             of <TT>.true.</TT> sets the position to the end of the file.
             If not specified,
             defaults according to <TT>defaultLogAppendFlag</TT>.
       
</DD>
<DT><STRONG>[defaultLogKindFlag]</STRONG></DT>
<DD>Default value for argument <TT>logKindFlag</TT>, setting the LogKind
             of the default ESMF log.
             If not specified, the default is <TT>ESMF_LOGKIND_MULTI</TT>.
       
</DD>
<DT><STRONG>[logKindFlag]</STRONG></DT>
<DD>Sets the LogKind of the default ESMF log. See section
             <A HREF="node6.html#const:logkindflag"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for a list of valid options.
             If not specified,
             defaults according to <TT>defaultLogKindFlag</TT>.
       
</DD>
<DT><STRONG>[mpiCommunicator]</STRONG></DT>
<DD>MPI communicator defining the group of processes on which the
             ESMF application is running.
             See section <A HREF="node6.html#vm_nesting_esmf"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> and <A HREF="node6.html#vm_multi_instance_esmf"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
             for details.
             If not specified, defaults to <TT>MPI_COMM_WORLD</TT>.
       
</DD>
<DT><STRONG>[ioUnitLBound]</STRONG></DT>
<DD>Lower bound for Fortran unit numbers used within the ESMF library.
             Fortran units are primarily used for log files.  Legal unit numbers
             are positive integers.  A value higher than 10 is recommended
             in order to avoid the compiler-specific
             reservations which are typically found on the first few units.
             If not specified, defaults to <TT>ESMF_LOG_FORT_UNIT_NUMBER</TT>,
             which is distributed with a value of 50.
       
</DD>
<DT><STRONG>[ioUnitUBound]</STRONG></DT>
<DD>Upper bound for Fortran unit numbers used within the ESMF library.
             Must be set to a value at least 5 units higher than <TT>ioUnitLBound</TT>.
             If not specified, defaults to <TT>ESMF_LOG_UPPER</TT>, which is
             distributed with a value of 99.
       
</DD>
<DT><STRONG>[defaultGlobalResourceControl]</STRONG></DT>
<DD>Default value for argument <TT>globalResourceControl</TT>, indicating
             whether PETs of the global VM are pinned to PEs and the OpenMP
             threading level is reset.
             If not specified, the default is <TT>.false.</TT>.
       
</DD>
<DT><STRONG>[globalResourceControl]</STRONG></DT>
<DD>For <TT>.true.</TT>, each global PET is pinned to the corresponding
             PE (i.e. CPU core) in order. Further, if OpenMP support is enabled
             for the ESMF installation (during build time), the
             <TT>OMP_NUM_THREADS</TT> is set to <TT>1</TT> on every PET, regardless
             of the setting in the launching environment. The <TT>.true.</TT>
             setting is recommended for applications that utilize the ESMF-aware
             threading and resource control features.
             For <TT>.false.</TT>, global PETs are <EM>not</EM> pinned by ESMF, and
             <TT>OMP_NUM_THREADS</TT> is <EM>not</EM> modified.
             If not specified,
             defaults according to <TT>defaultGlobalResourceControl</TT>.
       
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Returns the default <TT>ESMF_Config</TT> if the
             <TT>configFilename</TT> argument was provided. Otherwise the
             presence of this argument triggers an error.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Returns the global <TT>ESMF_VM</TT> that was created 
             during initialization.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04024200000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_InitializePreMPI - Initialize parts of ESMF that must happen before MPI is initialized</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_InitializePreMPI(rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method is <EM>only</EM> needed for cases where MPI is initialized
       explicitly by user code. In most typical cases <TT>ESMF_Initialize()</TT>
       is called before MPI is initialized, and takes care of all the internal
       initialization, including MPI.

<P>
There are circumstances where it is necessary or convenient to
       initialize MPI before calling into <TT>ESMF_Initialize()</TT>. This option
       is supported by ESMF, and for most cases no special action is required
       on the user side. However, for cases where <TT>ESMF_*CompSetVM*()</TT>
       methods are used to move processing elements (PEs), i.e. CPU cores,
       between persistent execution threads (PETs), ESMF uses POSIX signals
       between PETs. In order to do so safely, the proper signal handlers must
       be installed before MPI is initialized. This is accomplished by calling
       <TT>ESMF_InitializePreMPI()</TT> from the user code prior to the MPI
       initialization.

<P>
Note also that in order to use any of the advanced resource management
       functions that ESMF provides via the <TT>ESMF_*CompSetVM*()</TT> methods,
       the MPI environment must be thread-safe. <TT>ESMF_Initialize()</TT> handles
       this automatically if it is in charge of initializing MPI. However, if the
       user code initializes MPI before calling into <TT>ESMF_Initialize()</TT>,
       it must do so via <TT>MPI_Init_thread()</TT>, specifying
       <TT>MPI_THREAD_SERIALIZED</TT> or above for the required level of thread
       support.

<P>
The arguments are:
       <DL>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04024300000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_IsInitialized - Query Initialized status of ESMF</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     function ESMF_IsInitialized(rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_IsInitialized
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the framework has been initialized. This means 
       that <TT>ESMF_Initialize()</TT> has been called. Otherwise returns
       <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
       returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04024400000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_IsFinalized - Query Finalized status of ESMF</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     function ESMF_IsFinalized(rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_IsFinalized
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the framework has been finalized. This means 
       that <TT>ESMF_Finalize()</TT> has been called. Otherwise returns
       <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
       returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04024500000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_Finalize - Clean up and shut down ESMF</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_Finalize(endflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_End_Flag), intent(in), optional  :: endflag
       integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This must be called once on each PET before the application exits
       to allow ESMF to flush buffers, close open connections, and 
       release internal resources cleanly. The optional argument 
       <TT>endflag</TT> may be used to indicate the mode of termination.  
       Note that this call must be issued only once per PET with 
       <TT>endflag=ESMF_END_NORMAL</TT>, and that this call may not be followed
       by <TT>ESMF_Initialize()</TT>.  This last restriction means that it is not
       possible to restart ESMF within the same execution.

<P>
The arguments are:
       <DL>
<DT><STRONG>[endflag]</STRONG></DT>
<DD>Specify mode of termination. The default is <TT>ESMF_END_NORMAL</TT>
             which waits for all PETs of the global VM to reach 
             <TT>ESMF_Finalize()</TT> before termination. See section 
             <A HREF="#const:endflag">16.2.1</A> for a complete list and description of
             valid flags.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<P>

<H3><A NAME="SECTION04024600000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> User-code <TT>SetServices</TT> method</A>
</H3>

<P>
Many programs call some library routines.  The library
documentation must explain what the routine name is, what arguments 
are required and what are optional, and what the code does.  

<P>
In contrast, all ESMF components must be written to <I>be called</I>
by another part of the program; in effect, an ESMF component takes the 
place of a library.  The interface is prescribed by the framework,
and the component writer must provide specific subroutines which 
have standard argument lists and perform specific operations.
For technical reasons <EM>none</EM> of the arguments in user-provided subroutines
must be declared as <EM>optional</EM>.

<P>
The only <EM>required</EM> public interface of a Component is its
SetServices method.  This subroutine must have an
externally accessible name (be a public symbol), take a component
as the first argument, and an integer return code as the second. 
Both arguments are required and must <EM>not</EM> be declared as 
<TT>optional</TT>. If an intent is specified in the interface it must be 
<TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
second argument. The subroutine name is not predefined, it is set by the
component writer, but must be provided as part of the component 
documentation.

<P>
The required function that the SetServices subroutine must provide is to
specify the user-code entry points for the standard ESMF Component methods. To
this end the user-written SetServices routine calls the 

<P>
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetEntryPoint()</TT> method to set each 
Component entry point.

<P>
See sections <A HREF="#sec:GridSetServ">17.2.1</A> and <A HREF="#sec:CplSetServ">18.2.1</A> for examples of
how to write a user-code SetServices routine.

<P>
Note that a component does not call its own SetServices routine;
the AppDriver or parent component code, which is creating a component, 
will first call <TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT> to create a component object, and then must call into <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, supplying the user-code SetServices routine as an argument. The framework then calls into the user-code SetServices, after the Component's VM has been started up.

<P>
It is good practice to package the user-code implementing a component into a Fortran module, with the user-code SetService routine being the only public module method. ESMF supports three mechanisms for accessing the user-code SetServices routine from the calling AppDriver or parent component.

<P>

<UL>
<LI><B>Fortran USE association</B>: The AppDriver or parent component utilizes the standard Fortran USE statement on the component module to make all public entities available. The user-code SetServices routine can then be passed directly into the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT> interface documented in <A HREF="#GridComp:SetServices">17.4.19</A> and <A HREF="#CplComp:SetServices">18.4.19</A>, respectively.

<P>
<EM>Pros</EM>: Standard Fortran module use: name mangling and interface checking is handled by the Fortran compiler.

<P>
<EM>Cons</EM>: Fortran 90/95 has no mechanism to implement a "smart" dependency scheme through USE association. Any change in a lower level component module (even just adding or changing a comment!) will trigger a complete recompilation of all of the higher level components throughout the component hierarchy. This situation is particularly annoying for ESMF componentized code, where the prescribed ESMF component interfaces, in principle, remove all interdependencies between components that would require recompilation.

<P>
Fortran <EM>submodules</EM>, introduced as an extension to Fortran 2003, and now part for the Fortran 2008 standard, are designed to avoid this "false" dependency issue. A code change to an ESMF component that keeps the actual implementation within a submodule, will not trigger a recompilation of the components further up in the component hierarchy. Unfortunately, as of mid-2015, only two compiler vendors support submodules.

<P>
</LI>
<LI><B>External routine</B>: The AppDriver or parent component provides an explicit interface block for an external routine that implements (or calls) the user-code SetServices routine. This routine can then be passed directly into the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT> interface documented in <A HREF="#GridComp:SetServices">17.4.19</A> and <A HREF="#CplComp:SetServices">18.4.19</A>, respectively. (In practice this can be implemented by the component as an external subroutine that simply calls into the user-code SetServices module routine.)

<P>
<EM>Pros</EM>: Avoids Fortran USE dependencies: a change to lower level component code will not trigger a complete recompilation of all of the higher level components throughout the component hierarchy. Name mangling is handled by the Fortran compiler.

<P>
<EM>Cons</EM>: The user-code SetServices interface is not checked by the compiler. The user must ensure uniqueness of the external routine name across the entire application.

<P>

</LI>
<LI><B>Name lookup</B>: The AppDriver or parent component specifies the user-code SetServices routine by name. The actual lookup and code association does not occur until runtime. The name string is passed into the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT> interface documented in <A HREF="#GridComp:SetServicesShObj">17.4.20</A> and <A HREF="#CplComp:SetServicesShObj">18.4.20</A>, respectively.

<P>
<EM>Pros</EM>: Avoids Fortran USE dependencies: a change to lower level component code will not trigger a complete recompilation of all of the higher level components throughout the component hierarchy. The component code does not have to be accessible until runtime and may be located in a shared object, thus avoiding relinking of the application.

<P>
<EM>Cons</EM>: The user-code SetServices interface is not checked by the compiler. The user must explicitly deal with all of the Fortran name mangling issues: 1) Accessing a module routine requires precise knowledge of the name mangling rules of the specific compiler. Alternatively, the user-code SetServices routine may be implemented as an external routine, avoiding the module name mangling. 2) Even then, Fortran compilers typically append one or two underscores on a symbol name. This must be considered when passing the name into the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT> method.

<P>
</LI>
</UL>

<P>

<H3><A NAME="SECTION04024700000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> User-code <TT>Initialize</TT>, <TT>Run</TT>, and <TT>Finalize</TT> methods</A>
</H3>

<P>
The required standard ESMF Component methods, for which user-code entry
points must be set, are Initialize, Run, and Finalize. Currently optional,
a Component may also set entry points for the WriteRestart and
ReadRestart methods.

<P>
Sections <A HREF="#sec:GridSetServ">17.2.1</A> and <A HREF="#sec:CplSetServ">18.2.1</A> provide examples
of how the entry points for Initialize, Run, and Finalize are set during
the user-code SetServices routine, using the 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetEntryPoint()</TT> library call.

<P>
All standard user-code methods must abide <EM>exactly</EM> to the prescribed
interfaces. <EM>None</EM> of the arguments must be declared as <EM>optional</EM>.

<P>
The names of the Initialize, Run, and Finalize user-code subroutines do
not need to be public; in fact it is far better for them to be private to
lower the chances of public symbol clashes between different components.

<P>
See sections <A HREF="#sec:GridInitialize">17.2.2</A>, <A HREF="#sec:GridRun">17.2.3</A>,
<A HREF="#sec:GridFinalize">17.2.4</A>, and <A HREF="#sec:CplInitialize">18.2.2</A>, <A HREF="#sec:CplRun">18.2.3</A>,
<A HREF="#sec:CplFinalize">18.2.4</A> for examples of how to write entry points for the 
standard ESMF Component methods.

<P>

<H3><A NAME="SECTION04024800000000000000"></A>
<A NAME="sec:AppDriverSetVM"></A>
<BR>
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> User-code <TT>SetVM</TT> method
</H3>

<P>
When the AppDriver or parent component code calls
<TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT> it has the option to specify a 
<TT>petList</TT> argument. All of the parent PETs contained in this list become
resources of the child component. By default, without the <TT>petList</TT> argument, all of the parent PETs are provided to the child component.

<P>
Typically each component has its own virtual machine (VM) object. However, using the optional <TT>contextflag</TT> argument during <TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT> a child component can inherit its parent component's VM. Unless a child component inherits the parent VM, it has the option to set certain aspects of how its VM utilizes the provided resources. The resources provided via the parent PETs are the associated processing elements (PEs) and virtual address spaces (VASs).

<P>
The optional user-written SetVM routine is called from the parent for the child through the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> method. This is the only place where the child component can set aspects of its own VM before it is started up. The child component's VM must be running before the SetServices routine can be called, and thus the parent must call the optional <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> method <EM>before</EM> <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>.

<P>
Inside the user-code called by the SetVM routine, the component has the option to specify how the PETs share the provided parent PEs. Further, PETs on the same single system image (SSI) can be set to run multi-threaded within a reduced number of virtual address spaces (VAS), allowing a component to leverage shared memory concepts.

<P>
Sections <A HREF="#sec:GridSetVM">17.2.5</A> and <A HREF="#sec:CplSetVM">18.2.5</A> provide examples for
simple user-written SetVM routines.

<P>
One common use of the SetVM approach is to implement hybrid parallelism based on MPI+OpenMP. Under ESMF, each component can use its own hybrid parallelism implementation. Different components, even if running on the same PE resources, do not have to agree on the number of MPI processes (i.e. PETs), or the number of OpenMP threads launched under each PET. Hybrid and non-hybrid components can be mixed within the same application. Coupling between components of any flavor is supported under ESMF.

<P>
In order to obtain best performance when using SetVM based resource control for hybrid parallelism, it is <EM>strongly recommended</EM> to set <TT>OMP_WAIT_POLICY=PASSIVE</TT> in the environment. This is one of the standard OpenMP environment variables. The <TT>PASSIVE</TT> setting ensures that OpenMP threads relinquish the PEs as soon as they have completed their work. Without that setting ESMF resource control threads can be delayed, and context switching between components becomes more expensive.

<P>

<H3><A NAME="SECTION04024900000000000000"></A>
<A NAME="sec:AppDriverIntProc"></A>
<BR>
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> Use of <TT>internal procedures</TT> as user-provided procedures
</H3>

<P>
Internal procedures are nested within a surrounding procedure, and only local to the surrounding procedure.
They are specified by using the CONTAINS statement.

<P>
Prior to Fortran-2008 an internal procedure could not be used as a user-provided callback procedure.
In Fortran-2008 this restriction was lifted.  It is important to note that if ESMF is passed an internal
procedure, that the surrounding procedure be active whenever ESMF calls it.  This helps ensure that
local variables at the surrounding procedures scope are properly initialized.

<P>
When internal procedures contained within a main program unit are used for callbacks, there is no problem.
This is because the main program unit is always active.  However when internal procedures are used within
other program units, initialization could become a problem.  The following outlines the issue:

<P>
<PRE>
  module my_procs_mod
    use ESMF
    implicit none

  contains

    subroutine my_procs (...)
      integer :: my_setting
      :
      call ESMF_GridCompSetEntryPoint(gridcomp, methodflag=ESMF_METHOD_INITIALIZE, &amp;
          userRoutine=my_grid_proc_init, rc=localrc)
      :
      my_setting = 42

    contains

      subroutine my_grid_proc_init (gridcomp, importState, exportState, clock, rc)
        :
      ! my_setting is possibly uninitialized when my_grid_proc_init is used as a call-back
        something = my_setting
        :
      end subroutine my_grid_proc_init
    end subroutine my_procs
  end module my_procs_mod
</PRE>

<P>
The Fortran standard does not specify whether variable <I>my_setting</I> is statically or
automatically allocated, unless it is explicitly given the SAVE attribute.  Thus there is no
guarantee that its value will persist after <I>my_procs</I> has finished.  The SAVE attribute
is usually given to a variable via specifying a SAVE attribute in its delaration.  However it can
also be inferred by initializing the variable in its declaration:

<P>
<PRE>
      :
      integer, save : my_setting
      :
</PRE>

<P>
or,

<P>
<PRE>
      :
      integer :: my_setting = 42
      :
</PRE>

<P>
Because of the potential initialization issues, it is recommended that internal procedures
only be used as ESMF callbacks when the surrounding procedure is also active.

<H1><A NAME="SECTION04030000000000000000">
<SPAN CLASS="arabic">17</SPAN> GridComp Class</A>
</H1>

<H2><A NAME="SECTION04031000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:GridComp"></A>
<P>
In Earth system modeling, the most natural way to think about an ESMF 
Gridded Component, or <TT>ESMF_GridComp</TT>, is as a piece of code 
representing a particular physical domain, such as an atmospheric 
model or an ocean model.  Gridded Components may also represent individual
processes, such as radiation or chemistry.  It's up to the application
writer to decide how deeply to &ldquo;componentize.&rdquo;

<P>
Earth system software components tend to share a number of basic 
features.  Most ingest and produce a variety of physical fields, refer to 
a (possibly noncontiguous) spatial region and a grid that is 
partitioned across a set of computational resources, and require 
a clock for things like stepping a governing set of PDEs forward in time.  
Most can also be divided into distinct initialize, run, and finalize 
computational phases.  These common characteristics are used 
within ESMF to define a Gridded Component data structure that 
is tailored for Earth system modeling and yet is still flexible
enough to represent a variety of domains.

<P>
A well designed Gridded Component does not store information 
internally about how it couples to other Gridded Components.  That
allows it to be used in different contexts without changes to source
code.  The idea here is to avoid situations in which slightly
different versions of the same model source are maintained for use in 
different contexts - standalone vs. coupled versions, for example.
Data is passed in and out of Gridded Components using an ESMF State,
this is described in Section&nbsp;<A HREF="#sec:State">21.1</A>.

<P>
An ESMF Gridded Component has two parts, one which is user-written
and another which is part of the framework.  The user-written
part is software that represents a physical domain or performs some
other computational function.  It forms the body of the Gridded 
Component.  It may be a piece of legacy code, or it may be developed 
expressly for use with ESMF.  It must contain routines with
standard ESMF interfaces that can be called to initialize, run, and
finalize the Gridded Component.  These routines can have separate 
callable phases, such as distinct first and second initialization steps.

<P>
ESMF provides the Gridded Component derived type, 
<TT>ESMF_GridComp</TT>.  An <TT>ESMF_GridComp</TT> must be created 
for every portion of the application that will be represented 
as a separate component.  For example, in a climate model, there may 
be Gridded Components representing the land, ocean, sea ice, and 
atmosphere.  If the application contains an ensemble of identical 
Gridded Components, every one has its own associated <TT>ESMF_GridComp</TT>.
Each Gridded Component has its own name and is allocated
a set of computational resources, in the form of an ESMF Virtual
Machine, or <TT>VM</TT>.

<P>
The user-written part of a Gridded Component is associated with an
<TT>ESMF_GridComp</TT> derived type through a routine called 
<TT>ESMF_SetServices()</TT>.
This is a routine that the user must write, and declare public.
Inside the SetServices routine the user must call  
<TT>ESMF_SetEntryPoint()</TT> methods that associate a standard ESMF 
operation with the name of the corresponding Fortran subroutine 
in their user code.

<H2><A NAME="SECTION04032000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A Gridded Component is a computational entity which consumes and produces data. It uses a State object to exchange data between itself and other Components. It uses a Clock object to manage time, and a VM to describe its own and its child components' computational resources.

<P>
This section shows how to create Gridded Components.  For demonstrations
of the use of Gridded Components, see the system tests that are bundled with the ESMF software
distribution.  These can be found in the directory <TT>esmf/src/system_tests</TT>.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04032100000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Implement a user-code <TT>SetServices</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridSetServ"></A>
<P>
Every <TT>ESMF_GridComp</TT> is required to provide and document
   a public set services routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_GridComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set services routine must call the ESMF method 
   <TT>ESMF_GridCompSetEntryPoint()</TT> to
   register with the framework what user-code subroutines should be called 
   to initialize, run, and finalize the component.  There are
   additional routines which can be registered as well, for checkpoint
   and restart functions.

<P>
Note that the actual subroutines being registered do not have to be
   public to this module; only the set services routine itself must
   be available to be used by other code. 

<P>
<PRE>
    ! Example Gridded Component
    module ESMF_GriddedCompEx
    
    ! ESMF Framework module
    use ESMF
    implicit none
    public GComp_SetServices
    public GComp_SetVM

    contains

    subroutine GComp_SetServices(comp, rc)
      type(ESMF_GridComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional

      ! Set the entry points for standard ESMF Component methods
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_INITIALIZE, &amp;
                                userRoutine=GComp_Init, rc=rc)
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_RUN, &amp;
                                userRoutine=GComp_Run, rc=rc)
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_FINALIZE, &amp;
                                userRoutine=GComp_Final, rc=rc)

      rc = ESMF_SUCCESS

    end subroutine
</PRE>

<P>

<P>

<H3><A NAME="SECTION04032200000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Implement a user-code <TT>Initialize</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridInitialize"></A>
<P>
When a higher level component is ready to begin using an 
   <TT>ESMF_GridComp</TT>, it will call its initialize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
At initialization time the component can allocate data space, open
   data files, set up initial conditions; anything it needs to do to
   prepare to run.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine GComp_Init(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Init starting"

      ! This is where the model specific setup code goes.  
 
      ! If the initial Export state needs to be filled, do it here.
      !call ESMF_StateAdd(exportState, field, rc)
      !call ESMF_StateAdd(exportState, bundle, rc)
      print *, "Gridded Comp Init returning"
   
      rc = ESMF_SUCCESS

    end subroutine GComp_Init
</PRE>

<P>

<P>

<H3><A NAME="SECTION04032300000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Implement a user-code <TT>Run</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridRun"></A>
<P>
During the execution loop, the run routine may be called many times.
   Each time it should read data from the <TT>importState</TT>, use the
   <TT>clock</TT> to determine what the current time is in the calling
   component, compute new values or process the data,
   and produce any output and place it in the <TT>exportState</TT>. 

<P>
When a higher level component is ready to use the <TT>ESMF_GridComp</TT>
   it will call its run routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
It is expected that this is where the bulk of the model computation
   or data analysis will occur.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine GComp_Run(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Run starting"
      ! call ESMF_StateGet(), etc to get fields, bundles, arrays
      !  from import state.

      ! This is where the model specific computation goes.

      ! Fill export state here using ESMF_StateAdd(), etc

      print *, "Gridded Comp Run returning"

      rc = ESMF_SUCCESS

    end subroutine GComp_Run
</PRE>

<P>

<P>

<H3><A NAME="SECTION04032400000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Implement a user-code <TT>Finalize</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridFinalize"></A>
<P>
At the end of application execution, each <TT>ESMF_GridComp</TT> should
   deallocate data space, close open files, and flush final results.
   These functions should be placed in a finalize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned.

<P>
<PRE>
    subroutine GComp_Final(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Final starting"
    
      ! Add whatever code here needed

      print *, "Gridded Comp Final returning"
   
      rc = ESMF_SUCCESS

    end subroutine GComp_Final
</PRE>

<P>

<P>

<H3><A NAME="SECTION04032500000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Implement a user-code <TT>SetVM</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridSetVM"></A>
<P>
Every <TT>ESMF_GridComp</TT> can optionally provide and document
   a public set vm routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_GridComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set vm routine is the only place where the child component can
   use the <TT>ESMF_GridCompSetVMMaxPEs()</TT>, or
   <TT>ESMF_GridCompSetVMMaxThreads()</TT>, or 
   <TT>ESMF_GridCompSetVMMinThreads()</TT> call to modify aspects of its own VM.

<P>
A component's VM is started up right before its set services routine is
   entered. <TT>ESMF_GridCompSetVM()</TT> is executing in the parent VM, and must
   be called <EM>before</EM> <TT>ESMF_GridCompSetServices()</TT>. 

<P>
<PRE>
    subroutine GComp_SetVM(comp, rc)
      type(ESMF_GridComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional
      
      type(ESMF_VM) :: vm
      logical :: pthreadsEnabled
      
      ! Test for Pthread support, all SetVM calls require it
      call ESMF_VMGetGlobal(vm, rc=rc)
      call ESMF_VMGet(vm, pthreadsEnabledFlag=pthreadsEnabled, rc=rc)

      if (pthreadsEnabled) then
        ! run PETs single-threaded
        call ESMF_GridCompSetVMMinThreads(comp, rc=rc)
      endif

      rc = ESMF_SUCCESS

    end subroutine

    end module ESMF_GriddedCompEx
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION04032600000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Set and Get the Internal State</A>
</H3>  

<P>
ESMF provides the concept of an Internal State that is associated with
     a Component. Through the Internal State API a user can attach a private
     data block to a Component, and later retrieve a pointer to this memory
     allocation. Setting and getting of Internal State information are
     supported from anywhere in the Component's SetServices, Initialize, Run,
     or Finalize code.

<P>
The code below demonstrates the basic Internal State API
     of <TT>ESMF_&lt;Grid|Cpl&gt;SetInternalState()</TT> and
     <TT>ESMF_&lt;Grid|Cpl&gt;GetInternalState()</TT>. Notice that an extra level of
     indirection to the user data is necessary!

<P>
<PRE>
  ! ESMF Framework module
  use ESMF
  use ESMF_TestMod
  implicit none
  
  type(ESMF_GridComp) :: comp
  integer :: rc, finalrc

  ! Internal State Variables
  type testData
  sequence
    integer :: testValue
    real    :: testScaling
  end type

  type dataWrapper
  sequence
    type(testData), pointer :: p
  end type

  type(dataWrapper) :: wrap1, wrap2
  type(testData), target :: data
  type(testData), pointer :: datap  ! extra level of indirection
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------
        
  call ESMF_Initialize(defaultlogfilename="InternalStateEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

!-------------------------------------------------------------------------

  !  Creation of a Component
  comp = ESMF_GridCompCreate(name="test", rc=rc)  
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

!-------------------------------------------------------------------------
! This could be called, for example, during a Component's initialize phase.

    ! Initialize private data block
  data%testValue = 4567
  data%testScaling = 0.5

  ! Set Internal State
  wrap1%p =&gt; data
  call ESMF_GridCompSetInternalState(comp, wrap1, rc)
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

!-------------------------------------------------------------------------
! This could be called, for example, during a Component's run phase.

  ! Get Internal State
  call ESMF_GridCompGetInternalState(comp, wrap2, rc)
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

  ! Access private data block and verify data
  datap =&gt; wrap2%p 
  if ((datap%testValue .ne. 4567) .or. (datap%testScaling .ne. 0.5)) then
    print *, "did not get same values back"
    finalrc = ESMF_FAILURE
  else
    print *, "got same values back from GetInternalState as original"
  endif
</PRE>

<P>


<P>

<P>

<P>
When working with ESMF Internal States it is important to consider the
     applying scoping rules. The user must ensure that the private data block
     that is being referenced persists for the entire access period. This is
     not an issue in the previous example, where the private data block was
     defined on the scope of the main program. However, the Internal State 
     construct is often useful inside of Component modules to hold Component
     specific data between calls. One option to ensure persisting private data
     blocks is to use the Fortran SAVE attribute either on local or module
     variables. A second option, illustrated in the following example, is to 
     use Fortran pointers and user controlled memory management via allocate()
     and deallocate() calls.

<P>
One situation where the Internal State is useful is in the
     creation of ensembles of the same Component. In this case it can 
     be tricky to distinguish which data, held in saved module variables, 
     belongs to which ensemble member - especially if the ensemble members
     are executing on the same set of PETs. The Internal State solves this
     problem by providing a handle to instance specific data allocations.

<P>
<PRE>
module user_mod

  use ESMF

  implicit none
  
  ! module variables
  private

  ! Internal State Variables
  type testData
  sequence
    integer       :: testValue        ! scalar data
    real          :: testScaling      ! scalar data
    real, pointer :: testArray(:)     ! array data
  end type

  type dataWrapper
  sequence
    type(testData), pointer :: p
  end type
</PRE>

<P>
<PRE>
  contains !--------------------------------------------------------------
</PRE>

<P>
<PRE>
  subroutine mygcomp_init(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data
    integer :: i

    rc = ESMF_SUCCESS
    
    ! Allocate private data block
    allocate(data)

    ! Initialize private data block
    data%testValue = 4567         ! initialize scalar data
    data%testScaling = 0.5        ! initialize scalar data
    allocate(data%testArray(10))  ! allocate array data
    
    do i=1, 10
      data%testArray(i) = real(i) ! initialize array data
    enddo
    
    ! In a real ensemble application the initial data would be set to 
    ! something unique for this ensemble member. This could be 
    ! accomplished for example by reading a member specific config file 
    ! that was specified by the driver code. Alternatively, Attributes, 
    ! set by the driver, could be used to label the Component instances 
    ! as specific ensemble members.
    
    ! Set Internal State
    wrap%p =&gt; data
    call ESMF_GridCompSetInternalState(gcomp, wrap, rc)

  end subroutine !-------------------------------------------------------
  
  subroutine mygcomp_run(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data
    logical :: match = .true.
    integer :: i
    
    rc = ESMF_SUCCESS

    ! Get Internal State
    call ESMF_GridCompGetInternalState(gcomp, wrap, rc)
    if (rc/=ESMF_SUCCESS) return

    ! Access private data block and verify data
    data =&gt; wrap%p 
    if (data%testValue .ne. 4567) match = .false.   ! test scalar data
    if (data%testScaling .ne. 0.5) match = .false.  ! test scalar data
    do i=1, 10
      if (data%testArray(i) .ne. real(i)) match = .false. ! test array data
    enddo
    
    if (match) then
      print *, "got same values back from GetInternalState as original"
    else
      print *, "did not get same values back"
      rc = ESMF_FAILURE
    endif
    
  end subroutine !-------------------------------------------------------

  subroutine mygcomp_final(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data

    rc = ESMF_SUCCESS
    
    ! Get Internal State
    call ESMF_GridCompGetInternalState(gcomp, wrap, rc)
    if (rc/=ESMF_SUCCESS) return
    
    ! Deallocate private data block
    data =&gt; wrap%p 
    deallocate(data%testArray)  ! deallocate array data
    deallocate(data)
    
  end subroutine !--------------------------------------------------------------


end module
</PRE>

<P>


<H2><A NAME="SECTION04033000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No optional arguments.</B> User-written routines called by SetServices,
and registered for Initialize, Run and Finalize, <EM>must not</EM> declare any
of the arguments as optional.

<P>
</LI>
<LI><B>Namespace isolation.</B>
If possible, Gridded Components should attempt to make 
all data private, so public names do not interfere with data 
in other components.

<P>
</LI>
<LI><B>Single execution mode.</B>
It is not expected that a single Gridded Component be able 
to function in both sequential and concurrent modes, although 
Gridded Components of different types can be nested. For example,
a concurrently called Gridded Component can contain several nested 
sequential Gridded Components. 

<P>
</LI>
</OL>

<H2><A NAME="SECTION04034000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04034100000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GridCompAssignment(=) - GridComp assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     gridcomp1 = gridcomp2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp) :: gridcomp1
     type(ESMF_GridComp) :: gridcomp2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign gridcomp1 as an alias to the same ESMF GridComp object in memory
     as gridcomp2. If gridcomp2 is invalid, then gridcomp1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>gridcomp1</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>gridcomp2</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034200000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GridCompOperator(==) - GridComp equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (gridcomp1 == gridcomp2) then ... endif
               OR
     result = (gridcomp1 == gridcomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in) :: gridcomp1
     type(ESMF_GridComp), intent(in) :: gridcomp2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether gridcomp1 and gridcomp2 are valid aliases to the same ESMF
     GridComp object in memory. For a more general comparison of two ESMF GridComps,
     going beyond the simple alias test, the ESMF_GridCompMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>gridcomp1</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>gridcomp2</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034300000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GridCompOperator(/=) - GridComp not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (gridcomp1 /= gridcomp2) then ... endif
               OR
     result = (gridcomp1 /= gridcomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in) :: gridcomp1
     type(ESMF_GridComp), intent(in) :: gridcomp2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether gridcomp1 and gridcomp2 are <I>not</I> valid aliases to the
     same ESMF GridComp object in memory. For a more general comparison of two ESMF
     GridComps, going beyond the simple alias test, the ESMF_GridCompMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>gridcomp1</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>gridcomp2</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034400000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GridCompCreate - Create a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive function ESMF_GridCompCreate(grid, gridList, &amp;
     mesh, meshList, locstream, locstreamList, xgrid, xgridList, &amp;
     config, configFile, clock, petList, contextflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_GridComp) :: ESMF_GridCompCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Grid),         intent(in),    optional :: grid
     type(ESMF_Grid),         intent(in),    optional :: gridList(:)
     type(ESMF_Mesh),         intent(in),    optional :: mesh
     type(ESMF_Mesh),         intent(in),    optional :: meshList(:)
     type(ESMF_LocStream),    intent(in),    optional :: locstream
     type(ESMF_LocStream),    intent(in),    optional :: locstreamList(:)
     type(ESMF_XGrid),        intent(in),    optional :: xgrid
     type(ESMF_XGrid),        intent(in),    optional :: xgridList(:)
     type(ESMF_Config),       intent(in),    optional :: config
     character(len=*),        intent(in),    optional :: configFile
     type(ESMF_Clock),        intent(in),    optional :: clock
     integer,                 intent(in),    optional :: petList(:)
     type(ESMF_Context_Flag), intent(in),    optional :: contextflag
     character(len=*),        intent(in),    optional :: name
     integer,                 intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added arguments <TT>gridList</TT>, <TT>mesh</TT>, <TT>meshList</TT>,
     <TT>locstream</TT>, <TT>locstreamList</TT>, <TT>xgrid</TT>, and <TT>xgridList</TT>.
     These arguments add support for holding references to multiple geom objects,
     either of the same type, or different type, in the same
     <TT>ESMF_GridComp</TT> object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This interface creates an <TT>ESMF_GridComp</TT> object. By default, a
   separate VM context will be created for each component.  This implies
   creating a new MPI communicator and allocating additional memory to
   manage the VM resources. When running on a large number of processors,
   creating a separate VM for each component could be both time and memory
   inefficient.  If the application is sequential, i.e., each component is
   running on all the PETs of the global VM, it will be more efficient to use
   the global VM instead of creating a new one.  This can be done by setting
   <TT>contextflag</TT> to ESMF_CONTEXT_PARENT_VM.

<P>
The return value is the new <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Associate an <TT>ESMF_Grid</TT> object with the newly created component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>grid</TT> object.
     The <TT>grid</TT> argument is mutually exclusive with the <TT>gridList</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>grid</TT> nor <TT>gridList</TT> are provided,
     no <TT>ESMF_Grid</TT> objects are associated with the component.
   
</DD>
<DT><STRONG>[gridList]</STRONG></DT>
<DD>Associate a list of <TT>ESMF_Grid</TT> objects with the newly created
     component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>gridList</TT> object.
     The <TT>gridList</TT> argument is mutually exclusive with the <TT>grid</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>grid</TT> nor <TT>gridList</TT> are provided,
     no <TT>ESMF_Grid</TT> objects are associated with the component.
   
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>Associate an <TT>ESMF_Mesh</TT> object with the newly created component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>mesh</TT> object.
     The <TT>mesh</TT> argument is mutually exclusive with the <TT>meshList</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>mesh</TT> nor <TT>meshList</TT> are provided,
     no <TT>ESMF_Mesh</TT> objects are associated with the component.
   
</DD>
<DT><STRONG>[meshList]</STRONG></DT>
<DD>Associate a list of <TT>ESMF_Mesh</TT> objects with the newly created
     component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>meshList</TT> object.
     The <TT>meshList</TT> argument is mutually exclusive with the <TT>mesh</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>mesh</TT> nor <TT>meshList</TT> are provided,
     no <TT>ESMF_Mesh</TT> objects are associated with the component.
   
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>Associate an <TT>ESMF_LocStream</TT> object with the newly created component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>locstream</TT> object.
     The <TT>locstream</TT> argument is mutually exclusive with the
     <TT>locstreamList</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>locstream</TT> nor <TT>locstreamList</TT> are
     provided, no <TT>ESMF_LocStream</TT> objects are associated with the
     component.
   
</DD>
<DT><STRONG>[locstreamList]</STRONG></DT>
<DD>Associate a list of <TT>ESMF_LocStream</TT> objects with the newly created
     component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>locstreamList</TT> object.
     The <TT>locstreamList</TT> argument is mutually exclusive with the
     <TT>locstream</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>locstream</TT> nor <TT>locstreamList</TT> are
     provided, no <TT>ESMF_LocStream</TT> objects are associated with the
     component.
   
</DD>
<DT><STRONG>[xgrid]</STRONG></DT>
<DD>Associate an <TT>ESMF_XGrid</TT> object with the newly created component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>xgrid</TT> object.
     The <TT>xgrid</TT> argument is mutually exclusive with the <TT>xgridList</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>xgrid</TT> nor <TT>xgridList</TT> are provided,
     no <TT>ESMF_XGrid</TT> objects are associated with the component.
   
</DD>
<DT><STRONG>[xgridList]</STRONG></DT>
<DD>Associate a list of <TT>ESMF_XGrid</TT> objects with the newly created
     component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>xgridList</TT> object.
     The <TT>xgridList</TT> argument is mutually exclusive with the <TT>xgrid</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>xgrid</TT> nor <TT>xgridList</TT> are provided,
     no <TT>ESMF_XGrid</TT> objects are associated with the component.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>An already-created <TT>ESMF_Config</TT> object to be attached to the newly
     created component.
     If both <TT>config</TT> and <TT>configFile</TT> arguments are specified,
     <TT>config</TT> takes priority.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>The filename of an <TT>ESMF_Config</TT> format file.
     If specified, a new <TT>ESMF_Config</TT> object is created and attached to the
     newly created component. The <TT>configFile</TT> file is opened and associated
     with the new config object.
     If both <TT>config</TT> and <TT>configFile</TT> arguments are specified,
     <TT>config</TT> takes priority.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Component-specific <TT>ESMF_Clock</TT>.  This clock is available to be
     queried and updated by the new <TT>ESMF_GridComp</TT> as it chooses.
     This should
     not be the parent component clock, which should be maintained and passed
     down to the initialize/run/finalize routines separately.

</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List of parent <TT>PET</TT>s given to the created child component by the
     parent component. If <TT>petList</TT> is not specified all of the
     parent <TT>PET</TT>s will be given to the child component. The order of
     PETs in <TT>petList</TT> determines how the child local PETs refer back to
     the parent PETs.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Specify the component's VM context. The default context is
     <TT>ESMF_CONTEXT_OWN_VM</TT>. See section <A HREF="node9.html#const:contextflag"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for a
     complete list of valid flags.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the newly-created <TT>ESMF_GridComp</TT>.  This name can be altered
     from within the <TT>ESMF_GridComp</TT> code once the initialization routine
     is called.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034500000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_GridCompDestroy - Release resources associated with a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompDestroy(gridcomp, &amp;
     timeout, timeoutFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)          :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),   optional :: timeout
     logical,             intent(out),  optional :: timeoutFlag
     integer,             intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_GridComp</TT>, releasing the resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Release all resources associated with this <TT>ESMF_GridComp</TT>
     and mark the object as invalid.  It is an error to pass this
     object into any other routines after being destroyed.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034600000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_GridCompFinalize - Call the GridComp's finalize routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompFinalize(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user-supplied finalization routine for
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to call finalize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default
     is 1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034700000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_GridCompGet - Get GridComp information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompGet(gridcomp, &amp;
     gridIsPresent, grid, gridList, meshIsPresent, mesh, meshList, &amp;
     locstreamIsPresent, locstream, locstreamList, xgridIsPresent, &amp;
     xgrid, xgridList, importStateIsPresent, importState, &amp;
     exportStateIsPresent, exportState, configIsPresent, config, &amp;
     configFileIsPresent, configFile, clockIsPresent, clock, localPet, &amp;
     petCount, contextflag, currentMethod, currentPhase, comptype, &amp;
     vmIsPresent, vm, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),           intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                       intent(out), optional :: gridIsPresent
     type(ESMF_Grid),               intent(out), optional :: grid
     type(ESMF_Grid), allocatable,  intent(out), optional :: gridList(:)
     logical,                       intent(out), optional :: meshIsPresent
     type(ESMF_Mesh),               intent(out), optional :: mesh
     type(ESMF_Mesh), allocatable,  intent(out), optional :: meshList(:)
     logical,                       intent(out), optional :: locstreamIsPresent
     type(ESMF_LocStream),          intent(out), optional :: locstream
     type(ESMF_LocStream), allocatable, intent(out), optional :: locstreamList(:)
     logical,                       intent(out), optional :: xgridIsPresent
     type(ESMF_XGrid),              intent(out), optional :: xgrid
     type(ESMF_XGrid), allocatable, intent(out), optional :: xgridList(:)
     logical,                       intent(out), optional :: importStateIsPresent
     type(ESMF_State),              intent(out), optional :: importState
     logical,                       intent(out), optional :: exportStateIsPresent
     type(ESMF_State),              intent(out), optional :: exportState
     logical,                       intent(out), optional :: configIsPresent
     type(ESMF_Config),             intent(out), optional :: config
     logical,                       intent(out), optional :: configFileIsPresent
     character(len=*),              intent(out), optional :: configFile
     logical,                       intent(out), optional :: clockIsPresent
     type(ESMF_Clock),              intent(out), optional :: clock
     integer,                       intent(out), optional :: localPet
     integer,                       intent(out), optional :: petCount
     type(ESMF_Context_Flag),       intent(out), optional :: contextflag
     type(ESMF_Method_Flag),        intent(out), optional :: currentMethod
     integer,                       intent(out), optional :: currentPhase
     type(ESMF_CompType_Flag),      intent(out), optional :: comptype
     logical,                       intent(out), optional :: vmIsPresent
     type(ESMF_VM),                 intent(out), optional :: vm
     character(len=*),              intent(out), optional :: name
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added arguments <TT>gridList</TT>, <TT>meshIsPresent</TT>, <TT>mesh</TT>,
     <TT>meshList</TT>, <TT>locstreamIsPresent</TT>, <TT>locstream</TT>,
     <TT>locstreamList</TT>, <TT>xgridIsPresent</TT>, <TT>xgrid</TT>, and <TT>xgridList</TT>.
     These arguments add support for accessing references to multiple geom objects,
     either of the same type, or different type, associated with the same
     <TT>ESMF_GridComp</TT> object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get information about an <TT>ESMF_GridComp</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object being queried.
   
</DD>
<DT><STRONG>[gridIsPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if at least one <TT>ESMF_Grid</TT> object is
     associated with the <TT>gridcomp</TT> component.
     Set to <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Return the <TT>ESMF_Grid</TT> object associated with the <TT>gridcomp</TT>
     component. If multiple <TT>ESMF_Grid</TT> objects are associated, return the
     first in the list.
     It is an error to query for <TT>grid</TT> if no <TT>ESMF_Grid</TT> object is
     associated with the <TT>gridcomp</TT> component.
     If unsure, query for <TT>gridIsPresent</TT> first, or use the <TT>gridList</TT>
     variant.
   
</DD>
<DT><STRONG>[gridList]</STRONG></DT>
<DD>Return a list of all <TT>ESMF_Grid</TT> objects associated with the
     <TT>gridcomp</TT> component. The size of the returned <TT>gridList</TT>
     corresponds to the number of <TT>ESMF_Grid</TT> objects associated.
     If no <TT>ESMF_Grid</TT> object is associated with the <TT>gridcomp</TT>
     component, the size of the returned <TT>gridList</TT> is zero.
   
</DD>
<DT><STRONG>[meshIsPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if at least one <TT>ESMF_Mesh</TT> object is
     associated with the <TT>gridcomp</TT> component.
     Set to <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>Return the <TT>ESMF_Mesh</TT> object associated with the <TT>gridcomp</TT>
     component. If multiple <TT>ESMF_Mesh</TT> objects are associated, return the
     first in the list.
     It is an error to query for <TT>mesh</TT> if no <TT>ESMF_Mesh</TT> object is
     associated with the <TT>gridcomp</TT> component.
     If unsure, query for <TT>meshIsPresent</TT> first, or use the <TT>meshList</TT>
     variant.
   
</DD>
<DT><STRONG>[meshList]</STRONG></DT>
<DD>Return a list of all <TT>ESMF_Mesh</TT> objects associated with the
     <TT>gridcomp</TT> component. The size of the returned <TT>meshList</TT>
     corresponds to the number of <TT>ESMF_Mesh</TT> objects associated.
     If no <TT>ESMF_Mesh</TT> object is associated with the <TT>gridcomp</TT>
     component, the size of the returned <TT>meshList</TT> is zero.
   
</DD>
<DT><STRONG>[locstreamIsPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if at least one <TT>ESMF_LocStream</TT> object is
     associated with the <TT>gridcomp</TT> component.
     Set to <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>Return the <TT>ESMF_LocStream</TT> object associated with the <TT>gridcomp</TT>
     component. If multiple <TT>ESMF_LocStream</TT> objects are associated, return
     the first in the list.
     It is an error to query for <TT>locstream</TT> if no <TT>ESMF_Grid</TT> object is
     associated with the <TT>gridcomp</TT> component.
     If unsure, query for <TT>locstreamIsPresent</TT> first, or use the
     <TT>locstreamList</TT> variant.

</DD>
<DT><STRONG>[locstreamList]</STRONG></DT>
<DD>Return a list of all <TT>ESMF_LocStream</TT> objects associated with the
     <TT>gridcomp</TT> component. The size of the returned <TT>locstreamList</TT>
     corresponds to the number of <TT>ESMF_LocStream</TT> objects associated.
     If no <TT>ESMF_LocStream</TT> object is associated with the <TT>gridcomp</TT>
     component, the size of the returned <TT>locstreamList</TT> is zero.
   
</DD>
<DT><STRONG>[xgridIsPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if at least one <TT>ESMF_XGrid</TT> object is
     associated with the <TT>gridcomp</TT> component.
     Set to <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[xgrid]</STRONG></DT>
<DD>Return the <TT>ESMF_XGrid</TT> object associated with the <TT>gridcomp</TT>
     component. If multiple <TT>ESMF_XGrid</TT> objects are associated, return the
     first in the list.
     It is an error to query for <TT>xgrid</TT> if no <TT>ESMF_XGrid</TT> object is
     associated with the <TT>gridcomp</TT> component.
     If unsure, query for <TT>xgridIsPresent</TT> first, or use the <TT>xgridList</TT>
     variant.
   
</DD>
<DT><STRONG>[xgridList]</STRONG></DT>
<DD>Return a list of all <TT>ESMF_XGrid</TT> objects associated with the
     <TT>gridcomp</TT> component. The size of the returned <TT>xgridList</TT>
     corresponds to the number of <TT>ESMF_XGrid</TT> objects associated.
     If no <TT>ESMF_XGrid</TT> object is associated with the <TT>gridcomp</TT>
     component, the size of the returned <TT>xgridList</TT> is zero.
   
</DD>
<DT><STRONG>[importStateIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>importState</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD>Return the associated import State.
     It is an error to query for the import State if none is associated with
     the GridComp. If unsure, get <TT>importStateIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[exportStateIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>exportState</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD>Return the associated export State.
     It is an error to query for the export State if none is associated with
     the GridComp. If unsure, get <TT>exportStateIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[configIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>config</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Return the associated Config.
     It is an error to query for the Config if none is associated with
     the GridComp. If unsure, get <TT>configIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[configFileIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>configFile</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Return the associated configuration filename.
     It is an error to query for the configuration filename if none is associated with
     the GridComp. If unsure, get <TT>configFileIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[clockIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>clock</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Return the associated Clock.
     It is an error to query for the Clock if none is associated with
     the GridComp. If unsure, get <TT>clockIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[localPet]</STRONG></DT>
<DD>Return the local PET id within the <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>[petCount]</STRONG></DT>
<DD>Return the number of PETs in the the <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Return the <TT>ESMF_Context_Flag</TT> for this <TT>ESMF_GridComp</TT>.
     See section <A HREF="node9.html#const:contextflag"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for a complete list of valid flags.
   
</DD>
<DT><STRONG>[currentMethod]</STRONG></DT>
<DD>Return the current <TT>ESMF_Method_Flag</TT> of the <TT>ESMF_GridComp</TT>
     execution. See section <A HREF="node9.html#const:method"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>  for a complete list of valid
     options.
   
</DD>
<DT><STRONG>[currentPhase]</STRONG></DT>
<DD>Return the current <TT>phase</TT> of the <TT>ESMF_GridComp</TT> execution.
   
</DD>
<DT><STRONG>[comptype]</STRONG></DT>
<DD>Return the Component type.
     See section <A HREF="node9.html#const:comptype"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for a complete list of valid flags.
   
</DD>
<DT><STRONG>[vmIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>vm</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Return the associated VM.
     It is an error to query for the VM if none is associated with
     the GridComp. If unsure, get <TT>vmIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Return the name of the <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034800000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_GridCompGetInternalState - Get private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompGetInternalState(gridcomp, wrappedDataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)             :: gridcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_GridComp</TT> at any time after
   <TT>ESMF_GridCompSetInternalState</TT> has been called.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by this call.
   When running multiple instantiations of an <TT>ESMF_GridComp</TT>,
   for example during ensemble runs,
   it may be simpler to maintain private data specific to
   each run with private data blocks.  A corresponding
   <TT>ESMF_GridCompSetInternalState</TT> call sets the data pointer to
   this block, and this call retrieves the data pointer.
   Note that the <TT>wrappedDataPointer</TT> argument needs to be a derived type
   which contains only a pointer of the type of the data block defined
   by the user.  When making this call the pointer needs to be unassociated.
   When the call returns, the pointer will now reference the original
   data block which was set during the previous call to
   <TT>ESMF_GridCompSetInternalState</TT>.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_GridCompSetInternalState</TT> will be accessible.

<P>
CAUTION: If you are working with a compiler that does not support Fortran 2018
   assumed-type dummy arguments, then this method does not have an explicit
   Fortran interface. In this case do not specify argument keywords when calling
   this method!

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>wrappedDataPointer</STRONG></DT>
<DD>A derived type (wrapper), containing only an unassociated pointer
     to the private data block.
     The framework will fill in the pointer. When this call returns, the
     pointer is set to the same address set during the last
     <TT>ESMF_GridCompSetInternalState</TT> call.
     This level of indirection is needed to reliably set and retrieve
     the data block no matter which architecture or compiler is used.
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034900000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_GridCompInitialize - Call the GridComp's initialize routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompInitialize(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user initialization routine for
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call initialize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_GridCompIsCreated - Check whether a GridComp object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_GridCompIsCreated(gridcomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_GridCompIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>gridcomp</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341100000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_GridCompIsPetLocal - Inquire if this GridComp is to execute on the calling PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive function ESMF_GridCompIsPetLocal(gridcomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_GridCompIsPetLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Inquire if this <TT>ESMF_GridComp</TT> object is to execute on the calling PET.

<P>
The return value is <TT>.true.</TT> if the component is to execute on the
   calling PET, <TT>.false.</TT> otherwise.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341200000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_GridCompPrint - Print GridComp information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompPrint(gridcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints information about an <TT>ESMF_GridComp</TT> to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to print.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341300000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_GridCompReadRestart - Call the GridComp's read restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompReadRestart(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user read restart routine for
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341400000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_GridCompRun - Call the GridComp's run routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompRun(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user run routine for
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341500000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_GridCompServiceLoop - Call the GridComp's service loop routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompServiceLoop(gridcomp, &amp;
     importState, exportState, clock, syncflag, port, timeout, timeoutFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: port
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the ServiceLoop routine for an <TT>ESMF_GridComp</TT>.
   This tries to establish a "component tunnel" between the <EM>actual</EM>
   Component (calling this routine) and a <TT>dual</TT> Component connecting to it
   through a matching SetServices call.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call service loop routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[port]</STRONG></DT>
<DD>In case a port number is provided, the "component tunnel" is established
     using sockets. The actual component side, i.e. the side that calls into
     <TT>ESMF_GridCompServiceLoop()</TT>, starts to listen on the specified port
     as the server. The valid port range is [1024, 65535].
     In case the <TT>port</TT> argument is <EM>not</EM> specified, the "component
     tunnel" is established within the same executable using local communication
     methods (e.g. MPI).
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait for communications
     with the dual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour.
     (NOTE: Currently this option is only available for socket based component
     tunnels.)
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341600000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_GridCompSet - Set or reset information about the GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSet(gridcomp, grid, gridList, &amp;
     mesh, meshList, locstream, locstreamList, xgrid, xgridList, &amp;
     config, configFile, clock, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Grid),        intent(in),  optional :: grid
     type(ESMF_Grid),        intent(in),  optional :: gridList(:)
     type(ESMF_Mesh),        intent(in),  optional :: mesh
     type(ESMF_Mesh),        intent(in),  optional :: meshList(:)
     type(ESMF_LocStream),   intent(in),  optional :: locstream
     type(ESMF_LocStream),   intent(in),  optional :: locstreamList(:)
     type(ESMF_XGrid),       intent(in),  optional :: xgrid
     type(ESMF_XGrid),       intent(in),  optional :: xgridList(:)
     type(ESMF_Config),      intent(in),  optional :: config
     character(len=*),       intent(in),  optional :: configFile
     type(ESMF_Clock),       intent(in),  optional :: clock
     character(len=*),       intent(in),  optional :: name
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added arguments <TT>gridList</TT>, <TT>mesh</TT>, <TT>meshList</TT>,
     <TT>locstream</TT>, <TT>locstreamList</TT>, <TT>xgrid</TT>, and <TT>xgridList</TT>.
     These arguments add support for holding references to multiple geom objects,
     either of the same type, or different type, in the same
     <TT>ESMF_GridComp</TT> object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets or resets information about an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to change.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Associate an <TT>ESMF_Grid</TT> object with the <TT>gridcomp</TT> component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>grid</TT> object.
     The <TT>grid</TT> argument is mutually exclusive with the <TT>gridList</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>grid</TT> nor <TT>gridList</TT> are provided,
     the <TT>ESMF_Grid</TT> association of the incoming <TT>gridcomp</TT>
     component remains unchanged.
   
</DD>
<DT><STRONG>[gridList]</STRONG></DT>
<DD>Associate a list of <TT>ESMF_Grid</TT> objects with the <TT>gridcomp</TT>
     component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>gridList</TT> object.
     The <TT>gridList</TT> argument is mutually exclusive with the <TT>grid</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>grid</TT> nor <TT>gridList</TT> are provided,
     the <TT>ESMF_Grid</TT> association of the incoming <TT>gridcomp</TT>
     component remains unchanged.
   
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>Associate an <TT>ESMF_Mesh</TT> object with the <TT>gridcomp</TT> component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>mesh</TT> object.
     The <TT>mesh</TT> argument is mutually exclusive with the <TT>meshList</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>mesh</TT> nor <TT>meshList</TT> are provided,
     the <TT>ESMF_Mesh</TT> association of the incoming <TT>gridcomp</TT>
     component remains unchanged.
   
</DD>
<DT><STRONG>[meshList]</STRONG></DT>
<DD>Associate a list of <TT>ESMF_Mesh</TT> objects with the <TT>gridcomp</TT>
     component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>meshList</TT> object.
     The <TT>meshList</TT> argument is mutually exclusive with the <TT>mesh</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>mesh</TT> nor <TT>meshList</TT> are provided,
     the <TT>ESMF_Mesh</TT> association of the incoming <TT>gridcomp</TT>
     component remains unchanged.
   
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>Associate an <TT>ESMF_LocStream</TT> object with the <TT>gridcomp</TT> component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>locstream</TT> object.
     The <TT>locstream</TT> argument is mutually exclusive with the
     <TT>locstreamList</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>locstream</TT> nor <TT>locstreamList</TT> are
     provided, the <TT>ESMF_LocStream</TT> association of the incoming
     <TT>gridcomp</TT> component remains unchanged.
   
</DD>
<DT><STRONG>[locstreamList]</STRONG></DT>
<DD>Associate a list of <TT>ESMF_LocStream</TT> objects with the <TT>gridcomp</TT>
     component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>locstreamList</TT> object.
     The <TT>locstreamList</TT> argument is mutually exclusive with the
     <TT>locstream</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>locstream</TT> nor <TT>locstreamList</TT> are
     provided, the <TT>ESMF_LocStream</TT> association of the incoming
     <TT>gridcomp</TT> component remains unchanged.
   
</DD>
<DT><STRONG>[xgrid]</STRONG></DT>
<DD>Associate an <TT>ESMF_XGrid</TT> object with the <TT>gridcomp</TT> component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>xgrid</TT> object.
     The <TT>xgrid</TT> argument is mutually exclusive with the <TT>xgridList</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>xgrid</TT> nor <TT>xgridList</TT> are provided,
     the <TT>ESMF_XGrid</TT> association of the incoming <TT>gridcomp</TT>
     component remains unchanged.
   
</DD>
<DT><STRONG>[xgridList]</STRONG></DT>
<DD>Associate a list of <TT>ESMF_XGrid</TT> objects with the <TT>gridcomp</TT>
     component.
     This is simply a convenience feature for the user. The ESMF library code
     does not access the <TT>xgridList</TT> object.
     The <TT>xgridList</TT> argument is mutually exclusive with the <TT>xgrid</TT>
     argument. If both arguments are provided, the routine will fail, and an
     error is returned in <TT>rc</TT>.
     By default, i.e. if neither <TT>xgrid</TT> nor <TT>xgridList</TT> are provided,
     the <TT>ESMF_XGrid</TT> association of the incoming <TT>gridcomp</TT>
     component remains unchanged.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>An already-created <TT>ESMF_Config</TT> object to be attached to the
     component.
     If both <TT>config</TT> and <TT>configFile</TT> arguments are specified,
     <TT>config</TT> takes priority.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>The filename of an <TT>ESMF_Config</TT> format file.
     If specified, a new <TT>ESMF_Config</TT> object is created and attached to the
     component. The <TT>configFile</TT> file is opened and associated
     with the new config object.
     If both <TT>config</TT> and <TT>configFile</TT> arguments are specified,
     <TT>config</TT> takes priority.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Set the private clock for this <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Set the name of the <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341700000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_GridCompSetEntryPoint - Set user routine as entry point for standard GridComp method</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompSetEntryPoint(gridcomp, methodflag, &amp;
     userRoutine, phase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(inout)         :: gridcomp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: phase
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Registers a user-supplied <TT>userRoutine</TT> as the entry point for one of the
   predefined Component <TT>methodflag</TT>s. After this call the <TT>userRoutine</TT>
   becomes accessible via the standard Component method API.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>methodflag</STRONG></DT>
<DD>One of a set of predefined Component methods - e.g.
     <TT>ESMF_METHOD_INITIALIZE</TT>, <TT>ESMF_METHOD_RUN</TT>,
     <TT>ESMF_METHOD_FINALIZE</TT>. See section <A HREF="node9.html#const:method"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a complete list of valid method options.

</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated for this Component
     <TT>method</TT>.  Argument types, intent and order must match
     the interface signature, and must not have the <TT>optional</TT> attribute.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>The <TT>phase</TT> number for multi-phase methods. For single phase
     methods the <TT>phase</TT> argument can be omitted. The default setting
     is 1.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341800000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_GridCompSetInternalState - Set private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetInternalState(gridcomp, wrappedDataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)             :: gridcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_GridComp</TT> at any time, but
   expected to be
   most useful when called during the registration process, or initialization.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by subsequent calls.
   When running multiple instantiations of an <TT>ESMF_GridComp</TT>,
   for example during
   ensemble runs, it may be simpler to maintain private data specific to
   each run with private data blocks.  A corresponding
   <TT>ESMF_GridCompGetInternalState</TT> call retrieves the data pointer.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_GridCompSetInternalState</TT> will be accessible.

<P>
CAUTION: If you are working with a compiler that does not support Fortran 2018
   assumed-type dummy arguments, then this method does not have an explicit
   Fortran interface. In this case do not specify argument keywords when calling
   this method!

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>wrappedDataPointer</STRONG></DT>
<DD>A pointer to the private data block, wrapped in a derived type which
     contains only a pointer to the block.  This level of indirection is
     needed to reliably set and retrieve the data block no matter which
     architecture or compiler is used.
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341900000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_GridCompSetServices - Call user routine to register GridComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompSetServices(gridcomp, &amp;
     userRoutine, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     interface
       subroutine userRoutine(gridcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="GridComp:SetServices"></A>   Call into user provided <TT>userRoutine</TT> which is responsible for
   setting Component's Initialize(), Run(), and Finalize() services.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The Component writer must supply a subroutine with the exact interface
     shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls
     to <TT>ESMF_GridCompSetEntryPoint()</TT> to preset callback routines for
     standard Component Initialize(), Run(), and Finalize() methods.

</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_GridCompSetServices - Call user routine through name lookup, to register GridComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCompSetServices()
   recursive subroutine ESMF_GridCompSetServicesShObj(gridcomp, userRoutine, &amp;
     sharedObj, userRoutineFound, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     logical,             intent(out), optional :: userRoutineFound
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.3.0r</STRONG></DT>
<DD>Added argument <TT>userRoutineFound</TT>.
                The new argument provides a way to test availability without
                causing error conditions.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="GridComp:SetServicesShObj"></A>   Call into a user provided routine which is responsible for setting
   Component's Initialize(), Run(), and Finalize() services. The named
   <TT>userRoutine</TT> must exist in the executable, or in the shared object
   specified by <TT>sharedObj</TT>. In the latter case all of the platform
   specific details about dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface
     shown for <TT>userRoutine</TT> below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface
         subroutine userRoutine(gridcomp, rc)
           type(ESMF_GridComp)  :: gridcomp   ! must not be optional
           integer, intent(out) :: rc         ! must not be optional
         end subroutine
       end interface
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls
     to <TT>ESMF_GridCompSetEntryPoint()</TT> to preset callback routines for
     standard Component Initialize(), Run(), and Finalize() methods.

</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRoutineFound]</STRONG></DT>
<DD>Report back whether the specified <TT>userRoutine</TT> was found and executed,
     or was not available. If this argument is present, not finding the
     <TT>userRoutine</TT> will not result in returning an error in <TT>rc</TT>.
     The default is to return an error if the <TT>userRoutine</TT> cannot be found.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342100000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_GridCompSetServices - Set to serve as Dual Component for an Actual Component</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCompSetServices()
   recursive subroutine ESMF_GridCompSetServicesComp(gridcomp, &amp;
     actualGridcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     type(ESMF_GridComp), intent(in)            :: actualGridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the services of a Gridded Component to serve a "dual" Component for an
   "actual" Component. The component tunnel is VM based.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Dual Gridded Component.
   
</DD>
<DT><STRONG>actualGridcomp</STRONG></DT>
<DD>Actual Gridded Component.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342200000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_GridCompSetServices - Set to serve as Dual Component for an Actual Component through sockets</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCompSetServices()
   recursive subroutine ESMF_GridCompSetServicesSock(gridcomp, port, &amp;
     server, timeout, timeoutFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     integer,             intent(in)            :: port
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: server
     integer,             intent(in),  optional :: timeout
     logical,             intent(out), optional :: timeoutFlag
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the services of a Gridded Component to serve a "dual" Component for an
   "actual" Component. The component tunnel is socket based.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Dual Gridded Component.
   
</DD>
<DT><STRONG>port</STRONG></DT>
<DD>Port number under which the actual component is being served. The valid
     port range is [1024, 65535].
   
</DD>
<DT><STRONG>[server]</STRONG></DT>
<DD>Server name where the actual component is being served. The default, i.e.
     if the <TT>server</TT> argument was not provided, is <TT>localhost</TT>.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342300000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_GridCompSetVM - Call user routine to set GridComp VM properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompSetVM(gridcomp, userRoutine, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     interface
       subroutine userRoutine(gridcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible
   for setting Component's VM properties.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The Component writer must supply a subroutine with the exact interface
     shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>
The subroutine, when called by the framework, is expected to use any of the
     <TT>ESMF_GridCompSetVMxxx()</TT> methods to set the properties of the VM
     associated with the Gridded Component.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342400000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_GridCompSetVM - Call user routine through name lookup, to set GridComp VM properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCompSetVM()
   recursive subroutine ESMF_GridCompSetVMShObj(gridcomp, userRoutine, &amp;
     sharedObj, userRoutineFound, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     logical,             intent(out), optional :: userRoutineFound
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.4.0</STRONG></DT>
<DD>Added argument <TT>userRoutineFound</TT>.
                The new argument provides a way to test availability without
                causing error conditions.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible
   for setting Component's VM properties. The named
   <TT>userRoutine</TT> must exist in the executable, or in the shared object
   specified by <TT>sharedObj</TT>. In the latter case all of the platform
   specific details about dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface
     shown for <TT>userRoutine</TT> below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface
         subroutine userRoutine(gridcomp, rc)
           type(ESMF_GridComp)  :: gridcomp    ! must not be optional
           integer, intent(out) :: rc          ! must not be optional
         end subroutine
       end interface
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
The subroutine, when called by the framework, is expected to use any of the
     <TT>ESMF_GridCompSetVMxxx()</TT> methods to set the properties of the VM
     associated with the Gridded Component.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRoutineFound]</STRONG></DT>
<DD>Report back whether the specified <TT>userRoutine</TT> was found and executed,
     or was not available. If this argument is present, not finding the
     <TT>userRoutine</TT> will not result in returning an error in <TT>rc</TT>.
     The default is to return an error if the <TT>userRoutine</TT> cannot be found.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342500000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_GridCompSetVMMaxPEs - Associate PEs with PETs in GridComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMaxPEs(gridcomp, &amp;
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, &amp;
     pthreadMinStackSize, openMpHandling, openMpNumThreads, &amp;
     forceChildPthreads, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(in),  optional :: pthreadMinStackSize
     character(*),        intent(in),  optional :: openMpHandling
     integer,             intent(in),  optional :: openMpNumThreads
     logical,             intent(in),  optional :: forceChildPthreads
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Attempts to associate up to <TT>maxPeCountPerPet</TT> PEs with each PET. Only
     PEs that are located on the same single system image (SSI) can be associated
     with the same PET. Within this constraint the call tries to get as close as
     possible to the number specified by <TT>maxPeCountPerPet</TT>.

<P>
The other constraint to this call is that the number of PEs is preserved.
     This means that the child Component in the end is associated with as many
     PEs as the parent Component provided to the child. The number of child PETs
     however is adjusted according to the above rule.

<P>
The typical use of <TT>ESMF_GridCompSetVMMaxPEs()</TT> is to allocate
     multiple PEs per PET in a Component for user-level threading, e.g. OpenMP.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPeCountPerPet]</STRONG></DT>
<DD>Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pthreadMinStackSize]</STRONG></DT>
<DD>Minimum stack size in byte of any child PET executing as Pthread. By default
     single threaded child PETs do <EM>not</EM> execute as Pthread, and their stack
     size is unaffected by this argument. However, for multi-threaded child PETs,
     or if <TT>forceChildPthreads</TT> is <TT>.true.</TT>, child PETs execute
     as Pthreads with their own private stack.

<P>
For cases where OpenMP threads
     are used by the user code, each thread allocates its own private stack. For
     all threads <EM>other</EM> than the master, the stack size is set via the 
     typical <TT>OMP_STACKSIZE</TT> environment variable mechanism. The PET itself,
     however, becomes the <EM>master</EM> of the OpenMP thread team, and is not
     affected by <TT>OMP_STACKSIZE</TT>. It is the master's stack that can be
     sized via the <TT>pthreadMinStackSize</TT> argument, and a large enough size
     is often critical.

<P>
When <TT>pthreadMinStackSize</TT>
     is absent, the default is to use the system default
     set by the <TT>limit</TT> or <TT>ulimit</TT> command. However, the stack of a
     Pthread cannot be unlimited, and a shell <EM>stacksize</EM> setting of
     <EM>unlimited</EM>, or any setting below the ESMF implemented minimum,
     will result in setting the stack size to 20MiB (the ESMF minimum).
     Depending on how much private data is used by the user code under
     the master thread, the default might be too small, and
     <TT>pthreadMinStackSize</TT> must be used to allocate sufficient stack space.
   
</DD>
<DT><STRONG>[openMpHandling]</STRONG></DT>
<DD>Handling of OpenMP threads. Supported options are:
     
<UL>
<LI>"<TT>none</TT>" - OpenMP handling is completely left to the user.
</LI>
<LI>"<TT>set</TT>"  - ESMF uses the <TT>omp_set_num_threads()</TT> API to set
                          the number of OpenMP threads in each team.
</LI>
<LI>"<TT>init</TT>" - ESMF sets the number of OpenMP threads in each team,
                          and triggers the instantiation of the team.
</LI>
<LI>"<TT>pin</TT>" (default) - ESMF sets the number of OpenMP threads in each team,
                          triggers the instantiation of the team, and pins each
                          OpenMP thread to the corresponding PE.
     
</LI>
</UL>
   
</DD>
<DT><STRONG>[openMpNumThreads]</STRONG></DT>
<DD>Number of OpenMP threads in each OpenMP thread team. This can be any
     positive number. By default, or if <TT>openMpNumThreads</TT> is negative, each
     PET sets the number of OpenMP threads to its local peCount.
   
</DD>
<DT><STRONG>[forceChildPthreads]</STRONG></DT>
<DD>For <TT>.true.</TT>, force each child PET to execute in its own Pthread.
     By default, <TT>.false.</TT>, single PETs spawned from a parent PET
     execute in the same thread (or MPI process) as the parent PET. Multiple
     child PETs spawned by the same parent PET always execute as their own
     Pthreads.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342600000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_GridCompSetVMMaxThreads - Set multi-threaded PETs in GridComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMaxThreads(gridcomp, &amp;
     maxPetCountPerVas, prefIntraProcess, prefIntraSsi, prefInterSsi, &amp;
     pthreadMinStackSize, forceChildPthreads, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPetCountPerVas
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(in),  optional :: pthreadMinStackSize
     logical,             intent(in),  optional :: forceChildPthreads
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Attempts to provide <TT>maxPetCountPerVas</TT> threaded PETs in each
     virtual address space (VAS). Only as many threaded PETs as there are PEs
     located on the single system image (SSI) can be associated with the VAS.
     Within this constraint the call tries to get as close as possible to the
     number specified by <TT>maxPetCountPerVas</TT>.

<P>
The other constraint to this call is that the number of PETs is preserved.
     This means that the child Component in the end is associated with as many
     PETs as the parent Component provided to the child. The threading level of
     the child PETs however is adjusted according to the above rule.

<P>
The typical use of <TT>ESMF_GridCompSetVMMaxThreads()</TT> is to run a
     Component multi-threaded with groups of PETs executing within a common
     virtual address space.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPetCountPerVas]</STRONG></DT>
<DD>Maximum number of threaded PETs in each virtual address space (VAS).
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pthreadMinStackSize]</STRONG></DT>
<DD>Minimum stack size in byte of any child PET executing as Pthread. By default
     single threaded child PETs do <EM>not</EM> execute as Pthread, and their stack
     size is unaffected by this argument. However, for multi-threaded child PETs,
     or if <TT>forceChildPthreads</TT> is <TT>.true.</TT>, child PETs execute
     as Pthreads with their own private stack.

<P>
For cases where OpenMP threads
     are used by the user code, each thread allocates its own private stack. For
     all threads <EM>other</EM> than the master, the stack size is set via the 
     typical <TT>OMP_STACKSIZE</TT> environment variable mechanism. The PET itself,
     however, becomes the <EM>master</EM> of the OpenMP thread team, and is not
     affected by <TT>OMP_STACKSIZE</TT>. It is the master's stack that can be
     sized via the <TT>pthreadMinStackSize</TT> argument, and a large enough size
     is often critical.

<P>
When <TT>pthreadMinStackSize</TT>
     is absent, the default is to use the system default
     set by the <TT>limit</TT> or <TT>ulimit</TT> command. However, the stack of a
     Pthread cannot be unlimited, and a shell <EM>stacksize</EM> setting of
     <EM>unlimited</EM>, or any setting below the ESMF implemented minimum,
     will result in setting the stack size to 20MiB (the ESMF minimum).
     Depending on how much private data is used by the user code under
     the master thread, the default might be too small, and
     <TT>pthreadMinStackSize</TT> must be used to allocate sufficient stack space.
   
</DD>
<DT><STRONG>[forceChildPthreads]</STRONG></DT>
<DD>For <TT>.true.</TT>, force each child PET to execute in its own Pthread.
     By default, <TT>.false.</TT>, single PETs spawned from a parent PET
     execute in the same thread (or MPI process) as the parent PET. Multiple
     child PETs spawned by the same parent PET always execute as their own
     Pthreads.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342700000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_GridCompSetVMMinThreads - Set a reduced threading level in GridComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMinThreads(gridcomp, &amp;
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, &amp;
     pthreadMinStackSize, forceChildPthreads, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(in),  optional :: pthreadMinStackSize
     logical,             intent(in),  optional :: forceChildPthreads
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Reduces the number of threaded PETs in each VAS. The <TT>max</TT> argument
     may be specified to limit the maximum number of PEs that a single PET
     can be associated with.

<P>
Several constraints apply: 1) the number of PEs cannot change, 2) PEs
     cannot migrate between single system images (SSIs), 3) the number of PETs
     cannot increase, only decrease, 4) PETs cannot migrate between virtual
     address spaces (VASs), nor can VASs migrate between SSIs.

<P>
The typical use of <TT>ESMF_GridCompSetVMMinThreads()</TT> is to run a
     Component across a set of single-threaded PETs.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPeCountPerPet]</STRONG></DT>
<DD>Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pthreadMinStackSize]</STRONG></DT>
<DD>Minimum stack size in byte of any child PET executing as Pthread. By default
     single threaded child PETs do <EM>not</EM> execute as Pthread, and their stack
     size is unaffected by this argument. However, for multi-threaded child PETs,
     or if <TT>forceChildPthreads</TT> is <TT>.true.</TT>, child PETs execute
     as Pthreads with their own private stack.

<P>
For cases where OpenMP threads
     are used by the user code, each thread allocates its own private stack. For
     all threads <EM>other</EM> than the master, the stack size is set via the 
     typical <TT>OMP_STACKSIZE</TT> environment variable mechanism. The PET itself,
     however, becomes the <EM>master</EM> of the OpenMP thread team, and is not
     affected by <TT>OMP_STACKSIZE</TT>. It is the master's stack that can be
     sized via the <TT>pthreadMinStackSize</TT> argument, and a large enough size
     is often critical.

<P>
When <TT>pthreadMinStackSize</TT>
     is absent, the default is to use the system default
     set by the <TT>limit</TT> or <TT>ulimit</TT> command. However, the stack of a
     Pthread cannot be unlimited, and a shell <EM>stacksize</EM> setting of
     <EM>unlimited</EM>, or any setting below the ESMF implemented minimum,
     will result in setting the stack size to 20MiB (the ESMF minimum).
     Depending on how much private data is used by the user code under
     the master thread, the default might be too small, and
     <TT>pthreadMinStackSize</TT> must be used to allocate sufficient stack space.
   
</DD>
<DT><STRONG>[forceChildPthreads]</STRONG></DT>
<DD>For <TT>.true.</TT>, force each child PET to execute in its own Pthread.
     By default, <TT>.false.</TT>, single PETs spawned from a parent PET
     execute in the same thread (or MPI process) as the parent PET. Multiple
     child PETs spawned by the same parent PET always execute as their own
     Pthreads.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342800000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_GridCompValidate - Check validity of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompValidate(gridcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Currently all this method does is to check that the <TT>gridcomp</TT>
   was created.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to validate.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342900000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_GridCompWait - Wait for a GridComp to return</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompWait(gridcomp, syncflag, &amp;
     timeout, timeoutFlag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Sync_Flag), intent(in),  optional :: syncflag
     integer,              intent(in),  optional :: timeout
     logical,              intent(out), optional :: timeoutFlag
     integer,              intent(out), optional :: userRc
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
When executing asynchronously, wait for an <TT>ESMF_GridComp</TT> to return.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to wait for.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds the actual component is allowed to execute
     a previously invoked component method before it must communicate back to
     the dual component. If the actual component does not communicate back in
     the specified time, a timeout condition is raised on the dual side (this
     side). The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040343000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_GridCompWriteRestart - Call the GridComp's write restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompWriteRestart(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user write restart routine for
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<H1><A NAME="SECTION04040000000000000000">
<SPAN CLASS="arabic">18</SPAN> CplComp Class</A>
</H1>

<H2><A NAME="SECTION04041000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:CplComp"></A>
<P>
In a large, multi-component application such as a weather 
forecasting or climate prediction system running within ESMF, 
physical domains and major system functions are represented 
as Gridded Components 
(see Section <A HREF="#sec:GridComp">17.1</A>).  A Coupler Component, or 
<TT>ESMF_CplComp</TT>, arranges and executes the data 
transformations between the Gridded Components.  Ideally, 
Coupler Components should contain all the information 
about inter-component communication for an application.
This enables the Gridded Components in the application to be 
used in multiple contexts; that is, used in different coupled 
configurations without changes to their source code. 
For example, the same atmosphere might in one case be coupled 
to an ocean in a hurricane prediction model, and to a 
data assimilation system for numerical weather prediction in
another.  A single Coupler Component can couple 
two or more Gridded Components.

<P>
Like Gridded Components, Coupler Components have two parts, one
that is provided by the user and another that is part of the 
framework.  The user-written portion of the software is the coupling
code necessary for a particular exchange between Gridded Components.  
This portion of the Coupler Component code must be divided into 
separately callable initialize, run, and finalize methods.  The 
interfaces for these methods are prescribed by ESMF.

<P>
The term &ldquo;user-written&rdquo; is somewhat misleading here, since within 
a Coupler Component the user can leverage ESMF infrastructure 
software for regridding, redistribution, lower-level communications, 
calendar management, and other functions.  However, ESMF is unlikely 
to offer all the software necessary to customize a data transfer
between Gridded Components.  For instance, ESMF does not currently 
offer tools for unit tranformations or time averaging operations, 
so users must manage those operations themselves.

<P>
The second part of a Coupler Component is the <TT>ESMF_CplComp</TT>
derived type within ESMF.  The user must create one of these types
to represent a specific coupling function, such as the regular
transfer of data between a data assimilation system and an 
atmospheric model.  <A NAME="tex2html21"
  HREF="footnode.html#foot8307"><SUP><SPAN CLASS="arabic">2</SPAN></SUP></A>
<P>
The user-written part of a Coupler Component is associated with an
<TT>ESMF_CplComp</TT> derived type through a routine called 
<TT>ESMF_SetServices()</TT>.
This is a routine that the user must write and declare public.
Inside the <TT>ESMF_SetServices()</TT> routine the user must call 
<TT>ESMF_SetEntryPoint()</TT> methods that associate a standard ESMF 
operation with the name of the corresponding Fortran subroutine in 
their user code.  For example, a user routine called &ldquo;couplerInit&rdquo;
might be associated with the standard initialize routine in a 
Coupler Component.

<H2><A NAME="SECTION04042000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A Coupler Component manages the transformation of data between Components.
It contains a list of State objects and the operations needed to
make them compatible, including such things as regridding and unit conversion.
Coupler Components are user-written, following prescribed ESMF interfaces
and, wherever desired, using ESMF infrastructure tools.

<P>

<P>

<P>

<H3><A NAME="SECTION04042100000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Implement a user-code <TT>SetServices</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplSetServ"></A>
<P>
Every <TT>ESMF_CplComp</TT> is required to provide and document
   a public set services routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an 
   <TT>ESMF_CplComp</TT> as the first argument, and 
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set services routine must call the ESMF method 
   <TT>ESMF_CplCompSetEntryPoint()</TT> to
   register with the framework what user-code subroutines should be called
   to initialize, run, and finalize the component.  There are
   additional routines which can be registered as well, for checkpoint
   and restart functions.

<P>
Note that the actual subroutines being registered do not have to be
   public to this module; only the set services routine itself must
   be available to be used by other code. 

<P>
<PRE>
    ! Example Coupler Component
    module ESMF_CouplerEx
    
    ! ESMF Framework module
    use ESMF
    implicit none
    public CPL_SetServices

    contains

    subroutine CPL_SetServices(comp, rc)
      type(ESMF_CplComp)    :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional

      ! Set the entry points for standard ESMF Component methods
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_INITIALIZE, &amp;
                          userRoutine=CPL_Init, rc=rc)
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_RUN, &amp;
                          userRoutine=CPL_Run, rc=rc)
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_FINALIZE, &amp;
                          userRoutine=CPL_Final, rc=rc)

      rc = ESMF_SUCCESS
    end subroutine
</PRE>

<P>

<P>

<H3><A NAME="SECTION04042200000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Implement a user-code <TT>Initialize</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplInitialize"></A>
<P>
When a higher level component is ready to begin using an 
   <TT>ESMF_CplComp</TT>, it will call its initialize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
At initialization time the component can allocate data space, open
   data files, set up initial conditions; anything it needs to do to
   prepare to run.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine CPL_Init(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp               ! must not be optional
      type(ESMF_State)      :: importState        ! must not be optional
      type(ESMF_State)      :: exportState        ! must not be optional
      type(ESMF_Clock)      :: clock              ! must not be optional
      integer, intent(out)  :: rc                 ! must not be optional

      print *, "Coupler Init starting"
    
      ! Add whatever code here needed
      ! Precompute any needed values, fill in any inital values
      !  needed in Import States

      rc = ESMF_SUCCESS

      print *, "Coupler Init returning"
   
    end subroutine CPL_Init
</PRE>

<P>

<P>

<H3><A NAME="SECTION04042300000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Implement a user-code <TT>Run</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplRun"></A>
<P>
During the execution loop, the run routine may be called many times.
   Each time it should read data from the <TT>importState</TT>, use the
   <TT>clock</TT> to determine what the current time is in the calling
   component, compute new values or process the data, 
   and produce any output and place it in the <TT>exportState</TT>.

<P>
When a higher level component is ready to use the <TT>ESMF_CplComp</TT>
   it will call its run routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
It is expected that this is where the bulk of the model computation
   or data analysis will occur.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine CPL_Run(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp              ! must not be optional
      type(ESMF_State)      :: importState       ! must not be optional
      type(ESMF_State)      :: exportState       ! must not be optional
      type(ESMF_Clock)      :: clock             ! must not be optional
      integer, intent(out)  :: rc                ! must not be optional

      print *, "Coupler Run starting"

      ! Add whatever code needed here to transform Export state data
      !  into Import states for the next timestep.  

      rc = ESMF_SUCCESS

      print *, "Coupler Run returning"

    end subroutine CPL_Run
</PRE>

<P>

<P>

<H3><A NAME="SECTION04042400000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Implement a user-code <TT>Finalize</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplFinalize"></A>
<P>
At the end of application execution, each <TT>ESMF_CplComp</TT> should
   deallocate data space, close open files, and flush final results.
   These functions should be placed in a finalize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned.

<P>
<PRE>
    subroutine CPL_Final(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp                ! must not be optional
      type(ESMF_State)      :: importState         ! must not be optional
      type(ESMF_State)      :: exportState         ! must not be optional
      type(ESMF_Clock)      :: clock               ! must not be optional
      integer, intent(out)  :: rc                  ! must not be optional

      print *, "Coupler Final starting"
    
      ! Add whatever code needed here to compute final values and
      !  finish the computation.

      rc = ESMF_SUCCESS

      print *, "Coupler Final returning"
   
    end subroutine CPL_Final
</PRE>

<P>

<P>

<H3><A NAME="SECTION04042500000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Implement a user-code <TT>SetVM</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplSetVM"></A>
<P>
Every <TT>ESMF_CplComp</TT> can optionally provide and document
   a public set vm routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_CplComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set vm routine is the only place where the child component can
   use the <TT>ESMF_CplCompSetVMMaxPEs()</TT>, or
   <TT>ESMF_CplCompSetVMMaxThreads()</TT>, or 
   <TT>ESMF_CplCompSetVMMinThreads()</TT> call to modify aspects of its own VM.

<P>
A component's VM is started up right before its set services routine is
   entered. <TT>ESMF_CplCompSetVM()</TT> is executing in the parent VM, and must
   be called <EM>before</EM> <TT>ESMF_CplCompSetServices()</TT>. 

<P>
<PRE>
    subroutine GComp_SetVM(comp, rc)
      type(ESMF_CplComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional
      
      type(ESMF_VM) :: vm
      logical :: pthreadsEnabled
      
      ! Test for Pthread support, all SetVM calls require it
      call ESMF_VMGetGlobal(vm, rc=rc)
      call ESMF_VMGet(vm, pthreadsEnabledFlag=pthreadsEnabled, rc=rc)

      if (pthreadsEnabled) then
        ! run PETs single-threaded
        call ESMF_CplCompSetVMMinThreads(comp, rc=rc)
      endif

      rc = ESMF_SUCCESS

    end subroutine

    end module ESMF_CouplerEx
</PRE>

<P>


<H2><A NAME="SECTION04043000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No optional arguments.</B> User-written routines called by SetServices,
and registered for Initialize, Run and Finalize, <EM>must not</EM> declare any
of the arguments as optional.

<P>
</LI>
<LI><B>No Transforms.</B>  Components must exchange data through 
<TT>ESMF_State</TT> objects.  The input data are available at the time 
the component code is called, and data to be returned to another 
component are available when that code returns.  

<P>
</LI>
<LI><B>No automatic unit conversions.</B>  The ESMF framework does not 
currently contain tools for performing unit conversions, operations that 
are fairly standard within Coupler Components.

<P>
</LI>
<LI><B>No accumulator.</B>  The ESMF does not have an accumulator tool, to
perform time averaging of fields for coupling.  This is likely to be developed
in the near term.

<P>
</LI>
</OL>

<H2><A NAME="SECTION04044000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04044100000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_CplCompAssignment(=) - CplComp assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     cplcomp1 = cplcomp2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp) :: cplcomp1
     type(ESMF_CplComp) :: cplcomp2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign cplcomp1 as an alias to the same ESMF CplComp object in memory
     as cplcomp2. If cplcomp2 is invalid, then cplcomp1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>cplcomp1</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>cplcomp2</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044200000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_CplCompOperator(==) - CplComp equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (cplcomp1 == cplcomp2) then ... endif
               OR
     result = (cplcomp1 == cplcomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in) :: cplcomp1
     type(ESMF_CplComp), intent(in) :: cplcomp2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether cplcomp1 and cplcomp2 are valid aliases to the same ESMF
     CplComp object in memory. For a more general comparison of two ESMF CplComps,
     going beyond the simple alias test, the ESMF_CplCompMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>cplcomp1</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>cplcomp2</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044300000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_CplCompOperator(/=) - CplComp not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (cplcomp1 /= cplcomp2) then ... endif
               OR
     result = (cplcomp1 /= cplcomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in) :: cplcomp1
     type(ESMF_CplComp), intent(in) :: cplcomp2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether cplcomp1 and cplcomp2 are <I>not</I> valid aliases to the
     same ESMF CplComp object in memory. For a more general comparison of two ESMF
     CplComps, going beyond the simple alias test, the ESMF_CplCompMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>cplcomp1</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>cplcomp2</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044400000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_CplCompCreate - Create a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive function ESMF_CplCompCreate(config, configFile, &amp;
     clock, petList, contextflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_CplComp) :: ESMF_CplCompCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Config),       intent(in),  optional :: config
     character(len=*),        intent(in),  optional :: configFile
     type(ESMF_Clock),        intent(in),  optional :: clock
     integer,                 intent(in),  optional :: petList(:)
     type(ESMF_Context_Flag), intent(in),  optional :: contextflag
     character(len=*),        intent(in),  optional :: name
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This interface creates an <TT>ESMF_CplComp</TT> object. By default, a
   separate VM context will be created for each component.  This implies
   creating a new MPI communicator and allocating additional memory to
   manage the VM resources. When running on a large number of processors,
   creating a separate VM for each component could be both time and memory
   inefficient.  If the application is sequential, i.e., each component is
   running on all the PETs of the global VM, it will be more efficient to use
   the global VM instead of creating a new one.  This can be done by setting
   <TT>contextflag</TT> to ESMF_CONTEXT_PARENT_VM.

<P>
The return value is the new <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[config]</STRONG></DT>
<DD>An already-created <TT>ESMF_Config</TT> object to be attached to the newly
     created component.
     If both <TT>config</TT> and <TT>configFile</TT> arguments are specified,
     <TT>config</TT> takes priority.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>The filename of an <TT>ESMF_Config</TT> format file.
     If specified, a new <TT>ESMF_Config</TT> object is created and attached to the
     newly created component. The <TT>configFile</TT> file is opened and associated
     with the new config object.
     If both <TT>config</TT> and <TT>configFile</TT> arguments are specified,
     <TT>config</TT> takes priority.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Component-specific <TT>ESMF_Clock</TT>.  This clock is available to be
     queried and updated by the new <TT>ESMF_CplComp</TT> as it chooses.
     This should
     not be the parent component clock, which should be maintained and passed
     down to the initialize/run/finalize routines separately.

</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List of parent <TT>PET</TT>s given to the created child component by the
     parent component. If <TT>petList</TT> is not specified all of the
     parent <TT>PET</TT>s will be given to the child component. The order of
     PETs in <TT>petList</TT> determines how the child local PETs refer back to
     the parent PETs.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Specify the component's VM context. The default context is
     <TT>ESMF_CONTEXT_OWN_VM</TT>. See section <A HREF="node9.html#const:contextflag"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for a
     complete list of valid flags.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the newly-created <TT>ESMF_CplComp</TT>.  This name can be altered
     from within the <TT>ESMF_CplComp</TT> code once the initialization routine
     is called.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044500000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_CplCompDestroy - Release resources associated with a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompDestroy(cplcomp, &amp;
     timeout, timeoutFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)          :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),   optional :: timeout
     logical,            intent(out),  optional :: timeoutFlag
     integer,            intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_CplComp</TT>, releasing the resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Release all resources associated with this <TT>ESMF_CplComp</TT>
     and mark the object as invalid.  It is an error to pass this
     object into any other routines after being destroyed.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044600000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_CplCompFinalize - Call the CplComp's finalize routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompFinalize(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user-supplied finalization routine for
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to call finalize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044700000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_CplCompGet - Get CplComp information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompGet(cplcomp, configIsPresent, config, &amp;
     configFileIsPresent, configFile, clockIsPresent, clock, localPet, &amp;
     petCount, contextflag, currentMethod, currentPhase, vmIsPresent, &amp;
     vm, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),      intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(out), optional :: configIsPresent
     type(ESMF_Config),       intent(out), optional :: config
     logical,                 intent(out), optional :: configFileIsPresent
     character(len=*),        intent(out), optional :: configFile
     logical,                 intent(out), optional :: clockIsPresent
     type(ESMF_Clock),        intent(out), optional :: clock
     integer,                 intent(out), optional :: localPet
     integer,                 intent(out), optional :: petCount
     type(ESMF_Context_Flag), intent(out), optional :: contextflag
     type(ESMF_Method_Flag),  intent(out), optional :: currentMethod
     integer,                 intent(out), optional :: currentPhase
     logical,                 intent(out), optional :: vmIsPresent
     type(ESMF_VM),           intent(out), optional :: vm
     character(len=*),        intent(out), optional :: name
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get information about an <TT>ESMF_CplComp</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object being queried.
   
</DD>
<DT><STRONG>[configIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>config</TT> was set in CplComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Return the associated Config.
     It is an error to query for the Config if none is associated with
     the CplComp. If unsure, get <TT>configIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[configFileIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>configFile</TT> was set in CplComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Return the associated configuration filename.
     It is an error to query for the configuration filename if none is associated with
     the CplComp. If unsure, get <TT>configFileIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[clockIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>clock</TT> was set in CplComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Return the associated Clock.
     It is an error to query for the Clock if none is associated with
     the CplComp. If unsure, get <TT>clockIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[localPet]</STRONG></DT>
<DD>Return the local PET id within the <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>[petCount]</STRONG></DT>
<DD>Return the number of PETs in the the <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Return the <TT>ESMF_Context_Flag</TT> for this <TT>ESMF_CplComp</TT>.
     See section <A HREF="node9.html#const:contextflag"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for a complete list of valid flags.
   
</DD>
<DT><STRONG>[currentMethod]</STRONG></DT>
<DD>Return the current <TT>ESMF_Method_Flag</TT> of the <TT>ESMF_CplComp</TT> execution.
     See section <A HREF="node9.html#const:method"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>  for a complete list of valid options.
   
</DD>
<DT><STRONG>[currentPhase]</STRONG></DT>
<DD>Return the current <TT>phase</TT> of the <TT>ESMF_CplComp</TT> execution.
   
</DD>
<DT><STRONG>[vmIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>vm</TT> was set in CplComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Return the associated VM.
     It is an error to query for the VM if none is associated with
     the CplComp. If unsure, get <TT>vmIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Return the name of the <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044800000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_CplCompGetInternalState - Get private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompGetInternalState(cplcomp, wrappedDataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)              :: cplcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_CplComp</TT> at any time after
   <TT>ESMF_CplCompSetInternalState</TT> has been called.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by this call.
   When running multiple instantiations of an <TT>ESMF_CplComp</TT>,
   for example during ensemble runs,
   it may be simpler to maintain private data specific to
   each run with private data blocks.  A corresponding
   <TT>ESMF_CplCompSetInternalState</TT> call sets the data pointer to
   this block, and this call retrieves the data pointer.
   Note that the <TT>wrappedDataPointer</TT> argument needs to be a derived type
   which contains only a pointer of the type of the data block defined
   by the user.  When making this call the pointer needs to be unassociated.
   When the call returns, the pointer will now reference the original
   data block which was set during the previous call to
   <TT>ESMF_CplCompSetInternalState</TT>.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_CplCompSetInternalState</TT> will be accessible.

<P>
CAUTION: If you are working with a compiler that does not support Fortran 2018
   assumed-type dummy arguments, then this method does not have an explicit
   Fortran interface. In this case do not specify argument keywords when calling
   this method!

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>wrappedDataPointer</STRONG></DT>
<DD>A derived type (wrapper), containing only an unassociated pointer
     to the private data block.
     The framework will fill in the pointer. When this call returns, the
     pointer is set to the same address set during the last
     <TT>ESMF_CplCompSetInternalState</TT> call.
     This level of indirection is needed to reliably set and retrieve
     the data block no matter which architecture or compiler is used.
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044900000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_CplCompInitialize - Call the CplComp's initialize routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompInitialize(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user initialization routine for
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call initialize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_CplCompIsCreated - Check whether a CplComp object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_CplCompIsCreated(cplcomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_CplCompIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>cplcomp</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441100000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_CplCompIsPetLocal - Inquire if this CplComp is to execute on the calling PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive function ESMF_CplCompIsPetLocal(cplcomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_CplCompIsPetLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Inquire if this <TT>ESMF_CplComp</TT> object is to execute on the calling PET.

<P>
The return value is <TT>.true.</TT> if the component is to execute on the
   calling PET, <TT>.false.</TT> otherwise.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441200000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_CplCompPrint - Print CplComp information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompPrint(cplcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints information about an <TT>ESMF_CplComp</TT> to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to print.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441300000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_CplCompReadRestart - Call the CplComp's read restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompReadRestart(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user read restart routine for
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441400000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_CplCompRun - Call the CplComp's run routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompRun(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user run routine for
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441500000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_CplCompServiceLoop - Call the CplComp's service loop routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompServiceLoop(cplcomp, &amp;
     importState, exportState, clock, syncflag, port, timeout, timeoutFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: port
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the ServiceLoop routine for an <TT>ESMF_CplComp</TT>.
   This tries to establish a "component tunnel" between the <EM>actual</EM>
   Component (calling this routine) and a <TT>dual</TT> Component connecting to it
   through a matching SetServices call.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call service loop routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[port]</STRONG></DT>
<DD>In case a port number is provided, the "component tunnel" is established
     using sockets. The actual component side, i.e. the side that calls into
     <TT>ESMF_CplCompServiceLoop()</TT>, starts to listen on the specified port
     as the server. The valid port range is [1024, 65535].
     In case the <TT>port</TT> argument is <EM>not</EM> specified, the "component
     tunnel" is established within the same executable using local communication
     methods (e.g. MPI).
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait for communications
     with the dual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour.
     (NOTE: Currently this option is only available for socket based component
     tunnels.)
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441600000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_CplCompSet - Set or reset information about the CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSet(cplcomp, config, configFile, &amp;
     clock, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Config),  intent(in),  optional :: config
     character(len=*),   intent(in),  optional :: configFile
     type(ESMF_Clock),   intent(in),  optional :: clock
     character(len=*),   intent(in),  optional :: name
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets or resets information about an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to change.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Set the name of the <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>An already-created <TT>ESMF_Config</TT> object to be attached to the
     component.
     If both <TT>config</TT> and <TT>configFile</TT> arguments are specified,
     <TT>config</TT> takes priority.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>The filename of an <TT>ESMF_Config</TT> format file.
     If specified, a new <TT>ESMF_Config</TT> object is created and attached to the
     component. The <TT>configFile</TT> file is opened and associated
     with the new config object.
     If both <TT>config</TT> and <TT>configFile</TT> arguments are specified,
     <TT>config</TT> takes priority.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Set the private clock for this <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441700000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_CplCompSetEntryPoint - Set user routine as entry point for standard Component method</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompSetEntryPoint(cplcomp, methodflag, &amp;
     userRoutine, phase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(inout)         :: cplcomp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     interface
       subroutine userRoutine(cplcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: phase
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Registers a user-supplied <TT>userRoutine</TT> as the entry point for one of the
   predefined Component <TT>methodflag</TT>s. After this call the <TT>userRoutine</TT>
   becomes accessible via the standard Component method API.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>methodflag</STRONG></DT>
<DD>One of a set of predefined Component methods - e.g.
     <TT>ESMF_METHOD_INITIALIZE</TT>, <TT>ESMF_METHOD_RUN</TT>,
     <TT>ESMF_METHOD_FINALIZE</TT>. See section <A HREF="node9.html#const:method"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a complete list of valid method options.

</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated for this <TT>methodflag</TT>.
     The Component writer must supply a subroutine with the exact interface
     shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>The <TT>phase</TT> number for multi-phase methods. For single phase
     methods the <TT>phase</TT> argument can be omitted. The default setting
     is 1.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441800000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_CplCompSetInternalState - Set private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetInternalState(cplcomp, wrappedDataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)              :: cplcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_CplComp</TT> at any time, but
   expected to be
   most useful when called during the registration process, or initialization.
   Since init, run, and finalize must be separate subroutines data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by subsequent calls.
   When running multiple instantiations of an <TT>ESMF_CplComp</TT>,
   for example during
   ensemble runs, it may be simpler to maintain private data specific to
   each run with private data blocks.  A corresponding
   <TT>ESMF_CplCompGetInternalState</TT> call retrieves the data pointer.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_CplCompSetInternalState</TT> will be accessible.

<P>
CAUTION: If you are working with a compiler that does not support Fortran 2018
   assumed-type dummy arguments, then this method does not have an explicit
   Fortran interface. In this case do not specify argument keywords when calling
   this method!

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>wrappedDataPointer</STRONG></DT>
<DD>A pointer to the private data block, wrapped in a derived type which
     contains only a pointer to the block.  This level of indirection is
     needed to reliably set and retrieve the data block no matter which
     architecture or compiler is used.
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441900000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_CplCompSetServices - Call user routine to register CplComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompSetServices(cplcomp, userRoutine, &amp;
      userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: userRc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="CplComp:SetServices"></A>   Call into user provided <TT>userRoutine</TT> which is responsible
   for setting Component's Initialize(), Run(), and Finalize() services.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The Component writer must supply a subroutine with the exact interface
    shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
    must not be declared as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls to
    <TT>ESMF_CplCompSetEntryPoint()</TT> to preset callback routines for standard
    Component Initialize(), Run(), and Finalize() methods.

</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_CplCompSetServices - Call user routine through name lookup, to register CplComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_CplCompSetServices()
   recursive subroutine ESMF_CplCompSetServicesShObj(cplcomp, userRoutine, &amp;
     sharedObj, userRoutineFound, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     logical,             intent(out), optional :: userRoutineFound
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.3.0r</STRONG></DT>
<DD>Added argument <TT>userRoutineFound</TT>.
                The new argument provides a way to test availability without
                causing error conditions.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="CplComp:SetServicesShObj"></A>   Call into a user provided routine which is responsible for setting
   Component's Initialize(), Run(), and Finalize() services. The named
   <TT>userRoutine</TT> must exist in the executable, or in the shared object
   specified by <TT>sharedObj</TT>. In the latter case all of the platform
   specific details about dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface
     shown for <TT>userRoutine</TT> below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface
         subroutine userRoutine(cplcomp, rc)
           type(ESMF_CplComp)   :: cplcomp    ! must not be optional
           integer, intent(out) :: rc         ! must not be optional
         end subroutine
       end interface
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive
     calls to <TT>ESMF_CplCompSetEntryPoint()</TT> to preset callback routines for
     standard Component Initialize(), Run(), and Finalize() methods.

</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRoutineFound]</STRONG></DT>
<DD>Report back whether the specified <TT>userRoutine</TT> was found and executed,
     or was not available. If this argument is present, not finding the
     <TT>userRoutine</TT> will not result in returning an error in <TT>rc</TT>.
     The default is to return an error if the <TT>userRoutine</TT> cannot be found.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442100000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_CplCompSetServices - Set to serve as Dual Component for an Actual Component</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_CplCompSetServices()
   recursive subroutine ESMF_CplCompSetServicesComp(cplcomp, &amp;
     actualCplcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
     type(ESMF_CplComp), intent(in)            :: actualCplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the services of a Coupler Component to serve a "dual" Component for an
   "actual" Component. The component tunnel is VM based.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Dual Coupler Component.
   
</DD>
<DT><STRONG>actualCplcomp</STRONG></DT>
<DD>Actual Coupler Component.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442200000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_CplCompSetServices - Set to serve as Dual Component for an Actual Component through sockets</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_CplCompSetServices()
   recursive subroutine ESMF_CplCompSetServicesSock(cplcomp, port, &amp;
     server, timeout, timeoutFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
     integer,            intent(in)            :: port
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),   intent(in),  optional :: server
     integer,            intent(in),  optional :: timeout
     logical,            intent(out), optional :: timeoutFlag
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the services of a Coupler Component to serve a "dual" Component for an
   "actual" Component. The component tunnel is socket based.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Dual Coupler Component.
   
</DD>
<DT><STRONG>port</STRONG></DT>
<DD>Port number under which the actual component is being served. The valid
     port range is [1024, 65535].
   
</DD>
<DT><STRONG>[server]</STRONG></DT>
<DD>Server name where the actual component is being served. The default, i.e.
     if the <TT>server</TT> argument was not provided, is <TT>localhost</TT>.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442300000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_CplCompSetVM - Call user routine to set CplComp VM properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompSetVM(cplcomp, userRoutine, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: userRc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible
   for setting Component's VM properties.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The Component writer must supply a subroutine with the exact interface
     shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>
The subroutine, when called by the framework, is expected to use any of the
     <TT>ESMF_CplCompSetVMxxx()</TT> methods to set the properties of the VM
     associated with the Coupler Component.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442400000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_CplCompSetVM - Call user routine through name lookup, to set CplComp VM properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_CplCompSetVM()
   recursive subroutine ESMF_CplCompSetVMShObj(cplcomp, userRoutine, &amp;
     sharedObj, userRoutineFound, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     logical,             intent(out), optional :: userRoutineFound
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.4.0</STRONG></DT>
<DD>Added argument <TT>userRoutineFound</TT>.
                The new argument provides a way to test availability without
                causing error conditions.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible
   for setting Component's VM properties. The named
   <TT>userRoutine</TT> must exist in the executable, or in the shared object
   specified by <TT>sharedObj</TT>. In the latter case all of the platform
   specific details about dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface
     shown for <TT>userRoutine</TT> below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface
         subroutine userRoutine(cplcomp, rc)
           type(ESMF_CplComp)   :: cplcomp     ! must not be optional
           integer, intent(out) :: rc          ! must not be optional
         end subroutine
       end interface
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
The subroutine, when called by the framework, is expected to use any of the
     <TT>ESMF_CplCompSetVMxxx()</TT> methods to set the properties of the VM
     associated with the Coupler Component.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRoutineFound]</STRONG></DT>
<DD>Report back whether the specified <TT>userRoutine</TT> was found and executed,
     or was not available. If this argument is present, not finding the
     <TT>userRoutine</TT> will not result in returning an error in <TT>rc</TT>.
     The default is to return an error if the <TT>userRoutine</TT> cannot be found.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442500000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_CplCompSetVMMaxPEs - Associate PEs with PETs in CplComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMaxPEs(cplcomp, &amp;
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, &amp;
     pthreadMinStackSize, forceChildPthreads, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(in),  optional :: pthreadMinStackSize
     logical,             intent(in),  optional :: forceChildPthreads
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Attempts to associate up to <TT>maxPeCountPerPet</TT> PEs with each PET. Only
     PEs that are located on the same single system image (SSI) can be associated
     with the same PET. Within this constraint the call tries to get as close as
     possible to the number specified by <TT>maxPeCountPerPet</TT>.

<P>
The other constraint to this call is that the number of PEs is preserved.
     This means that the child Component in the end is associated with as many
     PEs as the parent Component provided to the child. The number of child PETs
     however is adjusted according to the above rule.

<P>
The typical use of <TT>ESMF_CplCompSetVMMaxPEs()</TT> is to allocate
     multiple PEs per PET in a Component for user-level threading, e.g. OpenMP.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPeCountPerPet]</STRONG></DT>
<DD>Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pthreadMinStackSize]</STRONG></DT>
<DD>Minimum stack size in byte of any child PET executing as Pthread. By default
     single threaded child PETs do <EM>not</EM> execute as Pthread, and their stack
     size is unaffected by this argument. However, for multi-threaded child PETs,
     or if <TT>forceChildPthreads</TT> is <TT>.true.</TT>, child PETs execute
     as Pthreads with their own private stack.

<P>
For cases where OpenMP threads
     are used by the user code, each thread allocates its own private stack. For
     all threads <EM>other</EM> than the master, the stack size is set via the 
     typical <TT>OMP_STACKSIZE</TT> environment variable mechanism. The PET itself,
     however, becomes the <EM>master</EM> of the OpenMP thread team, and is not
     affected by <TT>OMP_STACKSIZE</TT>. It is the master's stack that can be
     sized via the <TT>pthreadMinStackSize</TT> argument, and a large enough size
     is often critical.

<P>
When <TT>pthreadMinStackSize</TT>
     is absent, the default is to use the system default
     set by the <TT>limit</TT> or <TT>ulimit</TT> command. However, the stack of a
     Pthread cannot be unlimited, and a shell <EM>stacksize</EM> setting of
     <EM>unlimited</EM>, or any setting below the ESMF implemented minimum,
     will result in setting the stack size to 20MiB (the ESMF minimum).
     Depending on how much private data is used by the user code under
     the master thread, the default might be too small, and
     <TT>pthreadMinStackSize</TT> must be used to allocate sufficient stack space.
   
</DD>
<DT><STRONG>[forceChildPthreads]</STRONG></DT>
<DD>For <TT>.true.</TT>, force each child PET to execute in its own Pthread.
     By default, <TT>.false.</TT>, single PETs spawned from a parent PET
     execute in the same thread (or MPI process) as the parent PET. Multiple
     child PETs spawned by the same parent PET always execute as their own
     Pthreads.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442600000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_CplCompSetVMMaxThreads - Set multi-threaded PETs in CplComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMaxThreads(cplcomp, &amp;
     maxPetCountPerVas, prefIntraProcess, prefIntraSsi, prefInterSsi, &amp;
     pthreadMinStackSize, forceChildPthreads, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPetCountPerVas
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(in),  optional :: pthreadMinStackSize
     logical,             intent(in),  optional :: forceChildPthreads
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Attempts to provide <TT>maxPetCountPerVas</TT> threaded PETs in each
     virtual address space (VAS). Only as many threaded PETs as there are PEs
     located on the single system image (SSI) can be associated with the VAS.
     Within this constraint the call tries to get as close as possible to the
     number specified by <TT>maxPetCountPerVas</TT>.

<P>
The other constraint to this call is that the number of PETs is preserved.
     This means that the child Component in the end is associated with as many
     PETs as the parent Component provided to the child. The threading level of
     the child PETs however is adjusted according to the above rule.

<P>
The typical use of <TT>ESMF_CplCompSetVMMaxThreads()</TT> is to run a
     Component multi-threaded with groups of PETs executing within a common
     virtual address space.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPetCountPerVas]</STRONG></DT>
<DD>Maximum number of threaded PETs in each virtual address space (VAS).
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pthreadMinStackSize]</STRONG></DT>
<DD>Minimum stack size in byte of any child PET executing as Pthread. By default
     single threaded child PETs do <EM>not</EM> execute as Pthread, and their stack
     size is unaffected by this argument. However, for multi-threaded child PETs,
     or if <TT>forceChildPthreads</TT> is <TT>.true.</TT>, child PETs execute
     as Pthreads with their own private stack.

<P>
For cases where OpenMP threads
     are used by the user code, each thread allocates its own private stack. For
     all threads <EM>other</EM> than the master, the stack size is set via the 
     typical <TT>OMP_STACKSIZE</TT> environment variable mechanism. The PET itself,
     however, becomes the <EM>master</EM> of the OpenMP thread team, and is not
     affected by <TT>OMP_STACKSIZE</TT>. It is the master's stack that can be
     sized via the <TT>pthreadMinStackSize</TT> argument, and a large enough size
     is often critical.

<P>
When <TT>pthreadMinStackSize</TT>
     is absent, the default is to use the system default
     set by the <TT>limit</TT> or <TT>ulimit</TT> command. However, the stack of a
     Pthread cannot be unlimited, and a shell <EM>stacksize</EM> setting of
     <EM>unlimited</EM>, or any setting below the ESMF implemented minimum,
     will result in setting the stack size to 20MiB (the ESMF minimum).
     Depending on how much private data is used by the user code under
     the master thread, the default might be too small, and
     <TT>pthreadMinStackSize</TT> must be used to allocate sufficient stack space.
   
</DD>
<DT><STRONG>[forceChildPthreads]</STRONG></DT>
<DD>For <TT>.true.</TT>, force each child PET to execute in its own Pthread.
     By default, <TT>.false.</TT>, single PETs spawned from a parent PET
     execute in the same thread (or MPI process) as the parent PET. Multiple
     child PETs spawned by the same parent PET always execute as their own
     Pthreads.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442700000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_CplCompSetVMMinThreads - Set a reduced threading level in CplComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMinThreads(cplcomp, &amp;
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, &amp;
     pthreadMinStackSize, forceChildPthreads, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(in),  optional :: pthreadMinStackSize
     logical,             intent(in),  optional :: forceChildPthreads
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Reduces the number of threaded PETs in each VAS. The <TT>max</TT> argument
     may be specified to limit the maximum number of PEs that a single PET
     can be associated with.

<P>
Several constraints apply: 1) the number of PEs cannot change, 2) PEs
     cannot migrate between single system images (SSIs), 3) the number of PETs
     cannot increase, only decrease, 4) PETs cannot migrate between virtual
     address spaces (VASs), nor can VASs migrate between SSIs.

<P>
The typical use of <TT>ESMF_CplCompSetVMMinThreads()</TT> is to run a
     Component across a set of single-threaded PETs.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPeCountPerPet]</STRONG></DT>
<DD>Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[pthreadMinStackSize]</STRONG></DT>
<DD>Minimum stack size in byte of any child PET executing as Pthread. By default
     single threaded child PETs do <EM>not</EM> execute as Pthread, and their stack
     size is unaffected by this argument. However, for multi-threaded child PETs,
     or if <TT>forceChildPthreads</TT> is <TT>.true.</TT>, child PETs execute
     as Pthreads with their own private stack.

<P>
For cases where OpenMP threads
     are used by the user code, each thread allocates its own private stack. For
     all threads <EM>other</EM> than the master, the stack size is set via the 
     typical <TT>OMP_STACKSIZE</TT> environment variable mechanism. The PET itself,
     however, becomes the <EM>master</EM> of the OpenMP thread team, and is not
     affected by <TT>OMP_STACKSIZE</TT>. It is the master's stack that can be
     sized via the <TT>pthreadMinStackSize</TT> argument, and a large enough size
     is often critical.

<P>
When <TT>pthreadMinStackSize</TT>
     is absent, the default is to use the system default
     set by the <TT>limit</TT> or <TT>ulimit</TT> command. However, the stack of a
     Pthread cannot be unlimited, and a shell <EM>stacksize</EM> setting of
     <EM>unlimited</EM>, or any setting below the ESMF implemented minimum,
     will result in setting the stack size to 20MiB (the ESMF minimum).
     Depending on how much private data is used by the user code under
     the master thread, the default might be too small, and
     <TT>pthreadMinStackSize</TT> must be used to allocate sufficient stack space.
   
</DD>
<DT><STRONG>[forceChildPthreads]</STRONG></DT>
<DD>For <TT>.true.</TT>, force each child PET to execute in its own Pthread.
     By default, <TT>.false.</TT>, single PETs spawned from a parent PET
     execute in the same thread (or MPI process) as the parent PET. Multiple
     child PETs spawned by the same parent PET always execute as their own
     Pthreads.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442800000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_CplCompValidate - Ensure the CplComp is internally consistent</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompValidate(cplcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Currently all this method does is to check that the <TT>cplcomp</TT>
   was created.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to validate.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442900000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_CplCompWait - Wait for a CplComp to return</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompWait(cplcomp, syncflag, &amp;
     timeout, timeoutFlag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Sync_Flag), intent(in),  optional :: syncflag
     integer,              intent(in),  optional :: timeout
     logical,              intent(out), optional :: timeoutFlag
     integer,              intent(out), optional :: userRc
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
When executing asynchronously, wait for an <TT>ESMF_CplComp</TT> to return.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to wait for.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds the actual component is allowed to execute
     a previously invoked component method before it must communicate back to
     the dual component. If the actual component does not communicate back in
     the specified time, a timeout condition is raised on the dual side (this
     side). The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040443000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_CplCompWriteRestart - Call the CplComp's write restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompWriteRestart(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, timeout, timeoutFlag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(in),    optional :: timeout
     logical,              intent(out),   optional :: timeoutFlag
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added argument <TT>timeout</TT>.
                Added argument <TT>timeoutFlag</TT>.
                The new arguments provide access to the fault-tolerant component
                features.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the associated user write restart routine for
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     importState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     exportState argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The
     clock argument in the user code cannot be optional.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node9.html#const:sync"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[timeout]</STRONG></DT>
<DD>The maximum period in seconds that this call will wait in communications
     with the actual component, before returning with a timeout condition.
     The default is 3600, i.e. 1 hour. The <TT>timeout</TT> argument is only
     supported for connected dual components.
   
</DD>
<DT><STRONG>[timeoutFlag]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if the timeout was reached, <TT>.false.</TT> otherwise.
     If <TT>timeoutFlag</TT> was <EM>not</EM> provided, a timeout condition will lead
     to a return code of <TT>rc &#92;= ESMF_SUCCESS</TT>. Otherwise the
     return value of <TT>timeoutFlag</TT> is the sole indicator of a timeout
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<H1><A NAME="SECTION04050000000000000000">
<SPAN CLASS="arabic">19</SPAN> SciComp Class</A>
</H1>

<H2><A NAME="SECTION04051000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:SciComp"></A>
<P>
In Earth system modeling, a particular piece of code representing a physical 
domain, such as an atmospheric model or an ocean model, is typically 
implemented as an ESMF Gridded Component, or <TT>ESMC_GridComp</TT>.  
However, there are times when physical domains, or realms, need to be 
represented, but aren't actual pieces of code, or software.  These domains 
can be implemented as ESMF Science Components, or <TT>ESMC_SciComp</TT>.

<P>
Unlike Gridded and Coupler Components, Science Components are not associated 
with software; they don't include execution routines such as initialize, 
run and finalize.  The main purpose of a Science Component 
is to provide a container for Attributes within a Component hierarchy. 

<H2><A NAME="SECTION04052000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A Science Component is a container object intended to represent scientific
domains, or realms, in an Earth Science Model.  It's primary purpose is to 
provide a means for representing Component metadata within a hierarchy of
Components, and it does this by being a container for Attributes as well 
as other Components.

<P>

<P>

<P>

<H3><A NAME="SECTION04052100000000000000"></A>
   <A NAME="sec:component:usage:scicomp"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Use ESMF_SciComp and Attach Attributes
</H3>

<P>
This example illustrates the use of the ESMF_SciComp to attach Attributes
   within a Component hierarchy.  The hierarchy includes Coupler, Gridded,
   and Science Components and Attributes are attached to the Science Components.
   For demonstrable purposes, we'll add some CIM Component attributes to
   the Gridded Component.

<P>
Create the top 2 levels of the Component hierarchy.  This example creates
      a parent Coupler Component and 2 Gridded Components as children.

<P>
<PRE>
      ! Create top-level Coupler Component
      cplcomp = ESMF_CplCompCreate(name="coupler_component", rc=rc)

      ! Create Gridded Component for Atmosphere
      atmcomp = ESMF_GridCompCreate(name="Atmosphere", rc=rc)

      ! Create Gridded Component for Ocean
      ocncomp = ESMF_GridCompCreate(name="Ocean", rc=rc)
</PRE>

<P>
Now add CIM Attribute packages to the Component.  Also, add
      a CIM Component Properties package, to contain two custom attributes.

<P>
<PRE>
      convCIM = 'CIM 1.5'
      purpComp = 'ModelComp'
      purpProp = 'CompProp'
      purpField = 'Inputs'
      purpPlatform = 'Platform'

      convISO = 'ISO 19115'
      purpRP = 'RespParty'
      purpCitation = 'Citation'

      ! Add CIM Attribute package to the Science Component
      call ESMF_AttributeAdd(atmcomp, convention=convCIM, &amp;
        purpose=purpComp, attpack=attpack, rc=rc)
</PRE>

<P>
The Attribute package can also be retrieved in a multi-Component
      setting like this:

<P>
<PRE>
      call ESMF_AttributeGetAttPack(atmcomp, convCIM, purpComp, &amp;
                                    attpack=attpack, rc=rc)
</PRE>

<P>
Now, add some CIM Component attributes to the Atmosphere Grid Component.

<P>
<PRE>
      !
      ! Top-level model component attributes, set on gridded component
      !
      call ESMF_AttributeSet(atmcomp, 'ShortName', 'EarthSys_Atmos', &amp;
        attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(atmcomp, 'LongName', &amp;
        'Earth System High Resolution Global Atmosphere Model', &amp;
        attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(atmcomp, 'Description', &amp;
        'EarthSys brings together expertise from the global ' // &amp;
        'community in a concerted effort to develop coupled ' // &amp;
        'climate models with increased horizontal resolutions.  ' // &amp;
        'Increasing the horizontal resolution of coupled climate ' // &amp;
        'models will allow us to capture climate processes and ' // &amp;
        'weather systems in much greater detail.', &amp;
        attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(atmcomp, 'Version', '2.0', &amp;
        attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(atmcomp, 'ReleaseDate', '2009-01-01T00:00:00Z', &amp;
        attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(atmcomp, 'ModelType', 'aerosol', &amp;
        attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AttributeSet(atmcomp, 'URL', &amp;
        'www.earthsys.org', attpack=attpack, rc=rc)
</PRE>

<P>
Now create a set of Science Components as a children of the Atmosphere 
      Gridded Component. The hierarchy is as follows:
      
<UL>
<LI>Atmosphere
         
<UL>
<LI>AtmosDynamicalCore
            
<UL>
<LI>AtmosAdvection
            
</LI>
</UL>
</LI>
<LI>AtmosRadiation
         
</LI>
</UL>
</LI>
</UL>
      After each Component is created, we need to link it with its parent
      Component.  We then add some standard CIM Component properties as well 
      as Scientific Properties to each of these components.

<P>
<PRE>
    !
    ! Atmosphere Dynamical Core Science Component
    !
    dc_scicomp = ESMF_SciCompCreate(name="AtmosDynamicalCore", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeAdd(dc_scicomp,  &amp;
                           convention=convCIM, purpose=purpComp, &amp;
                           attpack=attpack, rc=rc)

    call ESMF_AttributeSet(dc_scicomp, "ShortName", "AtmosDynamicalCore", &amp;
                           attpack=attpack, rc=rc)
    call ESMF_AttributeSet(dc_scicomp, "LongName", &amp;
                           "Atmosphere Dynamical Core", &amp;
                           attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
    purpSci = 'SciProp'

    dc_sciPropAtt(1) = 'TopBoundaryCondition'
    dc_sciPropAtt(2) = 'HeatTreatmentAtTop'
    dc_sciPropAtt(3) = 'WindTreatmentAtTop'

    call ESMF_AttributeAdd(dc_scicomp,  &amp;
                           convention=convCIM, purpose=purpSci, &amp;
                           attrList=dc_sciPropAtt, &amp;
                           attpack=attpack, rc=rc)

    call ESMF_AttributeSet(dc_scicomp, 'TopBoundaryCondition', &amp;
                           'radiation boundary condition', &amp;
                           attpack=attpack, rc=rc)
    call ESMF_AttributeSet(dc_scicomp, 'HeatTreatmentAtTop', &amp;
                           'some heat treatment', &amp;
                           attpack=attpack, rc=rc)
    call ESMF_AttributeSet(dc_scicomp, 'WindTreatmentAtTop', &amp;
                           'some wind treatment', &amp;
                           attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
    !
    ! Atmosphere Advection Science Component
    !
    adv_scicomp = ESMF_SciCompCreate(name="AtmosAdvection", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeAdd(adv_scicomp,  &amp;
                           convention=convCIM, purpose=purpComp, &amp;
                           attpack=attpack, rc=rc)

    call ESMF_AttributeSet(adv_scicomp, "ShortName", "AtmosAdvection", &amp;
                           attpack=attpack, rc=rc)
    call ESMF_AttributeSet(adv_scicomp, "LongName", "Atmosphere Advection", &amp;
                           attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
    adv_sciPropAtt(1) = 'TracersSchemeName'
    adv_sciPropAtt(2) = 'TracersSchemeCharacteristics'
    adv_sciPropAtt(3) = 'MomentumSchemeName'

    call ESMF_AttributeAdd(adv_scicomp,  &amp;
                           convention=convCIM, purpose=purpSci, &amp;
                           attrList=adv_sciPropAtt, &amp;
                           attpack=attpack, rc=rc)

    call ESMF_AttributeSet(adv_scicomp, 'TracersSchemeName', 'Prather', &amp;
                           attpack=attpack, rc=rc)
    call ESMF_AttributeSet(adv_scicomp, 'TracersSchemeCharacteristics', &amp;
                           'modified Euler', &amp;
                           attpack=attpack, rc=rc)
    call ESMF_AttributeSet(adv_scicomp, 'MomentumSchemeName', 'Van Leer', &amp;
                           attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
    !
    ! Atmosphere Radiation Science Component
    !
    rad_scicomp = ESMF_SciCompCreate(name="AtmosRadiation", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_AttributeAdd(rad_scicomp,  &amp;
                           convention=convCIM, purpose=purpComp, &amp;
                           attpack=attpack, rc=rc)

    call ESMF_AttributeSet(rad_scicomp, "ShortName", "AtmosRadiation", &amp;
                           attpack=attpack, rc=rc)
    call ESMF_AttributeSet(rad_scicomp, "LongName", &amp;
                           "Atmosphere Radiation", &amp;
                           attpack=attpack, rc=rc)
</PRE>

<P>
<PRE>
    rad_sciPropAtt(1) = 'LongwaveSchemeType'
    rad_sciPropAtt(2) = 'LongwaveSchemeMethod'

    call ESMF_AttributeAdd(rad_scicomp,  &amp;
                           convention=convCIM, purpose=purpSci, &amp;
                           attrList=rad_sciPropAtt, &amp;
                           attpack=attpack, rc=rc)

    call ESMF_AttributeSet(rad_scicomp, &amp;
                           'LongwaveSchemeType', &amp;
                           'wide-band model', &amp;
                           attpack=attpack, rc=rc)
    call ESMF_AttributeSet(rad_scicomp, &amp;
                           'LongwaveSchemeMethod', &amp;
                           'two-stream', &amp;
                           attpack=attpack, rc=rc)
</PRE>

<P>
Finally, destroy all of the Components.

<P>
<PRE>
      call ESMF_SciCompDestroy(rad_scicomp, rc=rc)
      call ESMF_SciCompDestroy(adv_scicomp, rc=rc)
      call ESMF_SciCompDestroy(dc_scicomp, rc=rc)
      call ESMF_GridCompDestroy(atmcomp, rc=rc)
      call ESMF_GridCompDestroy(ocncomp, rc=rc)
      call ESMF_CplCompDestroy(cplcomp, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION04053000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>None.</B> 

<P>
</LI>
</OL>

<H2><A NAME="SECTION04054000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04054100000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_SciCompAssignment(=) - SciComp assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     scicomp1 = scicomp2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp) :: scicomp1
     type(ESMF_SciComp) :: scicomp2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign scicomp1 as an alias to the same ESMF SciComp object in memory
     as scicomp2. If scicomp2 is invalid, then scicomp1 will be equally 
     invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>scicomp1</STRONG></DT>
<DD>The <TT>ESMF_SciComp</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>scicomp2</STRONG></DT>
<DD>The <TT>ESMF_SciComp</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04054200000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_SciCompOperator(==) - SciComp equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (scicomp1 == scicomp2) then ... endif
               OR
     result = (scicomp1 == scicomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp), intent(in) :: scicomp1
     type(ESMF_SciComp), intent(in) :: scicomp2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether scicomp1 and scicomp2 are valid aliases to the same ESMF
     SciComp object in memory. For a more general comparison of two ESMF 
     SciComps, going beyond the simple alias test, the ESMF_SciCompMatch() 
     function (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>scicomp1</STRONG></DT>
<DD>The <TT>ESMF_SciComp</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>scicomp2</STRONG></DT>
<DD>The <TT>ESMF_SciComp</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04054300000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_SciCompOperator(/=) - SciComp not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (scicomp1 /= scicomp2) then ... endif
               OR
     result = (scicomp1 /= scicomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp), intent(in) :: scicomp1
     type(ESMF_SciComp), intent(in) :: scicomp2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether scicomp1 and scicomp2 are <I>not</I> valid aliases to the
     same ESMF SciComp object in memory. For a more general comparison of two 
     ESMF SciComps, going beyond the simple alias test, the ESMF_SciCompMatch()
     function (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>scicomp1</STRONG></DT>
<DD>The <TT>ESMF_SciComp</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>scicomp2</STRONG></DT>
<DD>The <TT>ESMF_SciComp</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04054400000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_SciCompCreate - Create a SciComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive function ESMF_SciCompCreate(name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_SciComp) :: ESMF_SciCompCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),        intent(in),    optional :: name
     integer,                 intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This interface creates an <TT>ESMF_SciComp</TT> object. 
   The return value is the new <TT>ESMF_SciComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the newly-created <TT>ESMF_SciComp</TT>.  This name can be altered
     from within the <TT>ESMF_SciComp</TT> code once the initialization routine
     is called.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04054500000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_SciCompDestroy - Release resources associated with a SciComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_SciCompDestroy(scicomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp), intent(inout)           :: scicomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out),  optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_SciComp</TT>, releasing the resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>scicomp</STRONG></DT>
<DD>Release all resources associated with this <TT>ESMF_SciComp</TT>
     and mark the object as invalid.  It is an error to pass this
     object into any other routines after being destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04054600000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_SciCompGet - Get SciComp information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_SciCompGet(scicomp, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp),       intent(in)            :: scicomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),         intent(out), optional :: name
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get information about an <TT>ESMF_SciComp</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>scicomp</STRONG></DT>
<DD>The <TT>ESMF_SciComp</TT> object being queried.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Return the name of the <TT>ESMF_SciComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04054700000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_SciCompIsCreated - Check whether a SciComp object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_SciCompIsCreated(scicomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_SciCompIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp), intent(in)            :: scicomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>scicomp</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>scicomp</STRONG></DT>
<DD><TT>ESMF_SciComp</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04054800000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_SciCompPrint - Print SciComp information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_SciCompPrint(scicomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp), intent(in)             :: scicomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints information about an <TT>ESMF_SciComp</TT> to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
   <DL>
<DT><STRONG>scicomp</STRONG></DT>
<DD><TT>ESMF_SciComp</TT> to print.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04054900000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_SciCompSet - Set or reset information about the SciComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_SciCompSet(scicomp, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp), intent(inout)          :: scicomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: name
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets or resets information about an <TT>ESMF_SciComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>scicomp</STRONG></DT>
<DD><TT>ESMF_SciComp</TT> to change.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Set the name of the <TT>ESMF_SciComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040541000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_SciCompValidate - Check validity of a SciComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_SciCompValidate(scicomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_SciComp), intent(in)             :: scicomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Currently all this method does is to check that the <TT>scicomp</TT>
   was created.

<P>
The arguments are:
   <DL>
<DT><STRONG>scicomp</STRONG></DT>
<DD><TT>ESMF_SciComp</TT> to validate.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<H1><A NAME="SECTION04060000000000000000">
<SPAN CLASS="arabic">20</SPAN> Fault-tolerant Component Tunnel</A>
</H1>

<H2><A NAME="SECTION04061000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:CompTunnel"></A>
<P>
For ensemble runs with many ensemble members, fault-tolerance becomes an issue of very critical practical impact. The meaning of <EM>fault-tolerance</EM> in this context refers to the ability of an ensemble application to continue with normal execution after one or more ensemble members have experienced catastrophic conditions, from which they cannot recover. ESMF implements this type of fault-tolerance on the Component level via a <B>timeout</B> paradigm: A timeout parameter is specified for all interactions that need to be fault-tolerant. When a connection to a component times out, maybe because it has become inaccessible due to some catastrophic condition, the driver application can react to this condition, for example by not further interacting with the component during the otherwise normal continuation of the model execution.

<P>
The fault-tolerant connection between a driver application and a Component is established through a <B>Component Tunnel</B>. There are two sides to a Component Tunnel: the "actual" side is where the component is actually executing, and the "dual" side is the portal through which the Component becomes accessible on the driver side. Both the actual and the dual side of a Component Tunnel are implemented in form of a regular ESMF Gridded or Coupler Component.

<P>
Component Tunnels between Components can be based on a number of low level implementations. The only implementation that currently provides fault-tolerance is <EM>socket</EM> based. In this case an actual Component typically runs as a separate executable, listening to a specific port for connections from the driver application. The dual Component is created on the driver side. It connects to the actual Component during the SetServices() call.

<H2><A NAME="SECTION04062000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A Component Tunnel connects a <EM>dual</EM> Component to an <EM>actual</EM> Component. This connection can be based on a number of different low level implementations, e.g. VM-based or socket-based. VM-based Component Tunnels require that both dual and actual Components run within the same application (i.e. execute under the same MPI_COMM_WORLD). Fault-tolerant Component Tunnels require that dual and actual Components run in separate applications, under different MPI_COMM_WORLD communicators. This mode is implemented in the socket-based Component Tunnels.

<P>

<P>

<P>

<H3><A NAME="SECTION04062100000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating an <EM>actual</EM> Component</A>
</H3>

<P>
<A NAME="sec:CompTunnelActualCreate"></A>
<P>
The creation process of an <EM>actual</EM> Gridded Component, which will become
   one of the two end points of a Component Tunnel, is identical to the creation
   of a regular Gridded Component. On the actual side, an actual Component is 
   very similar to a regular Component. Here the actual Component is created
   with a custom <TT>petList</TT>. 

<P>
<PRE>
  petList = (/0,1,2/)
  actualComp = ESMF_GridCompCreate(petList=petList, name="actual", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04062200000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Creating a <EM>dual</EM> Component</A>
</H3>

<P>
<A NAME="sec:CompTunnelDualCreate"></A>
<P>
The same way an actual Component appears as a regular Component in
   the context of the actual side application, a <EM>dual</EM> Component
   is created as a regular Component on the dual side.
   A dual Gridded Component with custom <TT>petList</TT> is created using the
   regular create call. 

<P>
<PRE>
  petList = (/4,3,5/)
  dualComp = ESMF_GridCompCreate(petList=petList, name="dual", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04062300000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Setting up the <EM>actual</EM> side of a Component Tunnel</A>
</H3>

<P>
<A NAME="sec:CompTunnelActualSide"></A>
<P>
After creation, the regular procedure for registering the standard Component
   methods is followed for the actual Gridded Component. 

<P>
<PRE>
  call ESMF_GridCompSetServices(actualComp, userRoutine=setservices, &amp;
    userRc=userRc, rc=rc)
</PRE>

<P>
So far the <TT>actualComp</TT> object is no different from a regular Gridded
   Component. In order to turn it into the <EM>actual</EM> end point of a Component
   Tunnel the <TT>ServiceLoop()</TT> method is called. Here the socket-based
   implementation is chosen. 

<P>
<PRE>
  call ESMF_GridCompServiceLoop(actualComp, port=61010, timeout=20, rc=rc)
</PRE>

<P>
This call opens the actual side of the Component Tunnel in form of a
   socket-based server, listening on <TT>port</TT> 61010. The <TT>timeout</TT> argument
   specifies how long the actual side will wait for the dual side
   to connect, before the actual side returns with a time out condition. The
   time out is set to 20 seconds.

<P>
At this point, before a dual Component connects to the other side of the 
   Component Tunnel, it is
   possible to manually connect to the waiting actual Component. This can be
   useful when debugging connection issues. A convenient tool for this is the 
   standard <TT>telnet</TT> application. Below is a transcript of such a connection.
   The manually typed commands are separate from the previous responses by a 
   blank line.

<P>
<PRE>
   $ telnet localhost 61010
   Trying 127.0.0.1...
   Connected to localhost.
   Escape character is '^]'.
   Hello from ESMF Actual Component server!
  
   date
   Tue Apr  3 21:53:03 2012
   
   version
   ESMF_VERSION_STRING: 5.3.0
</PRE>

<P>
If at any point the <TT>telnet</TT> session is manually shut down, the 
   <TT>ServiceLoop()</TT> on the actual side will return with an error condition. 
   The clean way to
   disconnect the <TT>telnet</TT> session, and to have the <TT>ServiceLoop()</TT>
   wait for a new connection, e.g. from a dual Component, is to send the
   <TT>reconnect</TT> command. This will automatically shut down the <TT>telnet</TT>
   connection.

<P>
<PRE>
   reconnect
   Actual Component server will reconnect now!
   Connection closed by foreign host.
   $
</PRE>

<P>
At this point the actual Component is back in listening mode, with a time out
   of 20 seconds, as specified during the ServiceLoop() call.

<P>
Before moving on to the dual side of the GridComp based Component Tunnel 
   example, it should be pointed out that the exact same procedure is used to
   set up the actual side of a <EM>CplComp</EM> based Component Tunnel. Assuming
   that <TT>actualCplComp</TT> is a CplComp object for which SetServices has already
   been called, the actual side uses <TT>ESMF_CplCompServiceLoop()</TT> to start
   listening for connections from the dual side.

<P>
<PRE>
  call ESMF_CplCompServiceLoop(actualCplComp, port=61011, timeout=2, &amp;
    timeoutFlag=timeoutFlag, rc=rc)
</PRE>

<P>
Here the <TT>timeoutFlag</TT> is specified in order to prevent the expected
   time-out condition to be indicated through the return code. Instead, when
   <TT>timeoutFlag</TT> is present, the return code is still <TT>ESMF_SUCCESS</TT>, 
   but <TT>timeoutFlag</TT> is set to <TT>.true.</TT> when a time-out occurs. 

<P>

<H3><A NAME="SECTION04062400000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Setting up the <EM>dual</EM> side of a Component Tunnel</A>
</H3>

<P>
<A NAME="sec:CompTunnelDualSide"></A>
<P>
On the dual side, the <TT>dualComp</TT> object needs to be connected to the
   actual Component in order to complete the Component Tunnel. Instead of
   registering standard Component methods locally, a special variant of the
   <TT>SetServices()</TT> call is used to connect to the actual Component. 

<P>
<PRE>
  call ESMF_GridCompSetServices(dualComp, port=61010, server="localhost", &amp;
    timeout=10, timeoutFlag=timeoutFlag, rc=rc)
</PRE>

<P>
The <TT>port</TT> and <TT>server</TT> arguments are used to connect to the desired
   actual Component. The time out of 10 seconds ensures that if the actual
   Component is not available, a time out condition is returned instead of
   resulting in a hang. The <TT>timeoutFlag</TT> argument further absorbs the time
   out condition, either returning as <TT>.true.</TT> or <TT>.false.</TT>. In this mode
   the standard <TT>rc</TT> will indicate success even when a time out condition
   was reached. 

<P>

<H3><A NAME="SECTION04062500000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Invoking standard Component methods through a Component Tunnel</A>
</H3>

<P>
<A NAME="sec:CompTunnelInvoking"></A>
<P>
Once a Component Tunnel is established, the actual Component is fully under
   the control of the dual Component. A standard Component method invoked on the
   dual Component is not executed by the dual Component itself, but by the 
   actual Component instead. In fact, it is the entry points registered with
   the actual Component that are executed when standard methods are invoked on
   the dual Component. The connected <TT>dualComp</TT> object serves as a portal
   through which the connected <TT>actualComp</TT> becomes accessible on the dual
   side.

<P>
Typically the first standard method called is the <TT>CompInitialize()</TT>
   routine. 

<P>
<PRE>
  call ESMF_GridCompInitialize(dualComp, timeout=10, timeoutFlag=timeoutFlag, &amp;
    userRc=userRc, rc=rc)
</PRE>

<P>
Again, the <TT>timeout</TT> argument serves to prevent the dual side from 
   hanging if the actual Component application has experienced a catastrophic
   condition and is no longer available, or takes longer than expected. The
   presence of the <TT>timeoutFlag</TT> allows time out conditions to be caught
   gracefully, so the dual side can deal with it in an orderly fashion, instead
   of triggering an application abort due to an error condition.

<P>
The <TT>CompRun()</TT> and <TT>CompFinalize()</TT> methods follow the same format.

<P>
<PRE>
  call ESMF_GridCompRun(dualComp, timeout=10, timeoutFlag=timeoutFlag, &amp;
    userRc=userRc, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompFinalize(dualComp, timeout=10, timeoutFlag=timeoutFlag, &amp;
    userRc=userRc, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04062600000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> The non-blocking option to invoke standard Component methods through a Component Tunnel</A>
</H3>

<P>
<A NAME="sec:CompTunnelInvokingNonblocking"></A>
<P>
Standard Component methods called on a connected dual Component are executed
   on the actual side, across the PETs of the actual Component. By default the
   dual Component PETs are blocked until the actual Component has finished
   executing the invoked Component method, or until a time out condition has been
   reached. In many practical applications a more loose synchronization between
   dual and actual Components is useful. Having the PETs of a dual
   Component return immediately from a standard Component method allows multiple
   dual Component, on the same PETs, to control multiple actual Components. 
   If the actual Components are executing in separate executables, or the same 
   executable but on exclusive sets of PETs, they can execute concurrently, even
   with the controlling dual Components all running on the same PETs.
   The non-blocking dual side regains control over the actual Component by 
   synchronizing through the CompWait() call.

<P>
Any of the standard Component methods can be called in non-blocking mode
   by setting the optional <TT>syncflag</TT> argument to 
   <TT>ESMF_SYNC_NONBLOCKING</TT>.  

<P>
<PRE>
  call ESMF_GridCompInitialize(dualComp, syncflag=ESMF_SYNC_NONBLOCKING, rc=rc)
</PRE>

<P>
<EM>If</EM> communication between the dual and the actual Component was successful, 
   this call will return immediately on all of the dual Component PETs, while the
   actual Component continues to execute the invoked Component method.
   However, if the dual Component has difficulties reaching the actual Component,
   the call will block on all dual PETs until successful contact was made, or the
   default time out (3600 seconds, i.e. 1 hour) has been reached. In most cases a 
   shorter time out condition is desired with the non-blocking option, as shown
   below.

<P>
First the dual Component must wait for the outstanding method. 

<P>
<PRE>
  call ESMF_GridCompWait(dualComp, rc=rc)
</PRE>

<P>
Now the same non-blocking CompInitialize() call is issued again, but this time
   with an explicit 10 second time out. 

<P>
<PRE>
  call ESMF_GridCompInitialize(dualComp, syncflag=ESMF_SYNC_NONBLOCKING, &amp;
    timeout=10, timeoutFlag=timeoutFlag, rc=rc)
</PRE>

<P>
This call is guaranteed to return within 10 seconds, or less, on the dual Component
   PETs, either without time out condition, indicating that the actual Component
   has been contacted successfully, or with time out condition, indicating that
   the actual Component was unreachable at the time. Either way, the dual 
   Component PETs are back under user control quickly.

<P>
Calling the CompWait() method on the dual Component causes the dual Component
   PETs to block until the actual Component method has returned, or a time out
   condition has been reached. 

<P>
<PRE>
  call ESMF_GridCompWait(dualComp, userRc=userRc, rc=rc)
</PRE>

<P>
The default time out for CompWait() is 3600 seconds, i.e. 1 hour, just like
   for the other Component methods. However, the semantics of a time out 
   condition under CompWait() is different from the other Component methods. Typically the <TT>timeout</TT> is simply the
   maximum time that any communication between dual and actual Component is allowed 
   to take before a time out condition is raised. For CompWait(), the <TT>timeout</TT>
   is the maximum time that an actual Component is allowed to execute before
   reporting back to the dual Component. Here, even with the default time out, 
   the dual Component would return from CompWait() immediately with a time out
   condition if the actual Component has already been executing for over 1 hour, 
   and is not already waiting to report back when the dual Component calls 
   CompWait(). On the other hand, if it has only been 30 minutes since 
   CompInitialize() was called on the dual Component, then the actual Component
   still has 30 minutes before CompWait() returns with a time out condition.
   During this time (or until the actual Component returns) the dual Component
   PETs are blocked.

<P>
A standard Component method is invoked in non-blocking mode. 

<P>
<PRE>
  call ESMF_GridCompRun(dualComp, syncflag=ESMF_SYNC_NONBLOCKING, &amp;
    timeout=10, timeoutFlag=timeoutFlag, rc=rc)
</PRE>

<P>
Once the user code on the dual side is ready to regain control over the
   actual Component it calls CompWait() on the dual Component. Here a
   <TT>timeout</TT> of 60s is specified, meaning that the total execution time the
   actual Component spends in the registered Run() routine may not exceed 60s
   before CompWait() returns with a time out condition. 

<P>
<PRE>
  call ESMF_GridCompWait(dualComp, timeout=60, userRc=userRc, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04062700000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Destroying a connected <EM>dual</EM> Component</A>
</H3>

<P>
<A NAME="sec:CompTunnelDualDestroy"></A>
<P>
A dual Component that is connected to an actual Component through a Component
   Tunnel is destroyed the same way a regular Component is. The only
   difference is that a connected dual Component may specify a <TT>timeout</TT>
   argument to the <TT>CompDestroy()</TT> call. 

<P>
<PRE>
  call ESMF_GridCompDestroy(dualComp, timeout=10, rc=rc)
</PRE>

<P>
The <TT>timeout</TT> argument again ensures that the dual side does not hang
   indefinitely in case the actual Component has become unavailable. If the
   actual Component is available, the destroy call will indicate to the actual
   Component that it should break out of the <TT>ServiceLoop()</TT>. Either way,
   the local dual Component is destroyed. 

<P>

<H3><A NAME="SECTION04062800000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Destroying a connected <EM>actual</EM> Component</A>
</H3>

<P>
<A NAME="sec:CompTunnelActualDestroy"></A>
<P>
An actual Component that is in a <TT>ServiceLoop()</TT> must first return from 
   that call before it can be destroyed. This can either happen when a connected
   dual Component calls its <TT>CompDestroy()</TT> method, or if the
   <TT>ServiceLoop()</TT> reaches the specified time out condition. Either way,
   once control has been returned to the user code, the actual Component is 
   destroyed in the same way a regular Component is, by calling the destroy
   method. 

<P>
<PRE>
  call ESMF_GridCompDestroy(actualComp, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION04063000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No data flow through States.</B> The current implementation does not support data flow (Fields, FieldBundles, etc.) between actual and dual Components. The current work-around is to employ user controlled, file based transfer methods. The next implementation phase will offer transparent data flow through the Component Tunnel, where the user code interacts with the States on the actual and dual side in the same way as if they were the same Component.

<P>
</LI>
</OL>

<H1><A NAME="SECTION04070000000000000000">
<SPAN CLASS="arabic">21</SPAN> State Class</A>
</H1>

<H2><A NAME="SECTION04071000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:State"></A>
<P>
A State contains the data and metadata to be transferred between 
ESMF Components.  It is an important class, because it defines a 
standard for how data is represented in data transfers between Earth
science components.  The 
State construct is a rational compromise between a fully prescribed 
interface - one that would dictate what specific fields should be 
transferred between components - and an interface in which data structures
are completely ad hoc.

<P>
There are two types of States, import and export.
An import State contains data that is necessary for a Gridded Component
or Coupler Component to execute, and an export State contains the data
that a Gridded Component or Coupler Component can make available.

<P>
States can contain Arrays, ArrayBundles, Fields, FieldBundles, 
and other States.  They cannot directly contain native language arrays
(i.e. Fortran or C style arrays).  Objects in a State must span
the VM on which they are running.  For sequentially executing components
which run on the same set of PETs this happens by calling the object
create methods on each PET, creating the object in unison.   For
concurrently executing components which are running on subsets of PETs,
an additional method, called <TT>ESMF_StateReconcile()</TT>, is provided by
ESMF to broadcast information
about objects which were created in sub-components.

<P>
State methods include creation and deletion, adding and retrieving 
data items, adding and retrieving attributes, and performing queries.  

<P>

<H2><A NAME="SECTION04072000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION04072100000000000000"></A>
<A NAME="const:stateintent"></A>
<BR>
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_STATEINTENT
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Specifies whether a <TT>ESMF_State</TT> contains data to be imported
into a component or exported from a component.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_StateIntent_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_STATEINTENT_IMPORT</STRONG></DT>
<DD>Contains data to be imported into a component.
   
</DD>
<DT><STRONG>ESMF_STATEINTENT_EXPORT</STRONG></DT>
<DD>Contains data to be exported out of a component.
   
</DD>
<DT><STRONG>ESMF_STATEINTENT_UNSPECIFIED</STRONG></DT>
<DD>The intent has not been specified.
</DD>
</DL>

<P>

<H3><A NAME="SECTION04072200000000000000"></A>
<A NAME="const:stateitem"></A>
<BR>
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_STATEITEM
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Specifies the type of object being added to or retrieved from an
ESMF_State.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_StateItem_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_STATEITEM_ARRAY</STRONG></DT>
<DD>Refers to an <TT>ESMF_Array</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_ARRAYBUNDLE</STRONG></DT>
<DD>Refers to an <TT>ESMF_Array</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_FIELD</STRONG></DT>
<DD>Refers to a <TT>ESMF_Field</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_FIELDBUNDLE</STRONG></DT>
<DD>Refers to a <TT>ESMF_FieldBundle</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_ROUTEHANDLE</STRONG></DT>
<DD>Refers to a <TT>ESMF_RouteHandle</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_STATE</STRONG></DT>
<DD>Refers to a <TT>ESMF_State</TT> within an <TT>ESMF_State</TT>.
</DD>
</DL>

<P>

<H2><A NAME="SECTION04073000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
A Gridded Component generally has one associated import 
State and one export State.  Generally the States 
associated with a Gridded Component will be created by 
the Gridded Component's parent component.
In many cases, the States will be created containing 
no data.  Both the empty States and the
newly created Gridded Component are passed
by the parent component into the Gridded Component's initialize 
method.  This is where the States get prepared for use 
and the import State is first filled with data.

<P>
States can be filled with data items that do not yet 
have data allocated.  Fields, FieldBundles, Arrays, and ArrayBundles each have 
methods that support their creation without actual data 
allocation - the Grid and Attributes are set up but no
Fortran array of data values is allocated.  In this approach, 
when a State is passed into its associated Gridded Component's 
initialize method, the incomplete Arrays, Fields, FieldBundles,
and ArrayBundles within the State can allocate or reference data 
inside the initialize method.

<P>
States are passed through the interfaces of the Gridded 
and Coupler Components' run methods in order to carry data 
between the components.  While we expect
a Gridded Component's import State to be filled with data 
during initialization, its export State will typically be
filled over the course of its run method.  At the end of
a Gridded Component's run method, the filled export State 
is passed out through the argument list into a Coupler 
Component's run method.  We recommend the convention that 
it enters the Coupler Component as the Coupler Component's
import State.  Here is it transformed into a form
that another Gridded Component requires, and passed out
of the Coupler Component as its export State.  It can then
be passed into the run method of a recipient Gridded Component
as that component's import State.

<P>
While the above sounds complicated, the rule is simple:
a State going into a component is an import State, and a 
State leaving a component is an export State.

<P>
Objects inside States are normally created in <I>unison</I> where
each PET executing a component makes the same object create call.
If the object contains data, like a Field, each PET may have a
different local chunk of the entire dataset but each Field has
the same name and is logically one part of a single distributed 
object.   As States are passed between components, if any object
in a State was not created in unison on all the current PETs 
then some PETs have no object to pass into a
communication method (e.g. regrid or data redistribution).
The <TT>ESMF_StateReconcile()</TT> method must be called to broadcast 
information about these objects to all PETs in a component;
after which all PETs have a single uniform view of all objects and metadata.  

<P>
If components are running in sequential mode on all available PETs
and States are being passed between them there is no need to call 
<TT>ESMF_StateReconcile</TT> since all PETs have a uniform view of the objects.
However, if components are running on a subset of the PETs, as is
usually the case when running in concurrent mode, then when States
are passed into components which contain a superset of those PETs,
for example, a Coupler Component, all PETs must call <TT>ESMF_StateReconcile</TT>
on the States before using them in any ESMF communication methods.
The reconciliation process broadcasts information about objects
which exist only on a subset of the PETs.  On PETs missing those
objects it creates a <I>proxy</I> object which contains any
qualities of the original object plus enough information for it
to be a data source or destination for a regrid or data redistribution
operation.

<P>

<H3><A NAME="SECTION04073100000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> State create and destroy</A>
</H3>

<P>
States can be created and destroyed at any time during
application execution.  The <TT>ESMF_StateCreate()</TT> routine
can take many different combinations of optional arguments.  Refer
to the API description for all possible methods of creating a State.
An empty State can be created by providing only a name and type for
the intended State:

<P>
<TT>state = ESMF_StateCreate(name, stateintent=ESMF_STATEINTENT_IMPORT, rc=rc)</TT>

<P>
When finished with an <TT>ESMF_State</TT>, the <TT>ESMF_StateDestroy</TT> method
removes it.  However, the objects inside the <TT>ESMF_State</TT>
created externally should be destroyed separately,
since objects can be added to more than one <TT>ESMF_State</TT>.

<P>

<P>

<P>

<H3><A NAME="SECTION04073200000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Add items to a State</A>
</H3>

<P>
Creation of an empty <TT>ESMF_State</TT>, and adding an <TT>ESMF_FieldBundle</TT>
    to it.  Note that the <TT>ESMF_FieldBundle</TT> does not get destroyed when
    the <TT>ESMF_State</TT> is destroyed; the <TT>ESMF_State</TT> only contains
    a reference to the objects it contains.  It also does not make a copy;
    the original objects can be updated and code accessing them by using
    the <TT>ESMF_State</TT> will see the updated version. 

<P>
<PRE>
    statename = "Ocean"
    state2 = ESMF_StateCreate(name=statename,  &amp;
                              stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
</PRE>

<P>
<PRE>
    bundlename = "Temperature"
    bundle1 = ESMF_FieldBundleCreate(name=bundlename, rc=rc)
    print *, "FieldBundle Create returned", rc
</PRE>

<P>
<PRE>
    call ESMF_StateAdd(state2, (/bundle1/), rc=rc)
    print *, "StateAdd returned", rc
</PRE>

<P>
<PRE>
    call ESMF_StateDestroy(state2, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleDestroy(bundle1, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04073300000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Add placeholders to a State</A>
</H3>

<P>
If a component could potentially produce a large number of optional
   items, one strategy is to add the names only of those objects to the
   <TT>ESMF_State</TT>.  Other components can call framework routines to
   set the <TT>ESMF_NEEDED</TT> flag to indicate they require that data.
   The original component can query this flag and then produce only the
   data that is required by another component. 

<P>
<PRE>
    statename = "Ocean"
    state3 = ESMF_StateCreate(name=statename,  &amp;
                              stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
</PRE>

<P>
<PRE>
    dataname = "Downward wind:needed"
    call ESMF_AttributeSet (state3, dataname, .false., rc=rc)
</PRE>

<P>
<PRE>
    dataname = "Humidity:needed"
    call ESMF_AttributeSet (state3, dataname, .false., rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04073400000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Mark an item <TT>NEEDED</TT></A>
</H3>

<P>
How to set the <TT>NEEDED</TT> state of an item. 

<P>
<PRE>
    dataname = "Downward wind:needed"
    call ESMF_AttributeSet (state3, name=dataname, value=.true., rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04073500000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Create a <TT>NEEDED</TT> item</A>
</H3>

<P>
Query an item for the <TT>NEEDED</TT> status, and creating an item on demand.
   Similar flags exist for "Ready", "Valid", and "Required for Restart",
   to mark each data item as ready, having been validated, or needed if the
   application is to be checkpointed and restarted.  The flags are supported
   to help coordinate the data exchange between components. 

<P>
<PRE>
    dataname = "Downward wind:needed"
    call ESMF_AttributeGet (state3, dataname, value=neededFlag, rc=rc)
</PRE>

<P>
<PRE>
    if (rc == ESMF_SUCCESS .and. neededFlag) then
        bundlename = dataname
        bundle2 = ESMF_FieldBundleCreate(name=bundlename, rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_StateAdd(state3, (/bundle2/), rc=rc)
</PRE>

<P>
<PRE>
    else
        print *, "Data not marked as needed", trim(dataname)
    endif
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION04073600000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> <TT>ESMF_StateReconcile()</TT> usage</A>
</H3>

<P>
The set services routines are used to tell ESMF which routine
   hold the user code for the initialize, run, and finalize
   blocks of user level Components.
   These are the separate subroutines called by the code below. 

<P>
<PRE>
! Initialize routine which creates "field1" on PETs 0 and 1
subroutine comp1_init(gcomp, istate, ostate, clock, rc)
    type(ESMF_GridComp)  :: gcomp
    type(ESMF_State)     :: istate, ostate
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    type(ESMF_Field) :: field1
    integer :: localrc

    print *, "i am comp1_init"

    field1 = ESMF_FieldEmptyCreate(name="Comp1 Field", rc=localrc)
  
    call ESMF_StateAdd(istate, (/field1/), rc=localrc)
    
    rc = localrc

end subroutine comp1_init

! Initialize routine which creates "field2" on PETs 2 and 3
subroutine comp2_init(gcomp, istate, ostate, clock, rc)
    type(ESMF_GridComp)  :: gcomp
    type(ESMF_State)     :: istate, ostate
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    type(ESMF_Field) :: field2
    integer :: localrc

    print *, "i am comp2_init"

    field2 = ESMF_FieldEmptyCreate(name="Comp2 Field", rc=localrc)
    
    call ESMF_StateAdd(istate, (/field2/), rc=localrc)

    rc = localrc

end subroutine comp2_init

subroutine comp_dummy(gcomp, rc)
   type(ESMF_GridComp)  :: gcomp
   integer, intent(out) :: rc

   rc = ESMF_SUCCESS
end subroutine comp_dummy
</PRE>

<P>
<PRE>
! !PROGRAM: ESMF_StateReconcileEx - State reconciliation
!
! !DESCRIPTION:
!
! This program shows examples of using the State Reconcile function
!-----------------------------------------------------------------------------
#include "ESMF.h"

    ! ESMF Framework module
    use ESMF
    use ESMF_TestMod
    use ESMF_StateReconcileEx_Mod
    implicit none

    ! Local variables
    integer :: rc, petCount
    type(ESMF_State) :: state1
    type(ESMF_GridComp) :: comp1, comp2
    type(ESMF_VM) :: vm
    character(len=ESMF_MAXSTR) :: comp1name, comp2name, statename
</PRE>

<P>
A Component can be created which will run only on a subset of the
    current PET list. 

<P>
<PRE>
    ! Get the global VM for this job.
    call ESMF_VMGetGlobal(vm=vm, rc=rc)

    comp1name = "Atmosphere"
    comp1 = ESMF_GridCompCreate(name=comp1name, petList=(/ 0, 1 /), rc=rc)
    print *, "GridComp Create returned, name = ", trim(comp1name)
</PRE>

<P>
<PRE>
    comp2name = "Ocean"
    comp2 = ESMF_GridCompCreate(name=comp2name, petList=(/ 2, 3 /), rc=rc)
    print *, "GridComp Create returned, name = ", trim(comp2name)
</PRE>

<P>
<PRE>
    statename = "Ocn2Atm"
    state1 = ESMF_StateCreate(name=statename, rc=rc)
</PRE>

<P>
Here we register the subroutines which should be called for initialization.
    Then we call ESMF_GridCompInitialize() on all PETs, but the code runs
    only on the PETs given in the petList when the Component was created.

<P>
Because this example is so short, we call the entry point code
    directly instead of the normal procedure of nesting it in a separate
    SetServices() subroutine.  

<P>
<PRE>
    ! This is where the VM for each component is initialized.
    ! Normally you would call SetEntryPoint inside set services,
    ! but to make this example very short, they are called inline below.
    ! This is o.k. because the SetServices routine must execute from within
    ! the parent component VM.
    call ESMF_GridCompSetVM(comp1, comp_dummy, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_GridCompSetVM(comp2, comp_dummy, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_GridCompSetServices(comp1, userRoutine=comp_dummy, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_GridCompSetServices(comp2, userRoutine=comp_dummy, rc=rc)
</PRE>

<P>
<PRE>
    print *, "ready to set entry point 1"
    call ESMF_GridCompSetEntryPoint(comp1, ESMF_METHOD_INITIALIZE, &amp;
         comp1_init, rc=rc)
</PRE>

<P>
<PRE>
    print *, "ready to set entry point 2"
    call ESMF_GridCompSetEntryPoint(comp2, ESMF_METHOD_INITIALIZE, &amp;
         comp2_init, rc=rc)
</PRE>

<P>
<PRE>
    print *, "ready to call init for comp 1"
    call ESMF_GridCompInitialize(comp1, exportState=state1, rc=rc)
</PRE>

<P>
<PRE>
    print *, "ready to call init for comp 2"
    call ESMF_GridCompInitialize(comp2, exportState=state1, rc=rc)
</PRE>

<P>
Now we have <TT>state1</TT> containing <TT>field1</TT> on PETs 0 and 1, and
   <TT>state1</TT> containing <TT>field2</TT> on PETs 2 and 3.  For the code
   to have a rational view of the data, we call <TT>ESMF_StateReconcile</TT>
   which determines which objects are missing from any PET, and communicates
   information about the object. After the call to reconcile, all
   <TT>ESMF_State</TT> objects now have a consistent view of the data. 

<P>
<PRE>
    print *, "State before calling StateReconcile()"
    call ESMF_StatePrint(state1, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_StateReconcile(state1, vm=vm, rc=rc)
</PRE>

<P>
<PRE>
    print *, "State after calling StateReconcile()"
    call ESMF_StatePrint(state1, rc=rc)
</PRE>

<P>
<PRE>
end program ESMF_StateReconcileEx
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION04073700000000000000"></A>
   <A NAME="example:StateRdWr"></A>
<BR>
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Read Arrays from a NetCDF file and add to a State
</H3>
   This program shows an example of reading and writing Arrays from a State
   from/to a NetCDF file. 

<P>
<PRE>
    ! ESMF Framework module
    use ESMF
    use ESMF_TestMod
    implicit none

    ! Local variables
    type(ESMF_State) :: state
    type(ESMF_Array) :: latArray, lonArray, timeArray, humidArray, &amp;
                        tempArray, pArray, rhArray
    type(ESMF_VM) :: vm
    integer :: localPet, rc
</PRE>

<P>
The following line of code will read all Array data contained in a NetCDF
    file, place them in <TT>ESMF_Arrays</TT> and add them to an <TT>ESMF_State</TT>.
    Only PET 0 reads the file; the States in the other PETs remain empty.
    Currently, the data is not decomposed or distributed; each PET
    has only 1 DE and only PET 0 contains data after reading the file.
    Future versions of ESMF will support data decomposition and distribution
    upon reading a file.

<P>
Note that the third party NetCDF library must be installed.  For more
    details, see the "ESMF Users Guide", 
    "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
    the website http://www.unidata.ucar.edu/software/netcdf. 

<P>
<PRE>
    ! Read the NetCDF data file into Array objects in the State on PET 0
    call ESMF_StateRead(state, "io_netcdf_testdata.nc", rc=rc)

    ! If the NetCDF library is not present (on PET 0), cleanup and exit 
    if (rc == ESMF_RC_LIB_NOT_PRESENT) then
      call ESMF_StateDestroy(state, rc=rc)
      goto 10
    endif
</PRE>

<P>
Only reading data into <TT>ESMF_Arrays</TT> is supported at this time;
    <TT>ESMF_ArrayBundles</TT>, <TT>ESMF_Fields</TT>, and <TT>ESMF_FieldBundles</TT>
    will be supported in future releases of ESMF. 

<P>

<H3><A NAME="SECTION04073800000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Print Array data from a State</A>
</H3>

<P>
To see that the State now contains the same data as in the file, the
    following shows how to print out what Arrays are contained within the
    State and to print the data contained within each Array.  The NetCDF utility
    "ncdump" can be used to view the contents of the NetCDF file.
    In this example, only PET 0 will contain data. 

<P>
<PRE>
    if (localPet == 0) then
      ! Print the names and attributes of Array objects contained in the State
      call ESMF_StatePrint(state, rc=rc)

      ! Get each Array by name from the State
      call ESMF_StateGet(state, "lat",  latArray,   rc=rc)
      call ESMF_StateGet(state, "lon",  lonArray,   rc=rc)
      call ESMF_StateGet(state, "time", timeArray,  rc=rc)
      call ESMF_StateGet(state, "Q",    humidArray, rc=rc)
      call ESMF_StateGet(state, "TEMP", tempArray,  rc=rc)
      call ESMF_StateGet(state, "p",    pArray,     rc=rc)
      call ESMF_StateGet(state, "rh",   rhArray,    rc=rc)

      ! Print out the Array data
      call ESMF_ArrayPrint(latArray,   rc=rc)
      call ESMF_ArrayPrint(lonArray,   rc=rc)
      call ESMF_ArrayPrint(timeArray,  rc=rc)
      call ESMF_ArrayPrint(humidArray, rc=rc)
      call ESMF_ArrayPrint(tempArray,  rc=rc)
      call ESMF_ArrayPrint(pArray,     rc=rc)
      call ESMF_ArrayPrint(rhArray,    rc=rc)
    endif
</PRE>

<P>
Note that the Arrays "lat", "lon", and "time" hold spatial and temporal
    coordinate data for the dimensions latitude, longitude and time,
    respectively.  These will be used in future releases of ESMF to create
    <TT>ESMF_Grids</TT>. 

<P>

<H3><A NAME="SECTION04073900000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Write Array data within a State to a NetCDF file</A>
</H3>

<P>
All the Array data within the State on PET 0 can be written out to a NetCDF
    file as follows: 

<P>
<PRE>
    ! Write Arrays within the State on PET 0 to a NetCDF file
    call ESMF_StateWrite(state, "io_netcdf_testdata_out.nc", rc=rc)
</PRE>

<P>
Currently writing is limited to PET 0; future versions of ESMF will allow
    parallel writing, as well as parallel reading.


<H2><A NAME="SECTION04074000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No synchronization of object IDs at object create time.</B>
Object IDs are used during the reconcile process to identify objects
which are unknown to some subset of the PETs in the currently running VM.
Object IDs are assigned in sequential order at object create time.

<P>
One important request by the user community during the ESMF object design was
that there be no communication overhead or synchronization when creating
distributed ESMF objects. As a consequence it is required to create these
objects in <B>unison</B> across all PETs in order to keep the ESMF object
identification in sync.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION04075000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>States contain the name of the associated Component, a flag for Import
or Export, and a list of data objects, which can be a combination of
FieldBundles, Fields, and/or Arrays.  The objects must be named and have
the proper attributes so they can be identified by the receiver of
the data.  For example, units and other detailed information
may need to be associated with the data as an Attribute.  

<P>
</LI>
<LI>Data contained in States must be created in unison on each
PET of the current VM.  This allows the creation process to avoid
doing communications since each PET can compute any information
it needs to know about any remote PET (for example, the grid
distribute method can compute the decomposition of the grid on
not only the local PET but also the remote PETs since it knows
each PET is making the identical call).  For all PETs to have a
consistent view of the data this means objects must be given
unique names when created, or all objects must be created in
the same order on all PETs so ESMF can generate consistent
default names for the objects.

<P>
When running components on subsets of the original VM all the
PETs can create consistent objects but then when they are put
into a State and passed to a component with a different VM and
a different set of PETs, a communication call (reconcile) must be 
made to communicate the missing information to the PETs which were 
not involved in the original object creation.  The reconcile call
broadcasts object lists; those PETs which are missing any objects
in the total list can receive enough information to
reconstruct a proxy object which contains all necessary information
about that object, with no local data, on that PET.  These proxy
objects can be queried by ESMF routines to determine the amount
of data and what PETs contain data which is destined to be moved
to the local PET (for receiving data) and conversely, can determine
which other PETs are going to receive data and how much (for
sending data).

<P>
For example, the FieldExcl system test creates 2 Gridded Components
on separate subsets of PETs.  They use the option of mapping
particular, non-monotonic PETs to DEs.  The following figures 
illustrate how the DEs are mapped in each of the Gridded Components
in that test:

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_source"></A><A NAME="13183"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 7:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the source grid created by <TT>user_model1.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_src_grid}}$
 -->
<IMG
 WIDTH="378" HEIGHT="221" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_src_grid}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_destination"></A><A NAME="13185"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 8:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the destination grid created by <TT>user_model2.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_dst_grid}}$
 -->
<IMG
 WIDTH="377" HEIGHT="220" ALIGN="BOTTOM" BORDER="0"
 SRC="img19.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_dst_grid}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
In the coupler code, all PETs must make the reconcile call before
accessing data in the State.  On PETs which already contain data,
the objects are unchanged.  On PETs which were not involved during
the creation of the FieldBundles or Fields, the reconcile call adds an
object to the State which contains all the same metadata associated
with the object, but creates a slightly different Grid object,
called a Proxy Grid. These PETs contain no local data, so the
Array object is empty, and the DELayout for the Grid is like this:

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_source_cpl"></A><A NAME="13187"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 9:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the source grid after the reconcile call in <TT>user_coupler.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_src_grid_cpl}}$
 -->
<IMG
 WIDTH="575" HEIGHT="257" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_src_grid_cpl}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_destination_cpl"></A><A NAME="13189"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 10:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the destination grid after the reconcile call in <TT>user_coupler.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_dst_grid_cpl}}$
 -->
<IMG
 WIDTH="649" HEIGHT="254" ALIGN="BOTTOM" BORDER="0"
 SRC="img21.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_dst_grid_cpl}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
</LI>
</OL>

<H2><A NAME="SECTION04076000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
State class.  States can contain FieldBundles, Fields, Arrays, or nested
States.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="600" HEIGHT="190" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.png"
 ALT="\includegraphics{State_obj}">   

</DIV>

<H2><A NAME="SECTION04077000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04077100000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_StateAssignment(=) - State assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface assignment(=)
   state1 = state2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State) :: state1
   type(ESMF_State) :: state2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign state1 as an alias to the same ESMF State object in memory
   as state2. If state2 is invalid, then state1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>state1</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>state2</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04077200000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_StateOperator(==) - State equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
   if (state1 == state2) then ... endif
   OR
   result = (state1 == state2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(in) :: state1
   type(ESMF_State), intent(in) :: state2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether state1 and state2 are valid aliases to the same ESMF
   State object in memory. For a more general comparison of two ESMF States,
   going beyond the simple alias test, the ESMF_StateMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>state1</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>state2</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04077300000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_StateOperator(/=) - State not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
   if (state1 /= state2) then ... endif
   OR
   result = (state1 /= state2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(in) :: state1
   type(ESMF_State), intent(in) :: state2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether state1 and state2 are <I>not</I> valid aliases to the
   same ESMF State object in memory. For a more general comparison of two ESMF
   States, going beyond the simple alias test, the ESMF_StateMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>state1</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>state2</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04077400000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_StateAdd - Add a list of items to a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_StateAdd(state, &lt;itemList&gt;, relaxedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(inout) :: state
   &lt;itemList&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   logical, intent(in), optional :: relaxedFlag
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add a list of items to a <TT>ESMF_State</TT>. It is an error if any item in
   &lt;itemlist&gt; already matches, by name, an item already contained in <TT>state</TT>.

<P>
Supported values for &lt;itemList&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: arrayList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: fieldList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(in) :: routehandleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: nestedStateList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> to which the &lt;itemList&gt; will be added.
   
</DD>
<DT><STRONG>&lt;itemList&gt;</STRONG></DT>
<DD>The list of items to be added.
   This is a reference only; when
   the <TT>ESMF_State</TT> is destroyed the &lt;itemList&gt; items contained within it will
   not be destroyed. Also, the items in the &lt;itemList&gt; cannot be safely
   destroyed before the <TT>ESMF_State</TT> is destroyed.
   Since &lt;itemList&gt; items can be added to multiple containers, it remains
   the responsibility of the user to manage their
   destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add",
   where it is <EM>not</EM> an error if <TT>&lt;itemList&gt;</TT> contains items
   with names that are found in <TT>state</TT>. The <TT>State</TT>
   is left unchanged for these items. For <TT>.false.</TT> this is treated
   as an error condition. The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04077500000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_StateAddReplace - Add or replace a list of items to a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_StateAddReplace(state, &lt;itemList&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(inout) :: state
   &lt;itemList&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add or replace a list of items to an <TT>ESMF_State</TT>. If an item in
   &lt;itemList&gt; does not match any items already present in <TT>state</TT>, it is
   added. Items with names already present in the <TT>state</TT> replace the
   existing item.

<P>
Supported values for &lt;itemList&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: arrayList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: fieldList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(in) :: routehandleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: nestedStateList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> to which the &lt;itemList&gt; will be added or replaced.
   
</DD>
<DT><STRONG>&lt;itemList&gt;</STRONG></DT>
<DD>The list of items to be added or replaced.
   This is a reference only; when
   the <TT>ESMF_State</TT> is destroyed the &lt;itemList&gt; items contained within it will
   not be destroyed. Also, the items in the &lt;itemList&gt; cannot be safely
   destroyed before the <TT>ESMF_State</TT> is destroyed.
   Since &lt;itemList&gt; items can be added to multiple containers, it remains
   the responsibility of the user to manage their
   destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04077600000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_StateCreate - Create a new State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_StateCreate(stateintent, &amp;
                    arrayList, arraybundleList, &amp;
                    fieldList, fieldbundleList, &amp;
                    nestedStateList, &amp;
                    routehandleList, name, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_State) :: ESMF_StateCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_StateIntent_Flag), intent(in), optional :: stateintent
       type(ESMF_Array), intent(in), optional :: arrayList(:)
       type(ESMF_ArrayBundle), intent(in), optional :: arraybundleList(:)
       type(ESMF_Field), intent(in), optional :: fieldList(:)
       type(ESMF_FieldBundle), intent(in), optional :: fieldbundleList(:)
       type(ESMF_State), intent(in), optional :: nestedStateList(:)
       type(ESMF_RouteHandle), intent(in), optional :: routehandleList(:)
       character(len=*), intent(in), optional :: name
       type(ESMF_VM), intent(in), optional :: vm
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
   different VM than that of the current context.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_State</TT>, set default characteristics for
   objects added to it, and optionally add initial objects to it.

<P>
The arguments are:
   <DL>
<DT><STRONG>[stateintent]</STRONG></DT>
<DD>Import or Export <TT>ESMF_State</TT>. Valid values are
   <TT>ESMF_STATEINTENT_IMPORT</TT>, <TT>ESMF_STATEINTENT_EXPORT</TT>,
   or <TT>ESMF_STATEINTENT_UNSPECIFIED</TT> The default
   is <TT>ESMF_STATEINTENT_UNSPECIFIED</TT>.
   
</DD>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_Array</TT>s.
   
</DD>
<DT><STRONG>[arraybundleList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_ArrayBundle</TT>s.
   
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_Field</TT>s.
   
</DD>
<DT><STRONG>[fieldbundleList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_FieldBundle</TT>s.
   
</DD>
<DT><STRONG>[nestedStateList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_State</TT>s to be nested
   inside the outer <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>[routehandleList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_RouteHandle</TT>s.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of this <TT>ESMF_State</TT> object. A default name will be generated
   if none is specified.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the State object is created on the specified
   <TT>ESMF_VM</TT> object. The default is to create on the VM of the
   current component context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04077700000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_StateDestroy - Release resources for a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       recursive subroutine ESMF_StateDestroy(state, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(inout) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical, intent(in), optional :: noGarbage
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_State</TT>. Actual
   objects added to <TT>ESMF_State</TT>s will not be destroyed, it
   remains the responsibility of the user to destroy these objects in the correct
   context.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>Destroy contents of this <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases - a situation which may lead to hard to debug
   application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
   set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
   removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04077800000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_StateGet - Get object-wide information from a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_StateGet()
       subroutine ESMF_StateGetInfo(state, &amp;
             itemSearch, itemorderflag, nestedFlag, &amp;
             stateintent, itemCount, itemNameList, itemTypeList, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in), optional :: itemSearch
       type(ESMF_ItemOrder_Flag), intent(in), optional :: itemorderflag
       logical, intent(in), optional :: nestedFlag
       type(ESMF_StateIntent_Flag), intent(out), optional :: stateintent
       integer, intent(out), optional :: itemCount
       character (len=*), intent(out), optional :: itemNameList(:)
       type(ESMF_StateItem_Flag), intent(out), optional :: itemTypeList(:)
       character (len=*), intent(out), optional :: name
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>itemorderflag</TT>.
   The new argument gives the user control over the order in which
   the items are returned.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns the requested information about this <TT>ESMF_State</TT>.
   The optional <TT>itemSearch</TT> argument may specify the name of
   an individual item to search for. When used in conjunction with
   the <TT>nestedFlag</TT>, nested States will also be searched.

<P>
Typically, an <TT>ESMF_StateGet()</TT> information request will be performed
   twice. The first time, the <TT>itemCount</TT> argument will be used to
   query the size of arrays that are needed. Arrays can then be allocated
   to the correct size for <TT>itemNameList</TT> and <TT>itemtypeList</TT>
   as needed. A second call to <TT>ESMF_StateGet()</TT> will then fill in the
   values.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> object to be queried.
   
</DD>
<DT><STRONG>[itemSearch]</STRONG></DT>
<DD>Query objects by name in the State. When the <TT>nestedFlag</TT>
   option is set to .true., all nested States will also be searched
   for the specified name.
   
</DD>
<DT><STRONG>[itemorderflag]</STRONG></DT>
<DD>Specifies the order of the returned items in the <TT>itemNameList</TT>
   and <TT>itemTypeList</TT>. The default is <TT>ESMF_ITEMORDER_ABC</TT>.
   See <A HREF="node9.html#const:itemorderflag"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for a full list of options.
   
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD>When set to <TT>.false.</TT>, returns information at the current
   State level only (default)
   When set to <TT>.true.</TT>, additionally returns information from
   nested States
   
</DD>
<DT><STRONG>[stateintent]</STRONG></DT>
<DD>Returns the type, e.g., Import or Export, of this <TT>ESMF_State</TT>.
   Possible values are listed in Section&nbsp;<A HREF="#const:stateintent">21.2.1</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Count of items in this <TT>ESMF_State</TT>.
   When the <TT>nestedFlag</TT> option is
   set to <TT>.true.</TT>, the count will include items present in nested
   States. When using <TT>itemSearch</TT>, it will count the number of
   items matching the specified name.
   
</DD>
<DT><STRONG>[itemNameList]</STRONG></DT>
<DD>Array of item names in this <TT>ESMF_State</TT>.
   When the <TT>nestedFlag</TT> option is
   set to <TT>.true.</TT>, the list will include items present in nested
   States. When using <TT>itemSearch</TT>, it will return the names of
   items matching the specified name. <TT>itemNameList</TT> must be at least
   <TT>itemCount</TT> long.
   
</DD>
<DT><STRONG>[itemTypeList]</STRONG></DT>
<DD>Array of possible item object types in this <TT>ESMF_State</TT>.
   When the <TT>nestedFlag</TT> option is
   set to <TT>.true.</TT>, the list will include items present in nested
   States. When using <TT>itemSearch</TT>, it will return the types of
   items matching the specified name. Must be at least <TT>itemCount</TT>
   long. Return values are listed in Section&nbsp;<A HREF="#const:stateitem">21.2.2</A>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Returns the name of this <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04077900000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_StateGet - Get information about an item in a State by item name</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_StateGet()
       subroutine ESMF_StateGetItemInfo(state, itemName, itemType, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: itemName
       type(ESMF_StateItem_Flag), intent(out) :: itemType
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns the type for the item named
   <TT>name</TT> in this <TT>ESMF_State</TT>. If no item with this name
   exists, the value <TT>ESMF_STATEITEM_NOTFOUND</TT> will be returned
   and the error code will not be set to an error. Thus this routine
   can be used to safely query for the existence of items by name
   whether or not they are expected to be there. The error code will
   be set in case of other errors, for example if the <TT>ESMF_State</TT>
   itself is invalid.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD><TT>ESMF_State</TT> to be queried.
   
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>Name of the item to return information about.
   
</DD>
<DT><STRONG>itemType</STRONG></DT>
<DD>Returned item types for the item with the given name, including
   placeholder names. Options are
   listed in Section&nbsp;<A HREF="#const:stateitem">21.2.2</A>. If no item with the
   given name is found, <TT>ESMF_STATEITEM_NOTFOUND</TT> will be returned
   and <TT>rc</TT> will <B>not</B> be set to an error.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040771000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_StateGet - Get an item from a State by item name</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_StateGet(state, itemName, &lt;item&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(in) :: state
   character (len=*), intent(in) :: itemName
   &lt;item&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns an &lt;item&gt; from an <TT>ESMF_State</TT> by item name.
   If the <TT>ESMF_State</TT> contains the &lt;item&gt; directly, only
   <TT>itemName</TT> is required.

<P>
If the <TT>state</TT> contains nested <TT>ESMF_State</TT>s,
   the <TT>itemName</TT> argument may specify a fully qualified name
   to access the desired item with a single call. This is performed
   using the '/' character to separate the names of the intermediate
   State names leading to the desired item. (E.g.,
   <TT>itemName='state1/state12/item'</TT>).

<P>
Supported values for &lt;item&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(out) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(out) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(out) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(out) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(out) :: routehandle
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(out) :: nestedState
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>State to query for an &lt;item&gt; named <TT>itemName</TT>.
   
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>Name of &lt;item&gt; to be returned. This name may be fully
   qualified in order to access nested State items.
   
</DD>
<DT><STRONG>&lt;item&gt;</STRONG></DT>
<DD>Returned reference to the &lt;item&gt;.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040771100000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_StateIsCreated - Check whether an State object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_StateIsCreated(state, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_StateIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>state</TT> has been created. Otherwise return
   <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
   returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD><TT>ESMF_State</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040771200000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_StatePrint - Print State information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_StatePrint(state, options, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
       character(len=*), intent(in), optional :: options
       logical, intent(in), optional :: nestedFlag
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>state</TT> to <TT>stdout</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to print.
   
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options:
   " ", or "brief" - print names and types of the objects within the state (default),
   "long" - print additional information, such as proxy flags
   
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD>When set to <TT>.false.</TT>, prints information about the current
   State level only (default),
   When set to <TT>.true.</TT>, additionally prints information from
   nested States
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040771300000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_StateRead - Read data items from a file into a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_StateRead(state, fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(inout) :: state
       character (len=*), intent(in) :: fileName
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Currently limited to read in all Arrays from a NetCDF file and add them
   to a State object. Future releases will enable more items of a State
   to be read from a file of various formats.

<P>
Only PET 0 reads the file; the States in other PETs remain empty.
   Currently, the data is not decomposed or distributed; each PET
   has only 1 DE and only PET 0 contains data after reading the file.
   Future versions of ESMF will support data decomposition and distribution
   upon reading a file. See Section&nbsp;<A HREF="#example:StateRdWr">21.3.7</A> for
   an example.

<P>
Note that the third party NetCDF library must be installed. For more
   details, see the "ESMF Users Guide",
   "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
   the website http://www.unidata.ucar.edu/software/netcdf.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to add items read from file. Currently only
   Arrays are supported.
   
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>File to be read.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   Equals <TT>ESMF_RC_LIB_NOT_PRESENT</TT> if the NetCDF library is
   not present.
   
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION040771400000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_StateReconcile - Reconcile State data across all PETs in a VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_StateReconcile(state, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),            intent(inout)         :: state
     type(ESMF_VM),               intent(in),  optional :: vm
     integer,                     intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Must be called for any <TT>ESMF_State</TT> which contains ESMF objects
       that have not been created on all the <TT>PET</TT>s of the currently
       running <TT>ESMF_Component</TT>.
       For example, if a coupler is operating on data
       which was created by another component that ran on only a subset
       of the couplers <TT>PET</TT>s, the coupler must make this call first
       before operating on any data inside that <TT>ESMF_State</TT>.
       After calling <TT>ESMF_StateReconcile</TT> all <TT>PET</TT>s will have
       a common view of all objects contained in this <TT>ESMF_State</TT>.

<P>
This call is collective across the specified VM.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD><TT>ESMF_State</TT> to reconcile.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD><TT>ESMF_VM</TT> for this <TT>ESMF_Component</TT>.  By default, it is set to the current vm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION040771500000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_StateRemove - Remove an item from a State - (DEPRECATED METHOD)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StateRemove ()
   subroutine ESMF_StateRemoveOneItem (state, itemName, &amp;
       relaxedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout) :: state
     character(*), intent(in) :: itemName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: relaxedFlag
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI><B>DEPRECATED METHOD</B> as of ESMF 5.3.1. Please use <TT>ESMF_StateRemove</TT>, section <TT><A HREF="#esmfstateremovelist">21.7.16</A></TT> instead.
   Rationale: The list version is consistent with other ESMF container
   operations which use lists.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove an existing reference to an item from a <TT>State</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> within which <TT>itemName</TT> will be removed.
   
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>The name of the item to be removed. This is a reference only.
   The item itself is unchanged.

<P>
If the <TT>state</TT> contains nested <TT>ESMF_State</TT>s,
   the <TT>itemName</TT> argument may specify a fully qualified name
   to remove the desired item with a single call. This is performed
   using the "/" character to separate the names of the intermediate
   State names leading to the desired item. (E.g.,
   <TT>itemName="state1/state12/item"</TT>.

<P>
Since an item could potentially be referenced by multiple containers,
   it remains the responsibility of the user to manage its
   destruction when it is no longer in use.
   
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "remove",
   where it is <EM>not</EM> an error if <TT>itemName</TT> is not present in the
   <TT>state</TT>. For <TT>.false.</TT> this is treated
   as an error condition. The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040771600000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_StateRemove - Remove a list of items from a State</A>
</H3>

<P>
<A NAME="esmfstateremovelist"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StateRemove ()
   subroutine ESMF_StateRemoveList (state, itemNameList, relaxedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout) :: state
     character(*), intent(in) :: itemNameList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: relaxedFlag
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.3.1. If code using this interface compiles with any version of ESMF starting with 5.3.1, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove existing references to items from a <TT>State</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> within which <TT>itemName</TT> will be removed.
   
</DD>
<DT><STRONG>itemNameList</STRONG></DT>
<DD>The name of the items to be removed. This is a reference only.
   The items themselves are unchanged.

<P>
If the <TT>state</TT> contains nested <TT>ESMF_State</TT>s,
   the <TT>itemName</TT> arguments may specify fully qualified names
   to remove the desired items with a single call. This is performed
   using the "/" character to separate the names of the intermediate
   State names leading to the desired items. (E.g.,
   <TT>itemName="state1/state12/item"</TT>.

<P>
Since items could potentially be referenced by multiple containers,
   it remains the responsibility of the user to manage their
   destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "remove",
   where it is <EM>not</EM> an error if an item in the <TT>itemNameList</TT>
   is not present in the <TT>state</TT>. For <TT>.false.</TT> this is treated
   as an error condition. The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040771700000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_StateReplace - Replace a list of items within a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_StateReplace(state, &lt;itemList&gt;, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(inout) :: state
   &lt;itemList&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   logical, intent(in), optional :: relaxedflag
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Replace a list of items with a <TT>ESMF_State</TT>. If an item in
   &lt;itemList&gt; does not match any items already present in <TT>state</TT>, an
   error is returned.

<P>
Supported values for &lt;itemList&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: arrayList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: fieldList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(in) :: routehandleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: nestedStateList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> within which the &lt;itemList&gt; items will be replaced.
   
</DD>
<DT><STRONG>&lt;itemList&gt;</STRONG></DT>
<DD>The list of items to be replaced.
   This is a reference only; when
   the <TT>ESMF_State</TT> is destroyed the &lt;itemList&gt; contained in it will
   not be destroyed. Also, the items in the &lt;itemList&gt; cannot be safely
   destroyed before the <TT>ESMF_State</TT> is destroyed.
   Since &lt;itemList&gt; items can be added to multiple containers, it remains
   the responsibility of the user to manage their
   destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "replace",
   where it is <EM>not</EM> an error if <TT>&lt;itemList&gt;</TT> contains items
   with names that are not found in <TT>state</TT>. The <TT>State</TT>
   is left unchanged for these items. For <TT>.false.</TT> this is treated
   as an error condition. The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>


<P>

<P>

<P>

<H3><A NAME="SECTION040771800000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_StateSet - Set State aspects</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_StateSet(state, stateIntent, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),            intent(inout)         :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_StateIntent_Flag), intent(in),  optional :: stateIntent
      character(len = *),         intent(in),  optional :: name
     integer,                     intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the info in the <TT>state</TT> object.

<P>
The arguments are:
        <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to set.
        
</DD>
<DT><STRONG>stateIntent</STRONG></DT>
<DD>Intent, e.g. Import or Export, of this <TT>ESMF_State</TT>.
          Possible values are listed in Section&nbsp;<A HREF="#const:stateintent">21.2.1</A>.
        
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The State name.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION040771900000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_StateValidate - Check validity of a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_StateValidate(state, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,          intent(in),  optional :: nestedFlag
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>state</TT> is internally consistent.
        Currently this method determines if the <TT>State</TT> is uninitialized 
        or already destroyed.  The method returns an error code if problems 
        are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to validate.
       
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD><TT>.false.</TT> - validates at the current State level only (default)
         <TT>.true.</TT> - recursively validates any nested States
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION040772000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_StateWrite - Write items from a State to file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_StateWrite(state, fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State),  intent(in)            :: state 
       character (len=*), intent(in)            :: fileName
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Currently limited to write out all Arrays of a State object to a
       netCDF file.  Future releases will enable more item types of a State to
       be written to files of various formats.

<P>
Writing is currently limited to PET 0; future versions of ESMF will allow
       parallel writing, as well as parallel reading.

<P>
See Section&nbsp;<A HREF="#example:StateRdWr">21.3.7</A> for an example.

<P>
Note that the third party NetCDF library must be installed.  For more
       details, see the "ESMF Users Guide",
       "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
       the website http://www.unidata.ucar.edu/software/netcdf.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> from which to write items.  Currently limited to
         Arrays.
       
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>File to be written.  
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
         Equals <TT>ESMF_RC_LIB_NOT_PRESENT</TT> if the NetCDF library is
         not present.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION04080000000000000000">
<SPAN CLASS="arabic">22</SPAN> Attachable Methods</A>
</H1>

<H2><A NAME="SECTION04081000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
ESMF allows user methods to be attached to Components and States. Providing
this capability supports a more object oriented way of model design. 

<P>
Attachable methods on Components can be used to implement the concept of
generic Components where the specialization requires attaching methods with
well defined names. This methods are then called by the generic Component 
code.

<P>
Attaching methods to States can be used to supply data operations along with
the data objects inside of a State object. This can be useful where a producer
Component not only supplies a data set, but also the associated processing
functionality. This can be more efficient than providing all of the possible
sets of derived data.

<H2><A NAME="SECTION04082000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how a producer Component attaches a
user defined method to a State, and how it implements the method. The attached
method is then executed by the consumer Component.

<P>

<P>

<P>

<H3><A NAME="SECTION04082100000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Producer Component attaches user defined method</A>
</H3>

<P>
The producer Component attaches a user defined method to <TT>exportState</TT>
    during the Component's initialize method. The user defined method is
    attached with label <TT>finalCalculation</TT> by which it will become
    accessible to the consumer Component. 

<P>
<PRE>
  subroutine init(gcomp, importState, exportState, clock, rc)
    ! arguments
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: importState, exportState
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    rc = ESMF_SUCCESS
    call ESMF_MethodAdd(exportState, label="finalCalculation", &amp;
      userRoutine=finalCalc, rc=rc)
    if (rc /= ESMF_SUCCESS) return

    ! just for testing purposes add the same method with a crazy string label
    call ESMF_MethodAdd(exportState, label="Somewhat of a SILLY @$^@_ label", &amp;
      userRoutine=finalCalc, rc=rc)
    if (rc /= ESMF_SUCCESS) return

  end subroutine !--------------------------------------------------------------
</PRE>

<P>

<H3><A NAME="SECTION04082200000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Producer Component implements user defined method</A>
</H3>

<P>
The producer Component implements the attached, user defined method
    <TT>finalCalc</TT>. Strict interface rules apply for the user defined
    method. 

<P>
<PRE>
  subroutine finalCalc(state, rc)
    ! arguments
    type(ESMF_State):: state
    integer, intent(out):: rc

    rc = ESMF_SUCCESS

    ! access data objects in state and perform calculation
    print *, "dummy output from attached method "

  end subroutine !--------------------------------------------------------------
</PRE>

<P>

<H3><A NAME="SECTION04082300000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Consumer Component executes user defined method</A>
</H3>

<P>
The consumer Component executes the user defined method on the
    <TT>importState</TT>.

<P>
<PRE>
  subroutine init(gcomp, importState, exportState, clock, rc)
    ! arguments
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: importState, exportState
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    integer:: userRc, i
    logical:: isPresent
    character(len=:), allocatable :: labelList(:)

    rc = ESMF_SUCCESS
</PRE>

<P>
The importState can be queried for a list of <EM>all</EM> the attached methods. 

<P>
<PRE>
    call ESMF_MethodGet(importState, labelList=labelList, rc=rc)
    if (rc /= ESMF_SUCCESS) return
    
    ! print the labels
    do i=1, size(labelList)
      print *, labelList(i)
    enddo
</PRE>

<P>
It is also possible to check the importState whether a <EM>specific</EM> method
   is attached. This allows the consumer code to implement alternatives in case
   the method is not available. 

<P>
<PRE>
    call ESMF_MethodGet(importState, label="finalCalculation", &amp;
      isPresent=isPresent, rc=rc)
    if (rc /= ESMF_SUCCESS) return
</PRE>

<P>
Finally call into the attached method from the consumer side. 

<P>
<PRE>
    call ESMF_MethodExecute(importState, label="finalCalculation", &amp;
      userRc=userRc, rc=rc)
    if (rc /= ESMF_SUCCESS) return
    rc = userRc
    if (rc /= ESMF_SUCCESS) return

  end subroutine !--------------------------------------------------------------
</PRE>

<P>


<H2><A NAME="SECTION04083000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Not reconciled.</B>
Attachable Methods are PET-local settings on an object. Currently Attachable
Methods cannot be reconciled (i.e. ignored during <TT>ESMF_StateReconcile()</TT>).
</LI>
<LI><B>No copy nor move.</B>
Currently Attachable Methods cannot be copied or moved between objects.
</LI>
</OL>

<P>

<H2><A NAME="SECTION04084000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04084100000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_MethodAdd - Attach user method to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodCplCompAdd(cplcomp, label, index, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Error out if there is a previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04084200000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_MethodAdd - Attach user method, located in shared object, to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodCplCompAddShObj(cplcomp, label, index, userRoutine, &amp;
     sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Error out if there is a previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodCplCompAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04084300000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_MethodAdd - Attach user method to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodGridCompAdd(gcomp, label, index, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(gcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)         :: gcomp        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Error out if there is a previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04084400000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_MethodAdd - Attach user method, located in shared object, to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodGridCompAddShObj(gcomp, label, index, userRoutine, &amp;
     sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Error out if there is a previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodGridCompAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04084500000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_MethodAdd - Attach user method to State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodStateAdd(state, label, index, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(state, rc)
         use ESMF_StateMod
         implicit none
         type(ESMF_State)            :: state        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Error out if there is a previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04084600000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_MethodAdd - Attach user method, located in shared object, to State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodStateAddShObj(state, label, index, userRoutine, &amp;
     sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Error out if there is a previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodStateAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04084700000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_MethodAddReplace - Attach user method to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAddReplace()
   subroutine ESMF_MethodCplCompAddRep(cplcomp, label, index, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Replacing potential previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04084800000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_MethodAddReplace - Attach user method, located in shared object, to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAddReplace()
   subroutine ESMF_MethodCplCompAddRepShObj(cplcomp, label, index, userRoutine, &amp;
     sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Replacing potential previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodCplCompAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04084900000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_MethodAddReplace - Attach user method to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAddReplace()
   subroutine ESMF_MethodGridCompAddRep(gcomp, label, index, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(gcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)         :: gcomp        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Replacing potential previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_MethodAddReplace - Attach user method, located in shared object, to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAddReplace()
   subroutine ESMF_MethodGridCompAddRepShObj(gcomp, label, index, userRoutine, &amp;
     sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Replacing potential previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodGridCompAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841100000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_MethodAddReplace - Attach user method to State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAddReplace()
   subroutine ESMF_MethodStateAddRep(state, label, index, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     interface
       subroutine userRoutine(state, rc)
         use ESMF_StateMod
         implicit none
         type(ESMF_State)            :: state        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Replacing potential previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841200000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_MethodAddReplace - Attach user method, located in shared object, to State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAddReplace()
   subroutine ESMF_MethodStateAddRepShObj(state, label, index, userRoutine, &amp;
     sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.
   Replacing potential previous attached method under the same
   <TT>label</TT> and <TT>index</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodStateAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.
     Prior to Fortran-2008, the subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified for it.
     An internal procedure which is contained within another procedure must not be used.
     From Fortran-2008 onwards, an internal procedure contained within either a main program
     or a module procedure may be used.  If the internal procedure is contained within a
     module procedure, it is subject to initialization requirements.  See: <A HREF="#sec:AppDriverIntProc">16.4.9</A>

<P>
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841300000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_MethodExecute - Execute user method attached to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodExecute()
   recursive subroutine ESMF_MethodCplCompExecute(cplcomp, label, index, existflag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[existflag]</STRONG></DT>
<DD>Returned <TT>.true.</TT> indicates that the method specified by <TT>label</TT>
     exists and was executed. A return value of <TT>.false.</TT> indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if <TT>existflag</TT> was not specified, the latter condition will lead
     to <TT>rc</TT> not equal <TT>ESMF_SUCCESS</TT> being returned. However, if
     <TT>existflag</TT> was specified, a method not existing is not an error
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by attached method before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841400000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_MethodExecute - Execute user method attached to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodExecute()
   recursive subroutine ESMF_MethodGridCompExecute(gcomp, label, index, existflag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[existflag]</STRONG></DT>
<DD>Returned <TT>.true.</TT> indicates that the method specified by <TT>label</TT>
     exists and was executed. A return value of <TT>.false.</TT> indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if <TT>existflag</TT> was not specified, the latter condition will lead
     to <TT>rc</TT> not equal <TT>ESMF_SUCCESS</TT> being returned. However, if
     <TT>existflag</TT> was specified, a method not existing is not an error
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by attached method before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841500000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_MethodExecute - Execute user method attached to State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodExecute()
   recursive subroutine ESMF_MethodStateExecute(state, label, index, existflag, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[existflag]</STRONG></DT>
<DD>Returned <TT>.true.</TT> indicates that the method specified by <TT>label</TT>
     exists and was executed. A return value of <TT>.false.</TT> indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if <TT>existflag</TT> was not specified, the latter condition will lead
     to <TT>rc</TT> not equal <TT>ESMF_SUCCESS</TT> being returned. However, if
     <TT>existflag</TT> was specified, a method not existing is not an error
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by attached method before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841600000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_MethodGet - Get info about user method attached to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodGet()
   subroutine ESMF_MethodCplCompGet(cplcomp, label, index, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: isPresent
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access information about attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD><TT>.true.</TT> if a method was attached for <TT>label</TT>/<TT>index</TT>.
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841700000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_MethodGet - Get info about user methods attached to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodGet()
   subroutine ESMF_MethodCplCompGetList(cplcomp, labelList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                                   :: cplcomp
     character(len=:), allocatable, intent(out)           :: labelList(:)
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access labels of all attached methods.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>labelList</STRONG></DT>
<DD>List of labels of <EM>all</EM> the attached methods. On return, it will be
     allocated with as many list elements as there are attached methods. The
     length of each label in <TT>labelList</TT> is that of the largest method label
     currently attached. Elements with shorter labels are padded with white
     spaces.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841800000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_MethodGet - Get info about user method attached to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodGet()
   subroutine ESMF_MethodGridCompGet(gcomp, label, index, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: isPresent
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access information about attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD><TT>.true.</TT> if a method was attached for <TT>label</TT>/<TT>index</TT>.
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040841900000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_MethodGet - Get info about user methods attached to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodGet()
   subroutine ESMF_MethodGridCompGetList(gcomp, labelList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                                  :: gcomp
     character(len=:), allocatable, intent(out)           :: labelList(:)
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access labels of all attached methods.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>labelList</STRONG></DT>
<DD>List of labels of <EM>all</EM> the attached methods. On return, it will be
     allocated with as many list elements as there are attached methods. The
     length of each label in <TT>labelList</TT> is that of the largest method label
     currently attached. Elements with shorter labels are padded with white
     spaces.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040842000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_MethodGet - Get info about user method attached to State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodGet()
   subroutine ESMF_MethodStateGet(state, label, index, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     logical,          intent(out), optional :: isPresent
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access information about attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD><TT>.true.</TT> if a method was attached for <TT>label</TT>/<TT>index</TT>.
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040842100000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_MethodGet - Get info about user methods attached to State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodGet()
   subroutine ESMF_MethodStateGetList(state, labelList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                     :: state
     character(len=:), allocatable, intent(out)           :: labelList(:)
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access labels of all attached methods.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>labelList</STRONG></DT>
<DD>List of labels of <EM>all</EM> the attached methods. On return, it will be
     allocated with as many list elements as there are attached methods. The
     length of each label in <TT>labelList</TT> is that of the largest method label
     currently attached. Elements with shorter labels are padded with white
     spaces.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040842200000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_MethodRemove - Remove user method attached to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodCplCompRemove(cplcomp, label, index, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040842300000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_MethodRemove - Remove user method attached to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodGridCompRemove(gcomp, label, index, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                      :: gcomp
     character(len=*),  intent(in)            :: label
      integer,          intent(in),  optional :: index
    integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040842400000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_MethodRemove - Remove user method attached to State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodStateRemove(state, label, index, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(in),  optional :: index
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object holding the attachable method.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Integer modifier to distinguish multiple entries with the same <TT>label</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<H1><A NAME="SECTION04090000000000000000">
<SPAN CLASS="arabic">23</SPAN> Web Services</A>
</H1>

<H2><A NAME="SECTION04091000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The goal of the ESMF Web Services is to provide the tools to allow ESMF Users to make 
their Components available via a web service.  The first step is to make the Component 
a service, and then make it accessible via the Web.  

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:webservices_fig"></A><A NAME="16753"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 11:</STRONG>
The diagram describes the ESMF Web Services software architecture. The architecture
defines a multi-tiered set of applications that provide a flexible approach for accessing
model components.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.5}{\includegraphics{webservices}}$
 -->
<IMG
 WIDTH="485" HEIGHT="437" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.png"
 ALT="\scalebox{0.5}{\includegraphics{webservices}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
At the heart of this architecture is the Component Service; this is the 
application that does the model work.  The ESMF Web Services part provides a way to make 
the model accessible via a network API (Application Programming Interface). ESMF provides 
the tools to turn a model component into a service as well as the tools to access the 
service from the network. 

<P>
The Process Controller is a stand-alone application that provides a control mechanism between 
the end user and the Component Service.  The Process Controller is responsible for managing 
client information as well as restricting client access to a Component Service.  
(The role of the Process Controller is expected to expand in the future.)

<P>
The tomcat/axis2 application provides the access via the Web using standard SOAP 
protocols. Part of this application includes the SOAP interface definition 
(using a WSDL file) as well as some java code that provides the access to the Process 
Controller application.

<P>
Finally, the Registrar maintains a list of Component Services that are currently 
available;  Component Services register themselves with the Registrar when they 
startup, and unregister themselves when they shutdown.  The list of available services 
is maintained in an XML file and is accessible from the Registrar using its network API.

<P>

<H3><A NAME="SECTION04091100000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating a Service around a Component</A>
</H3>

<H3><A NAME="SECTION04091200000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Code Modifications</A>
</H3>
One of the goals in providing the tools to make Components into services was to make 
the process as simple and easy as possible.  Any model component that has been 
implemented using the ESMF Component Framework can easily be turned into a 
Component Services with just a minor change to the Application 
driver code.  (For details on the ESMF Framework, see the ESMF Developers Documentation.)

<P>
The primary function in ESMF Web Services is the ESMF_WebServicesLoop routine.  This 
function registers the Component Service with the Registrar and then sets up a 
network socket service that listens for requests from a client.  It starts a loop 
that waits for incoming requests and manages the routing of these requests to 
all PETs.  It is also responsible for making sure the appropriate ESMF 
routine (ESMF_Initialize, ESMF_Run or ESMF_Finalize) is called based on the incoming 
request. When the client has completed its interaction with the Component Service, 
the loop will be terminated and it will unregister the Component Service from the Registrar. 

<P>
To make all of this happen, the Application Driver just needs to replace its calls to 
ESMF_Initialize, ESMF_Run, and ESMF_Finalize with a single call to ESMF_WebServicesLoop. 

<P>
<PRE>
	use ESMF_WebServMod
	....

	call ESMF_WebServicesLoop(gridComponent, portNumber, returnCode)
</PRE>

<P>
That's all there is to turning an ESMF Component into a network-accessible 
ESMF Component Service.  For a detailed example of an ESMF Component turned into 
an ESMF Component Service, see the Examples in the Web Services section of the 
Developer' Guide.

<P>

<H3><A NAME="SECTION04091300000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Accessing the Service</A>
</H3>
Now that the Component is available as a service, it can be accessed remotely by any client 
that can communicate via TCP sockets.  The ESMF library, in addition to providing the 
service tools, also provides the classes to create C++ clients to access the Component 
Service via the socket interface.

<P>
However, the goal of ESMF Web Services is to make an ESMF Component accessible through 
a standard web service, which is accomplished through the Process Controller and the 
Tomcat/Axis2 applications

<P>

<H3><A NAME="SECTION04091400000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Client Application via C++ API</A>
</H3>

<P>
Interfacing to a Component service is fairly simple using the ESMF library.  The following 
code is a simple example of how to interface to a Component Service in C++ and request 
the initialize operation (the entire sample client can be found in the Web Services examples 
section of the ESMF Distribution):

<P>
<PRE>
	#include "ESMCI_WebServCompSvrClient.h"

	int  main(int  argc, char*  argv[])
	{
   	    int    portNum = 27060;
      	    int    clientId = 101;
   	    int    rc = ESMF_SUCCESS;

   	    ESMCI::ESMCI_WebServCompSvrClient   
                         client("localhost", portNum, clientId);

   	    rc = client.init();
   	    printf("Initialize return code: %d\n", rc);
	}
</PRE>

<P>
To see a complete description of the NetEsmfClient class, refer to the netesmf library 
section of the Web Services Reference Manual.

<P>

<H3><A NAME="SECTION04091500000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Process Controller</A>
</H3>

<P>
The Process Controller is basically just a instance of a C++ client application. It manages 
client access to the Component Service (only 1 client can access the service at a time), 
and will eventually be responsible for starting up and shutting down instances of 
Component Services (planned for a future release). The Process Controller application is 
built with the ESMF library and is included in the apps section of the distribution.

<P>

<H3><A NAME="SECTION04091600000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Tomcat/Axis2</A>
</H3>

<P>
The Tomcat/Axis2 "application" is essentially the Apache Tomcat server using 
the Apache Axis2 servlet to  implement web services using SOAP protocols. The web 
interface is defined by a WSDL file, and its implementation is handled by the Component 
Connector java code.  Tomcat and Axis2 are both open source projects that should be 
downloaded from the Apache web site, but the WSDL file, the Component Connector java 
code, and all required software for supporting the interface can be found next to the 
ESMF distribution in the web_services_server directory. This code is not included with 
the ESMF distribution because they can be distributed and installed independent of each other.

<H2><A NAME="SECTION04092000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to use ESMF Web Services.

<P>

<P>

<P>

<H3><A NAME="SECTION04092100000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Making a Component available through ESMF Web Services</A>
</H3>

<P>
In this example, a standard ESMF Component is made available through
    the Web Services interface. 

<P>
The first step is to make sure your callback routines for initialize, run
    and finalize are setup.  This is done by creating a register routine that
    sets the entry points for each of these callbacks.  In this example, we've
    packaged it all up into a separate module.   

<P>
<PRE>
module ESMF_WebServUserModel

  ! ESMF Framework module
  use ESMF

  implicit none

  public ESMF_WebServUserModelRegister

  contains

  !-------------------------------------------------------------------------
  !  The Registration routine
  !  
  subroutine ESMF_WebServUserModelRegister(comp, rc)
    type(ESMF_GridComp)  :: comp
    integer, intent(out) :: rc

    ! Initialize return code
    rc = ESMF_SUCCESS

    print *, "User Comp1 Register starting"

    ! Register the callback routines.

    call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_INITIALIZE, &amp;
                                    userRoutine=user_init, rc=rc)
    if (rc/=ESMF_SUCCESS) return ! bail out

    call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_RUN, &amp;
                                    userRoutine=user_run, rc=rc)
    if (rc/=ESMF_SUCCESS) return ! bail out

    call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_FINALIZE, &amp;
                                    userRoutine=user_final, rc=rc)
    if (rc/=ESMF_SUCCESS) return ! bail out

    print *, "Registered Initialize, Run, and Finalize routines"
    print *, "User Comp1 Register returning"

  end subroutine

  !-------------------------------------------------------------------------
  !  The Initialization routine
  !  
  subroutine user_init(comp, importState, exportState, clock, rc)
    type(ESMF_GridComp)  :: comp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    ! Initialize return code
    rc = ESMF_SUCCESS

    print *, "User Comp1 Init"

  end subroutine user_init

  !-------------------------------------------------------------------------
  !  The Run routine
  !  
  subroutine user_run(comp, importState, exportState, clock, rc)
    type(ESMF_GridComp)  :: comp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    ! Initialize return code
    rc = ESMF_SUCCESS

    print *, "User Comp1 Run"

  end subroutine user_run

  !-------------------------------------------------------------------------
  !  The Finalization routine
  !  
  subroutine user_final(comp, importState, exportState, clock, rc)
    type(ESMF_GridComp)  :: comp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    ! Initialize return code
    rc = ESMF_SUCCESS

    print *, "User Comp1 Final"

  end subroutine user_final

end module ESMF_WebServUserModel
</PRE>

<P>
The actual driver code then becomes very simple; ESMF is initialized,
    the component is created, the callback functions for the component are
    registered, and the Web Service loop is started. 

<P>
<PRE>
program WebServicesEx
#include "ESMF.h"

  ! ESMF Framework module
  use ESMF
  use ESMF_TestMod

  use ESMF_WebServMod
  use ESMF_WebServUserModel

  implicit none

  ! Local variables
  type(ESMF_GridComp) :: comp1     !! Grid Component
  integer             :: rc        !! Return Code
  integer             :: finalrc  !! Final return code
  integer             :: portNum   !! The port number for the listening socket
</PRE>

<P>
A listening socket will be created on the local machine with the specified
    port number.  This socket is used by the service to
    wait for and receive requests from the client.  Check with your system
    administrator to determine an appropriate port to use for your service. 

<P>
<PRE>
  finalrc = ESMF_SUCCESS

  call ESMF_Initialize(defaultlogfilename="WebServicesEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
  ! create the grid component 
  comp1 = ESMF_GridCompCreate(name="My Component", rc=rc)
</PRE>

<P>
<PRE>
  ! Set up the register routine 
  call ESMF_GridCompSetServices(comp1, &amp;
          userRoutine=ESMF_WebServUserModelRegister, rc=rc)
</PRE>

<P>
<PRE>
  portNum = 27060

  ! Call the Web Services Loop and wait for requests to come in
  !call ESMF_WebServicesLoop(comp1, portNum, rc=rc)
</PRE>

<P>
The call to ESMF_WebServicesLoop will setup the listening socket for your
    service and will wait for requests from a client.  As requests are received,
    the Web Services software will process the requests and then return to the
    loop to continue to wait. 

<P>
The 3 main requests processed are INIT, RUN, and FINAL.  These requests 
    will then call the appropriate callback routine as specified in your 
    register routine (as specified in the ESMF_GridCompSetServices call).
    In this example, when the INIT request is received, the user_init routine
    found in the ESMF_WebServUserModel module is called. 

<P>
One other request is also processed by the Component Service, and that is
    the EXIT request.  When this request is received, the Web Services loop
    is terminated and the remainder of the code after the ESMF_WebServicesLoop
    call is executed. 

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program WebServicesEx
</PRE>

<P>


<H2><A NAME="SECTION04093000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Manual Control of Process.</B>
Currently, the Component Service must be manually started and stopped.  Future plans include having the Process Controller be responsible for controlling the Component Service processes.
</LI>
<LI><B>Data Streaming.</B>
While data can be streamed from the web server to the client, it is not yet getting the data directly from the Component Service.  Instead, the Component Service exports the data to a file which the Process Controller can read and return across the network interface.  The data streaming capabilities will be a major component of future improvements to the Web Services architecture.
</LI>
</OL>

<P>

<H2><A NAME="SECTION04094000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04094100000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_WebServicesLoop </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_WebServicesLoop(comp, portNum, clientId, registrarHost, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                         :: comp
     integer,            intent(inout), optional :: portNum
     character(len=*),   intent(in),    optional, target :: clientId
     character(len=*),   intent(in),    optional, target :: registrarHost
     integer,            intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Encapsulates all of the functionality necessary to setup a component as
     a component service.  On the root PET, it registers the
     component service and then enters into a loop that waits for requests on 
     a socket.  The loop continues until an "exit" request is received, at 
     which point it exits the loop and unregisters the service.  On
     any PET other than the root PET, it sets up a process block that waits
     for instructions from the root PET.  Instructions will come as requests
     are received from the socket.

<P>
The arguments are:
   <DL>
<DT><STRONG>[comp]</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> object that represents the Grid Component for which
     routine is run.
   
</DD>
<DT><STRONG>[portNum]</STRONG></DT>
<DD>Number of the port on which the component service is listening.
   
</DD>
<DT><STRONG>[clientId]</STRONG></DT>
<DD>Identifier of the client responsible for this component service.  If a
     Process Controller application manages this component service, then the
     clientId is provided to the component service application in the command
     line.  Otherwise, the clientId is not necessary.
   
</DD>
<DT><STRONG>[registrarHost]</STRONG></DT>
<DD>Name of the host on which the Registrar is running.  Needed so the
     component service can notify the Registrar when it is ready to receive
     requests from clients.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04094200000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_WebServicesCplCompLoop </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_WebServicesCplCompLoop(comp, portNum, clientId, registrarHost, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                         :: comp
     integer,           intent(inout), optional :: portNum
     character(len=*),  intent(in),    optional, target :: clientId
     character(len=*),  intent(in),    optional, target :: registrarHost
     integer,           intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Encapsulates all of the functionality necessary to setup a component as
     a component service.  On the root PET, it registers the
     component service and then enters into a loop that waits for requests on 
     a socket.  The loop continues until an "exit" request is received, at 
     which point it exits the loop and unregisters the service.  On
     any PET other than the root PET, it sets up a process block that waits
     for instructions from the root PET.  Instructions will come as requests
     are received from the socket.

<P>
The arguments are:
   <DL>
<DT><STRONG>[comp]</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> object that represents the Grid Component for which
     routine is run.
   
</DD>
<DT><STRONG>[portNum]</STRONG></DT>
<DD>Number of the port on which the component service is listening.
   
</DD>
<DT><STRONG>[clientId]</STRONG></DT>
<DD>Identifier of the client responsible for this component service.  If a
     Process Controller application manages this component service, then the
     clientId is provided to the component service application in the command
     line.  Otherwise, the clientId is not necessary.
   
</DD>
<DT><STRONG>[registrarHost]</STRONG></DT>
<DD>Name of the host on which the Registrar is running.  Needed so the
     component service can notify the Registrar when it is ready to receive
     requests from clients.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html1931"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1927"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1921"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1929"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1932"
  HREF="node5.html">4 Infrastructure: Fields and</A>
<B> Up:</B> <A NAME="tex2html1928"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1922"
  HREF="node3.html">2 Command Line Tools</A>
 &nbsp; <B>  <A NAME="tex2html1930"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
