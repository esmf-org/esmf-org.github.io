<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>2 Design and Implementation Notes</TITLE>
<META NAME="description" CONTENT="2 Design and Implementation Notes">
<META NAME="keywords" CONTENT="NUOPC_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="NUOPC_refdoc.css">

<LINK REL="next" HREF="node4.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="NUOPC_refdoc.html">
<LINK REL="next" HREF="node4.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html412"
  HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html408"
  HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html402"
  HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html410"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html413"
  HREF="node4.html">3 API</A>
<B> Up:</B> <A NAME="tex2html409"
  HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A NAME="tex2html403"
  HREF="node2.html">1 Description</A>
 &nbsp; <B>  <A NAME="tex2html411"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html414"
  HREF="node3.html#SECTION00031000000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Generic Components</A>
<UL>
<LI><A NAME="tex2html415"
  HREF="node3.html#SECTION00031100000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Component Specialization</A>
<LI><A NAME="tex2html416"
  HREF="node3.html#SECTION00031200000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Partial Specialization</A>
</UL>
<BR>
<LI><A NAME="tex2html417"
  HREF="node3.html#SECTION00032000000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Field Dictionary</A>
<UL>
<LI><A NAME="tex2html418"
  HREF="node3.html#SECTION00032100000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field Dictionary file</A>
<LI><A NAME="tex2html419"
  HREF="node3.html#SECTION00032200000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Preloaded Field Dictionary</A>
</UL>
<BR>
<LI><A NAME="tex2html420"
  HREF="node3.html#SECTION00033000000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Metadata</A>
<UL>
<LI><A NAME="tex2html421"
  HREF="node3.html#SECTION00033100000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Driver Component Metadata</A>
<LI><A NAME="tex2html422"
  HREF="node3.html#SECTION00033200000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Model Component Metadata</A>
<LI><A NAME="tex2html423"
  HREF="node3.html#SECTION00033300000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Mediator Component Metadata</A>
<LI><A NAME="tex2html424"
  HREF="node3.html#SECTION00033400000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Connector Component Metadata</A>
<LI><A NAME="tex2html425"
  HREF="node3.html#SECTION00033500000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> State Metadata</A>
<LI><A NAME="tex2html426"
  HREF="node3.html#SECTION00033600000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Field Metadata</A>
</UL>
<BR>
<LI><A NAME="tex2html427"
  HREF="node3.html#SECTION00034000000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Initialization</A>
<UL>
<LI><A NAME="tex2html428"
  HREF="node3.html#SECTION00034100000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Phase Maps, Semantic Specialization Labels, and Component Labels</A>
<LI><A NAME="tex2html429"
  HREF="node3.html#SECTION00034200000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> Field Pairing</A>
<LI><A NAME="tex2html430"
  HREF="node3.html#SECTION00034300000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> Namespaces</A>
<LI><A NAME="tex2html431"
  HREF="node3.html#SECTION00034400000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> Using Coupling Sets for Coupling Multiple Nests</A>
<LI><A NAME="tex2html432"
  HREF="node3.html#SECTION00034500000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> Connection Options</A>
<LI><A NAME="tex2html433"
  HREF="node3.html#SECTION00034600000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> Data-Dependencies during Initialize</A>
<LI><A NAME="tex2html434"
  HREF="node3.html#SECTION00034700000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> Transfer of Grid/Mesh/LocStream Objects between Components</A>
<LI><A NAME="tex2html435"
  HREF="node3.html#SECTION00034800000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> Field and Grid/Mesh/LocStream Reference Sharing</A>
<LI><A NAME="tex2html436"
  HREF="node3.html#SECTION00034900000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> Field Mirroring</A>
</UL>
<BR>
<LI><A NAME="tex2html437"
  HREF="node3.html#SECTION00035000000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Timekeeping</A>
<LI><A NAME="tex2html438"
  HREF="node3.html#SECTION00036000000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Component Hierarchies</A>
<LI><A NAME="tex2html439"
  HREF="node3.html#SECTION00037000000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Resource Control and Threaded Components</A>
<LI><A NAME="tex2html440"
  HREF="node3.html#SECTION00038000000000000000"><SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> External NUOPC Interface</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00030000000000000000">
<SPAN CLASS="arabic">2</SPAN> Design and Implementation Notes</A>
</H1>

<P>
The NUOPC Layer is implemented in Fortran on top of the public ESMF Fortran API.

<P>
The NUOPC utility routines form a very straightforward Fortran API, accessible through the <TT>NUOPC</TT> Fortran module. The interfaces only use native Fortran types and public ESMF derived types. In order to access the utility API of the NUOPC Layer, user code must include the following two <TT>use</TT> lines:

<P>
<PRE>
  use ESMF
  use NUOPC
</PRE>

<H2><A NAME="SECTION00031000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Generic Components</A>
</H2>

<P>
The NUOPC generic components are implemented as a <EM>collection</EM> of Fortran modules. Each module implements a single, well specified set of standard <TT>ESMF_GridComp</TT> or <TT>ESMF_CplComp</TT> methods. The nomenclature of the generic component modules starts with the <TT>NUOPC_</TT> prefix and continues with the kind: <TT>Driver</TT>, <TT>Model</TT>, <TT>Mediator</TT>, or <TT>Connector</TT>. The four kinds of generic components implemented by the NUOPC Layer are:

<P>

<UL>
<LI><TT>NUOPC_Driver</TT> - A generic driver component. It implements a child component harness, made of State and Component objects, that follows the NUOPC Common Model Architecture. It is specialized by plugging <TT>Model</TT>, <TT>Mediator</TT>, and <TT>Connector</TT> components into the harness. <TT>Driver</TT> components can be plugged into the harness to construct component hierarchies. The generic <TT>Driver</TT> initializes its child components according to a standard Initialization Phase Definition, and drives their Run() methods according a customizable run sequence.

<P>
</LI>
<LI><TT>NUOPC_Model</TT> - A generic model component that wraps a model code so it is suitable to be plugged into a generic <TT>Driver</TT> component.

<P>
</LI>
<LI><TT>NUOPC_Mediator</TT> - A generic mediator component that wraps custom coupling code (flux calculations, averaging, etc.) so it is suitable to be plugged into a generic <TT>Driver</TT> component.

<P>
</LI>
<LI><TT>NUOPC_Connector</TT> - A generic component that implements Field matching based on metadata and executes simple transforms (Regrid and Redist). It can be plugged into a generic <TT>Driver</TT> component.

<P>
</LI>
</UL>

<P>
The user code accesses the desired generic component(s) by including a <TT>use</TT> line for each one. Each generic component defines a small set of public names that are made available to the user code through the <TT>use</TT> statement. At a minimum the <TT>SetServices</TT> method is made public. Some of the generic components define additional public routines and labels as part of their user interface. It is recommended to rename entries of an imported generic component module, such as <TT>SetServices</TT>, in the local scope as part of the <TT>use</TT> association to prevent potential name clashes.

<P>
<PRE>
  use NUOPC_&lt;GenericComp&gt;, &amp;
    &lt;GenericComp&gt;SS      =&gt; SetServices
</PRE>

<P>
A generic component is used by user code to implement a specialized version of the generic component. The user component derives from the generic component code by implementing its own public <TT>SetServices</TT> routine that calls into the generic <TT>SetServices</TT> routine via the <TT>NUOPC_CompDerive()</TT> method.
Typically this should be the first call made before doing anything else. It is through this mechanism that the deriving component <EM>inherits</EM> functionality that is implemented in the generic component. The example below shows how a specific <EM>model</EM> component is implemented, deriving from the generic <TT>NUOPC_Model</TT>:

<P>
<PRE>
  use NUOPC_Model, &amp;
    modelSS =&gt; SetServices

  subroutine SetServices(model, rc)
    type(ESMF_GridComp)  :: model
    integer, intent(out) :: rc

    ! derive from NUOPC_Model
    call NUOPC_CompDerive(model, modelSS, rc=rc)

    ! specialize model
    !... calls to NUOPC_CompSpecialize() here
    
  end subroutine
</PRE>

<P>

<H3><A NAME="SECTION00031100000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Component Specialization</A>
</H3>

<P>
After the call to <TT>NUOPC_CompDerive()</TT> in a component's <TT>SetServices()</TT> method, the component is connected to all of the generic code provided by NUOPC for the respective component kind. In order to function properly, e.g. as an atmosphere model, ocean model, driver, etc., the component must be <EM>specialized</EM>.

<P>
The <TT>NUOPC_CompSpecialize()</TT> method is used to link specific user provided routines to pre-defined NUOPC specialization points. The labels of the pre-defined specialization points are use associated named constants made available by the respective generic component module. The naming of all pre-defined specialization labels starts with the <TT>label_</TT> prefix, and is followed by a short intent of the specialization. E.g. <TT>label_Advertise</TT> refers to the specialization point responsible for advertising Fields in the import- and exportStates of the component.

<P>
There are pre-defined specialization labels for Initialize, Run, and Finalize phases. Section <A HREF="#PhaseMaps">2.4.1</A> discusses the semantic labeling of specializations in greater detail. Lists of <EM>all</EM> pre-defined specialization labels for Initialize, Run, and Finalize, for each of the generic NUOPC component kinds, are provided at the beginning of the respective API sections. (Driver: <A HREF="node4.html#NUOPC_Driver">3.1</A>, Model: <A HREF="node4.html#NUOPC_Model">3.3</A>, Mediator: <A HREF="node4.html#NUOPC_Mediator">3.4</A>, Connector: <A HREF="node4.html#NUOPC_Connector">3.5</A>)

<P>
The following code snippet shows a full specialization of <TT>NUOPC_Model</TT>, using three specialization labels:

<P>
<PRE>
  use NUOPC_Model, &amp;
    modelSS =&gt; SetServices

  subroutine SetServices(model, rc)
    type(ESMF_GridComp)  :: model
    integer, intent(out) :: rc

    rc = ESMF_SUCCESS

    ! derive from NUOPC_Model
    call NUOPC_CompDerive(model, modelSS, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
      line=__LINE__, &amp;
      file=__FILE__)) &amp;
      return  ! bail out

    ! specialize model
    call NUOPC_CompSpecialize(model, specLabel=label_Advertise, &amp;
      specRoutine=Advertise, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
      line=__LINE__, &amp;
      file=__FILE__)) &amp;
      return  ! bail out
    call NUOPC_CompSpecialize(model, specLabel=label_RealizeProvided, &amp;
      specRoutine=Realize, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
      line=__LINE__, &amp;
      file=__FILE__)) &amp;
      return  ! bail out
    call NUOPC_CompSpecialize(model, specLabel=label_Advance, &amp;
      specRoutine=Advance, rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
      line=__LINE__, &amp;
      file=__FILE__)) &amp;
      return  ! bail out

  end subroutine
</PRE>

<P>
The user implemented specialization routines must follow the NUOPC interface definition.

<P>
<PRE>
  subroutine SpecRoutine(comp, rc)
    type(ESMF_*Comp)      :: comp
    integer, intent(out)  :: rc
  end subroutine
</PRE>

<P>
Here <TT>type(ESMF_*Comp)</TT> either corresponds to <TT>type(ESMF_GridComp)</TT> for Models, Mediators, and Drivers, or <TT>type(ESMF_CplComp)</TT> for Connectors.

<P>

<H3><A NAME="SECTION00031200000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Partial Specialization</A>
</H3>

<P>
Components that are derived from a generic component may choose to only specialize certain aspects, leaving other aspects unspecified. This allows a hierarchy of generic components to be implemented with a high degree of code re-use. The variable level of specialization supports the very differing user needs. Figure <A HREF="#fig:NUOPCGenericComp">1</A> depicts the inheritance structure of the standard generic components implemented by the NUOPC Layer. There are two trees, one is rooted in <TT>ESMF_GridComp</TT>, while the other is rooted in <TT>ESMF_CplComp</TT>.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:NUOPCGenericComp"></A><A NAME="266"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
The NUOPC Generic Component inheritance structure. The tree on the left is rooted in <TT>ESMF_GridComp</TT>, while the tree on the right is rooted in <TT>ESMF_CplComp</TT>. The ESMF data types are shown in green. The four main NUOPC Generic Component kinds are shown in dark blue boxes. The yellow box shows a partial specialization in the inheritance tree.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<BR>
<BR>
<BR>
<BR>
<!-- MATH
 $\scalebox{0.6}{\includegraphics{NUOPC_GC}}$
 -->
<IMG
 WIDTH="575" HEIGHT="182" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="\scalebox{0.6}{\includegraphics{NUOPC_GC}}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION00032000000000000000"></A>

<A NAME="field_dictionary"></A>
<BR>
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Field Dictionary
</H2>

<P>
The NUOPC Layer uses standard metadata on Fields to guide the decision making process that is implemented in generic code. The generic <TT>NUOPC_Connector</TT> component, for instance, uses the <TT>StandardName</TT> Attribute to construct a list of matching Fields between the import and export States. The NUOPC Field Dictionary provides a software implementation of a controlled vocabulary for the <TT>StandardName</TT> Field Attribute. It also associates each registered <TT>StandardName</TT> with <TT>CanonicalUnits</TT>. Currently the NUOPC Layer uses the <TT>CanonicalUnits</TT> entry to verify that Fields are provided in their canonical units. In the future, this entry may help support automatic unit conversion among exchanged fields.

<P>
The NUOPC Field Dictionary is set up by loading its content from a <A NAME="tex2html2"
  HREF="http://yaml.org/spec/1.2/spec.html">YAML 1.2</A>
file. See section&nbsp;<A HREF="#fd:docfile">2.2.1</A> for details.

<P>
Users can extend the dictionary by adding entries (field definitions or synonyms) to the YAML file, or by calling the <TT>NUOPC_FieldDictionaryAddEntry()</TT> interface.

<P>

<H3><A NAME="SECTION00032100000000000000"></A>
<A NAME="fd:docfile"></A>
<BR>
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field Dictionary file
</H3>

<P>
In a given NUOPC application, the NUOPC Field Dictionary can be set up by calling the <TT>NUOPC_FieldDictionarySetup()</TT> method to read in a properly-formatted YAML file. This feature is intended to improve the interoperability of codes that use the NUOPC Layer, as it allows a broader scientific community to contribute to the growth and upkeep of a common NUOPC Field Dictionary file shared among different Earth System Models. At this time, an initial version of the NUOPC Field Dictionary file is available through the dedicated GitHub repository: <A NAME="tex2html3"
  HREF="https://github.com/ESCOMP/NUOPCFieldDictionary">https://github.com/ESCOMP/NUOPCFieldDictionary</A>, hosted within the Earth System Community Modeling Portal (<A NAME="tex2html4"
  HREF="https://github.com/ESCOMP">ESCOMP</A>).

<P>
A NUOPC Field Dictionary YAML file is codified as a YAML map (an unordered association of unique keys to values) with only one key: <TT>field_dictionary</TT>. The value associated with this key is itself a YAML map that should include the mandatory key <TT>entries</TT> (pointing to the complete set of dictionary entries), and may include the optional keys: <TT>version_number</TT>, <TT>last_modified</TT>, <TT>institution</TT>, <TT>contact</TT>, <TT>source</TT>, and <TT>description</TT>. These optional keys are intended to hold information about the file itself and are currently ignored by the NUOPC Layer.

<P>
Entries in the NUOPC Field dictionary are organized as YAML lists of maps. List items under the <TT>entries</TT> keyword must be indented and preceded with a hyphen (<TT>-</TT>).

<P>
A dictionary entry fully defines a Field if it includes both the <TT>standard_name</TT> and <TT>canonical_units</TT> keys and their associated values. This entry may also include a brief narrative describing the Field, stored as the value of the optional key <TT>description</TT>.

<P>
Synonyms can be defined by adding separate entries that include both the <TT>alias</TT> key, associated with either a single synonym (YAML scalar, e.g. <TT>alias: &lt;name&gt;</TT>) or a comma-separated list of synonyms within square brackets (YAML flow sequence, e.g. <TT>alias: [&lt;name1&gt;, &lt;name2&gt;, ...]</TT>), and the <TT>standard_name</TT> key associated with the original Field name to be substituted. The original Field name must be fully defined in the dictionary file. While adding one <TT>alias</TT> keyword to a Field definition dictionary entry is allowed and will be parsed by the NUOPC Layer, it is recommended that all synonyms be included as separate entries.

<P>
A NUOPC Field dictionary sample file is included below.

<P>
<PRE>
field_dictionary:
    version_number: 0.0.1
    last_modified:  2018-03-14T11:01:19Z
    institution:    National ESPC, CSC &amp; MCL Working Groups
    contact:        esmf_support@ucar.edu

    source:         https://github.com/ESCOMP/NUOPCFieldDictionary
    description:    Community-based dictionary for shared coupling fields

    entries:
      - standard_name: air_pressure
        canonical_units: Pa
        description: Air pressure
      - standard_name: air_temperature
        canonical_units: K
        description:
          Bulk temperature of the air,
          not the surface (skin) temperature
      - alias: p
        standard_name: air_pressure
      - alias: [ t, temp ]
        standard_name: air_temperature
</PRE>

<P>

<H3><A NAME="SECTION00032200000000000000"></A>
<A NAME="fd:default"></A>
<BR>
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Preloaded Field Dictionary
</H3>

<P>
A version of the NUOPC Field Dictionary is preloaded by the NUOPC Layer at start-up, and, at this time, consists of the entries show in the table below. The value of the <TT>StandardName</TT> Attribute in each of these entries complies with the Climate and Forecast (CF) conventions <A NAME="tex2html5"
  HREF="http://cfconventions.org/Data/cf-standard-names/docs/guidelines.html">guidelines</A>.

<P>

<P>

<P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>StandardName</B></TD>
<TD ALIGN="LEFT"><B>CanonicalUnits</B></TD>
</TR>
<TR><TD ALIGN="LEFT">air_pressure_at_sea_level</TD>
<TD ALIGN="LEFT">Pa</TD>
</TR>
<TR><TD ALIGN="LEFT">magnitude_of_surface_downward_stress</TD>
<TD ALIGN="LEFT">Pa</TD>
</TR>
<TR><TD ALIGN="LEFT">precipitation_flux</TD>
<TD ALIGN="LEFT">kg m-2 s-1</TD>
</TR>
<TR><TD ALIGN="LEFT">sea_surface_height_above_sea_level</TD>
<TD ALIGN="LEFT">m</TD>
</TR>
<TR><TD ALIGN="LEFT">sea_surface_salinity</TD>
<TD ALIGN="LEFT">1e-3</TD>
</TR>
<TR><TD ALIGN="LEFT">sea_surface_temperature</TD>
<TD ALIGN="LEFT">K</TD>
</TR>
<TR><TD ALIGN="LEFT">surface_downward_eastward_stress</TD>
<TD ALIGN="LEFT">Pa</TD>
</TR>
<TR><TD ALIGN="LEFT">surface_downward_heat_flux_in_air</TD>
<TD ALIGN="LEFT">W m-2</TD>
</TR>
<TR><TD ALIGN="LEFT">surface_downward_northward_stress</TD>
<TD ALIGN="LEFT">Pa</TD>
</TR>
<TR><TD ALIGN="LEFT">surface_downward_water_flux</TD>
<TD ALIGN="LEFT">kg m-2 s-1</TD>
</TR>
<TR><TD ALIGN="LEFT">surface_eastward_sea_water_velocity</TD>
<TD ALIGN="LEFT">m s-1</TD>
</TR>
<TR><TD ALIGN="LEFT">surface_net_downward_longwave_flux</TD>
<TD ALIGN="LEFT">W m-2</TD>
</TR>
<TR><TD ALIGN="LEFT">surface_net_downward_shortwave_flux</TD>
<TD ALIGN="LEFT">W m-2</TD>
</TR>
<TR><TD ALIGN="LEFT">surface_northward_sea_water_velocity</TD>
<TD ALIGN="LEFT">m s-1</TD>
</TR>
</TABLE>

<P>


<H2><A NAME="SECTION00033000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Metadata</A>
</H2>
<A NAME="Metadata"></A>
<P>
The NUOPC Layer makes extensive use of the ESMF Attribute class to implement metadata on Components, States, and Fields. ESMF Attribute Packages (or AttPacks for short) are used to build an Attribute hierarchy for each object.

<P>
In some cases the lowest level NUOPC AttPack contains a nested AttPack defined by ESMF. For all objects, the highest level of the NUOPC AttPack hierarchy is implemented with convention="NUOPC", purpose="Instance". The public NUOPC Layer API allows a user to add Attributes to the highest AttPack hierarchy level.

<H3><A NAME="SECTION00033100000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Driver Component Metadata</A>
</H3>
<A NAME="DriverCompMeta"></A>The Driver Component metadata is implemented through ESMF_Info. It can be accessed
using the JSON Pointer "/NUOPC/Instance/" prefix followed by the "Attribute name"
as per the table below. E.g. "Verbosity" is accessed using <TT>key="/NUOPC/Instance/Verbosity"</TT>.

<P>
<B>Note</B> that some of the Attribute names in the following table are longer than the table column width. In these cases the
Attribute name had to be broken into multiple lines. When that happens, a hyphen shows up to indicate the line break. The hyphen
is <EM>not</EM> part of the Attribute name!

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><B>Attribute name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><B>Controlled vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Kind</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating component kind.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>Driver</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Verbosity</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control verbosity of the generic component implementation. Higher bits are available for user level verbosity control. <BR>
                       <B>bit 0</B>: Intro/Extro of methods with indentation.
<BR>
                       <B>bit 1</B>: Intro/Extro with memory info.
<BR>
                       <B>bit 2</B>: Intro/Extro with garbage collection info.
<BR>
                       <B>bit 3</B>: Intro/Extro with local VM info.
<BR>
                       <B>bit 4</B>: Intro/Extro with ImportState info.
<BR>
                       <B>bit 5</B>: Intro/Extro with ExportState info.
<BR>
                       <B>bit 6</B>: Log hierarchy protocol details.
<BR>
                       <B>bit 8</B>: Log Initialize phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 9</B>: Log Run phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 10</B>: Log Finalize phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 11</B>: Log info about data dependency during initialize resolution.
<BR>
                       <B>bit 12</B>: Log run sequence execution.
<BR>
                       <B>bit 13</B>: Log Component creation and destruction.
<BR>
                       <B>bit 14</B>: Log State creation and destruction.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "low": some verbosity, bits: 0, 8, 9, 10, 13
<BR>
                       "high": more verbosity, bits: 0, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14
<BR>
                       "max": all lower 16 bits</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Profiling</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control profiling of the generic component implementation. Higher bits are available for user level profiling control. <BR>
                       <B>bit 0</B>: Top level profiling of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 1</B>: Specialization point profiling of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 2</B>: Additional profiling of internals of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 3</B>: Top level profiling of <EM>Run</EM> phases.
<BR>
                       <B>bit 4</B>: Specialization point profiling of <EM>Run</EM> phases.
<BR>
                       <B>bit 5</B>: Additional profiling of internals of <EM>Run</EM> phases.
<BR>
                       <B>bit 6</B>: Top level profiling of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 7</B>: Specialization point profiling of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 8</B>: Additional profiling of internals of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 9</B>: Leading barrier for <EM>Initialize</EM> phases.
<BR>
                       <B>bit 10</B>: Leading barrier for <EM>Run</EM> phases.
<BR>
                       <B>bit 11</B>: Leading barrier for <EM>Finalize</EM> phases.
<BR>
                       <B>bit 12</B>: Run sequence iteration events.
<BR></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "low": Top level profiling. <BR>
                       "high": Top level, specialization point profiling, and additional profiling of internals. <BR>
                       "max": All lower 16 bits set.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>CompLabel</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value holding the label under which the component was added to its parent driver.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC initialize phases, of a specific Initialize Phase Definition (IPD) version, to the actual ESMF initialize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>IPDvXXpY=Z, where XX = two-digit revision number, e.g. 01, Y = logical NUOPC phase number, Z = actual ESMF phase number, with Y, Z &gt; 0 and Y, Z &lt; 10</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>RunPhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC run phases to the actual ESMF run phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>label-string</EM>=Z, where <EM>label-string</EM> can be chosen freely, and Z = actual ESMF phase number.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>FinalizePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC finalize phases to the actual ESMF finalize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>label-string</EM>=Z, where <EM>label-string</EM> can be chosen freely, and Z = actual ESMF phase number.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InternalInitializePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC initialize phases, of a specific Initialize Phase Definition (IPD) version, to the actual ESMF initialize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>IPDvXXpY=Z, where XX = two-digit revision number, e.g. 01, Y = logical NUOPC phase number, Z = actual ESMF phase number, with Y, Z &gt; 0 and Y, Z &lt; 10</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>NestingGeneration</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Integer value enumerating nesting level.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ...</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Nestling</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Integer value enumerating siblings within the same generation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ...</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializeDataResolution</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating whether the resolution loop is disabled or enabled.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializeDataComplete</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating whether all initialize data dependencies have been satisfied.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializeDataProgress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating whether progress is being made resolving initialize data dependencies.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>HierarchyProtocol</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value specifying the hierarchy protocol.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>"PushUpAllExportsAndUnsatisfiedImports" - activates field mirroring of all exports and unsatisfied imports. By default use reference sharing for the mirrored fields and geom objects. This is the default behavior without having <TT>HierarchyProtocol</TT> set. "ConnectProvidedFields"- no field mirroring, only connect to externally provided fields in the import- and exportStates. "Explorer" - like the default, but do not use reference sharing. <EM>All other values currently disable the hierarchy protocol.</EM></TD>
</TR>
</TABLE>

<H3><A NAME="SECTION00033200000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Model Component Metadata</A>
</H3>
<A NAME="ModelCompMeta"></A>The Model Component metadata is implemented through ESMF_Info. It can be accessed
using the JSON Pointer "/NUOPC/Instance/" prefix followed by the "Attribute name"
as per the table below. E.g. "Verbosity" is accessed using <TT>key="/NUOPC/Instance/Verbosity"</TT>.

<P>
<B>Note</B> that some of the Attribute names in the following table are longer than the table column width. In these cases the
Attribute name had to be broken into multiple lines. When that happens, a hyphen shows up to indicate the line break. The hyphen
is <EM>not</EM> part of the Attribute name!

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><B>Attribute name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><B>Controlled vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Kind</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating component kind.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>Model</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Verbosity</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control verbosity of the generic component implementation. Higher bits are available for user level verbosity control. <BR>
                       <B>bit 0</B>: Intro/Extro of methods with indentation.
<BR>
                       <B>bit 1</B>: Intro/Extro with memory info.
<BR>
                       <B>bit 2</B>: Intro/Extro with garbage collection info.
<BR>
                       <B>bit 3</B>: Intro/Extro with local VM info.
<BR>
                       <B>bit 4</B>: Intro/Extro with ImportState info.
<BR>
                       <B>bit 5</B>: Intro/Extro with ExportState info.
<BR>
                       <B>bit 8</B>: Log Initialize phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 9</B>: Log Run phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 10</B>: Log Finalize phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 11</B>: Log info about data dependency during initialize resolution.
<BR>
                       <B>bit 12</B>: Log run sequence execution.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "low": some verbosity, bits: 0, 8, 9, 10, 13
<BR>
                       "high": more verbosity, bits: 0, 4, 5, 8, 9, 10, 11, 12, 13, 14
<BR>
                       "max": all lower 16 bits</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Profiling</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control profiling of the generic component implementation. Higher bits are available for user level profiling control. <BR>
                       <B>bit 0</B>: Top level profiling of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 1</B>: Specialization point profiling of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 2</B>: Additional profiling of internals of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 3</B>: Top level profiling of <EM>Run</EM> phases.
<BR>
                       <B>bit 4</B>: Specialization point profiling of <EM>Run</EM> phases.
<BR>
                       <B>bit 5</B>: Additional profiling of internals of <EM>Run</EM> phases.
<BR>
                       <B>bit 6</B>: Top level profiling of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 7</B>: Specialization point profiling of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 8</B>: Additional profiling of internals of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 9</B>: Leading barrier for <EM>Initialize</EM> phases.
<BR>
                       <B>bit 10</B>: Leading barrier for <EM>Run</EM> phases.
<BR>
                       <B>bit 11</B>: Leading barrier for <EM>Finalize</EM> phases.
<BR></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "low": Top level profiling. <BR>
                       "high": Top level, specialization point profiling, and additional profiling of internals. <BR>
                       "max": All lower 16 bits set.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Diagnostic</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control diagnostic of the generic component implementation. Higher bits are available for user level diagnostic control. <BR>
                       <B>bit 0</B>: Dump fields of the importState on entering <EM>Initialize</EM> phases.
<BR>
                       <B>bit 1</B>: Dump fields of the exportState on entering <EM>Initialize</EM> phases.
<BR>
                       <B>bit 2</B>: Dump fields of the importState on exiting <EM>Initialize</EM> phases.
<BR>
                       <B>bit 3</B>: Dump fields of the exportState on exiting <EM>Initialize</EM> phases.
<BR>
                       <B>bit 4</B>: Dump fields of the importState on entering <EM>Run</EM> phases.
<BR>
                       <B>bit 5</B>: Dump fields of the exportState on entering <EM>Run</EM> phases.
<BR>
                       <B>bit 6</B>: Dump fields of the importState on exiting <EM>Run</EM> phases.
<BR>
                       <B>bit 7</B>: Dump fields of the exportState on exiting <EM>Run</EM> phases.
<BR>
                       <B>bit 8</B>: Dump fields of the importState on entering <EM>Finalize</EM> phases.
<BR>
                       <B>bit 9</B>: Dump fields of the exportState on entering <EM>Finalize</EM> phases.
<BR>
                       <B>bit 10</B>: Dump fields of the importState on exiting <EM>Finalize</EM> phases.
<BR>
                       <B>bit 11</B>: Dump fields of the exportState on exiting <EM>Finalize</EM> phases.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "max": All lower 16 bits set.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>CompLabel</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value holding the label under which the component was added to its parent driver.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC initialize phases, of a specific Initialize Phase Definition (IPD) version, to the actual ESMF initialize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>IPDvXXpY=Z, where XX = two-digit revision number, e.g. 01, Y = logical NUOPC phase number, Z = actual ESMF phase number, with Y, Z &gt; 0 and Y, Z &lt; 10</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>RunPhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC run phases to the actual ESMF run phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>label-string</EM>=Z, where <EM>label-string</EM> can be chosen freely, and Z = actual ESMF phase number.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>FinalizePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC finalize phases to the actual ESMF finalize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>label-string</EM>=Z, where <EM>label-string</EM> can be chosen freely, and Z = actual ESMF phase number.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InternalInitializePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC initialize phases, of a specific Initialize Phase Definition (IPD) version, to the actual ESMF initialize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>IPDvXXpY=Z, where XX = two-digit revision number, e.g. 01, Y = logical NUOPC phase number, Z = actual ESMF phase number, with Y, Z &gt; 0 and Y, Z &lt; 10</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>NestingGeneration</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Integer value enumerating nesting level.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ...</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Nestling</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Integer value enumerating siblings within the same generation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ...</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializeDataComplete</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating whether all initialize data dependencies have been satisfied.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializeDataProgress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating whether progress is being made resolving initialize data dependencies.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>HierarchyProtocol</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value specifying the hierarchy protocol.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>"PushUpAllExportsAndUnsatisfiedImports" for field mirroring and connecting, "ConnectProvidedFields" to only connect provided fields (no mirroring), <EM>All other values currently disable the hierarchy protocol.</EM></TD>
</TR>
</TABLE>

<H3><A NAME="SECTION00033300000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Mediator Component Metadata</A>
</H3>
<A NAME="MediatorCompMeta"></A>The Mediator Component metadata is implemented through ESMF_Info. It can be accessed
using the JSON Pointer "/NUOPC/Instance/" prefix followed by the "Attribute name"
as per the table below. E.g. "Verbosity" is accessed using <TT>key="/NUOPC/Instance/Verbosity"</TT>.

<P>
<B>Note</B> that some of the Attribute names in the following table are longer than the table column width. In these cases the
Attribute name had to be broken into multiple lines. When that happens, a hyphen shows up to indicate the line break. The hyphen
is <EM>not</EM> part of the Attribute name!

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><B>Attribute name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><B>Controlled vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Kind</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating component kind.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>Mediator</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Verbosity</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control verbosity of the generic component implementation. Higher bits are available for user level verbosity control. <BR>
                       <B>bit 0</B>: Intro/Extro of methods with indentation.
<BR>
                       <B>bit 1</B>: Intro/Extro with memory info.
<BR>
                       <B>bit 2</B>: Intro/Extro with garbage collection info.
<BR>
                       <B>bit 3</B>: Intro/Extro with local VM info.
<BR>
                       <B>bit 4</B>: Intro/Extro with ImportState info.
<BR>
                       <B>bit 5</B>: Intro/Extro with ExportState info.
<BR>
                       <B>bit 8</B>: Log Initialize phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 9</B>: Log Run phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 10</B>: Log Finalize phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 11</B>: Log info about data dependency during initialize resolution.
<BR>
                       <B>bit 12</B>: Log run sequence execution.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "low": some verbosity, bits: 0, 8, 9, 10, 13
<BR>
                       "high": more verbosity, bits: 0, 4, 5, 8, 9, 10, 11, 12, 13, 14
<BR>
                       "max": all lower 16 bits</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Profiling</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control profiling of the generic component implementation. Higher bits are available for user level profiling control. <BR>
                       <B>bit 0</B>: Top level profiling of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 1</B>: Specialization point profiling of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 2</B>: Additional profiling of internals of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 3</B>: Top level profiling of <EM>Run</EM> phases.
<BR>
                       <B>bit 4</B>: Specialization point profiling of <EM>Run</EM> phases.
<BR>
                       <B>bit 5</B>: Additional profiling of internals of <EM>Run</EM> phases.
<BR>
                       <B>bit 6</B>: Top level profiling of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 7</B>: Specialization point profiling of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 8</B>: Additional profiling of internals of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 9</B>: Leading barrier for <EM>Initialize</EM> phases.
<BR>
                       <B>bit 10</B>: Leading barrier for <EM>Run</EM> phases.
<BR>
                       <B>bit 11</B>: Leading barrier for <EM>Finalize</EM> phases.
<BR></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "low": Top level profiling. <BR>
                       "high": Top level, specialization point profiling, and additional profiling of internals. <BR>
                       "max": All lower 16 bits set.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Diagnostic</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control diagnostic of the generic component implementation. Higher bits are available for user level diagnostic control. <BR>
                       <B>bit 0</B>: Dump fields of the importState on entering <EM>Initialize</EM> phases.
<BR>
                       <B>bit 1</B>: Dump fields of the exportState on entering <EM>Initialize</EM> phases.
<BR>
                       <B>bit 2</B>: Dump fields of the importState on exiting <EM>Initialize</EM> phases.
<BR>
                       <B>bit 3</B>: Dump fields of the exportState on exiting <EM>Initialize</EM> phases.
<BR>
                       <B>bit 4</B>: Dump fields of the importState on entering <EM>Run</EM> phases.
<BR>
                       <B>bit 5</B>: Dump fields of the exportState on entering <EM>Run</EM> phases.
<BR>
                       <B>bit 6</B>: Dump fields of the importState on exiting <EM>Run</EM> phases.
<BR>
                       <B>bit 7</B>: Dump fields of the exportState on exiting <EM>Run</EM> phases.
<BR>
                       <B>bit 8</B>: Dump fields of the importState on entering <EM>Finalize</EM> phases.
<BR>
                       <B>bit 9</B>: Dump fields of the exportState on entering <EM>Finalize</EM> phases.
<BR>
                       <B>bit 10</B>: Dump fields of the importState on exiting <EM>Finalize</EM> phases.
<BR>
                       <B>bit 11</B>: Dump fields of the exportState on exiting <EM>Finalize</EM> phases.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "max": All lower 16 bits set.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>CompLabel</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value holding the label under which the component was added to its parent driver.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC initialize phases, of a specific Initialize Phase Definition (IPD) version, to the actual ESMF initialize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>IPDvXXpY=Z, where XX = two-digit revision number, e.g. 01, Y = logical NUOPC phase number, Z = actual ESMF phase number, with Y, Z &gt; 0 and Y, Z &lt; 10</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>RunPhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC run phases to the actual ESMF run phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>label-string</EM>=Z, where <EM>label-string</EM> can be chosen freely, and Z = actual ESMF phase number.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>FinalizePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC finalize phases to the actual ESMF finalize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><EM>label-string</EM>=Z, where <EM>label-string</EM> can be chosen freely, and Z = actual ESMF phase number.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InternalInitializePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>List of string values, mapping the logical NUOPC initialize phases, of a specific Initialize Phase Definition (IPD) version, to the actual ESMF initialize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>IPDvXXpY=Z, where XX = two-digit revision number, e.g. 01, Y = logical NUOPC phase number, Z = actual ESMF phase number, with Y, Z &gt; 0 and Y, Z &lt; 10</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>NestingGeneration</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Integer value enumerating nesting level.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ...</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Nestling</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Integer value enumerating siblings within the same generation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>0, 1, 2, ...</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializeDataComplete</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating whether all initialize data dependencies have been satisfied.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializeDataProgress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value indicating whether progress is being made resolving initialize data dependencies.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>HierarchyProtocol</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>String value specifying the hierarchy protocol.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150>"PushUpAllExportsAndUnsatisfiedImports" for field mirroring and connecting, "ConnectProvidedFields" to only connect provided fields (no mirroring), <EM>All other values currently disable the hierarchy protocol.</EM></TD>
</TR>
</TABLE>

<H3><A NAME="SECTION00033400000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Connector Component Metadata</A>
</H3>
<A NAME="ConnectorCompMeta"></A>The Connector Component metadata is implemented through ESMF_Info. It can be accessed
using the JSON Pointer "/NUOPC/Instance/" prefix followed by the "Attribute name"
as per the table below. E.g. "Verbosity" is accessed using <TT>key="/NUOPC/Instance/Verbosity"</TT>.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><B>Attribute name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><B>Controlled vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Kind</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating component kind.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>Connector</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Verbosity</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control verbosity of the generic component implementation. Higher bits are available for user level verbosity control. <BR>
                       <B>bit 0</B>: Intro/Extro of methods with indentation.
<BR>
                       <B>bit 1</B>: Intro/Extro with memory info.
<BR>
                       <B>bit 2</B>: Intro/Extro with garbage collection info.
<BR>
                       <B>bit 3</B>: Intro/Extro with local VM info.
<BR>
                       <B>bit 4</B>: Intro/Extro with ImportState info.
<BR>
                       <B>bit 5</B>: Intro/Extro with ExportState info.
<BR>
                       <B>bit 8</B>: Log FieldTransferPolicy.
<BR>
                       <B>bit 9</B>: Log bond level info.
<BR>
                       <B>bit 10</B>: Log CplList construction.
<BR>
                       <B>bit 11</B>: Log GeomObject Transfer.
<BR>
                       <B>bit 12</B>: Log looping over all elements in CplList for RouteHandle computation, FieldSharing, and Timestamp propagation.
<BR>
                       <B>bit 13</B>: Log Run phase with <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$&gt;&gt;&gt;$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$&lt;&lt;&lt;$"></SPAN>, and currTime.
<BR>
                       <B>bit 14</B>: Log info about RouteHandle execution.
<BR>
                       <B>bit 15</B>: Log info about RouteHandle release.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "low": some verbosity, bits: 0, 13
<BR>
                       "high": more verbosity, bits: 0, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15
<BR>
                       "max": all lower 16 bits</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Profiling</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control profiling of the generic component implementation. Higher bits are available for user level profiling control. <BR>
                       <B>bit 0</B>: Top level profiling of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 1</B>: Specialization point profiling of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 2</B>: Additional profiling of internals of <EM>Initialize</EM> phases.
<BR>
                       <B>bit 3</B>: Top level profiling of <EM>Run</EM> phases.
<BR>
                       <B>bit 4</B>: Specialization point profiling of <EM>Run</EM> phases.
<BR>
                       <B>bit 5</B>: Additional profiling of internals of <EM>Run</EM> phases.
<BR>
                       <B>bit 6</B>: Top level profiling of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 7</B>: Specialization point profiling of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 8</B>: Additional profiling of internals of <EM>Finalize</EM> phases.
<BR>
                       <B>bit 9</B>: Leading barrier for <EM>Initialize</EM> phases.
<BR>
                       <B>bit 10</B>: Leading barrier for <EM>Run</EM> phases.
<BR>
                       <B>bit 11</B>: Leading barrier for <EM>Finalize</EM> phases.
<BR></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "low": Top level profiling. <BR>
                       "high": Top level, specialization point profiling, and additional profiling of internals. <BR>
                       "max": All lower 16 bits set.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Diagnostic</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value, converted into an integer, and interpreted as a bit field. The lower 16 bits (0-15) are reserved to control diagnostic of the generic component implementation. Higher bits are available for user level diagnostic control. <BR>
                       <B>bit 0</B>: Dump fields of the importState on entering <EM>Initialize</EM> phases.
<BR>
                       <B>bit 1</B>: Dump fields of the exportState on entering <EM>Initialize</EM> phases.
<BR>
                       <B>bit 2</B>: Dump fields of the importState on exiting <EM>Initialize</EM> phases.
<BR>
                       <B>bit 3</B>: Dump fields of the exportState on exiting <EM>Initialize</EM> phases.
<BR>
                       <B>bit 4</B>: Dump fields of the importState on entering <EM>Run</EM> phases.
<BR>
                       <B>bit 5</B>: Dump fields of the exportState on entering <EM>Run</EM> phases.
<BR>
                       <B>bit 6</B>: Dump fields of the importState on exiting <EM>Run</EM> phases.
<BR>
                       <B>bit 7</B>: Dump fields of the exportState on exiting <EM>Run</EM> phases.
<BR>
                       <B>bit 8</B>: Dump fields of the importState on entering <EM>Finalize</EM> phases.
<BR>
                       <B>bit 9</B>: Dump fields of the exportState on entering <EM>Finalize</EM> phases.
<BR>
                       <B>bit 10</B>: Dump fields of the importState on exiting <EM>Finalize</EM> phases.
<BR>
                       <B>bit 11</B>: Dump fields of the exportState on exiting <EM>Finalize</EM> phases.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>0, 1, 2, ... <BR>
                       "off" = 0 (default), <BR>
                       "max": All lower 16 bits set.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>CompLabel</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value holding the label under which the component was added to its parent driver.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>InitializePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>List of string values, mapping the logical NUOPC initialize phases, of a specific Initialize Phase Definition (IPD) version, to the actual ESMF initialize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>IPDvXXpY=Z, where XX = two-digit revision number, e.g. 01, Y = logical NUOPC phase number, Z = actual ESMF phase number, with Y, Z &gt; 0 and Y, Z &lt; 10</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>RunPhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>List of string values, mapping the logical NUOPC run phases to the actual ESMF run phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>label-string</EM>=Z, where <EM>label-string</EM> can be chosen freely, and Z = actual ESMF phase number.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>FinalizePhaseMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>List of string values, mapping the logical NUOPC finalize phases to the actual ESMF finalize phase number under which the entry point is registered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>label-string</EM>=Z, where <EM>label-string</EM> can be chosen freely, and Z = actual ESMF phase number.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>CplList</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>List of StandardNames of the connected Fields. Each StandardName entry may be followed by a colon separated list of connection options. The details are discussed in section <A HREF="#connection_options">2.4.5</A></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>Standard names</EM> as per field dictionary, followed by <EM>connection options</EM> defined in section <A HREF="#connection_options">2.4.5</A>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>CplSetList</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>List of coupling sets. Each coupling set is identified by a string value.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ConnectionOptions</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value specifying the connection options to be applied to all the fields in the <TT>CplList</TT> by default.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>Connection options</EM> defined in section <A HREF="#connection_options">2.4.5</A>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>EpochThrottle</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer specifying the maximum number of outstanding EPOCH messages between any two PETs. The ESMF level default is 10.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>Any positive integer.</TD>
</TR>
</TABLE>

<H3><A NAME="SECTION00033500000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> State Metadata</A>
</H3>
<A NAME="StateMeta"></A>The State metadata is implemented through ESMF_Info. It can be accessed
using the JSON Pointer "/NUOPC/Instance/" prefix followed by the "Attribute name"
as per the table below. E.g. "Namespace" is accessed using <TT>key="/NUOPC/Instance/Namespace"</TT>.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><B>Attribute name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><B>Controlled vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Namespace</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value holding the namespace of all the objects contained in the State.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>FieldTransferPolicy</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating to Connector to transfer/mirror Fields.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>transferNone,
<BR>
transferAll</TD>
</TR>
</TABLE>

<H3><A NAME="SECTION00033600000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Field Metadata</A>
</H3>
<A NAME="FieldMeta"></A>The Field metadata is implemented through ESMF_Info. It can be accessed
using the JSON Pointer "/NUOPC/Instance/" prefix followed by the "Attribute name"
as per the table below. E.g. "StandardName" is accessed using <TT>key="/NUOPC/Instance/StandardName"</TT>.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><B>Attribute name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><B>Controlled vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>StandardName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Units</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>LongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Connected</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Connected status.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ProducerConnection</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating whether the Field has been connected with a producer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>open, targeted,
<BR>
connected</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ConsumerConnection</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating whether the Field has been connected with a consumer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>open, targeted,
<BR>
connected</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>Updated</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating updated status during initialization.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>false, true</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ProducerTransferOffer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating a producer component's ability to transfer information about the advertised Field, including its GeomObject.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>will provide,
<BR>
can provide,
<BR>
cannot provide</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ProducerTransferAction</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating the action a producer component is supposed to take with respect to transferring Field information, including its GeomObject.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>provide, accept</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ConsumerTransferOffer</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating a consumer component's ability to transfer information about the advertised Field, including its GeomObject.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>will provide,
<BR>
can provide,
<BR>
cannot provide</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ConsumerTransferAction</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating the action a consumer component is supposed to take with respect to transferring Field information, including its GeomObject.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>provide, accept</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>SharePolicyField</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating a component's policy with respect to sharing the Field data allocation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>share,
<BR>
not share</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ShareStatusField</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating the status with respect to sharing the underlying Field data allocation that was negotiated.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>shared,
<BR>
not shared</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>SharePolicyGeomObject</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating a component's policy with respect to sharing the Grid or Mesh on which the advertised Field object is defined.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>share,
<BR>
not share</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ShareStatusGeomObject</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>String value indicating the status with respect to sharing the underlying GeomObject that was negotiated.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>shared,
<BR>
not shared</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>UngriddedLBound</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer value list. If present equals the <TT>ungriddedLBound</TT> of the provider field during a GeomObject transfer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>UngriddedUBound</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer value list. If present equals the <TT>ungriddedUBound</TT> of the provider field.during a GeomObject transfer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>GridToFieldMap</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer value list. If present equals the <TT>gridToFieldMap</TT> of the provider field.during a GeomObject transfer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>ArbDimCount</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer value. If present equals the <TT>arbDimCount</TT> of the provider field.during a GeomObject transfer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>MinIndex</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer value list. If present equals the <TT>minIndex</TT> (of tile 1) of the provider field.during a GeomObject transfer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>MaxIndex</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer value list. If present equals the <TT>maxIndex</TT> (of tile 1) of the provider field.during a GeomObject transfer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>no restriction</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>TypeKind</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer value. If present equals the integer representation of <TT>typekind</TT> of the provider field.during a GeomObject transfer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>implementation dependent range</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=110><TT>GeomLoc</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=300>Integer value. If present equals the integer representation of <TT>staggerloc</TT> (for Grid) or <TT>meshloc</TT> (for Mesh) of the provider field.during a GeomObject transfer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><EM>implementation dependent range</EM></TD>
</TR>
</TABLE>

<H2><A NAME="SECTION00034000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Initialization</A>
</H2>

<H3><A NAME="SECTION00034100000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Phase Maps, Semantic Specialization Labels, and Component Labels</A>
</H3>

<P>
<A NAME="PhaseMaps"></A>
<P>
The NUOPC layer adds an abstraction on top of the ESMF phase index. ESMF introduces the concept of standard component methods: <TT>Initialize</TT>, <TT>Run</TT>, and <TT>Finalize</TT>. ESMF further recognizes the need for being able to split each of the standard methods into multiple phases. On the ESMF level, phases are implemented by a simple integer <TT>phase</TT> index. With NUOPC, logical phase labels are introduced that are mapped to the ESMF phase indices.

<P>
The NUOPC Layer introducing three component level attributes: <TT>InitializePhaseMap</TT>, <TT>RunPhaseMap</TT>, and <TT>FinalizePhaseMap</TT>. These attributes map logical NUOPC phase labels to integer ESMF phase indices. A NUOPC compliant component fully documents its available phases through the phase maps.

<P>
The generic <TT>NUOPC_Driver</TT> uses the <TT>InitializePhaseMap</TT> on each of its child component during the initialization stage to correctly interact with each component. The <TT>RunPhaseMap</TT> is used when setting up run sequences in the Driver. The <TT>NUOPC_DriverAddRunElement()</TT> takes the <TT>phaseLabel</TT> argument, and uses the <TT>RunPhaseMap</TT> attribute internally to translates the label into the corresponding ESMF phase index. The <TT>FinalizePhaseMap</TT> is currently not used by the NUOPC Layer

<P>
Appendix B, section <A HREF="node8.html#IPD">7</A>, lists the supported logical phase labels for reference. User code very rare needs to interact with the <TT>InitializePhaseMap</TT> or its entries directly. Instead, user code specializes the initialization behavior of a component through the semantic specialization labels discussed below.

<P>
NUOPC implements a very powerful initialization procedure. This procedure is, among other functions, capable of handling component hierarchies, transfer of geometries, reference sharing, and resolving data dependencies during initialization. The initialization features are discussed in detail in their respective sections of this document.

<P>
From the user level, specialization of the initialization is accessbile through the <EM>semantic specialization labels</EM>. These labels are predefined named constants that are passed into the <TT>NUOPC_CompSpecialize()</TT> method, together with the user provided routine, implementing the required actions. On a technical level, the user routine must follow the standard interface defined by NUOPC. Semantically, the purpose of each specialization point is indicated by the name of the predefined specialization label. For a definition of the labels,  and the ascribed purpose, see the <I CLASS="sans">SEMANTIC SPECIALIZATION LABELS</I> section under each of the generic component kinds. (Driver: <A HREF="node4.html#NUOPC_Driver">3.1</A>, Model: <A HREF="node4.html#NUOPC_Model">3.3</A>, Mediator: <A HREF="node4.html#NUOPC_Mediator">3.4</A>, Connector: <A HREF="node4.html#NUOPC_Connector">3.5</A>)

<P>
Finally, under NUOPC, each component is associated with a label when it is added to a driver through the <TT>NUOPC_DriverAddComp()</TT> call. Multiple instances of the same component can be added to a driver, provided each instance is given a unique label. Connectors between components are identified by providing the label of the source component and destination component.

<H3><A NAME="SECTION00034200000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> Field Pairing</A>
</H3>

<P>
<A NAME="FieldPairing"></A>
<P>
The NUOPC Model and Mediator components are required to advertise their import and export Fields with a standard set of Field metadata. This set includes the <TT>StandardName</TT> attribute. The NUOPC Layer implements a strategy of pairing advertised Fields that is based primarily on the <TT>StandardName</TT> of the Fields, and in more complex situations further utilizes the <TT>Namespace</TT> attribute on States.

<P>
Field pairing is accomplished as part of the initialization procedure and is a collective effort of the Driver and its child components: Models, Mediator, Connectors. The Connectors are the most active players when it comes to Field pairing. The end result of the process is where each Connector has a list of Fields that it connects between its importState and its exportState. Each connector keeps this list in its component level metadata as <TT>CplList</TT> attribute.

<P>
During the first stage of Field pairing, each Connector matches all of the Fields in its importState to all of the Fields in its exportState by looking at their <TT>StandardName</TT> attribute. For every match a <EM>bondLevel</EM> is calculated and stored in the Field on the export side, i.e. on the consumer side of the connection, in the Field's <TT>ConsumerConnection</TT> attribute. The larges found bondLevel is kept for each Field on the export side.

<P>
The bondLevel is a measure of how strong the pairing is considering the namespace rules explained in section <A HREF="#Namespaces">2.4.3</A>. Without the use of namespaces the bondLevel for all Field pairs that match by their <TT>StandardName</TT> is equal to 1.

<P>
After the first stage, there may be umbiguous Field pairs present. Ambiguous Field pairs are those that map different producer Fields (i.e. Fields in the importState of a Connector) to the <EM>same</EM> consumer Field (i.e. a Field in the exportState of a Connector). While the NUOPC Layer support having multiple consumer Fields connected to a single producer Field, it does not support the opposite condition. The second stage of Field pairing is responsible for disambiguating Field pairs with the same consumer Field.

<P>
Field pair disambiguation is based on the <EM>bondLevel</EM> that was calculated and stored on the consumer side Field for each pair during the first stage. The disambiguation rule simply selects the connection with the highest bondLevel and discards all lesser connection to the same consumer side Field. However, if the highest bondLevel is not unique, i.e. there are multiple pairs with the same bondLevel, disambiguation is not possible and an error is returned to the Driver by the Connector that finds the ambiguity first.

<P>
Assuming that the disambiguation step was successful, each Connector holds a valid <TT>CplList</TT> attribute with entries that correspond to the Field pairs that it is responsible for. At this stage the Driver can still overwrite this attribute and implement custom pairs if that is desired.

<H3><A NAME="SECTION00034300000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> Namespaces</A>
</H3>

<P>
<A NAME="Namespaces"></A>
<P>
Namespaces are used to control and fine-tune the disambiguation of Field pairs during the initialization. The general procedure of Field pairing and disambiguation is outlined in section <A HREF="#FieldPairing">2.4.2</A>, here the use of namespaces is described.

<P>
The NUOPC Layer implements namespaces through the <TT>Namespace</TT> attribute on <TT>ESMF_State</TT> objects. The value of this attribute is a simple character string. The NUOPC Layer automatically creates the import and export States of every Model and Mediator component that is added to a Driver. The <TT>Namespace</TT> attribute of these States is automatically set to the <TT>compLabel</TT> string that was provided during <TT>NUOPC_DriverAdd()</TT>. Doing this places every Field that is advertised through these States inside the component's unique namespace.

<P>
A secondary namespace can be added to a State using the <TT>NUOPC_StateNamespaceAdd()</TT> method. This creates a new State that is nested inside of an existing State, and sets the <TT>Namespace</TT> attribute of the new State. Fields that are advertised inside of such a nested State are in a namespace with two parts: <TT>NS1:NS2</TT>. Here <TT>NS1</TT> is the preset namespace of the import or export State (equal to the compLabel), and <TT>NS2</TT> is a freely chosen namespace string.

<P>
During Field pairing the namespace on each side of the connection is considered in the two part format <TT>NS1:NS2</TT>. The first part is equal to the compLabel of the corresponding component, and NS2 is either the namespace of a nested State, or empty if the Field is not inside a nested State. Using this format, the calculation of the <EM>bondLevel</EM> during Field pairing is governed by the following rules:

<P>

<UL>
<LI>Namespace matching is done in a cross wise fashion, meaning NS1 from one side is compared to NS2 of the other side, and vice versa.
</LI>
<LI>The bondLevel is incremented by one counter for each cross-wise match between namespaces. (Considering that the bondLevel starts out as 1 for any Field pair with matching standard names, the maximum bondLevel that can be reached is 3.)
</LI>
<LI>Finding one side of the cross-wise comparison being an empty string is neither counted as a match nor a mis-match. The bondLevel remains unchanged.
</LI>
<LI>A Field pair for which a mis-match in either of the two cross-wise namespace comparisons is detected is discarded from the possible pairs. It is not further considered.
</LI>
</UL>

<P>
In practice then, a component that targets a specific other component with its advertised Fields would add a secondary namespace to its import or export State, and set that namespace to the compLabel of the targeted component. This increases the bondLevel for each pair from 1 to 2. An even higher bondLevel of 3 is achieved when both sides target each other by specifying the other component's compLabel through a secondary namespace.

<P>
In conclusion, namespaces can affect the bondLevel calculation for each pair, but they do not affect how pairs are constructed and disambiguated. In particular, the requirement for unambiguous Field pairs for each consumer Field remains unchanged, and it is an error condition if the highest bondLevel for a consumer Field does not correspond to a unique Field pair.

<H3><A NAME="SECTION00034400000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> Using Coupling Sets for Coupling Multiple Nests</A>
</H3>

<P>
<A NAME="CplSets"></A>
<P>
The NUOPC Layer can couple multiple data sets by adding nested states to the import and export states of a <TT>NUOPC_Model</TT>. Each nested state is given a couple set identifier at the time it is added to the parent state. This identifier guarantees a <TT>NUOPC_Connector</TT> will only pair fields within this nested state to fields in a connected state with an identical identifier.

<P>
During <TT>label_Advertise</TT>, before calling <TT>NUOPC_Advertise</TT> (using methods <A HREF="node4.html#NUOPC_AdvertiseField">3.9.3</A> or <A HREF="node4.html#NUOPC_AdvertiseFields">3.9.4</A>), add nested states to import and export states using <TT>NUOPC_AddNestedState</TT>. Each nested state is given a couple set identifier using the CplSet argument, see <A HREF="node4.html#NUOPC_AddNestedState">3.9.2</A>. The nested states can then be used to advertise and realize fields. Each nested state may contain fields with identical standard names or unique standard names. Fields in each nested state will only connect to fields in another state if that state has an identical couple set identifier.

<P>
For a complete example of how to couple sets using the NUOPC API, see https://github.com/esmf-org/nuopc-app-prototypes/tree/develop/AtmOcnCplSetProto. The following code snippets demonstrates the critical pieces of code used to add a nested state with a couple set identifier.

<P>
<PRE>
  subroutine Advertise(model, rc)
    type(ESMF_GridComp)  :: model
    integer, intent(out) :: rc

    ! local variables
    type(ESMF_State) :: importState, exportState
    type(ESMF_State) :: NStateImp1, NStateImp2
    type(ESMF_State) :: NStateExp1, NStateExp2

    rc = ESMF_SUCCESS

    ! query model for importState and exportState
    call NUOPC_ModelGet(model, importState=importState, &amp;
      exportState=exportState, rc=rc)
    ! check rc

    ! add nested import states with couple set identifier
    call NUOPC_AddNestedState(importState, &amp;
      CplSet="Nest1", nestedStateName="NestedStateImp_N1", &amp;
      nestedState=NStateImp1, rc=rc)
    ! check rc
    call NUOPC_AddNestedState(importState, &amp;
      CplSet="Nest2", nestedStateName="NestedStateImp_N2", &amp;
      nestedState=NStateImp2, rc=rc)
    ! check rc

    ! add nested export states with couple set identifier
    call NUOPC_AddNestedState(exportState, &amp;
      CplSet="Nest1", nestedStateName="NestedStateExp_N1", &amp;
      nestedState=NStateExp1, rc=rc)
    ! check rc
    call NUOPC_AddNestedState(exportState, &amp;
      CplSet="Nest2", nestedStateName="NestedStateExp_N2", &amp;
      nestedState=NStateExp2, rc=rc)
    ! check rc

    ! importable field: sea_surface_temperature
    call NUOPC_Advertise(NStateImp1, &amp;
      StandardName="sea_surface_temperature", name="sst", rc=rc)
    ! check rc
    call NUOPC_Advertise(NStateImp2, &amp;
      StandardName="sea_surface_temperature", name="sst", rc=rc)
    ! check rc

    ! exportable field: air_pressure_at_sea_level
    call NUOPC_Advertise(NStateExp1, &amp;
      StandardName="air_pressure_at_sea_level", name="pmsl", rc=rc)
    ! check rc
    call NUOPC_Advertise(NStateExp2, &amp;
      StandardName="air_pressure_at_sea_level", name="pmsl", rc=rc)
    ! check rc

    ! exportable field: surface_net_downward_shortwave_flux
    call NUOPC_Advertise(NStateExp1, &amp;
      StandardName="surface_net_downward_shortwave_flux", name="rsns", rc=rc)
    ! check rc
    call NUOPC_Advertise(NStateExp2, &amp;
      StandardName="surface_net_downward_shortwave_flux", name="rsns", rc=rc)
    ! check rc

  end subroutine
</PRE>

<H3><A NAME="SECTION00034500000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> Connection Options</A>
</H3>

<P>
<A NAME="connection_options"></A>
<P>
Once the field pairing discussed in the previous sections is completed, each Connector component holds an attribute by the name of <TT>CplList</TT>. The <TT>CplList</TT> is a list type attribute with as many entries as there are fields for which the Connector component is responsible for connecting. The first part of each of these entries is always the <TT>StandardName</TT> of the associated field. See section <A HREF="#field_dictionary">2.2</A> for a discussion of the NUOPC field dictionary and standard names.

<P>
After the <TT>StandardName</TT> part, each <TT>CplList</TT> entry may optionally contain a string of <EM>connection options</EM>. Each Driver component has the chance as part of the <TT>label_ModifyInitializePhaseMap</TT> specialization, to modify the <TT>CplList</TT> attribute of all the Connectors that it drives.

<P>
The individual connection options are colon separated, leading to the following format for each <TT>CplList</TT> entry:

<P>
<PRE>
StandardName[:option1[:option2[: ...]]
</PRE>

<P>
The format of the options is:

<P>
<PRE>
OptionName=value1[=spec1][,value2[=spec2][, ...]]
</PRE>

<P>
OptionName and the value strings are case insensitive. There are single and multi-valued options as indicated in the table below. For single valued options only <TT>value1</TT> is relevant. If the same option is listed multiple times, only the first occurrence will be used. If an option has a default value, it is indicated in the table. If a value requires additional specification via <TT>=spec</TT> then the specifications are listed in the table.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>OptionName</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28><B>Type</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><B>Values</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>dstMaskValues</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>List of integer values that defines the mask values.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>multi</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>List of integers.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>dumpWeights</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Enable or disable dumping of the interpolation weights into a file.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>true</TT>, <TT>false</TT>(default)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>extrapDistExponent</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The exponent to raise the distance to when calculating weights for the nearest_idavg extrapolation method.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>real(default 2.0)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>extrapMethod</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Fill in points not mapped by the regrid method.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>none</TT>(default), <TT>nearest_idavg</TT>, <TT>nearest_stod</TT>, <TT>creep</TT>, <TT>creep_nrst_d</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>extrapNumLevels</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of levels to output for the extrapolation methods that fill levels. When a method is used that requires this, then an error will be returned, if it is not specified.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>integer</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>extrapNumSrcPnts</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of source points to use for the extrapolation methods that use more than one source point.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>integer(default 8)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ignoreDegenerate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Ignore degenerate cells when checking the input Grids or Meshes for errors.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>true</TT>, <TT>false</TT>(default)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ignoreUnmatchedIndices</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Ignore unmatched sequence indices when redistributing between source and destination index space.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>true</TT>, <TT>false</TT>(default)</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>pipelineDepth</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Maximum number of outstanding non-blocking communication calls during the parallel interpolation. Only relevant for cases where the automatic tuning procedure fails to find a setting that works well on a given hardware.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>integer</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>poleMethod</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Extrapolation method around the pole(s).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>none</TT>(default), <TT>allavg</TT>, <TT>npntavg</TT>=<EM>"integer indicating number of points"</EM>, <TT>teeth</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>remapMethod</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Redistribution or interpolation to compute the regridding weights.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>redist</TT>, <TT>bilinear</TT>(default), <TT>patch</TT>, <TT>nearest_stod</TT>, <TT>nearest_dtos</TT>, <TT>conserve</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>srcMaskValues</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>List of integer values that defines the mask values.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>multi</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>List of integers.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>srcTermProcessing</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Number of terms in each partial sum of the interpolation to process on the source side. This setting impacts the bit-for-bit reproducibility of the parallel interpolation results between runs. The strictest bit-for-bit setting is achieved by setting the value to 1.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99>integer</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>termOrder</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Order of the terms in each partial sum of the interpolation. This setting impacts the bit-for-bit reproducibility of the parallel interpolation results between runs. The strictest bit-for-bit setting is achieved by setting the value to <TT>srcseq</TT>.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>free</TT>(default), <TT>srcseq</TT>, <TT>srcpet</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>unmappedAction</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The action to take when unmapped destination elements are encountered.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>ignore</TT>(default), <TT>error</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>zeroRegion</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The region of destination elements set to zero before adding the result of the sparse matrix multiplication. The available options support total, selective, or no zeroing of destination elements.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=28>single</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=99><TT>total</TT>(default), <TT>select</TT>, <TT>empty</TT></TD>
</TR>
</TABLE>

<H3><A NAME="SECTION00034600000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> Data-Dependencies during Initialize</A>
</H3>

<P>
<A NAME="DataDepInit"></A>
<P>
For multi-model applications it is not uncommon that during start-up one or more components depends on data from one or more other components. These types of data-dependencies during initialize can become very complex very quickly. Finding the "correct" sequence to initialize all components for a complex dependency graph is not trivial. The NUOPC Layer deals with this issue by repeatedly looping over all components that indicate that their initialization has data dependencies on other components. The loop is finally exited when either all components have indicated completion of their initialization, or a dead-lock situation is being detected by the NUOPC Layer.

<P>
The data-dependency resolution loop considers all components that have specialized <TT>label_DataInitialize</TT>. Participating components communicate their current status to the NUOPC Layer via Field and Component metadata. Every time a component's <TT>label_DataInitialize</TT> specialization routine is called, it is responsible for checking the Fields in the importState and for initializing any internal data structures and Fields in the exportState. Fields that are fully initialized in the exportState must be indicated by setting their <TT>Updated</TT> Attribute to "true". This is used by the NUOPC Layer to ensure that there is continued progress during the resolution loop iterations. Once the component is fully initialized it must further set its <TT>InitializeDataComplete</TT> Attribute to "true" before returning.

<P>
During the execution of the data-dependency resolution loop the NUOPC Layer calls all of the Connectors <EM>to</EM> a Model/Mediator component before calling the component's <TT>label_DataInitialize</TT>. Doing so ensures that all the currently available Fields are passed to the component before it tries to access them. Once a component has set its <TT>InitializeDataComplete</TT> Attribute to "true", it, and the Connectors to it, will no longer be called during the remainder of the resolution loop. 

<P>
When <EM>all</EM> of the components that participate in the data-dependency resolution loop have set their <TT>InitializeDataComplete</TT> Attribute to "true", the NUOPC Layer successfully exits the data-dependency resolution loop. The loop is also interrupted before all <TT>InitializeDataComplete</TT> Attributes are set to "true" if a full cycle completes without any indicated progress. The NUOPC Layer flags this situation as a potential dead-lock and returns with error.

<H3><A NAME="SECTION00034700000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> Transfer of Grid/Mesh/LocStream Objects between Components</A>
</H3>

<P>
<A NAME="TransferGeom"></A>
<P>
There are modeling scenarios where the need arises to transfer physical grid information from one component to another. One common situation is that of modeling systems that utilize Mediator components to implement the interactions between Model components. In these cases the Mediator often carries out computations on a Model's native grid and performs regridding to the grid of other Model components. It is both cumbersome and error prone to recreate the Model grid in the Mediator. To solve this problem, NUOPC implements a transfer protocol for <TT>ESMF_Grid</TT>, <TT>ESMF_Mesh</TT>, and <TT>ESMF_LocStream</TT> objects (generally referred to as GeomObjects) between Model and/or Mediator components during initialization.

<P>
The NUOPC Layer transfer protocol for GeomObjects is based on two Field attributes: <TT>TransferOfferGeomObject</TT> and <TT>TransferActionGeomObject</TT>. The <TT>TransferOfferGeomObject</TT> attribute is used by the Model and/or Mediator components to indicate for each Field their intent for the associated GeomObject. The predefined values of this attribute are: "will provide", "can provide", and "cannot provide". The <TT>TransferOfferGeomObject</TT> attribute must be set during <TT>label_Advertise</TT>.

<P>
The generic Connector uses the intents from both sides and constructs a response according to the table below. The Connector's response is available during <TT>label_RealizeProvided</TT>. It sets the value of the <TT>TransferActionGeomObject</TT> attribute to either "provide" or "accept" on each Field. Fields indicating <TT>TransferActionGeomObject</TT> equal to "provide" must be realized on a Grid, Mesh, or LocStream object in the Model/Mediator before returning from <TT>label_RealizeProvided</TT>.

<P>
Fields that hold "accept" for the value of the <TT>TransferActionGeomObject</TT> attribute require two additional negotiation steps. During <TT>label_AcceptTransfer</TT> the Model/Mediator component can access the transferred Grid/Mesh/LocStream on the Fields that have the "accept" value. However, only the DistGrid, i.e. the decomposition and distribution information of the Grid/Mesh/LocStream is available at this stage, not the full physical grid information such as the coordinates. At this stage the Model/Mediator may modify this information by replacing the DistGrid object in the Grid/Mesh/LocStream. The DistGrid that is set on the Grid/Mesh/LocStream objects when leaving the Model/Mediator phase <TT>label_AcceptTransfer</TT> will consequently be used by the generic Connector to fully transfer the Grid/Mesh/LocStream object. The fully transferred objects are available on the Fields with "accept" during Model/Mediator phase <TT>label_RealizeAccepted</TT>, where they are used to realize the respective Field objects. At this point all Field objects are fully realized and the initialization process can proceed as usual.

<P>
The following table shows how the generic Connector sets the <TT>TransferActionGeomObject</TT> attribute on the Fields according to the incoming value of <TT>TransferOfferGeomObject</TT>.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><B><TT>TransferOfferGeomObject</TT> Incoming side A</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128><B><TT>TransferOfferGeomObject</TT> Incoming side B</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><B>Outgoing setting by generic Connector</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"will provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"will provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>A:<TT>TransferActionGeomObject</TT>="provide" B:<TT>TransferActionGeomObject</TT>="provide"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"will provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"can provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>A:<TT>TransferActionGeomObject</TT>="provide" B:<TT>TransferActionGeomObject</TT>="accept"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"will provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"cannot provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>A:<TT>TransferActionGeomObject</TT>="provide" B:<TT>TransferActionGeomObject</TT>="accept"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"can provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"will provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>A:<TT>TransferActionGeomObject</TT>="accept"  B:<TT>TransferActionGeomObject</TT>="provide"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"can provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"can provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>if (A is import side) then
<BR>
A:<TT>TransferActionGeomObject</TT>="provide" B:<TT>TransferActionGeomObject</TT>="accept"
     if (B is import side) then
<BR>
A:<TT>TransferActionGeomObject</TT>="accept" B:<TT>TransferActionGeomObject</TT>="provide"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"can provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"cannot provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>A:<TT>TransferActionGeomObject</TT>="provide" B:<TT>TransferActionGeomObject</TT>="accept"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"cannot provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"will provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>A:<TT>TransferActionGeomObject</TT>="accept"  B:<TT>TransferActionGeomObject</TT>="provide"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"cannot provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"can provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>A:<TT>TransferActionGeomObject</TT>="accept"  B:<TT>TransferActionGeomObject</TT>="provide"</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"cannot provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=128>"cannot provide"</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198>Flagged as error!</TD>
</TR>
</TABLE>
<BR>

<H3><A NAME="SECTION00034800000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> Field and Grid/Mesh/LocStream Reference Sharing</A>
</H3>

<P>
<A NAME="Sharing"></A>
<P>
For coupling scenarios with a very high coupling frequency, or for situations where large data volumes are exchanged (e.g. 3D volumetric fields), it can be necessary for fields and geom objects (Grid, Mesh, and LocStreams) to share their data via references. Reference sharing greatly reduces the coupling cost compared to local or remote copies.

<P>
In the current implementation, in order for NUOPC components to be coupled via reference sharing, they must only have data defined (i.e. have DEs) on PETs that are part of both components. Further, the distribution of data across the PETs must be identical for both components. If these conditions are met, and both sides of the connection indicate that they are willing to participate in reference sharing, the NUOPC Connector will handle technical details. The Connector will provide fields to the components that reference the exact same data allocations in memory. Notice however that once reference sharing is active, the NUOPC Layer cannot protect against components violating the data access conventions. Specifically fields in the importState are not to be modified by the component. Reference sharing requires a higher level of "trust" between the components. NUOPC therefore requires that both sides of a connection agree to reference sharing.

<P>
A component uses the <TT>SharePolicyField</TT> and <TT>SharePolicyGeomObject</TT> attributes on each field to indicate whether it is willing to reference share the data of a field, and/or the geom object on which the field is built. A setting of <TT>share</TT> indicates a component's willingness to share, while <TT>not share</TT> indicates the opposite. The share policy attributes are automatically set when a field is advertised via the <TT>NUOPC_Advertise()</TT> method. By default this method sets both share policies to <TT>not share</TT>.

<P>
When a Connector negotiates the connections between two components, it first considers the transfer offer attributes (i.e. <TT>TransferOfferGeomObject</TT>) on both sides for each field to determine the <TT>TransferActionGeomObject</TT> attribute for both side. The details of this protocol are outline in section <A HREF="#TransferGeom">2.4.7</A>. There are two cases to consider for each field that are relevant for reference sharing:

<P>
The simple case is where the Connector determines that for a specific field both sides must provide the field and geom object. This is indicated by <TT>TransferActionGeomObject</TT> being set to <TT>provide</TT> on both sides. For this case the <TT>ShareStatusField</TT> and <TT>ShareStatusGeomObject</TT> attributes are automatically set to <TT>not shared</TT> for all the fields, preventing any reference sharing.

<P>
The more interesting case is where one side of the connection receives the <TT>TransferActionGeomObject</TT> on a field set to <TT>provide</TT>, while the other side receives <TT>accept</TT>. In this case, the next step is for the Connector to take the <TT>SharePolicyField</TT> and <TT>SharePolicyGeomObject</TT> attributes on both sides into consideration. For each of the two attributes separately, if one side indicates <TT>not share</TT>, both sides will receive the associated ShareStatus set to <TT>not shared</TT>. However, if both sides of the connection indicate a SharePolicy of <TT>share</TT>, the Connector must further inspect the petLists to see if reference sharing is possible for the specific field. Under the current implementation a field is sharable with another component if all the PETs on which the field holds DEs are also in the other component's petList. If this condition is not met for the specific field, then the associated ShareStatus is set to <TT>not shared</TT>. Otherwise the ShareStatus is set to <TT>shared</TT>

<P>
During later phases of the Initialization protocol the Connector performs different operations, depending on how the <TT>TransferActionGeomObject</TT>, <TT>ShareStatusField</TT>, and <TT>ShareStatusGeomObject</TT> attributes were set as per the above protocol:

<UL>
<LI>For a field that has <TT>ShareStatusGeomObject</TT> equal to <TT>share</TT>, the geom object provided by the provider component will be made available to the acceptor component.
</LI>
<LI>For a field that has <TT>ShareStatusField</TT> equal to <TT>share</TT>, the Connector realizes the field for the acceptor component using the data allocation reference provided by the field of the provider component.
</LI>
</UL>

<H3><A NAME="SECTION00034900000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> Field Mirroring</A>
</H3>

<P>
<A NAME="FieldMirror"></A>
<P>
In some cases it is helpful for a NUOPC component to automatically mirror or match the set of fields advertised by another component.  One purpose of this is to automatically resolve the import data dependencies of a component, by setting up a component that exactly provides all of the needed fields.  This is currently used in the NUOPC Component Explorer:  when driving a child NUOPC Model with required import fields, the Component Explorer uses the field mirroring capability to advertise in the driver-self export State the exact set of fields advertised in the child NUOPC Model.  This ensures that the entire Initialize Phase Sequence will complete (because all dependencies are satisfied) and all phases can be exercised by the Component Explorer.

<P>
The field mirror capability is also useful with NUOPC Mediators since these components often exactly reflect, in separate States, the sets of fields of each of the connected components.  The field mirroring capability, therefore, can be used to ensure that a Mediator is always capable of accepting fields from connected components, and removes the need to specify field lists in multiple places, i.e., both within a set of Model components connected to a Mediator and within the Mediator itself.

<P>
To access the field mirror capability, a component sets the <TT>FieldTransferPolicy</TT> attribute during <TT>label_Advertise</TT>. The attribute is set on the Import- and/or Export- States to trigger field mirroring for each state, respectively.  The default value of "TransferNone" indicates that no fields should be mirrored.  The other option, "TransferAll", indicates that fields should be mirrored in the State of a connected component.

<P>
Each Connector consider the <TT>FieldTransferPolicy</TT> Attribute on both its import and export States.  If <EM>both</EM> States have a <TT>FieldTransferPolicy</TT> of "TransferAll", then fields are transferred between the States in both directions (i.e., import to export and export to import).  The transfer process works as follows:  First, the <TT>TransferOfferGoemObject</TT> attribute is reversed between the providing side and accepting side.  Intuitively, if a field from the providing component is to be mirrored and it can provide its own geometric object, then the mirrored field on the accepting side should be set to accept a geometric object.  Then, the field to be mirrored is advertised in the accepting State using a call to <TT>NUOPC_Advertise()</TT> such that the mirrored field shares the same Standard Name.

<P>
Components have the opportunity, using specialiozation point <TT>label_ModifyAdvertised</TT>, to modify any of the mirrored Fields in their Import/ExportState. After this the initialization sequence continues as usual.  Since fields to be mirrored have been advertised with matching Standard Names, the field pairing algorithm will now match them in the usual way thereby establishing a connection between the original and mirrored fields.

<H2><A NAME="SECTION00035000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Timekeeping</A>
</H2>

<P>
<A NAME="Timekeeping"></A>
<P>
The NUOPC Layer associates an internal clock with three of its four generic component kinds: <TT>NUOPC_Driver</TT>, <TT>NUOPC_Model</TT>, and <TT>NUOPC_Mediator</TT>. The <TT>NUOPC_Connector</TT> is the only NUOPC component kind that does not have an internal clock object that is managed by NUOPC.

<P>
The component internal clocks are implemented as <TT>ESMF_Clock</TT> objects. The interaction beween these clock objects between a parent component (driver) and its child components (models, mediators, and drivers) is defined by the NUOPC timekeeping behavior described below.

<P>
For a simple run sequence with only a single coupling time-step, the driver clock sets the <TT>startTime</TT>, <TT>stopTime</TT>, and <TT>timeStep</TT> to be the beginning, the end, and the coupling period of the run, respectively. At the beginning of executing the run sequence, the driver clock <TT>currTime</TT> is set to its <TT>startTime</TT>. As the driver component executes the run sequence, it passes its clock to each child component that it executes. At the end of each full sweep through the run sequence the driver <TT>currTime</TT> is incremented by <TT>timeStep</TT> (i.e. the coupling period). This continues until the driver clock <TT>stopTime</TT> has been reached, and the run is complete.

<P>
When a child component is being called during the execution of the driver run sequence, it receives the driver/parent clock. This access is read-only, and the child component is only allowed to inspect but not modify the parent clock. The child component is expected to run forward a single coupling period, i.e. one <TT>timeStep</TT> on the parent clock. Specifically this means that the <TT>currTime</TT> on the child clock must match the <TT>currTime</TT> on the parent clock. It then must take a single <TT>timeStep</TT> of the parent clock forward, using its own clock to do so. The child component can implement this forward step by taking multiple smaller advances on its own clock. 

<P>
The generic NUOPC component implementation provides the following assistance to implement the above described behavior:

<P>

<UL>
<LI>During initialization of a component, its clock is set as a copy of its parent clock. Specifically the settings for <TT>startTime</TT>, <TT>stopTime</TT>, <TT>timeStep</TT>, and <TT>currTime</TT> are propagated. Alarms are not propagated.
</LI>
<LI>A component can customize aspects of its clock during initialization by using the <TT>label_SetClock</TT> specialization point.
</LI>
<LI>During run time, the default <TT>label_SetRunClock</TT> specialization checks that the <TT>currTime</TT> matches between child and parent clock. It further checks that the child clock can reach the parent's <TT>currTime</TT>+<TT>timeStep</TT>, i.e. the next coupling time, by an integral number of it's own time steps. If so, the <TT>stopTime</TT> on the child clock is set to the parent's <TT>currTime</TT>+<TT>timeStep</TT>.

<UL>
<LI>It can be useful to customize <TT>label_SetRunClock</TT>, e.g. if the parent uses dynamic coupling periods, or in case of a run sequence with multiple coupling periods. In these cases the component must react to the parent <TT>timeStep</TT> provided during execution of the run sequence. In general the <TT>currTime</TT> match should be implemented, followed by setting the child's <TT>timeStep</TT> according to the information provided on the parent clock. Finally the the <TT>stopTime</TT> on the child clock should be set as to return at the next coupling time determined by the parent clock.
</LI>
</UL>
</LI>
<LI>Once past the <TT>label_SetRunClock</TT> specialization, the component checks the timestamps on the fields in the import state. This is done by calling into the <TT>label_CheckImport</TT> specialization point. The default implementation simply checks that all import fields are at <TT>currTime</TT> of the child clock. 

<UL>
<LI>In more complex situations, where the interaction between different components happens with different coupling periods, it can be necessary to specialialize the <TT>label_CheckImport</TT> of a component. For example, a component might receive fields in its import state that carry different timestamps. Consequentely, <TT>label_CheckImport</TT> must implement a more complex relationship between the component's <TT>currTime</TT>, and the timestamps on each import field.
</LI>
</UL>
</LI>
<LI>Finally the component clock is stepped forward from <TT>currTime</TT> to <TT>stopTime</TT>, using the <TT>timeStep</TT> interval set in the child clock. During this loop, the <TT>label_Advance</TT> specialization is called for each time step. The <TT>label_Advance</TT> specialization is responsible for any accumulating and averaging that may be necessary.

<UL>
<LI>In practice often the <TT>timeStep</TT> on the child clock is chosen to be identical to that of the parent clock. This way the <TT>label_Advance</TT> specialization is only called once for every coupling period. In this approach the details about potentially smaller model time steps, and associated accumulation and averaging is handled below the NUOPC cap layer of a model.
</LI>
</UL>
</LI>
<LI>After the <TT>stopTime</TT> has been reached on the child clock, the <TT>label_TimestampExport</TT> specialization point is called before the component returns to the parent. The default implementation simply timestamps all the fields in the export state with the <TT>currTime</TT> of of the child clock.
</LI>
</UL>

<P>

<H2><A NAME="SECTION00036000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Component Hierarchies</A>
</H2>

<P>
<A NAME="ComponentHierarchy"></A>
<P>
The NUOPC Layer supports component hierarchies. The key function to support this capability is the ability for a generic <TT>NUOPC_Driver</TT> to add another <TT>NUOPC_Driver</TT> component as a child, and to drive it much like a <TT>NUOPC_Model</TT> component. The interactions upward and downward the hierarchy tree are governed by the standard NUOPC component interaction protocols.

<P>
In the current implementation, data-dependencies during initialization can be resolved throughout the entire component hierarchy. The implementation is based on a sweep algorithm that continues up and down the hierarchy until either all data-dependencies have been resolved, or a dead-lock situation has been detected and flagged.

<P>
Along the downward direction, the interaction of a driver with its children allows the driver to mirror its child components' fields, and to transfer or share geom objects and fields up the component hierarchy. All of the interactions of a driver with its child components are handled by explicit <TT>NUOPC_Connector</TT> instances. These instances are automatically added by the driver when needed.

<P>
The detailed behavior of a <TT>NUOPC_Driver</TT> component within a component hierarchy depends on the setting of the <TT>HierarchyProtocol</TT> attribute on the driver component itself. Section <A HREF="#DriverCompMeta">2.3.1</A> lists all of the driver attributes defined by NUOPC. By default the <TT>HierarchyProtocol</TT> attribute is unset. For unset <TT>HierarchyProtocol</TT> or when set to <TT>PushUpAllExportsAndUnsatisfiedImports</TT>, the driver component pushes all the fields from its children exportStates into its own exportState, and all unsatisfied fields in its children importStates into its own importState. This is done using the standard Field Mirroring protocol discussed under <A HREF="#FieldMirror">2.4.9</A>. Further the driver sets the <TT>SharePolicyGeomObject</TT>, and 
<TT>SharePolicyField</TT> to <TT>share</TT> for all the fields it mirrors. This triggers the reference share protocol as described in section <A HREF="#Sharing">2.4.8</A>.

<P>
When the <TT>HierarchyProtocol</TT> is set to <TT>Explorer</TT>, the driver component still mirrors the fields from its child components' import- and exportStates, as was done for the default, however, the share policies will not be set. This protocol option is used by the NUOPC ComponentExplorer to connect to user provided components.

<P>
Finally, for a setting of <TT>HierarchyProtocol</TT> to <TT>ConnectProvidedFields</TT>, the driver does not modify its own import- and exportState. Instead connections are made only between fields that have been added to the driver states externally. This is useful for the situation where a <TT>NUOPC_Driver</TT> component is called directly via ESMF component method from a level that is outside of NUOPC. In this situation, field and/or geom object sharing must be activated explicitly if desired.

<H2><A NAME="SECTION00037000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Resource Control and Threaded Components</A>
</H2>

<P>
<A NAME="AdvancedResourceControl"></A>
<P>
Each instance of a NUOPC component within an application is defined on a fixed set of compute resources. The association of resources occurs when the component is added to its parent component via the <TT>NUOPC_DriverAddComp()</TT> call. Subsequently when any of the component's Initialize, Run, or Finalize phases is called, the component code executes on the associated resources.

<P>
The primary control of resource management under NUOPC is implemented through the <TT>petList</TT> argument that is accepted by <TT>NUOPC_DriverAddComp()</TT>. This argument holds a list of Persistent Execution Thread (PET) ids of the parent component on which the child component is to execute. By default, i.e. when <TT>petList</TT> is <EM>not</EM> specified, <EM>all</EM> of the parent PETs are associated with the added child component. Using custom <TT>petList</TT> constructions, a driver has control of exactly how its child components are sharing the available PET resources.

<P>
Notice that the <EM>order</EM> of PETs listed in a <TT>petList</TT> is significant. The local PET labeling inside a child component always goes from <TT>0</TT> to <TT>size(petList)-1</TT>. The order in which the child PETs correspond to the parent PETs is that specified by the <TT>petList</TT>. It is erroneous to list the same parent PET multiple times in the <EM>same</EM> <TT>petList</TT> argument.

<P>
For the following discussion it is convenient to think of PETs as simple MPI processes. While this is not strictly correct on a technically ESMF level, there are currently no features available to NUOPC where this interpretation would lead to inconsistencies. One of the key consequences of equating each PET to a simple MPI process is that each PET can only execute a single component's code at any given time. Therefore, in order to allow components to execute concurrently, a necessary condition is to define them on exclusive petLists. Of course the data dependencies between components must also support concurrent execution. Often this requires careful placement of Connectors in the run sequence and the introduction of time lags. However, this is more of a scientific than the resource control question covered in this section.

<P>
Many model components today implement the hybrid MPI+OpenMP paradigm to support scalability to larger core counts than would be possible in a purely MPI or OpenMP approach. NUOPC supports hybrid MPI+OpenMP components in two ways: NUOPC <EM>aware</EM> and NUOPC <EM>unaware</EM>. In the NUOPC <EM>unaware</EM> approach, the application is launched only on those MPI ranks that are going to participate in the hybrid execution with OpenMP. Usually this means that the MPI launch system (mpirun, mpiexec, aprun, srun, etc.), and a set of environment variables get involved in correctly associating the desired number of hardware cores with each MPI process, and to assure correct affinities. In this approach NUOPC is not at all involved in the resource management, and OpenMP threading happens purely on the user level.

<P>
The NUOPC <EM>unaware</EM> hybrid MPI+OpenMP approach provides a quick way to run hybrid applications that consist of a single model component, or where all of the model components use the same hybrid approach with the same ratio of OpenMP threads per MPI rank. In this case, shell-based user level resource control is often sufficient. However, for more complex coupling scenarios the NUOPC <EM>aware</EM> hybrid approach provides additional levels of control that are often needed to achieve optimal utilization of the available resources

<P>
Under the NUOPC <EM>aware</EM> resource control, some components might be purely MPI based, while others use the hybrid approach. Different hybrid components can be configured to run with different threading levels. This is possible independent on whether the components use the same or exclusive sets of resources.

<P>
Besides the already discussed <TT>petList</TT> argument, there are two additional optional arguments to <TT>NUOPC_DriverAddComp()</TT>. It is through those arguments that the advanced resource control features under NUOPC are implemented. One of these arguments is <TT>compSetVMRoutine</TT>. This argument allows the user to point to a specific public method of the child component. The signature of this method is the same as for the <TT>compSetServicesRoutine</TT> argument. If <TT>compSetVMRoutine</TT> is provided, it will be called <EM>before</EM> <TT>compSetServicesRoutine</TT>. The purpose of <TT>compSetVMRoutine</TT> is to allow the child component to set specific aspects of its own ESMF virtual machine (VM) before instantiating it. The ESMF reference manual discusses the details of this procedure under the "User-code SetVM method" section. Based on the information provided there, a user could implement a custom <TT>compSetVMRoutine</TT> method for a component. However, for convenience, NUOPC provides a generic implementation that can be passed into <TT>compSetVMRoutine</TT>. For most common situation, the generic implementation provided by NUOPC is sufficient, and there is no need for the user to provide a custom implementation of <TT>compSetVMRoutine</TT>.

<P>
Utilizing the generic <TT>SetVM</TT> method provided by NUOPC involves a few steps. First, the component implementation must make the generic <TT>SetVM</TT> <EM>public</EM> inside its own <EM>cap</EM> module:

<P>
<PRE>
module MODEL

  !-----------------------------------------------------------------------------
  ! MODEL Component.
  !-----------------------------------------------------------------------------

  use ESMF
  use NUOPC
  use NUOPC_Model, &amp;
    modelSS    =&gt; SetServices

  implicit none

  private

  public SetVM, SetServices   ! Here making SetVM and SetServices public.

  !-----------------------------------------------------------------------------
  contains
  !-----------------------------------------------------------------------------
  ...
end module
</PRE>

<P>
Second, the driver component that adds MODEL via <TT>NUOPC_DriverAddComp()</TT> as a child component, must make a <TT>USE</TT> association to the <TT>SetVM</TT>:

<P>
<PRE>
module driver

  !-----------------------------------------------------------------------------
  ! Code that specializes generic NUOPC_Driver
  !-----------------------------------------------------------------------------

  use MPI
  use ESMF
  use NUOPC
  use NUOPC_Driver, &amp;
    driverSS             =&gt; SetServices

  use MODEL, only: &amp;
    modelSS     =&gt; SetServices, &amp;
    modelSVM    =&gt; SetVM            ! Here making USE association to SetVM.

  implicit none

  private

  public SetServices

  !-----------------------------------------------------------------------------
  contains
  !-----------------------------------------------------------------------------
  ...
end module
</PRE>

<P>
Third, the driver can now pass the <TT>modelSVM</TT> into <TT>NUOPC_DriverAddComp()</TT> via the <TT>compSetVMRoutine</TT> argument, essentially providing the generic <TT>SetVM</TT> method.

<P>
Finally, the generic <TT>SetVM</TT> implementation needs to be informed about the specific resource control request. This is handled through <EM>the other</EM> optional argument to <TT>NUOPC_DriverAddComp()</TT> alluded to earlier. This is the <TT>info</TT> argument.

<P>
The <TT>info</TT> argument is of <TT>type(ESMF_Info)</TT>, which implements a structured key/value pair class. An <TT>info</TT> object must first be created via <TT>ESMF_InfoCreate()</TT> before any key/value pairs can be set.

<P>
<PRE>
    type(ESMF_Info)               :: info
    ...
    info = ESMF_InfoCreate(rc=rc)
    ! check rc
</PRE>

<P>
NUOPC resource control is implemented under the <TT>/NUOPC/Hint/PePerPet</TT> <EM>structure</EM>. The following table documents the available <EM>keys</EM> under this structure, the supported <EM>values</EM>, and their meaning. Notice that <EM>structure</EM> and <EM>keys</EM> are case sensitive, while <EM>values</EM> are case insensitive.

<P>
<BR>
<BR>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><B>key</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><B>value</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250><B>Meaning</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>MaxCount</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>Positive integer</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>The <EM>maximum</EM> number of Processing Elements (PEs), i.e. cores or hardware threads, associated with each child PET. The procedure is this: the PEs associated with the incoming parent PETs (e.g. via <TT>petList</TT>), are grouped by single system image (SSI), i.e. shared memory domain or hardware node. Within each SSI the PEs are divided by the <TT>MaxCount</TT> to determine how many child PETs are needed for each SSI. The PEs on each SSI are then associated with the child PETs.

<P>
Note that this procedure only then results in every child PET holding exactly <TT>MaxCount</TT> PEs when the number of PEs per SSI brought in by the parent PETs is a <EM>multiple</EM> of <TT>MaxCount</TT>.

<P>
Parent PETs that for the child VM gave up their PEs, and are not executing as child PETs, are paused for the duration of the child component execution. They resume execution under the parent VM once the child component returns control to the parent.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>OpenMpHandling</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>String: <EM>none</EM>, <EM>set</EM>, <EM>init</EM>, or <EM>pin</EM> (the default)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>For "none", OpenMP handling is completely left to the user. In this case the user child component code will typically want to query the child VM for the local number of PEs under each child PET. This number then would be used in an explicit call to <TT>omp_set_num_threads()</TT> in order to set the OpenMP thread number according to the available PEs under each child PET.

<P>
For "set", the NUOPC/ESMF layer make the call to <TT>omp_set_num_threads()</TT> under each child PET with the appropriate number of PEs.

<P>
For "init", the NUOPC/ESMF layers sets the number of OpenMP threads in each team, and triggers the instantiation of all the threads in the team.

<P>
For "pin", the NUOPC/ESMF layers sets the number of OpenMP threads in each team, triggers the instantiation of the team, and pins each OpenMP thread to the corresponding PE.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>OpenMpNumThreads</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>Positive integer</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>By default the "set", "init", or "pin" option under <TT>OpenMpHandling</TT> sets the number of OpenMP threads in each team equal to the number of PEs under each PET. Setting <TT>OpenMpNumThreads</TT>, this default can be overwritten. The option allows the user to under- or oversubscribe the PEs held by each PET.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>ForceChildPthreads</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>Logical: <TT>.true.</TT>, or <TT>.false.</TT> (the default)</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>By default (<TT>.false.</TT>) each PET executes under the same thread as its parent PET. Typically this means that PETs execute directly as the MPI process under which they were created. In some cases it is beneficial to create a separate Pthread for each child PET. This can be accomplished by setting the value to <TT>.true.</TT>.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>PthreadMinStackSize</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>Positive integer</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>The minimum stack size in <EM>byte</EM> of each child PET that is executing as Pthread. By default child PETs do <EM>not</EM> execute as Pthreads. Therefore the stack size by default is equal to that of the parent PET. However, if <TT>ForceChildPthreads</TT> is set to <TT>true</TT>, all child PETs are instantiated as Pthreads. This means that the stack size <EM>cannot</EM> be <EM>unlimited</EM>. ESMF implements a default minimum stack size for child PETs of 20MiB. This minimum default can be changed (up or down) via the <TT>PthreadMinStackSize</TT> key.

<P>
The system <TT>limit</TT> or <TT>ulimit</TT> commands can be used to further <EM>increase</EM> the stack size of child PETs. Any limit set lower than the <TT>PthreadMinStackSize</TT>, or set to <EM>unlimited</EM>, will result in usage of the <TT>PthreadMinStackSize</TT> if set, or the 20MiB default.

<P>
Note further that when OpenMP is used inside the child component, each child PET becomes the root thread of each of the OpenMP thread teams. It is therefore the root thread stack size that is affected by <TT>PthreadMinStackSize</TT>. The stack size of all the <EM>other</EM> OpenMP threads in each team is set via environment variable <TT>OMP_STACKSIZE</TT> as usual.</TD>
</TR>
</TABLE>

<P>
The following code snippet demonstrates a typical resource control request using the generic <TT>SetVM</TT> routine and an <TT>info</TT> object. This request is suitable for a hybrid MPI+OpenMP component where every child PET is expected to run 4-way OpenMP threaded.

<P>
<PRE>
    call ESMF_InfoSet(info, key="/NUOPC/Hint/PePerPet/MaxCount", value=4, rc=rc)
    ! check rc
    call NUOPC_DriverAddComp(driver, "MODEL1", modelSS, modelSVM, info=info, rc=rc)
    ! check rc
</PRE>

<P>
A second child component can be created that uses the same parent resources as the first, but sets up 8-way OpenMP threading under each child PET.

<P>
<PRE>
    call ESMF_InfoSet(info, key="/NUOPC/Hint/PePerPet/MaxCount", value=8, rc=rc)
    ! check rc
    call NUOPC_DriverAddComp(driver, "MODEL2", modelSS, modelSVM, info=info, rc=rc)
    ! check rc
</PRE>

<P>
If the default settings for some of the keys are not appropriate, they can be set explicitly. Here for instance a child component with the same number of PETs as the previous 4-way OpenMP threaded case is created, but is instructed to not handle any of the OpenMP aspects.

<P>
<PRE>
    call ESMF_InfoSet(info, key="/NUOPC/Hint/PePerPet/MaxCount", value=4, rc=rc)
    ! check rc
    call ESMF_InfoSet(info, key="/NUOPC/Hint/PePerPet/OpenMpHandling", &amp;
      value="none", rc=rc)
    ! check rc
    call NUOPC_DriverAddComp(driver, "MODEL3", modelSS, modelSVM, info=info, rc=rc)
    ! check rc
</PRE>

<P>
In this example, all three child components "MODEL1", "MODEL2", and "MODEL3" use the exact same parent resources. Due to this fact all three components can only execute sequentially. However, each child component manages the resources provided by the parent differently, and independently. Through this tailored approach, NUOPC allows optimal use of the available resources by each component. <TT>NUOPC_Connector</TT> components defined between components work as usual, taking care of all the required data movements automatically and completely transparent to the user.

<P>
In order to obtain best performance when using NUOPC <EM>aware</EM> resource control for hybrid parallelism, it is <EM>strongly recommended</EM> to set <TT>OMP_WAIT_POLICY=PASSIVE</TT> in the environment. This is one of the standard OpenMP environment variables. The <TT>PASSIVE</TT> setting ensures that OpenMP threads relinquish the hardware threads (i.e. cores) as soon as they have completed their work. Without that setting ESMF resource control threads can be delayed, and context switching between components becomes more expensive.

<H2><A NAME="SECTION00038000000000000000">
<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> External NUOPC Interface</A>
</H2>

<P>
<A NAME="ExternalInterface"></A>
<P>
Complete applications can easily be built by assembling NUOPC compliant components. Many such NUOPC applications are in productive use across several institutions. The top level of such applications is typically implemented via a very thin application layer holding the main program that calls into the top level driver component that derives from <TT>NUOPC_Driver</TT>. Model components sit under the top level driver, interacting with one another and the driver through the NUOPC protocols. Complex systems have one or more component hierarchy levels under the top level driver as discussed in the previous section.

<P>
There are situation, however, where a NUOPC application needs to be controlled by an outside component. Such an outside component does not derive from any of the generic NUOPC components, and cannot be expected to implement the complete NUOPC protocol. Typically such an external component implements its own control structure outside of NUOPC and ESMF. One example of such a situation are data assimilation systems that want to drive a NUOPC forecast application. 

<P>
In order to facilitate the external access into a NUOPC application, the <TT>NUOPC_Driver</TT> provides an <EM>external interface</EM>. This interface is implemented through the standard ESMF component methods: Initialize, Run, and Finalize. This interface with the top level NUOPC driver allows an external component to control and interact with the entire NUOPC application.

<P>
The standard ESMF component interfaces hold <TT>importState</TT>, <TT>exportState</TT>, and a <TT>clock</TT> argument. These arguments are used to pass data in and out of the NUOPC application, and control the time stepping of the NUOPC model, respectively. The top level driver of a NUOPC application has access to any field that is advertised by any of the components and therefore serves as a single point of access for the entire application.

<P>
The external NUOPC interface is currently defined by the Initialize, Run, and Finalize phases documented in the following table.

<P>
<BR>
<BR>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><B>methodFlag</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100><B>phaseLabel</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250><B>Meaning</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>ESMF_METHOD_INITIALIZE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>label_ExternalAdvertise</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Called after the external component has 
                                                                 set up the import- and exportStates with 
                                                                 fields (advertised) that it plans to interact with.
                                                                 On the NUOPC application side this call will
                                                                 got through the complete advertise cylce.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>ESMF_METHOD_INITIALIZE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>label_ExternalRealize</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Called after the external component has
                                                                 been informed about the connected status of
                                                                 the fields in the import- and exportState.
                                                                 On the NUOPC application side this call will
                                                                 finish setting up RouteHandles between all
                                                                 components involved.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>ESMF_METHOD_INITIALIZE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>label_ExternalDataInit</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Trigger a complete data initialize throughout
                                                                 the NUOPC application. The expectation is that
                                                                 all components reset their data consistent with
                                                                 the <TT>clock</TT> argument.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>ESMF_METHOD_RUN</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>The default Run() method steps the NUOPC
                                                                 application forward in time according to
                                                                 the <TT>clock</TT> argument.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>ESMF_METHOD_FINALIZE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>label_ExternalReset</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Inform the NUOPC application about a <TT>clock</TT>
                                                                 reset.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=150><TT>ESMF_METHOD_FINALIZE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=100>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=250>Completely finalize and shut down the NUOPC application.</TD>
</TR>
</TABLE>

<P>
Here <TT>methodFlag</TT> and <TT>phaseLabel</TT> corrsepond to the respective arguments of method <TT>NUOPC_CompSearchPhaseMap()</TT>. This method is used to determine the actual ESMF phase index needed when calling into <TT>ESMF_GridCompInitialize()</TT>, <TT>ESMF_GridCompRun()</TT>, or <TT>ESMF_GridCompFinalize()</TT>. In cases where no <TT>phaseLabel</TT> is indicated, the default phase is used for the implementation, accessible by not specifying the argument.

<P>
For a complete example of how the <EM>External NUOPC API</EM> is used in practice, see <TT><SMALL CLASS="SMALL">https://github.com/esmf-org/nuopc-app-prototypes/tree/develop/ExternalDriverAPIProto</SMALL></TT>. The following code snippets demonstrates the critical pieces of code from the external layer interacting with NUOPC/ESMF.

<P>
<PRE>
  ! Create the external level import/export States
  ! NOTE: The "stateintent" must be specified, and it must be set from the
  ! perspective of the external level:
  ! -&gt; state holding fields exported by the external level to the ESM component
  externalExportState = ESMF_StateCreate(stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
    ! check rc
  ! -&gt; state holding fields imported by the external level from the ESM component
  externalImportState = ESMF_StateCreate(stateintent=ESMF_STATEINTENT_IMPORT, rc=rc)
    ! check rc

  ! Advertise field(s) in external import state to receive from the NUOPC layer
  call NUOPC_Advertise(externalImportState, &amp;
    StandardNames=(/"sea_surface_temperature"/), &amp;
    TransferOfferGeomObject="cannot provide", SharePolicyField="share", rc=rc)
    ! check rc

  ! Call "ExternalAdvertise" Initialize for the earth system Component
  call NUOPC_CompSearchPhaseMap(nuopcApp, methodflag=ESMF_METHOD_INITIALIZE, &amp;
    phaseLabel=label_ExternalAdvertise, phaseIndex=phase, rc=rc)
    ! check rc
  call ESMF_GridCompInitialize(nuopcApp, phase=phase, clock=clock, &amp;
    importState=externalExportState, exportState=externalImportState, userRc=urc, rc=rc)
    ! check rc and urc

  ! Call "ExternalRealize" Initialize for the earth system Component
  call NUOPC_CompSearchPhaseMap(nuopcApp, methodflag=ESMF_METHOD_INITIALIZE, &amp;
    phaseLabel=label_ExternalRealize, phaseIndex=phase, rc=rc)
    ! check rc
  call ESMF_GridCompInitialize(nuopcApp, phase=phase, clock=clock, &amp;
    importState=externalExportState, exportState=externalImportState, userRc=urc, rc=rc)
    ! check rc and urc

  ! Call "ExternalDataInit" Initialize for the earth system Component
  call NUOPC_CompSearchPhaseMap(nuopcApp, methodflag=ESMF_METHOD_INITIALIZE, &amp;
    phaseLabel=label_ExternalDataInit, phaseIndex=phase, rc=rc)
    ! check rc
  call ESMF_GridCompInitialize(nuopcApp, phase=phase, clock=clock, &amp;
    importState=externalExportState, exportState=externalImportState, userRc=urc, rc=rc)
    ! check rc and urc

  ! Explicit time stepping loop on the external level, here based on ESMF_Clock
  do while (.not.ESMF_ClockIsStopTime(clock, rc=rc))
    ! Run the earth system Component: i.e. step ESM forward by timestep
    call ESMF_GridCompRun(nuopcApp, clock=clock, &amp;
      importState=externalExportState, exportState=externalImportState, userRc=urc, rc=rc)
    ! check rc and urc
    ! Advance the clock
    call ESMF_ClockAdvance(clock, rc=rc)
    ! check rc
  end do

  ! Finalize the earth system Component
  call ESMF_GridCompFinalize(nuopcApp, clock=clock, &amp;
    importState=externalExportState, exportState=externalImportState, userRc=urc, rc=rc)
    ! check rc and urc
</PRE>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html412"
  HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html408"
  HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html402"
  HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html410"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html413"
  HREF="node4.html">3 API</A>
<B> Up:</B> <A NAME="tex2html409"
  HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A NAME="tex2html403"
  HREF="node2.html">1 Description</A>
 &nbsp; <B>  <A NAME="tex2html411"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
