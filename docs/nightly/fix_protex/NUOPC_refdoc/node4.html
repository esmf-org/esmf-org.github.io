<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2025 (Released January 1, 2025) -->
<HTML lang="en">
<HEAD>
<TITLE>3 API</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2025">

<LINK REL="STYLESHEET" HREF="NUOPC_refdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html409"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node5.html">4 Standardized Component Dependencies</A>
<B> Up:</B> <A
 HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A
 HREF="node3.html">2 Design and Implementation Notes</A>
 &nbsp; <B>  <A ID="tex2html410"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html411"
  HREF="node4.html#SECTION00041000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Generic Component: NUOPC_Driver</A>
<UL>
<LI><A ID="tex2html412"
  HREF="node4.html#SECTION00041100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_DriverAddComp</A>
<LI><A ID="tex2html413"
  HREF="node4.html#SECTION00041200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_DriverAddComp</A>
<LI><A ID="tex2html414"
  HREF="node4.html#SECTION00041300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_DriverAddComp</A>
<LI><A ID="tex2html415"
  HREF="node4.html#SECTION00041400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_DriverAddRunElement</A>
<LI><A ID="tex2html416"
  HREF="node4.html#SECTION00041500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_DriverAddRunElement</A>
<LI><A ID="tex2html417"
  HREF="node4.html#SECTION00041600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_DriverAddRunElement</A>
<LI><A ID="tex2html418"
  HREF="node4.html#SECTION00041700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_DriverEgestRunSequence</A>
<LI><A ID="tex2html419"
  HREF="node4.html#SECTION00041800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_DriverGet</A>
<LI><A ID="tex2html420"
  HREF="node4.html#SECTION00041900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_DriverGetComp</A>
<LI><A ID="tex2html421"
  HREF="node4.html#SECTION000411000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_DriverGetComp</A>
<LI><A ID="tex2html422"
  HREF="node4.html#SECTION000411100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_DriverGetComp</A>
<LI><A ID="tex2html423"
  HREF="node4.html#SECTION000411200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_DriverGetComp</A>
<LI><A ID="tex2html424"
  HREF="node4.html#SECTION000411300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_DriverIngestRunSequence</A>
<LI><A ID="tex2html425"
  HREF="node4.html#SECTION000411400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_DriverIngestRunSequence</A>
<LI><A ID="tex2html426"
  HREF="node4.html#SECTION000411500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_DriverNewRunSequence</A>
<LI><A ID="tex2html427"
  HREF="node4.html#SECTION000411600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_DriverPrint</A>
<LI><A ID="tex2html428"
  HREF="node4.html#SECTION000411700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_DriverSetRunSequence</A>
</UL>
<BR>
<LI><A ID="tex2html429"
  HREF="node4.html#SECTION00042000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Generic Component: NUOPC_ModelBase</A>
<LI><A ID="tex2html430"
  HREF="node4.html#SECTION00043000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Generic Component: NUOPC_Model</A>
<UL>
<LI><A ID="tex2html431"
  HREF="node4.html#SECTION00043100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_ModelGet</A>
</UL>
<BR>
<LI><A ID="tex2html432"
  HREF="node4.html#SECTION00044000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Generic Component: NUOPC_Mediator</A>
<UL>
<LI><A ID="tex2html433"
  HREF="node4.html#SECTION00044100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_MediatorGet</A>
</UL>
<BR>
<LI><A ID="tex2html434"
  HREF="node4.html#SECTION00045000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Generic Component: NUOPC_Connector</A>
<UL>
<LI><A ID="tex2html435"
  HREF="node4.html#SECTION00045100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_ConnectorGet</A>
<LI><A ID="tex2html436"
  HREF="node4.html#SECTION00045200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_ConnectorSet</A>
</UL>
<BR>
<LI><A ID="tex2html437"
  HREF="node4.html#SECTION00046000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> General Generic Component Methods</A>
<UL>
<LI><A ID="tex2html438"
  HREF="node4.html#SECTION00046100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_CompAreServicesSet</A>
<LI><A ID="tex2html439"
  HREF="node4.html#SECTION00046200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_CompAreServicesSet</A>
<LI><A ID="tex2html440"
  HREF="node4.html#SECTION00046300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_CompAttributeAdd</A>
<LI><A ID="tex2html441"
  HREF="node4.html#SECTION00046400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_CompAttributeAdd</A>
<LI><A ID="tex2html442"
  HREF="node4.html#SECTION00046500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_CompAttributeEgest</A>
<LI><A ID="tex2html443"
  HREF="node4.html#SECTION00046600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_CompAttributeEgest</A>
<LI><A ID="tex2html444"
  HREF="node4.html#SECTION00046700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_CompAttributeGet</A>
<LI><A ID="tex2html445"
  HREF="node4.html#SECTION00046800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_CompAttributeGet</A>
<LI><A ID="tex2html446"
  HREF="node4.html#SECTION00046900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_CompAttributeGet</A>
<LI><A ID="tex2html447"
  HREF="node4.html#SECTION000461000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_CompAttributeGet</A>
<LI><A ID="tex2html448"
  HREF="node4.html#SECTION000461100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_CompAttributeGet</A>
<LI><A ID="tex2html449"
  HREF="node4.html#SECTION000461200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_CompAttributeGet</A>
<LI><A ID="tex2html450"
  HREF="node4.html#SECTION000461300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_CompAttributeGet</A>
<LI><A ID="tex2html451"
  HREF="node4.html#SECTION000461400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_CompAttributeGet</A>
<LI><A ID="tex2html452"
  HREF="node4.html#SECTION000461500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_CompAttributeIngest</A>
<LI><A ID="tex2html453"
  HREF="node4.html#SECTION000461600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_CompAttributeIngest</A>
<LI><A ID="tex2html454"
  HREF="node4.html#SECTION000461700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_CompAttributeIngest</A>
<LI><A ID="tex2html455"
  HREF="node4.html#SECTION000461800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> NUOPC_CompAttributeIngest</A>
<LI><A ID="tex2html456"
  HREF="node4.html#SECTION000461900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> NUOPC_CompAttributeReset</A>
<LI><A ID="tex2html457"
  HREF="node4.html#SECTION000462000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> NUOPC_CompAttributeReset</A>
<LI><A ID="tex2html458"
  HREF="node4.html#SECTION000462100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> NUOPC_CompAttributeSet</A>
<LI><A ID="tex2html459"
  HREF="node4.html#SECTION000462200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> NUOPC_CompAttributeSet</A>
<LI><A ID="tex2html460"
  HREF="node4.html#SECTION000462300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> NUOPC_CompAttributeSet</A>
<LI><A ID="tex2html461"
  HREF="node4.html#SECTION000462400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> NUOPC_CompAttributeSet</A>
<LI><A ID="tex2html462"
  HREF="node4.html#SECTION000462500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> NUOPC_CompAttributeSet</A>
<LI><A ID="tex2html463"
  HREF="node4.html#SECTION000462600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> NUOPC_CompAttributeSet</A>
<LI><A ID="tex2html464"
  HREF="node4.html#SECTION000462700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> NUOPC_CompCheckSetClock</A>
<LI><A ID="tex2html465"
  HREF="node4.html#SECTION000462800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> NUOPC_CompDerive</A>
<LI><A ID="tex2html466"
  HREF="node4.html#SECTION000462900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> NUOPC_CompDerive</A>
<LI><A ID="tex2html467"
  HREF="node4.html#SECTION000463000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> NUOPC_CompFilterPhaseMap</A>
<LI><A ID="tex2html468"
  HREF="node4.html#SECTION000463100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> NUOPC_CompFilterPhaseMap</A>
<LI><A ID="tex2html469"
  HREF="node4.html#SECTION000463200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> NUOPC_CompGet</A>
<LI><A ID="tex2html470"
  HREF="node4.html#SECTION000463300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> NUOPC_CompGet</A>
<LI><A ID="tex2html471"
  HREF="node4.html#SECTION000463400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> NUOPC_CompSearchPhaseMap</A>
<LI><A ID="tex2html472"
  HREF="node4.html#SECTION000463500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> NUOPC_CompSearchPhaseMap</A>
<LI><A ID="tex2html473"
  HREF="node4.html#SECTION000463600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> NUOPC_CompSearchRevPhaseMap</A>
<LI><A ID="tex2html474"
  HREF="node4.html#SECTION000463700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> NUOPC_CompSearchRevPhaseMap</A>
<LI><A ID="tex2html475"
  HREF="node4.html#SECTION000463800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> NUOPC_CompSetClock</A>
<LI><A ID="tex2html476"
  HREF="node4.html#SECTION000463900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> NUOPC_CompSetEntryPoint</A>
<LI><A ID="tex2html477"
  HREF="node4.html#SECTION000464000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> NUOPC_CompSetEntryPoint</A>
<LI><A ID="tex2html478"
  HREF="node4.html#SECTION000464100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> NUOPC_CompSetInternalEntryPoint</A>
<LI><A ID="tex2html479"
  HREF="node4.html#SECTION000464200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> NUOPC_CompSetServices</A>
<LI><A ID="tex2html480"
  HREF="node4.html#SECTION000464300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">43</SPAN> NUOPC_CompSetVM</A>
<LI><A ID="tex2html481"
  HREF="node4.html#SECTION000464400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">44</SPAN> NUOPC_CompSpecialize</A>
<LI><A ID="tex2html482"
  HREF="node4.html#SECTION000464500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">45</SPAN> NUOPC_CompSpecialize</A>
</UL>
<BR>
<LI><A ID="tex2html483"
  HREF="node4.html#SECTION00047000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Field Dictionary Methods</A>
<UL>
<LI><A ID="tex2html484"
  HREF="node4.html#SECTION00047100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_FieldDictionaryAddEntry</A>
<LI><A ID="tex2html485"
  HREF="node4.html#SECTION00047200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_FieldDictionaryEgest</A>
<LI><A ID="tex2html486"
  HREF="node4.html#SECTION00047300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_FieldDictionaryGetEntry</A>
<LI><A ID="tex2html487"
  HREF="node4.html#SECTION00047400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_FieldDictionaryHasEntry</A>
<LI><A ID="tex2html488"
  HREF="node4.html#SECTION00047500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_FieldDictionaryMatchSyno</A>
<LI><A ID="tex2html489"
  HREF="node4.html#SECTION00047600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_FieldDictionarySetSyno</A>
<LI><A ID="tex2html490"
  HREF="node4.html#SECTION00047700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_FieldDictionarySetup</A>
<LI><A ID="tex2html491"
  HREF="node4.html#SECTION00047800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_FieldDictionarySetup</A>
</UL>
<BR>
<LI><A ID="tex2html492"
  HREF="node4.html#SECTION00048000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Free Format Methods</A>
<UL>
<LI><A ID="tex2html493"
  HREF="node4.html#SECTION00048100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_FreeFormatAdd</A>
<LI><A ID="tex2html494"
  HREF="node4.html#SECTION00048200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_FreeFormatCreate</A>
<LI><A ID="tex2html495"
  HREF="node4.html#SECTION00048300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_FreeFormatCreate</A>
<LI><A ID="tex2html496"
  HREF="node4.html#SECTION00048400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_FreeFormatDestroy</A>
<LI><A ID="tex2html497"
  HREF="node4.html#SECTION00048500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_FreeFormatGet</A>
<LI><A ID="tex2html498"
  HREF="node4.html#SECTION00048600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_FreeFormatGetLine</A>
<LI><A ID="tex2html499"
  HREF="node4.html#SECTION00048700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_FreeFormatLog</A>
<LI><A ID="tex2html500"
  HREF="node4.html#SECTION00048800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_FreeFormatPrint</A>
</UL>
<BR>
<LI><A ID="tex2html501"
  HREF="node4.html#SECTION00049000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Utility Routines</A>
<UL>
<LI><A ID="tex2html502"
  HREF="node4.html#SECTION00049100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_AddNamespace</A>
<LI><A ID="tex2html503"
  HREF="node4.html#SECTION00049200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_AddNestedState</A>
<LI><A ID="tex2html504"
  HREF="node4.html#SECTION00049300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_Advertise</A>
<LI><A ID="tex2html505"
  HREF="node4.html#SECTION00049400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_Advertise</A>
<LI><A ID="tex2html506"
  HREF="node4.html#SECTION00049500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_AdjustClock</A>
<LI><A ID="tex2html507"
  HREF="node4.html#SECTION00049600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_CheckSetClock</A>
<LI><A ID="tex2html508"
  HREF="node4.html#SECTION00049700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_GetAttribute</A>
<LI><A ID="tex2html509"
  HREF="node4.html#SECTION00049800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_GetAttribute</A>
<LI><A ID="tex2html510"
  HREF="node4.html#SECTION00049900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_GetAttribute</A>
<LI><A ID="tex2html511"
  HREF="node4.html#SECTION000491000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_GetStateMemberLists</A>
<LI><A ID="tex2html512"
  HREF="node4.html#SECTION000491100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_GetStateMemberCount</A>
<LI><A ID="tex2html513"
  HREF="node4.html#SECTION000491200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_GetTimestamp</A>
<LI><A ID="tex2html514"
  HREF="node4.html#SECTION000491300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_IngestPetList</A>
<LI><A ID="tex2html515"
  HREF="node4.html#SECTION000491400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_IngestPetList</A>
<LI><A ID="tex2html516"
  HREF="node4.html#SECTION000491500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_IsAtTime</A>
<LI><A ID="tex2html517"
  HREF="node4.html#SECTION000491600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_IsAtTime</A>
<LI><A ID="tex2html518"
  HREF="node4.html#SECTION000491700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_IsConnected</A>
<LI><A ID="tex2html519"
  HREF="node4.html#SECTION000491800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">18</SPAN> NUOPC_IsConnected</A>
<LI><A ID="tex2html520"
  HREF="node4.html#SECTION000491900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">19</SPAN> NUOPC_IsUpdated</A>
<LI><A ID="tex2html521"
  HREF="node4.html#SECTION000492000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">20</SPAN> NUOPC_IsUpdated</A>
<LI><A ID="tex2html522"
  HREF="node4.html#SECTION000492100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">21</SPAN> NUOPC_NoOp</A>
<LI><A ID="tex2html523"
  HREF="node4.html#SECTION000492200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">22</SPAN> NUOPC_Realize</A>
<LI><A ID="tex2html524"
  HREF="node4.html#SECTION000492300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">23</SPAN> NUOPC_Realize</A>
<LI><A ID="tex2html525"
  HREF="node4.html#SECTION000492400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">24</SPAN> NUOPC_Realize</A>
<LI><A ID="tex2html526"
  HREF="node4.html#SECTION000492500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">25</SPAN> NUOPC_Realize</A>
<LI><A ID="tex2html527"
  HREF="node4.html#SECTION000492600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">26</SPAN> NUOPC_Realize</A>
<LI><A ID="tex2html528"
  HREF="node4.html#SECTION000492700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">27</SPAN> NUOPC_SetAttribute</A>
<LI><A ID="tex2html529"
  HREF="node4.html#SECTION000492800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">28</SPAN> NUOPC_SetAttribute</A>
<LI><A ID="tex2html530"
  HREF="node4.html#SECTION000492900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">29</SPAN> NUOPC_SetTimestamp</A>
<LI><A ID="tex2html531"
  HREF="node4.html#SECTION000493000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">30</SPAN> NUOPC_SetTimestamp</A>
<LI><A ID="tex2html532"
  HREF="node4.html#SECTION000493100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">31</SPAN> NUOPC_SetTimestamp</A>
<LI><A ID="tex2html533"
  HREF="node4.html#SECTION000493200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">32</SPAN> NUOPC_SetTimestamp</A>
<LI><A ID="tex2html534"
  HREF="node4.html#SECTION000493300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">33</SPAN> NUOPC_SetTimestamp</A>
</UL>
<BR>
<LI><A ID="tex2html535"
  HREF="node4.html#SECTION000410000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Auxiliary Routines</A>
<UL>
<LI><A ID="tex2html536"
  HREF="node4.html#SECTION000410100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_Write</A>
<LI><A ID="tex2html537"
  HREF="node4.html#SECTION000410200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_Write</A>
<LI><A ID="tex2html538"
  HREF="node4.html#SECTION000410300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_Write</A>
<LI><A ID="tex2html539"
  HREF="node4.html#SECTION000410400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_Write</A>
<LI><A ID="tex2html540"
  HREF="node4.html#SECTION000410500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_Write</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION00040000000000000000">
<SPAN CLASS="arabic">3</SPAN> API</A>
</H1>

<H2><A ID="SECTION00041000000000000000"></A>
<A ID="NUOPC_Driver"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Generic Component: NUOPC_Driver
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">MODULE:</SPAN>
<PRE>  module NUOPC_Driver
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Component that drives and coordinates initialization of its child components: Model, Mediator, and Connector components. For every Driver time step the same run sequence, i.e. sequence of Model, Mediator, and Connector <SPAN style="font-family:monospace">Run</SPAN> methods is called. The run sequence is fully customizable. The default run sequence implements explicit time stepping.

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SUPER:</SPAN>
<PRE>  ESMF_GridComp
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">USE DEPENDENCIES:</SPAN>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SETSERVICES:</SPAN>
<PRE>  subroutine SetServices(driver, rc)
    type(ESMF_GridComp)   :: driver
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SEMANTIC SPECIALIZATION LABELS:</SPAN>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_SetModelServices</B>
    
<UL>
<LI>Optional. By default driver has no child components.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_DriverAddComp()</SPAN> repeatedly to add child components to the driver.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_CompAttributeSet()</SPAN> or <SPAN style="font-family:monospace">NUOPC_CompAttributeIngest()</SPAN> to set attributes on child components.
</LI>
<LI>Create and set driver clock with startTime, stopTime, and timeStep, if not done by the driver's parent.
    
</LI>
</UL>
</LI>
<LI><B>label_SetRunSequence</B>
    
<UL>
<LI>Optional. By default drive child components in the sequence they were added.
</LI>
<LI>Define and set a RunSequence either by calling <SPAN style="font-family:monospace">NUOPC_DriverIngestRunSequence()</SPAN>, or by using the <SPAN style="font-family:monospace">NUOPC_DriverNewRunSequence()</SPAN> and <SPAN style="font-family:monospace">NUOPC_DriverAddRunElement()</SPAN> API.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyInitializePhaseMap</B>
    
<UL>
<LI>Optional. By default InitializePhaseMap attributes are not modified.
</LI>
<LI>Modify the InitializePhaseMap attribute on the child components as desired. This is very rarely needed.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyCplLists</B>
    
<UL>
<LI>Optional. By default CplList attributes are  not modified.
</LI>
<LI>Modify the CplList attribute on the child components as desired. This can be useful to set custom Connection Options for specific Field pairs.
    
</LI>
</UL>
</LI>
<LI><B>label_PreChildrenAdvertise</B>
    
<UL>
<LI>Optional.
</LI>
<LI>Allow driver to execute specific code before calling the Advertise phase of its children.
    
</LI>
</UL>
</LI>
<LI><B>label_PostChildrenAdvertise</B>
    
<UL>
<LI>Optional.
</LI>
<LI>Allow driver to execute specific code after calling the Advertise phase of its children.
    
</LI>
</UL>
</LI>
<LI><B>label_PreChildrenRealize</B>
    
<UL>
<LI>Optional.
</LI>
<LI>Allow driver to execute specific code before calling the Realize phase of its children.
    
</LI>
</UL>
</LI>
<LI><B>label_PostChildrenRealize</B>
    
<UL>
<LI>Optional.
</LI>
<LI>Allow driver to execute specific code after calling the Realize phase of its children.
    
</LI>
</UL>
</LI>
<LI><B>label_PreChildrenDataInitialize</B>
    
<UL>
<LI>Optional.
</LI>
<LI>Allow driver to execute specific code before calling the DataInitialize phase of its children.
    
</LI>
</UL>
</LI>
<LI><B>label_PostChildrenDataInitialize</B>
    
<UL>
<LI>Optional.
</LI>
<LI>Allow driver to execute specific code after calling the DataInitialize phase of its children.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_SetRunClock</B>
      
<UL>
<LI>Optional. By default driver clock is left unchanged if the parent component has no valid clock.
          If there is a valid parent clock, the current time is checked between it and the driver clock. An
          error is returned if the current time does not agree. Otherwise (current time does agree between
          both clocks), the driver clock stop time is adjusted to a single time step of the parent clock in
          the future. This ensures that the driver returns at the appropriate parent time step, even if that
          might change dynamically during the run.
</LI>
<LI>Modify the driver clock before executing RunSequence. This is very rarely needed.
      
</LI>
</UL>
</LI>
<LI><B>label_ExecuteRunSequence</B>
    
<UL>
<LI>Optional. By default use NUOPC generic RunSequence execution.
</LI>
<LI>Implement a custom RunSequence execution. This is very rarely needed.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<H3><A ID="SECTION00041100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_DriverAddComp - Add a GridComp child to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddGridComp(driver, compLabel, &amp;
     compSetServicesRoutine, compSetVMRoutine, petList, devList, info, config, &amp;
     hconfig, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                               :: driver
     character(len=*),    intent(in)                   :: compLabel
 #if defined (__NVCOMPILER) || defined (__PGI) || defined (ESMF_COMPILER_AOCC)
     interface
       recursive subroutine compSetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     interface
       recursive subroutine compSetVMRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     optional                                          :: compSetVMRoutine
 #else
     abstract interface
       recursive subroutine SetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
       recursive subroutine SetVMRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     procedure(SetServicesRoutine)                     :: compSetServicesRoutine
     procedure(SetVMRoutine),                 optional :: compSetVMRoutine
 #endif
     integer,             intent(in),         optional :: petList(:)
     integer,             intent(in),         optional :: devList(:)
     type(ESMF_Info),     intent(in),         optional :: info
     type(ESMF_Config),   intent(in),         optional :: config
     type(ESMF_HConfig),  intent(in),         optional :: hconfig
     type(ESMF_GridComp), intent(out),        optional :: comp
     integer,             intent(out),        optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Create and add a GridComp (i.e. Model, Mediator, or Driver) as a child
   component to a Driver. The component is created on the provided <SPAN style="font-family:monospace">petList</SPAN>,
   or by default across all of the Driver PETs.

<P>
The specified <SPAN style="font-family:monospace">compSetServicesRoutine()</SPAN> is called back immediately after
   the new child component has been created internally.
   Very little around the component is set up at that time (e.g. NUOPC component
   attributes are not yet available at this stage). The routine should therefore
   be very light weight, with the sole purpose of setting the entry points of
   the component &ndash; typically by deriving from a generic component followed by
   the appropriate specilizations.

<P>
If provided, the <SPAN style="font-family:monospace">compSetVMRoutine()</SPAN> is called back before the
   <SPAN style="font-family:monospace">compSetServicesRoutine()</SPAN>. This allows the child component to set
   aspects of its own VM, such as threading or the PE distribution among PETs.

<P>
The <SPAN style="font-family:monospace">info</SPAN> argument can be used to pass custom attributes to the child
   component. These attributes are available on the component when
   <SPAN style="font-family:monospace">compSetVMRoutine()</SPAN> and <SPAN style="font-family:monospace">compSetServicesRoutine()</SPAN> are called.
   The attributes provided in <SPAN style="font-family:monospace">info</SPAN> are <EM>copied</EM> onto the child
   component. This allows the same <SPAN style="font-family:monospace">info</SPAN> object to be used for multiple
   child components without conflict.

<P>
The <SPAN style="font-family:monospace">compLabel</SPAN> must uniquely identify the child component within the
   context of the Driver component.

<P>
If the <SPAN style="font-family:monospace">comp</SPAN> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A ID="SECTION00041200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_DriverAddComp - Add a GridComp child from shared object to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddGridCompSO(driver, compLabel, &amp;
     sharedObj, petList, devList, info, config, hconfig, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(in),  optional :: petList(:)
     integer,             intent(in),  optional :: devList(:)
     type(ESMF_Info),     intent(in),  optional :: info
     type(ESMF_Config),   intent(in),  optional :: config
     type(ESMF_HConfig),  intent(in),  optional :: hconfig
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Create and add a GridComp (i.e. Model, Mediator, or Driver) as a child
   component to a Driver. The component is created on the provided <SPAN style="font-family:monospace">petList</SPAN>,
   or by default across all of the Driver PETs.

<P>
The <SPAN style="font-family:monospace">SetVM()</SPAN> and <SPAN style="font-family:monospace">SetServices()</SPAN> routines in <SPAN style="font-family:monospace">sharedObj</SPAN>
   are called back immediately after the new child component has been created
   internally. 
   Very little around the component is set up at that time (e.g. NUOPC component
   attributes are not yet available at this stage). The routine should therefore
   be very light weight, with the sole purpose of setting the entry points of
   the component &ndash; typically by deriving from a generic component followed by
   the appropriate specilizations.

<P>
The asterisk character <SPAN style="font-family:monospace">(*)</SPAN> is supported as a wildcard for the
   file name suffix in <SPAN style="font-family:monospace">sharedObj</SPAN>. When present, the asterisk is replaced
   by "so", "dylib", and "dll", in this order, and the first successfully
   loaded object is used. If the <SPAN style="font-family:monospace">sharedObj</SPAN> argument is not provided, the
   executable itself is searched for the "<SPAN style="font-family:monospace">SetVM</SPAN>" and "<SPAN style="font-family:monospace">SetServices</SPAN>"
   symbols.

<P>
The <SPAN style="font-family:monospace">info</SPAN> argument can be used to pass custom attributes to the child
   component. These attributes are available on the component when
   <SPAN style="font-family:monospace">compSetVMRoutine()</SPAN> and <SPAN style="font-family:monospace">compSetServicesRoutine()</SPAN> are called.
   The attributes provided in <SPAN style="font-family:monospace">info</SPAN> are <EM>copied</EM> onto the child
   component. This allows the same <SPAN style="font-family:monospace">info</SPAN> object to be used for multiple
   child components without conflict.

<P>
The <SPAN style="font-family:monospace">compLabel</SPAN> must uniquely identify the child component within the
   context of the Driver component.

<P>
If the <SPAN style="font-family:monospace">comp</SPAN> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A ID="SECTION00041300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_DriverAddComp - Add a CplComp child to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddCplComp(driver, srcCompLabel, &amp;
     dstCompLabel, compSetServicesRoutine, compSetVMRoutine, petList, devList, &amp;
     info, config, hconfig, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                               :: driver
     character(len=*),    intent(in)                   :: srcCompLabel
     character(len=*),    intent(in)                   :: dstCompLabel
 #if defined (__NVCOMPILER) || defined (__PGI) || defined (ESMF_COMPILER_AOCC)
     interface
       recursive subroutine compSetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     interface
       recursive subroutine compSetVMRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     optional                                          :: compSetVMRoutine
 #else
     abstract interface
       recursive subroutine SetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
       recursive subroutine SetVMRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     procedure(SetServicesRoutine)                     :: compSetServicesRoutine
     procedure(SetVMRoutine),                 optional :: compSetVMRoutine
 #endif
     integer, target,     intent(in),         optional :: petList(:)
     integer, target,     intent(in),         optional :: devList(:)
     type(ESMF_Info),     intent(in),         optional :: info
     type(ESMF_Config),   intent(in),         optional :: config
     type(ESMF_HConfig),  intent(in),         optional :: hconfig
     type(ESMF_CplComp),  intent(out),        optional :: comp
     integer,             intent(out),        optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Create and add a CplComp (i.e. Connector) as a child component to a Driver.
   The component is created on the provided <SPAN style="font-family:monospace">petList</SPAN>, or by default across
   the union of PETs of the components indicated by <SPAN style="font-family:monospace">srcCompLabel</SPAN>
   and <SPAN style="font-family:monospace">dstCompLabel</SPAN>.

<P>
The specified <SPAN style="font-family:monospace">SetServices()</SPAN> routine is called back immediately after the
   new child component has been created internally.
   Very little around the component is set up at that time (e.g. NUOPC component
   attributes are not yet available at this stage). The routine should therefore
   be very light weight, with the sole purpose of setting the entry points of
   the component &ndash; typically by deriving from a generic component followed by
   the appropriate specilizations.

<P>
The <SPAN style="font-family:monospace">info</SPAN> argument can be used to pass custom attributes to the child
   component. These attributes are available on the component when
   <SPAN style="font-family:monospace">compSetVMRoutine()</SPAN> and <SPAN style="font-family:monospace">compSetServicesRoutine()</SPAN> are called.
   The attributes provided in <SPAN style="font-family:monospace">info</SPAN> are <EM>copied</EM> onto the child
   component. This allows the same <SPAN style="font-family:monospace">info</SPAN> object to be used for multiple
   child components without conflict.

<P>
The <SPAN style="font-family:monospace">compLabel</SPAN> must uniquely identify the child component within the
   context of the Driver component.

<P>
If the <SPAN style="font-family:monospace">comp</SPAN> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A ID="SECTION00041400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_DriverAddRunElement - Add RunElement for Model, Mediator, or Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementMPL(driver, slot, compLabel, &amp;
     phaseLabel, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     character(len=*),    intent(in)            :: compLabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: phaseLabel
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Add an element associated with a Model, Mediator, or Driver component to the
   run sequence of the Driver. The component must have been added to the Driver,
   and associated with <SPAN style="font-family:monospace">compLabel</SPAN> prior to this call.

<P>
If <SPAN style="font-family:monospace">phaseLabel</SPAN> was not specified, the first entry in the
   <SPAN style="font-family:monospace">RunPhaseMap</SPAN> attribute of the referenced component will be used to
   determine the run phase of the added element.

<P>
By default an error is returned if no component is associated with the
   specified <SPAN style="font-family:monospace">compLabel</SPAN>. This error can be suppressed by setting
   <SPAN style="font-family:monospace">relaxedflag=.true.</SPAN>, and no entry will be added to the run sequence.

<P>
The <SPAN style="font-family:monospace">slot</SPAN> number identifies the run sequence time slot in case multiple
   sequences are available. Slots start counting from 1. 

<P>

<P>

<H3><A ID="SECTION00041500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_DriverAddRunElement - Add RunElement for Connector</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementCPL(driver, slot, srcCompLabel,&amp;
     dstCompLabel, phaseLabel, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: phaseLabel
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Add an element associated with a Connector component to the
   run sequence of the Driver. The component must have been added to the Driver,
   and associated with <SPAN style="font-family:monospace">srcCompLabel</SPAN> and <SPAN style="font-family:monospace">dstCompLabel</SPAN> prior to this
   call.

<P>
If <SPAN style="font-family:monospace">phaseLabel</SPAN> was not specified, the first entry in the
   <SPAN style="font-family:monospace">RunPhaseMap</SPAN> attribute of the referenced component will be used to
   determine the run phase of the added element.

<P>
By default an error is returned if no component is associated with the
   specified <SPAN style="font-family:monospace">compLabel</SPAN>. This error can be suppressed by setting
   <SPAN style="font-family:monospace">relaxedflag=.true.</SPAN>, and no entry will be added to the run sequence.

<P>
The <SPAN style="font-family:monospace">slot</SPAN> number identifies the run sequence time slot in case multiple
   sequences are available. Slots start counting from 1. 

<P>

<P>

<H3><A ID="SECTION00041600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_DriverAddRunElement - Add RunElement that links to another slot</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementL(driver, slot, linkSlot, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     integer,             intent(in)            :: linkSlot
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Add an element to the run sequence of the Driver that links to the time slot
   indicated by <SPAN style="font-family:monospace">linkSlot</SPAN>. 

<P>

<P>

<H3><A ID="SECTION00041700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_DriverEgestRunSequence - Egest the run sequence as FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   recursive subroutine NUOPC_DriverEgestRunSequence(driver, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: driver
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Egest the run sequence stored in the driver as a FreeFormat object. It is the
   caller's responsibility to destroy the created freeFormat object. 

<P>

<P>

<H3><A ID="SECTION00041800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_DriverGet - Get info from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverGet()
   recursive subroutine NUOPC_DriverGet(driver, slotCount, parentClock, &amp;
     importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(out), optional :: slotCount
     type(ESMF_Clock),    intent(out), optional :: parentClock
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access Driver information. 

<P>

<P>

<H3><A ID="SECTION00041900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_DriverGetComp - Get a GridComp child from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetGridComp(driver, compLabel, comp, petList, &amp;
     importState, exportState, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             pointer,     optional :: petList(:)
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Query the Driver for a GridComp (i.e. Model, Mediator, or Driver) child
   component that was added under <SPAN style="font-family:monospace">compLabel</SPAN>.

<P>
If provided, the <SPAN style="font-family:monospace">petList</SPAN> argument will be associated with the petList
   that was used to create the referenced component. This is an internal
   allocation owned by the library. This pointer must <B>not</B> be deallocated
   by the user!

<P>
By default an error is returned if no component is associated with the
   specified <SPAN style="font-family:monospace">compLabel</SPAN>. This error can be suppressed by setting
   <SPAN style="font-family:monospace">relaxedflag=.true.</SPAN>, and unassociated arguments will be returned. 

<P>

<P>

<H3><A ID="SECTION000411000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_DriverGetComp - Get a CplComp child from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetCplComp(driver, srcCompLabel, &amp;
     dstCompLabel, comp, petList, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
     type(ESMF_CplComp),  intent(out), optional :: comp
     integer,             pointer    , optional :: petList(:)
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Query the Driver for a CplComp (i.e. Connector) child
   component that was added under <SPAN style="font-family:monospace">compLabel</SPAN>.

<P>
If provided, the <SPAN style="font-family:monospace">petList</SPAN> argument will be associated with the petList
   that was used to create the referenced component. This is an internal
   allocation owned by the library. This pointer must <B>not</B> be deallocated
   by the user!

<P>
By default an error is returned if no component is associated with the
   specified <SPAN style="font-family:monospace">compLabel</SPAN>. This error can be suppressed by setting
   <SPAN style="font-family:monospace">relaxedflag=.true.</SPAN>, and unassociated arguments will be returned. 

<P>

<P>

<H3><A ID="SECTION000411100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_DriverGetComp - Get all the GridComp child components from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetAllGridComp(driver, compList, petLists, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     type(ESMF_GridComp), pointer, optional     :: compList(:)
     type(ESMF_PtrInt1D), pointer, optional     :: petLists(:)
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Get all the GridComp (i.e. Model, Mediator, or Driver) child components from a
   Driver.

<P>
The incoming <SPAN style="font-family:monospace">compList</SPAN> and <SPAN style="font-family:monospace">petLists</SPAN> arguments must enter
   unassociated. This means that the user code must explicitly call
   <SPAN style="font-family:monospace">nullify()</SPAN> or use the <SPAN style="font-family:monospace">=&gt; null()</SPAN> syntax on the variables passed in
   as the actual arguments.

<P>
On return it becomes the responsibility of the caller to deallocate
   associated <SPAN style="font-family:monospace">compList</SPAN> and <SPAN style="font-family:monospace">petLists</SPAN> arguments:
   <PRE>
     if (associated(compList)) deallocate(compList)
     if (associated(petLists)) deallocate(petLists)
</PRE>

<P>
Notice that the <SPAN style="font-family:monospace">petLists(i)%ptr</SPAN> members, if associated, are pointing to
   an internal allocation owned by the library. These pointers must <B>not</B> be
   deallocated by the user! 

<P>

<P>

<H3><A ID="SECTION000411200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_DriverGetComp - Get all the CplComp child components from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetAllCplComp(driver, compList, petLists, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     type(ESMF_CplComp),  pointer               :: compList(:)
     type(ESMF_PtrInt1D), pointer, optional     :: petLists(:)
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Get all the CplComp (i.e. Connector) child components from a Driver.

<P>
The incoming <SPAN style="font-family:monospace">compList</SPAN> and <SPAN style="font-family:monospace">petLists</SPAN> arguments must enter
   unassociated. This means that the user code must explicitly call
   <SPAN style="font-family:monospace">nullify()</SPAN> or use the <SPAN style="font-family:monospace">=&gt; null()</SPAN> syntax on the variables passed in
   as the actual arguments.

<P>
On return it becomes the responsibility of the caller to deallocate
   associated <SPAN style="font-family:monospace">compList</SPAN> and <SPAN style="font-family:monospace">petLists</SPAN> arguments:
   <PRE>
     if (associated(compList)) deallocate(compList)
     if (associated(petLists)) deallocate(petLists)
</PRE>

<P>
Notice that the <SPAN style="font-family:monospace">petLists(i)%ptr</SPAN> members, if associated, are pointing to
   an internal allocation owned by the library. These pointers must <B>not</B> be
   deallocated by the user! 

<P>

<P>

<H3><A ID="SECTION000411300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_DriverIngestRunSequence - Ingest the run sequence from FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverIngestRunSequence()
   recursive subroutine NUOPC_DriverIngestRunSequenceFF(driver, freeFormat, &amp;
     autoAddConnectors, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: driver
     type(NUOPC_FreeFormat), intent(in),  target   :: freeFormat
     logical,                intent(in),  optional :: autoAddConnectors
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Ingest the run sequence from a FreeFormat object and replace the
   run sequence currently held by the driver. Every line in
   <SPAN style="font-family:monospace">freeFormat</SPAN> corresponds to either a component run sequence element, or
   is part of a time loop or alarm block defintion. Anything following a
   '#' character on a line is considered a comment, and ignored for the purpose
   of ingesting run sequence elements.

<P>
<B>Component run sequence elements</B> define the run method of a single
   component. The lines are interpreted sequentially, however, components
   will execute concurrently as long as this is not prevented by
   data-dependencies or overlapping petLists.

<P>
Each line specifies the precise run method phase for a single component
   instance. For model, mediator, and driver components the format is this:

<P>
<PRE>
     compLabel [phaseLabel]
</PRE>
   Here <SPAN style="font-family:monospace">compLabel</SPAN> is the label by which the component instance is known to
   the driver. It is optionally followed a <SPAN style="font-family:monospace">phaseLabel</SPAN> identifying a
   specific run phase. An example of calling the run phase of the ATM instance
   that contains the "fast" processes, and is labeled <SPAN style="font-family:monospace">fast</SPAN>:

<P>
<PRE>
     ATM fast
</PRE>
   By default, i.e. without <SPAN style="font-family:monospace">phaseLabel</SPAN>, the first
   registered run method of the component is used.

<P>
The format for connector components is different. It looks like this:

<P>
<PRE>
     srcCompLabel -&gt; dstCompLabel [connectionOptions]
</PRE>
   A connector instance is uniquely known by the two components it connects,
   i.e. by <SPAN style="font-family:monospace">srcCompLabel</SPAN> and <SPAN style="font-family:monospace">dstCompLabel</SPAN>. The syntax requires that
   the token <SPAN style="font-family:monospace">-&gt;</SPAN> be specified between source and destination. Optionally
   <SPAN style="font-family:monospace">connectionOptions</SPAN> can be supplied using the format discussed
   under section <A HREF="node3.html#connection_options">2.4.5</A>. The connection options are set
   as attribute <SPAN style="font-family:monospace">ConnectionOptions</SPAN> on the respective connector component.

<P>
An example of executing the connector
   instance that transfers fields from the ATM component to the OCN component,
   using redistribution for remapping:

<P>
<PRE>
     ATM -&gt; OCN :remapMethod=redist
</PRE>

<P>
By default <SPAN style="font-family:monospace">autoAddConnectors</SPAN> is <SPAN style="font-family:monospace">.false.</SPAN>, which means that all
   components referenced in the <SPAN style="font-family:monospace">freeFormat</SPAN> run sequence, including
   connectors, must already be available as child components of the <SPAN style="font-family:monospace">driver</SPAN>
   component. An error will be returned if this is not the case.
   However, when <SPAN style="font-family:monospace">autoAddConnectors</SPAN> is set to <SPAN style="font-family:monospace">.true.</SPAN>, connector
   components encountered in the run sequence that are no already present in
   the <SPAN style="font-family:monospace">driver</SPAN> will be added automatically. The default
   <SPAN style="font-family:monospace">NUOPC_Connector</SPAN> implementation is used for all automatically added
   connector instances.

<P>
Lines that contain a <B>time loop</B> definition have the general format:

<P>
<PRE>
     @{timeStep|*}[:runDuration]
       ...
       ...
     @
</PRE>
   Both <SPAN style="font-family:monospace">timeStep</SPAN> and <SPAN style="font-family:monospace">runDuration</SPAN> are numbers in units of seconds.
   Time loops can be nested and concatenated.

<P>
A wildcard "*" character can be specified in place of an actual <SPAN style="font-family:monospace">timeStep</SPAN>
   number. In this case the <SPAN style="font-family:monospace">timeStep</SPAN> of the associated run clock object
   is set to be equal to the <SPAN style="font-family:monospace">timeStep</SPAN> of the time loop one level up in the
   loop nesting hierarchy.
   If a wildcard time step is used for a single outer time loop in the run
   sequence, then the associated run clock is identical to the driver clock and
   must be set explicitly by the driver code, or its parent component.

<P>
The <SPAN style="font-family:monospace">runDuration</SPAN> specification is optional. If omitted, the duration of
   the associated run clock is set to the <SPAN style="font-family:monospace">timeStep</SPAN> of the time loop one
   level up in the loop nesting hierarchy. This ensures that for a single
   nested time loop, the loop returns to the parent loop level at the appropriate
   time.

<P>
A simple example of a single time loop with one hour timestep:

<P>
<PRE>
     @3600
       ...
       ...
     @
</PRE>
   Each time loop has its own associated clock object. NUOPC manages these clock
   objects, i.e. their creation and destruction, as well as <SPAN style="font-family:monospace">startTime</SPAN>,
   <SPAN style="font-family:monospace">endTime</SPAN>, <SPAN style="font-family:monospace">timeStep</SPAN> adjustments during the execution. The outer
   most time loop of the run sequence is a special case. It uses the driver
   clock itself. If a single outer most loop is defined in the run sequence
   provided by <SPAN style="font-family:monospace">freeFormat</SPAN>, this loop becomes the driver loop level
   directly. Therefore, setting the <SPAN style="font-family:monospace">timeStep</SPAN> or <SPAN style="font-family:monospace">runDuration</SPAN> for
   the outer most time loop results modifiying the driver clock itself.
   However, for cases with concatenated loops on the upper level of
   the run sequence in <SPAN style="font-family:monospace">freeFormat</SPAN>, a single outer loop is added
   automatically during ingestion, and the driver clock is used for this loop
   instead.

<P>
A more complex run sequence example, that shows component run
   sequence elements outside of time loops, a nested time loop, time step
   wildcards, explicit duration specifications, and concatenated time loops:

<P>
<PRE>
     @100:800
       ATM -&gt; OCN
       OCN -&gt; ATM
       ATM
       OCN
       @*
         OCN -&gt; EXTOCN
         EXTOCN
       @
     @
     ATM -&gt; EXTATM
     EXTATM
     @100:1000
       ATM -&gt; OCN
       OCN -&gt; ATM
       ATM
       OCN
     @
</PRE>
   Here the <SPAN style="font-family:monospace">timeStep</SPAN> of the first time loop is explicitly chosen at
   <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img4.svg"
 ALT="$100s$"></SPAN>. The <SPAN style="font-family:monospace">runDuration</SPAN> is explicitly set to <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img5.svg"
 ALT="$800s$"></SPAN>. The first time
   loop steps the current time forward for <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img5.svg"
 ALT="$800s$"></SPAN>, for each iteration executing
   ATM-OCN coupling, followed by the nested loop that calls the
   <SPAN style="font-family:monospace">OCN -&gt; EXTOCN</SPAN> and <SPAN style="font-family:monospace">EXTOCN</SPAN> components. The nested loop uses a
    wildcard <SPAN style="font-family:monospace">timeStep</SPAN> and therefore is
   identical to the parent loop level <SPAN style="font-family:monospace">timeStep</SPAN> of <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img4.svg"
 ALT="$100s$"></SPAN>. The nested
   <SPAN style="font-family:monospace">runDuration</SPAN> is not specified and therefore also defaults to the parent
   time step of <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img4.svg"
 ALT="$100s$"></SPAN>. In other words, the nested loop is executed exactly once
   for every parent loop iteration.

<P>
After <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img5.svg"
 ALT="$800s$"></SPAN> the first time loop is exited, and followed by explicit calls to
   <SPAN style="font-family:monospace">ATM -&gt; EXTAMT</SPAN> and <SPAN style="font-family:monospace">EXTATM</SPAN> components. Finally the second time loop
   is entered for another <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img6.svg"
 ALT="$1000s$"></SPAN> <SPAN style="font-family:monospace">runDuration</SPAN>. The <SPAN style="font-family:monospace">timeStep</SPAN> is again
   explicitly set to <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img4.svg"
 ALT="$100s$"></SPAN>. The second time loop only implements ATM-OCN
   coupling, and no coupling to EXTOCN is implemented. Finally, after <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.65ex; vertical-align: -0.11ex; " SRC="img7.svg"
 ALT="$1800s$"></SPAN>
   the sequence returns to the driver level loop.

<P>
Lines that contain an <B>alarm block</B> definition have the general format:

<P>
<PRE>
     @@{alarmTime|*}
       ...
       ...
     @@
</PRE>
   The <SPAN style="font-family:monospace">alarmTime</SPAN> is a number in units of seconds, and indicates at which
   interval the alarm will ring. The first ring time of an alarm is the current
   time of the parent clock.

<P>
Specification of the wildcard character <SPAN style="font-family:monospace">*</SPAN> sets the alarmTime equal to
   the timeStep of the parentClock.

<P>
When an alarm rings, the entire alarm block is executed once.

<P>
Nesting of time loops and alarm blocks is supported.

<P>

<P>

<H3><A ID="SECTION000411400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_DriverIngestRunSequence - Ingest the run sequence from HConfig</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverIngestRunSequence()
   recursive subroutine NUOPC_DriverIngestRunSequenceHC(driver, hconfig, &amp;
     autoAddConnectors, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: driver
     type(ESMF_HConfig),     intent(in)            :: hconfig
     logical,                intent(in),  optional :: autoAddConnectors
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Ingest the run sequence from a HConfig object and replace the run sequence
   currently held by the driver. The provided <SPAN style="font-family:monospace">hconfig</SPAN> must be a scalar,
   or else an error is returned. The scalar is interpreted as a string, broken
   into lines at the <EM>newline</EM> character. Each line is subsequently
   interpreted according to the rules described under the FreeFormat version of
   the <SPAN style="font-family:monospace">NUOPC_DriverIngestRunSequence()</SPAN> interface.

<P>
To preserve <EM>newline</EM> characters in run sequences expressed in YAML
   <EM>block</EM> notation, it is important to use <EM>literals</EM> indicated by the
   '|' character in YAML. For example:

<P>
<PRE>
   # A simple run sequence example as a YAML block literal
   --- |
    @900:1800          # comments are ignored
      MED
      MED -&gt; ATM       # any line can have a comment
      MED -&gt; OCN
      ATM
      OCN
      ATM -&gt; MED
      OCN -&gt; MED
    @
</PRE>

<P>
Notice the leading <EM>whitespace</EM> character(s) on each line of the block
   literal string. YAML requires at least one (1) leading <EM>whitespace</EM>
   character for strings in block notation. 

<P>

<P>

<H3><A ID="SECTION000411500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_DriverNewRunSequence - Replace the run sequence in a Driver</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   recursive subroutine NUOPC_DriverNewRunSequence(driver, slotCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slotCount
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Replace the current run sequence of the Driver with a new one that has
   <SPAN style="font-family:monospace">slotCount</SPAN> slots. Each slot uses its own clock for time keeping. 

<P>

<P>

<H3><A ID="SECTION000411600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_DriverPrint - Print internal Driver information</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   recursive subroutine NUOPC_DriverPrint(driver, orderflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     logical,             intent(in),  optional :: orderflag
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Print internal Driver information. If <SPAN style="font-family:monospace">orderflag</SPAN> is provided and set
   to <SPAN style="font-family:monospace">.true.</SPAN>, the output is ordered from lowest to highest PET. Setting
   this flag makes the method collective. 

<P>

<P>

<H3><A ID="SECTION000411700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_DriverSetRunSequence - Set internals of RunSequence slot</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_DriverSetRunSequence()
   recursive subroutine NUOPC_DriverSetRunSequence(driver, slot, clock, alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     type(ESMF_Clock),    intent(in)            :: clock
     type(ESMF_Alarm),    intent(in),  optional :: alarm
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the <SPAN style="font-family:monospace">clock</SPAN> in the run sequence under <SPAN style="font-family:monospace">slot</SPAN> of the Driver.

<H2><A ID="SECTION00042000000000000000"></A>
<A ID="NUOPC_ModelBase"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Generic Component: NUOPC_ModelBase
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">MODULE:</SPAN>
<PRE>  module NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Partial specialization of a component with a default <EM>explicit</EM> time dependency. Each time the <SPAN style="font-family:monospace">Run</SPAN> method is called the component steps one timeStep forward on the passed in parent
clock. The component flags incompatibility during <SPAN style="font-family:monospace">Run</SPAN> if the current time of the incoming
clock does not match the current time of the internal clock.

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SUPER:</SPAN>
<PRE>  ESMF_GridComp
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">USE DEPENDENCIES:</SPAN>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SETSERVICES:</SPAN>
<PRE>  subroutine SetServices(modelBase, rc)
    type(ESMF_GridComp)   :: modelBase
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SEMANTIC SPECIALIZATION LABELS:</SPAN>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_Advertise</B>
    
<UL>
<LI>Required in order to advertise fields.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Advertise()</SPAN> to advertise specific fields in the Import- and ExportState of the component.
</LI>
<LI>Alternatively set the FieldTransferPolicy attribute on the Import- and ExportState of the component to request field mirroring.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyAdvertised</B>
    
<UL>
<LI>Optional. By default do not modify the advertised fields.
</LI>
<LI>Mostly used when field mirroring was requested during Advertise.
</LI>
<LI>Remove undesired advertised fields in the Import- and ExportState of the component.
</LI>
<LI>Adjust attributes e.g. for TransferOffer on advertised fields.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeProvided</B>
    
<UL>
<LI>Required in order to realize fields.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Realize()</SPAN> to realize fields previously advertised, and for which this component is responsible for providing the Field allocation and/or the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_AcceptTransfer</B>
    
<UL>
<LI>Optional. By default accept the Distribution of the transferred GeomObjects.
</LI>
<LI>Change the distribution of any of the transferred GeomObjects.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeAccepted</B>
    
<UL>
<LI>Optional. Needed for any fields for which component is accepting the GeomObject.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Realize()</SPAN> to realize fields previously advertised, and for which this component is accepting the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_SetClock</B>
    
<UL>
<LI>Optional. By default create clock according to time information provided by driver.
</LI>
<LI>Adjust and set the component clock.
    
</LI>
</UL>
</LI>
<LI><B>label_DataInitialize</B>
    
<UL>
<LI>Optional. Needed to initialize data, and to participate in resolution of data dependencies between components during initialize.
</LI>
<LI>Initialize data in fields.
</LI>
<LI>Set NUOPC attributes used for data dependency resolution.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_Advance</B>
    
<UL>
<LI>Called every timeStep on the component internal clock.
</LI>
<LI>Implement the forward integration of the model.
</LI>
<LI>Ensure data in the export fields is updated before returning.
    
</LI>
</UL>
</LI>
<LI><B>label_AdvanceClock</B>
    
<UL>
<LI>Optional. By default the component internal clock is advanced by one internal timeStep at the end of the Advance step.
    
</LI>
</UL>
</LI>
<LI><B>label_CheckImport</B>
    
<UL>
<LI>Optional. By default check the timestamp of all import fields against the current time of the internal clock.
    
</LI>
</UL>
</LI>
<LI><B>label_SetRunClock</B>
    
<UL>
<LI>Optional. By default do not adjust the internal clock when entering Run.
    
</LI>
</UL>
</LI>
<LI><B>label_TimestampExport</B>
    
<UL>
<LI>Optinal. By default timestamp all export fields according to the current time of the component internal clock before returning.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<H2><A ID="SECTION00043000000000000000"></A>
<A ID="NUOPC_Model"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Generic Component: NUOPC_Model
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">MODULE:</SPAN>
<PRE>  module NUOPC_Model
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Model component with a default <EM>explicit</EM> time dependency. Each time the <SPAN style="font-family:monospace">Run</SPAN> method is called the model integrates one timeStep forward on the passed in parent clock. The internal clock is advanced at the end of each <SPAN style="font-family:monospace">Run</SPAN> call. The component flags incompatibility during <SPAN style="font-family:monospace">Run</SPAN> if the current time of the incoming clock does not match the current time of the internal clock.

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SUPER:</SPAN>
<PRE>  NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">USE DEPENDENCIES:</SPAN>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SETSERVICES:</SPAN>
<PRE>  subroutine SetServices(model, rc)
    type(ESMF_GridComp)   :: model
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SEMANTIC SPECIALIZATION LABELS:</SPAN>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_Advertise</B>
    
<UL>
<LI>Required in order to advertise fields.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Advertise()</SPAN> to advertise specific fields in the Import- and ExportState of the component.
</LI>
<LI>Alternatively set the FieldTransferPolicy attribute on the Import- and ExportState of the component to request field mirroring.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyAdvertised</B>
    
<UL>
<LI>Optional. By default do not modify the advertised fields.
</LI>
<LI>Mostly used when field mirroring was requested during Advertise.
</LI>
<LI>Remove undesired advertised fields in the Import- and ExportState of the component.
</LI>
<LI>Adjust attributes e.g. for TransferOffer on advertised fields.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeProvided</B>
    
<UL>
<LI>Required in order to realize fields.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Realize()</SPAN> to realize fields previously advertised, and for which this component is responsible for providing the Field allocation and/or the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_AcceptTransfer</B>
    
<UL>
<LI>Optional. By default accept the Distribution of the transferred GeomObjects.
</LI>
<LI>Change the distribution of any of the transferred GeomObjects.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeAccepted</B>
    
<UL>
<LI>Optional. Needed for any fields for which component is accepting the GeomObject.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Realize()</SPAN> to realize fields previously advertised, and for which this component is accepting the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_SetClock</B>
    
<UL>
<LI>Optional. By default create clock according to time information provided by driver.
</LI>
<LI>Adjust and set the component clock.
    
</LI>
</UL>
</LI>
<LI><B>label_DataInitialize</B>
    
<UL>
<LI>Optional. Needed to initialize data, and to participate in resolution of data dependencies between components during initialize.
</LI>
<LI>Initialize data in fields.
</LI>
<LI>Set NUOPC attributes used for data dependency resolution.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_Advance</B>
    
<UL>
<LI>Called every timeStep on the component internal clock.
</LI>
<LI>Implement the forward integration of the model.
</LI>
<LI>Ensure data in the export fields is updated before returning.
    
</LI>
</UL>
</LI>
<LI><B>label_AdvanceClock</B>
    
<UL>
<LI>Optional. By default the component internal clock is advanced by one internal timeStep at the end of the Advance step.
    
</LI>
</UL>
</LI>
<LI><B>label_CheckImport</B>
    
<UL>
<LI>Optional. By default check the timestamp of all import fields against the current time of the internal clock.
    
</LI>
</UL>
</LI>
<LI><B>label_SetRunClock</B>
    
<UL>
<LI>Optional. By default do not adjust the internal clock when entering Run.
    
</LI>
</UL>
</LI>
<LI><B>label_TimestampExport</B>
    
<UL>
<LI>Optinal. By default timestamp all export fields according to the current time of the component internal clock before returning.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<H3><A ID="SECTION00043100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_ModelGet - Get info from a Model</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_ModelGet(model, driverClock, modelClock, &amp;
     importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: model
     type(ESMF_Clock),    intent(out), optional :: driverClock
     type(ESMF_Clock),    intent(out), optional :: modelClock
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access Model information.

<H2><A ID="SECTION00044000000000000000"></A>
<A ID="NUOPC_Mediator"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Generic Component: NUOPC_Mediator
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">MODULE:</SPAN>
<PRE>  module NUOPC_Mediator
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Mediator component with a default <EM>explicit</EM> time dependency. Each time the <SPAN style="font-family:monospace">Run</SPAN> method is called, the time stamp on the imported Fields must match the current time (on both the incoming and internal clock). Before returning, the Mediator time stamps the exported Fields with the same current time, before advancing the internal clock one timeStep forward.

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SUPER:</SPAN>
<PRE>  NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">USE DEPENDENCIES:</SPAN>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SETSERVICES:</SPAN>
<PRE>  subroutine SetServices(mediator, rc)
    type(ESMF_GridComp)   :: mediator
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SEMANTIC SPECIALIZATION LABELS:</SPAN>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_Advertise</B>
    
<UL>
<LI>Required in order to advertise fields.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Advertise()</SPAN> to advertise specific fields in the Import- and ExportState of the component.
</LI>
<LI>Alternatively set the FieldTransferPolicy attribute on the Import- and ExportState of the component to request field mirroring.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyAdvertised</B>
    
<UL>
<LI>Optional. By default do not modify the advertised fields.
</LI>
<LI>Mostly used when field mirroring was requested during Advertise.
</LI>
<LI>Remove undesired advertised fields in the Import- and ExportState of the component.
</LI>
<LI>Adjust attributes e.g. for TransferOffer on advertised fields.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeProvided</B>
    
<UL>
<LI>Required in order to realize fields.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Realize()</SPAN> to realize fields previously advertised, and for which this component is responsible for providing the Field allocation and/or the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_AcceptTransfer</B>
    
<UL>
<LI>Optional. By default accept the Distribution of the transferred GeomObjects.
</LI>
<LI>Change the distribution of any of the transferred GeomObjects.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeAccepted</B>
    
<UL>
<LI>Optional. Needed for any fields for which component is accepting the GeomObject.
</LI>
<LI>Use <SPAN style="font-family:monospace">NUOPC_Realize()</SPAN> to realize fields previously advertised, and for which this component is accepting the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_SetClock</B>
    
<UL>
<LI>Optional. By default create clock according to time information provided by driver.
</LI>
<LI>Adjust and set the component clock.
    
</LI>
</UL>
</LI>
<LI><B>label_DataInitialize</B>
    
<UL>
<LI>Optional. Needed to initialize data, and to participate in resolution of data dependencies between components during initialize.
</LI>
<LI>Initialize data in fields.
</LI>
<LI>Set NUOPC attributes used for data dependency resolution.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_Advance</B>
    
<UL>
<LI>Called every timeStep on the component internal clock.
</LI>
<LI>Implement the forward integration of the model.
</LI>
<LI>Ensure data in the export fields is updated before returning.
    
</LI>
</UL>
</LI>
<LI><B>label_AdvanceClock</B>
    
<UL>
<LI>Optional. By default the component internal clock is advanced by one internal timeStep at the end of the Advance step.
    
</LI>
</UL>
</LI>
<LI><B>label_CheckImport</B>
    
<UL>
<LI>Optional. By default check the timestamp of all import fields against the current time of the internal clock.
    
</LI>
</UL>
</LI>
<LI><B>label_SetRunClock</B>
    
<UL>
<LI>Optional. By default do not adjust the internal clock when entering Run.
    
</LI>
</UL>
</LI>
<LI><B>label_TimestampExport</B>
    
<UL>
<LI>Optinal. By default timestamp all export fields according to the current time of the component internal clock before returning.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<H3><A ID="SECTION00044100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_MediatorGet - Get info from a Mediator</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_MediatorGet(mediator, driverClock, mediatorClock, &amp;
     importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: mediator
     type(ESMF_Clock),    intent(out), optional :: driverClock
     type(ESMF_Clock),    intent(out), optional :: mediatorClock
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access Mediator information.

<H2><A ID="SECTION00045000000000000000"></A>
<A ID="NUOPC_Connector"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Generic Component: NUOPC_Connector
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">MODULE:</SPAN>
<PRE>  module NUOPC_Connector
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Component that makes a unidirectional connection between model, mediator, and or driver components. During initialization field pairing is performed between the import and export side according to section <A HREF="node3.html#FieldPairing">2.4.2</A>, and paired fields are connected. By default the bilinear regrid method is used during <SPAN style="font-family:monospace">Run</SPAN> to transfer data from the connected import Fields to the connected export Fields.

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SUPER:</SPAN>
<PRE>  ESMF_CplComp
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">USE DEPENDENCIES:</SPAN>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SETSERVICES:</SPAN>
<PRE>  subroutine SetServices(connector, rc)
    type(ESMF_CplComp)    :: connector
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">SEMANTIC SPECIALIZATION LABELS:</SPAN>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_ComputeRouteHandle</B>
    
<UL>
<LI>Optional. By default compute routehandles according to CplList attribute.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_ExecuteRouteHandle</B>
    
<UL>
<LI>Optional. By default execute routehandles stored in the Connector.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_ReleaseRouteHandle</B>
    
<UL>
<LI>Optional. By default release routehandles stored in the Connector.
    
</LI>
</UL>
</LI>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<H3><A ID="SECTION00045100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_ConnectorGet - Get parameters from a Connector</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_ConnectorGet(connector, srcFields, dstFields, rh, state, &amp;
     CplSet, cplSetList, srcVM, dstVM, driverClock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: connector
     type(ESMF_FieldBundle), intent(out), optional :: srcFields
     type(ESMF_FieldBundle), intent(out), optional :: dstFields
     type(ESMF_RouteHandle), intent(out), optional :: rh
     type(ESMF_State),       intent(out), optional :: state
     character(*),           intent(in),  optional :: CplSet
     character(ESMF_MAXSTR), pointer,     optional :: cplSetList(:)
     type(ESMF_VM),          intent(out), optional :: srcVM
     type(ESMF_VM),          intent(out), optional :: dstVM
     type(ESMF_Clock),       intent(out), optional :: driverClock
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Get parameters from the <SPAN style="font-family:monospace">connector</SPAN> internal state.

<P>
The Connector keeps information about the connection that it implements 
     in its internal state. When customizing a Connector, it is often necessary
     to access and sometimes modify these data objects.

<P>
The arguments are:
     <DL>
<DT><STRONG>connector</STRONG></DT>
<DD>The Connector component.
     
</DD>
<DT><STRONG>[srcFields]</STRONG></DT>
<DD>The FieldBundle under which the Connector keeps track of all connected
       source side fields. The order in which the fields are stored
       in <SPAN style="font-family:monospace">srcFields</SPAN> is significant, as it corresponds to the order of
       fields in <SPAN style="font-family:monospace">dstFields</SPAN>. Consequently, when accessing and modifying
       the fields inside of <SPAN style="font-family:monospace">srcFields</SPAN>, it is important to use the
       <SPAN style="font-family:monospace">itemorderflag=ESMF_ITEMORDER_ADDORDER</SPAN> option to
       <SPAN style="font-family:monospace">ESMF_FieldBundleGet()</SPAN>.
     
</DD>
<DT><STRONG>[dstFields]</STRONG></DT>
<DD>The FieldBundle under which the Connector keeps track of all connected
       destination side fields. The order in which the fields are stored
       in <SPAN style="font-family:monospace">dstFields</SPAN> is significant, as it corresponds to the order of
       fields in <SPAN style="font-family:monospace">srcFields</SPAN>. Consequently, when accessing and modifying
       the fields inside of <SPAN style="font-family:monospace">dstFields</SPAN>, it is important to use the
       <SPAN style="font-family:monospace">itemorderflag=ESMF_ITEMORDER_ADDORDER</SPAN> option to
       <SPAN style="font-family:monospace">ESMF_FieldBundleGet()</SPAN>.
     
</DD>
<DT><STRONG>[rh]</STRONG></DT>
<DD>The RouteHandle that the Connector uses to move data from <SPAN style="font-family:monospace">srcFields</SPAN>
       to <SPAN style="font-family:monospace">dstFields</SPAN>.
     
</DD>
<DT><STRONG>[state]</STRONG></DT>
<DD>A State object that the Connector keeps to make customization of the 
       Connector more convenient. The generic Connector code handles creation
       and destruction of <SPAN style="font-family:monospace">state</SPAN>, but does <EM>not</EM> access it directly 
       for information.
     
</DD>
<DT><STRONG>[CplSet]</STRONG></DT>
<DD>If present, all of the returned information is specific to the specified
       coupling set.
     
</DD>
<DT><STRONG>[cplSetList]</STRONG></DT>
<DD>The list of coupling sets currently known to the Connector. This argument
       must enter the call <EM>unassociated</EM> or an error is returned. This means
       that the user code must explicitly call <SPAN style="font-family:monospace">nullify()</SPAN> or use the
       <SPAN style="font-family:monospace">=&gt; null()</SPAN> syntax on the variable passed in as <SPAN style="font-family:monospace">cplSetList</SPAN>
       argument. On return, the <SPAN style="font-family:monospace">cplSetList</SPAN> argument will be associated, 
       potentially of size zero. The responsibility for deallocation transfers
       to the caller.
     
</DD>
<DT><STRONG>[srcVM]</STRONG></DT>
<DD>The VM of the source side component.
     
</DD>
<DT><STRONG>[dstVM]</STRONG></DT>
<DD>The VM of the destination side component.
     
</DD>
<DT><STRONG>[driverClock]</STRONG></DT>
<DD>The Clock object used by the current RunSequence level to drive this
       component.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00045200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_ConnectorSet - Set parameters in a Connector</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_ConnectorSet(connector, srcFields, dstFields, rh, state, &amp;
     CplSet, srcVM, dstVM, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: connector
     type(ESMF_FieldBundle), intent(in),  optional :: srcFields
     type(ESMF_FieldBundle), intent(in),  optional :: dstFields
     type(ESMF_RouteHandle), intent(in),  optional :: rh
     type(ESMF_State),       intent(in),  optional :: state
     character(*),           intent(in),  optional :: CplSet
     type(ESMF_VM),          intent(in),  optional :: srcVM
     type(ESMF_VM),          intent(in),  optional :: dstVM
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set parameters in the <SPAN style="font-family:monospace">connector</SPAN> internal state.

<P>
The Connector keeps information about the connection that it implements 
     in its internal state. When customizing a Connector, it is often necessary
     to access and sometimes modify these data objects.

<P>
The arguments are:
     <DL>
<DT><STRONG>connector</STRONG></DT>
<DD>The Connector component.
     
</DD>
<DT><STRONG>[srcFields]</STRONG></DT>
<DD>The FieldBundle under which the Connector keeps track of all connected
       source side fields. The order in which the fields are stored
       in <SPAN style="font-family:monospace">srcFields</SPAN> is significant, as it corresponds to the order of
       fields in <SPAN style="font-family:monospace">dstFields</SPAN>. Consequently, when setting <SPAN style="font-family:monospace">srcFields</SPAN>, it
       is important to add them in the same order as for <SPAN style="font-family:monospace">dstFields</SPAN>.
     
</DD>
<DT><STRONG>[dstFields]</STRONG></DT>
<DD>The FieldBundle under which the Connector keeps track of all connected
       destination side fields. The order in which the fields are stored
       in <SPAN style="font-family:monospace">dstFields</SPAN> is significant, as it corresponds to the order of
       fields in <SPAN style="font-family:monospace">srcFields</SPAN>. Consequently, when setting <SPAN style="font-family:monospace">dstFields</SPAN>, it
       is important to add them in the same order as for <SPAN style="font-family:monospace">srcFields</SPAN>.
     
</DD>
<DT><STRONG>[rh]</STRONG></DT>
<DD>The RouteHandle that the Connector uses to move data from <SPAN style="font-family:monospace">srcFields</SPAN>
       to <SPAN style="font-family:monospace">dstFields</SPAN>.
     
</DD>
<DT><STRONG>[state]</STRONG></DT>
<DD>A State object that the Connector keeps to make customization of the 
       Connector more convenient. Only in very rare cases would the user want
       to replace the <SPAN style="font-family:monospace">state</SPAN> that is managed by the generic Connector
       implementation. If <SPAN style="font-family:monospace">state</SPAN> is set by this call, the user essentially
       claims ownership of the previous <SPAN style="font-family:monospace">state</SPAN> object, and becomes 
       responsible for its destruction. Ownership of the new <SPAN style="font-family:monospace">state</SPAN> is 
       transferred to the Connector and must not be explicitly destroyed by the
       user code.
     
</DD>
<DT><STRONG>[CplSet]</STRONG></DT>
<DD>If present, all of the passed in information is set under the specified
       coupling set.
     
</DD>
<DT><STRONG>[srcVM]</STRONG></DT>
<DD>The VM of the source side component.
     
</DD>
<DT><STRONG>[dstVM]</STRONG></DT>
<DD>The VM of the destination side component.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<H2><A ID="SECTION00046000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> General Generic Component Methods</A>
</H2>

<P>

<P>

<P>

<H3><A ID="SECTION00046100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_CompAreServicesSet - Check if SetServices was called</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAreServicesSet() 
   function NUOPC_GridCompAreServicesSet(comp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_GridCompAreServicesSet
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if SetServices has been called for <SPAN style="font-family:monospace">comp</SPAN>. 
     Otherwise return <SPAN style="font-family:monospace">.false.</SPAN>. 

<P>

<P>

<H3><A ID="SECTION00046200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_CompAreServicesSet - Check if SetServices was called</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAreServicesSet() 
   function NUOPC_CplCompAreServicesSet(comp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_CplCompAreServicesSet
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: comp
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if SetServices has been called for <SPAN style="font-family:monospace">comp</SPAN>.
     Otherwise return <SPAN style="font-family:monospace">.false.</SPAN>. 

<P>

<P>

<H3><A ID="SECTION00046300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_CompAttributeAdd - Add NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeAdd() 
   subroutine NUOPC_GridCompAttributeAdd(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Add Attributes to the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION00046400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_CompAttributeAdd - Add NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeAdd() 
   subroutine NUOPC_CplCompAttributeAdd(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Add Attributes to the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION00046500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_CompAttributeEgest - Egest NUOPC GridComp Attributes in FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeEgest() 
   subroutine NUOPC_GridCompAttributeEge(comp, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Egest the Attributes of the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance") as a FreeFormat object.
     It is the caller's responsibility to destroy the created <SPAN style="font-family:monospace">freeFormat</SPAN>
     object. 

<P>

<P>

<H3><A ID="SECTION00046600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_CompAttributeEgest - Egest NUOPC CplComp Attributes in FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeEgest() 
   subroutine NUOPC_CplCompAttributeEge(comp, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Egest the Attributes of the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance") as a FreeFormat object.
     It is the caller's responsibility to destroy the created <SPAN style="font-family:monospace">freeFormat</SPAN>
     object. 

<P>

<P>

<H3><A ID="SECTION00046700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute - string</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGet(comp, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>.

<P>
This call assumes to find a scalar value. An error is returned otherwise.

<P>
This call concverts to a string value, regardless of the actual attribute
     storage.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_GridComp</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00046800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute - string</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGet(comp, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>.

<P>
This call assumes to find a scalar value. An error is returned otherwise.

<P>
This call concverts to a string value, regardless of the actual attribute
     storage.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_CplComp</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00046900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute - integer</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetI(comp, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     integer,             intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_GridComp</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000461000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute - integer</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetI(comp, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     character(*),        intent(in)            :: name
     integer,             intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_CplComp</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000461100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute - string list</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetSL(comp, name, valueList, isPresent, &amp;
     isSet, itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),       intent(in)            :: comp
     character(*),              intent(in)            :: name
     character(*),              intent(out), optional :: valueList(:)
     logical,                   intent(out), optional :: isPresent
     logical,                   intent(out), optional :: isSet
     integer,                   intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag),  intent(out), optional :: typekind
     integer,                   intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_GridComp</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>[valueList]</STRONG></DT>
<DD>The list of values of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000461200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute - string list</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetSL(comp, name, valueList, isPresent, &amp;
     isSet, itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),       intent(in)            :: comp
     character(*),             intent(in)            :: name
     character(*),             intent(out), optional :: valueList(:)
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_CplComp</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>[valueList]</STRONG></DT>
<DD>The list of values of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000461300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute - integer list</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetIL(comp, name, valueList, isPresent, &amp;
     isSet, itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),       intent(in)            :: comp
     character(*),              intent(in)            :: name
     integer,                   intent(out)           :: valueList(:)
     logical,                   intent(out), optional :: isPresent
     logical,                   intent(out), optional :: isSet
     integer,                   intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag),  intent(out), optional :: typekind
     integer,                   intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_GridComp</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>valueList</STRONG></DT>
<DD>The list of values of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000461400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute - integer list</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetIL(comp, name, valueList, isPresent, &amp;
     isSet, itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),       intent(in)            :: comp
     character(*),             intent(in)            :: name
     integer,                  intent(out)           :: valueList(:)
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_CplComp</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>valueList</STRONG></DT>
<DD>The list of values of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000461500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_CompAttributeIngest - Ingest free format NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_GridCompAttributeIng(comp, freeFormat, addFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     logical,                intent(in),  optional :: addFlag
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_GridCompAttributeIng"></A>     Ingest the Attributes from a FreeFormat object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Important: Attributes ingested by this method are stored as type character
     strings, and must be accessed accordingly. Conversion from string into a
     different data type, e.g. <SPAN style="font-family:monospace">integer</SPAN> or <SPAN style="font-family:monospace">real</SPAN>, is the user's
     responsibility. This method does not support value lists. Attribute values
     ingested by this method must not contain whitespace within the value. If
     whitespace is found within the value the attribute will not be added to
     the comp.

<P>
If <SPAN style="font-family:monospace">addFlag</SPAN> is <SPAN style="font-family:monospace">.false.</SPAN> (default), an error will be returned if 
     an attribute is to be ingested that was not previously added to the 
     <SPAN style="font-family:monospace">comp</SPAN> object. If <SPAN style="font-family:monospace">addFlag</SPAN> is <SPAN style="font-family:monospace">.true.</SPAN>, all missing attributes
     will be added by this method automatically as needed.

<P>
Each line in <SPAN style="font-family:monospace">freeFormat</SPAN> is of this format:

<P>
<PRE>
       attributeName = attributeValue
</PRE>

<P>
For example:
     <PRE>
       Verbosity  = 0
       Profiling  = 0
       Diagnostic = 0
</PRE>
     could directly be ingested as Attributes for any instance of the four 
     standard NUOPC component kinds. This is because <SPAN style="font-family:monospace">Verbosity</SPAN>,
     <SPAN style="font-family:monospace">Profiling</SPAN>, and <SPAN style="font-family:monospace">Diagnostic</SPAN> are pre-defined Attributes of the 
     NUOPC component kinds according to sections <A HREF="node3.html#DriverCompMeta">2.3.1</A>, 
     <A HREF="node3.html#ModelCompMeta">2.3.2</A>, <A HREF="node3.html#MediatorCompMeta">2.3.3</A>, and <A HREF="node3.html#ConnectorCompMeta">2.3.4</A>.

<P>
When Attributes are specified in <SPAN style="font-family:monospace">freeFormat</SPAN> that are not pre-defined
     for a specific component kind, they can still be ingested by a component
     instance using the <SPAN style="font-family:monospace">addFlag=.true.</SPAN> option. For instance:
     <PRE>
       ModelOutputChoice = 2
</PRE>
     specifies a user-level Attribute, which is not part of the pre-defined 
     Attributes of any of the standard NUOPC component kinds.

<P>
Currently, whitespace is not supported in the attribute value and
     the following attributeName fails to be added.

<P>
<PRE>
       attributeName = attributeValue1 attributeValue2 attributedValue3
</PRE>

<P>
If a list is needed then a comma can be used as a delimiter. The
     attribute value list must then be parsed in user code.

<P>
<PRE>
       attributeName = attributeValue1,attributeValue2,attributedValue3
</PRE>

<P>

<P>

<H3><A ID="SECTION000461600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_CompAttributeIngest - Ingest free format NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_CplCompAttributeIng(comp, freeFormat, addFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     logical,                intent(in),  optional :: addFlag
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_CplCompAttributeIng"></A>     Ingest the Attributes from a FreeFormat object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Important: Attributes ingested by this method are stored as type character
     strings, and must be accessed accordingly. Conversion from string into a
     different data type, e.g. <SPAN style="font-family:monospace">integer</SPAN> or <SPAN style="font-family:monospace">real</SPAN>, is the user's
     responsibility.

<P>
If <SPAN style="font-family:monospace">addFlag</SPAN> is <SPAN style="font-family:monospace">.false.</SPAN> (default), an error will be returned if 
     an attribute is to be ingested that was not previously added to the 
     <SPAN style="font-family:monospace">comp</SPAN> object. If <SPAN style="font-family:monospace">addFlag</SPAN> is <SPAN style="font-family:monospace">.true.</SPAN>, all missing attributes
     will be added by this method automatically as needed.

<P>
Each line in <SPAN style="font-family:monospace">freeFormat</SPAN> is of this format:

<P>
<PRE>
       attributeName = attributeValue
</PRE>

<P>
For example:
     <PRE>
       Verbosity  = 0
       Profiling  = 0
       Diagnostic = 0
</PRE>
     could directly be ingested as Attributes for any instance of the four 
     standard NUOPC component kinds. This is because <SPAN style="font-family:monospace">Verbosity</SPAN>,
     <SPAN style="font-family:monospace">Profiling</SPAN>, and <SPAN style="font-family:monospace">Diagnostic</SPAN> are pre-defined Attributes of the 
     NUOPC component kinds according to sections <A HREF="node3.html#DriverCompMeta">2.3.1</A>, 
     <A HREF="node3.html#ModelCompMeta">2.3.2</A>, <A HREF="node3.html#MediatorCompMeta">2.3.3</A>, and <A HREF="node3.html#ConnectorCompMeta">2.3.4</A>.

<P>
When Attributes are specified in <SPAN style="font-family:monospace">freeFormat</SPAN> that are not pre-defined
     for a specific component kind, they can still be ingested by a component
     instance using the <SPAN style="font-family:monospace">addFlag=.true.</SPAN> option. For instance:
     <PRE>
       ModelOutputChoice = 2
</PRE>
     specifies a user-level Attribute, which is not part of the pre-defined 
     Attributes of any of the standard NUOPC component kinds.

<P>

<P>

<H3><A ID="SECTION000461700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_CompAttributeIngest - Ingest NUOPC GridComp Attributes from HConfig</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_GridCompAttributeIngHC(comp, hconfig, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(in)            :: comp
     type(ESMF_HConfig),     intent(in)            :: hconfig
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_GridCompAttributeIngHC"></A>     Ingest component attributes from a HConfig object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
The provided <SPAN style="font-family:monospace">hconfig</SPAN> is expected to be a <EM>map</EM>. An error is
     returned if this condition is not met. Each key-value pair held by
     <SPAN style="font-family:monospace">hconfig</SPAN> is added as an attribute to <SPAN style="font-family:monospace">comp</SPAN>.
     A copy of the source contents is made.

<P>
Transfers of <EM>scalar</EM>, <EM>sequence</EM>, and <EM>map</EM> values
     from <SPAN style="font-family:monospace">hconfig</SPAN> are supported.  Maps are treated recursively.
     Sequences are restricted to scalar elements of the same typekind.

<P>
The keys of any map provided by the <SPAN style="font-family:monospace">hconfig</SPAN> object must
     be of scalar type. Keys are interpreted as strings when transferred as an
     attribute.

<P>
Existing attributes with the same key are overridden by this operation.
     When attributes are overridden, the typekind of the associated value
     element is allowed to change.

<P>
<PRE>
   # A simple YAML definition of standard NUOPC attributes, followed by
   # component specific attributes.
  
   Verbosity:  4609             # decimal representation of explicit bit pattern
   Profiling:  low              # pre-defined NUOPC setting
   Diagnostic: 0                # explicit 0 turns OFF feature
   CustomSeq1: [1, 2, 3, 4]     # sequence of integers
   CustomSeq2: [1., 2., 3., 4.] # sequence of floats
   CustomSeq3: [true, false]    # sequence of bools
   CustomType: {k1: [a, aa, aaa], k2: b, k3: c}  # complex structure
</PRE>

<P>

<P>

<H3><A ID="SECTION000461800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> NUOPC_CompAttributeIngest - Ingest NUOPC CplComp Attributes from HConfig</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_CplCompAttributeIngHC(comp, hconfig, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(in)            :: comp
     type(ESMF_HConfig),     intent(in)            :: hconfig
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_CplCompAttributeIngHC"></A>     Ingest component attributes from a HConfig object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
The provided <SPAN style="font-family:monospace">hconfig</SPAN> is expected to be a <EM>map</EM>. An error is
     returned if this condition is not met. Each key-value pair held by
     <SPAN style="font-family:monospace">hconfig</SPAN> is added as an attribute to <SPAN style="font-family:monospace">comp</SPAN>.
     A copy of the source contents is made.

<P>
Transfers of <EM>scalar</EM>, <EM>sequence</EM>, and <EM>map</EM> values
     from <SPAN style="font-family:monospace">hconfig</SPAN> are supported.  Maps are treated recursively.
     Sequences are restricted to scalar elements of the same typekind.

<P>
The keys of any map provided by the <SPAN style="font-family:monospace">hconfig</SPAN> object must
     be of scalar type. Keys are interpreted as strings when transferred as an
     attribute.

<P>
Existing attributes with the same key are overridden by this operation.
     When attributes are overridden, the typekind of the associated value
     element is allowed to change.

<P>
<PRE>
   # A simple YAML definition of standard NUOPC attributes, followed by
   # component specific attributes.
  
   Verbosity:  4609             # decimal representation of explicit bit pattern
   Profiling:  low              # pre-defined NUOPC setting
   Diagnostic: 0                # explicit 0 turns OFF feature
   CustomSeq1: [1, 2, 3, 4]     # sequence of integers
   CustomSeq2: [1., 2., 3., 4.] # sequence of floats
   CustomSeq3: [true, false]    # sequence of bools
   CustomType: {k1: [a, aa, aaa], k2: b, k3: c}  # complex structure
</PRE>

<P>

<P>

<H3><A ID="SECTION000461900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> NUOPC_CompAttributeReset - Reset NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeReset() 
   subroutine NUOPC_GridCompAttributeReset(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Reset Attributes on the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION000462000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> NUOPC_CompAttributeReset - Reset NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeReset() 
   subroutine NUOPC_CplCompAttributeReset(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Reset Attributes on the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION000462100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> NUOPC_CompAttributeSet - Set a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetS(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the Attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION000462200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> NUOPC_CompAttributeSet - Set a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetS(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the Attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION000462300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> NUOPC_CompAttributeSet - Set a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetI(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     integer,      intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the Attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION000462400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> NUOPC_CompAttributeSet - Set a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetI(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     integer,      intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the Attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION000462500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> NUOPC_CompAttributeSet - Set a NUOPC GridComp List Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetSL(comp, name, valueList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: valueList(:)
     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the Attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION000462600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> NUOPC_CompAttributeSet - Set a NUOPC CplComp List Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetSL(comp, name, valueList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: valueList(:)
     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the Attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">comp</SPAN> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance"). 

<P>

<P>

<H3><A ID="SECTION000462700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> NUOPC_CompCheckSetClock - Check Clock compatibility and set stopTime</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompCheckSetClock() 
   subroutine NUOPC_GridCompCheckSetClock(comp, externalClock, checkTimeStep, &amp;
     forceTimeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     logical,                 intent(in),  optional :: checkTimeStep
     logical,                 intent(in),  optional :: forceTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Compare <SPAN style="font-family:monospace">externalClock</SPAN> to the internal clock of <SPAN style="font-family:monospace">comp</SPAN> to make sure
     they match in their current time. Also ensure that the time step of the
     external clock is a multiple of the time step of the internal clock. If
     both conditions are satisfied then set the stop time of the internal clock
     so it is reached in one time step of the external clock. Otherwise leave the
     internal clock unchanged and return with error. The direction of
     the involved clocks is taking into account.
     Setting the <SPAN style="font-family:monospace">forceTimeStep</SPAN> argument to <SPAN style="font-family:monospace">.true.</SPAN> forces the
     <SPAN style="font-family:monospace">timeStep</SPAN> of the <SPAN style="font-family:monospace">externalClock</SPAN> to be used to reset the
     <SPAN style="font-family:monospace">timeStep</SPAN> of the internal clock. 

<P>

<P>

<H3><A ID="SECTION000462800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> NUOPC_CompDerive - Derive a GridComp from a generic component</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompDerive() 
   recursive subroutine NUOPC_GridCompDerive(comp, genericSetServicesRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     interface
       subroutine genericSetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Derive a GridComp (i.e. Model, Mediator, or Driver) from a generic 
     component by calling into the specified <SPAN style="font-family:monospace">SetServices()</SPAN> routine of the
     generic component. This is typically the first call in the
     <SPAN style="font-family:monospace">SetServices()</SPAN> routine of the specializing component, and is followed
     by <SPAN style="font-family:monospace">NUOPC_CompSpecialize()</SPAN> calls. 

<P>

<P>

<H3><A ID="SECTION000462900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> NUOPC_CompDerive - Derive a CplComp from a generic component</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompDerive() 
   recursive subroutine NUOPC_CplCompDerive(comp, genericSetServicesRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     interface
       subroutine genericSetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Derive a CplComp (i.e. Connector) from a generic
     component by calling into the specified <SPAN style="font-family:monospace">SetServices()</SPAN> routine of the
     generic component. This is typically the first call in the
     <SPAN style="font-family:monospace">SetServices()</SPAN> routine of the specializing component, and is followed
     by <SPAN style="font-family:monospace">NUOPC_CompSpecialize()</SPAN> calls. 

<P>

<P>

<H3><A ID="SECTION000463000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> NUOPC_CompFilterPhaseMap - Filter the Phase Map of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompFilterPhaseMap()
   subroutine NUOPC_GridCompFilterPhaseMap(comp, methodflag, acceptStringList, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in)            :: acceptStringList(:)
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Filter all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   that do <EM>not</EM> match any entry in the <SPAN style="font-family:monospace">acceptStringList</SPAN>. 

<P>

<P>

<H3><A ID="SECTION000463100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> NUOPC_CompFilterPhaseMap - Filter the Phase Map of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompFilterPhaseMap()
   subroutine NUOPC_CplCompFilterPhaseMap(comp, methodflag, acceptStringList, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in)            :: acceptStringList(:)
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Filter all PhaseMap entries in a CplComp (i.e. Connector)
   that do <EM>not</EM> match any entry in the <SPAN style="font-family:monospace">acceptStringList</SPAN>. 

<P>

<P>

<H3><A ID="SECTION000463200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> NUOPC_CompGet - Access info from GridComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompGet()
   subroutine NUOPC_GridCompGet(comp, name, verbosity, profiling, diagnostic, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(out), optional :: name
     integer,            intent(out), optional :: verbosity
     integer,            intent(out), optional :: profiling
     integer,            intent(out), optional :: diagnostic
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access information from a GridComp. 

<P>

<P>

<H3><A ID="SECTION000463300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> NUOPC_CompGet - Access info from CplComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompGet()
   subroutine NUOPC_CplCompGet(comp, name, verbosity, profiling, diagnostic, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(out), optional :: name
     integer,            intent(out), optional :: verbosity
     integer,            intent(out), optional :: profiling
     integer,            intent(out), optional :: diagnostic
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access information from a CplComp. 

<P>

<P>

<H3><A ID="SECTION000463400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> NUOPC_CompSearchPhaseMap - Search the Phase Map of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSearchPhaseMap()
   subroutine NUOPC_GridCompSearchPhaseMap(comp, methodflag, internalflag, &amp;
     phaseLabel, phaseIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     logical,                intent(in),  optional :: internalflag
     character(len=*),       intent(in),  optional :: phaseLabel
     integer,                intent(out)           :: phaseIndex
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Search all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   to see if <SPAN style="font-family:monospace">phaseLabel</SPAN> is found. Return the associated ESMF
   <SPAN style="font-family:monospace">phaseIndex</SPAN>, or <SPAN style="font-family:monospace">-1</SPAN> if not found. If <SPAN style="font-family:monospace">phaseLabel</SPAN> is not
   specified, set <SPAN style="font-family:monospace">phaseIndex</SPAN> to the first entry in the PhaseMap, or 
   <SPAN style="font-family:monospace">-1</SPAN> if there are no entries. The <SPAN style="font-family:monospace">internalflag</SPAN> argument 
   allows to search the internal phase maps of driver components. The default
   is <SPAN style="font-family:monospace">internalflag=.false.</SPAN>. 

<P>

<P>

<H3><A ID="SECTION000463500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> NUOPC_CompSearchPhaseMap - Search the Phase Map of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSearchPhaseMap()
   subroutine NUOPC_CplCompSearchPhaseMap(comp, methodflag, phaseLabel, &amp;
     phaseIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in),  optional :: phaseLabel
     integer,                intent(out)           :: phaseIndex
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Search all PhaseMap entries in a CplComp (i.e. Connector)
   to see if <SPAN style="font-family:monospace">phaseLabel</SPAN> is found. Return the associated ESMF
   <SPAN style="font-family:monospace">phaseIndex</SPAN>, or <SPAN style="font-family:monospace">-1</SPAN> if not found. If <SPAN style="font-family:monospace">phaseLabel</SPAN> is not
   specified, set <SPAN style="font-family:monospace">phaseIndex</SPAN> to the first entry in the PhaseMap, or 
   <SPAN style="font-family:monospace">-1</SPAN> if there are no entries. 

<P>

<P>

<H3><A ID="SECTION000463600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> NUOPC_CompSearchRevPhaseMap - Reverse Search the Phase Map of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSearchRevPhaseMap()
   subroutine NUOPC_GridCompSearchRevPhaseMap(comp, methodflag, internalflag, &amp;
     phaseIndex, phaseLabel, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     logical,                intent(in),  optional :: internalflag
     integer,                intent(in),  optional :: phaseIndex
     character(len=*),       intent(out)           :: phaseLabel
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Search all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   to see if the ESMF <SPAN style="font-family:monospace">phaseIndex</SPAN> is found. Return the associated
   <SPAN style="font-family:monospace">phaseLabel</SPAN>, or an empty string if not found. If <SPAN style="font-family:monospace">phaseIndex</SPAN> is not
   specified, set <SPAN style="font-family:monospace">phaseLabel</SPAN> to the first entry in the PhaseMap, or 
   an empty string if there are no entries. The <SPAN style="font-family:monospace">internalflag</SPAN> argument 
   allows to search the internal phase maps of driver components. The default
   is <SPAN style="font-family:monospace">internalflag=.false.</SPAN>. 

<P>

<P>

<H3><A ID="SECTION000463700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> NUOPC_CompSearchRevPhaseMap - Reverse Search the Phase Map of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSearchRevPhaseMap()
   subroutine NUOPC_CplCompSearchRevPhaseMap(comp, methodflag, phaseIndex, &amp;
     phaseLabel, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     integer,                intent(in),  optional :: phaseIndex
     character(len=*),       intent(out)           :: phaseLabel
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Search all PhaseMap entries in a CplComp (i.e. Connector)
   to see if the ESMF <SPAN style="font-family:monospace">phaseIndex</SPAN> is found. Return the associated
   <SPAN style="font-family:monospace">phaseLabel</SPAN>, or an empty string if not found. If <SPAN style="font-family:monospace">phaseIndex</SPAN> is not
   specified, set <SPAN style="font-family:monospace">phaseLabel</SPAN> to the first entry in the PhaseMap, or 
   an empty string if there are no entries. 

<P>

<P>

<H3><A ID="SECTION000463800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> NUOPC_CompSetClock - Initialize and set the internal Clock of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSetClock()
   subroutine NUOPC_GridCompSetClock(comp, externalClock, stabilityTimeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     type(ESMF_TimeInterval), intent(in),  optional :: stabilityTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_GridCompSetClock"></A>
<P>
Set the component internal clock as a copy of <SPAN style="font-family:monospace">externalClock</SPAN>, but
     with a timeStep that is less than or equal to the stabilityTimeStep.
     At the same time ensure that the timeStep of the external clock is
     a multiple of the timeStep of the internal clock. If the stabilityTimeStep
     argument is not provided then the internal clock will simply be set
     as a copy of the external clock. 

<P>

<P>

<H3><A ID="SECTION000463900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> NUOPC_CompSetEntryPoint - Set entry point for a GridComp (DEPRECATED!)</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSetEntryPoint()
   subroutine NUOPC_GridCompSetEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set an entry point for a GridComp (i.e. Model, Mediator, or Driver). Publish
   the new entry point in the correct <SPAN style="font-family:monospace">PhaseMap</SPAN> component attribute.

<P>
Starting with version 8.1.0, the use of this method is deprecated. Components
   should instead specialize exclusively using the <SPAN style="font-family:monospace">NUOPC_CompSpecialize()</SPAN>
   method. 

<P>

<P>

<H3><A ID="SECTION000464000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> NUOPC_CompSetEntryPoint - Set entry point for a CplComp (DEPRECATED!)</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSetEntryPoint()
   subroutine NUOPC_CplCompSetEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(cplcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set an entry point for a CplComp (i.e. Connector). Publish
   the new entry point in the correct <SPAN style="font-family:monospace">PhaseMap</SPAN> component attribute.

<P>
Starting with version 8.1.0, the use of this method is deprecated. Components
   should instead specialize exclusively using the <SPAN style="font-family:monospace">NUOPC_CompSpecialize()</SPAN>
   method. 

<P>

<P>

<H3><A ID="SECTION000464100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> NUOPC_CompSetInternalEntryPoint - Set internal entry point for a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSetInternalEntryPoint()
   subroutine NUOPC_GridCompSetIntEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set an <EM>internal</EM> entry point for a GridComp (i.e. Driver). Only Drivers 
   currently utilize internal entry points. Internal entry points allow user
   specialization on the driver level during initialization and run sequencing. 

<P>

<P>

<H3><A ID="SECTION000464200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> NUOPC_CompSetServices - Try to find and call SetServices in a shared object</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSetServices()
   recursive subroutine NUOPC_GridCompSetServices(comp, sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     character(len=*),        intent(in),  optional :: sharedObj
     integer,                 intent(out), optional :: userRc
     integer,                 intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Try to find a routine called "<SPAN style="font-family:monospace">SetServices</SPAN>" in the <SPAN style="font-family:monospace">sharedObj</SPAN> file
     and execute the routine. An attempt is made to find a routine that
     is close in name to "<SPAN style="font-family:monospace">SetServices</SPAN>", allowing for compiler name
     mangling, i.e. upper and lower case, as well as trailing underscores.
     The asterisk character <SPAN style="font-family:monospace">(*)</SPAN> is supported as a wildcard for the
     file name suffix in <SPAN style="font-family:monospace">sharedObj</SPAN>. When present, the asterisk is replaced
     by "so", "dylib", and "dll", in this order, and the first successfully
     loaded object is used. If the <SPAN style="font-family:monospace">sharedObj</SPAN> argument is not provided, the
     executable itself is searched. 

<P>

<P>

<H3><A ID="SECTION000464300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">43</SPAN> NUOPC_CompSetVM - Try to find and call SetVM in a shared object</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSetVM()
   recursive subroutine NUOPC_GridCompSetVM(comp, sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     character(len=*),        intent(in),  optional :: sharedObj
     integer,                 intent(out), optional :: userRc
     integer,                 intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Try to find a routine called "<SPAN style="font-family:monospace">SetVM</SPAN>" in the <SPAN style="font-family:monospace">sharedObj</SPAN> file
     and execute the routine. An attempt is made to find a routine that
     is close in name to "<SPAN style="font-family:monospace">SetVM</SPAN>", allowing for compiler name
     mangling, i.e. upper and lower case, as well as trailing underscores.
     The asterisk character <SPAN style="font-family:monospace">(*)</SPAN> is supported as a wildcard for the
     file name suffix in <SPAN style="font-family:monospace">sharedObj</SPAN>. When present, the asterisk is replaced
     by "so", "dylib", and "dll", in this order, and the first successfully
     loaded object is used. If the <SPAN style="font-family:monospace">sharedObj</SPAN> argument is not provided, the
     executable itself is searched. 

<P>

<P>

<H3><A ID="SECTION000464400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">44</SPAN> NUOPC_CompSpecialize - Specialize a derived GridComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSpecialize()
   subroutine NUOPC_GridCompSpecialize(comp, specLabel, specPhaseLabel, &amp;
     specRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     character(len=*), intent(in)            :: specLabel
     character(len=*), intent(in),  optional :: specPhaseLabel
     interface
       subroutine specRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Specialize a derived GridComp (i.e. Model, Mediator, or Driver). If
   <SPAN style="font-family:monospace">specPhaseLabel</SPAN> is specified, the specialization only applies to
   the associated phase. Otherwise the specialization applies to all phases. 

<P>

<P>

<H3><A ID="SECTION000464500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">45</SPAN> NUOPC_CompSpecialize - Specialize a derived CplComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_CompSpecialize()
   subroutine NUOPC_CplCompSpecialize(comp, specLabel, specPhaseLabel, &amp;
     specRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: comp
     character(len=*), intent(in)            :: specLabel
     character(len=*), intent(in),  optional :: specPhaseLabel
     interface
       subroutine specRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Specialize a derived CplComp (i.e. Connector). If
   <SPAN style="font-family:monospace">specPhaseLabel</SPAN> is specified, the specialization only applies to
   the associated phase. Otherwise the specialization applies to all phases.

<H2><A ID="SECTION00047000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Field Dictionary Methods</A>
</H2>

<P>

<P>

<P>

<H3><A ID="SECTION00047100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_FieldDictionaryAddEntry - Add an entry to the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FieldDictionaryAddEntry(standardName, canonicalUnits, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     character(*),                 intent(in)            :: canonicalUnits
     integer,                      intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Add an entry to the NUOPC Field dictionary. If necessary the dictionary is
     first set up. 

<P>

<P>

<H3><A ID="SECTION00047200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_FieldDictionaryEgest - Egest NUOPC Field dictionary into FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FieldDictionaryEgest(freeFormat, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     type(ESMF_IOFmt_Flag),  intent(in),  optional :: iofmt
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Egest the contents of the NUOPC Field dictionary into a FreeFormat object.
     If I/O format option <SPAN style="font-family:monospace">iofmt</SPAN> is provided and equal to <SPAN style="font-family:monospace">ESMF_IOFMT_YAML</SPAN>,
     the FreeFormat object will contain the NUOPC Field dictionary expressed in YAML
     format. Other values for <SPAN style="font-family:monospace">iofmt</SPAN> are ignored and this method behaves as if
     the optional <SPAN style="font-family:monospace">iofmt</SPAN> argument were missing. In such a case, <SPAN style="font-family:monospace">freeFormat</SPAN>
     will contain NUOPC Field dictionary entries in the traditional format.
     It is the caller's responsibility to destroy the created <SPAN style="font-family:monospace">freeFormat</SPAN>
     object. 

<P>

<P>

<H3><A ID="SECTION00047300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_FieldDictionaryGetEntry - Get information about a NUOPC Field dictionary entry</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FieldDictionaryGetEntry(standardName, canonicalUnits, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     character(*),                 intent(out), optional :: canonicalUnits
     integer,                      intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return the canonical units that the NUOPC Field dictionary associates with
     the <SPAN style="font-family:monospace">standardName</SPAN>. 

<P>

<P>

<H3><A ID="SECTION00047400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_FieldDictionaryHasEntry - Check whether the NUOPC Field dictionary has a specific entry</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   function NUOPC_FieldDictionaryHasEntry(standardName, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_FieldDictionaryHasEntry
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     integer,                      intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if the NUOPC Field dictionary has an entry with the
     specified <SPAN style="font-family:monospace">standardName</SPAN>, <SPAN style="font-family:monospace">.false.</SPAN> otherwise. 

<P>

<P>

<H3><A ID="SECTION00047500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_FieldDictionaryMatchSyno - Check whether the NUOPC Field dictionary considers the standard names synonyms</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   function NUOPC_FieldDictionaryMatchSyno(standardName1, standardName2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_FieldDictionaryMatchSyno
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName1
     character(*),                 intent(in)            :: standardName2
     integer,                      intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if the NUOPC Field dictionary considers
     <SPAN style="font-family:monospace">standardName1</SPAN> and <SPAN style="font-family:monospace">standardName2</SPAN> synonyms, <SPAN style="font-family:monospace">.false.</SPAN> 
     otherwise. Also, if <SPAN style="font-family:monospace">standardName1</SPAN> and/or <SPAN style="font-family:monospace">standardName2</SPAN> do not 
     correspond to an existing dictionary entry, .false. will be returned. 

<P>

<P>

<H3><A ID="SECTION00047600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_FieldDictionarySetSyno - Set synonyms in the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FieldDictionarySetSyno(standardNames, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardNames(:)
     integer,                      intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set all of the elements of the <SPAN style="font-family:monospace">standardNames</SPAN> argument to be considered
     synonyms by the field dictionary. Every element in <SPAN style="font-family:monospace">standardNames</SPAN> must
     correspond to the standard name of already existing entries in the field 
     dictionary, or else an error will be returned. 

<P>

<P>

<H3><A ID="SECTION00047700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_FieldDictionarySetup - Setup the default NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_FieldDictionarySetup()
   subroutine NUOPC_FieldDictionarySetupDefault(rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Setup the default NUOPC Field dictionary. 

<P>

<P>

<H3><A ID="SECTION00047800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_FieldDictionarySetup - Setup the NUOPC Field dictionary from YAML file</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_FieldDictionarySetup()
   subroutine NUOPC_FieldDictionarySetupFile(fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),      intent(in)              :: fileName
     integer,               intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Setup the NUOPC Field dictionary by reading its content from YAML file.
     If the NUOPC Field dictionary already exists, remove it and create a new one.
     This feature requires ESMF built with YAML support. Please see the
     ESMF User's Guide for details.

<H2><A ID="SECTION00048000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Free Format Methods</A>
</H2>

<P>

<P>

<P>

<H3><A ID="SECTION00048100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_FreeFormatAdd - Add lines to a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FreeFormatAdd(freeFormat, stringList, line, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(inout) :: freeFormat
     character(len=*),                 intent(in)    :: stringList(:)
     integer,                optional, intent(in)    :: line
     integer,                optional, intent(out)   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Add lines to a FreeFormat object. The capacity of <SPAN style="font-family:monospace">freeFormat</SPAN> may 
     increase during this operation. The new lines provided in <SPAN style="font-family:monospace">stringList</SPAN>
     are added starting at position <SPAN style="font-family:monospace">line</SPAN>. If <SPAN style="font-family:monospace">line</SPAN> is greater than the
     current <SPAN style="font-family:monospace">lineCount</SPAN> of <SPAN style="font-family:monospace">freeFormat</SPAN>, blank lines are inserted to
     fill the gap. By default, i.e. without specifying the <SPAN style="font-family:monospace">line</SPAN> argument,
     the elements in <SPAN style="font-family:monospace">stringList</SPAN> are added to the <EM>end</EM> of the
     <SPAN style="font-family:monospace">freeFormat</SPAN> object. 

<P>

<P>

<H3><A ID="SECTION00048200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_FreeFormatCreate - Create a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_FreeFormatCreate()
   function NUOPC_FreeFormatCreateDefault(freeFormat, stringList, capacity, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(NUOPC_FreeFormat) :: NUOPC_FreeFormatCreateDefault
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat), optional, intent(in)  :: freeFormat
     character(len=*),       optional, intent(in)  :: stringList(:)
     integer,                optional, intent(in)  :: capacity
     integer,                optional, intent(out) :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Create a new FreeFormat object, which by default is empty. 
     If <SPAN style="font-family:monospace">freeFormat</SPAN> is provided, then the newly created object starts as
     a copy of <SPAN style="font-family:monospace">freeFormat</SPAN>. If <SPAN style="font-family:monospace">stringList</SPAN> is provided, then it is
     added to the end of the newly created object. If <SPAN style="font-family:monospace">capacity</SPAN> is provided,
     it is used for the <EM>initial</EM> creation of the newly created FreeFormat 
     object. However, if the <SPAN style="font-family:monospace">freeFormat</SPAN> or <SPAN style="font-family:monospace">stringList</SPAN> arguments are
     present, the final capacity may be larger than specified by <SPAN style="font-family:monospace">capacity</SPAN>. 

<P>

<P>

<H3><A ID="SECTION00048300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_FreeFormatCreate - Create a FreeFormat object from Config</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_FreeFormatCreate()
   function NUOPC_FreeFormatCreateRead(config, label, relaxedflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(NUOPC_FreeFormat) :: NUOPC_FreeFormatCreateRead
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config)                            :: config
     character(len=*),      intent(in)            :: label
     logical,               intent(in),  optional :: relaxedflag
     integer,               intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Create a new FreeFormat object from ESMF_Config object. The <SPAN style="font-family:monospace">config</SPAN>
     object must exist, and <SPAN style="font-family:monospace">label</SPAN> must reference either a single line
     or a table attribute within <SPAN style="font-family:monospace">config</SPAN>. The content of the attribute is
     read and returned in the newly created FreeFormat object.

<P>
By default an error is returned if <SPAN style="font-family:monospace">label</SPAN> is not found in <SPAN style="font-family:monospace">config</SPAN>.
   This error can be suppressed by setting <SPAN style="font-family:monospace">relaxedflag=.true.</SPAN>, in which
   case an empty FreeFormat object is returned.

<P>

<P>

<H3><A ID="SECTION00048400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_FreeFormatDestroy - Destroy a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FreeFormatDestroy(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(inout) :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Destroy a FreeFormat object. All internal memory is deallocated. 

<P>

<P>

<H3><A ID="SECTION00048500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_FreeFormatGet - Get information from a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FreeFormatGet(freeFormat, lineCount, capacity, stringList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),                       intent(in)  :: freeFormat
     integer,                            optional, intent(out) :: lineCount
     integer,                            optional, intent(out) :: capacity
     character(len=NUOPC_FreeFormatLen), optional, pointer     :: stringList(:)
     integer,                            optional, intent(out) :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Get information from a FreeFormat object. 

<P>

<P>

<H3><A ID="SECTION00048600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_FreeFormatGetLine - Get line info from a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FreeFormatGetLine(freeFormat, line, commentChar, lineString, &amp;
     tokenCount, tokenList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),                       intent(in)  :: freeFormat
     integer,                                      intent(in)  :: line
     character,                          optional, intent(in)  :: commentChar
     character(len=NUOPC_FreeFormatLen), optional, intent(out) :: lineString
     integer,                            optional, intent(out) :: tokenCount
     character(len=NUOPC_FreeFormatLen), optional, intent(out) :: tokenList(:)
     integer,                            optional, intent(out) :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Get information about a specific line in a FreeFormat object. If
     <SPAN style="font-family:monospace">commentChar</SPAN> is specified, anything on the line, starting with
     <SPAN style="font-family:monospace">commentChar</SPAN> is considered a comment, and subsequently ignored. 

<P>

<P>

<H3><A ID="SECTION00048700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_FreeFormatLog - Write a FreeFormat object to the default Log</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FreeFormatLog(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(in)    :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Write a FreeFormat object to the default Log. 

<P>

<P>

<H3><A ID="SECTION00048800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_FreeFormatPrint - Print a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_FreeFormatPrint(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(in)    :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Print a FreeFormat object.

<H2><A ID="SECTION00049000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Utility Routines</A>
</H2>

<P>

<P>

<P>

<H3><A ID="SECTION00049100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_AddNamespace - Add a nested state with Namespace to a State</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_AddNamespace(state, Namespace, nestedStateName, &amp;
     nestedState, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(len=*), intent(in)            :: Namespace
     character(len=*), intent(in),  optional :: nestedStateName
     type(ESMF_State), intent(out), optional :: nestedState
     type(ESMF_VM),    intent(in),  optional :: vm
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Add a Namespace to <SPAN style="font-family:monospace">state</SPAN>. Namespaces are implemented via nested 
     states. This creates a nested state inside of <SPAN style="font-family:monospace">state</SPAN>. The nested state
     is returned as <SPAN style="font-family:monospace">nestedState</SPAN>. If provided, <SPAN style="font-family:monospace">nestedStateName</SPAN> will 
     be used to name the newly created nested state. The default name of the 
     nested state is equal to <SPAN style="font-family:monospace">Namespace</SPAN>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object to which the Namespace is added.
     
</DD>
<DT><STRONG>Namespace</STRONG></DT>
<DD>The Namespace string.
     
</DD>
<DT><STRONG>[nestedStateName]</STRONG></DT>
<DD>Name of the nested state. Defaults to <SPAN style="font-family:monospace">Namespace</SPAN>.
     
</DD>
<DT><STRONG>[nestedState]</STRONG></DT>
<DD>Optional return of the newly created nested state.
     
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the nested State created to hold the namespace is created on
       the specified <SPAN style="font-family:monospace">ESMF_VM</SPAN> object. The default is to create the nested
       State on the VM of the current component context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00049200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_AddNestedState - Add a nested state to a state with NUOPC attributes</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_AddNestedState(state, Namespace, CplSet, nestedStateName, &amp;
     vm, nestedState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(len=*), intent(in),  optional :: Namespace
     character(len=*), intent(in),  optional :: CplSet
     character(len=*), intent(in),  optional :: nestedStateName
     type(ESMF_VM),    intent(in),  optional :: vm
     type(ESMF_State), intent(out), optional :: nestedState
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_AddNestedState"></A>     Create a nested state inside of <SPAN style="font-family:monospace">state</SPAN>. The arguments <SPAN style="font-family:monospace">Namespace</SPAN>
     and tt CplSet are used to set NUOPC attributes on the newly created
     state. The nested state is returned as <SPAN style="font-family:monospace">nestedState</SPAN>. If provided,
     <SPAN style="font-family:monospace">nestedStateName</SPAN> will be used to name the newly created nested state.
     The default name of the nested state is equal to
     <SPAN style="font-family:monospace">Namespace</SPAN>_<SPAN style="font-family:monospace">CplSet</SPAN>, <SPAN style="font-family:monospace">Namespace</SPAN>, or <SPAN style="font-family:monospace">CplSet</SPAN> if the
     arguments are provided.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object to which the namespace is added.
     
</DD>
<DT><STRONG>[Namespace]</STRONG></DT>
<DD>Optional The Namespace string. Defaults to "__UNSPECIFIED__".
     
</DD>
<DT><STRONG>[CplSet]</STRONG></DT>
<DD>Optional The CplSet string. Defaults to "__UNSPECIFIED__".
     
</DD>
<DT><STRONG>[nestedStateName]</STRONG></DT>
<DD>Name of the nested state. Defaults to <SPAN style="font-family:monospace">Namespace</SPAN>_<SPAN style="font-family:monospace">CplSet</SPAN>,
       <SPAN style="font-family:monospace">Namespace</SPAN>, or <SPAN style="font-family:monospace">CplSet</SPAN> if arguments are provided.
     
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the nested state object is created on the specified
       <SPAN style="font-family:monospace">ESMF_VM</SPAN> object. The default is to create the nested state object
       on the VM of the current component context.
     
</DD>
<DT><STRONG>[nestedState]</STRONG></DT>
<DD>Optional return of the newly created nested state.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00049300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_Advertise - Advertise a single Field in a State</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Advertise() 
   subroutine NUOPC_AdvertiseField(state, StandardName, Units, &amp;
     LongName, ShortName, name, TransferOfferGeomObject, SharePolicyField, &amp;
     SharePolicyGeomObject, vm, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardName
     character(*),     intent(in),  optional :: Units
     character(*),     intent(in),  optional :: LongName
     character(*),     intent(in),  optional :: ShortName
     character(*),     intent(in),  optional :: name
     character(*),     intent(in),  optional :: TransferOfferGeomObject
     character(*),     intent(in),  optional :: SharePolicyField
     character(*),     intent(in),  optional :: SharePolicyGeomObject
     type(ESMF_VM),    intent(in),  optional :: vm
     type(ESMF_Field), intent(out), optional :: field
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_AdvertiseField"></A>     Advertise a field in a state. This creates an empty field and adds it to
     <SPAN style="font-family:monospace">state</SPAN>. The "StandardName", "Units", "LongName", "ShortName", and 
     "TransferOfferGeomObject" attributes of the field are set according to the
     provided input..

<P>
The call checks the provided information against the NUOPC Field Dictionary
     to ensure correctness. Defaults are set according to the NUOPC Field 
     Dictionary.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object through which the field is advertised.
     
</DD>
<DT><STRONG>StandardName</STRONG></DT>
<DD>The "StandardName" attribute of the advertised field. Must be a 
       StandardName found in the NUOPC Field Dictionary.
<BR>
NOTE that if by below default rules, <SPAN style="font-family:monospace">StandardName</SPAN> is also used as
       the input for <SPAN style="font-family:monospace">name</SPAN>, then it must not contain the slash ("/")
       character.
     
</DD>
<DT><STRONG>[Units]</STRONG></DT>
<DD>The "Units" attribute of the advertised field. Must be convertible to the
       canonical units specified in the NUOPC Field Dictionary for the specified
       StandardName. (Currently this is restricted to be identical to the 
       canonical untis specified in the NUOPC Field Dictionary.)
       If omitted, the default is to use the canonical units associated with
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[LongName]</STRONG></DT>
<DD>The "LongName" attribute of the advertised field. NUOPC does not restrict
       the value of this attribute.
       If omitted, the default is to use the StandardName.
     
</DD>
<DT><STRONG>[ShortName]</STRONG></DT>
<DD>The "ShortName" attribute of the advertised field. NUOPC does not restrict
       the value of this attribute.
       If omitted, the default is to use the StandardName.
<BR>
NOTE that if by below default rules, <SPAN style="font-family:monospace">ShortName</SPAN> is also used as
       the input for <SPAN style="font-family:monospace">name</SPAN>, then it must not contain the slash ("/")
       character.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The actual name of the advertised field by which it is accessed in the
       state object. The string provided for <SPAN style="font-family:monospace">name</SPAN> must not contain the
       slash ("/") character.
       If omitted, the default is to use the value of the ShortName.
     
</DD>
<DT><STRONG>[TransferOfferGeomObject]</STRONG></DT>
<DD>If the state intent of <SPAN style="font-family:monospace">state</SPAN> is <SPAN style="font-family:monospace">ESMF_STATEINTENT_EXPORT</SPAN>,
       the "ProducerTransferOffer" attribute of the advertised field is set.
       If the state intent of <SPAN style="font-family:monospace">state</SPAN> is <SPAN style="font-family:monospace">ESMF_STATEINTENT_IMPORT</SPAN>,
       the "ConsumerTransferOffer" attribute of the advertised field is set.
       NUOPC controls the vocabulary of this attribute. Valid options are 
       "will provide", "can provide", "cannot provide".
       If omitted, the default is "will provide".
     
</DD>
<DT><STRONG>[SharePolicyField]</STRONG></DT>
<DD>The "SharePolicyField" attribute of the advertised field. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is "not share".
     
</DD>
<DT><STRONG>[SharePolicyGeomObject]</STRONG></DT>
<DD>The "SharePolicyGeomObject" attribute of the advertised field. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is equal to <SPAN style="font-family:monospace">SharePolicyField</SPAN>.
     
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field object used during advertising is created on the
       specified <SPAN style="font-family:monospace">ESMF_VM</SPAN> object. The default is to create the Field object
       on the VM of the current component context.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the empty field object that was used to advertise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00049400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_Advertise - Advertise a list of Fields in a State</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Advertise() 
   subroutine NUOPC_AdvertiseFields(state, StandardNames, &amp;
     TransferOfferGeomObject, SharePolicyField, SharePolicyGeomObject, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardNames(:)
     character(*),     intent(in),  optional :: TransferOfferGeomObject
     character(*),     intent(in),  optional :: SharePolicyField
     character(*),     intent(in),  optional :: SharePolicyGeomObject
     type(ESMF_VM),    intent(in),  optional :: vm
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_AdvertiseFields"></A>     Advertise a list of fields in a state. This creates a list of empty fields
     and adds it to the <SPAN style="font-family:monospace">state</SPAN>. The "StandardName", "TransferOfferGeomObject",
     "SharePolicyField", and "SharePolicyGeomObject" attributes of all the 
     fields are set according to the provided input. The "Units", "LongName",
     and "ShortName" attributes for each field are set according to the defaults
     documented under method <A HREF="#NUOPC_AdvertiseField">3.9.3</A>

<P>
The call checks the provided information against the NUOPC Field Dictionary
     to ensure correctness.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object through which the fields are advertised.
     
</DD>
<DT><STRONG>StandardNames</STRONG></DT>
<DD>A list of "StandardName" attributes of the advertised fields. Must be 
       StandardNames found in the  NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[TransferOfferGeomObject]</STRONG></DT>
<DD>The "TransferOfferGeomObject" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "will provide", "can provide", "cannot provide".
       If omitted, the default is "will provide".
     
</DD>
<DT><STRONG>[SharePolicyField]</STRONG></DT>
<DD>The "SharePolicyField" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is "not share".
     
</DD>
<DT><STRONG>[SharePolicyGeomObject]</STRONG></DT>
<DD>The "SharePolicyGeomObject" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is equal to <SPAN style="font-family:monospace">SharePolicyField</SPAN>.
     
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field objects used during advertising are created on the
       specified <SPAN style="font-family:monospace">ESMF_VM</SPAN> object. The default is to create the Field
       objects on the VM of the current component context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00049500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_AdjustClock - Adjust the timestep in a clock</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_AdjustClock(clock, maxTimestep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock)                               :: clock
     type(ESMF_TimeInterval), intent(in),  optional :: maxTimestep
     integer,                 intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Adjust the <SPAN style="font-family:monospace">clock</SPAN> to have a potentially smaller timestep. The timestep
     on the incoming <SPAN style="font-family:monospace">clock</SPAN> object is compared to the <SPAN style="font-family:monospace">maxTimestep</SPAN>, and
     reset to the smaller of the two.

<P>
The arguments are:
     <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The clock to be adjusted.
     
</DD>
<DT><STRONG>[maxTimestep]</STRONG></DT>
<DD>Upper bound of the timestep allowed in <SPAN style="font-family:monospace">clock</SPAN>. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00049600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_CheckSetClock - Check a Clock for compatibility and set its values</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_CheckSetClock(setClock, checkClock, setStartTimeToCurrent, &amp;
     currTime, forceCurrTime, checkTimeStep, forceTimeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock),        intent(inout)         :: setClock
     type(ESMF_Clock),        intent(in)            :: checkClock
     logical,                 intent(in),  optional :: setStartTimeToCurrent
     type(ESMF_Time),         intent(in),  optional :: currTime
     logical,                 intent(in),  optional :: forceCurrTime
     logical,                 intent(in),  optional :: checkTimeStep
     logical,                 intent(in),  optional :: forceTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
By default compare <SPAN style="font-family:monospace">setClock</SPAN> to <SPAN style="font-family:monospace">checkClock</SPAN> to ensure they match
     in their current time. Further ensure that the timeStep of <SPAN style="font-family:monospace">checkClock</SPAN>
     is a multiple of the timeStep of <SPAN style="font-family:monospace">setClock</SPAN>. If both conditions are 
     satisfied then the stopTime of the <SPAN style="font-family:monospace">setClock</SPAN> is set one 
     <SPAN style="font-family:monospace">checkClock</SPAN> timeStep, or <SPAN style="font-family:monospace">setClock</SPAN> runDuration, ahead of the
     current time, which ever is shorter. The direction of <SPAN style="font-family:monospace">checkClock</SPAN>
     is considered when setting the stopTime.

<P>
By default the startTime of the <SPAN style="font-family:monospace">setClock</SPAN> is not modified. However, if
     <SPAN style="font-family:monospace">setStartTimeToCurrent == .true.</SPAN> the startTime of <SPAN style="font-family:monospace">setClock</SPAN> is set
     to the currentTime of <SPAN style="font-family:monospace">checkClock</SPAN>.

<P>
The arguments are:
     <DL>
<DT><STRONG>setClock</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Clock</SPAN> object to be checked and set.
     
</DD>
<DT><STRONG>checkClock</STRONG></DT>
<DD>The reference clock object.
     
</DD>
<DT><STRONG>[setStartTimeToCurrent]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN> then also set the startTime in <SPAN style="font-family:monospace">setClock</SPAN> according to
       the startTime in <SPAN style="font-family:monospace">checkClock</SPAN>. The default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[currTime]</STRONG></DT>
<DD>If provided, use <SPAN style="font-family:monospace">currTime</SPAN> instead of <SPAN style="font-family:monospace">checkClock</SPAN> when checking
       or setting the current time of <SPAN style="font-family:monospace">setClock</SPAN>.
     
</DD>
<DT><STRONG>[forceCurrTime]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN> then do <EM>not</EM> check the current time of the
       <SPAN style="font-family:monospace">setClock</SPAN>, but instead force it to align with the <SPAN style="font-family:monospace">checkClock</SPAN>,
       or <SPAN style="font-family:monospace">currTime</SPAN>, if it was provided. The default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[checkTimeStep]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN> then check that <SPAN style="font-family:monospace">timeStep</SPAN> of the 
       <SPAN style="font-family:monospace">setClock</SPAN> can reach the next increment on the <SPAN style="font-family:monospace">checkClock</SPAN>
       by an integer number of steps. For <SPAN style="font-family:monospace">.false.</SPAN> do not check this
       condition. The default is <SPAN style="font-family:monospace">.true.</SPAN>.
     
</DD>
<DT><STRONG>[forceTimeStep]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN> then do <EM>not</EM> use the <SPAN style="font-family:monospace">timeStep</SPAN> of the 
       <SPAN style="font-family:monospace">setClock</SPAN> to check if the next increment on the <SPAN style="font-family:monospace">checkClock</SPAN>
       can be reached in an integer number of steps. Instead set the
       <SPAN style="font-family:monospace">timeStep</SPAN> of the <SPAN style="font-family:monospace">setClock</SPAN> to the <SPAN style="font-family:monospace">timeStep</SPAN> of the
       <SPAN style="font-family:monospace">checkClock</SPAN>. The default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00049700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_GetAttribute - Get the value of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeFieldVal(field, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     character(*),     intent(in)            :: name
     character(*),     intent(out)           :: value
     logical,          intent(out), optional :: isPresent
     logical,          intent(out), optional :: isSet
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">field</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the Attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00049800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_GetAttribute - Get the typekind of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeFieldTK(field, name, isPresent, isSet, &amp;
     itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(in)            :: field
     character(*),             intent(in)            :: name
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Query the <SPAN style="font-family:monospace">typekind</SPAN> of the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">field</SPAN>
     using the convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the Attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION00049900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_GetAttribute - Get the value of a NUOPC State Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeState(state, name, value, isPresent, isSet, &amp;
     itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),         intent(in)            :: state
     character(*),             intent(in)            :: name
     character(*),             intent(out), optional :: value
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">state</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <SPAN style="font-family:monospace">isPresent</SPAN> and <SPAN style="font-family:monospace">isSet</SPAN> are provided, return with error if 
     the Attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>[value]</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is present, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the queried attribute is set, <SPAN style="font-family:monospace">.false.</SPAN>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_GetStateMemberLists - Build lists of information of State members</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_GetStateMemberLists(state, StandardNameList, &amp;
     ConnectedList, NamespaceList, CplSetList, itemNameList, fieldList, &amp;
     stateList, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),       intent(in)            :: state
     character(ESMF_MAXSTR), pointer, optional     :: StandardNameList(:)
     character(ESMF_MAXSTR), pointer, optional     :: ConnectedList(:)
     character(ESMF_MAXSTR), pointer, optional     :: NamespaceList(:)
     character(ESMF_MAXSTR), pointer, optional     :: CplSetList(:)
     character(ESMF_MAXSTR), pointer, optional     :: itemNameList(:)
     type(ESMF_Field),       pointer, optional     :: fieldList(:)
     type(ESMF_State),       pointer, optional     :: stateList(:)
     logical,                intent(in), optional  :: nestedFlag
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Construct lists containing the StandardNames, field names, and connected 
     status of the fields in <SPAN style="font-family:monospace">state</SPAN>. Return this information in the
     list arguments. Recursively parse through nested States.

<P>
All pointer arguments present must enter this method unassociated. This
     means that the user code must explicitly call <SPAN style="font-family:monospace">nullify()</SPAN> or use the
     <SPAN style="font-family:monospace">=&gt; null()</SPAN> syntax on the variables passed in as any of the pointer
     arguments. On return, the pointer arguments may either be unassociated or
     associated. Consequently the user code must first check the status of any
     of the returned pointer arguments via the <SPAN style="font-family:monospace">associated()</SPAN> intrinsic
     before accessing the argument. The responsibility for deallocation of
     associated pointer arguments transfers to the caller.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object to be queried.
     
</DD>
<DT><STRONG>[StandardNameList]</STRONG></DT>
<DD>If present, return a list of the "StandardName" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[ConnectedList]</STRONG></DT>
<DD>If present, return a list of the "Connected" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[NamespaceList]</STRONG></DT>
<DD>If present, return a list of the "Namespace" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[CplSetList]</STRONG></DT>
<DD>If present, return a list of the "CplSet" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[itemNameList]</STRONG></DT>
<DD>If present, return a list of each member name.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>If present, return a list of the member fields.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[stateList]</STRONG></DT>
<DD>If present, return a list of the states corresonding to the owner of the
       fields returned under <SPAN style="font-family:monospace">fieldList</SPAN>.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD>When set to .true., returns information from nested States (default).
       When set to .false., returns information at the current State level only.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_GetStateMemberCount - Determing number of State members</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_GetStateMemberCount(state, fieldCount, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),       intent(in)            :: state
     integer,                intent(out), optional :: fieldCount
     logical,                intent(in),  optional :: nestedFlag
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Determine the number of fields in <SPAN style="font-family:monospace">state</SPAN>. By default recursively parse
     through nested States.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object to be queried.
     
</DD>
<DT><STRONG>[fieldCount]</STRONG></DT>
<DD>Number of fields.
     
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD>When set to .true., returns information from nested States (default).
       When set to .false., returns information at the current State level only.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_GetTimestamp - Get the timestamp of a Field</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_GetTimestamp(field, isValid, time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     logical,          intent(out), optional :: isValid
     type(ESMF_Time),  intent(out), optional :: time
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Access the timestamp on <SPAN style="font-family:monospace">field</SPAN> in form of an <SPAN style="font-family:monospace">ESMF_Time</SPAN> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object to be checked.
     
</DD>
<DT><STRONG>[isValid]</STRONG></DT>
<DD>Set to <SPAN style="font-family:monospace">.true.</SPAN> if the timestamp is valid, <SPAN style="font-family:monospace">.false.</SPAN> otherwise.
     
</DD>
<DT><STRONG>[time]</STRONG></DT>
<DD>The timestamp as <SPAN style="font-family:monospace">ESMF_Time</SPAN> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_IngestPetList - Ingest a petList from FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_IngestPetList()
   subroutine NUOPC_IngestPetListFF(petList, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, allocatable,   intent(out)           :: petList(:)
     type(NUOPC_FreeFormat), intent(in),  target   :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Construct a petList from a FreeFormat object.

<P>
The arguments are:
     <DL>
<DT><STRONG>petList</STRONG></DT>
<DD>The constructed petList. The size and content is set by this method.
     
</DD>
<DT><STRONG>freeFormat</STRONG></DT>
<DD>The incoming petList information in free format. The format supports
       two types of elements:
       
<UL>
<LI>Single PET elements consist of a single number referring to the PET.
</LI>
<LI>Block elements consist of two PET numbers, separated by a "-" 
             character. No white spaces are accepted between the dash and the
             PET numbers. A block element includes all of the PETs between the
             lower bound (left PET number), and the upper bound (right PET
             number), bounds inclusive. The upper bound must <EM>not</EM> be
             less than the lower bound. 
       
</LI>
</UL>
       Any number of elements may be listed in the free format. The idividual
       elements are separated by white spaces.

<P>
For an example, the free format petList definition
       <PRE>
       "2-5 12 0 15-23"
</PRE>
       would translate into a <SPAN style="font-family:monospace">petList</SPAN> output of
       <PRE>
       (/2, 3, 4, 5, 12, 0, 15, 16, 17, 18, 19, 20, 21, 22, 23/)
</PRE>
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_IngestPetList - Ingest a petList from HConfig</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_IngestPetList()
   subroutine NUOPC_IngestPetListHC(petList, hconfig, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, allocatable,   intent(out)           :: petList(:)
     type(ESMF_HConfig),     intent(in)            :: hconfig
     integer,                intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Construct a petList from a HConfig object.

<P>
The arguments are:
     <DL>
<DT><STRONG>petList</STRONG></DT>
<DD>The constructed petList. The size and content is set by this method.
     
</DD>
<DT><STRONG>hconfig</STRONG></DT>
<DD>The incoming petList information as HConfig. The provided <SPAN style="font-family:monospace">hconfig</SPAN>
       must be a scalar, or a list of lists and scalars. The input is recursively
       processed, and each scalar fed into the FreeFormat version of the
       <SPAN style="font-family:monospace">NUOPC_IngestPetList()</SPAN> interface as a single string. The resulting
       <SPAN style="font-family:monospace">petList</SPAN> is the union of all PETs determined by all of the elements
       contained in <SPAN style="font-family:monospace">hconfig</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_IsAtTime - Check if a Field is at the given Time</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_IsAtTime()
   function NUOPC_IsAtTimeField(field, time, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsAtTimeField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Returns <SPAN style="font-family:monospace">.true.</SPAN> if <SPAN style="font-family:monospace">field</SPAN> has a timestamp
     that matches <SPAN style="font-family:monospace">time</SPAN>. Otherwise returns <SPAN style="font-family:monospace">.false.</SPAN>. On PETs 
     with only a proxy instance of the field, <SPAN style="font-family:monospace">.true.</SPAN> is returned
     regardless of the actual timestamp.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object to be checked.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The time to compare against.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_IsAtTime - Check if Field(s) in a State are at the given Time</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_IsAtTime()
   function NUOPC_IsAtTimeState(state, time, fieldName, count, fieldList, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsAtTimeState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),              intent(in)            :: state
     type(ESMF_Time),               intent(in)            :: time
     character(*),                  intent(in),  optional :: fieldName
     integer,                       intent(out), optional :: count
     type(ESMF_Field), allocatable, intent(out), optional :: fieldList(:)
     integer,                       intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if the field(s) in <SPAN style="font-family:monospace">state</SPAN> have a timestamp 
     that matches <SPAN style="font-family:monospace">time</SPAN>. Otherwise return <SPAN style="font-family:monospace">.false.</SPAN>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object to be checked.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The time to compare against.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <SPAN style="font-family:monospace">state</SPAN> to be checked. If provided, and 
       the state does not contain a field with <SPAN style="font-family:monospace">fieldName</SPAN>, return an 
       error in <SPAN style="font-family:monospace">rc</SPAN>. If not provided, check <EM>all</EM> the fields contained
       in <SPAN style="font-family:monospace">state</SPAN> and return <SPAN style="font-family:monospace">.true.</SPAN> if all the fields are at the 
       correct time.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are at <SPAN style="font-family:monospace">time</SPAN> are returned. If 
       <SPAN style="font-family:monospace">fieldName</SPAN> is present then <SPAN style="font-family:monospace">count</SPAN> cannot be greater than 1.
     
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>If provided, the fields that are <EM>not</EM> at <SPAN style="font-family:monospace">time</SPAN> are returned. If 
       <SPAN style="font-family:monospace">fieldName</SPAN> is present then <SPAN style="font-family:monospace">fieldList</SPAN> can contain a maximum of
       1 field.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_IsConnected - Check if a Field is connected</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_IsConnected()
   function NUOPC_IsConnectedField(field, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsConnectedField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if the <SPAN style="font-family:monospace">field</SPAN> is connected.
     Otherwise return <SPAN style="font-family:monospace">.false.</SPAN>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object to be checked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">18</SPAN> NUOPC_IsConnected - Check if Field(s) in a State are connected</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_IsConnected()
   function NUOPC_IsConnectedState(state, fieldName, count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsConnectedState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if the field(s) in <SPAN style="font-family:monospace">state</SPAN> are connected. Otherwise
     return <SPAN style="font-family:monospace">.false.</SPAN>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object to be checked.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <SPAN style="font-family:monospace">state</SPAN> to be checked. If provided, and 
       the state does not contain a field with <SPAN style="font-family:monospace">fieldName</SPAN>, return an 
       error in <SPAN style="font-family:monospace">rc</SPAN>. If not provided, check <EM>all</EM> the fields contained
       in <SPAN style="font-family:monospace">state</SPAN> and return <SPAN style="font-family:monospace">.true.</SPAN> if all the fields are connected.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are connected are returned. If 
       <SPAN style="font-family:monospace">fieldName</SPAN> is present then <SPAN style="font-family:monospace">count</SPAN> cannot be greater than 1.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000491900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">19</SPAN> NUOPC_IsUpdated - Check if a Field is marked as updated</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_IsUpdated()
   function NUOPC_IsUpdatedField(field, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsUpdatedField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if the field has its "Updated"
     attribute set to "true". Otherwise return <SPAN style="font-family:monospace">.false.</SPAN>. 

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object to be checked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">20</SPAN> NUOPC_IsUpdated - Check if Field(s) in a State are marked as updated</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_IsUpdated()
   function NUOPC_IsUpdatedState(state, fieldName, count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsUpdatedState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Return <SPAN style="font-family:monospace">.true.</SPAN> if the field(s) in <SPAN style="font-family:monospace">state</SPAN> have the "Updated"
     attribute set to "true". Otherwise return <SPAN style="font-family:monospace">.false.</SPAN>. 

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object to be checked.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <SPAN style="font-family:monospace">state</SPAN> to be checked. If provided, and 
       the state does not contain a field with <SPAN style="font-family:monospace">fieldName</SPAN>, return an 
       error in <SPAN style="font-family:monospace">rc</SPAN>. If not provided, check <EM>all</EM> the fields contained
       in <SPAN style="font-family:monospace">state</SPAN> and return <SPAN style="font-family:monospace">.true.</SPAN> if all the fields are updated.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are updated are returned. If 
       <SPAN style="font-family:monospace">fieldName</SPAN> is present then <SPAN style="font-family:monospace">count</SPAN> cannot be greater than 1.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">21</SPAN> NUOPC_NoOp - No-Operation attachable method for GridComp</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   subroutine NUOPC_NoOp(gcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)   :: gcomp
     integer, intent(out)  :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
No-Op method with an interface that matches the
     requirements for a attachable method for ESMF_GridComp objects.

<P>
The arguments are:
     <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_GridComp</SPAN> object to which this method is attached.
     
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">22</SPAN> NUOPC_Realize - Realize previously advertised Fields inside a State on a single Grid with internal allocation</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteG(state, grid, fieldName, typekind, &amp;
     staggerloc, selection, dataFillScheme, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     type(ESMF_Grid),          intent(in)            :: grid
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     type(ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme    
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_RealizeCompleteG"></A>
<P>
Realize or remove fields inside of <SPAN style="font-family:monospace">state</SPAN> according to <SPAN style="font-family:monospace">selection</SPAN>.
     All of the fields that are realized are created internally on the same 
     <SPAN style="font-family:monospace">grid</SPAN> object, allocating memory for as many field dimensions as there 
     are grid dimensions.

<P>
The type and kind of the created fields is according to argument 
     <SPAN style="font-family:monospace">typekind</SPAN>.

<P>
Realized fields are filled with data according to the <SPAN style="font-family:monospace">dataFillScheme</SPAN>
     argument.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object in which the fields are realized.
     
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Grid</SPAN> object on which to realize the fields.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <SPAN style="font-family:monospace">state</SPAN> to be realized, or removed, according
       to <SPAN style="font-family:monospace">selection</SPAN>. If provided, and the state does not contain a field
       with name <SPAN style="font-family:monospace">fieldName</SPAN>, return an error in <SPAN style="font-family:monospace">rc</SPAN>. If not provided,
       realize <EM>all</EM> the fields contained in <SPAN style="font-family:monospace">state</SPAN> according to 
       <SPAN style="font-family:monospace">selection</SPAN>.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the internally created field(s). The valid options are
       <SPAN style="font-family:monospace">ESMF_TYPEKIND_I4</SPAN>, <SPAN style="font-family:monospace">ESMF_TYPEKIND_I8</SPAN>,
       <SPAN style="font-family:monospace">ESMF_TYPEKIND_R4</SPAN>, and <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN>.
       By default use the <SPAN style="font-family:monospace">typekind</SPAN> of the partially created field used
       during advertise, or <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN>, if the advertised field 
       did not have a <SPAN style="font-family:monospace">typekind</SPAN> defined.
     
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. By default use the same
       stagger location as the advertising field, or 
       <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN> if the advertising field was created empty.
     
</DD>
<DT><STRONG>[selection]</STRONG></DT>
<DD>Selection of mode of operation:
       
<UL>
<LI><SPAN style="font-family:monospace">"realize_all"</SPAN> (default)
</LI>
<LI><SPAN style="font-family:monospace">"realize_connected_remove_others"</SPAN>
</LI>
<LI><SPAN style="font-family:monospace">"realize_connected+provide_remove_others"</SPAN>
       
</LI>
</UL>
     
</DD>
<DT><STRONG>[dataFillScheme]</STRONG></DT>
<DD>Realized fields will be filled according to the selected fill
       scheme. See <SPAN style="font-family:monospace">ESMF_FieldFill()</SPAN> for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the completed field that was realized by this method. This option
       is only supported if also argument <SPAN style="font-family:monospace">fieldName</SPAN> was specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">23</SPAN> NUOPC_Realize - Realize previously advertised Fields inside a State on a single LocStream with internal allocation</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteLS(state, locstream, fieldName, typekind, selection,&amp;
     dataFillScheme, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     type(ESMF_LocStream),     intent(in)            :: locstream
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme    
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_RealizeCompleteLS"></A>
<P>
Realize or remove fields inside of <SPAN style="font-family:monospace">state</SPAN> according to <SPAN style="font-family:monospace">selection</SPAN>.
     All of the fields that are realized are created internally on the same 
     <SPAN style="font-family:monospace">locstream</SPAN> object, allocating memory accordingly.

<P>
The type and kind of the created fields is according to argument 
     <SPAN style="font-family:monospace">typekind</SPAN>.

<P>
Realized fields are filled with data according to the <SPAN style="font-family:monospace">dataFillScheme</SPAN>
     argument.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object in which the fields are realized.
     
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_LocStream</SPAN> object on which to realize the fields.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <SPAN style="font-family:monospace">state</SPAN> to be realized, or removed, according
       to <SPAN style="font-family:monospace">selection</SPAN>. If provided, and the state does not contain a field
       with name <SPAN style="font-family:monospace">fieldName</SPAN>, return an error in <SPAN style="font-family:monospace">rc</SPAN>. If not provided,
       realize <EM>all</EM> the fields contained in <SPAN style="font-family:monospace">state</SPAN> according to 
       <SPAN style="font-family:monospace">selection</SPAN>.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the internally created field(s). The valid options are
       <SPAN style="font-family:monospace">ESMF_TYPEKIND_I4</SPAN>, <SPAN style="font-family:monospace">ESMF_TYPEKIND_I8</SPAN>,
       <SPAN style="font-family:monospace">ESMF_TYPEKIND_R4</SPAN>, and <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN>.
       By default use the <SPAN style="font-family:monospace">typekind</SPAN> of the partially created field used
       during advertise, or <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN>, if the advertised field 
       did not have a <SPAN style="font-family:monospace">typekind</SPAN> defined.
     
</DD>
<DT><STRONG>[selection]</STRONG></DT>
<DD>Selection of mode of operation:
       
<UL>
<LI><SPAN style="font-family:monospace">"realize_all"</SPAN> (default)
</LI>
<LI><SPAN style="font-family:monospace">"realize_connected_remove_others"</SPAN>
       
</LI>
</UL>
     
</DD>
<DT><STRONG>[dataFillScheme]</STRONG></DT>
<DD>Realized fields will be filled according to the selected fill
       scheme. See <SPAN style="font-family:monospace">ESMF_FieldFill()</SPAN> for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the completed field that was realized by this method. This option
       is only supported if also argument <SPAN style="font-family:monospace">fieldName</SPAN> was specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">24</SPAN> NUOPC_Realize - Realize previously advertised Fields inside a State on a single Mesh with internal allocation</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteM(state, mesh, fieldName, typekind, &amp;
     meshloc, selection, dataFillScheme, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     type(ESMF_Mesh),          intent(in)            :: mesh
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     type(ESMF_MeshLoc),       intent(in),  optional :: meshloc
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_RealizeCompleteM"></A>
<P>
Realize or remove fields inside of <SPAN style="font-family:monospace">state</SPAN> according to <SPAN style="font-family:monospace">selection</SPAN>.
     All of the fields that are realized are created internally on the same 
     <SPAN style="font-family:monospace">mesh</SPAN> object, allocating memory accordingly.

<P>
The type and kind of the created fields is according to argument 
     <SPAN style="font-family:monospace">typekind</SPAN>.

<P>
Realized fields are filled with data according to the <SPAN style="font-family:monospace">dataFillScheme</SPAN>
     argument.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object in which the fields are realized.
     
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Mesh</SPAN> object on which to realize the fields.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <SPAN style="font-family:monospace">state</SPAN> to be realized, or removed, according
       to <SPAN style="font-family:monospace">selection</SPAN>. If provided, and the state does not contain a field
       with name <SPAN style="font-family:monospace">fieldName</SPAN>, return an error in <SPAN style="font-family:monospace">rc</SPAN>. If not provided,
       realize <EM>all</EM> the fields contained in <SPAN style="font-family:monospace">state</SPAN> according to 
       <SPAN style="font-family:monospace">selection</SPAN>.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the internally created field(s). The valid options are
       <SPAN style="font-family:monospace">ESMF_TYPEKIND_I4</SPAN>, <SPAN style="font-family:monospace">ESMF_TYPEKIND_I8</SPAN>,
       <SPAN style="font-family:monospace">ESMF_TYPEKIND_R4</SPAN>, and <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN>.
       By default use the <SPAN style="font-family:monospace">typekind</SPAN> of the partially created field used
       during advertise, or <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN>, if the advertised field 
       did not have a <SPAN style="font-family:monospace">typekind</SPAN> defined.
     
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Location of data in the mesh cell. By default use the same
       mesh location as the advertising field, or 
       <SPAN style="font-family:monospace">ESMF_STAGGERLOC_NODE</SPAN> if the advertising field was created empty.
     
</DD>
<DT><STRONG>[selection]</STRONG></DT>
<DD>Selection of mode of operation:
       
<UL>
<LI><SPAN style="font-family:monospace">"realize_all"</SPAN> (default)
</LI>
<LI><SPAN style="font-family:monospace">"realize_connected_remove_others"</SPAN>
       
</LI>
</UL>
     
</DD>
<DT><STRONG>[dataFillScheme]</STRONG></DT>
<DD>Realized fields will be filled according to the selected fill
       scheme. See <SPAN style="font-family:monospace">ESMF_FieldFill()</SPAN> for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the completed field that was realized by this method. This option
       is only supported if also argument <SPAN style="font-family:monospace">fieldName</SPAN> was specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">25</SPAN> NUOPC_Realize - Realize a previously advertised Field in a State</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeField(state, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_RealizeField"></A>
<P>
Realize a previously advertised field in <SPAN style="font-family:monospace">state</SPAN> by replacing the
     advertised field with <SPAN style="font-family:monospace">field</SPAN> of the same name.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object in which the fields are realized.
     
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>The new field to put in place of the previously advertised (empty) field.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">26</SPAN> NUOPC_Realize - Realize a previously advertised Field in a State after Transfer of GeomObject</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeTransfer(state, fieldName, typekind, gridToFieldMap, &amp;
     ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, &amp;
     realizeOnlyConnected, removeNotConnected, realizeOnlyNotShared, &amp;
     realizeOnlyNotComplete, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     character(*),             intent(in)            :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     integer, target,          intent(in),  optional :: gridToFieldMap(:)
     integer, target,          intent(in),  optional :: ungriddedLBound(:)
     integer, target,          intent(in),  optional :: ungriddedUBound(:)
     integer,                  intent(in),  optional :: totalLWidth(:)
     integer,                  intent(in),  optional :: totalUWidth(:)
     logical,                  intent(in),  optional :: realizeOnlyConnected
     logical,                  intent(in),  optional :: removeNotConnected
     logical,                  intent(in),  optional :: realizeOnlyNotShared
     logical,                  intent(in),  optional :: realizeOnlyNotComplete
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="NUOPC_RealizeTransfer"></A>
<P>
Realize a field where GeomObject has been set by the NUOPC GeomObject
     transfer protocol.

<P>
The data of the realized field is left uninitialized by this method.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object in which the field is realized.
     
</DD>
<DT><STRONG>fieldName</STRONG></DT>
<DD>The name of the field in <SPAN style="font-family:monospace">state</SPAN> to be realized. If <SPAN style="font-family:monospace">state</SPAN> does
       not contain a field with name <SPAN style="font-family:monospace">fieldName</SPAN>, return an error in 
       <SPAN style="font-family:monospace">rc</SPAN>.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the internally created field(s). The valid options are
       <SPAN style="font-family:monospace">ESMF_TYPEKIND_I4</SPAN>, <SPAN style="font-family:monospace">ESMF_TYPEKIND_I8</SPAN>,
       <SPAN style="font-family:monospace">ESMF_TYPEKIND_R4</SPAN>, and <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN>.
       By default use the <SPAN style="font-family:monospace">typekind</SPAN> of the connected provider field.
     
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>The mapping of grid/mesh dimensions against field dimensions. The argument
       is of rank 1 and with a size of dimCount. The elements correspond to the
       grid/mesh elements in order, and associates it with the indicated 
       field dimension. Only entries between 1 and the field rank are allowed.
       There must be no duplicate entries in <SPAN style="font-family:monospace">gridToFieldMap</SPAN>.
       By default use the <SPAN style="font-family:monospace">gridToFieldMap</SPAN> of the connected provider field.
     
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of
       elements defines the number of ungridded dimensions of the field and 
       must be consistent with <SPAN style="font-family:monospace">ungriddedUBound</SPAN>.
       By default use the <SPAN style="font-family:monospace">ungriddedLBound</SPAN> of the connected provider field.
     
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of
       elements defines the number of ungridded dimensions of the field and 
       must be consistent with <SPAN style="font-family:monospace">ungriddedLBound</SPAN>.
       By default use the <SPAN style="font-family:monospace">ungriddedLBound</SPAN> of the connected provider field.
     
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD><EM>This argument is only supported for fields defined on
       <SPAN style="font-family:monospace">ESMF_Grid</SPAN>.</EM>
       The number elements outside the lower bound of the exclusive region.
       The argument is of rank 1 and with a size of dimCount, the number of
       gridded dimensions of the field. The ordering of the dimensions is that
       of the field (considering <SPAN style="font-family:monospace">gridToFieldMap</SPAN>).
       By default a zero vector is used, resulting in no elements outside the
       exclusive region.
     
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD><EM>This argument is only supported for fields defined on
       <SPAN style="font-family:monospace">ESMF_Grid</SPAN>.</EM>
       The number elements outside the upper bound of the exclusive region.
       The argument is of rank 1 and with a size of dimCount, the number of
       gridded dimensions of the field. The ordering of the dimensions is that
       of the field (considering <SPAN style="font-family:monospace">gridToFieldMap</SPAN>).
       By default a zero vector is used, resulting in no elements outside the
       exclusive region.
     
</DD>
<DT><STRONG>[realizeOnlyConnected]</STRONG></DT>
<DD>If set to <SPAN style="font-family:monospace">.false.</SPAN>, realize the specified field irregardless of the
       connected status. If set to <SPAN style="font-family:monospace">.true.</SPAN>, only a connected field will be
       realized. The default is <SPAN style="font-family:monospace">.true.</SPAN>.
     
</DD>
<DT><STRONG>[removeNotConnected]</STRONG></DT>
<DD>If set to <SPAN style="font-family:monospace">.false.</SPAN>, do not remove a field from the state due to its
       connected status. If set to <SPAN style="font-family:monospace">.true.</SPAN>, remove the field if it is not
       connected. This requires <SPAN style="font-family:monospace">realizeOnlyConnected</SPAN> to be <SPAN style="font-family:monospace">.true.</SPAN>,
       and a runtime error will be returned otherwise.
       The default is <SPAN style="font-family:monospace">.true.</SPAN>.
     
</DD>
<DT><STRONG>[realizeOnlyNotShared]</STRONG></DT>
<DD>If set to <SPAN style="font-family:monospace">.false.</SPAN>, realize the specified field irregardless of its
       shared status. If set to <SPAN style="font-family:monospace">.true.</SPAN>, only a field that has 
       "ShareStatusField" set to "not shared" will be realized.
       The default is <SPAN style="font-family:monospace">.true.</SPAN>.
     
</DD>
<DT><STRONG>[realizeOnlyNotComplete]</STRONG></DT>
<DD>If set to <SPAN style="font-family:monospace">.false.</SPAN>, realize the specified field irregardless of its
       complete status. If set to <SPAN style="font-family:monospace">.true.</SPAN>, only a field that has not yet
       been completed will be realized.
       The default is <SPAN style="font-family:monospace">.true.</SPAN>.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the completed field that was realized by this method. An invalid
       field object will be returned if the conditions were such that the field
       was  not realized.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">27</SPAN> NUOPC_SetAttribute - Set the value of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_SetAttribute()
   subroutine NUOPC_SetAttributeField(field, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field)                      :: field
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">field</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object on which to set the attribute.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the set attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the set attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">28</SPAN> NUOPC_SetAttribute - Set the value of a NUOPC State Attribute</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_SetAttribute()
   subroutine NUOPC_SetAttributeState(state, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                      :: state
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the attribute <SPAN style="font-family:monospace">name</SPAN> inside of <SPAN style="font-family:monospace">state</SPAN> using the
     convention <SPAN style="font-family:monospace">NUOPC</SPAN> and purpose <SPAN style="font-family:monospace">Instance</SPAN>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object on which to set the attribute.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the set attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the set attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000492900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">29</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on a Field</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampField(field, time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout)         :: field
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the TimeStamp according to <SPAN style="font-family:monospace">time</SPAN> on <SPAN style="font-family:monospace">field</SPAN>.

<P>
This call should rarely be needed in user written code.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object to be time stampped.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Time</SPAN> object defining the TimeStamp.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000493000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">30</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on Fields in a list</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampFieldList(fieldList, time, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout)         :: fieldList(:)
     type(ESMF_Time),  intent(in)            :: time
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the TimeStamp according to <SPAN style="font-family:monospace">time</SPAN> on <SPAN style="font-family:monospace">field</SPAN>.

<P>
This call should rarely be needed in user written code.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldList</STRONG></DT>
<DD>The list of <SPAN style="font-family:monospace">ESMF_Field</SPAN> objects to be time stampped.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Time</SPAN> object defining the TimeStamp.
     
</DD>
<DT><STRONG>[selective]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN>, then only set the TimeStamp on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       TimeStamp on all the fields. Default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000493100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">31</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on Fields in a list from Clock</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampFieldListClk(fieldList, clock, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout)         :: fieldList(:)
     type(ESMF_Clock), intent(in)            :: clock
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the TimeStamp according to <SPAN style="font-family:monospace">time</SPAN> on <SPAN style="font-family:monospace">field</SPAN>.

<P>
This call should rarely be needed in user written code.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldList</STRONG></DT>
<DD>The list of <SPAN style="font-family:monospace">ESMF_Field</SPAN> objects to be time stampped.
     
</DD>
<DT><STRONG>clock</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Clock</SPAN> object defining the TimeStamp by its current time.
     
</DD>
<DT><STRONG>[selective]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN>, then only set the TimeStamp on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       TimeStamp on all the fields. Default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000493200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">32</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on all the Fields in a State</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampState(state, time, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Time),  intent(in)            :: time
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the TimeStamp according to <SPAN style="font-family:monospace">clock</SPAN> on all the fields in
     <SPAN style="font-family:monospace">state</SPAN>. Depending on <SPAN style="font-family:monospace">selective</SPAN>, all or only some fields may be
     updated.

<P>
This call should rarely be needed in user written code. It is used 
     by the generic Connector.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object holding the fields to be time stampped.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Time</SPAN> object defining the TimeStamp.
     
</DD>
<DT><STRONG>[selective]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN>, then only set the TimeStamp on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       TimeStamp on all the fields. Default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000493300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">33</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on all the Fields in a State from Clock</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampStateClk(state, clock, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Clock), intent(in)            :: clock
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Set the TimeStamp according to <SPAN style="font-family:monospace">clock</SPAN> on all the fields in
     <SPAN style="font-family:monospace">state</SPAN>. Depending on <SPAN style="font-family:monospace">selective</SPAN>, all or only some fields may be
     updated.

<P>
This call should rarely be needed in user written code. It is used 
     by the generic Connector.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object holding the fields to be time stampped.
     
</DD>
<DT><STRONG>clock</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Clock</SPAN> object defining the TimeStamp by its current time.
     
</DD>
<DT><STRONG>[selective]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN>, then only set the TimeStamp on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       TimeStamp on all the fields. Default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<H2><A ID="SECTION000410000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Auxiliary Routines</A>
</H2>
Auxiliary routines are provided with the NUOPC Layer as a convenience to the
user. Typically more work is needed on these methods before considering them
NUOPC core functionality.

<P>

<P>

<P>

<H3><A ID="SECTION000410100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_Write - Write a distributed interpolation matrix to file in SCRIP format</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_SCRIPWrite(factorList, factorIndexList, fileName, &amp;
     relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(in), target    :: factorList(:)
     integer,            intent(in), target    :: factorIndexList(:,:) 
     character(*),       intent(in)            :: fileName
     logical,            intent(in),  optional :: relaxedflag
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
<A ID="api_NUOPC_SCRIPWrite"></A>     Write the destributed interpolaton matrix provided by <SPAN style="font-family:monospace">factorList</SPAN> 
     and <SPAN style="font-family:monospace">factorIndexList</SPAN> to a SCRIP formatted NetCDF file. Each PET calls
     with its local list of factors and indices. The call then writes the 
     distributed factors into a single file. If the file already exists, the
     contents is replaced by this call.

<P>
The arguments are:
     <DL>
<DT><STRONG>factorList</STRONG></DT>
<DD>The distributed factor list.
     
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>The distributed list of source and destination indices.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file to be written to.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN>, then no error is returned even if the call cannot write
       the file due to library limitations. Default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000410200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_Write - Write a distributed factorList to file</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_FactorsWrite(factorList, fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), pointer               :: factorList(:)
     character(*),       intent(in)            :: fileName
     integer,            intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
THIS METHOD IS DEPRECATED. Use <A HREF="#api_NUOPC_SCRIPWrite">3.10.1</A> instead.

<P>
Write the destributed <SPAN style="font-family:monospace">factorList</SPAN> to file. Each PET calls with its 
     local list of factors. The call then writes the distributed factors into
     a single file. The order of the factors in the file is first by PET, and 
     within each PET the PET-local order is preserved. Changing the number of 
     PETs for the same regrid operation will likely change the order of factors
     across PETs, and therefore files written will differ.

<P>
The arguments are:
     <DL>
<DT><STRONG>factorList</STRONG></DT>
<DD>The distributed factor list.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file to be written to.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000410300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_Write - Write Field data to file</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_FieldWrite(field, fileName, overwrite, status, timeslice, &amp;
     iofmt, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),           intent(in)            :: field
     character(*),               intent(in)            :: fileName
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     logical,                    intent(in),  optional :: relaxedflag
     integer,                    intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Write the data in <SPAN style="font-family:monospace">field</SPAN> to <SPAN style="font-family:monospace">file</SPAN> under the field's "StandardName" 
     attribute if supported by the <SPAN style="font-family:monospace">iofmt</SPAN>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_Field</SPAN> object whose data is to be written.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file to write to.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Field data may
        <EM>not</EM> be overwritten. If .true., the
        data corresponding to each field's name will be
        be overwritten. If the <SPAN style="font-family:monospace">timeslice</SPAN> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
     
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Valid options are <SPAN style="font-family:monospace">ESMF_FILESTATUS_NEW</SPAN>, 
        <SPAN style="font-family:monospace">ESMF_FILESTATUS_OLD</SPAN>, <SPAN style="font-family:monospace">ESMF_FILESTATUS_REPLACE</SPAN>, and
        <SPAN style="font-family:monospace">ESMF_FILESTATUS_UNKNOWN</SPAN> (default).
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Time slice counter. Must be positive. The behavior of this
       option may depend on the setting of the <SPAN style="font-family:monospace">overwrite</SPAN> flag:
       <DL>
<DT><STRONG><SPAN style="font-family:monospace">overwrite = .false.</SPAN>:</STRONG></DT>
<DD> If the timeslice value is
       less than the maximum time already in the file, the write will fail.
       
</DD>
<DT><STRONG><SPAN style="font-family:monospace">overwrite = .true.</SPAN>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
       
</DD>
</DL>
       By default, i.e. by omitting the <SPAN style="font-family:monospace">timeslice</SPAN> argument, no
       provisions for time slicing are made in the output file,
       however, if the file already contains a time axis for the variable,
       a timeslice one greater than the maximum will be written.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Supported options are <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF</SPAN>,
       <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF4P</SPAN>, and <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF4C</SPAN>. If not
       present, defaults to <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF</SPAN>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN>, then no error is returned even if the call cannot write
       the file due to library limitations, or because <SPAN style="font-family:monospace">field</SPAN> does not 
       contain any data. Default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000410400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_Write - Write the Fields within a State to NetCDF files</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_StateWrite(state, fieldNameList, fileNamePrefix, overwrite, &amp;
     status, timeslice, iofmt, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),           intent(in)            :: state
     character(len=*),           intent(in),  optional :: fieldNameList(:)
     character(len=*),           intent(in),  optional :: fileNamePrefix
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     logical,                    intent(in),  optional :: relaxedflag
     integer,                    intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Write the data of the fields contained in <SPAN style="font-family:monospace">state</SPAN> to NetCDF files.
     Each field is written to an individual file using its "StandardName"
     attribute as its NetCDF attribute.
     FieldBundle objects that are encountered within <SPAN style="font-family:monospace">state</SPAN> are traversed,
     and the contained fields are handled in the same manner as fields directly
     held by the <SPAN style="font-family:monospace">state</SPAN> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_State</SPAN> object containing the fields written.
     
</DD>
<DT><STRONG>[fieldNameList]</STRONG></DT>
<DD>List of names of the fields to be written. By default write all the fields
       in <SPAN style="font-family:monospace">state</SPAN>.
     
</DD>
<DT><STRONG>[fileNamePrefix]</STRONG></DT>
<DD>File name prefix, common to all the files written.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing file data may
        <EM>not</EM> be overwritten. If .true., the
        data corresponding to each field's name will be
        be overwritten. If the <SPAN style="font-family:monospace">timeslice</SPAN> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
     
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Valid options are <SPAN style="font-family:monospace">ESMF_FILESTATUS_NEW</SPAN>,
        <SPAN style="font-family:monospace">ESMF_FILESTATUS_OLD</SPAN>, <SPAN style="font-family:monospace">ESMF_FILESTATUS_REPLACE</SPAN>, and
        <SPAN style="font-family:monospace">ESMF_FILESTATUS_UNKNOWN</SPAN> (default).
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Time slice counter. Must be positive. The behavior of this
       option may depend on the setting of the <SPAN style="font-family:monospace">overwrite</SPAN> flag:
       <DL>
<DT><STRONG><SPAN style="font-family:monospace">overwrite = .false.</SPAN>:</STRONG></DT>
<DD> If the timeslice value is
       less than the maximum time already in the file, the write will fail.
       
</DD>
<DT><STRONG><SPAN style="font-family:monospace">overwrite = .true.</SPAN>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
       
</DD>
</DL>
       By default, i.e. by omitting the <SPAN style="font-family:monospace">timeslice</SPAN> argument, no
       provisions for time slicing are made in the output file,
       however, if the file already contains a time axis for the variable,
       a timeslice one greater than the maximum will be written.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Supported options are <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF</SPAN>,
       <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF4P</SPAN>, and <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF4C</SPAN>. If not
       present, defaults to <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF</SPAN>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN>, then no error is returned even if the call cannot write
       the file due to library limitations. Default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A ID="SECTION000410500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_Write - Write the Fields within a FieldBundle to NetCDF files</A>
</H3>

<P>

<P><P>
<BR>
<SPAN style="font-family:sans-serif">INTERFACE:</SPAN>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_FieldBundleWrite(fieldbundle, fieldNameList, fileNamePrefix, overwrite, &amp;
     status, timeslice, iofmt, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),     intent(in)            :: fieldbundle
     character(len=*),           intent(in),  optional :: fieldNameList(:)
     character(len=*),           intent(in),  optional :: fileNamePrefix
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     logical,                    intent(in),  optional :: relaxedflag
     integer,                    intent(out), optional :: rc
</PRE>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

<P>
Write the data of the fields contained in <SPAN style="font-family:monospace">fieldbundle</SPAN> to NetCDF files.
     Each field is written to an individual file using its "StandardName"
     attribute as its NetCDF attribute.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>The <SPAN style="font-family:monospace">ESMF_FieldBundle</SPAN> object containing the fields.
     
</DD>
<DT><STRONG>[fieldNameList]</STRONG></DT>
<DD>List of names of the fields to be written. By default write all the fields
       in <SPAN style="font-family:monospace">fieldbundle</SPAN>.
     
</DD>
<DT><STRONG>[fileNamePrefix]</STRONG></DT>
<DD>File name prefix, common to all the files written.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Field data may
        <EM>not</EM> be overwritten. If .true., the
        data corresponding to each field's name will be
        be overwritten. If the <SPAN style="font-family:monospace">timeslice</SPAN> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
     
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Valid options are <SPAN style="font-family:monospace">ESMF_FILESTATUS_NEW</SPAN>,
        <SPAN style="font-family:monospace">ESMF_FILESTATUS_OLD</SPAN>, <SPAN style="font-family:monospace">ESMF_FILESTATUS_REPLACE</SPAN>, and
        <SPAN style="font-family:monospace">ESMF_FILESTATUS_UNKNOWN</SPAN> (default).
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Time slice counter. Must be positive. The behavior of this
       option may depend on the setting of the <SPAN style="font-family:monospace">overwrite</SPAN> flag:
       <DL>
<DT><STRONG><SPAN style="font-family:monospace">overwrite = .false.</SPAN>:</STRONG></DT>
<DD> If the timeslice value is
       less than the maximum time already in the file, the write will fail.
       
</DD>
<DT><STRONG><SPAN style="font-family:monospace">overwrite = .true.</SPAN>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
       
</DD>
</DL>
       By default, i.e. by omitting the <SPAN style="font-family:monospace">timeslice</SPAN> argument, no
       provisions for time slicing are made in the output file,
       however, if the file already contains a time axis for the variable,
       a timeslice one greater than the maximum will be written.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Supported options are <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF</SPAN>,
       <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF4P</SPAN>, and <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF4C</SPAN>. If not
       present, defaults to <SPAN style="font-family:monospace">ESMF_IOFMT_NETCDF</SPAN>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <SPAN style="font-family:monospace">.true.</SPAN>, then no error is returned even if the call cannot write
       the file due to library limitations. Default is <SPAN style="font-family:monospace">.false.</SPAN>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <SPAN style="font-family:monospace">ESMF_SUCCESS</SPAN> if there are no errors.
     
</DD>
</DL>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html409"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node5.html">4 Standardized Component Dependencies</A>
<B> Up:</B> <A
 HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A
 HREF="node3.html">2 Design and Implementation Notes</A>
 &nbsp; <B>  <A ID="tex2html410"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
