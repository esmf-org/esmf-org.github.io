<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>4 Infrastructure: Fields and Grids</TITLE>
<META NAME="description" CONTENT="4 Infrastructure: Fields and Grids">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node6.html">
<LINK REL="previous" HREF="node4.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node6.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html2267"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2263"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2257"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2265"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2268"
  HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html2264"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html2258"
  HREF="node4.html">3 Superstructure</A>
 &nbsp; <B>  <A NAME="tex2html2266"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><A NAME="tex2html2269"
  HREF="node5.html#SECTION05010000000000000000"><SPAN CLASS="arabic">24</SPAN> Overview of Data Classes</A>
<UL>
<LI><A NAME="tex2html2270"
  HREF="node5.html#SECTION05011000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">1</SPAN> Bit-for-Bit Considerations</A>
<LI><A NAME="tex2html2271"
  HREF="node5.html#SECTION05012000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN> Regrid</A>
<UL>
<LI><A NAME="tex2html2272"
  HREF="node5.html#SECTION05012100000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Interpolation methods: bilinear</A>
<LI><A NAME="tex2html2273"
  HREF="node5.html#SECTION05012200000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Interpolation methods: higher-order patch</A>
<LI><A NAME="tex2html2274"
  HREF="node5.html#SECTION05012300000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Interpolation methods: nearest source to destination</A>
<LI><A NAME="tex2html2275"
  HREF="node5.html#SECTION05012400000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Interpolation methods: nearest destination to source</A>
<LI><A NAME="tex2html2276"
  HREF="node5.html#SECTION05012500000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Interpolation methods: first-order conservative</A>
<LI><A NAME="tex2html2277"
  HREF="node5.html#SECTION05012600000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Interpolation methods: second-order conservative</A>
<LI><A NAME="tex2html2278"
  HREF="node5.html#SECTION05012700000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Conservation</A>
<LI><A NAME="tex2html2279"
  HREF="node5.html#SECTION05012800000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> The effect of normalization options on integrals and values produced by conservative methods</A>
<LI><A NAME="tex2html2280"
  HREF="node5.html#SECTION05012900000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">9</SPAN> Great circle cells</A>
<LI><A NAME="tex2html2281"
  HREF="node5.html#SECTION050121000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">10</SPAN> Masking</A>
<LI><A NAME="tex2html2282"
  HREF="node5.html#SECTION050121100000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">11</SPAN> Extrapolation methods: overview</A>
<LI><A NAME="tex2html2283"
  HREF="node5.html#SECTION050121200000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">12</SPAN> Extrapolation methods: nearest source to destination</A>
<LI><A NAME="tex2html2284"
  HREF="node5.html#SECTION050121300000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">13</SPAN> Extrapolation methods: inverse distance weighted average</A>
<LI><A NAME="tex2html2285"
  HREF="node5.html#SECTION050121400000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">14</SPAN> Extrapolation methods: creep fill</A>
<LI><A NAME="tex2html2286"
  HREF="node5.html#SECTION050121500000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">15</SPAN> Unmapped destination points</A>
<LI><A NAME="tex2html2287"
  HREF="node5.html#SECTION050121600000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN> Spherical grids and poles</A>
<LI><A NAME="tex2html2288"
  HREF="node5.html#SECTION050121700000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">17</SPAN> Troubleshooting guide</A>
<LI><A NAME="tex2html2289"
  HREF="node5.html#SECTION050121800000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">18</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2290"
  HREF="node5.html#SECTION050121900000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">19</SPAN> Design and implementation notes</A>
</UL>
<LI><A NAME="tex2html2291"
  HREF="node5.html#SECTION05013000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN> File-based Regrid API</A>
<UL>
<LI><A NAME="tex2html2292"
  HREF="node5.html#SECTION05013100000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_RegridWeightGen</A>
<LI><A NAME="tex2html2293"
  HREF="node5.html#SECTION05013200000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_RegridWeightGen</A>
<LI><A NAME="tex2html2294"
  HREF="node5.html#SECTION05013300000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_FileRegrid</A>
</UL>
<LI><A NAME="tex2html2295"
  HREF="node5.html#SECTION05014000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</UL>
<LI><A NAME="tex2html2296"
  HREF="node5.html#SECTION05020000000000000000"><SPAN CLASS="arabic">25</SPAN> FieldBundle Class</A>
<UL>
<LI><A NAME="tex2html2297"
  HREF="node5.html#SECTION05021000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2298"
  HREF="node5.html#SECTION05022000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2299"
  HREF="node5.html#SECTION05022100000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating a FieldBundle from a list of Fields</A>
<LI><A NAME="tex2html2300"
  HREF="node5.html#SECTION05022200000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Creating an empty FieldBundle then add one Field to it</A>
<LI><A NAME="tex2html2301"
  HREF="node5.html#SECTION05022300000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Creating an empty FieldBundle then add a list of Fields to it</A>
<LI><A NAME="tex2html2302"
  HREF="node5.html#SECTION05022400000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Query a Field stored in the FieldBundle by name or index</A>
<LI><A NAME="tex2html2303"
  HREF="node5.html#SECTION05022500000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Query FieldBundle for Fields list either alphabetical or in order of addition</A>
<LI><A NAME="tex2html2304"
  HREF="node5.html#SECTION05022600000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create a packed FieldBundle on a Grid</A>
<LI><A NAME="tex2html2305"
  HREF="node5.html#SECTION05022700000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Create a packed FieldBundle on a Mesh</A>
<LI><A NAME="tex2html2306"
  HREF="node5.html#SECTION05022800000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Destroy a FieldBundle</A>
<LI><A NAME="tex2html2307"
  HREF="node5.html#SECTION05022900000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">9</SPAN> Redistribute data from a source FieldBundle to a destination FieldBundle</A>
<LI><A NAME="tex2html2308"
  HREF="node5.html#SECTION050221000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">10</SPAN> Redistribute data from a packed source FieldBundle to a packed destination FieldBundle</A>
<LI><A NAME="tex2html2309"
  HREF="node5.html#SECTION050221100000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">11</SPAN> Perform sparse matrix multiplication from a source FieldBundle 
    to a destination FieldBundle</A>
<LI><A NAME="tex2html2310"
  HREF="node5.html#SECTION050221200000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">12</SPAN> Perform FieldBundle halo update</A>
</UL>
<LI><A NAME="tex2html2311"
  HREF="node5.html#SECTION05023000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2312"
  HREF="node5.html#SECTION05024000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2313"
  HREF="node5.html#SECTION05025000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API: Basic FieldBundle Methods</A>
<UL>
<LI><A NAME="tex2html2314"
  HREF="node5.html#SECTION05025100000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_FieldBundleAssignment(=)</A>
<LI><A NAME="tex2html2315"
  HREF="node5.html#SECTION05025200000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_FieldBundleOperator(==)</A>
<LI><A NAME="tex2html2316"
  HREF="node5.html#SECTION05025300000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_FieldBundleOperator(/=)</A>
<LI><A NAME="tex2html2317"
  HREF="node5.html#SECTION05025400000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_FieldBundleAdd</A>
<LI><A NAME="tex2html2318"
  HREF="node5.html#SECTION05025500000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_FieldBundleAddReplace</A>
<LI><A NAME="tex2html2319"
  HREF="node5.html#SECTION05025600000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html2320"
  HREF="node5.html#SECTION05025700000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html2321"
  HREF="node5.html#SECTION05025800000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html2322"
  HREF="node5.html#SECTION05025900000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_FieldBundleDestroy</A>
<LI><A NAME="tex2html2323"
  HREF="node5.html#SECTION050251000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html2324"
  HREF="node5.html#SECTION050251100000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html2325"
  HREF="node5.html#SECTION050251200000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html2326"
  HREF="node5.html#SECTION050251300000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html2327"
  HREF="node5.html#SECTION050251400000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_FieldBundleHalo</A>
<LI><A NAME="tex2html2328"
  HREF="node5.html#SECTION050251500000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_FieldBundleHaloRelease</A>
<LI><A NAME="tex2html2329"
  HREF="node5.html#SECTION050251600000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_FieldBundleHaloStore</A>
<LI><A NAME="tex2html2330"
  HREF="node5.html#SECTION050251700000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_FieldBundleIsCreated</A>
<LI><A NAME="tex2html2331"
  HREF="node5.html#SECTION050251800000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_FieldBundlePrint</A>
<LI><A NAME="tex2html2332"
  HREF="node5.html#SECTION050251900000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_FieldBundleRead</A>
<LI><A NAME="tex2html2333"
  HREF="node5.html#SECTION050252000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_FieldBundleRedist</A>
<LI><A NAME="tex2html2334"
  HREF="node5.html#SECTION050252100000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_FieldBundleRedistRelease</A>
<LI><A NAME="tex2html2335"
  HREF="node5.html#SECTION050252200000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_FieldBundleRedistStore</A>
<LI><A NAME="tex2html2336"
  HREF="node5.html#SECTION050252300000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_FieldBundleRedistStore</A>
<LI><A NAME="tex2html2337"
  HREF="node5.html#SECTION050252400000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_FieldBundleRegrid</A>
<LI><A NAME="tex2html2338"
  HREF="node5.html#SECTION050252500000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_FieldBundleRegridRelease</A>
<LI><A NAME="tex2html2339"
  HREF="node5.html#SECTION050252600000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_FieldBundleRegridStore</A>
<LI><A NAME="tex2html2340"
  HREF="node5.html#SECTION050252700000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_FieldBundleRemove</A>
<LI><A NAME="tex2html2341"
  HREF="node5.html#SECTION050252800000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_FieldBundleReplace</A>
<LI><A NAME="tex2html2342"
  HREF="node5.html#SECTION050252900000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_FieldBundleSet</A>
<LI><A NAME="tex2html2343"
  HREF="node5.html#SECTION050253000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_FieldBundleSet</A>
<LI><A NAME="tex2html2344"
  HREF="node5.html#SECTION050253100000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_FieldBundleSet</A>
<LI><A NAME="tex2html2345"
  HREF="node5.html#SECTION050253200000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_FieldBundleSet</A>
<LI><A NAME="tex2html2346"
  HREF="node5.html#SECTION050253300000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_FieldBundleSMM</A>
<LI><A NAME="tex2html2347"
  HREF="node5.html#SECTION050253400000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_FieldBundleSMMRelease</A>
<LI><A NAME="tex2html2348"
  HREF="node5.html#SECTION050253500000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_FieldBundleSMMStore</A>
<LI><A NAME="tex2html2349"
  HREF="node5.html#SECTION050253600000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_FieldBundleSMMStore</A>
<LI><A NAME="tex2html2350"
  HREF="node5.html#SECTION050253700000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_FieldBundleSMMStore</A>
<LI><A NAME="tex2html2351"
  HREF="node5.html#SECTION050253800000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_FieldBundleValidate</A>
<LI><A NAME="tex2html2352"
  HREF="node5.html#SECTION050253900000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_FieldBundleWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html2353"
  HREF="node5.html#SECTION05030000000000000000"><SPAN CLASS="arabic">26</SPAN> Field Class</A>
<UL>
<LI><A NAME="tex2html2354"
  HREF="node5.html#SECTION05031000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A NAME="tex2html2355"
  HREF="node5.html#SECTION05031100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Operations</A>
</UL>
<LI><A NAME="tex2html2356"
  HREF="node5.html#SECTION05032000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html2357"
  HREF="node5.html#SECTION05032100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_FIELDSTATUS</A>
</UL>
<LI><A NAME="tex2html2358"
  HREF="node5.html#SECTION05033000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2359"
  HREF="node5.html#SECTION05033100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field create and destroy</A>
<LI><A NAME="tex2html2360"
  HREF="node5.html#SECTION05033200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Get Fortran data pointer, bounds, and counts information from a Field</A>
<LI><A NAME="tex2html2361"
  HREF="node5.html#SECTION05033300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Get Grid, Array, and other information from a Field</A>
<LI><A NAME="tex2html2362"
  HREF="node5.html#SECTION05033400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Create a Field with a Grid, typekind, and rank</A>
<LI><A NAME="tex2html2363"
  HREF="node5.html#SECTION05033500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Create a Field with a Grid and Arrayspec</A>
<LI><A NAME="tex2html2364"
  HREF="node5.html#SECTION05033600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create a Field with a Grid and Array</A>
<LI><A NAME="tex2html2365"
  HREF="node5.html#SECTION05033700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Create an empty Field and complete it
   with FieldEmptySet and FieldEmptyComplete</A>
<LI><A NAME="tex2html2366"
  HREF="node5.html#SECTION05033800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Create an empty Field and complete it with FieldEmptyComplete</A>
<LI><A NAME="tex2html2367"
  HREF="node5.html#SECTION05033900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Create a 7D Field with a 5D Grid and 2D ungridded bounds
   from a Fortran data array</A>
<LI><A NAME="tex2html2368"
  HREF="node5.html#SECTION050331000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Shared memory features: DE pinning, sharing, and migration</A>
<LI><A NAME="tex2html2369"
  HREF="node5.html#SECTION050331100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Create a 2D Field with a 2D Grid and a Fortran data array</A>
<LI><A NAME="tex2html2370"
  HREF="node5.html#SECTION050331200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Create a 2D Field with a 2D Grid and a Fortran data pointer</A>
<LI><A NAME="tex2html2371"
  HREF="node5.html#SECTION050331300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> Create a 3D Field with a 2D Grid and a 3D Fortran data array</A>
<LI><A NAME="tex2html2372"
  HREF="node5.html#SECTION050331400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> Create a 3D Field with a 2D Grid and a 3D Fortran data array with gridToFieldMap argument</A>
<LI><A NAME="tex2html2373"
  HREF="node5.html#SECTION050331500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> Create a 3D Field with a 2D Grid and a 3D Fortran data array with halos</A>
<LI><A NAME="tex2html2374"
  HREF="node5.html#SECTION050331600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">16</SPAN> Create a Field from a LocStream, typekind, and rank</A>
<LI><A NAME="tex2html2375"
  HREF="node5.html#SECTION050331700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">17</SPAN> Create a Field from a LocStream and arrayspec</A>
<LI><A NAME="tex2html2376"
  HREF="node5.html#SECTION050331800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">18</SPAN> Create a Field from a Mesh, typekind, and rank</A>
<LI><A NAME="tex2html2377"
  HREF="node5.html#SECTION050331900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">19</SPAN> Create a Field from a Mesh and arrayspec</A>
<LI><A NAME="tex2html2378"
  HREF="node5.html#SECTION050332000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">20</SPAN> Create a Field from a Mesh and an Array</A>
<LI><A NAME="tex2html2379"
  HREF="node5.html#SECTION050332100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">21</SPAN> Create a Field from a Mesh and an ArraySpec with optional features</A>
<LI><A NAME="tex2html2380"
  HREF="node5.html#SECTION050332200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">22</SPAN> Create a Field with replicated dimensions</A>
<LI><A NAME="tex2html2381"
  HREF="node5.html#SECTION050332300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">23</SPAN> Create a Field on an arbitrarily distributed Grid</A>
<LI><A NAME="tex2html2382"
  HREF="node5.html#SECTION050332400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">24</SPAN> Create a Field on an arbitrarily distributed Grid with replicated dimensions &amp; ungridded bounds</A>
<LI><A NAME="tex2html2383"
  HREF="node5.html#SECTION050332500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">25</SPAN> Field regridding</A>
<LI><A NAME="tex2html2384"
  HREF="node5.html#SECTION050332600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">26</SPAN> Field regrid with masking</A>
<LI><A NAME="tex2html2385"
  HREF="node5.html#SECTION050332700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">27</SPAN> Field regrid example: Mesh to Mesh</A>
<LI><A NAME="tex2html2386"
  HREF="node5.html#SECTION050332800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">28</SPAN> Gather Field data onto root PET</A>
<LI><A NAME="tex2html2387"
  HREF="node5.html#SECTION050332900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">29</SPAN> Scatter Field data from root PET onto its set of joint PETs</A>
<LI><A NAME="tex2html2388"
  HREF="node5.html#SECTION050333000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">30</SPAN> Redistribute data from source Field to destination Field</A>
<LI><A NAME="tex2html2389"
  HREF="node5.html#SECTION050333100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">31</SPAN> FieldRedist as a form of scatter involving arbitrary distribution</A>
<LI><A NAME="tex2html2390"
  HREF="node5.html#SECTION050333200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">32</SPAN> FieldRedist as a form of gather involving arbitrary distribution</A>
<LI><A NAME="tex2html2391"
  HREF="node5.html#SECTION050333300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">33</SPAN> Sparse matrix multiplication from source Field to destination Field</A>
<LI><A NAME="tex2html2392"
  HREF="node5.html#SECTION050333400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">34</SPAN> Field Halo solving a domain decomposed heat transfer problem</A>
</UL>
<LI><A NAME="tex2html2393"
  HREF="node5.html#SECTION05034000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2394"
  HREF="node5.html#SECTION05035000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2395"
  HREF="node5.html#SECTION05036000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2396"
  HREF="node5.html#SECTION05036100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_FieldAssignment(=)</A>
<LI><A NAME="tex2html2397"
  HREF="node5.html#SECTION05036200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_FieldOperator(==)</A>
<LI><A NAME="tex2html2398"
  HREF="node5.html#SECTION05036300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_FieldOperator(/=)</A>
<LI><A NAME="tex2html2399"
  HREF="node5.html#SECTION05036400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_FieldCopy</A>
<LI><A NAME="tex2html2400"
  HREF="node5.html#SECTION05036500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2401"
  HREF="node5.html#SECTION05036600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2402"
  HREF="node5.html#SECTION05036700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2403"
  HREF="node5.html#SECTION05036800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2404"
  HREF="node5.html#SECTION05036900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2405"
  HREF="node5.html#SECTION050361000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2406"
  HREF="node5.html#SECTION050361100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2407"
  HREF="node5.html#SECTION050361200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2408"
  HREF="node5.html#SECTION050361300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2409"
  HREF="node5.html#SECTION050361400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2410"
  HREF="node5.html#SECTION050361500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2411"
  HREF="node5.html#SECTION050361600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2412"
  HREF="node5.html#SECTION050361700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2413"
  HREF="node5.html#SECTION050361800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2414"
  HREF="node5.html#SECTION050361900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2415"
  HREF="node5.html#SECTION050362000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2416"
  HREF="node5.html#SECTION050362100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2417"
  HREF="node5.html#SECTION050362200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2418"
  HREF="node5.html#SECTION050362300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2419"
  HREF="node5.html#SECTION050362400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2420"
  HREF="node5.html#SECTION050362500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2421"
  HREF="node5.html#SECTION050362600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2422"
  HREF="node5.html#SECTION050362700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2423"
  HREF="node5.html#SECTION050362800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_FieldCreate</A>
<LI><A NAME="tex2html2424"
  HREF="node5.html#SECTION050362900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_FieldDestroy</A>
<LI><A NAME="tex2html2425"
  HREF="node5.html#SECTION050363000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2426"
  HREF="node5.html#SECTION050363100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2427"
  HREF="node5.html#SECTION050363200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2428"
  HREF="node5.html#SECTION050363300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2429"
  HREF="node5.html#SECTION050363400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2430"
  HREF="node5.html#SECTION050363500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2431"
  HREF="node5.html#SECTION050363600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2432"
  HREF="node5.html#SECTION050363700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2433"
  HREF="node5.html#SECTION050363800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2434"
  HREF="node5.html#SECTION050363900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2435"
  HREF="node5.html#SECTION050364000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2436"
  HREF="node5.html#SECTION050364100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2437"
  HREF="node5.html#SECTION050364200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2438"
  HREF="node5.html#SECTION050364300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">43</SPAN> ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html2439"
  HREF="node5.html#SECTION050364400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">44</SPAN> ESMF_FieldEmptyCreate</A>
<LI><A NAME="tex2html2440"
  HREF="node5.html#SECTION050364500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">45</SPAN> ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html2441"
  HREF="node5.html#SECTION050364600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">46</SPAN> ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html2442"
  HREF="node5.html#SECTION050364700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">47</SPAN> ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html2443"
  HREF="node5.html#SECTION050364800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">48</SPAN> ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html2444"
  HREF="node5.html#SECTION050364900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">49</SPAN> ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html2445"
  HREF="node5.html#SECTION050365000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">50</SPAN> ESMF_FieldFill</A>
<LI><A NAME="tex2html2446"
  HREF="node5.html#SECTION050365100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">51</SPAN> ESMF_FieldGather</A>
<LI><A NAME="tex2html2447"
  HREF="node5.html#SECTION050365200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">52</SPAN> ESMF_FieldGet</A>
<LI><A NAME="tex2html2448"
  HREF="node5.html#SECTION050365300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">53</SPAN> ESMF_FieldGet</A>
<LI><A NAME="tex2html2449"
  HREF="node5.html#SECTION050365400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">54</SPAN> ESMF_FieldGetBounds</A>
<LI><A NAME="tex2html2450"
  HREF="node5.html#SECTION050365500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">55</SPAN> ESMF_FieldHalo</A>
<LI><A NAME="tex2html2451"
  HREF="node5.html#SECTION050365600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">56</SPAN> ESMF_FieldHaloRelease</A>
<LI><A NAME="tex2html2452"
  HREF="node5.html#SECTION050365700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">57</SPAN> ESMF_FieldHaloStore</A>
<LI><A NAME="tex2html2453"
  HREF="node5.html#SECTION050365800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">58</SPAN> ESMF_FieldIsCreated</A>
<LI><A NAME="tex2html2454"
  HREF="node5.html#SECTION050365900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">59</SPAN> ESMF_FieldPrint</A>
<LI><A NAME="tex2html2455"
  HREF="node5.html#SECTION050366000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">60</SPAN> ESMF_FieldRead</A>
<LI><A NAME="tex2html2456"
  HREF="node5.html#SECTION050366100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">61</SPAN> ESMF_FieldRedist</A>
<LI><A NAME="tex2html2457"
  HREF="node5.html#SECTION050366200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">62</SPAN> ESMF_FieldRedistRelease</A>
<LI><A NAME="tex2html2458"
  HREF="node5.html#SECTION050366300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">63</SPAN> ESMF_FieldRedistStore</A>
<LI><A NAME="tex2html2459"
  HREF="node5.html#SECTION050366400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">64</SPAN> ESMF_FieldRedistStore</A>
<LI><A NAME="tex2html2460"
  HREF="node5.html#SECTION050366500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">65</SPAN> ESMF_FieldRegrid</A>
<LI><A NAME="tex2html2461"
  HREF="node5.html#SECTION050366600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">66</SPAN> ESMF_FieldRegridRelease</A>
<LI><A NAME="tex2html2462"
  HREF="node5.html#SECTION050366700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">67</SPAN> ESMF_FieldRegridStore</A>
<LI><A NAME="tex2html2463"
  HREF="node5.html#SECTION050366800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">68</SPAN> ESMF_FieldRegridStore</A>
<LI><A NAME="tex2html2464"
  HREF="node5.html#SECTION050366900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">69</SPAN> ESMF_FieldRegridGetArea</A>
<LI><A NAME="tex2html2465"
  HREF="node5.html#SECTION050367000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">70</SPAN> ESMF_FieldScatter</A>
<LI><A NAME="tex2html2466"
  HREF="node5.html#SECTION050367100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">71</SPAN> ESMF_FieldSet</A>
<LI><A NAME="tex2html2467"
  HREF="node5.html#SECTION050367200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">72</SPAN> ESMF_FieldSync</A>
<LI><A NAME="tex2html2468"
  HREF="node5.html#SECTION050367300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">73</SPAN> ESMF_FieldSMM</A>
<LI><A NAME="tex2html2469"
  HREF="node5.html#SECTION050367400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">74</SPAN> ESMF_FieldSMMRelease</A>
<LI><A NAME="tex2html2470"
  HREF="node5.html#SECTION050367500000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">75</SPAN> ESMF_FieldSMMStore</A>
<LI><A NAME="tex2html2471"
  HREF="node5.html#SECTION050367600000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">76</SPAN> ESMF_FieldSMMStore</A>
<LI><A NAME="tex2html2472"
  HREF="node5.html#SECTION050367700000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">77</SPAN> ESMF_FieldSMMStore</A>
<LI><A NAME="tex2html2473"
  HREF="node5.html#SECTION050367800000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">78</SPAN> ESMF_FieldSMMStore</A>
<LI><A NAME="tex2html2474"
  HREF="node5.html#SECTION050367900000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">79</SPAN> ESMF_FieldSMMStore</A>
<LI><A NAME="tex2html2475"
  HREF="node5.html#SECTION050368000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">80</SPAN> ESMF_FieldSMMStore</A>
<LI><A NAME="tex2html2476"
  HREF="node5.html#SECTION050368100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">81</SPAN> ESMF_FieldValidate</A>
<LI><A NAME="tex2html2477"
  HREF="node5.html#SECTION050368200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">82</SPAN> ESMF_FieldWrite</A>
</UL>
<LI><A NAME="tex2html2478"
  HREF="node5.html#SECTION05037000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: Field Utilities</A>
<UL>
<LI><A NAME="tex2html2479"
  HREF="node5.html#SECTION05037100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GridGetFieldBounds</A>
<LI><A NAME="tex2html2480"
  HREF="node5.html#SECTION05037200000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LocStreamGetFieldBounds</A>
<LI><A NAME="tex2html2481"
  HREF="node5.html#SECTION05037300000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_MeshGetFieldBounds</A>
<LI><A NAME="tex2html2482"
  HREF="node5.html#SECTION05037400000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_XGridGetFieldBounds</A>
</UL>
</UL>
<LI><A NAME="tex2html2483"
  HREF="node5.html#SECTION05040000000000000000"><SPAN CLASS="arabic">27</SPAN> ArrayBundle Class</A>
<UL>
<LI><A NAME="tex2html2484"
  HREF="node5.html#SECTION05041000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2485"
  HREF="node5.html#SECTION05042000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2486"
  HREF="node5.html#SECTION05042100000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating an ArrayBundle from a list of Arrays</A>
<LI><A NAME="tex2html2487"
  HREF="node5.html#SECTION05042200000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Adding, removing, replacing Arrays in the ArrayBundle</A>
<LI><A NAME="tex2html2488"
  HREF="node5.html#SECTION05042300000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Accessing Arrays inside the ArrayBundle</A>
<LI><A NAME="tex2html2489"
  HREF="node5.html#SECTION05042400000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Destroying an ArrayBundle and its constituents</A>
<LI><A NAME="tex2html2490"
  HREF="node5.html#SECTION05042500000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Halo communication</A>
</UL>
<LI><A NAME="tex2html2491"
  HREF="node5.html#SECTION05043000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2492"
  HREF="node5.html#SECTION05044000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2493"
  HREF="node5.html#SECTION05045000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2494"
  HREF="node5.html#SECTION05045100000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ArrayBundleAssignment(=)</A>
<LI><A NAME="tex2html2495"
  HREF="node5.html#SECTION05045200000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ArrayBundleOperator(==)</A>
<LI><A NAME="tex2html2496"
  HREF="node5.html#SECTION05045300000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ArrayBundleOperator(/=)</A>
<LI><A NAME="tex2html2497"
  HREF="node5.html#SECTION05045400000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ArrayBundleAdd</A>
<LI><A NAME="tex2html2498"
  HREF="node5.html#SECTION05045500000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ArrayBundleAddReplace</A>
<LI><A NAME="tex2html2499"
  HREF="node5.html#SECTION05045600000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ArrayBundleCreate</A>
<LI><A NAME="tex2html2500"
  HREF="node5.html#SECTION05045700000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ArrayBundleDestroy</A>
<LI><A NAME="tex2html2501"
  HREF="node5.html#SECTION05045800000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_ArrayBundleGet</A>
<LI><A NAME="tex2html2502"
  HREF="node5.html#SECTION05045900000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_ArrayBundleGet</A>
<LI><A NAME="tex2html2503"
  HREF="node5.html#SECTION050451000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_ArrayBundleGet</A>
<LI><A NAME="tex2html2504"
  HREF="node5.html#SECTION050451100000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_ArrayBundleHalo</A>
<LI><A NAME="tex2html2505"
  HREF="node5.html#SECTION050451200000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_ArrayBundleHaloRelease</A>
<LI><A NAME="tex2html2506"
  HREF="node5.html#SECTION050451300000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_ArrayBundleHaloStore</A>
<LI><A NAME="tex2html2507"
  HREF="node5.html#SECTION050451400000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_ArrayBundleIsCreated</A>
<LI><A NAME="tex2html2508"
  HREF="node5.html#SECTION050451500000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_ArrayBundlePrint</A>
<LI><A NAME="tex2html2509"
  HREF="node5.html#SECTION050451600000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_ArrayBundleRead</A>
<LI><A NAME="tex2html2510"
  HREF="node5.html#SECTION050451700000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_ArrayBundleRedist</A>
<LI><A NAME="tex2html2511"
  HREF="node5.html#SECTION050451800000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_ArrayBundleRedistRelease</A>
<LI><A NAME="tex2html2512"
  HREF="node5.html#SECTION050451900000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_ArrayBundleRedistStore</A>
<LI><A NAME="tex2html2513"
  HREF="node5.html#SECTION050452000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_ArrayBundleRedistStore</A>
<LI><A NAME="tex2html2514"
  HREF="node5.html#SECTION050452100000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_ArrayBundleRemove</A>
<LI><A NAME="tex2html2515"
  HREF="node5.html#SECTION050452200000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_ArrayBundleReplace</A>
<LI><A NAME="tex2html2516"
  HREF="node5.html#SECTION050452300000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_ArrayBundleSMM</A>
<LI><A NAME="tex2html2517"
  HREF="node5.html#SECTION050452400000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_ArrayBundleSMMRelease</A>
<LI><A NAME="tex2html2518"
  HREF="node5.html#SECTION050452500000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_ArrayBundleSMMStore</A>
<LI><A NAME="tex2html2519"
  HREF="node5.html#SECTION050452600000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_ArrayBundleSMMStore</A>
<LI><A NAME="tex2html2520"
  HREF="node5.html#SECTION050452700000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_ArrayBundleWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html2521"
  HREF="node5.html#SECTION05050000000000000000"><SPAN CLASS="arabic">28</SPAN> Array Class</A>
<UL>
<LI><A NAME="tex2html2522"
  HREF="node5.html#SECTION05051000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2523"
  HREF="node5.html#SECTION05052000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2524"
  HREF="node5.html#SECTION05052100000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Array from native Fortran array with 1 DE per PET</A>
<LI><A NAME="tex2html2525"
  HREF="node5.html#SECTION05052200000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Array from native Fortran array with extra elements for halo or padding</A>
<LI><A NAME="tex2html2526"
  HREF="node5.html#SECTION05052300000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Array from <TT>ESMF_LocalArray</TT></A>
<LI><A NAME="tex2html2527"
  HREF="node5.html#SECTION05052400000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Create Array with automatic memory allocation</A>
<LI><A NAME="tex2html2528"
  HREF="node5.html#SECTION05052500000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Native language memory access</A>
<LI><A NAME="tex2html2529"
  HREF="node5.html#SECTION05052600000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Regions and default bounds</A>
<LI><A NAME="tex2html2530"
  HREF="node5.html#SECTION05052700000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Array bounds</A>
<LI><A NAME="tex2html2531"
  HREF="node5.html#SECTION05052800000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Computational region and extra elements for halo or padding</A>
<LI><A NAME="tex2html2532"
  HREF="node5.html#SECTION05052900000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">9</SPAN> Create 1D and 3D Arrays</A>
<LI><A NAME="tex2html2533"
  HREF="node5.html#SECTION050521000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">10</SPAN> Working with Arrays of different rank</A>
<LI><A NAME="tex2html2534"
  HREF="node5.html#SECTION050521100000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">11</SPAN> Array and DistGrid rank - 2D+1 Arrays</A>
<LI><A NAME="tex2html2535"
  HREF="node5.html#SECTION050521200000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">12</SPAN> Arrays with replicated dimensions</A>
<LI><A NAME="tex2html2536"
  HREF="node5.html#SECTION050521300000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">13</SPAN> Shared memory features: DE pinning, sharing, and migration</A>
<LI><A NAME="tex2html2537"
  HREF="node5.html#SECTION050521400000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">14</SPAN> Communication - Scatter and Gather</A>
<LI><A NAME="tex2html2538"
  HREF="node5.html#SECTION050521500000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">15</SPAN> Communication - Halo</A>
<LI><A NAME="tex2html2539"
  HREF="node5.html#SECTION050521600000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN> Communication - Halo for arbitrary distribution</A>
<LI><A NAME="tex2html2540"
  HREF="node5.html#SECTION050521700000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">17</SPAN> Communication - Redist</A>
<LI><A NAME="tex2html2541"
  HREF="node5.html#SECTION050521800000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">18</SPAN> Communication - SparseMatMul</A>
<LI><A NAME="tex2html2542"
  HREF="node5.html#SECTION050521900000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">19</SPAN> Communication - Scatter and Gather, revisited</A>
<LI><A NAME="tex2html2543"
  HREF="node5.html#SECTION050522000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">20</SPAN> Non-blocking Communications</A>
</UL>
<LI><A NAME="tex2html2544"
  HREF="node5.html#SECTION05053000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2545"
  HREF="node5.html#SECTION05054000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2546"
  HREF="node5.html#SECTION05055000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2547"
  HREF="node5.html#SECTION05055100000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ArrayAssignment(=)</A>
<LI><A NAME="tex2html2548"
  HREF="node5.html#SECTION05055200000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ArrayOperator(==)</A>
<LI><A NAME="tex2html2549"
  HREF="node5.html#SECTION05055300000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ArrayOperator(/=)</A>
<LI><A NAME="tex2html2550"
  HREF="node5.html#SECTION05055400000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ArrayCopy</A>
<LI><A NAME="tex2html2551"
  HREF="node5.html#SECTION05055500000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2552"
  HREF="node5.html#SECTION05055600000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2553"
  HREF="node5.html#SECTION05055700000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2554"
  HREF="node5.html#SECTION05055800000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2555"
  HREF="node5.html#SECTION05055900000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2556"
  HREF="node5.html#SECTION050551000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2557"
  HREF="node5.html#SECTION050551100000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2558"
  HREF="node5.html#SECTION050551200000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2559"
  HREF="node5.html#SECTION050551300000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2560"
  HREF="node5.html#SECTION050551400000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2561"
  HREF="node5.html#SECTION050551500000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2562"
  HREF="node5.html#SECTION050551600000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_ArrayDestroy</A>
<LI><A NAME="tex2html2563"
  HREF="node5.html#SECTION050551700000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_ArrayGather</A>
<LI><A NAME="tex2html2564"
  HREF="node5.html#SECTION050551800000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_ArrayGet</A>
<LI><A NAME="tex2html2565"
  HREF="node5.html#SECTION050551900000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_ArrayGet</A>
<LI><A NAME="tex2html2566"
  HREF="node5.html#SECTION050552000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_ArrayGet</A>
<LI><A NAME="tex2html2567"
  HREF="node5.html#SECTION050552100000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_ArrayGet</A>
<LI><A NAME="tex2html2568"
  HREF="node5.html#SECTION050552200000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_ArrayHalo</A>
<LI><A NAME="tex2html2569"
  HREF="node5.html#SECTION050552300000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_ArrayHaloRelease</A>
<LI><A NAME="tex2html2570"
  HREF="node5.html#SECTION050552400000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_ArrayHaloStore</A>
<LI><A NAME="tex2html2571"
  HREF="node5.html#SECTION050552500000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_ArrayIsCreated</A>
<LI><A NAME="tex2html2572"
  HREF="node5.html#SECTION050552600000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_ArrayPrint</A>
<LI><A NAME="tex2html2573"
  HREF="node5.html#SECTION050552700000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_ArrayRead</A>
<LI><A NAME="tex2html2574"
  HREF="node5.html#SECTION050552800000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_ArrayRedist</A>
<LI><A NAME="tex2html2575"
  HREF="node5.html#SECTION050552900000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_ArrayRedistRelease</A>
<LI><A NAME="tex2html2576"
  HREF="node5.html#SECTION050553000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_ArrayRedistStore</A>
<LI><A NAME="tex2html2577"
  HREF="node5.html#SECTION050553100000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_ArrayRedistStore</A>
<LI><A NAME="tex2html2578"
  HREF="node5.html#SECTION050553200000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_ArrayRedistStore</A>
<LI><A NAME="tex2html2579"
  HREF="node5.html#SECTION050553300000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_ArrayRedistStore</A>
<LI><A NAME="tex2html2580"
  HREF="node5.html#SECTION050553400000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_ArrayScatter</A>
<LI><A NAME="tex2html2581"
  HREF="node5.html#SECTION050553500000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_ArraySet</A>
<LI><A NAME="tex2html2582"
  HREF="node5.html#SECTION050553600000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_ArraySet</A>
<LI><A NAME="tex2html2583"
  HREF="node5.html#SECTION050553700000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_ArraySMM</A>
<LI><A NAME="tex2html2584"
  HREF="node5.html#SECTION050553800000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_ArraySMMRelease</A>
<LI><A NAME="tex2html2585"
  HREF="node5.html#SECTION050553900000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html2586"
  HREF="node5.html#SECTION050554000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">40</SPAN> ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html2587"
  HREF="node5.html#SECTION050554100000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">41</SPAN> ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html2588"
  HREF="node5.html#SECTION050554200000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">42</SPAN> ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html2589"
  HREF="node5.html#SECTION050554300000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">43</SPAN> ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html2590"
  HREF="node5.html#SECTION050554400000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">44</SPAN> ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html2591"
  HREF="node5.html#SECTION050554500000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">45</SPAN> ESMF_ArraySync</A>
<LI><A NAME="tex2html2592"
  HREF="node5.html#SECTION050554600000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">46</SPAN> ESMF_ArrayValidate</A>
<LI><A NAME="tex2html2593"
  HREF="node5.html#SECTION050554700000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">47</SPAN> ESMF_ArrayWrite</A>
<LI><A NAME="tex2html2594"
  HREF="node5.html#SECTION050554800000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">48</SPAN> ESMF_SparseMatrixWrite</A>
</UL>
<LI><A NAME="tex2html2595"
  HREF="node5.html#SECTION05056000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API: DynamicMask Methods</A>
<UL>
<LI><A NAME="tex2html2596"
  HREF="node5.html#SECTION05056100000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DynamicMaskSetR8R8R8</A>
<LI><A NAME="tex2html2597"
  HREF="node5.html#SECTION05056200000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_DynamicMaskSetR8R8R8V</A>
<LI><A NAME="tex2html2598"
  HREF="node5.html#SECTION05056300000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_DynamicMaskSetR4R8R4</A>
<LI><A NAME="tex2html2599"
  HREF="node5.html#SECTION05056400000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_DynamicMaskSetR4R8R4V</A>
<LI><A NAME="tex2html2600"
  HREF="node5.html#SECTION05056500000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_DynamicMaskSetR4R4R4</A>
<LI><A NAME="tex2html2601"
  HREF="node5.html#SECTION05056600000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_DynamicMaskSetR4R4R4V</A>
</UL>
</UL>
<LI><A NAME="tex2html2602"
  HREF="node5.html#SECTION05060000000000000000"><SPAN CLASS="arabic">29</SPAN> LocalArray Class</A>
<UL>
<LI><A NAME="tex2html2603"
  HREF="node5.html#SECTION05061000000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2604"
  HREF="node5.html#SECTION05062000000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">2</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2605"
  HREF="node5.html#SECTION05063000000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2606"
  HREF="node5.html#SECTION05063100000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LocalArrayAssignment(=)</A>
<LI><A NAME="tex2html2607"
  HREF="node5.html#SECTION05063200000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LocalArrayOperator(==)</A>
<LI><A NAME="tex2html2608"
  HREF="node5.html#SECTION05063300000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LocalArrayOperator(/=)</A>
<LI><A NAME="tex2html2609"
  HREF="node5.html#SECTION05063400000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html2610"
  HREF="node5.html#SECTION05063500000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html2611"
  HREF="node5.html#SECTION05063600000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html2612"
  HREF="node5.html#SECTION05063700000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html2613"
  HREF="node5.html#SECTION05063800000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_LocalArrayDestroy</A>
<LI><A NAME="tex2html2614"
  HREF="node5.html#SECTION05063900000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_LocalArrayGet</A>
<LI><A NAME="tex2html2615"
  HREF="node5.html#SECTION050631000000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_LocalArrayGet</A>
<LI><A NAME="tex2html2616"
  HREF="node5.html#SECTION050631100000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_LocalArrayIsCreated</A>
</UL>
</UL>
<LI><A NAME="tex2html2617"
  HREF="node5.html#SECTION05070000000000000000"><SPAN CLASS="arabic">30</SPAN> ArraySpec Class</A>
<UL>
<LI><A NAME="tex2html2618"
  HREF="node5.html#SECTION05071000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2619"
  HREF="node5.html#SECTION05072000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2620"
  HREF="node5.html#SECTION05072100000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Set ArraySpec values</A>
<LI><A NAME="tex2html2621"
  HREF="node5.html#SECTION05072200000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Get ArraySpec values</A>
</UL>
<LI><A NAME="tex2html2622"
  HREF="node5.html#SECTION05073000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2623"
  HREF="node5.html#SECTION05074000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2624"
  HREF="node5.html#SECTION05075000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2625"
  HREF="node5.html#SECTION05075100000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ArraySpecAssignment(=)</A>
<LI><A NAME="tex2html2626"
  HREF="node5.html#SECTION05075200000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ArraySpecOperator(==)</A>
<LI><A NAME="tex2html2627"
  HREF="node5.html#SECTION05075300000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ArraySpecOperator(/=)</A>
<LI><A NAME="tex2html2628"
  HREF="node5.html#SECTION05075400000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ArraySpecGet</A>
<LI><A NAME="tex2html2629"
  HREF="node5.html#SECTION05075500000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ArraySpecPrint</A>
<LI><A NAME="tex2html2630"
  HREF="node5.html#SECTION05075600000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ArraySpecSet</A>
<LI><A NAME="tex2html2631"
  HREF="node5.html#SECTION05075700000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ArraySpecValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2632"
  HREF="node5.html#SECTION05080000000000000000"><SPAN CLASS="arabic">31</SPAN> Grid Class</A>
<UL>
<LI><A NAME="tex2html2633"
  HREF="node5.html#SECTION05081000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A NAME="tex2html2634"
  HREF="node5.html#SECTION05081100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Representation in ESMF</A>
<LI><A NAME="tex2html2635"
  HREF="node5.html#SECTION05081200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Grids</A>
<LI><A NAME="tex2html2636"
  HREF="node5.html#SECTION05081300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Grid Topologies and Periodicity</A>
<LI><A NAME="tex2html2637"
  HREF="node5.html#SECTION05081400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Grid Distribution</A>
<LI><A NAME="tex2html2638"
  HREF="node5.html#SECTION05081500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Coordinates</A>
<LI><A NAME="tex2html2639"
  HREF="node5.html#SECTION05081600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Coordinate Specification and Generation</A>
<LI><A NAME="tex2html2640"
  HREF="node5.html#SECTION05081700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> Staggering</A>
<LI><A NAME="tex2html2641"
  HREF="node5.html#SECTION05081800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> Masking</A>
</UL>
<LI><A NAME="tex2html2642"
  HREF="node5.html#SECTION05082000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html2643"
  HREF="node5.html#SECTION05082100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GRIDCONN</A>
<LI><A NAME="tex2html2644"
  HREF="node5.html#SECTION05082200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GRIDITEM</A>
<LI><A NAME="tex2html2645"
  HREF="node5.html#SECTION05082300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GRIDMATCH</A>
<LI><A NAME="tex2html2646"
  HREF="node5.html#SECTION05082400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GRIDSTATUS</A>
<LI><A NAME="tex2html2647"
  HREF="node5.html#SECTION05082500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_POLEKIND</A>
<LI><A NAME="tex2html2648"
  HREF="node5.html#SECTION05082600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_STAGGERLOC</A>
</UL>
<LI><A NAME="tex2html2649"
  HREF="node5.html#SECTION05083000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2650"
  HREF="node5.html#SECTION05083100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Create single-tile Grid shortcut method</A>
<LI><A NAME="tex2html2651"
  HREF="node5.html#SECTION05083200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Create a 2D regularly distributed rectilinear Grid
                    with uniformly spaced coordinates</A>
<LI><A NAME="tex2html2652"
  HREF="node5.html#SECTION05083300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Create a periodic 2D regularly distributed rectilinear Grid</A>
<LI><A NAME="tex2html2653"
  HREF="node5.html#SECTION05083400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Create a 2D irregularly distributed rectilinear Grid
                    with uniformly spaced coordinates</A>
<LI><A NAME="tex2html2654"
  HREF="node5.html#SECTION05083500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Create a 2D irregularly distributed Grid
                    with curvilinear coordinates</A>
<LI><A NAME="tex2html2655"
  HREF="node5.html#SECTION05083600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create an irregularly distributed rectilinear Grid with
                  a non-distributed vertical dimension</A>
<LI><A NAME="tex2html2656"
  HREF="node5.html#SECTION05083700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Create an arbitrarily distributed rectilinear Grid with
                  a non-distributed vertical dimension</A>
<LI><A NAME="tex2html2657"
  HREF="node5.html#SECTION05083800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Create a curvilinear Grid using the coordinates defined
   in a SCRIP file</A>
<LI><A NAME="tex2html2658"
  HREF="node5.html#SECTION05083900000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Create an empty Grid in a parent Component
   for completion in a child Component</A>
<LI><A NAME="tex2html2659"
  HREF="node5.html#SECTION050831000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Create a six-tile cubed sphere Grid</A>
<LI><A NAME="tex2html2660"
  HREF="node5.html#SECTION050831100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Create a six-tile cubed sphere Grid and apply Schmidt transform</A>
<LI><A NAME="tex2html2661"
  HREF="node5.html#SECTION050831200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Create a six-tile cubed sphere Grid from a GRIDSPEC Mosaic file</A>
<LI><A NAME="tex2html2662"
  HREF="node5.html#SECTION050831300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> Grid stagger locations</A>
<LI><A NAME="tex2html2663"
  HREF="node5.html#SECTION050831400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> Associate coordinates with stagger locations</A>
<LI><A NAME="tex2html2664"
  HREF="node5.html#SECTION050831500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> Specify the relationship of coordinate Arrays
                 to index space dimensions</A>
<LI><A NAME="tex2html2665"
  HREF="node5.html#SECTION050831600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">16</SPAN> Access coordinates</A>
<LI><A NAME="tex2html2666"
  HREF="node5.html#SECTION050831700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">17</SPAN> Associate items with stagger locations</A>
<LI><A NAME="tex2html2667"
  HREF="node5.html#SECTION050831800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">18</SPAN> Access items</A>
<LI><A NAME="tex2html2668"
  HREF="node5.html#SECTION050831900000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">19</SPAN> Grid regions and bounds</A>
<LI><A NAME="tex2html2669"
  HREF="node5.html#SECTION050832000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">20</SPAN> Get Grid coordinate bounds</A>
<LI><A NAME="tex2html2670"
  HREF="node5.html#SECTION050832100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">21</SPAN> Get Grid stagger location bounds</A>
<LI><A NAME="tex2html2671"
  HREF="node5.html#SECTION050832200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">22</SPAN> Get Grid stagger location information</A>
<LI><A NAME="tex2html2672"
  HREF="node5.html#SECTION050832300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">23</SPAN> Create an Array at a stagger location</A>
<LI><A NAME="tex2html2673"
  HREF="node5.html#SECTION050832400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">24</SPAN> Create more complex Grids using DistGrid</A>
<LI><A NAME="tex2html2674"
  HREF="node5.html#SECTION050832500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">25</SPAN> Specify custom stagger locations</A>
<LI><A NAME="tex2html2675"
  HREF="node5.html#SECTION050832600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">26</SPAN> Specify custom stagger padding</A>
</UL>
<LI><A NAME="tex2html2676"
  HREF="node5.html#SECTION05084000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2677"
  HREF="node5.html#SECTION05085000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html2678"
  HREF="node5.html#SECTION05085100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Topology</A>
</UL>
<LI><A NAME="tex2html2679"
  HREF="node5.html#SECTION05086000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API: General Grid Methods</A>
<UL>
<LI><A NAME="tex2html2680"
  HREF="node5.html#SECTION05086100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GridAssignment(=)</A>
<LI><A NAME="tex2html2681"
  HREF="node5.html#SECTION05086200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GridOperator(==)</A>
<LI><A NAME="tex2html2682"
  HREF="node5.html#SECTION05086300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GridOperator(/=)</A>
<LI><A NAME="tex2html2683"
  HREF="node5.html#SECTION05086400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GridAddCoord</A>
<LI><A NAME="tex2html2684"
  HREF="node5.html#SECTION05086500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_GridAddItem</A>
<LI><A NAME="tex2html2685"
  HREF="node5.html#SECTION05086600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2686"
  HREF="node5.html#SECTION05086700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2687"
  HREF="node5.html#SECTION05086800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2688"
  HREF="node5.html#SECTION05086900000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2689"
  HREF="node5.html#SECTION050861000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2690"
  HREF="node5.html#SECTION050861100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2691"
  HREF="node5.html#SECTION050861200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2692"
  HREF="node5.html#SECTION050861300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2693"
  HREF="node5.html#SECTION050861400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_GridCreate</A>
<LI><A NAME="tex2html2694"
  HREF="node5.html#SECTION050861500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_GridCreate1PeriDim</A>
<LI><A NAME="tex2html2695"
  HREF="node5.html#SECTION050861600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_GridCreate1PeriDim</A>
<LI><A NAME="tex2html2696"
  HREF="node5.html#SECTION050861700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_GridCreate1PeriDim</A>
<LI><A NAME="tex2html2697"
  HREF="node5.html#SECTION050861800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_GridCreate2PeriDim</A>
<LI><A NAME="tex2html2698"
  HREF="node5.html#SECTION050861900000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_GridCreate2PeriDim</A>
<LI><A NAME="tex2html2699"
  HREF="node5.html#SECTION050862000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_GridCreate2PeriDim</A>
<LI><A NAME="tex2html2700"
  HREF="node5.html#SECTION050862100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_GridCreateNoPeriDim</A>
<LI><A NAME="tex2html2701"
  HREF="node5.html#SECTION050862200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_GridCreateNoPeriDim</A>
<LI><A NAME="tex2html2702"
  HREF="node5.html#SECTION050862300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_GridCreateNoPeriDim</A>
<LI><A NAME="tex2html2703"
  HREF="node5.html#SECTION050862400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_GridCreate1PeriDimUfrm</A>
<LI><A NAME="tex2html2704"
  HREF="node5.html#SECTION050862500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_GridCreate1PeriDimUfrm</A>
<LI><A NAME="tex2html2705"
  HREF="node5.html#SECTION050862600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_GridCreateNoPeriDimUfrm</A>
<LI><A NAME="tex2html2706"
  HREF="node5.html#SECTION050862700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_GridCreateCubedSphere</A>
<LI><A NAME="tex2html2707"
  HREF="node5.html#SECTION050862800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_GridCreateCubedSphere</A>
<LI><A NAME="tex2html2708"
  HREF="node5.html#SECTION050862900000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_GridCreateMosaic</A>
<LI><A NAME="tex2html2709"
  HREF="node5.html#SECTION050863000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_GridCreateMosaic</A>
<LI><A NAME="tex2html2710"
  HREF="node5.html#SECTION050863100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_GridDestroy</A>
<LI><A NAME="tex2html2711"
  HREF="node5.html#SECTION050863200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_GridEmptyComplete</A>
<LI><A NAME="tex2html2712"
  HREF="node5.html#SECTION050863300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_GridEmptyComplete</A>
<LI><A NAME="tex2html2713"
  HREF="node5.html#SECTION050863400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_GridEmptyComplete</A>
<LI><A NAME="tex2html2714"
  HREF="node5.html#SECTION050863500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_GridEmptyCreate</A>
<LI><A NAME="tex2html2715"
  HREF="node5.html#SECTION050863600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_GridGet</A>
<LI><A NAME="tex2html2716"
  HREF="node5.html#SECTION050863700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_GridGet</A>
<LI><A NAME="tex2html2717"
  HREF="node5.html#SECTION050863800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_GridGet</A>
<LI><A NAME="tex2html2718"
  HREF="node5.html#SECTION050863900000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_GridGet</A>
<LI><A NAME="tex2html2719"
  HREF="node5.html#SECTION050864000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> ESMF_GridGet</A>
<LI><A NAME="tex2html2720"
  HREF="node5.html#SECTION050864100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2721"
  HREF="node5.html#SECTION050864200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2722"
  HREF="node5.html#SECTION050864300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">43</SPAN> ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2723"
  HREF="node5.html#SECTION050864400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">44</SPAN> ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2724"
  HREF="node5.html#SECTION050864500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">45</SPAN> ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2725"
  HREF="node5.html#SECTION050864600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">46</SPAN> ESMF_GridGetCoordBounds</A>
<LI><A NAME="tex2html2726"
  HREF="node5.html#SECTION050864700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">47</SPAN> ESMF_GridGetItem</A>
<LI><A NAME="tex2html2727"
  HREF="node5.html#SECTION050864800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">48</SPAN> ESMF_GridGetItem</A>
<LI><A NAME="tex2html2728"
  HREF="node5.html#SECTION050864900000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">49</SPAN> ESMF_GridGetItem</A>
<LI><A NAME="tex2html2729"
  HREF="node5.html#SECTION050865000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">50</SPAN> ESMF_GridGetItemBounds</A>
<LI><A NAME="tex2html2730"
  HREF="node5.html#SECTION050865100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">51</SPAN> ESMF_GridIsCreated</A>
<LI><A NAME="tex2html2731"
  HREF="node5.html#SECTION050865200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">52</SPAN> ESMF_GridMatch</A>
<LI><A NAME="tex2html2732"
  HREF="node5.html#SECTION050865300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">53</SPAN> ESMF_GridRedist</A>
<LI><A NAME="tex2html2733"
  HREF="node5.html#SECTION050865400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">54</SPAN> ESMF_GridSetCoord</A>
<LI><A NAME="tex2html2734"
  HREF="node5.html#SECTION050865500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">55</SPAN> ESMF_GridSetItem</A>
<LI><A NAME="tex2html2735"
  HREF="node5.html#SECTION050865600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">56</SPAN> ESMF_GridValidate</A>
</UL>
<LI><A NAME="tex2html2736"
  HREF="node5.html#SECTION05087000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: StaggerLoc Methods</A>
<UL>
<LI><A NAME="tex2html2737"
  HREF="node5.html#SECTION05087100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_StaggerLocGet</A>
<LI><A NAME="tex2html2738"
  HREF="node5.html#SECTION05087200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_StaggerLocSet</A>
<LI><A NAME="tex2html2739"
  HREF="node5.html#SECTION05087300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_StaggerLocSet</A>
<LI><A NAME="tex2html2740"
  HREF="node5.html#SECTION05087400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_StaggerLocString</A>
<LI><A NAME="tex2html2741"
  HREF="node5.html#SECTION05087500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_StaggerLocPrint</A>
</UL>
</UL>
<LI><A NAME="tex2html2742"
  HREF="node5.html#SECTION05090000000000000000"><SPAN CLASS="arabic">32</SPAN> LocStream Class</A>
<UL>
<LI><A NAME="tex2html2743"
  HREF="node5.html#SECTION05091000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2744"
  HREF="node5.html#SECTION05092000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html2745"
  HREF="node5.html#SECTION05092100000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Coordinate keyNames</A>
<LI><A NAME="tex2html2746"
  HREF="node5.html#SECTION05092200000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Masking keyName</A>
</UL>
<LI><A NAME="tex2html2747"
  HREF="node5.html#SECTION05093000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2748"
  HREF="node5.html#SECTION05093100000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Create a LocStream with user allocated memory</A>
<LI><A NAME="tex2html2749"
  HREF="node5.html#SECTION05093200000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Create a LocStream with internally allocated memory</A>
<LI><A NAME="tex2html2750"
  HREF="node5.html#SECTION05093300000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Create a LocStream with a distribution based on a Grid</A>
<LI><A NAME="tex2html2751"
  HREF="node5.html#SECTION05093400000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Regridding from a Grid to a LocStream</A>
</UL>
<LI><A NAME="tex2html2752"
  HREF="node5.html#SECTION05094000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2753"
  HREF="node5.html#SECTION05094100000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LocStreamAssignment(=)</A>
<LI><A NAME="tex2html2754"
  HREF="node5.html#SECTION05094200000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LocStreamOperator(==)</A>
<LI><A NAME="tex2html2755"
  HREF="node5.html#SECTION05094300000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LocStreamOperator(/=)</A>
<LI><A NAME="tex2html2756"
  HREF="node5.html#SECTION05094400000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html2757"
  HREF="node5.html#SECTION05094500000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html2758"
  HREF="node5.html#SECTION05094600000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html2759"
  HREF="node5.html#SECTION05094700000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2760"
  HREF="node5.html#SECTION05094800000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2761"
  HREF="node5.html#SECTION05094900000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2762"
  HREF="node5.html#SECTION050941000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2763"
  HREF="node5.html#SECTION050941100000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2764"
  HREF="node5.html#SECTION050941200000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2765"
  HREF="node5.html#SECTION050941300000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2766"
  HREF="node5.html#SECTION050941400000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2767"
  HREF="node5.html#SECTION050941500000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_LocStreamDestroy</A>
<LI><A NAME="tex2html2768"
  HREF="node5.html#SECTION050941600000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_LocStreamGet</A>
<LI><A NAME="tex2html2769"
  HREF="node5.html#SECTION050941700000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_LocStreamGetBounds</A>
<LI><A NAME="tex2html2770"
  HREF="node5.html#SECTION050941800000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html2771"
  HREF="node5.html#SECTION050941900000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html2772"
  HREF="node5.html#SECTION050942000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html2773"
  HREF="node5.html#SECTION050942100000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_LocStreamIsCreated</A>
<LI><A NAME="tex2html2774"
  HREF="node5.html#SECTION050942200000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_LocStreamPrint</A>
<LI><A NAME="tex2html2775"
  HREF="node5.html#SECTION050942300000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_LocStreamValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2776"
  HREF="node5.html#SECTION050100000000000000000"><SPAN CLASS="arabic">33</SPAN> Mesh Class</A>
<UL>
<LI><A NAME="tex2html2777"
  HREF="node5.html#SECTION050101000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A NAME="tex2html2778"
  HREF="node5.html#SECTION050101100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh representation in ESMF</A>
<LI><A NAME="tex2html2779"
  HREF="node5.html#SECTION050101200000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Meshes</A>
</UL>
<LI><A NAME="tex2html2780"
  HREF="node5.html#SECTION050102000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html2781"
  HREF="node5.html#SECTION050102100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_MESHELEMTYPE</A>
</UL>
<LI><A NAME="tex2html2782"
  HREF="node5.html#SECTION050103000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2783"
  HREF="node5.html#SECTION050103100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh creation</A>
<LI><A NAME="tex2html2784"
  HREF="node5.html#SECTION050103200000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Create a small single PET Mesh in one step</A>
<LI><A NAME="tex2html2785"
  HREF="node5.html#SECTION050103300000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Create a small single PET Mesh in three steps</A>
<LI><A NAME="tex2html2786"
  HREF="node5.html#SECTION050103400000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Create a small Mesh on 4 PETs in one step</A>
<LI><A NAME="tex2html2787"
  HREF="node5.html#SECTION050103500000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Create a copy of a Mesh with a new distribution</A>
<LI><A NAME="tex2html2788"
  HREF="node5.html#SECTION050103600000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create a small Mesh of all one element type on 4 PETs using easy element method</A>
<LI><A NAME="tex2html2789"
  HREF="node5.html#SECTION050103700000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Create a small Mesh of multiple element types on 4 PETs using easy element method</A>
<LI><A NAME="tex2html2790"
  HREF="node5.html#SECTION050103800000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Create a Mesh from an unstructured grid file</A>
<LI><A NAME="tex2html2791"
  HREF="node5.html#SECTION050103900000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Create a Mesh representation of a cubed sphere grid</A>
<LI><A NAME="tex2html2792"
  HREF="node5.html#SECTION0501031000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Remove Mesh memory</A>
<LI><A NAME="tex2html2793"
  HREF="node5.html#SECTION0501031100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Mesh Masking</A>
<LI><A NAME="tex2html2794"
  HREF="node5.html#SECTION0501031200000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Mesh Halo Communication</A>
</UL>
<LI><A NAME="tex2html2795"
  HREF="node5.html#SECTION050104000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2796"
  HREF="node5.html#SECTION050104100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_MeshAssignment(=)</A>
<LI><A NAME="tex2html2797"
  HREF="node5.html#SECTION050104200000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_MeshOperator(==)</A>
<LI><A NAME="tex2html2798"
  HREF="node5.html#SECTION050104300000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_MeshOperator(/=)</A>
<LI><A NAME="tex2html2799"
  HREF="node5.html#SECTION050104400000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_MeshAddElements</A>
<LI><A NAME="tex2html2800"
  HREF="node5.html#SECTION050104500000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_MeshAddNodes</A>
<LI><A NAME="tex2html2801"
  HREF="node5.html#SECTION050104600000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_MeshCreate</A>
<LI><A NAME="tex2html2802"
  HREF="node5.html#SECTION050104700000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_MeshCreate</A>
<LI><A NAME="tex2html2803"
  HREF="node5.html#SECTION050104800000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_MeshCreate</A>
<LI><A NAME="tex2html2804"
  HREF="node5.html#SECTION050104900000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_MeshCreate</A>
<LI><A NAME="tex2html2805"
  HREF="node5.html#SECTION0501041000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_MeshCreate</A>
<LI><A NAME="tex2html2806"
  HREF="node5.html#SECTION0501041100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_MeshCreate</A>
<LI><A NAME="tex2html2807"
  HREF="node5.html#SECTION0501041200000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_MeshCreate</A>
<LI><A NAME="tex2html2808"
  HREF="node5.html#SECTION0501041300000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_MeshCreateCubedSphere</A>
<LI><A NAME="tex2html2809"
  HREF="node5.html#SECTION0501041400000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_MeshDestroy</A>
<LI><A NAME="tex2html2810"
  HREF="node5.html#SECTION0501041500000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_MeshEmptyCreate</A>
<LI><A NAME="tex2html2811"
  HREF="node5.html#SECTION0501041600000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_MeshFreeMemory</A>
<LI><A NAME="tex2html2812"
  HREF="node5.html#SECTION0501041700000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_MeshGet</A>
<LI><A NAME="tex2html2813"
  HREF="node5.html#SECTION0501041800000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_MeshGetMOAB</A>
<LI><A NAME="tex2html2814"
  HREF="node5.html#SECTION0501041900000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_MeshIsCreated</A>
<LI><A NAME="tex2html2815"
  HREF="node5.html#SECTION0501042000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_MeshSet</A>
<LI><A NAME="tex2html2816"
  HREF="node5.html#SECTION0501042100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_MeshSetMOAB</A>
</UL>
</UL>
<LI><A NAME="tex2html2817"
  HREF="node5.html#SECTION050110000000000000000"><SPAN CLASS="arabic">34</SPAN> XGrid Class</A>
<UL>
<LI><A NAME="tex2html2818"
  HREF="node5.html#SECTION050111000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2819"
  HREF="node5.html#SECTION050112000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html2820"
  HREF="node5.html#SECTION050112100000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_XGRIDSIDE</A>
</UL>
<LI><A NAME="tex2html2821"
  HREF="node5.html#SECTION050113000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2822"
  HREF="node5.html#SECTION050113100000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Create an XGrid from Grids then use it for regridding</A>
<LI><A NAME="tex2html2823"
  HREF="node5.html#SECTION050113200000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Using XGrid in Earth System modeling</A>
<LI><A NAME="tex2html2824"
  HREF="node5.html#SECTION050113300000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Create an XGrid from user input data then use it for regridding</A>
<LI><A NAME="tex2html2825"
  HREF="node5.html#SECTION050113400000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Query the XGrid for its internal information</A>
<LI><A NAME="tex2html2826"
  HREF="node5.html#SECTION050113500000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Destroying the XGrid and other resources</A>
</UL>
<LI><A NAME="tex2html2827"
  HREF="node5.html#SECTION050114000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<UL>
<LI><A NAME="tex2html2828"
  HREF="node5.html#SECTION050114100000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Restrictions and Future Work</A>
</UL>
<LI><A NAME="tex2html2829"
  HREF="node5.html#SECTION050115000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2830"
  HREF="node5.html#SECTION050116000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2831"
  HREF="node5.html#SECTION050116100000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_XGridAssignment(=)</A>
<LI><A NAME="tex2html2832"
  HREF="node5.html#SECTION050116200000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_XGridOperator(==)</A>
<LI><A NAME="tex2html2833"
  HREF="node5.html#SECTION050116300000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_XGridOperator(/=)</A>
<LI><A NAME="tex2html2834"
  HREF="node5.html#SECTION050116400000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_XGridCreate</A>
<LI><A NAME="tex2html2835"
  HREF="node5.html#SECTION050116500000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_XGridCreateFromSparseMat</A>
<LI><A NAME="tex2html2836"
  HREF="node5.html#SECTION050116600000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_XGridIsCreated</A>
<LI><A NAME="tex2html2837"
  HREF="node5.html#SECTION050116700000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_XGridDestroy</A>
<LI><A NAME="tex2html2838"
  HREF="node5.html#SECTION050116800000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_XGridGet</A>
</UL>
</UL>
<LI><A NAME="tex2html2839"
  HREF="node5.html#SECTION050120000000000000000"><SPAN CLASS="arabic">35</SPAN> Geom Class</A>
<UL>
<LI><A NAME="tex2html2840"
  HREF="node5.html#SECTION050121000000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2841"
  HREF="node5.html#SECTION050122000000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API: Geom Methods</A>
<UL>
<LI><A NAME="tex2html2842"
  HREF="node5.html#SECTION050122100000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GeomCreate</A>
<LI><A NAME="tex2html2843"
  HREF="node5.html#SECTION050122200000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GeomCreate</A>
<LI><A NAME="tex2html2844"
  HREF="node5.html#SECTION050122300000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GeomCreate</A>
<LI><A NAME="tex2html2845"
  HREF="node5.html#SECTION050122400000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GeomCreate</A>
<LI><A NAME="tex2html2846"
  HREF="node5.html#SECTION050122500000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_GeomDestroy</A>
<LI><A NAME="tex2html2847"
  HREF="node5.html#SECTION050122600000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_GeomGet</A>
</UL>
</UL>
<LI><A NAME="tex2html2848"
  HREF="node5.html#SECTION050130000000000000000"><SPAN CLASS="arabic">36</SPAN> DistGrid Class</A>
<UL>
<LI><A NAME="tex2html2849"
  HREF="node5.html#SECTION050131000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2850"
  HREF="node5.html#SECTION050132000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html2851"
  HREF="node5.html#SECTION050132100000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DISTGRIDMATCH</A>
</UL>
<LI><A NAME="tex2html2852"
  HREF="node5.html#SECTION050133000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2853"
  HREF="node5.html#SECTION050133100000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Single tile DistGrid with regular decomposition</A>
<LI><A NAME="tex2html2854"
  HREF="node5.html#SECTION050133200000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> DistGrid and DELayout</A>
<LI><A NAME="tex2html2855"
  HREF="node5.html#SECTION050133300000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Single tile DistGrid with decomposition by DE blocks</A>
<LI><A NAME="tex2html2856"
  HREF="node5.html#SECTION050133400000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> 2D multi-tile DistGrid with regular decomposition</A>
<LI><A NAME="tex2html2857"
  HREF="node5.html#SECTION050133500000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Arbitrary DistGrids with user-supplied sequence indices</A>
<LI><A NAME="tex2html2858"
  HREF="node5.html#SECTION050133600000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> DistGrid Connections - Definition</A>
<LI><A NAME="tex2html2859"
  HREF="node5.html#SECTION050133700000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> DistGrid Connections - Single tile periodic and pole connections</A>
<LI><A NAME="tex2html2860"
  HREF="node5.html#SECTION050133800000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> DistGrid Connections - Multi tile connections</A>
</UL>
<LI><A NAME="tex2html2861"
  HREF="node5.html#SECTION050134000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2862"
  HREF="node5.html#SECTION050135000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2863"
  HREF="node5.html#SECTION050136000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2864"
  HREF="node5.html#SECTION050136100000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DistGridAssignment(=)</A>
<LI><A NAME="tex2html2865"
  HREF="node5.html#SECTION050136200000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_DistGridOperator(==)</A>
<LI><A NAME="tex2html2866"
  HREF="node5.html#SECTION050136300000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_DistGridOperator(/=)</A>
<LI><A NAME="tex2html2867"
  HREF="node5.html#SECTION050136400000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2868"
  HREF="node5.html#SECTION050136500000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2869"
  HREF="node5.html#SECTION050136600000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2870"
  HREF="node5.html#SECTION050136700000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2871"
  HREF="node5.html#SECTION050136800000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2872"
  HREF="node5.html#SECTION050136900000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2873"
  HREF="node5.html#SECTION0501361000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2874"
  HREF="node5.html#SECTION0501361100000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2875"
  HREF="node5.html#SECTION0501361200000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2876"
  HREF="node5.html#SECTION0501361300000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2877"
  HREF="node5.html#SECTION0501361400000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_DistGridDestroy</A>
<LI><A NAME="tex2html2878"
  HREF="node5.html#SECTION0501361500000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_DistGridGet</A>
<LI><A NAME="tex2html2879"
  HREF="node5.html#SECTION0501361600000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_DistGridGet</A>
<LI><A NAME="tex2html2880"
  HREF="node5.html#SECTION0501361700000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_DistGridGet</A>
<LI><A NAME="tex2html2881"
  HREF="node5.html#SECTION0501361800000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_DistGridIsCreated</A>
<LI><A NAME="tex2html2882"
  HREF="node5.html#SECTION0501361900000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_DistGridMatch</A>
<LI><A NAME="tex2html2883"
  HREF="node5.html#SECTION0501362000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_DistGridPrint</A>
<LI><A NAME="tex2html2884"
  HREF="node5.html#SECTION0501362100000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_DistGridSet</A>
<LI><A NAME="tex2html2885"
  HREF="node5.html#SECTION0501362200000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_DistGridValidate</A>
</UL>
<LI><A NAME="tex2html2886"
  HREF="node5.html#SECTION050137000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: DistGridConnection Methods</A>
<UL>
<LI><A NAME="tex2html2887"
  HREF="node5.html#SECTION050137100000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DistGridConnectionGet</A>
<LI><A NAME="tex2html2888"
  HREF="node5.html#SECTION050137200000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_DistGridConnectionSet</A>
</UL>
<LI><A NAME="tex2html2889"
  HREF="node5.html#SECTION050138000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">8</SPAN> Class API: DistGridRegDecomp Methods</A>
<UL>
<LI><A NAME="tex2html2890"
  HREF="node5.html#SECTION050138100000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DistGridRegDecompSetCubic</A>
</UL>
</UL>
<LI><A NAME="tex2html2891"
  HREF="node5.html#SECTION050140000000000000000"><SPAN CLASS="arabic">37</SPAN> RouteHandle Class</A>
<UL>
<LI><A NAME="tex2html2892"
  HREF="node5.html#SECTION050141000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2893"
  HREF="node5.html#SECTION050142000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html2894"
  HREF="node5.html#SECTION050142100000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Bit-for-bit reproducibility</A>
<LI><A NAME="tex2html2895"
  HREF="node5.html#SECTION050142200000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Asynchronous RouteHandle communication with VMEpoch</A>
<LI><A NAME="tex2html2896"
  HREF="node5.html#SECTION050142300000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Creating a RouteHandle from an existing RouteHandle - 
   Transfer to a different set of PETs</A>
<LI><A NAME="tex2html2897"
  HREF="node5.html#SECTION050142400000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Write a RouteHandle to file and creating a RouteHandle from file</A>
<LI><A NAME="tex2html2898"
  HREF="node5.html#SECTION050142500000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Reusablity of RouteHandles and interleaved distributed 
   and undistributed dimensions</A>
<LI><A NAME="tex2html2899"
  HREF="node5.html#SECTION050142600000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Dynamic Masking</A>
</UL>
<LI><A NAME="tex2html2900"
  HREF="node5.html#SECTION050143000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2901"
  HREF="node5.html#SECTION050144000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html2902"
  HREF="node5.html#SECTION050145000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2903"
  HREF="node5.html#SECTION050145100000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_RouteHandleCreate</A>
<LI><A NAME="tex2html2904"
  HREF="node5.html#SECTION050145200000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_RouteHandleCreate</A>
<LI><A NAME="tex2html2905"
  HREF="node5.html#SECTION050145300000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_RouteHandleDestroy</A>
<LI><A NAME="tex2html2906"
  HREF="node5.html#SECTION050145400000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_RouteHandleGet</A>
<LI><A NAME="tex2html2907"
  HREF="node5.html#SECTION050145500000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_RouteHandleIsCreated</A>
<LI><A NAME="tex2html2908"
  HREF="node5.html#SECTION050145600000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_RouteHandlePrint</A>
<LI><A NAME="tex2html2909"
  HREF="node5.html#SECTION050145700000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_RouteHandleSet</A>
<LI><A NAME="tex2html2910"
  HREF="node5.html#SECTION050145800000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_RouteHandleWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html2911"
  HREF="node5.html#SECTION050150000000000000000"><SPAN CLASS="arabic">38</SPAN> I/O Capability</A>
<UL>
<LI><A NAME="tex2html2912"
  HREF="node5.html#SECTION050151000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html2913"
  HREF="node5.html#SECTION050152000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">2</SPAN> Data I/O</A>
<LI><A NAME="tex2html2914"
  HREF="node5.html#SECTION050153000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">3</SPAN> Data formats</A>
<LI><A NAME="tex2html2915"
  HREF="node5.html#SECTION050154000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html2916"
  HREF="node5.html#SECTION050155000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION05000000000000000000">
<SPAN CLASS="arabic">4</SPAN> Infrastructure: Fields and Grids</A>
</H1>

<H1><A NAME="SECTION05010000000000000000">
<SPAN CLASS="arabic">24</SPAN> Overview of Data Classes</A>
</H1>

<P>
The ESMF infrastructure data classes are part of the framework's 
hierarchy of structures for handling Earth system model data and 
metadata on parallel platforms.  The hierarchy is in complexity; the 
simplest data class in the infrastructure represents a distributed data
array and the most complex data class represents a bundle of physical 
fields that are discretized on the same grid.  Data class methods 
are called both from user-written code and from other classes 
internal to the framework. 

<P>
Data classes are distributed over <B>DE</B>s, or <B>Decomposition Elements</B>.  
A DE represents a piece of a decomposition.  A DELayout is a collection
of DEs with some associated connectivity that describes a specific 
distribution.  For example, the distribution of a grid divided 
into four segments in the x-dimension would be expressed in ESMF as
a DELayout with four DEs lying along an x-axis. This abstract concept 
enables a data decomposition to be defined in 
terms of threads, MPI processes, virtual decomposition elements, or
combinations of these without changes to user code.  This is a
primary strategy for ensuring optimal performance and portability
for codes using ESMF for communications.

<P>
ESMF data classes provide a standard,
convenient way for developers to collect together information 
related to model or observational data.  The information assembled 
in a data class includes a data pointer, a set of attributes 
(e.g. units, although attributes can also be user-defined), and a 
description of an associated grid.  The same set of information within 
an ESMF data object can be used by the framework to arrange 
intercomponent data transfers, to perform I/O, for communications
such as gathers and scatters, for simplification of interfaces 
within user code, for debugging, and for other functions.  
This unifies and organizes codes overall so that the user need not
define different representations of metadata for the same field 
for I/O and for component coupling.  

<P>
Since it is critical that users be able to introduce ESMF into their
codes easily and incrementally, ESMF data classes can be created based 
on native Fortran pointers.  Likewise, there are methods for retrieving 
native Fortran pointers from within ESMF data objects.  This allows
the user to perform allocations using ESMF, and to retrieve Fortran
arrays later for optimized model calculations.  The ESMF data classes 
do not have associated differential operators or other mathematical 
methods.

<P>
For flexibility, it is not necessary to build an ESMF data object 
all at once.  For example, it's possible to create a 
field but to defer allocation of the associated field data until 
a later time.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchy of data structures designed specifically for the Earth 
system domain and high performance, parallel computing.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multi-use ESMF structures simplify user code overall.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Data objects support incremental construction and deferred allocation.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Native Fortran arrays can be associated with or retrieved from ESMF data
objects, for ease of adoption, convenience, and performance.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>A variety of operations are provided for manipulating data in data objects 
such as regridding, redistribution, halo communication, and sparse matrix multiply.</TD>
</TR>
</TABLE>
</DIV>

<P>
The main classes that are used for model and observational data manipulation
are as follows:

<P>

<UL>
<LI><B>Array</B>  An ESMF Array contains a data pointer, 
information about its associated datatype, precision, and 
dimension.  

<P>
Data elements in Arrays are partitioned into categories 
defined by the role the data element plays in distributed halo 
operations.  Haloing - sometimes called ghosting - is the 
practice of copying portions of array data to multiple memory 
locations to ensure that data dependencies can be satisfied 
quickly when performing a calculation.  ESMF Arrays contain 
an <B>exclusive</B> domain, which contains data elements
updated exclusively and definitively by a given DE; a 
<B>computational</B> domain, which contains all data elements
with values that are updated by the DE in computations; and 
a <B>total</B> domain, which includes both the computational 
domain and data elements from other DEs which may be read 
but are not updated in computations.

<P>
</LI>
<LI><B>ArrayBundle</B> ArrayBundles are collections of
Arrays that are stored in a single object.  Unlike FieldBundles,
they don't need to be distributed the same way across PETs.  The
motivation for ArrayBundles is both convenience and performance.

<P>
</LI>
<LI><B>Field</B>  A Field holds model and/or observational 
data together with its underlying grid or set of spatial 
locations.  It provides methods for configuration, 
initialization, setting and retrieving data values, 
data I/O, data regridding, and manipulation of attributes.

<P>
</LI>
<LI><B>FieldBundle</B> Groups of Fields on the same underlying 
physical grid can be collected into a single object called a FieldBundle.  
A FieldBundle provides two major functions: it allows groups of 
Fields to be manipulated using a single identifier, for example 
during export or import of data between Components; and 
it allows data from multiple Fields to be packed together 
in memory for higher locality of reference and ease in 
subsetting operations.  Packing a set of Fields into a single
FieldBundle before performing a data communication allows the set 
to be transferred at once rather than as a Field at a time.
This can improve performance on high-latency platforms.

<P>
FieldBundle objects contain methods for setting and retrieving constituent 
fields, regridding, data I/O, and reordering of data in memory.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION05011000000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">1</SPAN> Bit-for-Bit Considerations</A>
</H2>

<P>
Bit-for-bit reproducibility is at the core of the regression testing
schemes of many scientific model codes. The bit-for-bit requirement makes it
easy to compare the numerical results of simulation runs using standard
binary diff tools.

<P>
For the most part, ESMF methods do not modify user data numerically, and
thus have no effect on the bit-for-bit characteristics of the model code.
The exceptions are the regrid weight generation and the sparse matrix
multiplication.

<P>
In the case of the regrid weight generation, user data is used to produce
interpolation weights following specific numerical schemes. The bit-for-bit
reproducibility of the generated weights depends on the implementation
details. Section <A HREF="#sec:regrid">24.2</A> provides more details about the bit-for-bit
considerations with respect to the regrid weights generated by ESMF.

<P>
In the case of the sparse matrix multiplication, which is the typical method
that is used to apply the regrid weights, user data is directly manipulated 
by ESMF. In order to help users with the implementation of their bit-for-bit
requirements, while also considering the associated performance impact,
the ESMF sparse matrix implementation provides three levels of bit-for-bit
support. The strictest level ensures that the numerical results are
bit-for-bit identical, even when executing across different numbers of
PETs. In the relaxed level, bit-for-bit reproducibility is guaranteed when
running across an unchanged number of PETs. The lowest level makes no
guarantees about bit-for-bit reproducibility, however, it provides the
greatest performance potential for those cases where numerical round-off
differences are acceptable. An in-depth discussion of bit-for-bit
reproducibility, and the performance aspects of route-based communication
methods, such the sparse matrix multiplication, is given in section
<A HREF="#RH:bfb">37.2.1</A>.

<P>

<H2><A NAME="SECTION05012000000000000000"></A><A NAME="sec:regrid"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN> Regrid
</H2>

<P>
This section describes the regridding methods provided by ESMF. Regridding, also called remapping or interpolation, is 
 the process of changing the grid that underlies data values while preserving qualities of the original data. Different 
 kinds of transformations are appropriate for different problems. Regridding may be needed when communicating data between
 Earth system model components such as land and atmosphere, or between different data sets to support operations such as visualization.

<P>
Regridding can be broken into two stages. The first stage is generation of an interpolation weight matrix that describes how points in 
 the source grid contribute to points in the destination grid. The second stage is the multiplication of values on the source grid by the
 interpolation weight matrix to produce values on the destination grid. This is implemented as a parallel sparse matrix multiplication.

<P>
There are two options for accessing ESMF regridding functionality: <B>offline</B> and <B>integrated</B>. Offline regridding is a process whereby interpolation 
 weights are generated by a separate ESMF command line tool, not within the user code. The ESMF offline regridding tool also only generates the interpolation 
 matrix, the user is responsible for reading in this matrix and doing the actual interpolation (multiplication by the sparse matrix) in their code.
 Please see Section&nbsp;<A HREF="node3.html#sec:ESMF_RegridWeightGen">12</A> for a description of the offline regridding command line tool and the options it supports. For user convenience, there
 is also a method interface to the offline regrid tool functionality which is described in Section&nbsp;<A HREF="#api:esmf_regridweightgenfile">24.3.1</A>.
 In contrast to offline regridding, integrated regridding is a process whereby interpolation weights are generated via subroutine calls during the
 execution of the user's code. In addition to generating the weights, integrated regridding can also produce a <B>RouteHandle</B> (described in Section&nbsp;<A HREF="#sec:RHandle">37.1</A>) which allows the user to perform the parallel sparse 
 matrix multiplication using ESMF methods. In other words, ESMF integrated regridding allows a user to perform the whole process of interpolation within their code. 

<P>
To see what types of grids and other options are supported in the two types of regridding and their testing status, please see the <A NAME="tex2html28"
  HREF="http://earthsystemmodeling.org/regrid/">ESMF Regridding Status</A>
webpage for this version of ESMF.
 Figure&nbsp;<A HREF="#Regrid_Interfaces">24.2</A> shows a comparison of different regrid interfaces and where they can be found in the documentation. 

<P>
The rest of this section further describes the various options available in ESMF regridding. 

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="17214"></A>
<TABLE>
<CAPTION><STRONG>Table 1:</STRONG>
Regrid Interfaces</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Name</TD>
<TD ALIGN="LEFT">Access via</TD>
<TD ALIGN="LEFT">Inputs</TD>
<TD ALIGN="CENTER" COLSPAN=2><SPAN>Outputs</SPAN></TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER">Weights</TD>
<TD ALIGN="CENTER">RouteHandle</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_FieldRegridStore()</TD>
<TD ALIGN="LEFT">Subroutine call</TD>
<TD ALIGN="LEFT">Field object</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="LEFT">Sec.&nbsp;<A HREF="#api:esmf_fieldregridstorenx">26.6.67</A></TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_FieldBundleRegridStore()</TD>
<TD ALIGN="LEFT">Subroutine call</TD>
<TD ALIGN="LEFT">Fieldbundle obj.</TD>
<TD ALIGN="CENTER">no</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="LEFT">Sec.&nbsp;<A HREF="#api:esmf_fieldbundleregridstore">25.5.26</A></TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_RegridWeightGen()</TD>
<TD ALIGN="LEFT">Subroutine call</TD>
<TD ALIGN="LEFT">Grid files</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">no</TD>
<TD ALIGN="LEFT">Sec.&nbsp;<A HREF="#api:esmf_regridweightgenfile">24.3.1</A></TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_RegridWeightGen</TD>
<TD ALIGN="LEFT">Command Line Tool</TD>
<TD ALIGN="LEFT">Grid files</TD>
<TD ALIGN="CENTER">yes</TD>
<TD ALIGN="CENTER">no</TD>
<TD ALIGN="LEFT">Sec.&nbsp;<A HREF="node3.html#sec:ESMF_RegridWeightGen">12</A></TD>
</TR>
</TABLE>
<A NAME="Regrid_Interfaces"></A>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>

<H3><A NAME="SECTION05012100000000000000"></A><A NAME="sec:interpolation:bilinear"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Interpolation methods: bilinear
</H3>
 Bilinear interpolation calculates the value for the 
 destination point as a combination of multiple linear interpolations, one for each dimension of the Grid. Note that for ease of 
 use, the term bilinear interpolation is used for 3D interpolation in ESMF as well, although it should more properly be referred 
 to as trilinear interpolation.

<P>

<P></P>

<P>
In 2D, ESMF supports bilinear regridding between any combination of the following:

<UL>
<LI>Structured grids (<TT>ESMF_Grid</TT>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<TT>ESMF_Mesh</TT>) composed of polygons with any number of sides
</LI>
<LI>A set of disconnected points (<TT>ESMF_LocStream</TT>) may be the destination of the regridding
</LI>
<LI>An exchange grid (<TT>ESMF_XGrid</TT>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports bilinear regridding between any combination of the following:

<UL>
<LI>Structured grids (<TT>ESMF_Grid</TT>) composed of a single logically rectangular tile
</LI>
<LI>Unstructured meshes (<TT>ESMF_Mesh</TT>) composed of hexahedrons 
</LI>
<LI>A set of disconnected points (<TT>ESMF_LocStream</TT>) may be the destination of the regridding
 
</LI>
</UL>

<P>

<P></P>

<P>
<B>Restrictions:</B>

<UL>
<LI>Cells which contain enough identical corners to collapse to a line or point are currently ignored
</LI>
<LI>Self-intersecting cells (e.g. a cell twisted into a bow tie) are not supported 
</LI>
<LI>On a spherical grid, cells which contain an edge which extends more than half way around the sphere are not supported 
</LI>
<LI>Source Fields built on a Grid which contains a DE of width less than 2 elements are not supported
 
</LI>
</UL>

<P>
To use the bilinear method the user may create their Fields on any stagger location (e.g. <TT>ESMF_STAGGERLOC_CENTER</TT>) for a Grid, or
 any Mesh location (e.g. <TT>ESMF_MESHLOC_NODE</TT>) for a Mesh. For either a Grid or a Mesh, the location upon which the Field is built 
 must contain coordinates. This method will also work with a destination Field built on a LocStream that contains coordinates, 
 or with a source or destination Field built on an XGrid.

<P>

<H3><A NAME="SECTION05012200000000000000"></A><A NAME="sec:interpolation:patch"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Interpolation methods: higher-order patch
</H3>

<P>
Patch (or higher-order) interpolation is the ESMF version of a technique called &ldquo;patch recovery&rdquo; commonly
 used in finite element modeling&nbsp;[<A
 HREF="node8.html#PatchInterp1">28</A>]&nbsp;[<A
 HREF="node8.html#PatchInterp2">24</A>]. It typically results in better approximations to 
 values and derivatives when compared to bilinear interpolation.
 Patch interpolation works by constructing multiple polynomial patches to represent
 the data in a source cell. For 2D grids, these polynomials
 are currently 2nd degree 2D polynomials. One patch is constructed for each corner of the source cell, and the patch is constructed 
 by doing a least squares fit through the data in the cells surrounding the corner. The interpolated value at the destination point is 
 then a weighted average of the values of the patches at that point. 

<P>
The patch method has a larger stencil than the bilinear, for this reason the patch weight matrix can be correspondingly larger
 than the bilinear matrix (e.g. for a quadrilateral grid the patch matrix is around 4x the size of
 the bilinear matrix). This can be an issue when performing a regrid operation close to the memory
 limit on a machine. 

<P>
The patch method does not guarantee that after regridding the range of values in the destination field is within the range of 
 values in the source field. For example, if the mininum value in the source field is 0.0, then it's possible that after regridding with the 
 patch method, the destination field will contain values less than 0.0.

<P>

<P></P>

<P>
In 2D, ESMF supports patch regridding between any combination of the following:

<UL>
<LI>Structured Grids (<TT>ESMF_Grid</TT>) composed of a single logically rectangular tile
</LI>
<LI>Unstructured meshes (<TT>ESMF_Mesh</TT>) composed of polygons with any number of sides
</LI>
<LI>A set of disconnected points (<TT>ESMF_LocStream</TT>) may be the destination of the regridding
</LI>
<LI>An exchange grid (<TT>ESMF_XGrid</TT>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports patch regridding between any combination of the following:

<UL>
<LI>NONE
 
</LI>
</UL>

<P>

<P></P>

<P>
<B>Restrictions:</B>

<UL>
<LI>Cells which contain enough identical corners to collapse to a line or point are currently ignored
</LI>
<LI>Self-intersecting cells (e.g. a cell twisted into a bow tie) are not supported
</LI>
<LI>On a spherical grid, cells which contain an edge which extends more than half way around the sphere are not supported 
</LI>
<LI>Source Fields built on a Grid which contains a DE of width less than 2 elements are not supported
 
</LI>
</UL>

<P>
To use the patch method the user may create their Fields on any stagger location (e.g. <TT>ESMF_STAGGERLOC_CENTER</TT>) for a Grid, or
 any Mesh location (e.g. <TT>ESMF_MESHLOC_NODE</TT>) for a Mesh. For either a Grid or a Mesh, the location upon which the Field is built 
 must contain coordinates. This method will also work with a destination Field built on a LocStream that contains coordinates, 
 or with a source or destination Field built on an XGrid.

<P>

<H3><A NAME="SECTION05012300000000000000"></A><A NAME="sec:interpolation:neareststod"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Interpolation methods: nearest source to destination
</H3>
In nearest source to destination interpolation (<TT>ESMF_REGRIDMETHOD_NEAREST_STOD</TT>) each destination point is mapped to the closest source point. A given source point may map to multiple destination points, but no destination point will receive input from more than one source point. If two points are equally close, then the point with the smallest sequence index is arbitrarily used (i.e. the point which would have the smallest index in the weight matrix). 

<P>

<P></P>

<P>
In 2D, ESMF supports nearest source to destination regridding between any combination of the following:

<UL>
<LI>Structured Grids (<TT>ESMF_Grid</TT>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<TT>ESMF_Mesh</TT>) composed of polygons with any number of sides
</LI>
<LI>A set of disconnected points (<TT>ESMF_LocStream</TT>) 
</LI>
<LI>An exchange grid (<TT>ESMF_XGrid</TT>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports nearest source to destination regridding between any combination of the following:

<UL>
<LI>Structured Grids (<TT>ESMF_Grid</TT>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured Meshes (<TT>ESMF_Mesh</TT>) composed of hexahedrons (e.g. cubes) and tetrahedrons
</LI>
<LI>A set of disconnected points (<TT>ESMF_LocStream</TT>) 
 
</LI>
</UL>

<P>

<P></P>

<P>
<SPAN  CLASS="textbf">Restrictions:</SPAN>
<BR>
<SPAN  CLASS="textit">NONE</SPAN>

<P>

<P></P>

<P>
To use the nearest source to destination method the user may create their Fields on any stagger location (e.g. <TT>ESMF_STAGGERLOC_CENTER</TT>) for a Grid, or
 any Mesh location (e.g. <TT>ESMF_MESHLOC_NODE</TT>) for a Mesh. For either a Grid or a Mesh, the location upon which the Field is built 
 must contain coordinates. This method will also work with a source or destination Field built on a LocStream that contains coordinates, or when the source 
or destination Field is built on an XGrid.

<P>

<H3><A NAME="SECTION05012400000000000000"></A><A NAME="sec:interpolation:nearestdtos"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Interpolation methods: nearest destination to source
</H3>
In nearest destination to source interpolation (<TT>ESMF_REGRIDMETHOD_NEAREST_DTOS</TT>) each source point is mapped to the closest destination point. A given destination point may receive input from multiple source points, but no source point will map to more than one destination point. If two points are equally close, then the point with the smallest sequence index is arbitrarily used (i.e. the point which would have the smallest index in the weight matrix). Note that with this method the unmapped destination point detection currently doesn't work, so no error will be returned even if there are destination points that don't map to any source point. 

<P>

<P></P>

<P>
In 2D, ESMF supports nearest destination to source regridding between any combination of the following:

<UL>
<LI>Structured Grids (<TT>ESMF_Grid</TT>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<TT>ESMF_Mesh</TT>) composed of polygons with any number of sides
</LI>
<LI>A set of disconnected points (<TT>ESMF_LocStream</TT>) 
</LI>
<LI>An exchange grid (<TT>ESMF_XGrid</TT>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports nearest destination to source regridding between any combination of the following:

<UL>
<LI>Structured Grids (<TT>ESMF_Grid</TT>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured Meshes (<TT>ESMF_Mesh</TT>) composed of hexahedrons (e.g. cubes) and tetrahedrons
</LI>
<LI>A set of disconnected points (<TT>ESMF_LocStream</TT>) 
 
</LI>
</UL>

<P>

<P></P>

<P>
<SPAN  CLASS="textbf">Restrictions:</SPAN>
<BR>

<UL>
<LI>The unmapped destination point detection doesn't currently work for this method. Even if there are unmapped points, no error will be returned. 
</LI>
</UL>

<P>

<P></P>

<P>
To use the nearest destination to source method the user may create their Fields on any stagger location (e.g. <TT>ESMF_STAGGERLOC_CENTER</TT>) for a Grid, or
 any Mesh location (e.g. <TT>ESMF_MESHLOC_NODE</TT>) for a Mesh. For either a Grid or a Mesh, the location upon which the Field is built 
 must contain coordinates. This method will also work with a source or destination Field built on a LocStream that contains coordinates, or when the source 
or destination Field is built on an XGrid.

<P>

<H3><A NAME="SECTION05012500000000000000"></A><A NAME="sec:interpolation:conserve"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Interpolation methods: first-order conservative
</H3>
 The goal of this method is to preserve the integral of the field across the interpolation from source to destination.  
 (For a more in-depth description of what this preservation of the integral (i.e. conservation) means please see section&nbsp;<A HREF="#sec:interpolation:conservation">24.2.7</A>.)  In this method the value across each source cell is treated as a constant, so it will typically have a larger 
 interpolation error than the bilinear or patch methods.  The first-order method used here is similar to that described in the following paper&nbsp;[<A
 HREF="node8.html#ConservativeOrder1">31</A>].

<P>
In the first-order method, the values for a particular destination cell are a calculated as a combination of the values of the intersecting 
 source cells. The weight of a given source cell's contribution 
 to the total being the amount that that source cell overlaps with the destination cell. 
 In particular, the weight is the ratio of the area of intersection of the source and destination cells to the area of the whole destination cell. 

<P>
To see a description of how the different normalization options affect the values and integrals produced by the conservative methods see section&nbsp;<A HREF="#sec:interpolation:conservative_norm_opts">24.2.8</A>. For Grids, Meshes, or XGrids on a sphere this method uses great circle cells, for a description of potential problems with these see&nbsp;<A HREF="#sec:interpolation:great_circle_cells">24.2.9</A>.

<P>

<P></P>

<P>
In 2D, ESMF supports conservative regridding between any combination of the following:

<UL>
<LI>Structured Grids (<TT>ESMF_Grid</TT>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<TT>ESMF_Mesh</TT>) composed of polygons with any number of sides
</LI>
<LI>An exchange grid (<TT>ESMF_XGrid</TT>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports conservative regridding between any combination of the following:

<UL>
<LI>Structured Grids (<TT>ESMF_Grid</TT>) composed of a single logically rectangular tile
</LI>
<LI>Unstructured Meshes (<TT>ESMF_Mesh</TT>) composed of hexahedrons (e.g. cubes) and tetrahedrons
 
</LI>
</UL>

<P>

<P></P>

<P>
<B>Restrictions:</B>

<UL>
<LI>Cells which contain enough identical corners to collapse to a line or point are optionally (via a flag) either ignored or return an error
</LI>
<LI>Self-intersecting cells (e.g. a cell twisted into a bow tie) are not supported
</LI>
<LI>On a spherical grid, cells which contain an edge which extends more than half way around the sphere are not supported 
</LI>
<LI>Source or destination Fields built on a Grid which contains a DE of width less than 2 elements are not supported
 
</LI>
</UL>

<P>

<P></P>

<P>
To use the conservative method the user should create their Fields on the center 
 stagger location (<TT>ESMF_STAGGERLOC_CENTER</TT> in 2D or <TT>ESMF_STAGGERLOC_CENTER_VCENTER</TT> in 3D) for Grids  or the element location (<TT>ESMF_MESHLOC_ELEMENT</TT>) for Meshes.
 For Grids, the corner stagger location (<TT>ESMF_STAGGERLOC_CORNER</TT> in 2D or <TT>ESMF_STAGGERLOC_CORNER_VFACE</TT> in 3D) must contain coordinates describing the outer perimeter of the Grid cells. This method will also work when the source or destination Field is built on an XGrid.

<P>

<H3><A NAME="SECTION05012600000000000000"></A><A NAME="sec:interpolation:conserve_2ndorder"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Interpolation methods: second-order conservative
</H3>
 Like the first-order conservative method, this method's goal is to preserve the integral of the field across the interpolation from source to destination.  
 (For a more in-depth description of what this preservation of the integral (i.e. conservation) means please see section&nbsp;<A HREF="#sec:interpolation:conservation">24.2.7</A>.)  The difference between the first and second-order conservative methods is that the second-order takes the source gradient into account, so
 it yields a smoother destination field that typically better matches the source field. This difference between the first and second-order methods 
 is particularly apparent when going from a coarse source grid to a finer destination grid. Another difference is that the second-order method
  does not guarantee that after regridding the range of values in the destination field is within the range of 
 values in the source field. For example, if the mininum value in the source field is 0.0, then it's possible that after regridding with the 
 second-order method, the destination field will contain values less than 0.0.  The implementation of this method is based on the one 
  described in this paper&nbsp;[<A
 HREF="node8.html#ConservativeOrder2">19</A>]. 

<P>
Like the first-order method, the values for a particular destination cell with the second-order method
 are a combination of the values of the intersecting source cells with the weight of a given source cell's contribution to the total 
 being the amount that that source cell overlaps with the destination cell. 
 However, with the second-order conservative interpolation there are additional terms that take into account the gradient of the field 
 across the source cell. In particular, the value <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$d$"></SPAN> for a given destination cell is calculated as:

<P>
<!-- MATH
 $d=\sum^{intersecting-source-cells}_{i}(s_{i}+\nabla s_{i} \cdot (c_{si}-c_{d}))$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="352" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$d=\sum^{intersecting-source-cells}_{i}(s_{i}+\nabla s_{i} \cdot (c_{si}-c_{d}))$"></SPAN>

<P>

<P></P>

<P>
Where:
<BR>
<DL>
<DD></DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.png"
 ALT="$s_{i}$"></SPAN></STRONG></DT>
<DD>is the intersecting source cell value. 
  
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG
 WIDTH="30" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img29.png"
 ALT="$\nabla s_{i}$"></SPAN></STRONG></DT>
<DD>is the intersecting source cell gradient. 
  
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG
 WIDTH="22" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img30.png"
 ALT="$c_{si}$"></SPAN></STRONG></DT>
<DD>is the intersecting source cell centroid. 
  
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$c_{d}$"></SPAN></STRONG></DT>
<DD>is the destination cell centroid. 
</DD>
</DL>

<P>

<P></P>

<P>
To see a description of how the different normalization options affect the values and integrals produced by the conservative methods see section&nbsp;<A HREF="#sec:interpolation:conservative_norm_opts">24.2.8</A>. For Grids, Meshes, or XGrids on a sphere this method uses great circle cells, for a description of potential problems with these see&nbsp;<A HREF="#sec:interpolation:great_circle_cells">24.2.9</A>.

<P>

<P></P>

<P>
In 2D, ESMF supports second-order conservative regridding between any combination of the following:

<UL>
<LI>Structured Grids (<TT>ESMF_Grid</TT>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<TT>ESMF_Mesh</TT>) composed of polygons with any number of sides
</LI>
<LI>An exchange grid (<TT>ESMF_XGrid</TT>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports second-order conservative regridding between any combination of the following:

<UL>
<LI>NONE
 
</LI>
</UL>

<P>

<P></P>

<P>
<B>Restrictions:</B>

<UL>
<LI>Cells which contain enough identical corners to collapse to a line or point are optionally (via a flag) either ignored or return an error
</LI>
<LI>Self-intersecting cells (e.g. a cell twisted into a bow tie) are not supported
</LI>
<LI>On a spherical grid, cells which contain an edge which extends more than half way around the sphere are not supported 
</LI>
<LI>Source or destination Fields built on a Grid which contains a DE of width less than 2 elements are not supported
 
</LI>
</UL>

<P>

<P></P>

<P>
To use the second-order conservative method the user should create their Fields on the center 
 stagger location (<TT>ESMF_STAGGERLOC_CENTER</TT> for Grids  or the element location (<TT>ESMF_MESHLOC_ELEMENT</TT>) for Meshes.
 For Grids, the corner stagger location (<TT>ESMF_STAGGERLOC_CORNER</TT> in 2D must contain coordinates describing the outer perimeter of the Grid cells. 
 This method will also work when the source or destination Field is built on an XGrid.

<P>

<H3><A NAME="SECTION05012700000000000000"></A><A NAME="sec:interpolation:conservation"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Conservation
</H3>
 Conservation means that the following equation will hold:  <!-- MATH
 $\sum^{all-source-cells}(V_{si}*A_{si}) = \sum^{all-destination-cells}(V_{dj}*A_{dj})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="430" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$\sum^{all-source-cells}(V_{si}*A_{si}) = \sum^{all-destination-cells}(V_{dj}*A_{dj})$"></SPAN>, where
 V is the variable being regridded and A is the area of a cell.  The subscripts s and d refer to source and destination values, and the i and j are the source  and destination grid cell indices (flattening the arrays to 1 dimension). 

<P>
If the user doesn't specify a cell areas in the involved Grids or Meshes, then the areas (A) in the above equation are calculated by ESMF. 
 For Cartesian grids, the area of a grid cell calculated by ESMF is the typical Cartesian area. 
 For grids on a sphere, cell areas are calculated by connecting the corner coordinates of each grid cell with great circles. If the user 
 does specify the areas in the Grid or Mesh, then the conservation will be adjusted to work for the areas 
 provided by the user. This means that the above equation will hold, but with the areas (A) being the ones specified by the user.

<P>
The user should be aware that because of the conservation relationship between the source and destination fields, the more the total source area
 differs from the total destination area the more the values of the source field will differ from the corresponding values of the destination field, 
 likely giving a higher interpolation error. It is best to have the total source and destination areas the same 
 (this will automatically be true if no user areas are specified). For source and destination grids 
 that only partially overlap, the overlapping regions of the source and destination should be the same.

<P>

<H3><A NAME="SECTION05012800000000000000"></A><A NAME="sec:interpolation:conservative_norm_opts"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> The effect of normalization options on integrals and values produced by conservative methods
</H3>
 It is important to note that by default (i.e. using destination area normalization) 
conservative regridding doesn't normalize the interpolation weights by the destination fraction. 
This means that for a destination grid which only partially overlaps the source grid
the destination field that is output from the regrid operation 
should be divided by the corresponding destination fraction to yield the 
true interpolated values for cells which are only partially covered by the source grid. 
The fraction also needs to be included when computing the total source and destination integrals. 
(To include the fraction in the conservative weights, the user can specify 
the fraction area normalization type. This can be done by specifying <TT>normType=ESMF_NORMTYPE_FRACAREA</TT> when
invoking <TT>ESMF_FieldRegridStore()</TT>.)

<P>
For weights generated using destination area normalization (either by not specifying any normalization type or by specifying <TT>normType=ESMF_NORMTYPE_DSTAREA</TT>), if a destination field extends 
outside the unmasked source field, then the values of the cells which 
extend partway outside the unmasked source field are decreased by the fraction they extend outside. 
To correct these values, the destination field (<TT>dst_field</TT>) resulting
from the <TT>ESMF_FieldRegrid()</TT> call can be divided by the destination fraction <TT>dst_frac</TT> 
from the <TT>ESMF_FieldRegridStore()</TT> call. The following pseudocode demonstrates  how to do this:

<P>
<PRE>

 for each destination element i
    if (dst_frac(i) not equal to 0.0) then
       dst_field(i)=dst_field(i)/dst_frac(i)
    end if
 end for
</PRE>

<P>
For weights generated using destination area normalization (either by not specifying any normalization type or by specifying <TT>normType=ESMF_NORMTYPE_DSTAREA</TT>), 
the following pseudo-code shows how to compute the total destination integral (<TT>dst_total</TT>) given the
destination field values (<TT>dst_field</TT>) resulting
from the <TT>ESMF_FieldRegrid()</TT> call, the destination area (<TT>dst_area</TT>) from the <TT>ESMF_FieldRegridGetArea()</TT> call,  and the destination fraction (<TT>dst_frac</TT>) from the <TT>ESMF_FieldRegridStore()</TT> call. As shown in the previous paragraph, it also 
shows how to adjust the destination field (<TT>dst_field</TT>) resulting from the <TT>ESMF_FieldRegrid()</TT> call by the
fraction (<TT>dst_frac</TT>) from the <TT>ESMF_FieldRegridStore()</TT> call: 

<P>
<PRE>

 dst_total=0.0
 for each destination element i
    if (dst_frac(i) not equal to 0.0) then
       dst_total=dst_total+dst_field(i)*dst_area(i) 
       dst_field(i)=dst_field(i)/dst_frac(i)
       ! If mass computed here after dst_field adjust, would need to be:
       ! dst_total=dst_total+dst_field(i)*dst_area(i)*dst_frac(i) 
    end if
 end for
</PRE>

<P>
For weights generated using fraction area normalization (by specifying <TT>normType=ESMF_NORMTYPE_FRACAREA</TT>),
no adjustment of the destination field is necessary. The following pseudo-code shows how to compute 
the total destination integral (<TT>dst_total</TT>) given the
destination field values (<TT>dst_field</TT>) resulting
from the <TT>ESMF_FieldRegrid()</TT> call, the destination area (<TT>dst_area</TT>) from the <TT>ESMF_FieldRegridGetArea()</TT>
call,  and the destination fraction (<TT>dst_frac</TT>) from the <TT>ESMF_FieldRegridStore()</TT> call:

<P>
<PRE>
 dst_total=0.0
 for each destination element i
      dst_total=dst_total+dst_field(i)*dst_area(i)*dst_frac(i) 
 end for
</PRE>

<P>
For both normalization types, the following pseudo-code shows how to compute the total source integral (<TT>src_total</TT>) given the source field values
 (<TT>src_field</TT>), the source area (<TT>src_area</TT>) from the <TT>ESMF_FieldRegridGetArea()</TT> call, and
 the source fraction (<TT>src_frac</TT>) from the <TT>ESMF_FieldRegridStore()</TT> call:

<P>
<PRE>
 src_total=0.0
 for each source element i
    src_total=src_total+src_field(i)*src_area(i)*src_frac(i)
 end for
</PRE>

<P>

<H3><A NAME="SECTION05012900000000000000"></A><A NAME="sec:interpolation:great_circle_cells"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">9</SPAN> Great circle cells
</H3>
 For Grids, Meshes, or XGrids on a sphere some combinations of interpolation options 
 (e.g. first and second-order conservative methods) use cells whose edges are great circles. This section describes some behavior 
 that the user may not expect from these cells and some potential solutions. 

<P>
A great circle edge isn't necessarily the same as a straight line in latitude longitude space. 
 For small edges, this difference will be small, but for long edges it
 could be significant. This means if the user expects cell edges as straight lines in latitude longitude 
 space, they should avoid using one large cell with 
 long edges to compute an average over a region (e.g. over an ocean basin).

<P>
Also, the  user should also avoid using cells that contain one edge that runs half way or more around the earth, because the 
 regrid weight calculation assumes the edge follows the shorter great circle path. 
 There isn't a unique great circle edge defined between points on the 
 exact opposite side of the earth from one another (antipodal points). 
 However, the user can work around both of these problem by breaking the long edge into two smaller edges by inserting 
 an extra node, or by breaking the large target grid cells 
 into two or more smaller grid cells. This allows the application to resolve the ambiguity in edge direction. 

<P>

<H3><A NAME="SECTION050121000000000000000"></A>
<A NAME="regrid:masking"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">10</SPAN> Masking
</H3>
Masking is the process whereby parts of a Grid, Mesh, or LocStream 
can be marked to be ignored during an operation, such as when they 
are used in regridding.  Masking can be used on a Field created from 
a regridding source to indicate that certain portions should not be 
used to generate regridded data.  This is useful, for example, if a 
portion of the source contains unusable values.  Masking can also be 
used on a Field created from a regridding destination to indicate 
that a certain portion should not receive regridded data.  This is 
useful, for example, when part of the destination isn't being used 
(e.g. the land portion of an ocean grid).

<P>
The user may mask out points in the source
Field or destination Field or both. To do masking the user sets
mask information in the Grid (see <A HREF="#sec:usage:items">31.3.17</A>), Mesh
(see <A HREF="#sec:mesh:mask">33.3.11</A>), or LocStream (see <A HREF="#const:maskkeyname">32.2.2</A>)
upon which the Fields passed into the
<TT>ESMF_FieldRegridStore()</TT> call are built. The <TT>srcMaskValues</TT>
and <TT>dstMaskValues</TT> arguments to that
call can then be used to specify which values in that mask
information indicate that a location should be masked out. For
example, if <TT>dstMaskValues</TT> is set to (/1,2/), then any location that
has a value of 1 or 2 in the mask information of the Grid, Mesh or LocStream
upon which the destination Field is built will be masked out.

<P>
Masking behavior differs slightly between regridding methods. For
non-conservative regridding methods (e.g. bilinear or high-order
patch), masking is done on points. For these methods, masking a
destination point means that that point won't participate in
regridding (e.g. won't be interpolated to). For these methods,
masking a source point means that the entire source cell using
that point is masked out. In other words, if any corner point
making up a source cell is masked then the cell is masked. For
conservative regridding methods (e.g. first-order conservative)
masking is done on cells. Masking a destination cell means that
the cell won't participate in regridding (e.g. won't be
interpolated to). Similarly, masking a source cell means that the
cell won't participate in regridding (e.g. won't be interpolated
from).  For any type of interpolation method (conservative or
non-conservative) the masking is set on the location upon
which the Fields passed into the regridding call are built.
For example, if Fields built on  <TT>ESMF_STAGGERLOC_CENTER</TT> are
passed into the <TT>ESMF_FieldRegridStore()</TT> call then the masking
should also be set on <TT>ESMF_STAGGERLOC_CENTER</TT>.

<P>

<H3><A NAME="SECTION050121100000000000000"></A><A NAME="sec:extrapolation:overview"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">11</SPAN> Extrapolation methods: overview
</H3>

<P>
Extrapolation in the ESMF regridding system is a way to automatically fill some or all of the 
destination points left unmapped by a regridding method. Weights generated by
the extrapolation method are merged into the regridding weights to yield one set of weights or 
routehandle. Currently extrapolation is not supported with conservative regridding methods, because 
doing so would result in non-conservative weights. 

<P>

<H3><A NAME="SECTION050121200000000000000"></A><A NAME="sec:extrapolation:neareststod"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">12</SPAN> Extrapolation methods: nearest source to destination
</H3>
In nearest source to destination extrapolation (<TT>ESMF_EXTRAPMETHOD_NEAREST_STOD</TT>) each unmapped 
destination point is mapped to the closest source point. A given source point may map to 
multiple destination points, but no destination point will receive input from more than one source point. 
If two points are equally close, then the point with the smallest sequence index is arbitrarily used 
(i.e. the point which would have the smallest index in the weight matrix). 

<P>
If there is at least one unmasked source point, then this method is expected to fill all unmapped points. 

<P>

<H3><A NAME="SECTION050121300000000000000"></A><A NAME="sec:extrapolation:nearestidavg"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">13</SPAN> Extrapolation methods: inverse distance weighted average
</H3>
In inverse distance weighted average extrapolation (<TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT>) each unmapped 
destination point is the weighted average of the closest N source points. The weight is 
the reciprocal of the distance of the source point from the destination point raised to a power P.
All the weights contributing to one destination point are normalized so that they sum to 1.0. 
The user can choose N and P when using this method, but defaults are also provided. For example, when 
calling <TT>ESMF_FieldRegridStore()</TT> N is specified via the argument <TT>extrapNumSrcPnts</TT> and 
P is specified via the argument <TT>extrapDistExponent</TT>.  

<P>
If there is at least one unmasked source point, then this method is expected to fill all unmapped points. 

<P>

<H3><A NAME="SECTION050121400000000000000"></A><A NAME="sec:extrapolation:creep"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">14</SPAN> Extrapolation methods: creep fill
</H3>
In creep fill extrapolation (<TT>ESMF_EXTRAPMETHOD_CREEP</TT>) unmapped destination points are filled by 
repeatedly moving data from mapped locations to neighboring unmapped locations for a user specified 
number of levels. More precisely, for each creeped point, its value is the average of the values of the 
point's immediate neighbors in the previous level. For the first level, the values are the average of the 
point's immediate neighbors in the destination points mapped by the regridding method. The number of creep levels
is specified by the user. For example, in ESMF_FieldRegridStore() this number of levels is specified 
via the <TT>extrapNumLevels</TT> argument. 

<P>
Unlike some extrapolation methods, creep fill does not necessarily 
fill all unmapped destination points. Unfilled destination points are still unmapped with the usual 
consequences (e.g. they won't be in the resulting regridding matrix, and won't be set by the application 
of the regridding weights).

<P>
Because it depends on the connections in the destination grid, creep fill extrapolation is not supported when the 
destination Field is built on a Location Stream (ESMF_LocStream). Also, creep fill is currently only supported for 
2D Grids, Meshes, or XGrids

<P>

<H3><A NAME="SECTION050121500000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">15</SPAN> Unmapped destination points</A>
</H3>
 If a destination point can't be mapped to a location in the source grid by the combination of regrid method and 
 optional follow on extrapolation method, then the user has two choices. The user may ignore those destination points
 that can't be mapped by setting the <TT>unmappedaction</TT> argument to <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> (Ignored points won't be included in
 the sparse matrix or routeHandle). If the user needs the unmapped points, the <TT>ESMF_FieldRegridStore()</TT> method has the capability to return
 a list of them using the <TT>unmappedDstList</TT> argument.  In addition to ignoring them, the user also has the option to return
 an error if unmapped destination points exist. This is the default behavior, so the user can either not set the <TT>unmappedaction</TT> argument
 or the user can set it to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. Currently, the unmapped destination error detection doesn't 
 work with the nearest destination to source regrid method (<TT>ESMF_REGRIDMETHOD_NEAREST_DTOS</TT>), so with this method the regridding 
 behaves as if <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> is always on. 

<P>

<H3><A NAME="SECTION050121600000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN> Spherical grids and poles</A>
</H3>
In the case that the Grid is on a sphere (<TT>coordSys=ESMF_COORDSYS_SPH_DEG or ESMF_COORDSYS_SPH_RAD</TT>)
then the coordinates given in the Grid are interpreted as latitude and longitude values. The coordinates can either be in degrees or radians as indicated by the 
<TT>coordSys</TT> flag set during Grid creation. As is true with many global models, this application currently assumes the latitude and longitude refer to positions on a 
perfect sphere, as opposed to a more complex and accurate representation of the Earth's true shape such as would be used in a GIS system. (ESMF's current user base doesn't 
require this level of detail in representing the Earth's shape, but it could be added in the future if necessary.)

<P>
For Grids on a sphere, the regridding occurs in 3D Cartesian to avoid
problems with periodicity and with the pole singularity. This library
 supports four options for handling the pole region (i.e. the empty area above the top row of the source grid or below
 the bottom row of the source grid).  Note that all of these pole options currently only work for the Fields build on the Grid class.

<P>
The first option is to leave the pole region empty (<TT>polemethod=ESMF_POLEMETHOD_NONE</TT>), in this 
 case if a destination point lies above or below the 
 top row of the source grid, it will fail to map, yielding an error (unless <TT>unmappedaction=ESMF_UNMAPPEDACTION_IGNORE</TT> is specified).  

<P>
With the next two options (<TT>ESMF_POLEMETHOD_ALLAVG</TT> and <TT>ESMF_POLEMETHOD_NPNTAVG</TT>), the pole region is handled by constructing 
 an artificial pole in the center of the top and bottom row of grid points and then filling
 in the region from this pole to the edges of the source grid with triangles. 
 The pole is located at the average of the position of the points surrounding
 it, but moved outward to be at the same radius as the rest of the points
 in the grid. The difference between the two artificial pole options is what value is used at the pole. 
 The option (<TT>polemethod=ESMF_POLEMETHOD_ALLAVG</TT>) sets the value at the pole to be the average of the values
 of all of the grid points surrounding the pole. The option (<TT>polemethod=ESMF_POLEMETHOD_NPNTAVG</TT>) allows the user to choose
 a number N from 1 to the number of source grid points around the pole. The value N is set via the argument <TT>regridPoleNPnts</TT>. For
 each destination point, the value at the pole is then the average of the N source points
 surrounding that destination point. 

<P>
The last option (<TT>polemethod=ESMF_POLEMETHOD_TEETH</TT>) does not construct an artificial pole, instead the
 pole region is covered by connecting points across the top and bottom row of the source Grid into triangles. As 
 this makes the top and bottom of the source sphere flat, for a big enough difference between the size of
 the source and destination pole regions, this can still result in unmapped destination points.  
 Only pole option <TT>ESMF_POLEMETHOD_NONE</TT> is currently supported with the conservative interpolation methods 
 (e.g. <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE</TT>) and with the nearest neighbor interpolation options (e.g. <TT>regridmethod=ESMF_REGRIDMETHOD_NEAREST_STOD</TT>).

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="17455"></A>
<TABLE>
<CAPTION><STRONG>Table 2:</STRONG>
Line Type Support by Regrid Method (* indicates the default)</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Regrid Method</TD>
<TD ALIGN="CENTER" COLSPAN=2><SPAN>Line Type</SPAN></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER">ESMF_LINETYPE_CART</TD>
<TD ALIGN="CENTER">ESMF_LINETYPE_GREAT_CIRCLE</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_REGRIDMETHOD_BILINEAR</TD>
<TD ALIGN="CENTER">Y*</TD>
<TD ALIGN="CENTER">Y</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_REGRIDMETHOD_PATCH</TD>
<TD ALIGN="CENTER">Y*</TD>
<TD ALIGN="CENTER">Y</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_REGRIDMETHOD_NEAREST_STOD</TD>
<TD ALIGN="CENTER">Y*</TD>
<TD ALIGN="CENTER">N</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_REGRIDMETHOD_NEAREST_DTOS</TD>
<TD ALIGN="CENTER">Y*</TD>
<TD ALIGN="CENTER">N</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_REGRIDMETHOD_CONSERVE</TD>
<TD ALIGN="CENTER">N/A</TD>
<TD ALIGN="CENTER">Y*</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_REGRIDMETHOD_CONSERVE_2ND</TD>
<TD ALIGN="CENTER">N/A</TD>
<TD ALIGN="CENTER">Y*</TD>
</TR>
</TABLE>
<A NAME="line_type_support"></A>
</TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Another variation in the regridding supported with spherical grids is <B>line type</B>. This is controlled in the
<TT>ESMF_FieldRegridStore()</TT> method by the <TT>lineType</TT> argument. This argument allows the user to select the path of the line which connects
two points on a sphere surface. This in turn controls the path along which distances are calculated and the shape of 
the edges that make up a cell. Both of these quantities can influence how interpolation weights are calculated, for example in
bilinear interpolation the distances are used to calculate the weights and the cell edges are used to determine to which source 
cell a destination point should be mapped. 

<P>
ESMF currently supports two line types: ESMF_LINETYPE_CART and ESMF_LINETYPE_GREAT_CIRCLE. The ESMF_LINETYPE_CART option 
specifies that the line between two points follows a straight path through the 3D Cartesian space in which the sphere is embedded.
Distances are measured along 
this 3D Cartesian line. Under this option cells are approximated by planes in 3D space, and their boundaries are 3D Cartesian lines
between their corner points.  The ESMF_LINETYPE_GREAT_CIRCLE option specifies that the line between two points follows
a great circle path along the sphere surface. (A great circle is the shortest path between two points on a sphere.) 
Distances are measured along the great circle path. Under this option cells are on the sphere surface, and their boundaries 
are great circle paths between their corner points. 

<P>
Figure&nbsp;<A HREF="#line_type_support">24.2.16</A> shows which line types are supported for each regrid method as well as the defaults (indicated by *). 

<P>

<H3><A NAME="SECTION050121700000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">17</SPAN> Troubleshooting guide</A>
</H3>

<P>
The below is a list of problems users commonly encounter with regridding and potential solutions. 
 This is by no means an exhaustive list, so if none of these problems fit your case, or if the solutions
 don't fix your problem, please feel free to email esmf support (esmf_support@ucar.edu).

<P>

<P><P>
<BR>

<P>
<B>Problem:</B> Regridding is too slow.

<P>

<P>
<BR>

<P>
<B>Possible Cause:</B> The <TT>ESMF_FieldRegridStore()</TT> method is called more than is necessary. <BR>
The <TT>ESMF_FieldRegridStore()</TT> operation is a complex one and can be 
 relatively slow for some cases (large Grids, 3D grids, etc.) 

<P>

<P></P>

<P>
<B>Solution:</B> Reduce the number of <TT>ESMF_FieldRegridStore()</TT> calls to the minimum necessary. The
 routeHandle generated by the <TT>ESMF_FieldRegridStore()</TT> call depends on only four factors: the 
 stagger locations that the input Fields are created on, the coordinates in the Grids the input Fields
 are built on at those stagger locations, the padding of the input Fields 
 (specified by the <TT>totalWidth</TT> arguments in <TT>FieldCreate</TT>) and the size of the tensor
 dimensions in the input Fields (specified by the <TT>ungridded</TT> arguments in <TT>FieldCreate</TT>). 
 For any pair of Fields which share these attributes with the Fields used in the
 <TT>ESMF_FieldRegridStore</TT> call  the same routeHandle can be used. Note that the data in the 
 Fields does NOT matter, the same routeHandle can be used no matter how the data in the Fields changes.

<P>

<P></P>

<P>
In particular:
 
<UL>
<LI>If Grid coordinates do not change during a run, then the <TT>ESMF_FieldRegridStore()</TT> call can be
 done once between a pair of Fields at the beginning and the resulting routeHandle used for each 
 timestep during the run. 

<P>
</LI>
<LI>If a pair of Fields was created with exactly the same arguments to <TT>ESMF_FieldCreate()</TT> as the 
 pair of Fields used during an <TT>ESMF_FieldRegridStore()</TT> call, then the resulting routeHandle can 
 also be used between that pair of Fields. 
 
</LI>
</UL>

<P>

<P><P>
<BR>

<P>
<B>Problem:</B> Distortions in destination Field at periodic boundary.

<P>

<P>
<BR>

<P>
<B>Possible Cause:</B> The Grid overlaps itself. With a periodic Grid, the regrid system expects
  the first point to not be a repeat of the last point. In other words,
  regrid constructs its own connection and overlap between the first and last points of the
  periodic dimension and so the Grid doesn't need to contain these. If the Grid does, then this
  can cause problems. 

<P>

<P></P>

<P>
<B>Solution:</B> Define the Grid so that it doesn't contain the overlap point. This typically means simply making
 the Grid one point smaller in the periodic dimension.  If a Field 
 constructed on the Grid needs to contain these overlap points then the user can use the
 <TT>totalWidth</TT> arguments to include this extra padding in the Field. Note, however, 
 that the regrid won't update these extra points, so the user will have to do a copy to fill the points
 in the overlap region in the Field.  

<P>

<H3><A NAME="SECTION050121800000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">18</SPAN> Restrictions and Future Work</A>
</H3>
This section contains restrictions that apply to the entire regridding system. For restrictions that apply to just one interpolation method, see the section corresponding to that method above.

<P>

<UL>
<LI><B>Regridding doesn't work on a Field created on a Grid with an arbitrary distribution:</B> Using a Field built on a Grid with an arbitrary distribution will cause the regridding to stop with an error.  

<P>
</LI>
</UL>

<P>

<H3><A NAME="SECTION050121900000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">19</SPAN> Design and implementation notes</A>
</H3>

<P>
The ESMF regrid weight calculation functionality has been designed to enable it to support a wide range
of grid and interpolation types without needing to support each individual combination of source grid type,
destination grid type, and interpolation method. To avoid the quadratic growth of the number of pairs
of grid types, all grids are converted to a common internal format and the regrid weight calculation
is performed on that format. This vastly reduces the variety of grids that need to be supported in 
the weight calculations for each interpolation method. It also has the added benefit of making it
straightforward to add new grid types and to allow them to work with all the existing grid types.
To hook into the existing weight calculation code, the new type just needs to be converted to the
internal format. 

<P>
The internal grid format used by the ESMF regrid weight calculation is a finite element
unstructured mesh. This was chosen because it was the most general format and all the others could be 
converted to it. The ESMF finite element unstructured mesh (ESMF FEM) is similar in some respects to the SIERRA&nbsp;[<A
 HREF="node8.html#Sierra">20</A>] package 
developed at Sandia National Laboratory. The ESMF code relies on some of the same underlying toolkits (e.g. Zoltan&nbsp;[<A
 HREF="node8.html#Zoltan">18</A>] library 
for calculating mesh partitions) and adds a layer on top that allows the calculation of regrid weights and some mesh operations 
(e.g. mesh redistribution) that ESMF needs. The ESMF FEM has similar notions to SIERRA about the basic structure of the
mesh entities, fields, iteration and a similar notion of parallel distribution. 

<P>
Currently we use the ESMF FEM internal mesh to hold the structure of our Mesh class and 
in our regrid weight calculation. The parts of the internal FEM code that are used/tested by ESMF are the following:

<UL>
<LI>The creation of a mesh composed of triangles and quadrilaterals or hexahedrons and tetrahedrons.
</LI>
<LI>The object relations data base to store the connections between objects (e.g. which element contains which nodes).
</LI>
<LI>The fields to hold data (e.g. coordinates). We currently only build fields on nodes and elements (2D and 3D).
</LI>
<LI>Iteration to move through mesh entities.
</LI>
<LI>The parallel code to maintain information about the distribution of the mesh across processors and to communicate data between parts of the mesh on different processors (i.e. halos).
</LI>
</UL>

<P>

<H2><A NAME="SECTION05013000000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN> File-based Regrid API</A>
</H2>&nbsp;<A NAME="sec:filebasedregrid"></A>

<P>

<P>

<P>

<H3><A NAME="SECTION05013100000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_RegridWeightGen - Generate regrid weight file from grid files</A>
</H3>

<P>
<A NAME="api:esmf_regridweightgenfile"></A>
<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_RegridWeightGen()
   subroutine ESMF_RegridWeightGenFile(srcFile, dstFile, &amp;
     weightFile, rhFile, regridmethod, polemethod, regridPoleNPnts, lineType, normType, &amp;
     extrapMethod, extrapNumSrcPnts, extrapDistExponent, extrapNumLevels, &amp;
     unmappedaction, ignoreDegenerate, srcFileType, dstFileType, &amp;
     srcRegionalFlag, dstRegionalFlag, srcMeshname, dstMeshname,  &amp;
     srcMissingvalueFlag, srcMissingvalueVar, &amp;
     dstMissingvalueFlag, dstMissingvalueVar, &amp;
     useSrcCoordFlag, srcCoordinateVars, &amp;
     useDstCoordFlag, dstCoordinateVars, &amp;
     useSrcCornerFlag, useDstCornerFlag, &amp;
     useUserAreaFlag, largefileFlag, &amp;
     netcdf4fileFlag, weightOnlyFlag, &amp;
     tileFilePath, &amp;
     verboseFlag, checkFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> 
   character(len=*),             intent(in)            :: srcFile
   character(len=*),             intent(in)            :: dstFile
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character(len=*),             intent(in),  optional :: weightFile
   character(len=*),             intent(in),  optional :: rhFile
   type(ESMF_RegridMethod_Flag), intent(in),  optional :: regridmethod
   type(ESMF_PoleMethod_Flag),   intent(in),  optional :: polemethod
   integer,                      intent(in),  optional :: regridPoleNPnts
   type(ESMF_LineType_Flag),     intent(in),  optional :: lineType
   type(ESMF_NormType_Flag),     intent(in),  optional :: normType
   type(ESMF_ExtrapMethod_Flag),   intent(in),    optional :: extrapMethod
   integer,                        intent(in),    optional :: extrapNumSrcPnts
   real,                           intent(in),    optional :: extrapDistExponent
   integer,                      intent(in), optional :: extrapNumLevels
   type(ESMF_UnmappedAction_Flag),intent(in), optional :: unmappedaction
   logical,                      intent(in),  optional :: ignoreDegenerate
   type(ESMF_FileFormat_Flag),   intent(in),  optional :: srcFileType
   type(ESMF_FileFormat_Flag),   intent(in),  optional :: dstFileType
   logical,                      intent(in),  optional :: srcRegionalFlag
   logical,                      intent(in),  optional :: dstRegionalFlag
   character(len=*),             intent(in),  optional :: srcMeshname
   character(len=*),             intent(in),  optional :: dstMeshname
   logical,                      intent(in),  optional :: srcMissingValueFlag
   character(len=*),             intent(in),  optional :: srcMissingValueVar
   logical,                      intent(in),  optional :: dstMissingValueFlag
   character(len=*),             intent(in),  optional :: dstMissingValueVar
   logical,                      intent(in),  optional :: useSrcCoordFlag
   character(len=*),             intent(in),  optional :: srcCoordinateVars(:)
   logical,                      intent(in),  optional :: useDstCoordFlag
   character(len=*),             intent(in),  optional :: dstCoordinateVars(:)
   logical,                      intent(in),  optional :: useSrcCornerFlag
   logical,                      intent(in),  optional :: useDstCornerFlag
   logical,                      intent(in),  optional :: useUserAreaFlag
   logical,                      intent(in),  optional :: largefileFlag
   logical,                      intent(in),  optional :: netcdf4fileFlag
   logical,                      intent(in),  optional :: weightOnlyFlag
   character(len=*),             intent(in),  optional :: tileFilePath
   logical,                      intent(in),  optional :: verboseFlag
   logical,                      intent(in),  optional :: checkFlag
   integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine provides the same function as the <TT>ESMF_RegridWeightGen</TT> application
   described in Section&nbsp;<A HREF="node3.html#sec:ESMF_RegridWeightGen">12</A>.  It takes two grid files in NetCDF format and writes out an
   interpolation weight file also in NetCDF format.  The interpolation weights can be generated with the
   bilinear&nbsp;(<A HREF="#sec:interpolation:bilinear">24.2.1</A>), higher-order patch&nbsp;(<A HREF="#sec:interpolation:patch">24.2.2</A>),
   or first order conservative&nbsp;(<A HREF="#sec:interpolation:conserve">24.2.5</A>) methods.  The grid files can be in
   one of the following four formats:
   
<UL>
<LI>The SCRIP format&nbsp;(<A HREF="node3.html#sec:fileformat:scrip">12.8.1</A>)
</LI>
<LI>The native ESMF format for an unstructured grid&nbsp;(<A HREF="node3.html#sec:fileformat:esmf">12.8.2</A>)
</LI>
<LI>The CF Convention Single Tile File format&nbsp;(<A HREF="node3.html#sec:fileformat:gridspec">12.8.3</A>)
</LI>
<LI>The proposed CF Unstructured grid (UGRID) format&nbsp;(<A HREF="node3.html#sec:fileformat:ugrid">12.8.4</A>)
</LI>
<LI>The GRIDSPEC Mosaic File format&nbsp;(<A HREF="node3.html#sec:fileformat:mosaic">12.8.5</A>)
   
</LI>
</UL>
   
<P></P>
The weight file is created in SCRIP format&nbsp;(<A HREF="node3.html#sec:weightfileformat">12.9</A>).
   The optional arguments allow users to specify various options to control the regrid operation,
   such as which pole option to use,
   whether to use user-specified area in the conservative regridding, or whether ESMF should generate masks using a given
   variable's missing value.  There are also optional arguments specific to a certain type of the grid file.
   All the optional arguments are similar to the command line arguments for the <TT>ESMF_RegridWeightGen</TT>
   application&nbsp;(<A HREF="node3.html#sec:regridusage">12.6</A>). The acceptable values and the default value for the optional arguments
   are listed below.

<P>
The arguments are:
     <DL>
<DT><STRONG>srcFile</STRONG></DT>
<DD>The source grid file name.
     
</DD>
<DT><STRONG>dstFile</STRONG></DT>
<DD>The destination grid file name.
     
</DD>
<DT><STRONG>weightFile</STRONG></DT>
<DD>The interpolation weight file name.
     
</DD>
<DT><STRONG>[rhFile]</STRONG></DT>
<DD>The RouteHandle file name.
     
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. Please see Section&nbsp;<A HREF="node9.html#opt:regridmethod">54.49</A>
       for a list of valid options. If not specified, defaults to
       <TT>ESMF_REGRIDMETHOD_BILINEAR</TT>.
     
</DD>
<DT><STRONG>[polemethod]</STRONG></DT>
<DD>A flag to indicate which type of artificial pole
       to construct on the source Grid for regridding. Please see
       Section&nbsp;<A HREF="node9.html#const:polemethod">54.46</A> for a list of valid options.
       The default value varies depending on the regridding method and the grid type and format.
     
</DD>
<DT><STRONG>[regridPoleNPnts]</STRONG></DT>
<DD>If <TT>polemethod</TT> is set to <TT>ESMF_POLEMETHOD_NPNTAVG</TT>, this argument is required to
       specify how many points should be averaged over at the pole.
     
</DD>
<DT><STRONG>[lineType]</STRONG></DT>
<DD>This argument controls the path of the line which connects two points on a sphere surface. This in
             turn controls the path along which distances are calculated and the shape of the edges that make
             up a cell. Both of these quantities can influence how interpolation weights are calculated.
             As would be expected, this argument is only applicable when <TT>srcField</TT> and <TT>dstField</TT> are
             built on grids which lie on the surface of a sphere. Section&nbsp;<A HREF="node9.html#opt:lineType">54.34</A> shows a
             list of valid options for this argument. If not specified, the default depends on the
             regrid method. Section&nbsp;<A HREF="node9.html#opt:lineType">54.34</A> has the defaults by line type. Figure&nbsp;<A HREF="#line_type_support">24.2.16</A> shows
             which line types are supported for each regrid method as well as showing the default line type by regrid method.
       
</DD>
<DT><STRONG>[normType]</STRONG></DT>
<DD>This argument controls the type of normalization used when generating conservative weights. This option
             only applies to weights generated with <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE</TT>. Please see
             Section&nbsp;<A HREF="node9.html#opt:normType">54.43</A> for a
             list of valid options. If not specified <TT>normType</TT> defaults to <TT>ESMF_NORMTYPE_DSTAREA</TT>.
       
</DD>
<DT><STRONG>[extrapMethod]</STRONG></DT>
<DD>The type of extrapolation. Please see Section&nbsp;<A HREF="node9.html#opt:extrapmethod">54.17</A>
             for a list of valid options. If not specified, defaults to
             <TT>ESMF_EXTRAPMETHOD_NONE</TT>.
       
</DD>
<DT><STRONG>[extrapNumSrcPnts]</STRONG></DT>
<DD>The number of source points to use for the extrapolation methods that use more than one source point
             (e.g. <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT>). If not specified, defaults to 8.
       
</DD>
<DT><STRONG>[extrapDistExponent]</STRONG></DT>
<DD>The exponent to raise the distance to when calculating weights for
             the <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT> extrapolation method. A higher value reduces the influence
             of more distant points. If not specified, defaults to 2.0.
       
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Please see Section&nbsp;<A HREF="node9.html#const:unmappedaction">54.60</A> for a
             list of valid options. If not specified, <TT>unmappedaction</TT> defaults to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>.
       
</DD>
<DT><STRONG>[ignoreDegenerate]</STRONG></DT>
<DD>Ignore degenerate cells when checking the input Grids or Meshes for errors. If this is set to true, then the
             regridding proceeds, but degenerate cells will be skipped. If set to false, a degenerate cell produces an error.
             If not specified, <TT>ignoreDegenerate</TT> defaults to false.
     
</DD>
<DT><STRONG>[srcFileType]</STRONG></DT>
<DD>The file format of the source grid. Please see
       Section&nbsp;<A HREF="node9.html#const:fileformatflag">54.19</A> for a list of valid options. 
        If not specifed, the program will determine the file format automatically.
     
</DD>
<DT><STRONG>[dstFileType]</STRONG></DT>
<DD>The file format of the destination grid.  Please see Section&nbsp;<A HREF="node9.html#const:fileformatflag">54.19</A> for a list of valid options.
        If not specifed, the program will determine the file format automatically.
     
</DD>
<DT><STRONG>[srcRegionalFlag]</STRONG></DT>
<DD>If .TRUE., the source grid is a regional grid, otherwise,
       it is a global grid.  The default value is .FALSE.
     
</DD>
<DT><STRONG>[dstRegionalFlag]</STRONG></DT>
<DD>If .TRUE., the destination grid is a regional grid, otherwise,
       it is a global grid.  The default value is .FALSE.
     
</DD>
<DT><STRONG>[srcMeshname]</STRONG></DT>
<DD>If the source file is in UGRID format, this argument is required
       to define the dummy variable name in the grid file that contains the
       mesh topology info.
     
</DD>
<DT><STRONG>[dstMeshname]</STRONG></DT>
<DD>If the destination file is in UGRID format, this argument is required
       to define the dummy variable name in the grid file that contains the
       mesh topology info.
     
</DD>
<DT><STRONG>[srcMissingValueFlag]</STRONG></DT>
<DD>If .TRUE., the source grid mask will be constructed using the missing
       values of the variable defined in <TT>srcMissingValueVar</TT>. This flag is
       only used for the grid defined in  the GRIDSPEC or the UGRID file formats.
       The default value is .FALSE..
     
</DD>
<DT><STRONG>[srcMissingValueVar]</STRONG></DT>
<DD>If <TT>srcMissingValueFlag</TT> is .TRUE., the argument is required to define
       the variable name whose missing values will be used to construct the grid
       mask.  It is only used for the grid defined in  the GRIDSPEC or the UGRID
       file formats.
     
</DD>
<DT><STRONG>[dstMissingValueFlag]</STRONG></DT>
<DD>If .TRUE., the destination grid mask will be constructed using the missing
       values of the variable defined in <TT>dstMissingValueVar</TT>. This flag is
       only used for the grid defined in  the GRIDSPEC or the UGRID file formats.
       The default value is .FALSE..
     
</DD>
<DT><STRONG>[dstMissingValueVar]</STRONG></DT>
<DD>If <TT>dstMissingValueFlag</TT> is .TRUE., the argument is required to define
       the variable name whose missing values will be used to construct the grid
       mask.  It is only used for the grid defined in  the GRIDSPEC or the UGRID
       file formats.
     
</DD>
<DT><STRONG>[useSrcCoordFlag]</STRONG></DT>
<DD>If .TRUE., the coordinate variables defined in <TT>srcCoordinateVars</TT> will
       be used as the longitude and latitude variables for the source grid.
       This flag is only used for the GRIDSPEC file format.  The default is .FALSE.
     
</DD>
<DT><STRONG>[srcCoordinateVars]</STRONG></DT>
<DD>If <TT>useSrcCoordFlag</TT> is .TRUE., this argument defines the longitude and
  !     latitude variables in the source grid file to be used for the regrid.
       This argument is only used when the grid file is in GRIDSPEC format.
       <TT>srcCoordinateVars</TT> should be a array of 2 elements.
     
</DD>
<DT><STRONG>[useDstCoordFlag]</STRONG></DT>
<DD>If .TRUE., the coordinate variables defined in <TT>dstCoordinateVars</TT> will
       be used as the longitude and latitude variables for the destination grid.
       This flag is only used for the GRIDSPEC file format.  The default is .FALSE.
     
</DD>
<DT><STRONG>[dstCoordinateVars]</STRONG></DT>
<DD>If <TT>useDstCoordFlag</TT> is .TRUE., this argument defines the longitude and
       latitude variables in the destination grid file to be used for the regrid.
       This argument is only used when the grid file is in GRIDSPEC format.
       <TT>dstCoordinateVars</TT> should be a array of 2 elements.
     
</DD>
<DT><STRONG>[useSrcCornerFlag]</STRONG></DT>
<DD>If <TT>useSrcCornerFlag</TT> is .TRUE., the corner coordinates of the source file
       will be used for regridding. Otherwise, the center coordinates will be us ed.
       The default is .FALSE. The corner stagger is not supported for the SCRIP formatted input
       grid or multi-tile GRIDSPEC MOSAIC input grid.
     
</DD>
<DT><STRONG>[useDstCornerFlag]</STRONG></DT>
<DD>If <TT>useDstCornerFlag</TT> is .TRUE., the corner coordinates of the destination file
       will be used for regridding. Otherwise, the center coordinates will be used.
       The default is .FALSE. The corner stagger is not supported for the SCRIP formatted input
       grid or multi-tile GRIDSPEC MOSAIC input grid.
     
</DD>
<DT><STRONG>[useUserAreaFlag]</STRONG></DT>
<DD>If .TRUE., the element area values defined in the grid files are used.
       Only the SCRIP and ESMF format grid files have user specified areas. This flag
       is only used for conservative regridding. The default is .FALSE..
     
</DD>
<DT><STRONG>[largefileFlag]</STRONG></DT>
<DD>If .TRUE., the output weight file is in NetCDF 64bit offset format.
       The default is .FALSE..
     
</DD>
<DT><STRONG>[netcdf4fileFlag]</STRONG></DT>
<DD>If .TRUE., the output weight file is in NetCDF4 file format.
       The default is .FALSE..
     
</DD>
<DT><STRONG>[weightOnlyFlag]</STRONG></DT>
<DD>If .TRUE., the output weight file only contains factorList and factorIndexList.
       The default is .FALSE..
     
</DD>
<DT><STRONG>[tileFilePath]</STRONG></DT>
<DD>Optional argument to define the path where the tile files reside. If it
       is given, it overwrites the path defined in <TT>gridlocation</TT> variable
       in the mosaic file.
     
</DD>
<DT><STRONG>[verboseFlag]</STRONG></DT>
<DD>If .TRUE., it will print summary information about the regrid parameters,
       default to .FALSE..
     
</DD>
<DT><STRONG>[checkFlag]</STRONG></DT>
<DD>checkFlag value to pass into ESMF_FieldRegridStore(), if not provided
       has same default as ESMF_FieldRegridStore() which is false.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05013200000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_RegridWeightGen - Generate regrid routeHandle and an optional weight file from grid files with user-specified distribution</A>
</H3>

<P>
<A NAME="api:esmf_regridweightgenDG"></A>
<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_RegridWeightGen()
   subroutine ESMF_RegridWeightGenDG(srcFile, dstFile, regridRouteHandle, &amp;
     srcElementDistgrid, dstElementDistgrid, &amp;
     srcNodalDistgrid, dstNodalDistgrid, &amp;
     weightFile, regridmethod, lineType, normType, &amp;
     extrapMethod, extrapNumSrcPnts, extrapDistExponent, extrapNumLevels,&amp;
     unmappedaction, ignoreDegenerate, useUserAreaFlag, &amp;
     largefileFlag, netcdf4fileFlag, &amp;
     weightOnlyFlag, verboseFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> 
   character(len=*),             intent(in)            :: srcFile
   character(len=*),             intent(in)            :: dstFile
   type(ESMF_RouteHandle),       intent(out)           :: regridRouteHandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DistGrid),          intent(in),  optional :: srcElementDistgrid
   type(ESMF_DistGrid),          intent(in),  optional :: dstElementDistgrid
   character(len=*),             intent(in),  optional :: weightFile
   type(ESMF_DistGrid),          intent(in),  optional :: srcNodalDistgrid
   type(ESMF_DistGrid),          intent(in),  optional :: dstNodalDistgrid
   type(ESMF_RegridMethod_Flag), intent(in),  optional :: regridmethod
   type(ESMF_LineType_Flag),     intent(in),  optional :: lineType
   type(ESMF_NormType_Flag),     intent(in),  optional :: normType
   type(ESMF_ExtrapMethod_Flag),   intent(in),    optional :: extrapMethod
   integer,                        intent(in),    optional :: extrapNumSrcPnts
   real,                           intent(in),    optional :: extrapDistExponent
   integer,                      intent(in),  optional :: extrapNumLevels
   type(ESMF_UnmappedAction_Flag),intent(in), optional :: unmappedaction
   logical,                      intent(in),  optional :: ignoreDegenerate
   logical,                      intent(in),  optional :: useUserAreaFlag
   logical,                      intent(in),  optional :: largefileFlag
   logical,                      intent(in),  optional :: netcdf4fileFlag
   logical,                      intent(in),  optional :: weightOnlyFlag
   logical,                      intent(in),  optional :: verboseFlag
   integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine does online regridding weight generation from files with user specified distribution.
   The main differences between this API and the one in <A HREF="#api:esmf_regridweightgenfile">24.3.1</A> are listed below:
   
<UL>
<LI>The input grids are always represented as <TT>ESMF_Mesh</TT> whether they are logically rectangular or unstructured.
</LI>
<LI>The input grids will be decomposed using a user-specified distribution instead of a fixed decomposition in the
   other subroutine if <TT>srcElementDistgrid</TT> and <TT>dstElementDistgrid</TT> are specified.
</LI>
<LI>The source and destination grid files have to be in the SCRIP grid file format.
</LI>
<LI>This subroutine has one additional required argument <TT>regridRouteHandle</TT> and four additional optional
   arguments: <TT>srcElementDistgrid</TT>, <TT>dstElementDistgrid</TT>, <TT>srcNodelDistgrid</TT> and <TT>dstNodalDistgrid</TT>.
   These four arguments are of type <TT>ESMF_DistGrid</TT>, they are used to define the distribution of the source
   and destination grid elements and nodes. The output <TT>regridRouteHandle</TT> allows users to regrid the field
   values later in the application.
</LI>
<LI>The <TT>weightFile</TT> argument is optional. When it is given, a weightfile will be generated as well.
   
</LI>
</UL>
   
<P></P>

<P>
The arguments are:
     <DL>
<DT><STRONG>srcFile</STRONG></DT>
<DD>The source grid file name in SCRIP grid file format
     
</DD>
<DT><STRONG>dstFile</STRONG></DT>
<DD>The destination grid file name in SCRIP grid file format
     
</DD>
<DT><STRONG>regridRouteHandle</STRONG></DT>
<DD>The regrid RouteHandle returned by <TT>ESMF_FieldRegridStore()</TT>
     
</DD>
<DT><STRONG>srcElementDistgrid</STRONG></DT>
<DD>An optional distGrid that specifies the distribution of the source grid's elements. If not
       specified, a system-defined block decomposition is used.
     
</DD>
<DT><STRONG>dstElementDistgrid</STRONG></DT>
<DD>An optional distGrid that specifies the distribution of the destination grid's elements. If
       not specified, a system-defined block decomposition is used.
     
</DD>
<DT><STRONG>weightFile</STRONG></DT>
<DD>The interpolation weight file name. If present, an output weight file will be generated.
     
</DD>
<DT><STRONG>srcNodalDistgrid</STRONG></DT>
<DD>An optional distGrid that specifies the distribution of the source grid's nodes
     
</DD>
<DT><STRONG>dstNodalDistgrid</STRONG></DT>
<DD>An optional distGrid that specifies the distribution of the destination grid's nodes
     
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. Please see Section&nbsp;<A HREF="node9.html#opt:regridmethod">54.49</A>
       for a list of valid options. If not specified, defaults to
       <TT>ESMF_REGRIDMETHOD_BILINEAR</TT>.
     
</DD>
<DT><STRONG>[lineType]</STRONG></DT>
<DD>This argument controls the path of the line which connects two points on a sphere surface. This in
             turn controls the path along which distances are calculated and the shape of the edges that make
             up a cell. Both of these quantities can influence how interpolation weights are calculated.
             As would be expected, this argument is only applicable when <TT>srcField</TT> and <TT>dstField</TT> are
             built on grids which lie on the surface of a sphere. Section&nbsp;<A HREF="node9.html#opt:lineType">54.34</A> shows a
             list of valid options for this argument. If not specified, the default depends on the
             regrid method. Section&nbsp;<A HREF="node9.html#opt:lineType">54.34</A> has the defaults by line type. Figure&nbsp;<A HREF="#line_type_support">24.2.16</A> shows
             which line types are supported for each regrid method as well as showing the default line type by regrid method.
       
</DD>
<DT><STRONG>[normType]</STRONG></DT>
<DD>This argument controls the type of normalization used when generating conservative weights. This option
             only applies to weights generated with <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE</TT>. Please see
             Section&nbsp;<A HREF="node9.html#opt:normType">54.43</A> for a
             list of valid options. If not specified <TT>normType</TT> defaults to <TT>ESMF_NORMTYPE_DSTAREA</TT>.
       
</DD>
<DT><STRONG>[extrapMethod]</STRONG></DT>
<DD>The type of extrapolation. Please see Section&nbsp;<A HREF="node9.html#opt:extrapmethod">54.17</A>
             for a list of valid options. If not specified, defaults to
             <TT>ESMF_EXTRAPMETHOD_NONE</TT>.
       
</DD>
<DT><STRONG>[extrapNumSrcPnts]</STRONG></DT>
<DD>The number of source points to use for the extrapolation methods that use more than one source point
             (e.g. <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT>). If not specified, defaults to 8..
       
</DD>
<DT><STRONG>[extrapDistExponent]</STRONG></DT>
<DD>The exponent to raise the distance to when calculating weights for
             the <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT> extrapolation method. A higher value reduces the influence
             of more distant points. If not specified, defaults to 2.0.
       
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Please see Section&nbsp;<A HREF="node9.html#const:unmappedaction">54.60</A> for a
             list of valid options. If not specified, <TT>unmappedaction</TT> defaults to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>.
       
</DD>
<DT><STRONG>[ignoreDegenerate]</STRONG></DT>
<DD>Ignore degenerate cells when checking the input Grids or Meshes for errors. If this is set to true, then the
             regridding proceeds, but degenerate cells will be skipped. If set to false, a degenerate cell produces an error.
             If not specified, <TT>ignoreDegenerate</TT> defaults to false.
     
</DD>
<DT><STRONG>[useUserAreaFlag]</STRONG></DT>
<DD>If .TRUE., the element area values defined in the grid files are used.
       Only the SCRIP and ESMF format grid files have user specified areas. This flag
       is only used for conservative regridding. The default is .FALSE.
     
</DD>
<DT><STRONG>[largefileFlag]</STRONG></DT>
<DD>If .TRUE., the output weight file is in NetCDF 64bit offset format.
       The default is .FALSE.
     
</DD>
<DT><STRONG>[netcdf4fileFlag]</STRONG></DT>
<DD>If .TRUE., the output weight file is in NetCDF4 file format.
       The default is .FALSE.
     
</DD>
<DT><STRONG>[weightOnlyFlag]</STRONG></DT>
<DD>If .TRUE., the output weight file only contains factorList and factorIndexList.
       The default is .FALSE.
     
</DD>
<DT><STRONG>[verboseFlag]</STRONG></DT>
<DD>If .TRUE., it will print summary information about the regrid parameters,
       default to .FALSE.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>


<P>

<P>

<P>

<H3><A NAME="SECTION05013300000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_FileRegrid - Regrid variables defined in the grid files</A>
</H3>

<P>
<A NAME="api:esmf_fileregrid"></A>
<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FileRegrid(srcFile, dstFile, srcVarName, dstVarName, &amp;
     dstLoc, srcDataFile, dstDataFile, tileFilePath, &amp;
     dstCoordVars, regridmethod, polemethod, regridPoleNPnts, &amp;
     unmappedaction, ignoreDegenerate, srcRegionalFlag, dstRegionalFlag, &amp;
     verboseFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> 
   character(len=*),             intent(in)            :: srcFile
   character(len=*),             intent(in)            :: dstFile
   character(len=*),             intent(in)            :: srcVarName
   character(len=*),             intent(in)            :: dstVarName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character(len=*),             intent(in),  optional :: dstLoc
   character(len=*),             intent(in),  optional :: srcDataFile     
   character(len=*),             intent(in),  optional :: dstDataFile     
   character(len=*),             intent(in),  optional :: tileFilePath
   character(len=*),             intent(in),  optional :: dstCoordVars
   type(ESMF_RegridMethod_Flag), intent(in),  optional :: regridmethod
   type(ESMF_PoleMethod_Flag),   intent(in),  optional :: polemethod
   integer,                      intent(in),  optional :: regridPoleNPnts
   type(ESMF_UnmappedAction_Flag),intent(in), optional :: unmappedaction
   logical,                      intent(in),  optional :: ignoreDegenerate
   logical,                      intent(in),  optional :: srcRegionalFlag
   logical,                      intent(in),  optional :: dstRegionalFlag
   logical,                      intent(in),  optional :: verboseFlag
   integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine provides the same function as the <TT>ESMF_Regrid</TT> application
   described in Section&nbsp;<A HREF="node3.html#sec:ESMF_Regrid">13</A>.  It takes two grid files in NetCDF format and interpolate
   the variable defined in the source grid file to the destination variable using one of the ESMF supported
   regrid methods - bilinear&nbsp;(<A HREF="#sec:interpolation:bilinear">24.2.1</A>), higher-order patch&nbsp;(<A HREF="#sec:interpolation:patch">24.2.2</A>),
   first order conservative&nbsp;(<A HREF="#sec:interpolation:conserve">24.2.5</A>) or nearest neighbor methods.
   The grid files can be in one of the following two formats:
   
<UL>
<LI>The GRIDSPEC Tile grid file following the CF metadata convention&nbsp;(<A HREF="node3.html#sec:fileformat:gridspec">12.8.3</A>) for logically rectangular grids
</LI>
<LI>The proposed CF Unstructured grid (UGRID) format&nbsp;(<A HREF="node3.html#sec:fileformat:ugrid">12.8.4</A>) for  unstructured grids.
   
</LI>
</UL>
   
<P></P>
The optional arguments allow users to specify various options to control the regrid operation,
   such as which pole option to use, or whether to use user-specified area in the conservative regridding.
   The acceptable values and the default value for the optional arguments are listed below.

<P>
The arguments are:
     <DL>
<DT><STRONG>srcFile</STRONG></DT>
<DD>The source grid file name.
     
</DD>
<DT><STRONG>dstFile</STRONG></DT>
<DD>The destination grid file name.
     
</DD>
<DT><STRONG>srcVarName</STRONG></DT>
<DD>The source variable names to be regridded. If more than one, separate them by comma.
     
</DD>
<DT><STRONG>dstVarName</STRONG></DT>
<DD>The destination variable names to be regridded to. If more than one, separate them by comma.
     
</DD>
<DT><STRONG>[dstLoc]</STRONG></DT>
<DD>The destination variable's location, either 'node' or 'face'.  This
       argument is only used when the destination grid file is UGRID, the regridding method is
       non-conservative and the destination variable does not exist in the destination grid file.
       If not specified, default is 'face'.
     
</DD>
<DT><STRONG>[srcDataFile]</STRONG></DT>
<DD>The input data file prefix if the srcFile is in GRIDSPEC MOSAIC
       fileformat.  The tilename and the file extension (.nc) will be added to
       the prefix.  The tilename is defined in the MOSAIC file using variable "gridtiles".
     
</DD>
<DT><STRONG>[dstDataFile]</STRONG></DT>
<DD>The output data file prefix if the dstFile is in GRIDSPEC MOSAIC
       fileformat.  The tilename and the file extension (.nc) will be added to
       the prefix.  The tilename is defined in the MOSAIC file using variable "gridtiles".
     
</DD>
<DT><STRONG>[tileFilePath]</STRONG></DT>
<DD>The alternative file path for the tile files and mosaic data files when either srcFile or
       dstFile is a GRIDSPEC MOSAIC grid.  The path can be either relative or absolute.  If it is
       relative, it is relative to the working directory.  When specified, the gridlocation variable
       defined in the Mosaic file will be ignored.
     
</DD>
<DT><STRONG>[dstCoordVars]</STRONG></DT>
<DD>The destination coordinate variable names if the dstVarName does not exist in the dstFile
     
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. Please see Section&nbsp;<A HREF="node9.html#opt:regridmethod">54.49</A>
       for a list of valid options. If not specified, defaults to
       <TT>ESMF_REGRIDMETHOD_BILINEAR</TT>.
     
</DD>
<DT><STRONG>[polemethod]</STRONG></DT>
<DD>A flag to indicate which type of artificial pole
       to construct on the source Grid for regridding. Please see
       Section&nbsp;<A HREF="node9.html#const:polemethod">54.46</A> for a list of valid options.
       The default value varies depending on the regridding method and the grid type and format.
     
</DD>
<DT><STRONG>[regridPoleNPnts]</STRONG></DT>
<DD>If <TT>polemethod</TT> is set to <TT>ESMF_POLEMETHOD_NPNTAVG</TT>, this argument is required to
       specify how many points should be averaged over at the pole.
     
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Please see Section&nbsp;<A HREF="node9.html#const:unmappedaction">54.60</A> for a
             list of valid options. If not specified, <TT>unmappedaction</TT> defaults to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>.
     
</DD>
<DT><STRONG>[ignoreDegenerate]</STRONG></DT>
<DD>Ignore degenerate cells when checking the input Grids or Meshes for errors. If this is set to true, then the
             regridding proceeds, but degenerate cells will be skipped. If set to false, a degenerate cell produces an error.
             If not specified, <TT>ignoreDegenerate</TT> defaults to false.
     
</DD>
<DT><STRONG>[srcRegionalFlag]</STRONG></DT>
<DD>If .TRUE., the source grid is a regional grid, otherwise,
       it is a global grid.  The default value is .FALSE.
     
</DD>
<DT><STRONG>[dstRegionalFlag]</STRONG></DT>
<DD>If .TRUE., the destination grid is a regional grid, otherwise,
       it is a global grid.  The default value is .FALSE.
     
</DD>
<DT><STRONG>[verboseFlag]</STRONG></DT>
<DD>If .TRUE., it will print summary information about the regrid parameters,
       default to .FALSE.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>


<P>

<H2><A NAME="SECTION05014000000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<OL>
<LI><B>32-bit index limitation:</B> Currently all index space dimensions in an ESMF object are represented by signed 32-bit integers. This limits the number of elements in one-dimensional objects to the 32-bit limit. This limit can be crossed by higher dimensional objects, where the product space is only limited by the 64-bit sequence index representation.
</LI>
</OL>

<H1><A NAME="SECTION05020000000000000000">
<SPAN CLASS="arabic">25</SPAN> FieldBundle Class</A>
</H1>

<H2><A NAME="SECTION05021000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
A FieldBundle functions mainly as a convenient container for storing
similar Fields.  It represents &ldquo;bundles&rdquo; of Fields that are 
discretized on the same Grid, Mesh, LocStream, or XGrid and distributed in the same manner.
The FieldBundle is an important data structure because it can be added to a State, 
which is used for sending and receiving data between Components.

<P>
In the common case where FieldBundle is built on top of a Grid,
Fields within a FieldBundle may be located at different locations relative 
to the vertices of their common Grid.  The Fields in a FieldBundle may
be of different dimensions, as long as the Grid dimensions that 
are distributed are the same.  For example, a surface Field on 
a distributed lat/lon Grid and a 3D Field with an added vertical 
dimension on the same distributed lat/lon Grid can be included
in the same FieldBundle.

<P>
FieldBundles can be created and destroyed, can have Attributes 
added or retrieved, and can have Fields added, removed, replaced, or retrieved.
Methods include queries that return information about the FieldBundle
itself and about the Fields that it contains.  The Fortran 
data pointer of a Field within a FieldBundle can be obtained 
by first retrieving the Field with a call to <TT>ESMF_FieldBundleGet()</TT>,
and then using <TT>ESMF_FieldGet()</TT> to get the data.

<P>
In the future FieldBundles will serve as a mechanism for performance
optimization.  ESMF will take advantage of the similarities of the
Fields within a FieldBundle to optimize collective communication,
I/O, and regridding.  See Section <A HREF="#sec:bundlerest">25.3</A> for a
description of features that are scheduled for future work.

<H2><A NAME="SECTION05022000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
Examples of creating, accessing and destroying FieldBundles and their
constituent Fields are provided in this section, along with some
notes on FieldBundle methods.

<P>

<P>

<P>

<H3><A NAME="SECTION05022100000000000000"></A>
   <A NAME="sec:fieldbundle:usage:create_list"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating a FieldBundle from a list of Fields
</H3>
   A user can create a FieldBundle from a predefined list of Fields. In the following
   example, we first create an <TT>ESMF_Grid</TT>, then build 3 different <TT>ESMF_Field</TT>s with 
   different names. The <TT>ESMF_FieldBundle</TT> is created from the list of 3 Fields.
  
<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create several Fields and add them to a new FieldBundle.
 
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
                                  regDecomp=(/2,2/), name="atmgrid", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R8, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    field(1) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="temperature", rc=rc)
</PRE>

<P>
<PRE>
    field(2) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="pressure", rc=rc)
</PRE>

<P>
<PRE>
    field(3) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="heat flux", rc=rc)
</PRE>

<P>
<PRE>
    bundle1 = ESMF_FieldBundleCreate(fieldList=field(1:3), &amp;
                                name="atmosphere data", rc=rc)

    print *, "FieldBundle example 1 returned"
</PRE>

<P>

<H3><A NAME="SECTION05022200000000000000"></A>
   <A NAME="sec:fieldbundle:usage:create_empty"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Creating an empty FieldBundle then add one Field to it
</H3>
   A user can create an empty FieldBundle then add Fields to the empty FieldBundle.
   In the following example, we use the previously defined <TT>ESMF_Grid</TT>
   to build an <TT>ESMF_Field</TT>.
   An empty <TT>ESMF_FieldBundle</TT> is created, then the Field is added
   to the FieldBundle.
<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create an empty FieldBundle and then add a single field to it.


    simplefield = ESMF_FieldCreate(grid, arrayspec, &amp;
                  staggerloc=ESMF_STAGGERLOC_CENTER, name="rh", rc=rc)
</PRE>

<P>
<PRE>
    bundle2 = ESMF_FieldBundleCreate(name="time step 1", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleAdd(bundle2, (/simplefield/), rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle2, fieldCount=fieldcount, rc=rc)

    print *, "FieldBundle example 2 returned, fieldcount =", fieldcount
</PRE>

<P>

<H3><A NAME="SECTION05022300000000000000"></A>
   <A NAME="sec:fieldbundle:usage:create_emptylist"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Creating an empty FieldBundle then add a list of Fields to it
</H3>
   A user can create an empty FieldBundle then add multiple 
   Fields to the empty FieldBundle.
   In the following example, we use the previously defined <TT>ESMF_Grid</TT>
   and <TT>ESMF_Field</TT>s.
   An empty <TT>ESMF_FieldBundle</TT> is created, then three Fields are added
   to the FieldBundle.
<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create an empty FieldBundle and then add multiple fields to it.

    bundle3 = ESMF_FieldBundleCreate(name="southern hemisphere", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleAdd(bundle3, field(1:3), rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle3, fieldCount=fieldcount, rc=rc)

    print *, "FieldBundle example 3 returned, fieldcount =", fieldcount
</PRE>

<P>

<H3><A NAME="SECTION05022400000000000000"></A>
   <A NAME="sec:fieldbundle:usage:get"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Query a Field stored in the FieldBundle by name or index
</H3>
   Users can query a Field stored in a FieldBundle by the Field's name or index.
   In the following example, the pressure Field stored in FieldBundle
   is queried by its name then by its index through <TT>ESMF_FieldBundleGet()</TT>
   method.
<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Get a Field back from a FieldBundle, first by name and then by index.
!   !  Also get the FieldBundle name.

    call ESMF_FieldBundleGet(bundle1, "pressure", field=returnedfield1, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldGet(returnedfield1, name=fname1, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle1, 2, returnedfield2, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldGet(returnedfield2, name=fname2, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle1, name=bname1, rc=rc)

    print *, "FieldBundle example 4 returned, field names = ", &amp;
                   trim(fname1), ", ", trim(fname2)
    print *, "FieldBundle name = ", trim(bname1)
</PRE>

<P>

<H3><A NAME="SECTION05022500000000000000"></A>
   <A NAME="sec:fieldbundle:usage:getlist"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Query FieldBundle for Fields list either alphabetical or in order of addition
</H3>
   Users can query the list of Fields stored in a FieldBundle.
   By default the returned list of Fields are ordered alphabetically by
   the Field names. Users can also retrieve the list of Fields in the order by which
   the Fields were added to the FieldBundle.
<P>
<PRE>
    call ESMF_FieldBundleGet(bundle1, fieldList=r_fields, rc=rc)
</PRE>

<P>
<PRE>
    do i = 1, 3
      call ESMF_FieldGet(r_fields(i), name=fname1, rc=rc)
</PRE>

<P>
<PRE>
      print *, fname1
    enddo
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle1, fieldList=r_fields, &amp;
      itemorderflag=ESMF_ITEMORDER_ADDORDER, rc=rc)
</PRE>

<P>
<PRE>
    do i = 1, 3
      call ESMF_FieldGet(r_fields(i), name=fname1, rc=rc)
</PRE>

<P>
<PRE>
      print *, fname1
    enddo
</PRE>

<P>

<H3><A NAME="SECTION05022600000000000000"></A>
   <A NAME="sec:fieldbundle:usage:packedFBGrid"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create a packed FieldBundle on a Grid
</H3>
   Create a packed fieldbundle from user supplied 
   field names and a packed Fortran array pointer that contains
   the data of the packed fields on a Grid.  

<P>
Create a 2D grid of 4x1 regular decomposition on 4 PETs, each PET has 10x50 elements.
   The index space of the entire Grid is 40x50.
<P>
<PRE>
  gridxy = ESMF_GridCreateNoPeriDim(maxIndex=(/40,50/), regDecomp=(/4,1/), rc=rc)
</PRE>

<P>
Allocate a packed Fortran array pointer containing 10 packed fields, each field has
   3 time slices and uses the 2D grid created. Note that gridToFieldMap uses the position
   of the grid dimension as elements, 3rd element of the packedPtr is 10, 4th element
   of the packedPtr is 50.
<P>
<PRE>
  allocate(packedPtr(10, 3, 10, 50)) ! fieldDim, time, y, x
  fieldDim = 1
  packedFB = ESMF_FieldBundleCreate(fieldNameList, packedPtr, gridxy, fieldDim, &amp;
  gridToFieldMap=(/3,4/), staggerloc=ESMF_Staggerloc_Center, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05022700000000000000"></A>
   <A NAME="sec:fieldbundle:usage:packedFBMesh"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Create a packed FieldBundle on a Mesh
</H3>
   Similarly we could create a packed fieldbundle from user supplied 
   field names and a packed Fortran array pointer that contains
   the data of the packed fields on a Mesh. 

<P>
Due to the verbosity of the MeshCreate process, the code for MeshCreate is
   not shown below, user can either refer to the MeshCreate section
   <A HREF="#sec:mesh:usage:meshCreation">33.3.1</A>
   or examine the FieldBundleCreate example source code contained
   in the ESMF source distribution directly.
   A ESMF Mesh on 4 PETs with one mesh element on each PET is created. 

<P>
Allocate the packed Fortran array pointer, the first dimension
   is fieldDim; second dimension is the data associated with mesh element,
   since there is only one mesh element on each processor in this example,
   the allocation is 1; last dimension is the time dimension which contains
   3 time slices.
<P>
<PRE>
      allocate(packedPtr3D(10, 1, 3))
      fieldDim = 1
      packedFB = ESMF_FieldBundleCreate(fieldNameList, packedPtr3D, meshEx, fieldDim, &amp;
        gridToFieldMap=(/2/), meshloc=ESMF_MESHLOC_ELEMENT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05022800000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Destroy a FieldBundle</A>
</H3>

<P>
The user must call <TT>ESMF_FieldBundleDestroy()</TT> before 
  deleting any of the Fields it contains.  Because Fields
  can be shared by multiple FieldBundles and States, they are
  not deleted by this call.
<P>
<PRE>
!-------------------------------------------------------------------------

     call ESMF_FieldBundleDestroy(bundle1, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION05022900000000000000"></A>
   <A NAME="sec:fieldbundle:usage:redist_1dptr"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">9</SPAN> Redistribute data from a source FieldBundle to a destination FieldBundle
</H3>

<P>
The <TT>ESMF_FieldBundleRedist</TT> interface can be used to redistribute data from
   source FieldBundle to destination FieldBundle. This interface is overloaded by type and kind;
   In the version of <TT>ESMF_FieldBundleRedist</TT> without factor argument, a default value
   of factor 1 is used.

<P>
In this example, we first create two FieldBundles, a source FieldBundle and a destination
   FieldBundle. Then we use <TT>ESMF_FieldBundleRedist</TT> to
   redistribute data from source FieldBundle to destination FieldBundle.
<P>
<PRE>
    ! perform redist
    call ESMF_FieldBundleRedistStore(srcFieldBundle, dstFieldBundle, &amp;
         routehandle, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleRedist(srcFieldBundle, dstFieldBundle, &amp;
         routehandle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050221000000000000000"></A>
   <A NAME="sec:fieldbundle:usage:redist_packed"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">10</SPAN> Redistribute data from a packed source FieldBundle to a packed destination FieldBundle
</H3>

<P>
The <TT>ESMF_FieldBundleRedist</TT> interface can be used to redistribute data from
   source FieldBundle to destination FieldBundle when both Bundles are packed with same
   number of fields.  

<P>
In this example, we first create two packed FieldBundles, a source FieldBundle and a destination
   FieldBundle. Then we use <TT>ESMF_FieldBundleRedist</TT> to
   redistribute data from source FieldBundle to destination FieldBundle.

<P>
The same Grid is used where the source and destination packed FieldBundle are built upon. Source
   and destination Bundle have different memory layout.
<P>
<PRE>
    allocate(srcfptr(3,5,10), dstfptr(10,5,3))
    srcfptr = lpe
    srcFieldBundle = ESMF_FieldBundleCreate((/'field01', 'field02', 'field03'/), &amp;
      srcfptr, grid, 1, gridToFieldMap=(/2,3/), rc=rc)
</PRE>

<P>
<PRE>
    dstFieldBundle = ESMF_FieldBundleCreate((/'field01', 'field02', 'field03'/), &amp;
      dstfptr, grid, 3, gridToFieldMap=(/2,1/), rc=rc)
</PRE>

<P>
<PRE>
    ! perform redist
    call ESMF_FieldBundleRedistStore(srcFieldBundle, dstFieldBundle, &amp;
         routehandle, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleRedist(srcFieldBundle, dstFieldBundle, &amp;
         routehandle, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050221100000000000000"></A>
   <A NAME="sec:fieldbundle:usage:smm_1dptr"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">11</SPAN> Perform sparse matrix multiplication from a source FieldBundle 
    to a destination FieldBundle
</H3>

<P>
The <TT>ESMF_FieldBundleSMM</TT> interface can be used to perform SMM from
   source FieldBundle to destination FieldBundle. This interface is overloaded by type and kind;

<P>
In this example, we first create two FieldBundles, a source FieldBundle and a destination
   FieldBundle. Then we use <TT>ESMF_FieldBundleSMM</TT> to
   perform sparse matrix multiplication from source FieldBundle to destination FieldBundle.

<P>
The operation performed in this example is better illustrated in 
   section <A HREF="#sec:field:usage:smm_1dptr">26.3.33</A>.

<P>
Section <A HREF="#Array:SparseMatMul">28.2.18</A> provides a detailed discussion of the 
   sparse matrix multiplication operation implemented in ESMF.
<P>
<PRE>
    call ESMF_VMGetCurrent(vm, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
</PRE>

<P>
<PRE>
    ! create distgrid and grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
</PRE>

<P>
<PRE>
    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        gridEdgeLWidth=(/0/), gridEdgeUWidth=(/0/), &amp;
        name="grid", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
</PRE>

<P>
<PRE>
    ! create field bundles and fields
    srcFieldBundle = ESMF_FieldBundleCreate(rc=rc)
</PRE>

<P>
<PRE>
    dstFieldBundle = ESMF_FieldBundleCreate(rc=rc)
</PRE>

<P>
<PRE>
    do i = 1, 3
        srcField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            totalLWidth=(/1/), totalUWidth=(/2/), &amp;
            rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_FieldGet(srcField(i), localDe=0, farrayPtr=srcfptr, rc=rc)
</PRE>

<P>
<PRE>
        srcfptr = 1

        call ESMF_FieldBundleAdd(srcFieldBundle, (/srcField(i)/), rc=rc)
</PRE>

<P>
<PRE>
        dstField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            totalLWidth=(/1/), totalUWidth=(/2/), &amp;
            rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_FieldGet(dstField(i), localDe=0, farrayPtr=dstfptr, rc=rc)
</PRE>

<P>
<PRE>
        dstfptr = 0

        call ESMF_FieldBundleAdd(dstFieldBundle, (/dstField(i)/), rc=rc)
</PRE>

<P>
<PRE>
    enddo

    ! initialize factorList and factorIndexList
    allocate(factorList(4))
    allocate(factorIndexList(2,4))
    factorList = (/1,2,3,4/)
    factorIndexList(1,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    factorIndexList(2,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    call ESMF_FieldBundleSMMStore(srcFieldBundle, dstFieldBundle, &amp;
        routehandle, factorList, factorIndexList, rc=rc)
</PRE>

<P>
<PRE>
    ! perform smm
    call ESMF_FieldBundleSMM(srcFieldBundle, dstFieldBundle, routehandle, &amp;
          rc=rc)
</PRE>

<P>
<PRE>
    ! release SMM route handle
    call ESMF_FieldBundleSMMRelease(routehandle, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050221200000000000000"></A>
   <A NAME="sec:fieldbundle:usage:halo"></A>
<BR>
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">12</SPAN> Perform FieldBundle halo update
</H3>

<P>

   <TT>ESMF_FieldBundleHalo</TT> interface can be used to perform halo updates
   for all the Fields contained in the <TT>ESMF_FieldBundle</TT>.

<P>
In this example, we will set up a FieldBundle for a 2D inviscid and compressible
   flow problem. We will illustrate the FieldBundle halo update operation but we will
   not solve the non-linear PDEs. The emphasis here is to demonstrate
   how to set up halo regions, how a numerical scheme updates
   the exclusive regions, and how a halo update communicates data in the halo regions. Here
   are the governing equations:

<P>
<!-- MATH
 $u_t + u u_x + v u_y + \frac{1}{\rho} p_x = 0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="184" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$u_t + u u_x + v u_y + \frac{1}{\rho} p_x = 0$"></SPAN> (conservation of momentum in x-direction)

<P>
<!-- MATH
 $v_t + u v_x + v v_y + \frac{1}{\rho} p_y = 0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="179" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$v_t + u v_x + v v_y + \frac{1}{\rho} p_y = 0$"></SPAN> (conservation of momentum in y-direction)

<P>
<!-- MATH
 ${\rho}_t + {\rho u}_x + {\rho v}_y = 0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="135" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="${\rho}_t + {\rho u}_x + {\rho v}_y = 0$"></SPAN> (conservation of mass)

<P>
<!-- MATH
 $\frac{\rho}{\rho^\gamma} + u {(\frac{p}{\rho^\gamma})}_x + v {(\frac{p}{\rho^\gamma})}_y = 0$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="183" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$\frac{\rho}{\rho^\gamma} + u {(\frac{p}{\rho^\gamma})}_x + v {(\frac{p}{\rho^\gamma})}_y = 0$"></SPAN> (conservation of energy)

<P>
The four unknowns are pressure <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="$p$"></SPAN>, density <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$\rho$"></SPAN>, velocity (<SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img39.png"
 ALT="$u$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$v$"></SPAN>). The grids
   are set up using Arakawa D stagger (<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="$p$"></SPAN> on corner, <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$\rho$"></SPAN> at center, <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img39.png"
 ALT="$u$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$v$"></SPAN> on edges).
   <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="$p$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$\rho$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img39.png"
 ALT="$u$"></SPAN>, and <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$v$"></SPAN> are bounded by necessary boundary conditions and initial conditions.

<P>
Section <A HREF="#Array:Halo">28.2.15</A> provides a detailed discussion of the 
   halo operation implemented in ESMF.
<P>
<PRE>
    ! create distgrid and grid according to the following decomposition 
    ! and stagger pattern, r is density.
    !
    ! p--------u-------+p+-------u--------p
    ! !                 |                 |
    ! !                 |                 |
    ! !                 |                 |
    ! v        r        v        r        v
    ! !      PET 0      |      PET 1      |
    ! !                 |                 |
    ! !                 |                 |
    ! p--------u-------+p+-------u--------p
    ! !                 |                 |
    ! !                 |                 |
    ! !                 |                 |
    ! v        r        v        r        v
    ! !      PET 2      |      PET 3      |
    ! !                 |                 |
    ! !                 |                 |
    ! p--------u-------+p+-------u--------p
    !
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/256,256/), &amp;
        regDecomp=(/2,2/), &amp;
        rc=rc)
</PRE>

<P>
<PRE>
    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc=rc)
</PRE>

<P>
<PRE>
    ! create field bundles and fields
    fieldBundle = ESMF_FieldBundleCreate(rc=rc)
</PRE>

<P>
<PRE>
    ! set up exclusive/total region for the fields
    !
    ! halo: L/U, nDim, nField, nPet
    ! halo configuration for pressure, and similarly for density, u, and v
    halo(1,1,1,1) = 0
    halo(2,1,1,1) = 0
    halo(1,2,1,1) = 0
    halo(2,2,1,1) = 0
    halo(1,1,1,2) = 1   ! halo in x direction on left hand side of pet 1
    halo(2,1,1,2) = 0
    halo(1,2,1,2) = 0
    halo(2,2,1,2) = 0
    halo(1,1,1,3) = 0
    halo(2,1,1,3) = 1   ! halo in y direction on upper side of pet 2
    halo(1,2,1,3) = 0
    halo(2,2,1,3) = 0
    halo(1,1,1,4) = 1   ! halo in x direction on left hand side of pet 3
    halo(2,1,1,4) = 1   ! halo in y direction on upper side of pet 3
    halo(1,2,1,4) = 0
    halo(2,2,1,4) = 0
</PRE>

<P>
<PRE>
    ! names and staggers of the 4 unknown fields
    names(1) = "pressure"
    names(2) = "density"
    names(3) = "u"
    names(4) = "v"
    staggers(1) = ESMF_STAGGERLOC_CORNER
    staggers(2) = ESMF_STAGGERLOC_CENTER
    staggers(3) = ESMF_STAGGERLOC_EDGE2
    staggers(4) = ESMF_STAGGERLOC_EDGE1
    
    ! create a FieldBundle
    lpe = lpe + 1
    do i = 1, 4
        field(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
                totalLWidth=(/halo(1,1,i,lpe), halo(1,2,i,lpe)/), &amp;
                totalUWidth=(/halo(2,1,i,lpe), halo(2,2,i,lpe)/), &amp;
                staggerloc=staggers(i), name=names(i), &amp;
                rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_FieldBundleAdd(fieldBundle, (/field(i)/), rc=rc)
</PRE>

<P>
<PRE>
    enddo

    ! compute the routehandle
    call ESMF_FieldBundleHaloStore(fieldBundle, routehandle=routehandle, &amp;
                                   rc=rc)
</PRE>

<P>
<PRE>
    do iter = 1, 10
        do i = 1, 4
            call ESMF_FieldGet(field(i), farrayPtr=fptr, &amp;
                exclusiveLBound=excllb, exclusiveUBound=exclub, rc=rc)
</PRE>

<P>
<PRE>
            sizes = exclub - excllb
            ! fill the total region with 0.
            fptr = 0.
            ! only update the exclusive region on local PET
            do j = excllb(1), exclub(1)
              do k = excllb(2), exclub(2)
                fptr(j,k) = iter * cos(2.*PI*j/sizes(1))*sin(2.*PI*k/sizes(2))
              enddo 
            enddo 
        enddo
        ! call halo execution to update the data in the halo region,
        ! it can be verified that the halo regions change from 0. 
        ! to non zero values.
        call ESMF_FieldBundleHalo(fieldbundle, routehandle=routehandle, rc=rc)
</PRE>

<P>
<PRE>
    enddo
    ! release halo route handle
    call ESMF_FieldBundleHaloRelease(routehandle, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION05023000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>
<A NAME="sec:bundlerest"></A>
<P>

<OL>
<LI><B>No enforcement of the <EM>same</EM> Grid, Mesh, LocStream, or XGrid 
restriction.</B>
While the documentation indicates in several places (including the Design and
Implementation Notes) that a FieldBundle can only contain Fields that are built
on the same Grid, Mesh, LocStream, or XGrid, and all Fields must have the same
distribution, the actual FieldBundle implementation is more general and
supports bundling of any Fields. The documentation, however, is
in line with the long term plan of making the restrictive FieldBundle definition
the default behavior. The more general bundling option would then be retained
as a special case that requires explicit specification by the user.
There is currently no functional difference in the FieldBundle implementation
that profits from the documented restrictive approach. In addition, the general
bundling option has been supported for a long time. Note however that the
documented restrictive behavior is the anticipated long term default for
FieldBundles.

<P>
</LI>
<LI><B>No mathematical operators.</B>
The FieldBundle class does not support differential or other
mathematical operators.  We do not anticipate providing this 
functionality in the near future.

<P>
</LI>
<LI><B>Limited validation and print options.</B>
We are planning to increase the number of validity checks available
for FieldBundles as soon as possible.  We also will
be working on print options.

<P>
</LI>
<LI><B>Packed data has limited supported.</B>
One of the options that we are currently working on for FieldBundles is
packing.  Packing means that the data from all the
Fields that comprise the FieldBundle are manipulated collectively.
This operation can be done without 
destroying the original Field data.  Packing is being designed to 
facilitate optimized regridding, data communication, and I/O operations.
This will reduce the latency overhead of the communication.  

<P>
<B>CAUTION:</B> For communication methods, the undistributed dimension representing
the number of fields must have identical size between source and destination packed
data. Communication methods do not permute the order of fields in the source
and destination packed FieldBundle.

<P>
</LI>
<LI><B>Interleaving Fields within a FieldBundle.</B>
Data locality is important for performance on some computing
platforms.  An interleave option will be added to allow the user to create
a packed FieldBundle in which Fields are either concatenated in memory
or in which Field elements are interleaved.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION05024000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI><B>Fields in a FieldBundle reference the same Grid, Mesh, LocStream, or XGrid.</B>
In order to reduce memory requirements and ensure consistency, the 
Fields within a FieldBundle all reference the same Grid, Mesh, 
LocStream, or XGrid object. This restriction may be relaxed in the future.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION05025000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API: Basic FieldBundle Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05025100000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_FieldBundleAssignment(=) - FieldBundle assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface assignment(=)
   fieldbundle1 = fieldbundle2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_FieldBundle) :: fieldbundle1
   type(ESMF_FieldBundle) :: fieldbundle2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign fieldbundle1 as an alias to the same ESMF fieldbundle object in memory
   as fieldbundle2. If fieldbundle2 is invalid, then fieldbundle1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle1</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>fieldbundle2</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025200000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_FieldBundleOperator(==) - FieldBundle equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
   if (fieldbundle1 == fieldbundle2) then ... endif
   OR
   result = (fieldbundle1 == fieldbundle2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_FieldBundle), intent(in) :: fieldbundle1
   type(ESMF_FieldBundle), intent(in) :: fieldbundle2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether fieldbundle1 and fieldbundle2 are valid aliases to the same ESMF
   fieldbundle object in memory. For a more general comparison of two ESMF FieldBundles,
   going beyond the simple alias test, the ESMF_FieldBundleMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle1</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>fieldbundle2</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025300000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_FieldBundleOperator(/=) - FieldBundle not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
   if (fieldbundle1 /= fieldbundle2) then ... endif
   OR
   result = (fieldbundle1 /= fieldbundle2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_FieldBundle), intent(in) :: fieldbundle1
   type(ESMF_FieldBundle), intent(in) :: fieldbundle2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether fieldbundle1 and fieldbundle2 are <I>not</I> valid aliases to the
   same ESMF fieldbundle object in memory. For a more general comparison of two ESMF
   FieldBundles, going beyond the simple alias test, the ESMF_FieldBundleMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle1</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>fieldbundle2</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025400000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_FieldBundleAdd - Add Fields to a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_FieldBundleAdd()
     subroutine ESMF_FieldBundleAddList(fieldbundle, fieldList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     type(ESMF_Field), intent(in) :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: multiflag
     logical, intent(in), optional :: relaxedflag
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add Field(s) to a FieldBundle. It is an error if <TT>fieldList</TT> contains
   Fields that match by name Fields already contained in
   <TT>fieldbundle</TT> when multiflag
   is set to <TT>.false.</TT> and relaxedflag is set to <TT>.false.</TT>.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be added to.
   
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>List of <TT>ESMF_Field</TT> objects to be added.
   
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
   to be added to <TT>ESMF_FieldBundle</TT>. For <TT>.false.</TT> added items must
   have unique names. The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add"
   under <TT>multiflag=.false.</TT> mode, where it is <EM>not</EM> an error if
   <TT>fieldList</TT> contains items with names that are also found in
   <TT>ESMF_FieldBundle</TT>. The <TT>ESMF_FieldBundle</TT> is left unchanged for these items.
   For <TT>.false.</TT> this is treated as an error condition.
   The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025500000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_FieldBundleAddReplace - Conditionally add or replace Fields in a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleAddReplace(fieldbundle, fieldList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     type(ESMF_Field), intent(in) :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Fields in <TT>fieldList</TT> that do not match any Fields by name in
   <TT>fieldbundle</TT> are added to the FieldBundle. Fields in <TT>fieldList</TT>
   that match any Fields by name in <TT>fieldbundle</TT> replace those Fields.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be manipulated.
   
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>List of <TT>ESMF_Field</TT> objects to be added or used as replacement.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025600000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_FieldBundleCreate - Create a non packed FieldBundle from a list of Fields</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleCreate()
   function ESMF_FieldBundleCreateDefault(fieldList, &amp;
       multiflag, relaxedflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateDefault
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Field), intent(in), optional :: fieldList(:)
     logical, intent(in), optional :: multiflag
     logical, intent(in), optional :: relaxedflag
     character (len=*),intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_FieldBundle</TT> object from a list of existing Fields.

<P>
The creation of a FieldBundle leaves the bundled Fields unchanged, they
   remain valid individual objects. a FieldBundle is a light weight container
   of Field references. The actual data remains in place, there are no
   data movements or duplications associated with the creation of an
   FieldBundle.

<P>
<DL>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>List of <TT>ESMF_Field</TT> objects to be bundled.
   
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
   to be added to <TT>fieldbundle</TT>. For <TT>.false.</TT> added items must
   have unique names. The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add"
   under <TT>multiflag=.false.</TT> mode, where it is <EM>not</EM> an error if
   <TT>fieldList</TT> contains items with names that are also found in
   <TT>fieldbundle</TT>. The <TT>fieldbundle</TT> is left unchanged for these items.
   For <TT>.false.</TT> this is treated as an error condition.
   The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the created <TT>ESMF_FieldBundle</TT>. A default name is generated
   if not specified.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025700000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_FieldBundleCreate - Create a packed FieldBundle from Fortran array pointer and Grid </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleCreate() 
   function ESMF_FieldBundleCreateGrid&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(fieldNameList, &amp; 
   farrayPtr, grid, fieldDim, &amp; 
   indexflag, staggerLoc, &amp; 
   gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateGridDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   character(len=*), intent(in) :: fieldNameList(:) 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_Grid), intent(in) :: grid 
   integer, intent(in) :: fieldDim 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Index_Flag), intent(in), optional :: indexflag 
   type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a packed FieldBundle from user supplied list of field names, pre-allocated 
   Fortran array pointer, and <TT>ESMF_Grid</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>fieldNameList</STRONG></DT>
<DD>A list of field names for the Fields held by the packed <TT>FieldBundle</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Pre-allocated Fortran array pointer holding the memory of the list of Fields. 
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on which the Fields in the packed FieldBundle are built. 
   
</DD>
<DT><STRONG>fieldDim</STRONG></DT>
<DD>The dimension in the <TT>farrayPtr</TT> that contains the indices of Fields to be packed. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   All Fields in packed FieldBundle use identical indexflag setting. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>. 
   To create a custom stagger location see section 
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   All Fields in packed FieldBundle use identical staggerloc setting. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. 
   The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   All Fields in packed FieldBundle use identical gridToFieldMap setting. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   All Fields in packed FieldBundle use identical totalLWidth setting. 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   All Fields in packed FieldBundle use identical totalUWidth setting. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>FieldBundle name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05025800000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_FieldBundleCreate - Create a packed FieldBundle from Fortran array pointer and Mesh </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleCreate() 
   function ESMF_FieldBundleCreateMesh&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(fieldNameList, &amp; 
   farrayPtr, Mesh, fieldDim, &amp; 
   meshLoc, gridToFieldMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_FieldBundle) :: ESMF_FieldBundleCreateMeshDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   character(len=*), intent(in) :: fieldNameList(:) 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_Mesh), intent(in) :: mesh 
   integer, intent(in) :: fieldDim 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_MeshLoc), intent(in), optional:: meshloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a packed FieldBundle from user supplied list of field names, pre-allocated 
   Fortran array pointer, and <TT>ESMF_Mesh</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>fieldNameList</STRONG></DT>
<DD>A list of field names for the Fields held by the packed <TT>FieldBundle</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Pre-allocated Fortran array pointer holding the memory of the list of Fields. 
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on which the Fields in the packed FieldBundle are built. 
   
</DD>
<DT><STRONG>fieldDim</STRONG></DT>
<DD>The dimension in the <TT>farrayPtr</TT> that contains the indices of Fields to be packed. 
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>The part of the Mesh on which to build the Field. For valid 
   predefined values see Section&nbsp;<A HREF="node9.html#const:meshloc">54.39</A>. 
   If not set, defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. 
   The default is to 
   map all of the <TT>mesh</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>mesh</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   All Fields in packed FieldBundle use identical gridToFieldMap setting. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>FieldBundle name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05025900000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_FieldBundleDestroy - Release resources associated with a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleDestroy(fieldbundle, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: noGarbage
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_FieldBundle</TT> object. The member Fields are not
   touched by this operation and remain valid objects that need to be
   destroyed individually if necessary.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases - a situation which may lead to hard to debug
   application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
   set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
   removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_FieldBundleGet - Get object-wide information from a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_FieldBundleGet()
     subroutine ESMF_FieldBundleGetListAll(fieldbundle, &amp;
       itemorderflag, geomtype, grid, locstream, mesh, xgrid, &amp;
       fieldCount, fieldList, fieldNameList, isPacked, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ItemOrder_Flag), intent(in), optional :: itemorderflag
     type(ESMF_GeomType_Flag), intent(out), optional :: geomtype
     type(ESMF_Grid), intent(out), optional :: grid
     type(ESMF_LocStream), intent(out), optional :: locstream
     type(ESMF_Mesh), intent(out), optional :: mesh
     type(ESMF_XGrid), intent(out), optional :: xgrid
     integer, intent(out), optional :: fieldCount
     type(ESMF_Field), intent(out), optional :: fieldList(:)
     character(len=*), intent(out), optional :: fieldNameList(:)
     logical, intent(out), optional :: isPacked
     character(len=*), intent(out), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>itemorderflag</TT>.
   The new argument gives the user control over the order in which
   the items are returned.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>isPacked</TT>.
   The new argument allows the user to query if this is a packed FieldBundle.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the list of all Fields and field names bundled in a FieldBundle.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be queried.
   
</DD>
<DT><STRONG>[itemorderflag]</STRONG></DT>
<DD>Specifies the order of the returned items in the <TT>fieldList</TT> or the
   <TT>fieldNameList</TT>.
   The default is <TT>ESMF_ITEMORDER_ABC</TT>.
   See <A HREF="node9.html#const:itemorderflag">54.32</A> for a full list of options.
   
</DD>
<DT><STRONG>[geomtype]</STRONG></DT>
<DD>Flag that indicates what type of geometry this FieldBundle object holds.
   Can be <TT>ESMF_GEOMTYPE_GRID</TT>, <TT>ESMF_GEOMTYPE_MESH</TT>, <TT>ESMF_GEOMTYPE_LOCSTREAM</TT>,
   <TT>ESMF_GEOMTYPE_XGRID</TT>
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>The Grid object that this FieldBundle object holds.
   
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>The LocStream object that this FieldBundle object holds.
   
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>The Mesh object that this FieldBundle object holds.
   
</DD>
<DT><STRONG>[xgrid]</STRONG></DT>
<DD>The XGrid object that this FieldBundle object holds.
   
</DD>
<DT><STRONG>[fieldCount]</STRONG></DT>
<DD>Upon return holds the number of Fields bundled in the fieldbundle.
   
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>Upon return holds a list of Fields bundled in <TT>ESMF_FieldBundle</TT>. The
   argument must be allocated to be at least of size <TT>fieldCount</TT>.
   
</DD>
<DT><STRONG>[fieldNameList]</STRONG></DT>
<DD>Upon return holds a list of the names of the fields bundled in
   <TT>ESMF_FieldBundle</TT>. The argument must be allocated to be at least of
   size <TT>fieldCount</TT>.
   
</DD>
<DT><STRONG>[isPacked]</STRONG></DT>
<DD>Upon return holds the information if this FieldBundle is packed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the fieldbundle object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251100000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_FieldBundleGet - Get information about a Field by name and optionally return a Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_FieldBundleGet()
     subroutine ESMF_FieldBundleGetItem(fieldbundle, fieldName, &amp;
       field, fieldCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle
     character(len=*), intent(in) :: fieldName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Field), intent(out), optional :: field
     integer, intent(out), optional :: fieldCount
     logical, intent(out), optional :: isPresent
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get information about items that match <TT>fieldName</TT> in FieldBundle.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be queried.
   
</DD>
<DT><STRONG>fieldName</STRONG></DT>
<DD>Specified name.
   
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Upon return holds the requested field item. It is an error if this
   argument was specified and there is not exactly one field item in
   <TT>ESMF_FieldBundle</TT> that matches <TT>fieldName</TT>.
   
</DD>
<DT><STRONG>[fieldCount]</STRONG></DT>
<DD>Number of Fields with <TT>fieldName</TT> in <TT>ESMF_FieldBundle</TT>.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Upon return indicates whether field(s) with <TT>fieldName</TT> exist
   in <TT>ESMF_FieldBundle</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251200000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_FieldBundleGet - Get a list of Fields by name</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_FieldBundleGet()
     subroutine ESMF_FieldBundleGetList(fieldbundle, fieldName, fieldList, &amp;
       itemorderflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle
     character(len=*), intent(in) :: fieldName
     type(ESMF_Field), intent(out) :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ItemOrder_Flag), intent(in), optional :: itemorderflag
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>itemorderflag</TT>.
   The new argument gives the user control over the order in which
   the items are returned.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the list of Fields from fieldbundle that match fieldName.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be queried.
   
</DD>
<DT><STRONG>fieldName</STRONG></DT>
<DD>Specified name.
   
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>List of Fields in <TT>ESMF_FieldBundle</TT> that match <TT>fieldName</TT>. The
   argument must be allocated to be at least of size <TT>fieldCount</TT>
   returned for this <TT>fieldName</TT>.
   
</DD>
<DT><STRONG>[itemorderflag]</STRONG></DT>
<DD>Specifies the order of the returned items in the <TT>fieldList</TT>.
   The default is <TT>ESMF_ITEMORDER_ABC</TT>.
   See <A HREF="node9.html#const:itemorderflag">54.32</A> for a full list of options.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251300000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_FieldBundleGet - Get Fortran array pointer from a packed FieldBundle </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleGet() 
   function ESMF_FieldBundleGetDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(fieldBundle, &amp; 
   localDe, farrayPtr, &amp; 
   rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_FieldBundle) :: ESMF_FieldBundleGetDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_FieldBundle), intent(in) :: fieldBundle 
   integer, intent(in), optional :: localDe 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a Fortran pointer to DE-local memory allocation within packed FieldBundle. 
   It's erroneous to perform this call on a FieldBundle that's not packed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>fieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> object. 
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. [0,..,localDeCount-1]. 
   For localDeCount==1 the localDe argument may be omitted, 
   in which case it will default to localDe=0. In the case where 
   packed FieldBundle is created on a Grid, the number of localDes can 
   be queried from the Grid attached to the FieldBundle. In the case where 
   packed FieldBundle is created on a Mesh, the number of localDes is 1. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Fortran array pointer which will be pointed at DE-local memory allocation 
   in packed FieldBundle. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050251400000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_FieldBundleHalo - Execute a FieldBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleHalo(fieldbundle, routehandle, &amp;
     checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(inout) :: fieldbundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: checkflag
         integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed halo operation for the Fields in <TT>fieldbundle</TT>.
   The FieldBundle must match the respective FieldBundle used during
   <TT>ESMF_FieldBundleHaloStore()</TT> in <EM>type</EM>, <EM>kind</EM>, and
   memory layout of the <EM>gridded</EM> dimensions. However, the size, number,
   and index order of <EM>ungridded</EM> dimensions may be different. See section
   <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle
   reusability.

<P>
See <TT>ESMF_FieldBundleHaloStore()</TT> on how to precompute
   <TT>routehandle</TT>.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. The data in this
   FieldBundle may be destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
   consistency with the precomputed operation provided by <TT>routehandle</TT>.
   If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
   will be performed, leaving many inconsistencies undetected. Set
   <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251500000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_FieldBundleHaloRelease - Release resources associated with a FieldBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleHaloRelease(routehandle, &amp;
     noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: noGarbage
         integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with a FieldBundle halo operation. After this call
   <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases - a situation which may lead to hard to debug
   application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
   set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
   removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251600000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_FieldBundleHaloStore - Precompute a FieldBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleHaloStore(fieldbundle, routehandle, &amp;
       rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle halo operation over the data in <TT>fieldbundle</TT>.
   By definition, all elements in the total Field regions that lie
   outside the exclusive regions will be considered potential destination
   elements for the halo operation. However, only those elements that have a corresponding
   halo source element, i.e. an exclusive element on one of the DEs, will be
   updated under the halo operation. Elements that have no associated source
   remain unchanged under halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call
   <TT>ESMF_FieldBundleHalo()</TT> on any pair of FieldBundles that matches
   <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
   and memory layout of the <EM>gridded</EM> dimensions. However, the size,
   number, and index order of <EM>ungridded</EM> dimensions may be different.
   See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
   RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> containing data to be haloed. The data in this
   FieldBundle may be destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251700000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_FieldBundleIsCreated - Check whether a FieldBundle object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_FieldBundleIsCreated(fieldbundle, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_FieldBundleIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>fieldbundle</TT> has been created. Otherwise return
   <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
   returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251800000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_FieldBundlePrint - Print FieldBundle information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundlePrint(fieldbundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>fieldbundle</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251900000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_FieldBundleRead - Read Fields to a FieldBundle from file(s)</A>
</H3>

<P>
<A NAME="api:FieldBundleRead"></A>
<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRead(fieldbundle, fileName, &amp;
     singleFile, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     character(*), intent(in) :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: singleFile
     integer, intent(in), optional :: timeslice
     type(ESMF_IOFmt_Flag), intent(in), optional :: iofmt
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Read field data to a FieldBundle object from file(s).
   For this API to be functional, the environment variable <TT>ESMF_PIO</TT>
   should be set to either "internal" or "external" when the ESMF library is built.
   Please see the section on Data I/O,&nbsp;<A HREF="#io:dataio">38.2</A>.

<P>
Limitations:
   
<UL>
<LI>For multi-tile Fields, all Fields in the FieldBundle must contain
   the same number of tiles.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
   
</LI>
</UL>

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file from which FieldBundle data is read.
   If the FieldBundle contains multi-tile Arrays, then fileName must contain
   exactly one instance of "*"; this is a placeholder that will be replaced
   by the tile number, with each tile being read from a separate file. (For
   example, for a fileName of "myfile*.nc", tile 1 will be read from
   "myfile1.nc", tile 2 from "myfile2.nc", etc.)
   (This handling of the fileName for multi-tile I/O is subject to change.)
   
</DD>
<DT><STRONG>[singleFile]</STRONG></DT>
<DD>A logical flag, the default is .true., i.e., all Fields in the bundle
   are stored in one single file. If .false., each field is stored
   in separate files; these files are numbered with the name based on the
   argument "file". That is, a set of files are named: [file_name]001,
   [file_name]002, [file_name]003,...
   
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>The time-slice number of the variable read from file.
   
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format. Please see Section&nbsp;<A HREF="node9.html#opt:iofmtflag">54.28</A> for the list
   of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_FieldBundleRedist - Execute a FieldBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRedist(srcFieldBundle, dstFieldBundle, &amp;
     routehandle, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in), optional :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout), optional :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: checkflag
         integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed redistribution from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>.
   Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must match the
   respective FieldBundles used during <TT>ESMF_FieldBundleRedistStore()</TT>
   in <EM>type</EM>, <EM>kind</EM>, and memory layout of the <EM>gridded</EM>
   dimensions. However, the size, number,
   and index order of <EM>ungridded</EM> dimensions may be different. See section
   <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle
   reusability.

<P>
The <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments are optional in support of
   the situation where <TT>srcFieldBundle</TT> and/or <TT>dstFieldBundle</TT> are not defined on
   all PETs. The <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be specified on those
   PETs that hold source or destination DEs, respectively, but may be omitted
   on all other PETs. PETs that hold neither source nor destination DEs may
   omit both arguments.

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
   <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleRedistStore()</TT> on how to precompute
   <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:fieldbundle:usage:redist_1dptr">25.2.9</A>.

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
   
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
   consistency with the precomputed operation provided by <TT>routehandle</TT>.
   If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
   will be performed, leaving many inconsistencies undetected. Set
   <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252100000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_FieldBundleRedistRelease - Release resources associated with a FieldBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRedistRelease(routehandle, &amp;
     noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: noGarbage
         integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with a FieldBundle redistribution. After this call
   <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases - a situation which may lead to hard to debug
   application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
   set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
   removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252200000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_FieldBundleRedistStore - Precompute a FieldBundle redistribution with local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleRedistStore()
   subroutine ESMF_FieldBundleRedistStore&lt;type&gt;&lt;kind&gt;(srcFieldBundle, &amp;
   dstFieldBundle, routehandle, factor, &amp;
   ignoreUnmatchedIndicesFlag, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
   type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
   type(ESMF_RouteHandle), intent(inout) :: routehandle
   &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in) :: factor
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   logical, intent(in), optional :: ignoreUnmatchedIndicesFlag(:)
   integer, intent(in), optional :: srcToDstTransposeMap(:)
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndicesFlag</TT> to support cases
   where source and destination side do not cover the exact same index space.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle redistribution operation from <TT>srcFieldBundle</TT> to <TT>dstFieldBundle</TT>.
   PETs that
   specify a <TT>factor</TT> argument must use the &lt;type&gt;&lt;kind&gt; overloaded interface. Other
   PETs call into the interface without <TT>factor</TT> argument. If multiple PETs specify
   the <TT>factor</TT> argument its type and kind as well as its value must match across
   all PETs. If none of the PETs specifies a <TT>factor</TT> argument the default will be a
   factor of 1.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized
   vectors. The
   sequence is defined by the order of DistGrid dimensions and the order of
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See
   section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of <EM>sequence indices</EM>.
   Redistribution corresponds to an identity mapping of the source FieldBundle vector to
   the destination FieldBundle vector.

<P>
Source and destination FieldBundles may be of different &lt;type&gt;&lt;kind&gt;. Further source
   and destination FieldBundles may differ in shape, however, the number of elements
   must match.

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle
   and dstFieldBundle arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call
   <TT>ESMF_FieldBundleRedist()</TT> on any pair of FieldBundles that matches
   <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
   and memory layout of the <EM>gridded</EM> dimensions. However, the size,
   number, and index order of <EM>ungridded</EM> dimensions may be different.
   See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
   RouteHandle reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:fieldbundle:usage:redist_1dptr">25.2.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this
   FieldBundle may be destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multiply source data.
   
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
   cover the identical index space, using precisely matching sequence
   indices. If set to .true., mismatching sequence indices between source
   and destination side are silently ignored.
   The size of this array argument must either be 1 or equal the number of
   Fields in the <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments. In
   the latter case, the handling of unmatched indices is specified for each
   Field pair separately. If only one element is specified, it is
   used for <EM>all</EM> Field pairs.
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcFieldBundle</TT>. Each
   entry maps the corresponding <TT>srcFieldBundle</TT> dimension
   against the specified <TT>dstFieldBundle</TT>
   dimension. Mixing of distributed and undistributed dimensions is supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252300000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_FieldBundleRedistStore - Precompute a FieldBundle redistribution without local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleRedistStore()
   subroutine ESMF_FieldBundleRedistStoreNF(srcFieldBundle, dstFieldBundle, &amp;
     routehandle, ignoreUnmatchedIndicesFlag, &amp;
     srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
     type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
     type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: ignoreUnmatchedIndicesFlag(:)
     integer, intent(in), optional :: srcToDstTransposeMap(:)
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndicesFlag</TT> to support cases
   where source and destination side do not cover the exact same index space.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle redistribution operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a
   PET does not provide matrix elements. Alternatively, PETs that do not
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized
   vectors. The
   sequence is defined by the order of DistGrid dimensions and the order of
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See
   section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of <EM>sequence indices</EM>.
   Redistribution corresponds to an identity mapping of the source FieldBundle vector to
   the destination FieldBundle vector.

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source
   and destination Fields may differ in shape, however, the number of elements
   must match.

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle and dstFieldBundle
   arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call
   <TT>ESMF_FieldBundleRedist()</TT> on any pair of FieldBundles that matches
   <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
   and memory layout of the <EM>gridded</EM> dimensions. However, the size,
   number, and index order of <EM>ungridded</EM> dimensions may be different.
   See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
   RouteHandle reusability.

<P>
This call is collective across the current VM.

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:fieldbundle:usage:redist_1dptr">25.2.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this
   FieldBundle may be destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
   cover the identical index space, using precisely matching sequence
   indices. If set to .true., mismatching sequence indices between source
   and destination side are silently ignored.
   The size of this array argument must either be 1 or equal the number of
   Fields in the <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments. In
   the latter case, the handling of unmatched indices is specified for each
   Field pair separately. If only one element is specified, it is
   used for <EM>all</EM> Field pairs.
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcFieldBundle</TT>. Each
   entry maps the corresponding <TT>srcFieldBundle</TT> dimension
   against the specified <TT>dstFieldBundle</TT>
   dimension. Mixing of distributed and undistributed dimensions is supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252400000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_FieldBundleRegrid - Execute a FieldBundle regrid operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRegrid(srcFieldBundle, dstFieldBundle, &amp;
          routehandle, zeroregion, termorderflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in), optional :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout), optional :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         type(ESMF_Region_Flag), intent(in), optional :: zeroregion
         type(ESMF_TermOrder_Flag), intent(in), optional :: termorderflag(:)
         logical, intent(in), optional :: checkflag
         integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>termorderflag</TT>.
   The new argument gives the user control over the order in which
   the src terms are summed up.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed regrid from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>.
   Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must match the
   respective FieldBundles used during <TT>ESMF_FieldBundleRedistStore()</TT>
   in <EM>type</EM>, <EM>kind</EM>, and memory layout of the <EM>gridded</EM>
   dimensions. However, the size, number,
   and index order of <EM>ungridded</EM> dimensions may be different. See section
   <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle
   reusability.

<P>
The <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments are optional in support of
   the situation where <TT>srcFieldBundle</TT> and/or <TT>dstFieldBundle</TT> are not defined on
   all PETs. The <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be specified on those
   PETs that hold source or destination DEs, respectively, but may be omitted
   on all other PETs. PETs that hold neither source nor destination DEs may
   omit both arguments.

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
   <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleRegridStore()</TT> on how to precompute
   <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
   
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
   all DEs in <TT>dstFieldBundle</TT> will be initialized to zero before updating the
   elements with the results of the sparse matrix multiplication. If set to
   <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstFieldBundle</TT> will not be
   modified prior to the sparse matrix multiplication and results will be
   added to the incoming element values. Setting <TT>zeroregion</TT> to
   <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the
   destination FieldBundle that will be updated by the sparse matrix
   multiplication. See section <A HREF="node9.html#const:region">54.48</A> for a complete list of
   valid settings.

</DD>
<DT><STRONG>[termorderflag]</STRONG></DT>
<DD>Specifies the order of the source side terms in all of the destination
   sums. The <TT>termorderflag</TT> only affects the order of terms during
   the execution of the RouteHandle. See the <A HREF="#RH:bfb">37.2.1</A> section for an
   in-depth discussion of <EM>all</EM> bit-for-bit reproducibility
   aspects related to route-based communication methods.
   See <A HREF="node9.html#const:termorderflag">54.58</A> for a full list of options.
   The size of this array argument must either be 1 or equal the number of
   Fields in the <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments. In
   the latter case, the term order for each Field Regrid operation is
   indicated separately. If only one term order element is specified, it is
   used for <EM>all</EM> Field pairs.
   The default is <TT>(/ESMF_TERMORDER_FREE/)</TT>, allowing maximum
   flexibility in the order of terms for optimum performance.
   
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
   consistency with the precomputed operation provided by <TT>routehandle</TT>.
   If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
   will be performed, leaving many inconsistencies undetected. Set
   <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252500000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_FieldBundleRegridRelease - Release resources associated with a FieldBundle regrid operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRegridRelease(routehandle, &amp;
     noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: noGarbage
         integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with a FieldBundle regrid operation. After this call
   <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases - a situation which may lead to hard to debug
   application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
   set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
   removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252600000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_FieldBundleRegridStore - Precompute a FieldBundle regrid operation</A>
</H3>

<P>
<A NAME="api:esmf_fieldbundleregridstore"></A>
<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRegridStore(srcFieldBundle, dstFieldBundle, &amp;
        srcMaskValues, dstMaskValues, regridmethod, polemethod, regridPoleNPnts, &amp;
        lineType, normType, extrapMethod, extrapNumSrcPnts, extrapDistExponent, &amp;
        extrapNumLevels, unmappedaction, ignoreDegenerate, srcTermProcessing, &amp;
        pipelineDepth, routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
     type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
  TODO: why is there no ESMF_KeywordEnforcer here???
     integer(ESMF_KIND_I4), target, intent(in), optional :: srcMaskValues(:)
     integer(ESMF_KIND_I4), target, intent(in), optional :: dstMaskValues(:)
     type(ESMF_RegridMethod_Flag), intent(in), optional :: regridmethod
     type(ESMF_PoleMethod_Flag), intent(in), optional :: polemethod
     integer, intent(in), optional :: regridPoleNPnts
     type(ESMF_LineType_Flag), intent(in), optional :: lineType
     type(ESMF_NormType_Flag), intent(in), optional :: normType
     type(ESMF_ExtrapMethod_Flag), intent(in), optional :: extrapMethod
     integer, intent(in), optional :: extrapNumSrcPnts
     real, intent(in), optional :: extrapDistExponent
     integer, intent(in), optional :: extrapNumLevels
     type(ESMF_UnmappedAction_Flag),intent(in), optional :: unmappedaction
     logical, intent(in), optional :: ignoreDegenerate
     integer, intent(inout), optional :: srcTermProcessing
     integer, intent(inout), optional :: pipelineDepth
     type(ESMF_RouteHandle), intent(inout), optional :: routehandle
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added arguments <TT>ignoreDegenerate</TT>, <TT>lineType</TT>,
   and <TT>normType</TT>. The argument <TT>ignoreDegenerate</TT> allows the user to
   skip degenerate cells in the regridding instead of stopping with an error.
   The argument <TT>lineType</TT> allows the user to control the path of the line
   between two points on a sphere surface. This allows the user to use their
   preferred line path for the calculation of distances and the shape of cells
   during regrid weight calculation on a sphere. The argument <TT>normType</TT>
   allows the user to control the type of normalization done during
   conservative weight generation.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>srcTermProcessing</TT>.
   Added argument <TT>pipelineDepth</TT>.
   The new arguments provide access to the tuning parameters
   affecting the performance and bit-for-bit behavior when applying
   the regridding weights.

<P>
Added arguments <TT>extrapMethod</TT>, <TT>extrapNumSrcPnts</TT>, and
   <TT>extrapDistExponent</TT>. These three new extrapolation arguments allow the
   user to extrapolate destination points not mapped by the regrid method.
   <TT>extrapMethod</TT> allows the user to choose the extrapolation method.
   <TT>extrapNumSrcPnts</TT> and <TT>extrapDistExponent</TT> are parameters that
   allow the user to tune the behavior of the
   <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT> method.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>extrapNumLevels</TT>. For level based
   extrapolation methods (e.g. <TT>ESMF_EXTRAPMETHOD_CREEP</TT>) this argument
   allows the user to set how many levels to extrapolate.
  !
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle regrid operation over the data in <TT>srcFieldBundle</TT>
   and <TT>dstFieldBundle</TT> pair.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call
   <TT>ESMF_FieldBundleRegrid()</TT> on any pair of FieldBundles that matches
   <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
   and memory layout of the <EM>gridded</EM> dimensions. However, the size,
   number, and index order of <EM>ungridded</EM> dimensions may be different.
   See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
   RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcFieldbundle</STRONG></DT>
<DD>Source <TT>ESMF_FieldBundle</TT> containing data to be regridded.
   
</DD>
<DT><STRONG>dstFieldbundle</STRONG></DT>
<DD>Destination <TT>ESMF_FieldBundle</TT>. The data in this FieldBundle may be
   overwritten by this call.
   
</DD>
<DT><STRONG>[srcMaskValues]</STRONG></DT>
<DD>Mask information can be set in the Grids (see&nbsp;<A HREF="#sec:usage:items">31.3.17</A>)
   or Meshes (see&nbsp;<A HREF="#sec:mesh:mask">33.3.11</A>) upon which the Fields in the
   <TT>srcFieldbundle</TT> are built. The <TT>srcMaskValues</TT> argument
   specifies the values in that mask information which indicate a source
   point should be masked out. In other words, a location is masked if and
   only if the value for that location in the mask information matches one
   of the values listed in <TT>srcMaskValues</TT>.
   If <TT>srcMaskValues</TT> is not specified, no masking will occur.
   
</DD>
<DT><STRONG>[dstMaskValues]</STRONG></DT>
<DD>Mask information can be set in the Grids (see&nbsp;<A HREF="#sec:usage:items">31.3.17</A>) or Meshes (see&nbsp;<A HREF="#sec:mesh:mask">33.3.11</A>)
   upon which the Fields in the <TT>dstFieldbundle</TT> are built.
   The <TT>dstMaskValues</TT> argument specifies the values in that mask
   information which indicate a destination point should be masked out.
   In other words, a location is masked if and only if the value for that
   location in the mask information matches
   one of the values listed in <TT>dstMaskValues</TT>.
   If <TT>dstMaskValues</TT> is not specified, no masking will occur.
   
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. Please see Section&nbsp;<A HREF="node9.html#opt:regridmethod">54.49</A> for a list of
   valid options. If not specified, defaults to <TT>ESMF_REGRIDMETHOD_BILINEAR</TT>.
   
</DD>
<DT><STRONG>[polemethod]</STRONG></DT>
<DD>Which type of artificial pole
   to construct on the source Grid for regridding. Please see
   section&nbsp;<A HREF="node9.html#const:polemethod">54.46</A> for a list of valid options. If not
   specified, defaults to <TT>ESMF_POLEMETHOD_ALLAVG</TT>.
   
</DD>
<DT><STRONG>[regridPoleNPnts]</STRONG></DT>
<DD>If <TT>polemethod</TT> is <TT>ESMF_POLEMETHOD_NPNTAVG</TT>.
   This parameter indicates how many points should be averaged
   over. Must be specified if <TT>polemethod</TT> is
   <TT>ESMF_POLEMETHOD_NPNTAVG</TT>.
   
</DD>
<DT><STRONG>[lineType]</STRONG></DT>
<DD>This argument controls the path of the line which connects two points on a sphere surface. This in
   turn controls the path along which distances are calculated and the shape of the edges that make
   up a cell. Both of these quantities can influence how interpolation weights are calculated.
   As would be expected, this argument is only applicable when <TT>srcField</TT> and <TT>dstField</TT> are
   built on grids which lie on the surface of a sphere. Section&nbsp;<A HREF="node9.html#opt:lineType">54.34</A> shows a
   list of valid options for this argument. If not specified, the default depends on the
   regrid method. Section&nbsp;<A HREF="node9.html#opt:lineType">54.34</A> has the defaults by line type. Figure&nbsp;<A HREF="#line_type_support">24.2.16</A> shows
   which line types are supported for each regrid method as well as showing the default line type by regrid method.
   
</DD>
<DT><STRONG>[normType]</STRONG></DT>
<DD>This argument controls the type of normalization used when generating conservative weights. This option
   only applies to weights generated with <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE</TT>. Please see
   Section&nbsp;<A HREF="node9.html#opt:normType">54.43</A> for a
   list of valid options. If not specified <TT>normType</TT> defaults to <TT>ESMF_NORMTYPE_DSTAREA</TT>.
   
</DD>
<DT><STRONG>[extrapMethod]</STRONG></DT>
<DD>The type of extrapolation. Please see Section&nbsp;<A HREF="node9.html#opt:extrapmethod">54.17</A>
   for a list of valid options. If not specified, defaults to
   <TT>ESMF_EXTRAPMETHOD_NONE</TT>.
   
</DD>
<DT><STRONG>[extrapNumSrcPnts]</STRONG></DT>
<DD>The number of source points to use for the extrapolation methods that use more than one source point
   (e.g. <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT>). If not specified, defaults to 8.
   
</DD>
<DT><STRONG>[extrapDistExponent]</STRONG></DT>
<DD>The exponent to raise the distance to when calculating weights for
   the <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT> extrapolation method. A higher value reduces the influence
   of more distant points. If not specified, defaults to 2.0.
   
</DD>
<DT><STRONG>[extrapNumLevels]</STRONG></DT>
<DD>The number of levels to output for the extrapolation methods that fill levels
   (e.g. <TT>ESMF_EXTRAPMETHOD_CREEP</TT>). When a method is used that requires this, then an error will be returned, if it
   is not specified.
   
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
   can not be mapped to a source cell. Please see Section&nbsp;<A HREF="node9.html#const:unmappedaction">54.60</A> for a
   list of valid options. If not specified, <TT>unmappedaction</TT> defaults to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>.
   
</DD>
<DT><STRONG>[ignoreDegenerate]</STRONG></DT>
<DD>Ignore degenerate cells when checking the input Grids or Meshes for errors. If this is set to true, then the
   regridding proceeds, but degenerate cells will be skipped. If set to false, a degenerate cell produces an error.
   If not specified, <TT>ignoreDegenerate</TT> defaults to false.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
   located on the same PET and summing into the same destination element,
   are summed into partial sums on the source PET before being transferred
   to the destination PET. A value of 0 indicates that the entire arithmetic
   is done on the destination PET; source elements are neither multiplied
   by their factors nor added into partial sums before being sent off by the
   source PET. A value of 1 indicates that source elements are multiplied
   by their factors on the source side before being sent to the destination
   PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
   of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
   See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
   bit-for-bit reproducibility aspects related to route-based communication
   methods.

<P>
The <TT>ESMF_FieldRegridStore()</TT> method implements an auto-tuning scheme
   for the <TT>srcTermProcessing</TT> parameter. The intent on the
   <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
   support both overriding and accessing the auto-tuning parameter.
   If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
   <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
   In this case the <TT>srcTermProcessing</TT> argument is not modified on
   return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
   parameter is determined internally using the auto-tuning scheme. In this
   case the <TT>srcTermProcessing</TT> argument is re-set to the internally
   determined value on return. Auto-tuning is also used if the optional
   <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
   may have outstanding during a sparse matrix exchange. Larger values
   of <TT>pipelineDepth</TT> typically lead to better performance. However,
   on some systems too large a value may lead to performance degradation,
   or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
   reproducibility of the results. However, it may affect the performance
   reproducibility of the exchange.

<P>
The <TT>ESMF_FieldRegridStore()</TT> method implements an auto-tuning scheme
   for the <TT>pipelineDepth</TT> parameter. The intent on the
   <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
   support both overriding and accessing the auto-tuning parameter.
   If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
   <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
   In this case the <TT>pipelineDepth</TT> argument is not modified on
   return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
   parameter is determined internally using the auto-tuning scheme. In this
   case the <TT>pipelineDepth</TT> argument is re-set to the internally
   determined value on return. Auto-tuning is also used if the optional
   <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[routehandle]</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252700000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_FieldBundleRemove - Remove Fields from FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRemove(fieldbundle, fieldNameList, &amp;
     multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     character(len=*), intent(in) :: fieldNameList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: multiflag
     logical, intent(in), optional :: relaxedflag
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove field(s) by name from FieldBundle. In the relaxed setting it is
   <EM>not</EM> an error if <TT>fieldNameList</TT> contains names that are not
   found in <TT>fieldbundle</TT>.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> from which to remove items.
   
</DD>
<DT><STRONG>fieldNameList</STRONG></DT>
<DD>List of items to remove.
   
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple Fields with the same name
   to be removed from <TT>fieldbundle</TT>. For <TT>.false.</TT>, items to be
   removed must have unique names. The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "remove"
   where it is <EM>not</EM> an error if <TT>fieldNameList</TT> contains item
   names that are not found in <TT>fieldbundle</TT>. For <TT>.false.</TT> this is
   treated as an error condition.
   Further, in <TT>multiflag=.false.</TT> mode, the relaxed definition of
   "remove" also covers the case where there are multiple items in
   <TT>fieldbundle</TT> that match a single entry in <TT>fieldNameList</TT>.
   For <TT>relaxedflag=.false.</TT> this is treated as an error condition.
   The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252800000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_FieldBundleReplace - Replace Fields in FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleReplace(fieldbundle, fieldList, &amp;
     multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout) :: fieldbundle
     type(ESMF_Field), intent(in) :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: multiflag
     logical, intent(in), optional :: relaxedflag
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Replace field(s) by name in FieldBundle. In the relaxed setting it is not
   an error if <TT>fieldList</TT> contains Fields that do not match by name any
   item in <TT>fieldbundle</TT>. These Fields are simply ignored in this case.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> in which to replace items.
   
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>List of items to replace.
   
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
   to be replaced in <TT>fieldbundle</TT>. For <TT>.false.</TT>, items to be
   replaced must have unique names. The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "replace"
   where it is <EM>not</EM> an error if <TT>fieldList</TT> contains items with
   names that are not found in <TT>fieldbundle</TT>. These items in
   <TT>fieldList</TT> are ignored in the relaxed mode. For <TT>.false.</TT> this
   is treated as an error condition.
   Further, in <TT>multiflag=.false.</TT> mode, the relaxed definition of
   "replace" also covers the case where there are multiple items in
   <TT>fieldbundle</TT> that match a single entry by name in <TT>fieldList</TT>.
   For <TT>relaxedflag=.false.</TT> this is treated as an error condition.
   The default setting is <TT>.false.</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252900000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_FieldBundleSet - Associate a Grid with an empty FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetGrid(fieldbundle, grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: fieldbundle
       type(ESMF_Grid), intent(in) :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the <TT>grid</TT> for a <TT>fieldbundle</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> which all <TT>ESMF_Field</TT>s added to this
   <TT>ESMF_FieldBundle</TT> must have.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_FieldBundleSet - Associate a Mesh with an empty FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetMesh(fieldbundle, mesh, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: fieldbundle
       type(ESMF_Mesh), intent(in) :: mesh
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the <TT>mesh</TT> for a <TT>fieldbundle</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> which all <TT>ESMF_Field</TT>s added to this
   <TT>ESMF_FieldBundle</TT> must have.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253100000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_FieldBundleSet - Associate a LocStream with an empty FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetLS(fieldbundle, locstream, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: fieldbundle
       type(ESMF_LocStream), intent(in) :: locstream
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the <TT>locstream</TT> for a <TT>fieldbundle</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> which all <TT>ESMF_Field</TT>s added to this
   <TT>ESMF_FieldBundle</TT> must have.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253200000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_FieldBundleSet - Associate a XGrid with an empty FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_FieldBundleSet()
       subroutine ESMF_FieldBundleSetXGrid(fieldbundle, xgrid, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_FieldBundle), intent(inout) :: fieldbundle
       type(ESMF_XGrid), intent(in) :: xgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the <TT>xgrid</TT> for a <TT>fieldbundle</TT>

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> which all <TT>ESMF_Field</TT>s added to this
   <TT>ESMF_FieldBundle</TT> must have.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253300000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_FieldBundleSMM - Execute a FieldBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleSMM(srcFieldBundle, dstFieldBundle, &amp;
     routehandle, &amp;
     zeroregion, &amp; ! DEPRECATED ARGUMENT
     zeroregionflag, termorderflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in), optional :: srcFieldBundle
     type(ESMF_FieldBundle), intent(inout), optional :: dstFieldBundle
     type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Region_Flag), intent(in), optional :: zeroregion ! DEPRECATED ARGUMENT
     type(ESMF_Region_Flag), intent(in), target, optional :: zeroregionflag(:)
     type(ESMF_TermOrder_Flag), intent(in), optional :: termorderflag(:)
     logical, intent(in), optional :: checkflag
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>termorderflag</TT>.
   The new argument gives the user control over the order in which
   the src terms are summed up.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>zeroregionflag</TT>, and deprecated
   <TT>zeroregion</TT>. The new argument allows greater flexibility
   in setting the zero region for individual FieldBundle members.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed sparse matrix multiplication from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>.
   Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must match the
   respective FieldBundles used during <TT>ESMF_FieldBundleRedistStore()</TT>
   in <EM>type</EM>, <EM>kind</EM>, and memory layout of the <EM>gridded</EM>
   dimensions. However, the size, number,
   and index order of <EM>ungridded</EM> dimensions may be different. See section
   <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle
   reusability.

<P>
The <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments are optional in support of
   the situation where <TT>srcFieldBundle</TT> and/or <TT>dstFieldBundle</TT> are not defined on
   all PETs. The <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be specified on those
   PETs that hold source or destination DEs, respectively, but may be omitted
   on all other PETs. PETs that hold neither source nor destination DEs may
   omit both arguments.

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
   <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleSMMStore()</TT> on how to precompute
   <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:fieldbundle:usage:smm_1dptr">25.2.11</A>.

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
   
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
   all DEs in all Fields in <TT>dstFieldBundle</TT> will be initialized to zero
   before updating the elements with the results of the sparse matrix
   multiplication. If set to <TT>ESMF_REGION_EMPTY</TT> the elements in the
   Fields in <TT>dstFieldBundle</TT> will not be modified prior to the sparse
   matrix multiplication and results will be added to the incoming element
   values. Setting <TT>zeroregion</TT> to <TT>ESMF_REGION_SELECT</TT> will only
   zero out those elements in the destination Fields that will be updated
   by the sparse matrix multiplication. See section <A HREF="node9.html#const:region">54.48</A>
   
</DD>
<DT><STRONG>[zeroregionflag]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
   all DEs in the destination Field will be initialized to zero
   before updating the elements with the results of the sparse matrix
   multiplication. If set to <TT>ESMF_REGION_EMPTY</TT> the elements in the
   destination Field will not be modified prior to the sparse
   matrix multiplication and results will be added to the incoming element
   values. A setting of <TT>ESMF_REGION_SELECT</TT> will only
   zero out those elements in the destination Field that will be updated
   by the sparse matrix multiplication. See section <A HREF="node9.html#const:region">54.48</A>
   for a complete list of valid settings.
   The size of this array argument must either be 1 or equal the number of
   Fields in the <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments. In
   the latter case, the zero region for each Field SMM operation is
   indicated separately. If only one zero region element is specified, it is
   used for <EM>all</EM> Field pairs.
   
</DD>
<DT><STRONG>[termorderflag]</STRONG></DT>
<DD>Specifies the order of the source side terms in all of the destination
   sums. The <TT>termorderflag</TT> only affects the order of terms during
   the execution of the RouteHandle. See the <A HREF="#RH:bfb">37.2.1</A> section for an
   in-depth discussion of <EM>all</EM> bit-for-bit reproducibility
   aspects related to route-based communication methods.
   See <A HREF="node9.html#const:termorderflag">54.58</A> for a full list of options.
   The size of this array argument must either be 1 or equal the number of
   Fields in the <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments. In
   the latter case, the term order for each Field SMM operation is
   indicated separately. If only one term order element is specified, it is
   used for <EM>all</EM> Field pairs.
   The default is <TT>(/ESMF_TERMORDER_FREE/)</TT>, allowing maximum
   flexibility in the order of terms for optimum performance.
   
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
   consistency with the precomputed operation provided by <TT>routehandle</TT>.
   If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
   will be performed, leaving many inconsistencies undetected. Set
   <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253400000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_FieldBundleSMMRelease - Release resources associated with a FieldBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleSMMRelease(routehandle, &amp;
     noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: noGarbage
         integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with a FieldBundle sparse matrix multiplication. After this call
   <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases - a situation which may lead to hard to debug
   application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
   set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
   removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253500000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_FieldBundleSMMStore - Precompute a FieldBundle sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleSMMStore()
   subroutine ESMF_FieldBundleSMMStore&lt;type&gt;&lt;kind&gt;(srcFieldBundle, &amp;
   dstFieldBundle, routehandle, factorList, factorIndexList, &amp;
   ignoreUnmatchedIndicesFlag, srcTermProcessing, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
   type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
   type(ESMF_RouteHandle), intent(inout) :: routehandle
   &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in) :: factorList(:)
   integer, intent(in), :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   logical, intent(in), optional :: ignoreUnmatchedIndicesFlag(:)
   integer, intent(inout), optional :: srcTermProcessing(:)
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>srcTermProcessing</TT>.
   The new argument gives the user access to the tuning parameter
   affecting the sparse matrix execution and bit-wise
   reproducibility.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndicesFlag</TT> to support cases
   where the sparse matrix includes terms with source or destination sequence
   indices not present in the source or destination field.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle sparse matrix multiplication operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with
   <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a
   PET does not provide matrix elements. Alternatively, PETs that do not
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized
   vectors. The
   sequence is defined by the order of DistGrid dimensions and the order of
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See
   section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of <EM>sequence indices</EM>.
   SMM corresponds to an identity mapping of the source FieldBundle vector to
   the destination FieldBundle vector.

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source
   and destination Fields may differ in shape, however, the number of elements
   must match.

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle
   and dstFieldBundle arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call
   <TT>ESMF_FieldBundleSMM()</TT> on any pair of FieldBundles that matches
   <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
   and memory layout of the <EM>gridded</EM> dimensions. However, the size,
   number, and index order of <EM>ungridded</EM> dimensions may be different.
   See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
   RouteHandle reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:fieldbundle:usage:smm_1dptr">25.2.11</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this
   FieldBundle may be destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
   
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
   pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
   dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
   sequence index of the source element in the <TT>srcFieldBundle</TT> while
   <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
   destination element in <TT>dstFieldBundle</TT>. For this format to be a valid
   option source and destination FieldBundles must have matching number of
   tensor elements (the product of the sizes of all Field tensor dimensions).
   Under this condition an identity matrix can be applied within the space of
   tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
   tensor element count. Here the

<P>
<TT>factorIndexList(1,:)</TT> specifies the
   sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
   sequence index of the source element in the <TT>srcFieldBundle</TT>. Further
   <TT>factorIndexList(3,:)</TT> specifies the sequence index and
   <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the
   destination element in the <TT>dstFieldBundle</TT>.

<P>
See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of
   <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
   cover all of the squence indices defined in the sparse matrix. An error
   will be returned if a sequence index in the sparse matrix does not match
   on either the source or destination side.
   If set to .true., mismatching sequence indices are silently ignored.
   The size of this array argument must either be 1 or equal the number of
   Fieldss in the <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments. In
   the latter case, the handling of unmatched indices is specified for each
   Field pair separately. If only one element is specified, it is
   used for <EM>all</EM> Field pairs.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>Source term summing options for route handle creation. See
   <TT>ESMF_FieldRegridStore</TT> documentation for a full parameter description.
   Two forms may be provided. If a single element list is provided, this
   integer value is applied across all bundle members. Otherwise, the list must
   contain as many elements as there are bundle members. For the special case
   of accessing the auto-tuned parameter (providing a negative integer value),
   the list length must equal the bundle member count.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253600000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_FieldBundleSMMStore - Precompute a FieldBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleSMMStore()
     subroutine ESMF_FieldBundleSMMStoreNF(srcFieldBundle, dstFieldBundle, &amp;
         routehandle, ignoreUnmatchedIndicesFlag, &amp;
         srcTermProcessing, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical, intent(in), optional :: ignoreUnmatchedIndicesFlag(:)
         integer, intent(inout), optional :: srcTermProcessing(:)
         integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>srcTermProcessing</TT>.
   The new argument gives the user access to the tuning parameter
   affecting the sparse matrix execution and bit-wise
   reproducibility.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndicesFlag</TT> to support cases
   where the sparse matrix includes terms with source or destination sequence
   indices not present in the source or destination field.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle sparse matrix multiplication operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a
   PET does not provide matrix elements. Alternatively, PETs that do not
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized
   vectors. The
   sequence is defined by the order of DistGrid dimensions and the order of
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See
   section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of <EM>sequence indices</EM>.
   SMM corresponds to an identity mapping of the source FieldBundle vector to
   the destination FieldBundle vector.

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source
   and destination Fields may differ in shape, however, the number of elements
   must match.

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle and dstFieldBundle
   arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call
   <TT>ESMF_FieldBundleSMM()</TT> on any pair of FieldBundles that matches
   <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
   and memory layout of the <EM>gridded</EM> dimensions. However, the size,
   number, and index order of <EM>ungridded</EM> dimensions may be different.
   See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
   RouteHandle reusability.

<P>
This method is overloaded for
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
This call is collective across the current VM.

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:fieldbundle:usage:smm_1dptr">25.2.11</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this
   FieldBundle may be destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
   
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
   cover all of the squence indices defined in the sparse matrix. An error
   will be returned if a sequence index in the sparse matrix does not match
   on either the source or destination side.
   If set to .true., mismatching sequence indices are silently ignored.
   The size of this array argument must either be 1 or equal the number of
   Fieldss in the <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments. In
   the latter case, the handling of unmatched indices is specified for each
   Field pair separately. If only one element is specified, it is
   used for <EM>all</EM> Field pairs.
   
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>Source term summing options for route handle creation. See
   <TT>ESMF_FieldRegridStore</TT> documentation for a full parameter description.
   Two forms may be provided. If a single element list is provided, this
   integer value is applied across all bundle members. Otherwise, the list must
   contain as many elements as there are bundle members. For the special case
   of accessing the auto-tuned parameter (providing a negative integer value),
   the list length must equal the bundle member count.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253700000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_FieldBundleSMMStore - Precompute field bundle sparse matrix multiplication using factors read from file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleSMMStore()
     subroutine ESMF_FieldBundleSMMStoreFromFile(srcFieldBundle, dstFieldBundle, &amp;
       filename, routehandle, ignoreUnmatchedIndicesFlag, &amp;
       srcTermProcessing, rc)
   ! ARGUMENTS:
       type(ESMF_FieldBundle), intent(in) :: srcFieldBundle
       type(ESMF_FieldBundle), intent(inout) :: dstFieldBundle
       character(len=*), intent(in) :: filename
       type(ESMF_RouteHandle), intent(inout) :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical, intent(in), optional :: ignoreUnmatchedIndicesFlag(:)
       integer, intent(inout), optional :: srcTermProcessing(:)
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute an <TT>ESMF_RouteHandle</TT> using factors read from file.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.

<P>
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this field
   bundle may be destroyed by this call.

<P>
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Path to the file containing weights for creating an <TT>ESMF_RouteHandle</TT>.
   See&nbsp;(<A HREF="node3.html#sec:weightfileformat">12.9</A>) for a description of the SCRIP weight
   file format. Only "row", "col", and "S" variables are required. They
   must be one-dimensionsal with dimension "n_s".

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the <TT>ESMF_RouteHandle</TT>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
   cover all of the squence indices defined in the sparse matrix. An error
   will be returned if a sequence index in the sparse matrix does not match
   on either the source or destination side.
   If set to .true., mismatching sequence indices are silently ignored.
   The size of this array argument must either be 1 or equal the number of
   Fieldss in the <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> arguments. In
   the latter case, the handling of unmatched indices is specified for each
   Field pair separately. If only one element is specified, it is
   used for <EM>all</EM> Field pairs.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>Source term summing options for route handle creation. See
   <TT>ESMF_FieldRegridStore</TT> documentation for a full parameter description.
   Two forms may be provided. If a single element list is provided, this
   integer value is applied across all bundle members. Otherwise, the list must
   contain as many elements as there are bundle members. For the special case
   of accessing the auto-tuned parameter (providing a negative integer value),
   the list length must equal the bundle member count.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253800000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_FieldBundleValidate - Validate fieldbundle internals</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleValidate(fieldbundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>fieldbundle</TT> is internally consistent.
   The method returns an error code if problems are found.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>Specified <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253900000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_FieldBundleWrite - Write the Fields into a file</A>
</H3>

<P>
<A NAME="api:FieldBundleWrite"></A>
<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleWrite(fieldbundle, fileName, &amp;
       convention, purpose, singleFile, overwrite, status, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle
     character(*), intent(in) :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*), intent(in), optional :: convention
     character(*), intent(in), optional :: purpose
     logical, intent(in), optional :: singleFile
     logical , intent(in), optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in), optional :: status
     integer, intent(in), optional :: timeslice
     type(ESMF_IOFmt_Flag), intent(in), optional :: iofmt
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write the Fields into a file. For this API to be functional,
   the environment variable <TT>ESMF_PIO</TT> should be set to either "internal" or "external"
   when the ESMF library is built. Please see the section on
   Data I/O,&nbsp;<A HREF="#io:dataio">38.2</A>.

<P>
When <TT>convention</TT> and <TT>purpose</TT> arguments are specified, NetCDF dimension
   labels and variable attributes are written from each Field in the FieldBundle
   from the corresponding Attribute package. Additionally, Attributes may be
   set on the FieldBundle level under the same Attribute package. This allows
   the specification of global attributes within the file.
   As with individual Fields, the value associated with each name may be either
   a scalar character string, or a scalar or array of type integer, real, or
   double precision.

<P>
Limitations:
   
<UL>
<LI>For multi-tile Fields, all Fields in the FieldBundle must contain
   the same number of tiles.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
   
</LI>
</UL>

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
   
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the output file to which field bundle data is written.
   If the FieldBundle contains multi-tile Arrays, then fileName must contain
   exactly one instance of "*"; this is a placeholder that will be replaced
   by the tile number, with each tile being written to a separate file. (For
   example, for a fileName of "myfile*.nc", tile 1 will be written to
   "myfile1.nc", tile 2 to "myfile2.nc", etc.)
   (This handling of the fileName for multi-tile I/O is subject to change.)
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>Specifies an Attribute package associated with the FieldBundle, and the
   contained Fields, used to create NetCDF dimension labels and attributes
   in the file. When this argument is present, the <TT>purpose</TT>
   argument must also be present. Use this argument only with a NetCDF
   I/O format. If binary format is used, ESMF will return an error code.
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>Specifies an Attribute package associated with the FieldBundle, and the
   contained Fields, used to create NetCDF dimension labels and attributes
   in the file. When this argument is present, the <TT>convention</TT>
   argument must also be present. Use this argument only with a NetCDF
   I/O format. If binary format is used, ESMF will return an error code.
   
</DD>
<DT><STRONG>[singleFile]</STRONG></DT>
<DD>A logical flag, the default is .true., i.e., all fields in the bundle
   are written in one single file. If .false., each field will be written
   in separate files; these files are numbered with the name based on the
   argument "file". That is, a set of files are named: [file_name]001,
   [file_name]002, [file_name]003,...
   
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing field data may
   <EM>not</EM> be overwritten. If .true., only the
   data corresponding to the fields name will be
   be overwritten. If the <TT>timeslice</TT> option is given, only data for
   the given timeslice will be overwritten.
   Note that it is always an error to attempt to overwrite a NetCDF
   variable with data which has a different shape.

</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Please see Section&nbsp;<A HREF="node9.html#const:filestatusflag">54.21</A> for
   the list of options. If not present, defaults to
   <TT>ESMF_FILESTATUS_UNKNOWN</TT>.

</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Some I/O formats (e.g. NetCDF) support the output of data in form of
   time slices. The <TT>timeslice</TT> argument provides access to this
   capability. <TT>timeslice</TT> must be positive. The behavior of this
   option may depend on the setting of the <TT>overwrite</TT> flag:
   <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
   less than the maximum time already in the file, the write will fail.
   
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
   
</DD>
</DL>
   By default, i.e. by omitting the <TT>timeslice</TT> argument, no
   provisions for time slicing are made in the output file,
   however, if the file already contains a time axis for the variable,
   a timeslice one greater than the maximum will be written.

</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format. Please see Section&nbsp;<A HREF="node9.html#opt:iofmtflag">54.28</A> for the list
   of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<H1><A NAME="SECTION05030000000000000000">
<SPAN CLASS="arabic">26</SPAN> Field Class</A>
</H1>

<H2><A NAME="SECTION05031000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
An ESMF Field represents a physical field, such as temperature.
The motivation for including Fields in ESMF is that bundles of 
Fields are the entities that are normally exchanged when coupling
Components.  

<P>
The ESMF Field class contains distributed and discretized field data, a reference 
to its associated grid, and metadata.  The Field class stores the grid <I>staggering</I>
for that physical field.
This is the relationship of how the data array of a field maps onto a grid 
(e.g. one item per
cell located at the cell center, one item per cell located at the NW
corner,  one item per cell vertex, etc.).  This means that different Fields
which are on the same underlying ESMF Grid but have different
staggerings can share the same Grid object without needing to replicate
it multiple times. 

<P>
Fields can be added to States for use in inter-Component
data communications.  Fields can also be added to FieldBundles,
which are groups of Fields on the same underlying Grid.  
One motivation for packing Fields into FieldBundles is convenience; 
another is the ability to perform optimized collective data transfers.  

<P>
Field communication capabilities include: data redistribution, regridding, scatter,
gather, sparse-matrix multiplication, and halo update.  These are discussed
in more detail in the documentation for the specific method calls.  
ESMF does not currently support vector fields, so the components of 
a vector field must be stored as separate Field objects.  

<P>

<H3><A NAME="SECTION05031100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Operations</A>
</H3>

<P>
The Field class allows the user to easily perform a number of operations on 
the data stored in a Field. This section gives a brief summary of the different types of operations
and the range of their capabilities. The operations covered here are: redistribution (<TT>ESMF_FieldRedistStore()</TT>), sparse matrix multiply (<TT>ESMF_FieldSMMStore()</TT>), and regridding (<TT>ESMF_FieldRegridStore()</TT>).

<P>
The redistribution operation (<TT>ESMF_FieldRedistStore()</TT>) allows the user to move data between two Fields with the same size, but different 
distribution. This operation is useful, for example, to move data between two components with different distributions. 
Please see Section&nbsp;<A HREF="#sec:field:usage:redist_1dptr">26.3.30</A> for an example of the redistribution capability.

<P>
The sparse matrix multiplication operation (<TT>ESMF_FieldSMMStore()</TT>) allows the user to multiply the data in a Field by a sparse matrix. This operation is useful, for example, if the user has an interpolation matrix and wants to apply it to the data in a Field. Please see Section&nbsp;<A HREF="#sec:field:usage:smm_1dptr">26.3.33</A>
for an example of the sparse matrix multiply capability.

<P>
The regridding operation (<TT>ESMF_FieldRegridStore()</TT>) allows the user to move data from one grid to another while maintaining certain properties
of the data. Regridding is also called interpolation or remapping. In the Field regridding operation the grids the data is being moved between
are the grids associated with the Fields storing the data. The regridding operation works on Fields built on Meshes, Grids, or Location Streams.  
There are six regridding methods available: bilinear, higher-order patch, two types of nearest neighbor, first-order conservative, and second-order conservative.
Please see section&nbsp;<A HREF="#sec:regrid">24.2</A> for a more indepth description of regridding including in which situations each method is supported. 
Please see section&nbsp;<A HREF="#sec:fieldregrid">26.3.25</A> for a description of the regridding capability as it applies to Fields. Several sections following section&nbsp;<A HREF="#sec:fieldregrid">26.3.25</A> 
contain examples of using regridding. 

<P>

<H2><A NAME="SECTION05032000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05032100000000000000"></A>
<A NAME="const:fieldstatus"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_FIELDSTATUS
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>  

An ESMF_Field can be in different status after initialization. Field status can be queried using <TT>ESMF_FieldGet()</TT> method.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_FieldStatus_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_FIELDSTATUS_EMPTY</STRONG></DT>
<DD>Field is empty without geombase or data storage. Such a Field can be added to a <TT>ESMF_State</TT> and participate <TT>ESMF_StateReconcile()</TT>. 
</DD>
<DT><STRONG>ESMF_FIELDSTATUS_GRIDSET</STRONG></DT>
<DD>Field is partially created. It has a geombase object internally created and the geombase object associates with either a <TT>ESMF_Grid</TT>, or a <TT>ESMF_Mesh</TT>, or an <TT>ESMF_XGrid</TT>, or a <TT>ESMF_LocStream</TT>. It's an error to set another geombase object in such a Field. It can also be added to a <TT>ESMF_State</TT> and participate <TT>ESMF_StateReconcile()</TT>.
</DD>
<DT><STRONG>ESMF_FIELDSTATUS_COMPLETE</STRONG></DT>
<DD>Field is completely created with geombase and data storage internally allocated. 
</DD>
</DL>

<H2><A NAME="SECTION05033000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
A Field serves as an annotator of data, since it carries 
a description of the grid it is associated with and metadata 
such as name and units.  Fields can be used in this capacity
alone, as convenient, descriptive containers into which arrays 
can be placed and retrieved.  However, for most codes the primary 
use of Fields is in the context of import and export States,
which are the objects that carry coupling information between 
Components.  Fields enable data to be self-describing, and a
State holding ESMF Fields contains data in a standard format
that can be queried and manipulated.  

<P>
The sections below go into more detail about Field usage.

<P>

<H3><A NAME="SECTION05033100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field create and destroy</A>
</H3>

<P>
Fields can be created and destroyed at any time during 
application execution.  However, these Field methods require 
some time to complete.  We do not recommend that the user
create or destroy Fields inside performance-critical 
computational loops.

<P>
All versions of the <TT>ESMF_FieldCreate()</TT> 
routines require a Grid object as input, or require a Grid
be added before most operations involving Fields can be performed.
The Grid contains the information needed to know which 
Decomposition Elements (DEs) are participating in 
the processing of this Field, and which subsets of the data
are local to a particular DE.

<P>
The details of how the create process happens depend
on which of the variants of the <TT>ESMF_FieldCreate()</TT> 
call is used.  Some of the variants are discussed below.

<P>
There are versions of the <TT>ESMF_FieldCreate()</TT> interface
which create the Field based on the input Grid.  The ESMF
can allocate the proper amount of 
space but not assign initial values.  The user code
can then get the pointer to the uninitialized buffer and 
set the initial data values.

<P>
Other versions of the <TT>ESMF_FieldCreate()</TT> interface
allow user code to attach arrays that have already been
allocated by the user.  Empty Fields can also be created in
which case the data can be added at some later time.

<P>
For versions of Create which do not specify data values,
user code can create an ArraySpec object, which
contains information about the typekind and rank of the
data values in the array.  Then at Field create time, the
appropriate amount of memory is allocated to contain the
data which is local to each DE.

<P>
When finished with a <TT>ESMF_Field</TT>, the <TT>ESMF_FieldDestroy</TT> method
removes it.  However, the objects inside the <TT>ESMF_Field</TT>
created externally should be destroyed separately, 
since objects can be added to
more than one <TT>ESMF_Field</TT>.  For example, the same <TT>ESMF_Grid</TT>
can be referenced by multiple <TT>ESMF_Field</TT>s.  In this case the
internal Grid is not deleted by the <TT>ESMF_FieldDestroy</TT> call.

<P>

<P>

<P>

<H3><A NAME="SECTION05033200000000000000"></A>
  <A NAME="sec:field:usage:field_get_dataptr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Get Fortran data pointer, bounds, and counts information from a Field
</H3>

<P>
A user can get bounds and counts information from an <TT>ESMF_Field</TT>
    through the <TT>ESMF_FieldGet()</TT> interface.  Also available through this interface
    is the intrinsic
    Fortran data pointer contained in the internal <TT>ESMF_Array</TT> object
    of an <TT>ESMF_Field</TT>. The bounds and counts information are DE specific
    for the associated Fortran data pointer.

<P>
For a better discussion of the terminologies, bounds and widths in ESMF
    e.g. exclusive, computational, total bounds
    for the lower and upper corner of data region, etc.., user can refer to
    the explanation of these concepts for Grid and Array in their respective sections
    in the <I>Reference Manual</I>, e.g. Section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> on Array
    and Section <A HREF="#sec:grid:usage:bounds">31.3.19</A> on Grid.

<P>
In this example, we first create a 3D Field based on a 3D Grid and Array.
    Then we use the <TT>ESMF_FieldGet()</TT> interface to retrieve the data pointer,
    potentially updating or verifying its values. We also retrieve the bounds and counts
    information of the 3D Field to assist in data element iteration.
  
<P>
<PRE>
    xdim = 180
    ydim = 90
    zdim = 50

    ! create a 3D data Field from a Grid and Array.
    ! first create a Grid
    grid3d = ESMF_GridCreateNoPeriDim(minIndex=(/1,1,1/), &amp;
            maxIndex=(/xdim,ydim,zdim/), &amp;
            regDecomp=(/2,2,1/), name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_GridGet(grid=grid3d, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
           distgrid=distgrid3d, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_GridGetFieldBounds(grid=grid3d, localDe=0, &amp;
        staggerloc=ESMF_STAGGERLOC_CENTER, totalCount=fa_shape, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    allocate(farray(fa_shape(1), fa_shape(2), fa_shape(3)) )

    ! create an Array
    array3d = ESMF_ArrayCreate(distgrid3d, farray, &amp;
        indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create a Field
    field = ESMF_FieldCreate(grid=grid3d, array=array3d, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! retrieve the Fortran data pointer from the Field
    call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farray1, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! retrieve the Fortran data pointer from the Field and bounds
    call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farray1, &amp;
        computationalLBound=compLBnd, computationalUBound=compUBnd, &amp;
        exclusiveLBound=exclLBnd, exclusiveUBound=exclUBnd, &amp;
        totalLBound=totalLBnd, totalUBound=totalUBnd, &amp;
        computationalCount=comp_count, &amp;
        exclusiveCount=excl_count, &amp;
        totalCount=total_count, &amp;
        rc=rc)


    ! iterate through the total bounds of the field data pointer
    do k = totalLBnd(3), totalUBnd(3)
        do j = totalLBnd(2), totalUBnd(2)
            do i = totalLBnd(1), totalUBnd(1)
                farray1(i, j, k) = sin(2*i/total_count(1)*PI) + &amp;
                    sin(4*j/total_count(2)*PI) + &amp;
                    sin(8*k/total_count(2)*PI)
            enddo
        enddo
    enddo
</PRE>

<P>

<H3><A NAME="SECTION05033300000000000000"></A>
  <A NAME="sec:field:usage:field_get_default"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Get Grid, Array, and other information from a Field
</H3>

<P>
A user can get the internal <TT>ESMF_Grid</TT> and <TT>ESMF_Array</TT>
    from a <TT>ESMF_Field</TT>.  Note that the user should not issue any destroy command
    on the retrieved grid or array object since they are referenced
    from within the <TT>ESMF_Field</TT>. The retrieved objects should be used
    in a read-only fashion to query additional information not directly
    available through the <TT>ESMF_FieldGet()</TT> interface.
  
<P>
<PRE>
    call ESMF_FieldGet(field, grid=grid, array=array, &amp;
        typekind=typekind, dimCount=dimCount, staggerloc=staggerloc, &amp;
        gridToFieldMap=gridToFieldMap, &amp;
        ungriddedLBound=ungriddedLBound, ungriddedUBound=ungriddedUBound, &amp;
        totalLWidth=totalLWidth, totalUWidth=totalUWidth, &amp;
        name=name, &amp;
        rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05033400000000000000"></A>
  <A NAME="sec:field:usage:create_grid_tkr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Create a Field with a Grid, typekind, and rank
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> from an <TT>ESMF_Grid</TT> and
    typekind/rank.
    This create method associates the two objects.

<P>
We first create a Grid with a regular distribution that is
    10x20 index in 2x2 DEs.  This version of Field create simply
    associates the data with the Grid.  The data is referenced
    explicitly on a regular 2x2 uniform grid.
    Finally we create a Field from
    the Grid, typekind, rank, and a user specified StaggerLoc.

<P>
This example also illustrates a typical use of this Field creation
    method. By creating a Field from a Grid and typekind/rank, the
    user allows the ESMF library to create a internal Array in the Field.
    Then the user can use <TT>ESMF_FieldGet()</TT> to retrieve the Fortran
    data array
    and necessary bounds information to assign initial values to it.
<P>
<PRE>
    ! create a grid
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create a Field from the Grid and arrayspec
    field1 = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_R4, &amp;
        indexflag=ESMF_INDEX_DELOCAL, &amp;
        staggerloc=ESMF_STAGGERLOC_CENTER, name="pressure", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_FieldGet(field1, localDe=0, farrayPtr=farray2dd, &amp;
        totalLBound=ftlb, totalUBound=ftub, totalCount=ftc, rc=rc)

    do i = ftlb(1), ftub(1)
        do j = ftlb(2), ftub(2)
            farray2dd(i, j) = sin(i/ftc(1)*PI) * cos(j/ftc(2)*PI)
        enddo
    enddo

    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION05033500000000000000"></A>
  <A NAME="sec:field:usage:create_grid_arrayspec"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Create a Field with a Grid and Arrayspec
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> from an <TT>ESMF_Grid</TT> and a
    <TT>ESMF_Arrayspec</TT> with corresponding rank and type.
    This create method associates the two objects.

<P>
We first create a Grid with a regular distribution that is
    10x20 index in 2x2 DEs.  This version of Field create simply
    associates the data with the Grid.  The data is referenced
    explicitly on a regular 2x2 uniform grid.
    Then we create an ArraySpec.  Finally we create a Field from
    the Grid, ArraySpec, and a user specified StaggerLoc.

<P>
This example also illustrates a typical use of this Field creation
    method. By creating a Field from a Grid and an ArraySpec, the
    user allows the ESMF library to create a internal Array in the Field.
    Then the user can use <TT>ESMF_FieldGet()</TT> to retrieve the Fortran
    data array
    and necessary bounds information to assign initial values to it.
<P>
<PRE>
    ! create a grid
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! setup arrayspec
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create a Field from the Grid and arrayspec
    field1 = ESMF_FieldCreate(grid, arrayspec, &amp;
         indexflag=ESMF_INDEX_DELOCAL, &amp;
         staggerloc=ESMF_STAGGERLOC_CENTER, name="pressure", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_FieldGet(field1, localDe=0, farrayPtr=farray2dd, &amp;
        totalLBound=ftlb, totalUBound=ftub, totalCount=ftc, rc=rc)

    do i = ftlb(1), ftub(1)
        do j = ftlb(2), ftub(2)
            farray2dd(i, j) = sin(i/ftc(1)*PI) * cos(j/ftc(2)*PI)
        enddo
    enddo

    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
A user can also create an ArraySpec that has a different rank
     from the Grid, For example, the following code shows creation of
     of 3D Field from a 2D Grid using a 3D ArraySpec.

<P>
This example also demonstrates the technique to create a typical
     3D data Field that has 2 gridded dimensions and 1 ungridded
     dimension.

<P>
First we create a 2D grid with an index space of 180x360 equivalent to
     180x360 Grid cells (note that for a distributed memory computer, this
     means each
     grid cell will be on a separate PE!). In the FieldCreate call, we use gridToFieldMap
     to indicate the mapping between Grid dimension and Field dimension.
     For the ungridded dimension (typically the altitude), we use
     ungriddedLBound and ungriddedUBound to describe its bounds. Internally
     the ungridded dimension has a stride of 1, so the number of elements
     of the ungridded dimension is ungriddedUBound - ungriddedLBound + 1.

<P>
Note that gridToFieldMap in this specific example is (/1,2/) which
     is the default value
     so the user can neglect this argument for the FieldCreate call.
<P>
<PRE>
    grid2d = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), &amp;
          maxIndex=(/180,360/), regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_ArraySpecSet(arrayspec, 3, ESMF_TYPEKIND_R4, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    field1 = ESMF_FieldCreate(grid2d, arrayspec, &amp;
         indexflag=ESMF_INDEX_DELOCAL, &amp;
         staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
         gridToFieldMap=(/1,2/), &amp;
         ungriddedLBound=(/1/), ungriddedUBound=(/50/), &amp;
         name="pressure", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION05033600000000000000"></A>
  <A NAME="sec:field:usage:create_grid_array"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create a Field with a Grid and Array
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> from an <TT>ESMF_Grid</TT> and a
    <TT>ESMF_Array</TT>. The Grid was created in the previous example.

<P>
This example creates a 2D <TT>ESMF_Field</TT> from a 2D <TT>ESMF_Grid</TT>
    and a 2D <TT>ESMF_Array</TT>.
<P>
<PRE>
    ! Get necessary information from the Grid
    call ESMF_GridGet(grid, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
        distgrid=distgrid, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Create a 2D ESMF_TYPEKIND_R4 arrayspec
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Create a ESMF_Array from the arrayspec and distgrid
    array2d = ESMF_ArrayCreate(arrayspec=arrayspec, &amp;
            distgrid=distgrid, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Create a ESMF_Field from the grid and array
    field4 = ESMF_FieldCreate(grid, array2d, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION05033700000000000000"></A>
  <A NAME="sec:field:usage:partial_creation"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Create an empty Field and complete it
   with FieldEmptySet and FieldEmptyComplete
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> in three steps: first create an empty
    <TT>ESMF_Field</TT>; then set a <TT>ESMF_Grid</TT> on the empty <TT>ESMF_Field</TT>;
    and finally complete the <TT>ESMF_Field</TT> by calling <TT>ESMF_FieldEmptyComplete</TT>.
  
<P>
<PRE>
    ! create an empty Field
    field3 = ESMF_FieldEmptyCreate(name="precip", rc=rc)
</PRE>

<P>
<PRE>
    ! use FieldGet to retrieve the Field Status
    call ESMF_FieldGet(field3, status=fstatus, rc=rc)
</PRE>

<P>
Once the Field is created, we can verify that the status of the Field
    is <TT>ESMF_FIELDSTATUS_EMPTY</TT>.
<P>
<PRE>
    ! Test the status of the Field
    if (fstatus /= ESMF_FIELDSTATUS_EMPTY) then
         call ESMF_Finalize(endflag=ESMF_END_ABORT)
    endif
</PRE>

<P>
Next we set a Grid on the empty Field. We use the 2D grid created in
    a previous example simply to demonstrate the method. The Field data points
    will be on east edge of the Grid cells with the specified
    <TT>ESMF_STAGGERLOC_EDGE1</TT>.
<P>
<PRE>
    ! Set a grid on the Field
    call ESMF_FieldEmptySet(field3, grid2d, &amp;
             staggerloc=ESMF_STAGGERLOC_EDGE1, rc=rc)
</PRE>

<P>
<PRE>
    ! use FieldGet to retrieve the Field Status again
    call ESMF_FieldGet(field3, status=fstatus, rc=rc)
</PRE>

<P>
<PRE>
    ! Test the status of the Field
    if (fstatus /= ESMF_FIELDSTATUS_GRIDSET) then
         call ESMF_Finalize(endflag=ESMF_END_ABORT)
    endif
</PRE>

<P>
The partially created Field is completed by specifying the typekind of its
     data storage. This method is overloaded with one of the
     following parameters, arrayspec, typekind, Fortran array, or Fortran array pointer.
     Additional optional arguments can be used to specify ungridded dimensions and
     halo regions similar to the other Field creation methods.
<P>
<PRE>
    ! Complete the Field by specifying the data typekind
    ! to be allocated internally.
    call ESMF_FieldEmptyComplete(field3, typekind=ESMF_TYPEKIND_R8, &amp;
      ungriddedLBound=(/1/), ungriddedUBound=(/5/), rc=rc)
</PRE>

<P>
<PRE>
    ! use FieldGet to retrieve the Field Status again
    call ESMF_FieldGet(field3, status=fstatus, rc=rc)
</PRE>

<P>
<PRE>
    ! Test the status of the Field
    if (fstatus /= ESMF_FIELDSTATUS_COMPLETE) then
         call ESMF_Finalize(endflag=ESMF_END_ABORT)
    endif
</PRE>

<P>

<H3><A NAME="SECTION05033800000000000000"></A>
  <A NAME="sec:field:usage:create_empty"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Create an empty Field and complete it with FieldEmptyComplete
</H3>

<P>
A user can create an empty <TT>ESMF_Field</TT>.
    Then the user can finalize the empty <TT>ESMF_Field</TT> from a <TT>ESMF_Grid</TT>
    and an intrinsic
    Fortran data array. This interface is overloaded for typekind and rank
    of the Fortran data array.

<P>
In this example, both the grid and the Fortran array pointer are 2 dimensional
    and each dimension of the grid is mapped to the corresponding dimension of the
    Fortran array pointer, i.e. 1st dimension of grid maps to 1st dimension of
    Fortran array pointer, 2nd dimension of grid maps to 2nd dimension of
    Fortran array pointer, so on and so forth.

<P>
In order to create or complete a Field from a Grid and a Fortran array pointer,
    certain rules of the Fortran array bounds must be obeyed. We will discuss these
    rules as we progress in Field creation examples.  We will make
    frequent reference to the terminologies for bounds and widths in ESMF.
    For a better discussion of
    these terminologies and concepts behind them,
    e.g. exclusive, computational, total bounds
    for the lower and upper corner of data region, etc.., users can refer to
    the explanation of these concepts for Grid and Array in their respective sections
    in the <I>Reference Manual</I>, e.g. Section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> on Array
    and Section <A HREF="#sec:grid:usage:bounds">31.3.19</A> on Grid.
    The examples here are designed to help a user to get up to speed with
    creating Fields for typical use.

<P>
This example introduces a helper method, the <TT>ESMF_GridGetFieldBounds</TT>
    interface that facilitates the computation of Fortran data array bounds
    and shape to assist <TT>ESMF_FieldEmptyComplete</TT> finalizing a Field from an
    intrinsic Fortran data array and a Grid.
  
<P>
<PRE>
    ! create an empty Field
    field3 = ESMF_FieldEmptyCreate(name="precip", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! use FieldGet to retrieve total counts
    call ESMF_GridGetFieldBounds(grid2d, localDe=0, &amp;
        staggerloc=ESMF_STAGGERLOC_CENTER, totalCount=ftc, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! allocate the 2d Fortran array based on retrieved total counts
    allocate(farray2d(ftc(1), ftc(2)))

    ! finalize the Field
    call ESMF_FieldEmptyComplete(field3, grid2d, farray2d, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05033900000000000000"></A>
  <A NAME="sec:field:usage:create_5dgrid_7dptr_2dungridded"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Create a 7D Field with a 5D Grid and 2D ungridded bounds
   from a Fortran data array
</H3>

<P>
In this example, we will show how to create a 7D Field from a 5D <TT>   ESMF_Grid</TT> and 2D ungridded bounds with arbitrary halo widths and
   gridToFieldMap.

<P>
We first create a 5D DistGrid and a 5D Grid based on the DistGrid; then
   <TT>ESMF_GridGetFieldBounds</TT> computes the shape of a 7D array in fsize. We can then
   create a 7D Field from the 5D Grid and the 7D Fortran data array with
   other assimilating parameters.
<P>
<PRE>
    ! create a 5d distgrid
    distgrid5d = ESMF_DistGridCreate(minIndex=(/1,1,1,1,1/), &amp;
        maxIndex=(/10,4,10,4,6/), regDecomp=(/2,1,2,1,1/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Create a 5d Grid
    grid5d = ESMF_GridCreate(distgrid=distgrid5d, name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! use FieldGet to retrieve total counts
    call ESMF_GridGetFieldBounds(grid5d, localDe=0, ungriddedLBound=(/1,2/), &amp;
        ungriddedUBound=(/4,5/), &amp;
        totalLWidth=(/1,1,1,2,2/), totalUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        totalCount=fsize, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! allocate the 7d Fortran array based on retrieved total counts
    allocate(farray7d(fsize(1), fsize(2), fsize(3), fsize(4), fsize(5), &amp;
                        fsize(6), fsize(7)))

    ! create the Field
    field7d = ESMF_FieldCreate(grid5d, farray7d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/1,2/), ungriddedUBound=(/4,5/), &amp;
        totalLWidth=(/1,1,1,2,2/), totalUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
A user can allocate the Fortran array in a different manner using the lower and
    upper bounds returned from FieldGet through the optional totalLBound and totalUBound
    arguments. In the following example, we create another 7D Field by retrieving the bounds
    and allocate the Fortran array with this approach. In this scheme, indexing the
    Fortran array is sometimes more convenient than using the shape directly.
<P>
<PRE>
    call ESMF_GridGetFieldBounds(grid5d, localDe=0, ungriddedLBound=(/1,2/), &amp;
        ungriddedUBound=(/4,5/), &amp;
        totalLWidth=(/1,1,1,2,2/), totalUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        totalLBound=flbound, totalUBound=fubound, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    allocate(farray7d2(flbound(1):fubound(1), flbound(2):fubound(2), &amp;
                       flbound(3):fubound(3), flbound(4):fubound(4), &amp;
                       flbound(5):fubound(5), flbound(6):fubound(6), &amp;
                       flbound(7):fubound(7)) )

    field7d2 = ESMF_FieldCreate(grid5d, farray7d2, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/1,2/), ungriddedUBound=(/4,5/), &amp;
        totalLWidth=(/1,1,1,2,2/), totalUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050331000000000000000"></A>
   <A NAME="Field_shared_memory_features"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Shared memory features: DE pinning, sharing, and migration
</H3>

<P>
See <A HREF="#Array_shared_memory_features">28.2.13</A> for a introduction of the DE pinning feature.
   Here we focus on demonstrating the use of the DE pinning feature in the context of
   ESMF Field.

<P>
When an ESMF Field object is created, the specified underlying DistGrid indicates how
   many Decomposition Elements (DEs) are created. Each DE has its own memory
   allocation to hold user data. The DELayout, referenced by the DistGrid,
   determines which PET is considered the <EM>owner</EM> of each of the DEs. Queried
   for the local DEs, the Field object returns the list of DEs that are owned by
   the local PET making the query.

<P>
By default DEs are <EM>pinned</EM> to the PETs under which they were created.
   The memory allocation associated with a specific DE is only defined in the
   VAS of the PET to which the DE is pinned. As a consequence, only the PET
   owning a DE has access to its memory allocation.

<P>
On shared memory systems, however, ESMF allows DEs to be pinned to SSIs
   instead of PETs. In this case the PET under which a DE was created is still
   consider the owner, but now <EM>all</EM> PETs under the same SSI have access to
   the DE. For this the memory allocation associated with the DE is mapped into
   the VAS of all the PETs under the SSI.

<P>
To create an Field with each DE pinned to SSI instead of PET, first query the
   VM for the available level of support.
<P>
<PRE>
  call ESMF_VMGet(vm, ssiSharedMemoryEnabledFlag=ssiSharedMemoryEnabled, rc=rc)
</PRE>

<P>
<PRE>
  if (ssiSharedMemoryEnabled) then
</PRE>

<P>
Knowing that the SSI shared memory feature is available, it is now possible
   to create an Field object with DE to SSI pinning.
<P>
<PRE>
    grid = ESMF_GridCreateNoPeriDim(maxIndex=(/40,10/), regDecomp=(/4,1/), &amp;
      coordSys = ESMF_COORDSYS_CART, &amp;
      rc=rc)
</PRE>

<P>
<PRE>
    field = ESMF_FieldCreate(typekind=ESMF_TYPEKIND_R8, grid=grid, &amp;
      pinflag=ESMF_PIN_DE_TO_SSI, rc=rc)
</PRE>

<P>
Just as in the cases discussed before, where the same Grid was used, a
   default DELayout with as many DEs as PETs in the VM is constructed. Setting
   the <TT>pinflag</TT> to <TT>ESMF_PIN_DE_TO_SSI</TT> does not change the
   fact that each PET owns exactly one of the DEs. However, assuming that this
   code is run on a set of PETs that are all located under the same SSI, every
   PET now has <EM>access</EM> to all of the DEs. The situation can be observed by
   querying for both the <TT>localDeCount</TT>, and the <TT>ssiLocalDeCount</TT>.
<P>
<PRE>
    call ESMF_FieldGet(field, localDeCount=localDeCount, &amp;
      ssiLocalDeCount=ssiLocalDeCount, rc=rc)
</PRE>

<P>
Assuming execution on 4 PETs, all located on the same SSI, the values of the
   returned variable are <TT>localDeCount==1</TT> and <TT>ssiLocalDeCount==4</TT> on 
   all of the PETs. The mapping between each PET's local DE, and the global DE
   index is provided through the <TT>localDeToDeMap</TT> array argument. The amount
   of mapping information returned is dependent on how large <TT>localDeToDeMap</TT>
   has been sized by the user. For <TT>size(localDeToDeMap)==localDeCount</TT>,
   only mapping information for those DEs <EM>owned</EM> by the local PET is filled
   in. However for <TT>size(localDeToDeMap)==ssiLocalDeCount</TT>, mapping
   information for all locally <EM>accessible</EM> DEs is returned, including
   those owned by other PETs on the same SSI.
   
<P>
<PRE>
    allocate(localDeToDeMap(0:ssiLocalDeCount-1))
    call ESMF_FieldGet(field, localDeToDeMap=localDeToDeMap, rc=rc)
</PRE>

<P>
The first <TT>localDeCount</TT> entries of <TT>localDeToDeMap</TT> are always the
   global DE indices of the DEs <EM>owned</EM> by the local PET. The remaining 
   <TT>ssiLocalDeCount</TT>-<TT>localDeCount</TT> entries are the global DE indices of
   DEs <EM>shared</EM> by other PETs. The ordering of the shared DEs is from
   smallest to greatest, excluding the locally owned DEs, which were already
   listed at the beginning of <TT>localDeToDeMap</TT>. For the current case, again
   assuming execution on 4 PETs all located on the same SSI, we expect the
   following situation:

<P>
PET 0: <TT>localDeToDeMap</TT>==<TT>(/0,1,2,3/)</TT>
<BR>
PET 1: <TT>localDeToDeMap</TT>==<TT>(/1,0,2,3/)</TT>
<BR>
PET 2: <TT>localDeToDeMap</TT>==<TT>(/2,0,1,3/)</TT>
<BR>
PET 3: <TT>localDeToDeMap</TT>==<TT>(/3,0,1,2/)</TT>
<BR>

<P>
Each PET can access the memory allocations associated with <EM>all</EM> of the
   DEs listed in the <TT>localDeToDeMap</TT> returned by the Field object. Direct
   access to the Fortran array pointer of a specific memory allocation is
   available through <TT>ESMF_FieldGet()</TT>. Here each PET queries for the
   <TT>farrayPtr</TT> of <TT>localDe==2</TT>, i.e. the 2nd shared DE.
<P>
<PRE>
    call ESMF_FieldGet(field, farrayPtr=myFarray, localDe=2, rc=rc)
</PRE>

<P>
Now variable <TT>myFarray</TT> on PETs 0 and 1 both point to the <EM>same</EM>
   memory allocation for global DE 2. Both PETs have access to the same
   piece of shared memory! The same is true for PETs 2 and 3, pointing to the
   shared memory allocation of global DE 1.

<P>
It is important to note that all of the typical considerations surrounding
   shared memory programming apply when accessing shared DEs! Proper
   synchronization between PETs accessing shared DEs is critical to avoid
   <EM>race conditions</EM>. Also performance issues like <EM>false sharing</EM>
   need to be considered for optimal use.

<P>
For a simple demonstration, PETs 0 and 2 fill the entire memory allocation of
   DE 2 and 1, respectively, to a unique value.
<P>
<PRE>
    if (localPet==0) then
      myFarray = 12345.6789d0
    else if (localPet==2) then
      myFarray = 6789.12345d0
    endif
</PRE>

<P>
Here synchronization is needed before any PETs that share access to the same
   DEs can safely access the data without race condition. The Field class provides
   a simple synchronization method that can be used.
<P>
<PRE>
    call ESMF_FieldSync(field, rc=rc) ! prevent race condition
</PRE>

<P>
Now it is safe for PETs 1 and 3 to access the shared DEs. We expect to find
   the data that was set above. For simplicity of the code only the first
   array element is inspected here.
<P>
<PRE>
    if (localPet==1) then
      if (abs(myFarray(1,1)-12345.6789d0)&gt;1.d10) print *, "bad data detected"
    else if (localPet==3) then
      if (abs(myFarray(1,1)-6789.12345d0)&gt;1.d10) print *, "bad data detected"
    endif
</PRE>

<P>
<PRE>
  endif ! ending the ssiSharedMemoryEnabled conditional
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050331100000000000000"></A>
  <A NAME="sec:field:usage:create_2darray"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Create a 2D Field with a 2D Grid and a Fortran data array
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> directly from an <TT>ESMF_Grid</TT> and an intrinsic 
    Fortran data array. This interface is overloaded for typekind and rank
    of the Fortran data array.  

<P>
In the following example, each dimension size of the Fortran array is equal to the 
    exclusive bounds of its corresponding 
    Grid dimension queried from the Grid through <TT>ESMF_GridGet()</TT> public interface.

<P>
Formally let fa_shape(i) be the shape of i-th dimension of user supplied Fortran array,
    then rule 1 states:  
    <PRE>
   
    (1) fa_shape(i) = exclusiveCount(i)         
                  i = 1...GridDimCount
</PRE>

<P>
fa_shape(i) defines the shape of i-th dimension of the Fortran array.
    ExclusiveCount are the number of data elements of i-th dimension in the exclusive region queried
    from <TT>ESMF_GridGet</TT> interface. <EM>Rule 1 assumes that the Grid and the Fortran intrinsic
    array have same number of dimensions; and optional arguments
    of FieldCreate from Fortran array are left unspecified using default setup</EM>. These assumptions 
    are true for most typical uses of FieldCreate from Fortran data array. This is the easiest way
    to create a Field from a Grid and a Fortran intrinsic data array.

<P>
Fortran array dimension sizes (called shape in most Fortran language books) are equivalent
    to the bounds and counts used in this manual.  The following equation holds: 
    <PRE>
   
    fa_shape(i) = shape(i) = counts(i) = upper_bound(i) - lower_bound(i) + 1
</PRE>

<P>
These typically mean the same concept unless specifically explained to mean something else.
    For example, ESMF uses DimCount very often to mean number of dimensions instead of its meaning
    implied in the above equation. We'll clarify the meaning of a word when ambiguity could occur.

<P>
Rule 1 is most useful for a user working with Field creation from a Grid and a Fortran
    data array in most scenarios. It extends to higher dimension count, 3D, 4D, etc...
    Typically, as the code example demonstrates, a user first creates a Grid,
    then uses <TT>ESMF_GridGet()</TT>
    to retrieve the exclusive counts.  Next the user calculates the shape
    of each Fortran array dimension according to rule 1. The Fortran data array is allocated
    and initialized based on the computed shape.  A Field can either be created in one shot or
    created empty and finished using <TT>ESMF_FieldEmptyComplete</TT>.

<P>
There are important details that can be skipped but are good to know for <TT>ESMF_FieldEmptyComplete</TT>
    and <TT>ESMF_FieldCreate</TT> from a Fortran data array. 1) these methods require <EM>each PET contains
    exactly one DE</EM>. This implies that a code using FieldCreate from a data array or FieldEmptyComplete must
    have the same number of DEs and PETs, formally <!-- MATH
 $n_{DE} = n_{PET}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="96" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.png"
 ALT="$n_{DE} = n_{PET}$"></SPAN>. Violation of this condition
    will cause run time failures. 2) the bounds and counts retrieved from GridGet are DE specific
    or equivalently PET specific, which means that <EM>the Fortran array shape could be different from one
    PET to another</EM>. 
    
    
<P>
<PRE>
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_GridGet(grid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
        exclusiveCount=gec, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    allocate(farray(gec(1), gec(2)) )

    field = ESMF_FieldCreate(grid, farray, ESMF_INDEX_DELOCAL, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050331200000000000000"></A>
  <A NAME="sec:field:usage:create_2dptr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Create a 2D Field with a 2D Grid and a Fortran data pointer
</H3>

<P>
The setup of this example is similar to the previous section except 
   that the Field is created from a data pointer instead of a data array.
   We highlight the ability to deallocate the internal Fortran data
   pointer queried from the Field. This gives a user more flexibility with
   memory management.
  
<P>
<PRE>
    allocate(farrayPtr(gec(1), gec(2)) )

    field = ESMF_FieldCreate(grid, farrayPtr, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    call ESMF_FieldGet(field, farrayPtr=farrayPtr2, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    ! deallocate the retrieved Fortran array pointer
    deallocate(farrayPtr2)
</PRE>

<P>

<H3><A NAME="SECTION050331300000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> Create a 3D Field with a 2D Grid and a 3D Fortran data array
</H3>

<P>
This example demonstrates a typical use of <TT>ESMF_Field</TT> combining
    a 2D grid and a 3D Fortran native data array. One immediate problem follows: 
    how does one define the bounds of the ungridded dimension? This is
    solved by the optional arguments <TT>ungriddedLBound</TT> and <TT>ungriddedUBound</TT>
    of the <TT>ESMF_FieldCreate</TT> interface. By definition, <TT>ungriddedLBound</TT>
    and <TT>ungriddedUBound</TT>
    are both 1 dimensional integer Fortran arrays.

<P>
Formally, let fa_shape(j=1...FieldDimCount-GridDimCount) be the shape of the
    ungridded dimensions of a Field relative to the Grid used in Field creation.
    The Field dimension count is equal to the number of dimensions of the Fortran array, which
    equals the number of dimensions of the resultant Field. GridDimCount is
    the number of dimensions of the Grid. 

<P>
fa_shape(j) is computed as:
    <PRE>
   
    fa_shape(j) = ungriddedUBound(j) - ungriddedLBound(j) + 1
</PRE>

<P>
fa_shape is easy to compute when the gridded and ungridded dimensions do not
    mix. However, it's conceivable that at higher dimension count, gridded and ungridded
    dimensions can interleave. To aid the computation of ungridded dimension shape
    we formally introduce the mapping concept.

<P>
Let <!-- MATH
 $map_{A,B}(i=1...n_A) = i_B$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="177" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$map_{A,B}(i=1...n_A) = i_B$"></SPAN>, and <!-- MATH
 $i_B \in [\phi, 1...n_B]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="107" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="$i_B \in [\phi, 1...n_B]$"></SPAN>. <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$n_A$"></SPAN> is the number
    of elements in set A, <SPAN CLASS="MATH"><IMG
 WIDTH="25" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$n_B$"></SPAN> is the number of elements in set B. <SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img48.png"
 ALT="$map_{A,B}(i)$"></SPAN> defines
    a mapping from i-th element of set A to <SPAN CLASS="MATH"><IMG
 WIDTH="21" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img49.png"
 ALT="$i_B$"></SPAN>-th element in set B. <SPAN CLASS="MATH"><IMG
 WIDTH="51" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$i_B = \phi$"></SPAN> 
    indicates there does not exist a mapping from i-th element of set A to set B.

<P>
Suppose we have a mapping from dimension index of ungriddedLBound (or
    ungriddedUBound) to Fortran array dimension index, called ugb2fa. 
    By definition, <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$n_A$"></SPAN> equals to the dimension count of
    ungriddedLBound (or ungriddedUBound), <SPAN CLASS="MATH"><IMG
 WIDTH="25" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img47.png"
 ALT="$n_B$"></SPAN> equals to the dimension count of
    the Fortran array. We can now formulate the computation of ungridded
    dimension shape as rule 2:
    <PRE>
   
    (2) fa_shape(ugb2fa(j)) = ungriddedUBound(j) - ungriddedLBound(j) + 1 
                          j = 1..FortranArrayDimCount - GridDimCount
</PRE>

<P>
The mapping can be computed in linear time proportional to the
    Fortran array dimension count (or rank) using the following algorithm in pseudocode:
    <PRE>
  
    map_index = 1
    do i = 1, farray_rank
        if i-th dimension of farray is ungridded
            ugb2fa(map_index) = i
            map_index = map_index + 1
        endif
    enddo
</PRE>

<P>
Here we use rank and dimension count interchangeably. These 2 terminologies are typically
    equivalent. But there are subtle differences
    under certain conditions. Rank is the total number of dimensions of a tensor object.
    Dimension count allows a finer description of the heterogeneous dimensions in that object.
    For example, a Field of rank 5 can have 3 gridded dimensions and 2 ungridded dimensions.
    Rank is precisely the summation of dimension count of all types of dimensions. 

<P>
For example, if a 5D array is used with a 3D Grid, there are 2 ungridded dimensions:
    ungriddedLBound=(/1,2/) and ungriddedUBound=(/5,7/).
    Suppose the distribution of dimensions looks like (O, X, O, X, O), O means gridded,
    X means ungridded. Then the mapping from ungridded bounds to Fortran array is
    ugb2fa=(/2, 4/). The shape of 2nd and 4th dimension of Fortran array should equal
    (5, 8).

<P>
Back to our 3D Field created from a 2D Grid and 3D Fortran array example, suppose the 3rd
    Field dimension is ungridded, ungriddedLBound=(/3/), ungriddedUBound=(/9/).
    First we use rule 1 to compute shapes of the gridded Fortran array dimension,
    then we use rule 2 to compute shapes of the ungridded Fortran array dimension.
    In this example, we used the exclusive bounds obtained in the previous
    example.
<P>
<PRE>
    fa_shape(1) = gec(1) ! rule 1
    fa_shape(2) = gec(2)
    fa_shape(3) = 7 ! rule 2 9-3+1
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050331400000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr_map"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> Create a 3D Field with a 2D Grid and a 3D Fortran data array with gridToFieldMap argument
</H3>

<P>
Building upon the previous example, we will create a 3D Field from
    a 2D grid and 3D array but with a slight twist. In this example, we
    introduce the gridToFieldMap argument that allows a user to map Grid 
    dimension index to Field dimension index.

<P>
In this example, both dimensions of the Grid are distributed and the
    mapping from DistGrid to Grid is (/1,2/). We will introduce rule 3
    assuming distgridToGridMap=(/1,2,3...gridDimCount/), and distgridDimCount equals
    to gridDimCount. This is a reasonable assumption in typical Field use.

<P>
We apply the mapping gridToFieldMap on rule 1 to create rule 3:
    <PRE>
   
    (3) fa_shape(gridToFieldMap(i)) = exclusiveCount(i)        
                                  i = 1,..GridDimCount.
</PRE>

<P>
Back to our example, suppose the 2nd
    Field dimension is ungridded, ungriddedLBound=(/3/), ungriddedUBound=(/9/).
    gridToFieldMap=(/3,1/), meaning the 1st Grid dimension maps to 3rd Field dimension,
    and 2nd Grid dimension maps to 1st Field dimension.

<P>
First we use rule 3 to compute shapes of the gridded Fortran array dimension,
    then we use rule 2 to compute shapes of the ungridded Fortran array dimension.
    In this example, we use the exclusive bounds obtained in the previous
    example.
<P>
<PRE>
    gridToFieldMap2d(1) = 3
    gridToFieldMap2d(2) = 1
    do i = 1, 2
        fa_shape(gridToFieldMap2d(i)) = gec(i)
    end do
    fa_shape(2) = 7
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        gridToFieldMap=gridToFieldMap2d, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050331500000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr_map_halo"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> Create a 3D Field with a 2D Grid and a 3D Fortran data array with halos
</H3>

<P>
This example is similar to example <A HREF="#sec:field:usage:create_2dgrid_3dptr_map">26.3.14</A>.
    In addition, here we will show how
    a user can associate different halo widths to a Fortran array to create
    a Field through the totalLWidth and totalUWidth optional arguments.
    A diagram of the dimension configuration from Grid, halos, and Fortran data array
    is shown here.
  <DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:fieldparameter"></A><A NAME="24365"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 12:</STRONG>
Field dimension configuration from Grid, halos, and Fortran data array.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{FieldParameterSetup}}$
 -->
<IMG
 WIDTH="684" HEIGHT="736" ALIGN="BOTTOM" BORDER="0"
 SRC="img51.png"
 ALT="\scalebox{0.75}{\includegraphics{FieldParameterSetup}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The <TT>ESMF_FieldCreate()</TT> interface supports creating a Field from a Grid and a
    Fortran array padded with halos on the distributed dimensions of the Fortran
    array. Using this technique one can avoid passing non-contiguous Fortran array
    slice to FieldCreate. It guarantees the same exclusive region,
    and by using halos, it also defines a bigger total region to contain 
    the entire contiguous memory block of the Fortran array.

<P>
The elements of totalLWidth and totalUWidth are applied in the order
    distributed dimensions appear in the Fortran array. By definition, 
    totalLWidth and totalUWidth are 1 dimensional arrays of non-negative 
    integer values. The size of haloWidth arrays is equal to the number of distributed
    dimensions of the Fortran array, which is also equal to the number of
    distributed dimensions of the Grid used in the Field creation.

<P>
Because the order of totalWidth (representing both totalLWidth and
    totalUWidth) element is applied to the order distributed dimensions
    appear in the Fortran array dimensions, it's quite simple to compute
    the shape of distributed dimensions of the Fortran array. They are done
    in a similar manner when applying ungriddedLBound and ungriddedUBound 
    to ungridded dimensions of the Fortran array defined by rule 2.

<P>
Assume we have the mapping from the dimension index of totalWidth
    to the dimension index of Fortran array, called mhw2fa; and we also
    have the mapping from dimension index of Fortran array to dimension
    index of the Grid, called fa2g. The shape of
    distributed dimensions of a Fortran array can be computed by rule 4: 

<P>
<PRE>
  
    (4) fa_shape(mhw2fa(k)) = exclusiveCount(fa2g(mhw2fa(k)) + 
                              totalUWidth(k) + totalLWidth(k)
                          k = 1...size(totalWidth)
</PRE>

<P>
This rule may seem confusing but algorithmically the computation
    can be done by the following pseudocode:

<P>
<PRE>
  
    fa_index = 1
    do i = 1, farray_rank
       if i-th dimension of Fortran array is distributed
           fa_shape(i) = exclusiveCount(fa2g(i)) + 
                         totalUWidth(fa_index) + totalLWidth(fa_index)
           fa_index = fa_index + 1
       endif
    enddo
</PRE>

<P>
The only complication then is to figure out the mapping from Fortran
    array dimension index to Grid dimension index. This process can
    be done by computing the reverse mapping from Field to Grid.

<P>
Typically, we don't have to consider these complications if the following
    conditions are met: 1) All Grid dimensions are distributed. 2) DistGrid
    in the Grid has a dimension index mapping to the Grid in the form of 
    natural order (/1,2,3,.../). This natural order mapping is the
    default mapping between various objects throughout ESMF. 3) Grid to Field
    mapping is in the form of natural order, i.e. default mapping. These
    seem like a lot of conditions but they are the default case in the interaction
    among DistGrid, Grid, and Field. When these conditions are met, which
    is typically true, the shape of distributed dimensions of Fortran array
    follows rule 5 in a simple form:

<P>
<PRE>
  
    (5) fa_shape(k) = exclusiveCount(k) + 
                      totalUWidth(k) + totalLWidth(k) 
                  k = 1...size(totalWidth)
</PRE>

<P>
Let's examine an example on how to apply rule 5. Suppose we have a
    5D array and a 3D Grid that has its first 3 dimensions mapped to the first
    3 dimensions of the Fortran array. totalLWidth=(/1,2,3/), 
    totalUWidth=(/7,9,10/), then by rule 5, the following pseudo code
    can be used to compute the shape of the first 3 dimensions of the Fortran
    array. The shape of the remaining two ungridded dimensions can be
    computed according to rule 2.

<P>
<PRE>
  
    do k = 1, 3
        fa_shape(k) = exclusiveCount(k) + 
                      totalUWidth(k) + totalLWidth(k)) 
    enddo
</PRE>

<P>
Suppose now gridToFieldMap=(/2,3,4/) instead which says
    the first dimension of Grid maps to the 2nd dimension of Field (or 
    Fortran array) and so on and so forth, we can obtain a more general form 
    of rule 5 by introducing first_distdim_index shift when Grid to Field
    map (gridToFieldMap) is in the form of (/a,a+1,a+2.../).

<P>
<PRE>
  
    (6) fa_shape(k+first_distdim_index-1) = exclusiveCount(k) +
                                            totalUWidth(k) + totalLWidth(k)
                                        k = 1...size(totalWidth)
</PRE>

<P>
It's obvious that first_distdim_index=a. If the first dimension of the Fortran
    array is distributed, then rule 6 degenerates into rule 5, which is
    the typical case.

<P>
Back to our example creating a 3D Field from a 2D Grid and a 3D intrinsic
    Fortran array, we will use the Grid created from previous example
    that satisfies condition 1 and 2. We'll also use a simple gridToFieldMap
    (1,2) which is the default mapping that satisfies condition 3. 
    First we use rule 5 to compute
    the shape of distributed dimensions then we use rule 2 to compute the shape
    of the ungridded dimensions.
<P>
<PRE>
    gridToFieldMap2d(1) = 1
    gridToFieldMap2d(2) = 2
    totalLWidth2d(1) = 3
    totalLWidth2d(2) = 4
    totalUWidth2d(1) = 3
    totalUWidth2d(2) = 5
    do k = 1, 2
        fa_shape(k) = gec(k) + totalLWidth2d(k) + totalUWidth2d(k)
    end do
    fa_shape(3) = 7          ! 9-3+1
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        totalLWidth=totalLWidth2d, totalUWidth=totalUWidth2d, &amp;
        gridToFieldMap=gridToFieldMap2d, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050331600000000000000"></A>
  <A NAME="sec:field:usage:create_locs_tkr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">16</SPAN> Create a Field from a LocStream, typekind, and rank
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_LocStream</TT> 
   and typekind/rank.
   The location stream object is uniformly distributed
   in a 1 dimensional space on 4 DEs. The rank is 1 dimensional. 
   Please refer to LocStream examples section for more information on LocStream creation.
  
<P>
<PRE>
    locs = ESMF_LocStreamCreate(minIndex=1, maxIndex=16, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    field = ESMF_FieldCreate(locs, typekind=ESMF_TYPEKIND_I4, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050331700000000000000"></A>
  <A NAME="sec:field:usage:create_locs_arrayspec"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">17</SPAN> Create a Field from a LocStream and arrayspec
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_LocStream</TT> 
   and an <TT>ESMF_Arrayspec</TT>.
   The location stream object is uniformly distributed
   in a 1 dimensional space on 4 DEs. The arrayspec is 1 dimensional. 
   Please refer to LocStream examples section for more information on LocStream creation.
  
<P>
<PRE>
    locs = ESMF_LocStreamCreate(minIndex=1, maxIndex=16, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    field = ESMF_FieldCreate(locs, arrayspec, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050331800000000000000"></A>
  <A NAME="sec:field:usage:create_mesh_tkr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">18</SPAN> Create a Field from a Mesh, typekind, and rank
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT> 
   and typekind/rank.
   The mesh object is on a Euclidean surface that is partitioned to a 2x2 rectangular
   space with 4 elements and 9 nodes. The nodal space is represented by
   a distgrid with 9 indices. A Field is created on locally owned nodes on each PET.
   Therefore, the created Field has 9 data points globally.
   The mesh object can be represented by the picture
   below. For more information on Mesh creation, please see Section&nbsp;<A HREF="#sec:mesh:usage:meshCreation">33.3.1</A>.
   <PRE>
                Mesh Ids
  
    2.0   7 ------- 8 -------- 9
          |         |          |
          |    3    |    4     |
          |         |          |
    1.0   4 ------- 5 -------- 6
          |         |          |
          |    1    |    2     |
          |         |          |
    0.0   1 ------- 2 -------- 3
  
         0.0       1.0        2.0 
  
        Node Ids at corners
        Element Ids in centers
   
  
               Mesh Owners
  
    2.0   2 ------- 2 -------- 3
          |         |          |
          |    2    |    3     |
          |         |          |
    1.0   0 ------- 0 -------- 1
          |         |          |
          |    0    |    1     |
          |         |          |
    0.0   0 ------- 0 -------- 1
  
         0.0       1.0        2.0 
  
        Node Owners at corners
        Element Owners in centers
</PRE> 
  
<P>
<PRE>
      ! Create Mesh structure in 1 step
      mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
             nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
             nodeOwners=nodeOwners, elementIds=elemIds,&amp;
             elementTypes=elemTypes, elementConn=elemConn, &amp;
             rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

      ! Field is created on the 1 dimensional nodal distgrid. On
      ! each PET, Field is created on the locally owned nodes.
      field = ESMF_FieldCreate(mesh, typekind=ESMF_TYPEKIND_I4, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050331900000000000000"></A>
  <A NAME="sec:field:usage:create_mesh_arrayspec"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">19</SPAN> Create a Field from a Mesh and arrayspec
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT> 
   and an <TT>ESMF_Arrayspec</TT>.
   The mesh object is on a Euclidean surface that is partitioned to a 2x2 rectangular
   space with 4 elements and 9 nodes. The nodal space is represented by
   a distgrid with 9 indices. Field is created on locally owned nodes on each PET.
   Therefore, the created Field has 9 data points globally.
   The mesh object can be represented by the picture
   below. For more information on Mesh creation, please see Section&nbsp;<A HREF="#sec:mesh:usage:meshCreation">33.3.1</A>.
  
<P>
<PRE>
      ! Create Mesh structure in 1 step
      mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
             nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
             nodeOwners=nodeOwners, elementIds=elemIds,&amp;
             elementTypes=elemTypes, elementConn=elemConn, &amp;
             rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

      call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

      ! Field is created on the 1 dimensional nodal distgrid. On
      ! each PET, Field is created on the locally owned nodes.
      field = ESMF_FieldCreate(mesh, arrayspec, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050332000000000000000"></A>
  <A NAME="sec:field:usage:create_mesh_array"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">20</SPAN> Create a Field from a Mesh and an Array
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT> 
   and an <TT>ESMF_Array</TT>. The mesh object is created in the previous example and
   the array object is retrieved from the field created in the previous example too.
  
<P>
<PRE>
    call ESMF_MeshGet(mesh, nodalDistgrid=distgrid, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    array = ESMF_ArrayCreate(distgrid=distgrid, arrayspec=arrayspec, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    ! query the array from the previous example
    call ESMF_FieldGet(field, array=array, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    ! create a Field from a mesh and an array
    field1 = ESMF_FieldCreate(mesh, array, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050332100000000000000"></A>
  <A NAME="sec:field:usage:createMeshArrayspecOpt"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">21</SPAN> Create a Field from a Mesh and an ArraySpec with optional features
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT>
   and an <TT>ESMF_ArraySpec</TT>. The mesh object is created in the previous example.
   The Field is also created with optional arguments such as ungridded dimensions
   and dimension mapping.

<P>
In this example, the mesh is mapped to the 2nd dimension of the
   <TT>ESMF_Field</TT>, with its first dimension being the ungridded dimension with bounds 1,3.
  
<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_I4, rc=rc)
    field = ESMF_FieldCreate(mesh, arrayspec=arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050332200000000000000"></A>
  <A NAME="sec:field:usage:create_repdim"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">22</SPAN> Create a Field with replicated dimensions
</H3>

<P>
In this example an <TT>ESMF_Field</TT> with replicated dimension is created from an <TT>ESMF_Grid</TT> and
    an <TT>ESMF_Arrayspec</TT>. A user can also use other <TT>ESMF_FieldCreate()</TT> methods to create replicated
    dimension Field, this example illustrates the key concepts and use of a replicated dimension Field.

<P>
Normally gridToFieldMap argument in <TT>ESMF_FieldCreate()</TT> should not contain
    0 value entries. However, for a Field with replicated dimension, a 0 entry in gridToFieldMap
    indicates the corresponding Grid dimension is replicated in the Field. In such a Field,
    the rank of the Field is no longer necessarily greater than its Grid rank.
    An example will make this clear. We will start by creating Distgrid and Grid.
  
<P>
<PRE>
    ! create 4D distgrid
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1,1,1/), &amp;
        maxIndex=(/6,4,6,4/), regDecomp=(/2,1,2,1/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create 4D grid on top of the 4D distgrid
    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create 3D arrayspec
    call ESMF_ArraySpecSet(arrayspec, 3, ESMF_TYPEKIND_R8, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
In this example, a user creates a 3D Field with replicated dimension
   replicated along the 2nd and 4th dimension of its underlying 4D Grid.
   In addition, the 2nd dimension of the Field is ungridded (why?). The 1st and
   3rd dimensions of the Field have halos.
<P>
<PRE>
    ! create field, 2nd and 4th dimensions of the Grid are replicated
    field = ESMF_FieldCreate(grid, arrayspec, indexflag=ESMF_INDEX_DELOCAL, &amp;
        gridToFieldMap=(/1,0,2,0/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/4/), &amp;
        totalLWidth=(/1,1/), totalUWidth=(/4,5/), &amp;
        staggerloc=ESMF_STAGGERLOC_CORNER, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! get basic information from the field
    call ESMF_FieldGet(field, grid=grid1, array=array, typekind=typekind, &amp;
        dimCount=dimCount, staggerloc=lstaggerloc, &amp;
        gridToFieldMap=lgridToFieldMap, ungriddedLBound=lungriddedLBound, &amp;
        ungriddedUBound=lungriddedUBound, totalLWidth=ltotalLWidth, &amp;
        totalUWidth=ltotalUWidth, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! get bounds information from the field
    call ESMF_FieldGet(field, localDe=0, farrayPtr=farray, &amp;
        exclusiveLBound=felb, exclusiveUBound=feub, exclusiveCount=fec, &amp;
        computationalLBound=fclb, computationalUBound=fcub, &amp;
        computationalCount=fcc, totalLBound=ftlb, totalUBound=ftub, &amp;
        totalCount=ftc, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Next we verify that the field and array bounds agree with each other
 <PRE>
    call ESMF_ArrayGet(array, rank=arank, dimCount=adimCount, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    gridrank_repdim = 0
    do i = 1, size(gridToFieldMap)
        if(gridToFieldMap(i) == 0) gridrank_repdim = gridrank_repdim + 1
    enddo
</PRE>

<P>
Number of undistributed dimension of the array <I>X</I> is computed from
   total rank of the array <I>A</I>, the dimension count of its underlying distgrid
   <I>B</I> and number of replicated dimension in the distgrid <I>C</I>.
   We have the following formula: X = A - (B - C)
<P>
<PRE>
    allocate(audlb(arank-adimCount+gridrank_repdim), &amp;
        audub(arank-adimCount+gridrank_repdim))
    call ESMF_ArrayGet(array, exclusiveLBound=aelb, exclusiveUBound=aeub, &amp;
        computationalLBound=aclb, computationalUBound=acub, &amp;
        totalLBound=atlb, totalUBound=atub, &amp;
        undistLBound=audlb, undistUBound=audub, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! verify the ungridded bounds from field match
    ! undistributed bounds from its underlying array
    do i = 1, arank-adimCount
        if(lungriddedLBound(i) .ne. audlb(i) ) &amp;
            rc = ESMF_FAILURE
    enddo
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    do i = 1, arank-adimCount
        if(lungriddedUBound(i) .ne. audub(i) ) &amp;
            rc = ESMF_FAILURE
    enddo
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
We then verify the data in the replicated dimension Field can be updated and accessed.
<P>
<PRE>
    do ik = ftlb(3), ftub(3)
     do ij = ftlb(2), ftub(2)
      do ii = ftlb(1), ftub(1)
        farray(ii,ij,ik) = ii+ij*2+ik
      enddo
     enddo
    enddo
    ! access and verify
    call ESMF_FieldGet(field, localDe=0, farrayPtr=farray1, &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    do ik = ftlb(3), ftub(3)
     do ij = ftlb(2), ftub(2)
      do ii = ftlb(1), ftub(1)
        n = ii+ij*2+ik
        if(farray1(ii,ij,ik) .ne. n ) rc = ESMF_FAILURE
      enddo
     enddo
    enddo
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! release resources
    call ESMF_FieldDestroy(field)
    call ESMF_GridDestroy(grid)
    call ESMF_DistGridDestroy(distgrid)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050332300000000000000"></A>
  <A NAME="sec:field:usage:createArbGrid"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">23</SPAN> Create a Field on an arbitrarily distributed Grid
</H3>

<P>
With the introduction of Field on arbitrarily distributed Grid, Field has two kinds of dimension
    count: one associated geometrical (or physical) dimensionality, the other one associated with its
    memory index space representation. Field and Grid dimCount reflect the physical index 
    space of the objects. A new type of dimCount rank should be added to both of these entities.
    The rank gives the number of dimensions of the memory index space of the objects.
    This would be the dimension of the pointer pulled out of Field and the
    size of the bounds vector, for example. 

<P>
For non-arbitrary Grids rank=dimCount, but for grids and fields with
    arbitrary dimensions rank = dimCount - (number of Arb dims) + 1
    (Internally Field can use the Arb info from the grid to create the mapping
    from the Field Array to the DistGrid)

<P>
When creating a Field size(GridToFieldMap)=dimCount for both Arb and Non-arb grids
    This array specifies the mapping of Field to Grid identically for both Arb and Nonarb grids 
    If a zero occurs in an entry corresponding to any arbitrary dimension, then
    a zero must occur in every entry corresponding to an arbitrary dimension (i.e.
    all arbitrary dimensions must either be all replicated or all not replicated,
    they can't be broken apart).

<P>
In this example an <TT>ESMF_Field</TT> is created from an arbitrarily distributed <TT>ESMF_Grid</TT> and 
    an <TT>ESMF_Arrayspec</TT>. A user can also use other <TT>ESMF_FieldCreate()</TT> methods to create 
    such a Field, this example illustrates the key concepts and use of Field on arbitrary distributed Grid.

<P>
The Grid is 3 dimensional in physics index space but the first two dimension are collapsed into
    a single memory index space. Thus the resulting Field is 3D in physics index space and 2D in memory index
    space. This is made obvious with the 2D arrayspec used to create this Field.
  
<P>
<PRE>
    ! create a 3D grid with the first 2 dimensions collapsed 
    ! and arbitrarily distributed
    grid3d = ESMF_GridCreateNoPeriDim(coordTypeKind=ESMF_TYPEKIND_R8, &amp;
      minIndex=(/1,1,1/), maxIndex=(/xdim, ydim,zdim/), &amp;
      arbIndexList=localArbIndex,arbIndexCount=localArbIndexCount, &amp;
      name="arb3dgrid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create a 2D arrayspec
    call ESMF_ArraySpecSet(arrayspec2D, rank=2, typekind=ESMF_TYPEKIND_R4, &amp;
         rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create a 2D Field using the Grid and the arrayspec
    field = ESMF_FieldCreate(grid3d, arrayspec2D, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    call ESMF_FieldGet(field, rank=rank, dimCount=dimCount, &amp;
                       rc=rc)
    if (myPet .eq. 0) print *, 'Field rank, dimCount', &amp;
                                rank, dimCount
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    ! verify that the dimension counts are correct
    if (rank .ne. 2) correct = .false.
    if (dimCount .ne. 3) correct = .false.
</PRE>

<P>

<H3><A NAME="SECTION050332400000000000000"></A>
  <A NAME="sec:field:usage:createArbGridRep"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">24</SPAN> Create a Field on an arbitrarily distributed Grid with replicated dimensions &amp; ungridded bounds
</H3>

<P>
The next example is slightly more complicated in
    that the Field also contains one ungridded dimension and its gridded dimension
    is replicated on the arbitrarily distributed dimension of the Grid.

<P>
The same 3D Grid and 2D arrayspec in the previous example
    are used but a gridToFieldMap argument
    is supplied to the <TT>ESMF_FieldCreate()</TT> call. The first 2 entries of
    the map are 0, the last (3rd) entry is 1. The 3rd dimension of the Grid is
    mapped to the first dimension of the Field, this dimension is then replicated
    on the arbitrarily distributed dimensions of the Grid. In addition, the
    Field also has one ungridded dimension. Thus the final dimension count of the
    Field is 2 in both physics and memory index space.
  
<P>
<PRE>
    field = ESMF_FieldCreate(grid3d, arrayspec2D,gridToFieldMap=(/0,0,1/), &amp;
            ungriddedLBound=(/1/), ungriddedUBound=(/10/),rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    call ESMF_FieldGet(field, rank=rank, dimCount=dimCount, &amp;
                       rc=rc)
    if (myPet .eq. 0) print *, 'Field rank, dimCount', &amp;
                                rank, dimCount
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    if (rank .ne. 2) correct = .false.
    if (dimCount .ne. 2) correct = .false.
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050332500000000000000"></A><A NAME="sec:fieldregrid"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">25</SPAN> Field regridding
</H3>

<P>
This section describes the Field regrid methods. For an in depth description of ESMF regridding and the options available
   please see Section&nbsp;<A HREF="#sec:regrid">24.2</A>. 

<P>
The basic flow of ESMF Field regridding is as follows. First a source and destination geometry object are created, depending on 
   the regrid method they can be either a Grid, a Mesh, an XGrid, or a LocStream. 
   Next Fields are built on the source and destination grid objects. These Fields are then passed into <TT>ESMF_FieldRegridStore()</TT>. The user can either get a 
   sparse matrix from this call and/or a <TT>routeHandle</TT>. If the user gets the sparse matrix then they are responsible for deallocating it, but other than that
   can use it as they wish. The <TT>routeHandle</TT> can be used in the <TT>ESMF_FieldRegrid()</TT> call to perform the actual interpolation of data from the source 
   to the destination field. This interpolation can be repeated for the same set of Fields as long as the coordinates at the staggerloc involved in the
   regridding in the associated grid object don't change. The same <TT>routeHandle</TT> can also be used between any pair of Fields that matches the original 
   pari in <EM>type</EM>, <EM>kind</EM>, and memory layout of the <EM>gridded</EM> dimensions. However, the size, number, and index order of <EM>ungridded</EM> dimensions
   may be different. See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle reusability.
   However, if you want                                     
   the routehandle to be the same interpolation between the grid objects upon which the Fields are built as was calculated                                        
   with the original <TT>ESMF_FieldRegridStore()</TT> call, then there                                                                                              
   are additional constraints on the grid objects. To be the same interpolation, the grid objects upon which the                                                  
   Fields are build must contain the same coordinates at the stagger locations involved in the regridding as                                                      
   the original source and destination Fields used in the <TT>ESMF_FieldRegridStore()</TT> call.                                                                    
   The routehandle represents the interpolation between the grid objects as they were during the <TT>ESMF_FieldRegridStore()</TT> call.                             
   So if the coordinates at the stagger location in the grid objects change, a new call to <TT>ESMF_FieldRegridStore()</TT>                                         
   is necessary to compute the interpolation between that new set of coordinates. When finished with the <TT>routeHandle</TT> 
   <TT>ESMF_FieldRegridRelease()</TT> should be used to 
   free the associated memory. 

<P>
The following example demonstrates doing a regrid operation between two Fields.
  
<P>
<PRE>
  ! (Create source Grid, Mesh, XGrid, or LocStream.)
  ! (Create srcField on the above.)

  ! (Create destination Grid, Mesh, XGrid, or LocStream.)
  ! (Create dstField on the above.)
  
  ! Create the routeHandle which encodes the communication and
  ! information necessary for the regrid sparse matrix multiply.
  call ESMF_FieldRegridStore(srcField=srcField, dstField=dstField, &amp;
                             routeHandle=routeHandle, rc=localrc)
</PRE>

<P>
<PRE>
 
  ! Can loop here regridding from srcField to dstField 
  ! do i=1,....

       ! (Put data into srcField)

       ! Use the routeHandle to regrid data from srcField to dstField.
       ! As described above, the same routeHandle can be used to 
       ! regrid a large class of different source and destination Fields. 
       call ESMF_FieldRegrid(srcField, dstField, routeHandle, rc=localrc)
</PRE>

<P>
<PRE>
  !    (Use data in dstField)

  ! enddo 


  ! Free the buffers and data associated with the routeHandle. 
  call ESMF_FieldRegridRelease(routeHandle, rc=localrc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050332600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">26</SPAN> Field regrid with masking</A>
</H3>
   As before, to create the sparse matrix regrid operator we call the
   <TT>ESMF_FieldRegridStore()</TT> routine. 
   However, in this case we apply masking to the regrid operation. 
   The mask value for each index location in the Grids may be set using
   the <TT>ESMF_GridAddItem()</TT> call (see Section&nbsp;<A HREF="#sec:usage:items">31.3.17</A>
   and Section&nbsp;<A HREF="#sec:usage:items:accessing">31.3.18</A>). Mask values may be set independently 
   for the source and destination Grids. If no mask values have been set in a Grid, then it is 
   assumed no masking should be used for that Grid. The <TT>srcMaskValues</TT>
   parameter allows the user to set the list of values which indicate
   that a source location should be masked out. The <TT>dstMaskValues</TT>
   parameter allows the user to set the list of values which indicate
   that a destination location should be masked out. The absence of 
   one of these parameters indicates that no masking should be used
   for that Field (e.g no <TT>srcMaskValue</TT> parameter indicates that source
   masking shouldn't occur). The <TT>unmappedaction</TT> flag may be
   used with or without masking and indicates what should occur
   if destination points can not be mapped to a source cell. 
   Here the <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> value indicates that unmapped
   destination points are to be ignored and no sparse matrix entries should be
    generated for them. 
<P>
<PRE>
  call ESMF_FieldRegridStore(srcField=srcField, srcMaskValues=(/1/),       &amp;
                             dstField=dstField, dstMaskValues=(/1/),       &amp;
                             unmappedaction=ESMF_UNMAPPEDACTION_IGNORE, &amp;
                             routeHandle=routeHandle,                      &amp;
                             regridmethod=ESMF_REGRIDMETHOD_BILINEAR,     &amp;
                             rc=localrc)
</PRE>

<P>
The <TT>ESMF_FieldRegrid</TT> and <TT>ESMF_FieldRegridRelease</TT> calls
   may then be applied as in the previous example.


<P>

<P>

<P>

<H3><A NAME="SECTION050332700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">27</SPAN> Field regrid example: Mesh to Mesh</A>
</H3>
   This example demonstrates the regridding process between Fields created on Meshes. First
   the Meshes are created. This example omits the setup of the arrays describing the Mesh, but please see
   Section&nbsp;<A HREF="#sec:mesh:usage:meshCreation">33.3.1</A> for examples of this. After creation Fields are constructed on the Meshes, 
   and then ESMF_FieldRegridStore() is called to construct a RouteHandle implementing the regrid operation. Finally, ESMF_FieldRegrid() is
   called with the Fields and the RouteHandle to do the interpolation between the source Field and 
   destination Field.  Note the coordinates of the source and destination Mesh should be in degrees.
   
<P>
<PRE>
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Source Mesh
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Create the Mesh structure.
  ! For brevity's sake, the code to fill the Mesh creation 
  ! arrays is omitted from this example. However, here
  ! is a brief description of the arrays:
  ! srcNodeIds    - the global ids for the src nodes
  ! srcNodeCoords - the coordinates for the src nodes
  ! srcNodeOwners - which PET owns each src node
  ! srcElemIds    - the global ids of the src elements
  ! srcElemTypes  - the topological shape of each src element
  ! srcElemConn   - how to connect the nodes to form the elements
  !                 in the source mesh
  ! Several examples of setting up these arrays can be seen in
  ! the Mesh Section "Mesh Creation". 
  srcMesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=srcNodeIds, nodeCoords=srcNodeCoords, &amp;
         nodeOwners=srcNodeOwners, elementIds=srcElemIds,&amp;
         elementTypes=srcElemTypes, elementConn=srcElemConn, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)



  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create and Fill Source Field
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Set description of source Field
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Create source Field
  srcField = ESMF_FieldCreate(srcMesh, arrayspec, &amp;
                        name="source", rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Get source Field data pointer to put data into
  call ESMF_FieldGet(srcField, 0, fptr1D,  rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Get number of local nodes to allocate space
  ! to hold local node coordinates
  call ESMF_MeshGet(srcMesh, &amp;
         numOwnedNodes=numOwnedNodes, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Allocate space to hold local node coordinates
  ! (spatial dimension of Mesh*number of local nodes)
  allocate(ownedNodeCoords(2*numOwnedNodes))

  ! Get local node coordinates
  call ESMF_MeshGet(srcMesh, &amp;
         ownedNodeCoords=ownedNodeCoords, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Set the source Field to the function 20.0+x+y
  do i=1,numOwnedNodes
    ! Get coordinates
    x=ownedNodeCoords(2*i-1)
    y=ownedNodeCoords(2*i)

   ! Set source function
   fptr1D(i) = 20.0+x+y
  enddo

  ! Deallocate local node coordinates
  deallocate(ownedNodeCoords)


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Destination Mesh
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Create the Mesh structure.
  ! For brevity's sake, the code to fill the Mesh creation 
  ! arrays is omitted from this example. However, here
  ! is a brief description of the arrays:
  ! dstNodeIds    - the global ids for the dst nodes
  ! dstNodeCoords - the coordinates for the dst nodes
  ! dstNodeOwners - which PET owns each dst node
  ! dstElemIds    - the global ids of the dst elements
  ! dstElemTypes  - the topological shape of each dst element
  ! dstElemConn   - how to connect the nodes to form the elements
  !                 in the destination mesh
  ! Several examples of setting up these arrays can be seen in
  ! the Mesh Section "Mesh Creation". 
  dstMesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=dstNodeIds, nodeCoords=dstNodeCoords, &amp;
         nodeOwners=dstNodeOwners, elementIds=dstElemIds,&amp;
         elementTypes=dstElemTypes, elementConn=dstElemConn, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Destination Field
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Set description of source Field
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Create destination Field
  dstField = ESMF_FieldCreate(dstMesh, arrayspec, &amp;
                        name="destination", rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Do Regrid
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Compute RouteHandle which contains the regrid operation
  call ESMF_FieldRegridStore( &amp;
          srcField, &amp;
          dstField=dstField, &amp;
          routeHandle=routeHandle, &amp;
          regridmethod=ESMF_REGRIDMETHOD_BILINEAR, &amp;
          rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Perform Regrid operation moving data from srcField to dstField
  call ESMF_FieldRegrid(srcField, dstField, routeHandle, rc=rc)


  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! dstField now contains the interpolated data.
  ! If the Meshes don't change, then routeHandle
  ! may be used repeatedly to interpolate from 
  ! srcField to dstField.  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   
  ! User code to use the routeHandle, Fields, and
  ! Meshes goes here before they are freed below.


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Free the objects created in the example.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Free the RouteHandle
  call ESMF_FieldRegridRelease(routeHandle, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Free the Fields
  call ESMF_FieldDestroy(srcField, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_FieldDestroy(dstField, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Free the Meshes
  call ESMF_MeshDestroy(dstMesh, rc=rc)

  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_MeshDestroy(srcMesh, rc=rc)
 
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050332800000000000000"></A>
   <A NAME="sec:field:usage:gather_2dptr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">28</SPAN> Gather Field data onto root PET
</H3>

<P>
User can use <TT>ESMF_FieldGather</TT> interface to gather Field data from multiple
   PETs onto a single root PET. This interface is overloaded by type, kind, and rank.

<P>
Note that the implementation of Scatter and Gather is not sequence index based.
   If the Field is built on arbitrarily distributed Grid, Mesh, LocStream or XGrid, 
   Gather will not gather data to rootPet 
   from source data points corresponding to the sequence index on the rootPet. 
   Instead Gather will gather a contiguous memory range from source PET to
   rootPet. The size of the memory range is equal to the number of 
   data elements on the source PET. Vice versa for the Scatter operation. 
   In this case, the user should use <TT>ESMF_FieldRedist</TT> to achieve
   the same data operation result. For examples how to use <TT>ESMF_FieldRedist</TT>
   to perform Gather and Scatter, please refer to
   <A HREF="#sec:field:usage:redist_gathering">26.3.32</A> and
   <A HREF="#sec:field:usage:redist_scattering">26.3.31</A>.

<P>
In this example, we first create a 2D Field, then use <TT>ESMF_FieldGather</TT> to
   collect all the data in this Field into a data pointer on PET 0.
<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Create a 2D Grid and use this grid to create a Field
    ! farray is the Fortran data array that contains data on each PET.
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
        regDecomp=(/2,2/), &amp;
        name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    field = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, rc=localrc)
    if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)


    call ESMF_FieldGet(field, farrayPtr=fptr, rc=localrc)
    if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    !---------Initialize pet specific field data----------------
    !    1        5         10
    ! 1  +--------+---------+
    !    |        |         |
    !    |   0    |    1    |
    !    |        |         |
    ! 10 +--------+---------+
    !    |        |         |
    !    |   2    |    3    |
    !    |        |         |
    ! 20 +--------+---------+
    fptr = lpe

    ! allocate the Fortran data array on PET 0 to store gathered data
    if(lpe .eq. 0) then
      allocate (farrayDst(10,20))
    else
      allocate (farrayDst(0,0))
    end if
    call ESMF_FieldGather(field, farrayDst, rootPet=0, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! check that the values gathered on rootPet are correct
    if(lpe .eq. 0) then
       do i = 1, 5
          do j = 1, 10
             if(farrayDst(i, j) .ne. 0) localrc=ESMF_FAILURE
          enddo
       enddo
      if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
       do i = 6, 10
          do j = 1, 10
             if(farrayDst(i, j) .ne. 1) localrc=ESMF_FAILURE
          enddo
       enddo
      if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
       do i = 1, 5
          do j = 11, 20
             if(farrayDst(i, j) .ne. 2) localrc=ESMF_FAILURE
          enddo
       enddo
      if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
       do i = 6, 10
          do j = 11, 20
             if(farrayDst(i, j) .ne. 3) localrc=ESMF_FAILURE
          enddo
       enddo
      if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    endif

    ! destroy all objects created in this example to prevent memory leak
    call ESMF_FieldDestroy(field, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    call ESMF_GridDestroy(grid, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    if(lpe .eq. 0) deallocate(farrayDst)
</PRE>

<P>

<H3><A NAME="SECTION050332900000000000000"></A>
   <A NAME="sec:field:usage:scatter_2dptr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">29</SPAN> Scatter Field data from root PET onto its set of joint PETs
</H3>

<P>
User can use <TT>ESMF_FieldScatter</TT> interface to scatter Field data from root
   PET onto its set of joint PETs. This interface is overloaded by type, kind, and rank.

<P>
In this example, we first create a 2D Field, then use <TT>ESMF_FieldScatter</TT> to
   scatter the data from a data array located on PET 0 onto this Field.
<P>
<PRE>
    ! Create a 2D Grid and use this grid to create a Field
    ! farray is the Fortran data array that contains data on each PET.
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
        regDecomp=(/2,2/), &amp;
        name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    field = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, rc=localrc)
    if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! initialize values to be scattered
    !    1        5         10
    ! 1  +--------+---------+
    !    |        |         |
    !    |   0    |    1    |
    !    |        |         |
    ! 10 +--------+---------+
    !    |        |         |
    !    |   2    |    3    |
    !    |        |         |
    ! 20 +--------+---------+
    if(lpe .eq. 0) then
        allocate(farraySrc(10,20))
        farraySrc(1:5,1:10) = 0
        farraySrc(6:10,1:10) = 1
        farraySrc(1:5,11:20) = 2
        farraySrc(6:10,11:20) = 3
    else
      allocate (farraySrc(0,0))
    endif

    ! scatter the data onto individual PETs of the Field
    call ESMF_FieldScatter(field, farraySrc, rootPet=0, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_FieldGet(field, localDe=0, farrayPtr=fptr, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! verify that the scattered data is properly distributed
    do i = lbound(fptr, 1), ubound(fptr, 1)
        do j = lbound(fptr, 2), ubound(fptr, 2)
            if(fptr(i, j) .ne. lpe) localrc = ESMF_FAILURE
        enddo
        if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    enddo

    ! destroy all objects created in this example to prevent memory leak
    call ESMF_FieldDestroy(field, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    call ESMF_GridDestroy(grid, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    if(lpe .eq. 0) deallocate(farraySrc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050333000000000000000"></A>
   <A NAME="sec:field:usage:redist_1dptr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">30</SPAN> Redistribute data from source Field to destination Field
</H3>

<P>
User can use <TT>ESMF_FieldRedist</TT> interface to redistribute data from 
   source Field to destination Field. This interface is overloaded by type and kind;
   In the version of <TT>ESMF_FieldRedist</TT> without factor argument, a default value
   of 1 is used.

<P>
In this example, we first create two 1D Fields, a source Field and a destination
   Field. Then we use <TT>ESMF_FieldRedist</TT> to
   redistribute data from source Field to destination Field.
   
<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_VMGet(vm, localPet=localPet, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
            regDecomp=(/4/), &amp;
            rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create srcField
    ! +--------+--------+--------+--------+
    !      0        1        2        3            ! value
    ! 1        4        8        12       16       ! bounds
    srcField = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, &amp;
      indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_FieldGet(srcField, farrayPtr=srcfptr, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    srcfptr(:) = localPet

    ! create dstField
    ! +--------+--------+--------+--------+
    !      0        0        0        0            ! value
    ! 1        4        8        12       16       ! bounds
    dstField = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, &amp;
      indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_FieldGet(dstField, farrayPtr=dstfptr, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    dstfptr(:) = 0

    ! perform redist
    ! 1. setup routehandle from source Field to destination Field
    call ESMF_FieldRedistStore(srcField, dstField, routehandle, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! 2. use precomputed routehandle to redistribute data
    call ESMF_FieldRedist(srcfield, dstField, routehandle, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! verify redist
    call ESMF_FieldGet(dstField, localDe=0, farrayPtr=fptr, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Verify that the redistributed data in dstField is correct.
    ! Before the redist op, the dst Field contains all 0. 
    ! The redist op reset the values to the PE value, verify this is the case.
    do i = lbound(fptr, 1), ubound(fptr, 1)
        if(fptr(i) .ne. localPet) localrc = ESMF_FAILURE
    enddo
    if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Field redistribution can also be performed between different Field pairs that
   match the original Fields in <EM>type</EM>, <EM>kind</EM>, and memory layout of the
   <EM>gridded</EM> dimensions. However, the size, number, and index order of 
   <EM>ungridded</EM> dimensions may be different. See section <A HREF="#RH:Reusability">37.2.5</A>
   for a more detailed discussion of RouteHandle reusability.
<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=2, rc=rc)
</PRE>

<P>
Create two fields with ungridded dimensions using the Grid created previously.
   The new Field pair has matching number of elements. The ungridded dimension
   is mapped to the first dimension of either Field.
<P>
<PRE>
    srcFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
    dstFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
Using the previously computed routehandle, the Fields can be redistributed.
<P>
<PRE>
    call ESMF_FieldRedist(srcfieldA, dstFieldA, routehandle, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldRedistRelease(routehandle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050333100000000000000"></A>
   <A NAME="sec:field:usage:redist_scattering"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">31</SPAN> FieldRedist as a form of scatter involving arbitrary distribution
</H3>

<P>
User can use <TT>ESMF_FieldRedist</TT> interface to redistribute data from 
   source Field to destination Field, where the destination Field is built on
   an arbitrarily distributed structure, e.g. <TT>ESMF_Mesh</TT>. The underlying mechanism is explained
   in section <A HREF="#Array:ScatterGatherRevisited">28.2.19</A>.

<P>
In this example, we will create 2 one dimensional Fields, the src Field has a regular decomposition
   and holds all its data on a single PET, in this case PET 0. The destination Field is built on a Mesh
   which is itself built on an arbitrarily distributed distgrid. Then we use <TT>ESMF_FieldRedist</TT> to
   redistribute data from source Field to destination Field, similar to a traditional scatter operation.

<P>
The src Field only has data on PET 0 where it is sequentially initialized, i.e. 1,2,3...This data
   will be redistributed (or scattered) from PET 0 to the destination Field arbitrarily distributed on 
   all the PETs.
<P>
<PRE>
    ! a one dimensional grid whose elements are all located on PET 0
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/9/), &amp;
        regDecomp=(/1/), &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    srcField = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! initialize the source data
    if (localPet == 0) then
        call ESMF_FieldGet(srcField, farrayPtr=srcfptr, rc=rc)
        if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
        do i = 1, 9
            srcfptr(i) = i
        enddo
    endif
</PRE>

<P>
For more information on Mesh creation, user can refer to Mesh examples section or Field creation
   on Mesh example for more details.
<P>
<PRE>
      ! Create Mesh structure
      mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
             nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
             nodeOwners=nodeOwners, elementIds=elemIds,&amp;
             elementTypes=elemTypes, elementConn=elemConn, &amp;
             rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Create the destination Field on the Mesh that is arbitrarily distributed on 
   all the PETs.
<P>
<PRE>
      dstField = ESMF_FieldCreate(mesh, typekind=ESMF_TYPEKIND_I4, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Perform the redistribution from source Field to destination Field.
<P>
<PRE>
     call ESMF_FieldRedistStore(srcField, dstField, &amp;
             routehandle=routehandle, rc=rc)
     if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
     call ESMF_FieldRedist(srcField, dstField, routehandle=routehandle, rc=rc)
     if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
We can now verify that the sequentially initialized source data is scattered
   on to the destination Field. The data has been scattered onto the destination
   Field with the following distribution.
  <PRE>
  
   4 elements on PET 0:  1 2 4 5
   2 elements on PET 1:  3 6
   2 elements on PET 2:  7 8
   1 element  on PET 3:  9
</PRE>
   Because the redistribution is index based, the elements also corresponds to the
   index space of Mesh in the destination Field.
<P>
<PRE>
    call ESMF_FieldGet(dstField, farrayPtr=dstfptr, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
The scatter operation is successful. Since the routehandle computed with
   <TT>ESMF_FieldRedistStore</TT> can be reused, user can use the same routehandle
   to scatter multiple source Fields from a single PET to multiple destination
   Fields distributed on all PETs. The <TT>gathering</TT> operation is just the 
   opposite of the demonstrated <TT>scattering</TT> operation, where a user would
   redist from a source Field distributed on multiple PETs to a destination Field
   that only has data storage on a single PET.

<P>
Now it's time to release all the resources.
<P>
<PRE>
    call ESMF_FieldRedistRelease(routehandle=routehandle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050333200000000000000"></A>
   <A NAME="sec:field:usage:redist_gathering"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">32</SPAN> FieldRedist as a form of gather involving arbitrary distribution
</H3>

<P>
Similarly, one can use the same approach to gather the data from an arbitrary distribution
   to a non-arbitrary distribution. This concept is demonstrated by using the previous Fields but 
   the data operation is reversed. This time data is gathered from the Field built on the mesh to the Field
   that has only data allocation on rootPet.

<P>
First a FieldRedist routehandle is created from the Field built on Mesh to the Field
   that has only data allocation on rootPet.
<P>
<PRE>
    call ESMF_FieldRedistStore(dstField, srcField, routehandle=routehandle, &amp;
         rc=rc)
</PRE>

<P>
Perform FieldRedist, this will gather the data points from the Field built on mesh to
   the data pointer on the rootPet (default to 0) stored in the srcField.
<P>
<PRE>
    call ESMF_FieldRedist(dstField, srcField, routehandle=routehandle, rc=rc)
</PRE>

<P>
Release the routehandle used for the gather operation.
<P>
<PRE>
    call ESMF_FieldRedistRelease(routehandle=routehandle, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050333300000000000000"></A>
   <A NAME="sec:field:usage:smm_1dptr"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">33</SPAN> Sparse matrix multiplication from source Field to destination Field
</H3>

<P>
The <TT>ESMF_FieldSMM()</TT> interface can be used to perform sparse matrix multiplication
   from
   source Field to destination Field. This interface is overloaded by type and kind;

<P>
In this example, we first create two 1D Fields, a source Field and a destination
   Field. Then we use <TT>ESMF_FieldSMM</TT> to
   perform sparse matrix multiplication from source Field to destination Field.

<P>
The source and destination Field data are arranged such that each of the 4 PETs has 4
   data elements. Moreover, the source Field has all its data elements initialized to a linear
   function based on local PET number.
   Then collectively on each PET, a SMM according to the following formula
   is preformed: <BR>
   <!-- MATH
 $dstField(i) = i * srcField(i), i = 1 ... 4$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="265" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$dstField(i) = i * srcField(i), i = 1 ... 4$"></SPAN> <BR>
   <BR>

<P>
Because source Field data are initialized to a linear function based on local PET number,
   the formula predicts that
   the result destination Field data on each PET is 1,2,3,4. This is verified in the
   example.

<P>
Section <A HREF="#Array:SparseMatMul">28.2.18</A> provides a detailed discussion of the
   sparse matrix multiplication operation implemented in ESMF.
  
<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create distgrid and grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_GridGetFieldBounds(grid, localDe=0, totalCount=fa_shape, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create src\_farray, srcArray, and srcField
    ! +--------+--------+--------+--------+
    !      1        2        3        4            ! value
    ! 1        4        8        12       16       ! bounds
    allocate(src_farray(fa_shape(1)) )
    src_farray = lpe+1
    srcArray = ESMF_ArrayCreate(distgrid, src_farray, &amp;
                indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    srcField = ESMF_FieldCreate(grid, srcArray, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! create dst_farray, dstArray, and dstField
    ! +--------+--------+--------+--------+
    !      0        0        0        0            ! value
    ! 1        4        8        12       16       ! bounds
    allocate(dst_farray(fa_shape(1)) )
    dst_farray = 0
    dstArray = ESMF_ArrayCreate(distgrid, dst_farray, &amp;
                indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    dstField = ESMF_FieldCreate(grid, dstArray, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! perform sparse matrix multiplication
    ! 1. setup routehandle from source Field to destination Field
    ! initialize factorList and factorIndexList
    allocate(factorList(4))
    allocate(factorIndexList(2,4))
    factorList = (/1,2,3,4/)
    factorIndexList(1,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    factorIndexList(2,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)

    call ESMF_FieldSMMStore(srcField, dstField, routehandle, &amp;
        factorList, factorIndexList, rc=localrc)
    if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! 2. use precomputed routehandle to perform SMM
    call ESMF_FieldSMM(srcfield, dstField, routehandle, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! verify sparse matrix multiplication
    call ESMF_FieldGet(dstField, localDe=0, farrayPtr=fptr, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Verify that the result data in dstField is correct.
    ! Before the SMM op, the dst Field contains all 0.
    ! The SMM op reset the values to the index value, verify this is the case.
    ! +--------+--------+--------+--------+
    !  1 2 3 4  2 4 6 8  3 6 9 12  4 8 12 16       ! value
    ! 1        4        8        12       16       ! bounds
    do i = lbound(fptr, 1), ubound(fptr, 1)
        if(fptr(i) /= i*(lpe+1)) rc = ESMF_FAILURE
    enddo
</PRE>

<P>
Field sparse matrix multiplication can also be applied between Fields 
   that matche the original Fields in <EM>type</EM>, <EM>kind</EM>, and 
   memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
   and index order of <EM>ungridded</EM> dimensions may be different. See section
   <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
   reusability
 <PRE>
    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=2, rc=rc)
</PRE>

<P>
Create two fields with ungridded dimensions using the Grid created previously.
   The new Field pair has matching number of elements. The ungridded dimension
   is mapped to the first dimension of either Field.
<P>
<PRE>
    srcFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
    dstFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
Using the previously computed routehandle, the sparse matrix multiplication
   can be performed between the Fields.
<P>
<PRE>
    call ESMF_FieldSMM(srcfieldA, dstFieldA, routehandle, rc=rc)
</PRE>

<P>
<PRE>
    ! release route handle
    call ESMF_FieldSMMRelease(routehandle, rc=rc)
</PRE>

<P>
In the following discussion, we demonstrate how to set up a SMM routehandle
   between a pair of Fields that are different in number of gridded dimensions
   and the size of those gridded dimensions. The source Field has a 1D decomposition
   with 16 total elements; the destination Field has a 2D decomposition with
   12 total elements. For ease of understanding of the actual matrix calculation,
   a global indexing scheme is used.
<P>
<PRE>
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        indexflag=ESMF_INDEX_GLOBAL, &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        indexflag=ESMF_INDEX_GLOBAL, &amp;
        name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_GridGetFieldBounds(grid, localDe=0, totalLBound=tlb, &amp;
                       totalUBound=tub, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
create 1D src_farray, srcArray, and srcField
  <PRE>
   +  PET0  +  PET1  +  PET2  +  PET3  +
   +--------+--------+--------+--------+
        1        2        3        4            ! value
   1        4        8        12       16       ! bounds of seq indices
</PRE>
<P>
<PRE>
    allocate(src_farray2(tlb(1):tub(1)) )
    src_farray2 = lpe+1
    srcArray = ESMF_ArrayCreate(distgrid, src_farray2, &amp;
                  indexflag=ESMF_INDEX_GLOBAL, &amp;
      rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    !print *, lpe, '+', tlb, tub, '+', src_farray2

    srcField = ESMF_FieldCreate(grid, srcArray, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Create 2D dstField on the following distribution
   (numbers are the sequence indices):
  <PRE>
   +  PET0  +  PET1  +  PET2  +  PET3  +
   +--------+--------+--------+--------+
   |        |        |        |        |
   |   1    |   4    |   7    |   10   |
   |        |        |        |        |
   +--------+--------+--------+--------+
   |        |        |        |        |
   |   2    |   5    |   8    |   11   |
   |        |        |        |        |
   +--------+--------+--------+--------+
   |        |        |        |        |
   |   3    |   6    |   9    |   12   |
   |        |        |        |        |
   +--------+--------+--------+--------+
</PRE>
<P>
<PRE>
    ! Create the destination Grid
    dstGrid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/3,4/), &amp;
      indexflag = ESMF_INDEX_GLOBAL, &amp;
      regDecomp = (/1,4/), &amp;
      rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    dstField = ESMF_FieldCreate(dstGrid, typekind=ESMF_TYPEKIND_R4, &amp;
      indexflag=ESMF_INDEX_GLOBAL, &amp;
      rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Perform sparse matrix multiplication <SPAN CLASS="MATH"><IMG
 WIDTH="31" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img53.png"
 ALT="$dst_i$"></SPAN> = <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$M_{i,j}$"></SPAN> * <SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$src_j$"></SPAN>
   First setup routehandle from source Field to destination Field
   with prescribed factorList and factorIndexList.

<P>
The sparse matrix is of size 12x16, however only the following entries
   are filled:
   <PRE>
   M(3,1) = 0.1
   M(3,10) = 0.4
   M(8,2) = 0.25
   M(8,16) = 0.5
   M(12,1) = 0.3
   M(12,16) = 0.7
</PRE>

<P>
By the definition of matrix calculation, the 8th element on PET2 in the
   dstField equals to 0.25*srcField(2) + 0.5*srcField(16) = 0.25*1+0.5*4=2.25
   For simplicity, we will load the factorList and factorIndexList on
   PET 0 and 1, the SMMStore engine will load balance the parameters on all 4
   PETs internally for optimal performance.
<P>
<PRE>
    if(lpe == 0) then
      allocate(factorList(3), factorIndexList(2,3))
      factorList=(/0.1,0.4,0.25/)
      factorIndexList(1,:)=(/1,10,2/)
      factorIndexList(2,:)=(/3,3,8/)
      call ESMF_FieldSMMStore(srcField, dstField, routehandle=routehandle, &amp;
          factorList=factorList, factorIndexList=factorIndexList, rc=localrc)
      if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    else if(lpe == 1) then
      allocate(factorList(3), factorIndexList(2,3))
      factorList=(/0.5,0.3,0.7/)
      factorIndexList(1,:)=(/16,1,16/)
      factorIndexList(2,:)=(/8,12,12/)
      call ESMF_FieldSMMStore(srcField, dstField, routehandle=routehandle, &amp;
          factorList=factorList, factorIndexList=factorIndexList, rc=localrc)
      if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    else
      call ESMF_FieldSMMStore(srcField, dstField, routehandle=routehandle, &amp;
          rc=localrc)
      if (localrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    endif

    ! 2. use precomputed routehandle to perform SMM
    call ESMF_FieldSMM(srcfield, dstField, routehandle=routehandle, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050333400000000000000"></A>
   <A NAME="sec:field:usage:halo"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">34</SPAN> Field Halo solving a domain decomposed heat transfer problem
</H3>

<P>
The <TT>ESMF_FieldHalo()</TT> interface can be used to perform halo updates for a Field. This
   eases communication programming from a user perspective. By definition, the user
   program only needs to update locally owned exclusive region in each domain, then call
   FieldHalo to communicate the values in the halo region from/to neighboring domain elements.
   In this example, we solve a 1D heat transfer problem: <!-- MATH
 $u_t = \alpha^2 u_{xx}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="82" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img56.png"
 ALT="$u_t = \alpha^2 u_{xx}$"></SPAN> with the
   initial condition <SPAN CLASS="MATH"><IMG
 WIDTH="87" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img57.png"
 ALT="$u(0, x) = 20$"></SPAN> and boundary conditions <!-- MATH
 $u(t, 0) = 10, u(t, 1) = 40$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="170" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img58.png"
 ALT="$u(t, 0) = 10, u(t, 1) = 40$"></SPAN>.
   The temperature field <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img39.png"
 ALT="$u$"></SPAN>
   is represented by a <TT>ESMF_Field</TT>. A finite difference explicit time stepping scheme is employed.
   During each time step, FieldHalo update is called to communicate values in the halo region
   to neighboring domain elements. The steady state (as <!-- MATH
 $t \rightarrow \infty$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="50" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img59.png"
 ALT="$t \rightarrow \infty$"></SPAN>) solution
   is a linear temperature profile along <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img60.png"
 ALT="$x$"></SPAN>. The numerical solution is an approximation of
   the steady state solution. It can be verified to represent a linear temperature profile.

<P>
Section <A HREF="#Array:Halo">28.2.15</A> provides a discussion of the
   halo operation implemented in <TT>ESMF_Array</TT>.
  
<P>
<PRE>
! create 1D distgrid and grid decomposed according to the following diagram:
! +------------+   +----------------+   +---------------+   +--------------+
! |   DE 0  |  |   |  |   DE 1   |  |   |  |   DE 2  |  |   |  |   DE 3    |
! |  1 x 16 |  |   |  |  1 x 16  |  |   |  |  1 x 16 |  |   |  |  1 x 16   |
! |         | 1|&lt;-&gt;|1 |          | 1|&lt;-&gt;|1 |         | 1|&lt;-&gt;|1 |           |
! |         |  |   |  |          |  |   |  |         |  |   |  |           |
! +------------+   +----------------+   +---------------+   +--------------+
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/npx/), &amp;
        regDecomp=(/4/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! set up initial condition and boundary conditions of the
    ! temperature Field
    if(lpe == 0) then
        allocate(fptr(17), tmp_farray(17))
        fptr = 20.
        fptr(1) = 10.
        tmp_farray(1) = 10.
        startx = 2
        endx = 16

        field = ESMF_FieldCreate(grid, fptr, totalUWidth=(/1/), &amp;
                name="temperature", rc=rc)
        if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    else if(lpe == 3) then
        allocate(fptr(17), tmp_farray(17))
        fptr = 20.
        fptr(17) = 40.
        tmp_farray(17) = 40.
        startx = 2
        endx = 16

        field = ESMF_FieldCreate(grid, fptr, totalLWidth=(/1/), &amp;
                name="temperature", rc=rc)
        if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    else
        allocate(fptr(18), tmp_farray(18))
        fptr = 20.
        startx = 2
        endx = 17

        field = ESMF_FieldCreate(grid, fptr, &amp;
            totalLWidth=(/1/), totalUWidth=(/1/), name="temperature", rc=rc)
        if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    endif

    ! compute the halo update routehandle of the decomposed temperature Field
    call ESMF_FieldHaloStore(field, routehandle=routehandle, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    dt = 0.01
    dx = 1./npx
    alpha = 0.1

    ! Employ explicit time stepping
    ! Solution converges after about 9000 steps based on apriori knowledge.
    ! The result is a linear temperature profile stored in field.
    do iter = 1, 9000
     ! only elements in the exclusive region are updated locally
     ! in each domain
     do i = startx, endx
       tmp_farray(i) = &amp;
       fptr(i)+alpha*alpha*dt/dx/dx*(fptr(i+1)-2.*fptr(i)+fptr(i-1))
      enddo
      fptr = tmp_farray
     ! call halo update to communicate the values in the halo region to
     ! neighboring domains
     call ESMF_FieldHalo(field, routehandle=routehandle, rc=rc)
     if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    enddo

    ! release the halo routehandle
    call ESMF_FieldHaloRelease(routehandle, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION05034000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<A NAME="Field:rest"></A>

<OL>
<LI><B>CAUTION:</B> It depends on the specific entry point of <TT>ESMF_FieldCreate()</TT> used during Field creation, which Fortran operations are supported on the Fortran array pointer <TT>farrayPtr</TT>, returned by <TT>ESMF_FieldGet()</TT>. Only if the <TT>ESMF_FieldCreate()</TT> <EM>from pointer</EM> variant was used, will the returned <TT>farrayPtr</TT> variable contain the original bounds information, and be suitable for the Fortran <TT>deallocate()</TT> call. This limitation is a direct consequence of the Fortran 95 standard relating to the passing of array arguments.

<P>
</LI>
<LI><B>No mathematical operators.</B>  The Fields class does not 
currently support advanced
operations on fields, such as differential or other
mathematical operators.

<P>
</LI>
<LI><B>No vector Fields.</B>  ESMF does not currently  support storage of 
multiple vector Field components in the same Field component, although
that support is planned.  At this time users need to create a 
separate Field object to represent each vector component.

<P>
</LI>
</OL>

<H2><A NAME="SECTION05035000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>Some methods which have a Field interface are actually 
implemented at the underlying Grid or Array level; they
are inherited by the Field class.  This allows the user
API (Application Programming Interface) to present functions at
the level which is most consistent to the application without
restricting where inside the ESMF the actual implementation
is done.

<P>
</LI>
<LI>The Field class is implemented in Fortran, and as such is
defined inside the framework by a Field derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The Field class itself is very thin; it is a container class which
groups a Grid and an Array object together.

<P>
</LI>
<LI>Fields follow the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same Fields at the same point in their execution.  Since an early
user request was that global object creation not impose the overhead of
a barrier or synchronization point, Field creation does no inter-PET
communication.  For this to work, each PET must query the total number
of PETs in this VM, and which local PET number it is.  It can then
compute which DE(s) are part of the local decomposition, and any
global information can be computed in unison by all PETs independently
of the others.  In this way the overhead of communication is avoided,
at the cost of more difficulty in diagnosing program bugs which result
from not all PETs executing the same create calls.

<P>
</LI>
<LI>Related to the item above, the user request to not impose
inter-PET communication at object creation time means that requirement
FLD 1.5.1, that all Fields will have unique names, and if not specified, 
the framework will generate a unique name for it, is difficult or
impossible to support.  A part of this requirement has been implemented;
a unique object counter is maintained in the Base object class, and if
a name is not given at create time a name such as "Field003" is generated
which is guaranteed to not be repeated by the framework.   However, it
is impossible to error check that the user has not replicated a name,
and it is possible under certain conditions that if not all PETs have
created the same number of objects, that the counters on different PETs
may not stay synchronized.   This remains an open issue.

<P>
</LI>
</OL>

<H2><A NAME="SECTION05036000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05036100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_FieldAssignment(=) - Field assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface assignment(=)
   field1 = field2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field) :: field1
   type(ESMF_Field) :: field2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign field1 as an alias to the same ESMF Field object in memory
   as field2. If field2 is invalid, then field1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>field1</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>field2</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05036200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_FieldOperator(==) - Field equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
   if (field1 == field2) then ... endif
   OR
   result = (field1 == field2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field1
   type(ESMF_Field), intent(in) :: field2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether field1 and field2 are valid aliases to the same ESMF
   Field object in memory. For a more general comparison of two ESMF Fields,
   going beyond the simple alias test, the ESMF_FieldMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>field1</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>field2</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05036300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_FieldOperator(/=) - Field not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
   if (field1 /= field2) then ... endif
   OR
   result = (field1 /= field2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field1
   type(ESMF_Field), intent(in) :: field2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether field1 and field2 are <I>not</I> valid aliases to the
   same ESMF Field object in memory. For a more general comparison of two ESMF
   Fields, going beyond the simple alias test, the ESMF_FieldMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>field1</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>field2</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05036400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_FieldCopy - Copy data from one Field object to another</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldCopy(fieldOut, fieldIn, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Field), intent(inout) :: fieldOut
        type(ESMF_Field), intent(in) :: fieldIn
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Copy data from one <TT>ESMF_Field</TT> object to another.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldOut</STRONG></DT>
<DD><TT>ESMF_Field</TT> object into which to copy the data. The incoming
   <TT>fieldOut</TT> must already references a matching memory allocation.
   
</DD>
<DT><STRONG>fieldIn</STRONG></DT>
<DD><TT>ESMF_Field</TT> object that holds the data to be copied.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05036500000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_FieldCreate - Create a Field from Geom and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
 function ESMF_FieldCreateGBTKR(geom, typekind, &amp;
      gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
      totalLWidth, totalUWidth, pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGBTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Geom), intent(in) :: geom
     type(ESMF_TypeKind_Flag),intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_grid_tkr">26.3.4</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>geom</STRONG></DT>
<DD><TT>ESMF_Geom</TT> object.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field. See section <A HREF="node9.html#const:typekind">54.59</A>
   for a list of valid typekind options.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_FieldCreate - Create a Field from Geom and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGBArraySpec(geom, arrayspec, gridToFieldMap, &amp;
     ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, &amp;
     pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGBArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Geom) :: geom
     type(ESMF_ArraySpec), intent(in) :: arrayspec
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_grid_arrayspec">26.3.5</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>geom</STRONG></DT>
<DD><TT>ESMF_Geom</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_FieldCreate - Create a Field from Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGBData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(geom, &amp; 
   farray, indexflag, datacopyflag, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateGBData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Geom) :: geom 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), target :: farray 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data array and <TT>ESMF_Geom</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 
   The arguments are: 
   <DL>
<DT><STRONG>geom</STRONG></DT>
<DD><TT>ESMF_Geom</TT> object. The dimCount of the 
   Geom must be smaller than or equal to the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farray</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>farray</TT>. That is, for each gridded dimension the 
   <TT>farray</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farray</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>farray</TT>. That is, for each gridded dimension the 
   <TT>farray</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036800000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_FieldCreate - Create a Field from Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGBDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(geom, &amp; 
   farrayPtr, datacopyflag, gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateGBDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Geom) :: geom 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data pointer and <TT>ESMF_Geom</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>geom</STRONG></DT>
<DD><TT>ESMF_Geom</TT> object. The dimCount of the 
   Geom must be smaller than or equal to the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036900000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_FieldCreate - Create a Field from Grid and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridTKR(grid, typekind, &amp;
     indexflag, staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     totalLWidth, totalUWidth, pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGridTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_TypeKind_Flag),intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag), intent(in), optional :: indexflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_grid_tkr">26.3.4</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field. See section <A HREF="node9.html#const:typekind">54.59</A>
   for a list of valid typekind options.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node9.html#const:indexflag">54.27</A>
   for a list of valid indexflag options. The default indexflag value is the
   one stored in then <TT>ESMF_Grid</TT> object. Currently it is
   erroneous to specify an indexflag
   different from the one stored in the <TT>ESMF_Grid</TT> object. The default
   value is <TT>ESMF_INDEX_DELOCAL</TT>
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>.
   To create a custom stagger location see section
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_FieldCreate - Create a Field from Grid and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridArraySpec(grid, arrayspec, &amp;
     indexflag, staggerloc, gridToFieldMap, ungriddedLBound, &amp;
     ungriddedUBound, totalLWidth, totalUWidth, pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGridArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag), intent(in), optional :: indexflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_grid_arrayspec">26.3.5</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node9.html#const:indexflag">54.27</A>
   for a list of valid indexflag options. The default indexflag value is the
   one stored in then <TT>ESMF_Grid</TT> object. Currently it is
   erroneous to specify an indexflag
   different from the one stored in the <TT>ESMF_Grid</TT> object.The default
   value is <TT>ESMF_INDEX_DELOCAL</TT>
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>.
   To create a custom stagger location see section
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_FieldCreate - Create a Field from Grid and Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridArray(grid, array, datacopyflag, &amp;
     staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     totalLWidth, totalUWidth, name, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGridArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     character (len = *), intent(in), optional :: name
     type(ESMF_VM), intent(in), optional :: vm
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
   different VM than that of the current context.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_grid_array">26.3.6</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is
   <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>.
   To create a custom stagger location see section
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field object is constructed on the specified
   <TT>ESMF_VM</TT> object. The default is to construct on the VM of the
   current component context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_FieldCreate - Create a Field from Grid and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGridData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(grid, &amp; 
   farray, indexflag, datacopyflag, staggerloc, &amp; 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp; 
   totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateGridData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data array and <TT>ESMF_Grid</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 
   For examples and 
   associated documentation regarding this method see section 
   <A HREF="#sec:field:usage:create_2darray">26.3.11</A>, 
   <A HREF="#sec:field:usage:create_2dgrid_3dptr">26.3.13</A>, 
   <A HREF="#sec:field:usage:create_2dgrid_3dptr_map">26.3.14</A>, 
   <A HREF="#sec:field:usage:create_2dgrid_3dptr_map_halo">26.3.15</A>, and 
   <A HREF="#sec:field:usage:create_5dgrid_7dptr_2dungridded">26.3.9</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   Currently it is erroneous to specify an indexflag 
   different from the one stored in the <TT>ESMF_Grid</TT> object. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>. 
   To create a custom stagger location see section 
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farray</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>farray</TT>. That is, for each gridded dimension the 
   <TT>farray</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farray</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>farray</TT>. That is, for each gridded dimension the 
   <TT>farray</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_FieldCreate - Create a Field from Grid and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGridDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(grid, &amp; 
   farrayPtr, datacopyflag, staggerloc, gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateGridDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data pointer and <TT>ESMF_Grid</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
For examples and 
   associated documentation regarding this method see section 
   <A HREF="#sec:field:usage:create_2dptr">26.3.12</A>, 
   <A HREF="#sec:field:usage:create_2dgrid_3dptr">26.3.13</A>, 
   <A HREF="#sec:field:usage:create_2dgrid_3dptr_map">26.3.14</A>, 
   <A HREF="#sec:field:usage:create_2dgrid_3dptr_map_halo">26.3.15</A>, and 
   <A HREF="#sec:field:usage:create_5dgrid_7dptr_2dungridded">26.3.9</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>. 
   To create a custom stagger location see section 
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_FieldCreate - Create a Field from LocStream and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSTKR(locstream, typekind, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateLSTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_TypeKind_Flag),intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_locs_tkr">26.3.16</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field. See section <A HREF="node9.html#const:typekind">54.59</A>
   for a list of valid typekind options.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361500000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_FieldCreate - Create a Field from LocStream and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSArraySpec(locstream, arrayspec, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateLSArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_locs_arrayspec">26.3.17</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_FieldCreate - Create a Field from LocStream and Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSArray(locstream, array, &amp;
     datacopyflag, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateLSArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_grid_array">26.3.6</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is
   <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_FieldCreate - Create a Field from LocStream and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateLSData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(locstream, farray, &amp; 
   indexflag, datacopyflag, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateLSData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data array and <TT>ESMF_LocStream</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed.

<P>
The arguments are: 
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>locstream</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>locstream</TT>. Unlocstreamded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361800000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_FieldCreate - Create a Field from LocStream and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateLSDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(locstream, &amp; 
   farrayPtr, datacopyflag, gridToFieldMap, &amp; 
   name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateLSDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data pointer and <TT>ESMF_LocStream</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>locstream</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>locstream</TT>. Unlocstreamded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361900000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_FieldCreate - Create a Field from Mesh and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshTKR(mesh, typekind, indexflag, &amp;
     meshloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateMeshTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag), intent(in), optional :: indexflag
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_mesh_tkr">26.3.18</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field. See section <A HREF="node9.html#const:typekind">54.59</A>
   for a list of valid typekind options.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>The part of the Mesh on which to build the Field. For valid
   predefined values see Section&nbsp;<A HREF="node9.html#const:meshloc">54.39</A>.
   If not set, defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_FieldCreate - Create a Field from Mesh and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshArraySpec(mesh, arrayspec, &amp;
     indexflag, meshloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateMeshArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag),intent(in), optional :: indexflag
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_mesh_arrayspec">26.3.19</A> and
   <A HREF="#sec:field:usage:createMeshArrayspecOpt">26.3.21</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>The part of the Mesh on which to build the Field. For valid
   predefined values see Section&nbsp;<A HREF="node9.html#const:meshloc">54.39</A>.
   If not set, defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_FieldCreate - Create a Field from Mesh and Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshArray(mesh, array, &amp;
     datacopyflag, meshloc, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateMeshArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     type(ESMF_VM), intent(in), optional :: vm
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_mesh_array">26.3.20</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is
   <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>The part of the Mesh on which to build the Field. For valid
   predefined values see Section&nbsp;<A HREF="node9.html#const:meshloc">54.39</A>.
   If not set, defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field object is constructed on the specified
   <TT>ESMF_VM</TT> object. The default is to construct on the VM of the
   current component context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_FieldCreate - Create a Field from Mesh and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateMeshData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(mesh, &amp; 
   farray, indexflag, datacopyflag, meshloc, &amp; 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateMeshData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data array and <TT>ESMF_Mesh</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>The part of the Mesh on which to build the Field. For valid 
   predefined values see Section&nbsp;<A HREF="node9.html#const:meshloc">54.39</A>. 
   If not set, defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>mesh</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>mesh</TT>. Unmeshded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_FieldCreate - Create a Field from Mesh and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateMeshDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(mesh, &amp; 
   farrayPtr, datacopyflag, meshloc, gridToFieldMap, &amp; 
   name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateMeshDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data pointer and <TT>ESMF_Mesh</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>The part of the Mesh on which to build the Field. For valid 
   predefined values see Section&nbsp;<A HREF="node9.html#const:meshloc">54.39</A>. 
   If not set, defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>mesh</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>mesh</TT>. Unmeshded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_FieldCreate - Create a Field from XGrid and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGTKR(xgrid, typekind, xgridside, &amp;
     gridindex, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateXGTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside
     integer, intent(in), optional :: gridindex
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_locs_tkr">26.3.16</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field. See section <A HREF="node9.html#const:typekind">54.59</A>
   for a list of valid typekind options.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
   defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridSide is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362500000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_FieldCreate - Create a Field from XGrid and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGArraySpec(xgrid, arrayspec, &amp;
     xgridside, gridindex, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     pinflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateXGArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridSide
     integer, intent(in), optional :: gridIndex
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     type(ESMF_Pin_Flag), intent(in), optional :: pinflag
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_locs_arrayspec">26.3.17</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
   defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_FieldCreate - Create a Field from XGrid and Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGArray(xgrid, array, &amp;
     datacopyflag, xgridside, gridindex, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateXGArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside
     integer, intent(in), optional :: gridindex
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_grid_array">26.3.6</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is
   <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
   defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridSide is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_FieldCreate - Create a Field from XGrid and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateXGData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(xgrid, &amp; 
   farray, indexflag, datacopyflag, xgridside, gridindex, &amp; 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, name,&amp; 
   rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateXGData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_XGrid), intent(in) :: xgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data array and <TT>ESMF_Xgrid</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A, 
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then 
   defaults to ESMF_XGRIDSIDE_BALANCED. 
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>xgrid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>xgrid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>xgrid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>xgrid</TT>. Unxgridded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Xgrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Xgrid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than xgrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than xgrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362800000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_FieldCreate - Create a Field from XGrid and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateXGDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(xgrid, farrayPtr, &amp; 
   datacopyflag, xgridside, &amp; 
   gridindex, gridToFieldMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateXGDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_XGrid), intent(in) :: xgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a Fortran data pointer and <TT>ESMF_Xgrid</TT>. 
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the Fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A, 
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then 
   defaults to ESMF_XGRIDSIDE_BALANCED. 
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>xgrid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>xgrid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>xgrid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>xgrid</TT>. Unxgridded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Xgrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Xgrid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362900000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_FieldDestroy - Release resources associated with a Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldDestroy(field, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: noGarbage
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys the <TT>ESMF_Field</TT>, releasing the resources associated with
   the object.

<P>
If an <TT>ESMF_Grid</TT> is associated with <TT>field</TT>, it will not be
   released.

<P>
By default a small remnant of the object is kept in memory in order to
   prevent problems with dangling aliases. The default garbage collection
   mechanism can be overridden with the <TT>noGarbage</TT> argument.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases - a situation which may lead to hard to debug
   application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
   set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
   removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050363000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_FieldEmptyComplete - Complete a Field from arrayspec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete()
 subroutine ESMF_FieldEmptyCompAS(field, arrayspec, indexflag, &amp;
  gridToFieldMap, ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, &amp;
  pinflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>  type(ESMF_Field), intent(inout) :: field
  type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
  type(ESMF_Index_Flag), intent(in), optional :: indexflag
  integer, intent(in), optional :: gridToFieldMap(:)
  integer, intent(in), optional :: ungriddedLBound(:)
  integer, intent(in), optional :: ungriddedUBound(:)
  integer, intent(in), optional :: totalLWidth(:)
  integer, intent(in), optional :: totalUWidth(:)
  type(ESMF_Pin_Flag), intent(in), optional :: pinflag
  integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Complete an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT> based on arrayspec.
   The input <TT>ESMF_Field</TT> must have a status of
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. After this call the completed <TT>ESMF_Field</TT>
   has a status of <TT>ESMF_FIELDSTATUS_COMPLETE</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The input <TT>ESMF_Field</TT> with a status of
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node9.html#const:indexflag">54.27</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_FieldEmptyComplete - Complete a Field from typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete()
 subroutine ESMF_FieldEmptyCompTK(field, typekind, indexflag, &amp;
  gridToFieldMap, ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, &amp;
  pinflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>  type(ESMF_Field), intent(inout) :: field
  type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
  type(ESMF_Index_Flag), intent(in), optional :: indexflag
  integer, intent(in), optional :: gridToFieldMap(:)
  integer, intent(in), optional :: ungriddedLBound(:)
  integer, intent(in), optional :: ungriddedUBound(:)
  integer, intent(in), optional :: totalLWidth(:)
  integer, intent(in), optional :: totalUWidth(:)
  type(ESMF_Pin_Flag), intent(in), optional :: pinflag
  integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Complete an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT> based on typekind.
   The input <TT>ESMF_Field</TT> must have a status of
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. After this call the completed <TT>ESMF_Field</TT>
   has a status of <TT>ESMF_FIELDSTATUS_COMPLETE</TT>.

<P>
For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:partial_creation">26.3.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The input <TT>ESMF_Field</TT> with a status of
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node9.html#const:indexflag">54.27</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_FieldEmptyComplete - Complete a Field from Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyComp&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, &amp; 
   farray, indexflag, datacopyflag, gridToFieldMap, &amp; 
   ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Complete an <TT>ESMF_Field</TT> and allocate space internally for an 
   <TT>ESMF_Array</TT> based on typekind. 
   The input <TT>ESMF_Field</TT> must have a status of 
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. After this call the completed <TT>ESMF_Field</TT> 
   has a status of <TT>ESMF_FIELDSTATUS_COMPLETE</TT>.

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
For an example and 
   associated documentation using this method see section 
   <A HREF="#sec:field:usage:create_empty">26.3.8</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The input <TT>ESMF_Field</TT> with a status of 
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. 
   The <TT>ESMF_Field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_FieldEmptyComplete - Complete a Field from Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, &amp; 
   farrayPtr, datacopyflag, gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Complete an <TT>ESMF_Field</TT> and allocate space internally for an 
   <TT>ESMF_Array</TT> based on typekind. 
   The input <TT>ESMF_Field</TT> must have a status of 
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. After this call the completed <TT>ESMF_Field</TT> 
   has a status of <TT>ESMF_FIELDSTATUS_COMPLETE</TT>. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the Fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The input <TT>ESMF_Field</TT> with a status of 
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. 
   The <TT>ESMF_Field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_FieldEmptyComplete - Complete a Field from Grid started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompGrid&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, grid, &amp; 
   farray, indexflag, datacopyflag, staggerloc, gridToFieldMap, &amp; 
   ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>. 
   To create a custom stagger location see section 
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363500000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_FieldEmptyComplete - Complete a Field from Grid started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompGridPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, grid, &amp; 
   farrayPtr, datacopyflag, staggerloc, gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the Fortran data pointer in this case. This gives user more flexibility over memory management. 
    
   The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>. 
   To create a custom stagger location see section 
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_FieldEmptyComplete - Complete a Field from LocStream started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompLS&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, locstream, &amp; 
   farray, indexflag, datacopyflag, gridToFieldMap, &amp; 
   ungriddedLBound, ungriddedUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>locstream</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_FieldEmptyComplete - Complete a Field from LocStream started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompLSPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, locstream, &amp; 
   farrayPtr, datacopyflag, gridToFieldMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the Fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>locstream</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363800000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_FieldEmptyComplete - Complete a Field from Mesh started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompMesh&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, mesh, &amp; 
   farray, indexflag, datacopyflag, meshloc, &amp; 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either 
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set, 
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>mesh</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363900000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_FieldEmptyComplete - Complete a Field from Mesh started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompMeshPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, mesh, &amp; 
   farrayPtr, datacopyflag, meshloc, gridToFieldMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the Fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either 
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set, 
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>mesh</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050364000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> ESMF_FieldEmptyComplete - Complete a Field from XGrid started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompXG&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, xgrid, &amp; 
   farray, indexflag, datacopyflag, xgridside, gridindex, &amp; 
   gridToFieldMap, &amp; 
   ungriddedLBound, ungriddedUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_XGrid), intent(in) :: xgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A, 
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then 
   defaults to ESMF_XGRIDSIDE_BALANCED. 
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridSide is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>xgrid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>xgrid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>xgrid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the XGrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   XGrid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than XGrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than XGrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050364100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> ESMF_FieldEmptyComplete - Complete a Field from XGrid started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompXGPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, xgrid, &amp; 
   farrayPtr, xgridside, gridindex, &amp; 
   datacopyflag, gridToFieldMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_XGrid), intent(in) :: xgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the Fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A, 
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then 
   defaults to ESMF_XGRIDSIDE_BALANCED. 
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>xgrid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>xgrid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>xgrid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the XGrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   XGrid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050364200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> ESMF_FieldEmptyComplete - Complete a Field started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompGB&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, geom, &amp; 
   farray, indexflag, datacopyflag, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Geom), intent(in) :: geom 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), target :: farray 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. For an example and 
   associated documentation using this method see section 
   <A HREF="#sec:field:usage:partial_creation">26.3.7</A>. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>geom</STRONG></DT>
<DD>The <TT>ESMF_Geom</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native Fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>geom</TT>'s dimCount. The list elements map each dimension 
   of the <TT>geom</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>geom</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050364300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">43</SPAN> ESMF_FieldEmptyComplete - Complete a Field started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompGBPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, geom, &amp; 
   farrayPtr, datacopyflag, gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inou) :: field 
   type(ESMF_Geom), intent(in) :: geom 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), dimension(&lt;rank&gt;), pointer :: farrayPtr 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. For an example and 
   associated documentation using this method see section 
   <A HREF="#sec:field:usage:partial_creation">26.3.7</A>. 

<P>
The Fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the Fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>geom</STRONG></DT>
<DD>The <TT>ESMF_Geom</TT> object to complete the Field. The dimCount of the 
   Geom must be smaller than or equal to the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native Fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>geom</TT>'s dimCount. The list elements map each dimension 
   of the <TT>geom</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>geom</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050364400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">44</SPAN> ESMF_FieldEmptyCreate - Create an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_FieldEmptyCreate(name, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldEmptyCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character (len = *), intent(in), optional :: name
     type(ESMF_VM), intent(in), optional :: vm
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
   different VM than that of the current context.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This version of <TT>ESMF_FieldCreate</TT> builds an empty <TT>ESMF_Field</TT>
   and depends on later calls to add an <TT>ESMF_Grid</TT> and <TT>ESMF_Array</TT> to
   it. The empty <TT>ESMF_Field</TT> can be completed in one more step or two more steps by
   the <TT>ESMF_FieldEmptySet</TT> and <TT>ESMF_FieldEmptyComplete</TT> methods.
   Attributes can be added to an empty Field object. For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:create_empty">26.3.8</A> and <A HREF="#sec:field:usage:partial_creation">26.3.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field object is created on the specified
   <TT>ESMF_VM</TT> object. The default is to create on the VM of the
   current component context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050364500000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">45</SPAN> ESMF_FieldEmptySet - Set a Geom in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetGeom(field, geom, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_Geom), intent(in) :: geom
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_VM), intent(in), optional :: vm
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a geom in a non-completed <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must not be completed for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Geom</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT> or
   stays <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>
For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:partial_creation">26.3.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Grid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.
   
</DD>
<DT><STRONG>geom</STRONG></DT>
<DD><TT>ESMF_Geom</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field object will only be accessed, and the Grid object
   set, on those PETs contained in the specified <TT>ESMF_VM</TT> object.
   The default is to assume the VM of the current context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050364600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">46</SPAN> ESMF_FieldEmptySet - Set a Grid in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetGrid(field, grid, StaggerLoc, &amp;
     vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_Grid), intent(in) :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_STAGGERLOC), intent(in), optional :: StaggerLoc
   type(ESMF_VM), intent(in), optional :: vm
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
   different VM than that of the current context.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a grid and an optional staggerloc (default to center stagger
   <TT>ESMF_STAGGERLOC_CENTER</TT>) in a non-completed <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must not be completed for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Grid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT> or
   stays <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>
For an example and
   associated documentation using this method see section
   <A HREF="#sec:field:usage:partial_creation">26.3.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Grid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[StaggerLoc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="#const:staggerloc">31.2.6</A>.
   To create a custom stagger location see section
   <A HREF="#sec:usage:staggerloc:adv">31.3.25</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field object will only be accessed, and the Grid object
   set, on those PETs contained in the specified <TT>ESMF_VM</TT> object.
   The default is to assume the VM of the current context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050364700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">47</SPAN> ESMF_FieldEmptySet - Set a Mesh in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetMesh(field, mesh, indexflag, meshloc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_Mesh), intent(in) :: mesh
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Index_Flag),intent(in), optional :: indexflag
   type(ESMF_MeshLoc), intent(in), optional :: meshloc
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a mesh and an optional meshloc (default to center stagger
   <TT>ESMF_MESHLOC_NODE</TT>) in a non-completed <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must not be completed for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Mesh</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT> or
   stays <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Mesh</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set,
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050364800000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">48</SPAN> ESMF_FieldEmptySet - Set a LocStream in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetLocStream(field, locstream, &amp;
     vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_LocStream), intent(in) :: locstream
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_VM), intent(in), optional :: vm
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a <TT>ESMF_LocStream</TT> in a non-completed <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must not be completed for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_LocStream</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT> or
   stays <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_LocStream</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field object will only be accessed, and the Grid object
   set, on those PETs contained in the specified <TT>ESMF_VM</TT> object.
   The default is to assume the VM of the current context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050364900000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">49</SPAN> ESMF_FieldEmptySet - Set an XGrid in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetXGrid(field, xgrid, xgridside, gridindex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_XGrid), intent(in) :: xgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside
   integer, intent(in), optional :: gridindex
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a xgrid and optional xgridside (default to balanced side
   <TT>ESMF_XGRIDSIDE_Balanced</TT>) and gridindex (default to 1)
   in a non-complete <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must not be completed for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_XGrid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>
   or stays <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_XGrid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

</DD>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Side of XGrid to retrieve a DistGrid. For valid
   predefined values see section <A HREF="#const:xgridside">34.2.1</A>.
   The default value is <TT>ESMF_XGRIDSIDE_BALANCED</TT>.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>Index to specify which DistGrid when on side A or side B.
   The default value is 1.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050365000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">50</SPAN> ESMF_FieldFill - Fill data into a Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldFill(field, dataFillScheme, &amp;
     const1, member, step, &amp;
     param1I4, param2I4, param3I4, &amp;
     param1R4, param2R4, param3R4, &amp;
     param1R8, param2R8, param3R8, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*), intent(in), optional :: dataFillScheme
     real(ESMF_KIND_R8), intent(in), optional :: const1
     integer, intent(in), optional :: member
     integer, intent(in), optional :: step
     integer(ESMF_KIND_I4), intent(in), optional :: param1I4
     integer(ESMF_KIND_I4), intent(in), optional :: param2I4
     integer(ESMF_KIND_I4), intent(in), optional :: param3I4
     real(ESMF_KIND_R4), intent(in), optional :: param1R4
     real(ESMF_KIND_R4), intent(in), optional :: param2R4
     real(ESMF_KIND_R4), intent(in), optional :: param3R4
     real(ESMF_KIND_R8), intent(in), optional :: param1R8
     real(ESMF_KIND_R8), intent(in), optional :: param2R8
     real(ESMF_KIND_R8), intent(in), optional :: param3R8
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ESMF_FieldFill"></A>   Fill <TT>field</TT> with data according to <TT>dataFillScheme</TT>. Depending
   on the chosen fill scheme, the <TT>member</TT> and <TT>step</TT> arguments are
   used to provide differing fill data patterns.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to fill with data.
   
</DD>
<DT><STRONG>[dataFillScheme]</STRONG></DT>
<DD>The fill scheme. The available options are "sincos", "one", "const",
   "random", "nan", and "snan". Defaults to "sincos".
   
</DD>
<DT><STRONG>[const1]</STRONG></DT>
<DD>Constant of real type. Defaults to 0.
   
</DD>
<DT><STRONG>[member]</STRONG></DT>
<DD>Member incrementor. Defaults to 1.
   
</DD>
<DT><STRONG>[step]</STRONG></DT>
<DD>Step incrementor. Defaults to 1.
   
</DD>
<DT><STRONG>[param1I4]</STRONG></DT>
<DD>Optional parameter of typekind I4.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[param2I4]</STRONG></DT>
<DD>Optional parameter of typekind I4.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[param3I4]</STRONG></DT>
<DD>Optional parameter of typekind I4.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[param1R4]</STRONG></DT>
<DD>Optional parameter of typekind R4.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[param2R4]</STRONG></DT>
<DD>Optional parameter of typekind R4.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[param3R4]</STRONG></DT>
<DD>Optional parameter of typekind R4.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[param1R8]</STRONG></DT>
<DD>Optional parameter of typekind R8.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[param2R8]</STRONG></DT>
<DD>Optional parameter of typekind R8.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[param3R8]</STRONG></DT>
<DD>Optional parameter of typekind R8.
   The default depends on the specified <TT>dataFillScheme</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050365100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">51</SPAN> ESMF_FieldGather - Gather a Fortran array from an ESMF_Field </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldGather&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, farray, &amp; 
   rootPet, tile, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field 
   &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(out), target :: farray(&lt;rank&gt;) 
   integer, intent(in) :: rootPet 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: tile 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gather the data of an ESMF_Field object into the <TT>farray</TT> located on 
   <TT>rootPET</TT>. A single DistGrid tile of <TT>array</TT> must be 
   gathered into <TT>farray</TT>. The optional <TT>tile</TT> 
   argument allows selection of the tile. For Fields defined on a single 
   tile DistGrid the default selection (tile 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the tile in Field. 

<P>
If the Field contains replicating DistGrid dimensions data will be 
   gathered from the numerically higher DEs. Replicated data elements in 
   numericaly lower DEs will be ignored. 

<P>
The implementation of Scatter and Gather is not sequence index based. 
   If the Field is built on arbitrarily distributed Grid, Mesh, LocStream or XGrid, 
   Gather will not gather data to rootPet 
   from source data points corresponding to the sequence index on rootPet. 
   Instead Gather will gather a contiguous memory range from source PET to 
   rootPet. The size of the memory range is equal to the number of 
   data elements on the source PET. Vice versa for the Scatter operation. 
   In this case, the user should use <TT>ESMF_FieldRedist</TT> to achieve 
   the same data operation result. For examples how to use <TT>ESMF_FieldRedist</TT> 
   to perform Gather and Scatter, please refer to 
   <A HREF="#sec:field:usage:redist_gathering">26.3.32</A> and 
   <A HREF="#sec:field:usage:redist_scattering">26.3.31</A>. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
For examples and associated documentation regarding this method see Section 
   <A HREF="#sec:field:usage:gather_2dptr">26.3.28</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object from which data will be gathered. 
   
</DD>
<DT><STRONG>{farray}</STRONG></DT>
<DD>The Fortran array into which to gather data. Only root 
   must provide a valid <TT>farray</TT>, the other PETs may treat 
   <TT>farray</TT> as an optional argument. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid destination array, i.e. <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The DistGrid tile in <TT>field</TT> from which to gather <TT>farray</TT>. 
   By default <TT>farray</TT> will be gathered from tile 1. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050365200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">52</SPAN> ESMF_FieldGet - Get object-wide Field information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet()
   subroutine ESMF_FieldGetDefault(field, arrayspec, &amp;
     status, geomtype, grid, mesh, locstream, xgrid, array, localarrayList, &amp;
     typekind, dimCount, rank, staggerloc, meshloc, xgridside, &amp;
     gridindex, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     totalLWidth, totalUWidth, localDeCount, ssiLocalDeCount, &amp;
     localDeToDeMap, minIndex, maxIndex, elementCount, &amp;
     localMinIndex, localMaxIndex, localElementCount, isESMFAllocated, &amp;
     name, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ArraySpec), intent(out), optional :: arrayspec
     type(ESMF_FieldStatus_Flag),intent(out), optional :: status
     type(ESMF_GeomType_Flag), intent(out), optional :: geomtype
     type(ESMF_Grid), intent(out), optional :: grid
     type(ESMF_Mesh), intent(out), optional :: mesh
     type(ESMF_LocStream), intent(out), optional :: locstream
     type(ESMF_XGrid), intent(out), optional :: xgrid
     type(ESMF_Array), intent(out), optional :: array
     type(ESMF_LocalArray), target, intent(out), optional :: localarrayList(:)
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer, intent(out), optional :: dimCount
     integer, intent(out), optional :: rank
     type(ESMF_StaggerLoc), intent(out), optional :: staggerloc
     type(ESMF_MeshLoc), intent(out), optional :: meshloc
     type(ESMF_XGridSide_Flag), intent(out), optional :: xgridside
     integer, intent(out), optional :: gridindex
     integer, intent(out), optional :: gridToFieldMap(:)
     integer, intent(out), optional :: ungriddedLBound(:)
     integer, intent(out), optional :: ungriddedUBound(:)
     integer, intent(out), optional :: totalLWidth(:,:)
     integer, intent(out), optional :: totalUWidth(:,:)
     integer, intent(out), optional :: localDeCount
     integer, intent(out), optional :: ssiLocalDeCount
     integer, intent(out), optional :: localDeToDeMap(:)
     integer, intent(out), optional :: minIndex(:)
     integer, intent(out), optional :: maxIndex(:)
     integer, intent(out), optional :: elementCount(:)
     integer, intent(out), optional :: localMinIndex(:)
     integer, intent(out), optional :: localMaxIndex(:)
     integer, intent(out), optional :: localElementCount(:)
     logical, intent(out), optional :: isESMFAllocated
     character(len=*), intent(out), optional :: name
     type(ESMF_VM), intent(out), optional :: vm
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r - <EM>except those arguments indicated below</EM>.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.3.0r</STRONG></DT>
<DD>Added argument <TT>vm</TT> in order to offer information about the
   VM on which the Field was created.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>minIndex</TT>.
   The new argument allows the user to query the global lower bounds of the field data across all PETs.
<BR>
Added argument <TT>maxIndex</TT>.
   The new argument allows the user to query the global upper bounds of the field data across all PETs.
<BR>
Added argument <TT>elementCount</TT>.
   The new argument allows the user to query the global number of items of the field data across all PETs.
<BR>
Added argument <TT>localMinIndex</TT>.
   The new argument allows the user to query the PET local lower bounds globally indexed of the field data.
<BR>
Added argument <TT>localMaxIndex</TT>.
   The new argument allows the user to query the PET local upper bounds globally indexed of the field data.
<BR>
Added argument <TT>localElementCount</TT>.
   The new argument allows the user to query the PET local number of items of the field data.
<BR>
Added argument <TT>ssiLocalDeCount</TT> and <TT>localarrayList</TT> to
   support DE sharing between PETs on the same single system
   image (SSI).
<BR>
Added argument <TT>localDeToDeMap</TT> to support DE handling from
   the Field level rather than require user to go to Array level.
   
</DD>
<DT><STRONG>8.5.0</STRONG></DT>
<DD>Added argument <TT>isESMFAllocated</TT> to support user query of
   whether ESMF or user is responsible for the data allocation
   referenced by this object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query an <TT>ESMF_Field</TT> object for various pieces of information.
   All arguments after the <TT>field</TT> argument are optional. To select
   individual items use the <TT>named_argument=value</TT> syntax. For an example
   and associated documentation using this method see section
   <A HREF="#sec:field:usage:field_get_default">26.3.3</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object to query.
   
</DD>
<DT><STRONG>[arrayspec]</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information
   of the Field object.
   
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The status of the Field. See section <A HREF="#const:fieldstatus">26.2.1</A> for a
   complete list of values.

</DD>
<DT><STRONG>[geomtype]</STRONG></DT>
<DD>The type of geometry on which the Field is built. See
   section&nbsp;<A HREF="node9.html#const:geomtype">54.22</A> for the range of values.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD><TT>ESMF_Grid</TT>.
   
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>   <TT>ESMF_Mesh</TT>.
   
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>   <TT>ESMF_LocStream</TT>.
   
</DD>
<DT><STRONG>[xgrid]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>   <TT>ESMF_XGrid</TT>.
   
</DD>
<DT><STRONG>[array]</STRONG></DT>
<DD><TT>ESMF_Array</TT>.
   
</DD>
<DT><STRONG>[localarrayList]</STRONG></DT>
<DD>Upon return this holds a list of the associated <TT>ESMC_LocalArray</TT>
   objects. <TT>localarrayList</TT> must be allocated to be of size
   <TT>localDeCount</TT> or <TT>ssiLocalDeCount</TT>.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind specifier for Field. See section <A HREF="node9.html#const:typekind">54.59</A> for a
   complete list of values.
   
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of geometrical dimensions in <TT>field</TT>.
   For an detailed discussion of this parameter, please see
   section <A HREF="#sec:field:usage:createArbGrid">26.3.23</A> and
   section <A HREF="#sec:field:usage:createArbGridRep">26.3.24</A>.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Number of dimensions in the physical memory of the <TT>field</TT> data. It is
   identical to dimCount when the corresponding grid is a non-arbitrary grid.
   It is less than dimCount when the grid is arbitrarily distributed.
   For an detailed discussion of this parameter, please see
   section <A HREF="#sec:field:usage:createArbGrid">26.3.23</A> and
   section <A HREF="#sec:field:usage:createArbGridRep">26.3.24</A>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values and interpretation of results see
   section <A HREF="#const:staggerloc">31.2.6</A>.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>
The part of the mesh to build the Field on. Can be either
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set,
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>
The side of the XGrid that the Field was created on. See section
   <A HREF="#const:xgridside">34.2.1</A> for a complete list of values.

</DD>
<DT><STRONG>[gridIndex]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>
If xgridside is <TT>ESMF_XGRIDSIDE_A</TT> or <TT>ESMF_XGRIDSIDE_B</TT>
   then this index tells which Grid/Mesh on that side the Field was
   created on.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of the first dimension of this array is the number
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   The size of the 2nd dimension of this array is localDeCount.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of the first dimension of this array is the number
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   The size of the 2nd dimension of this array is localDeCount.
   
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>Upon return this holds the number of PET-local DEs defined in
   the DELayout associated with the Field object.
   
</DD>
<DT><STRONG>[ssiLocalDeCount]</STRONG></DT>
<DD>The number of DEs in the Field available to the local PET. This
   includes DEs that are local to other PETs on the same SSI, that are
   accessible via shared memory.
   
</DD>
<DT><STRONG>[localDeToDeMap]</STRONG></DT>
<DD>Mapping between localDe indices and the (global) DEs associated with
   the local PET. The localDe index variables are discussed in sections
   <A HREF="node6.html#DELayout_general_mapping">50.3.7</A> and <A HREF="#Array_native_language_localde">28.2.5</A>.
   The provided actual argument must be of size <TT>localDeCount</TT>, or
   <TT>ssiLocalDeCount</TT>, and will be filled accordingly.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Upon return this holds the global lower bounds of the field data across all PETs.
   This information will be identical across all PETs.
   <TT>minIndex</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>Upon return this holds the global upper bounds of the field data across all PETs.
   This information will be identical across all PETs.
   <TT>maxIndex</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[elementCount]</STRONG></DT>
<DD>Upon return this holds the global number of items of the field data across all PETs.
   This information will be identical across all PETs.
   <TT>elementCount</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[localMinIndex]</STRONG></DT>
<DD>Upon return this holds the PET local lower bounds globally indexed of the field data.
   <TT>localMinIndex</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[localMaxIndex]</STRONG></DT>
<DD>Upon return this holds the PET local upper bounds globally indexed of the field data.
   <TT>localMaxIndex</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[localElementCount]</STRONG></DT>
<DD>Upon return this holds the PET local number of items of the field data.
   <TT>localElementCount</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[isESMFAllocated]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for data allocations held by ESMF. Set to
   <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Field object.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>The VM on which the Field object was created.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050365300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">53</SPAN> ESMF_FieldGet - Get a DE-local Fortran array pointer from a Field </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet() 
   subroutine ESMF_FieldGetDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, localDe, &amp; 
   farrayPtr, exclusiveLBound, exclusiveUBound, exclusiveCount, &amp; 
   computationalLBound, computationalUBound, computationalCount, &amp; 
   totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: localDe 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   integer, intent(out), optional :: exclusiveLBound(:) 
   integer, intent(out), optional :: exclusiveUBound(:) 
   integer, intent(out), optional :: exclusiveCount(:) 
   integer, intent(out), optional :: computationalLBound(:) 
   integer, intent(out), optional :: computationalUBound(:) 
   integer, intent(out), optional :: computationalCount(:) 
   integer, intent(out), optional :: totalLBound(:) 
   integer, intent(out), optional :: totalUBound(:) 
   integer, intent(out), optional :: totalCount(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a Fortran pointer to DE-local memory allocation within <TT>field</TT>. 
   For convenience DE-local bounds can be queried at the same time. 
   For an example and 
   associated documentation using this method see section 
   <A HREF="#sec:field:usage:field_get_dataptr">26.3.2</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object. 
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>. 
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted, 
   in which case it will default to <TT>localDe=0</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Fortran array pointer which will be pointed at DE-local memory allocation. 
   It depends on the specific entry point 
   of <TT>ESMF_FieldCreate()</TT> used during <TT>field</TT> creation, which 
   Fortran operations are supported on the returned <TT>farrayPtr</TT>. See 
   <A HREF="#Field:rest">26.4</A> for more details. 
   
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region. 
   <TT>exclusiveLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region. 
   <TT>exclusiveUBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>, 
   in the exclusive region per dimension. 
   <TT>exclusiveCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region. 
   <TT>computationalLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region. 
   <TT>computationalUBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension 
   (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region. 
   <TT>totalLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region. 
   <TT>totalUBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension 
   (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>computationalCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A> for a description 
   of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050365400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">54</SPAN> ESMF_FieldGetBounds - Get DE-local Field data bounds</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGetBounds()
   subroutine ESMF_FieldGetBounds(field, localDe, &amp;
     exclusiveLBound, exclusiveUBound, exclusiveCount, computationalLBound, &amp;
     computationalUBound, computationalCount, totalLBound, &amp;
     totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: localDe
     integer, intent(out), optional :: exclusiveLBound(:)
     integer, intent(out), optional :: exclusiveUBound(:)
     integer, intent(out), optional :: exclusiveCount(:)
     integer, intent(out), optional :: computationalLBound(:)
     integer, intent(out), optional :: computationalUBound(:)
     integer, intent(out), optional :: computationalCount(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method returns the bounds information of a field that consists of a
   internal grid and a internal array. The exclusive and computational bounds
   are shared between the grid and the array but the total bounds are the array
   bounds plus the halo width. The count is the number of elements between each
   bound pair.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Field to get the information from.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
   <TT>exclusiveLBound</TT> must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
   <TT>exclusiveUBound</TT> must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>,
   in the exclusive region per dimension.
   <TT>exclusiveCount</TT> must
   be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
   <TT>computationalLBound</TT> must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
   <TT>computationalUBound</TT> must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
   (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
   must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
   <TT>totalLBound</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
   <TT>totalUBound</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
   (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
   be allocated to be of size equal to the field rank.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>


<P>

<P>

<P>

<H3><A NAME="SECTION050365500000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">55</SPAN> ESMF_FieldHalo - Execute a FieldHalo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldHalo(field, routehandle,  &amp;
                             routesyncflag, finishedflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),          intent(inout)          :: field
     type(ESMF_RouteHandle),    intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag), intent(in),  optional  :: routesyncflag
     logical,                   intent(out), optional  :: finishedflag
     logical,                   intent(in),  optional  :: checkflag
     integer,                   intent(out), optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field halo operation for <TT>field</TT>. 
     The <TT>field</TT> argument must match the Field used during 
     <TT>ESMF_FieldHaloStore()</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
See <TT>ESMF_FieldHaloStore()</TT> on how to precompute <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[routesyncflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_ROUTESYNC_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node9.html#const:routesync">54.51</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>, or a final call with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT>. For all other <TT>routesyncflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.

</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050365600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">56</SPAN> ESMF_FieldHaloRelease - Release resources associated with a Field halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldHaloRelease(routehandle, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional  :: noGarbage
     integer,                intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with a Field halo operation.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050365700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">57</SPAN> ESMF_FieldHaloStore - Store a FieldHalo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_FieldHaloStore(field, routehandle,  &amp;
       startregion, haloLDepth, haloUDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),            intent(inout)           :: field
     type(ESMF_RouteHandle),      intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_StartRegion_Flag), intent(in),    optional :: startregion
     integer,                     intent(in),    optional :: haloLDepth(:)
     integer,                     intent(in),    optional :: haloUDepth(:)
     integer,                     intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a Field halo operation over the data in <TT>field</TT>. By default,
     i.e. without specifying <TT>startregion</TT>, <TT>haloLDepth</TT> and
     <TT>haloUDepth</TT>, all elements in the total Field region that lie outside
     the exclusive region will be considered potential destination elements for
     halo. However, only those elements that have a corresponding halo source
     element, i.e. an exclusive element on one of the DEs, will be updated under
     the halo operation. Elements that have no associated source remain 
     unchanged under halo.

<P>
Specifying <TT>startregion</TT> allows to change the shape of the 
     effective halo region from the inside. Setting this flag to
     <TT>ESMF_STARTREGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region of the Field are considered for potential
     destination elements for the halo operation. The default is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>startregion</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total Field region, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Field region is
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for the halo operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldHalo()</TT> on any Field that matches 
     <TT>field</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> containing data to be haloed. The data in this Field may be
       destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[startregion]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elements.
       See section <A HREF="node9.html#const:startregion">54.54</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>startregion</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>startregion</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050365800000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">58</SPAN> ESMF_FieldIsCreated - Check whether a Field object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_FieldIsCreated(field, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_FieldIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>field</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050365900000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">59</SPAN> ESMF_FieldPrint - Print Field information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldPrint(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>field</TT> to <TT>stdout</TT>.
       This subroutine goes through the internal data members of a field
       data type and prints information of each data member.

<P>
The arguments are:
       <DL>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050366000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">60</SPAN> ESMF_FieldRead - Read Field data from a file</A>
</H3>

<P>
<A NAME="api:FieldRead"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldRead(field, fileName,        &amp;
       variableName, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),      intent(inout)          :: field
     character(*),          intent(in)             :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*),          intent(in),  optional  :: variableName
     integer,               intent(in),  optional  :: timeslice
     type(ESMF_IOFmt_Flag), intent(in),  optional  :: iofmt
     integer,               intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Read Field data from a file and put it into an ESMF_Field object.
     For this API to be functional, the environment variable <TT>ESMF_PIO</TT>
     should be set to either "internal" or "external" when the ESMF library is built.
     Please see the section on Data I/O,&nbsp;<A HREF="#io:dataio">38.2</A>.

<P>
Limitations:
     
<UL>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object in which the read data is returned.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file from which Field data is read.
       If the Field is a multi-tile Array, then fileName must contain
       exactly one instance of "*"; this is a placeholder that will be replaced
       by the tile number, with each tile being read from a separate file. (For
       example, for a fileName of "myfile*.nc", tile 1 will be read from
       "myfile1.nc", tile 2 from "myfile2.nc", etc.)
       (This handling of the fileName for multi-tile I/O is subject to change.)
     
</DD>
<DT><STRONG>[variableName]</STRONG></DT>
<DD>Variable name in the file; default is the "name" of Field.
      Use this argument only in the I/O format (such as NetCDF) that
      supports variable name. If the I/O format does not support this
      (such as binary format), ESMF will return an error code.
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Number of slices to be read from file, starting from the 1st slice
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Please see Section&nbsp;<A HREF="node9.html#opt:iofmtflag">54.28</A> for the list
      of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050366100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">61</SPAN> ESMF_FieldRedist - Execute a Field redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldRedist(srcField, dstField, routehandle,  &amp;
     checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),       intent(in),optional     :: srcField
         type(ESMF_Field),       intent(inout),optional  :: dstField
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field redistribution from <TT>srcField</TT> to
     <TT>dstField</TT>. 
     Both <TT>srcField</TT> and <TT>dstField</TT> must match the respective Fields
     used during <TT>ESMF_FieldRedistStore()</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
The <TT>srcField</TT> and <TT>dstField</TT> arguments are optional in support of
     the situation where <TT>srcField</TT> and/or <TT>dstField</TT> are not defined on
     all PETs. The <TT>srcField</TT> and <TT>dstField</TT> must be specified on those
     PETs that hold source or destination DEs, respectively, but may be omitted
     on all other PETs. PETs that hold neither source nor destination DEs may
     omit both arguments.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
See <TT>ESMF_FieldRedistStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentation regarding this method see Section
     <A HREF="#sec:field:usage:redist_1dptr">26.3.30</A>. 

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050366200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">62</SPAN> ESMF_FieldRedistRelease - Release resources associated with Field redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldRedistRelease(routehandle, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical,                intent(in),   optional  :: noGarbage
         integer,                intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with a Field redistribution. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050366300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">63</SPAN> ESMF_FieldRedistStore - Precompute Field redistribution with a local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldRedistStore() 
   subroutine ESMF_FieldRedistStore&lt;type&gt;&lt;kind&gt;(srcField, dstField, &amp; 
          routehandle, factor, srcToDstTransposeMap, &amp;
          ignoreUnmatchedIndices, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(in)            :: srcField  
     type(ESMF_Field),         intent(inout)         :: dstField  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factor 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(in),  optional :: srcToDstTransposeMap(:) 
     logical,                  intent(in),  optional :: ignoreUnmatchedIndices
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndices</TT> to support sparse 
                matrices that contain elements with indices that do not have a
                match within the source or destination Array.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="FieldRedistStoreTK"></A>   <TT>ESMF_FieldRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_FieldRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_FieldRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#FieldRedistStoreTK">26.6.63</A> and
   <A HREF="#FieldRedistStoreNF">26.6.64</A>, is described in the following paragraphs as a whole.

<P>
Store a Field redistribution operation from <TT>srcField</TT> to <TT>dstField</TT>.
   Interface <A HREF="#FieldRedistStoreTK">26.6.63</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="#FieldRedistStoreNF">26.6.64</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Field, destination Field, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Fields may differ in shape,
   however, the number of elements must match. 

<P>
The default redistribution operation, when <TT>srcToDstTransposeMap</TT> is not
   specified, corresponds to the identity mapping: each element of the
   sequentialized source Field is copied to the sequentialized
   destination Field element in order.

<P>
If the <TT>srcToDstTransposeMap</TT> argument is provided it must be identical
   across all PETs. The <TT>srcToDstTransposeMap</TT> allows source and destination
   Field dimensions to be transposed during the redistribution. To support this
   option, the number of source and destination Field dimensions must be equal
   and the size of the associated dimensions must match.
   See section <A HREF="#Array:Redist:TransposeMode">28.2.17</A> for more details about the
   use of the <TT>srcToDstTransposeMap</TT> argument.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
   <TT>dstField</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldRedist()</TT> on any pair of Fields that matches 
     <TT>srcField</TT> and <TT>dstField</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:field:usage:redist_1dptr">26.3.30</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multiply data. Default is 1. See full method
     description above for details on the interplay with other PETs.
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>A list with as many entries as there are dimensions in <TT>srcField</TT>, or
     <TT>tileCount</TT> times this many entries.
     Each entry maps the corresponding <TT>srcField</TT> dimension against the
     specified <TT>dstField</TT> dimension. Mixing distributed and
     undistributed dimensions is supported.
     Negative entries reverse the order of elements along the specified
     dimension when going from source to destination.
     When providing <!-- MATH
 $rank \times tileCount$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$rank \times tileCount$"></SPAN> elements in
     <TT>srcToDstTransposeMap</TT>,  each block of size <TT>rank</TT> is associated
     with the corresponding tile (in order), and interpreted as the
     tile-specific transpose map.
   
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when not all elements match
     between the <TT>srcField</TT> and <TT>dstField</TT> side. The default setting
     is <TT>.false.</TT>, indicating that it is an error when such a situation is 
     encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
     unmatched indices.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050366400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">64</SPAN> ESMF_FieldRedistStore - Precompute Field redistribution without a local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldRedistStore() 
     subroutine ESMF_FieldRedistStoreNF(srcField, dstField, &amp; 
         routehandle, srcToDstTransposeMap, &amp;
         ignoreUnmatchedIndices, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),       intent(in)            :: srcField  
         type(ESMF_Field),       intent(inout)         :: dstField  
         type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         integer,                intent(in), optional  :: srcToDstTransposeMap(:) 
         logical,                intent(in), optional  :: ignoreUnmatchedIndices
         integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="FieldRedistStoreNF"></A>   <TT>ESMF_FieldRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_FieldRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_FieldRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#FieldRedistStoreTK">26.6.63</A> and
   <A HREF="#FieldRedistStoreNF">26.6.64</A>, is described in the following paragraphs as a whole.

<P>
Store a Field redistribution operation from <TT>srcField</TT> to <TT>dstField</TT>.
   Interface <A HREF="#FieldRedistStoreTK">26.6.63</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="#FieldRedistStoreNF">26.6.64</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Field, destination Field, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Fields may differ in shape,
   however, the number of elements must match. 

<P>
The default redistribution operation, when <TT>srcToDstTransposeMap</TT> is not
   specified, corresponds to the identity mapping: each element of the
   sequentialized source Field is copied to the sequentialized
   destination Field element in order.

<P>
If the <TT>srcToDstTransposeMap</TT> argument is provided it must be identical
   across all PETs. The <TT>srcToDstTransposeMap</TT> allows source and destination
   Field dimensions to be transposed during the redistribution. To support this
   option, the number of source and destination Field dimensions must be equal
   and the size of the associated dimensions must match.
   See section <A HREF="#Array:Redist:TransposeMode">28.2.17</A> for more details about the
   use of the <TT>srcToDstTransposeMap</TT> argument.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
   <TT>dstField</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldRedist()</TT> on any pair of Fields that matches 
     <TT>srcField</TT> and <TT>dstField</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:field:usage:redist_1dptr">26.3.30</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>A list with as many entries as there are dimensions in <TT>srcField</TT>, or
     <TT>tileCount</TT> times this many entries.
     Each entry maps the corresponding <TT>srcField</TT> dimension against the
     specified <TT>dstField</TT> dimension. Mixing distributed and
     undistributed dimensions is supported.
     Negative entries reverse the order of elements along the specified
     dimension when going from source to destination.
     When providing <!-- MATH
 $rank \times tileCount$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$rank \times tileCount$"></SPAN> elements in
     <TT>srcToDstTransposeMap</TT>,  each block of size <TT>rank</TT> is associated
     with the corresponding tile (in order), and interpreted as the
     tile-specific transpose map.
   
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when not all elements match
     between the <TT>srcField</TT> and <TT>dstField</TT> side. The default setting
     is <TT>.false.</TT>, indicating that it is an error when such a situation is 
     encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
     unmatched indices.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050366500000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">65</SPAN> ESMF_FieldRegrid - Compute a regridding operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldRegrid(srcField, dstField, routehandle, &amp;
     zeroregion, termorderflag, checkflag, dynamicMask, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field),               intent(in),    optional :: srcField
       type(ESMF_Field),               intent(inout), optional :: dstField
       type(ESMF_RouteHandle),         intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Region_Flag),         intent(in),    optional :: zeroregion
       type(ESMF_TermOrder_Flag),      intent(in),    optional :: termorderflag
       logical,                        intent(in),    optional :: checkflag
       type(ESMF_DynamicMask), target, intent(in),    optional :: dynamicMask
       integer,                        intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>termorderflag</TT>.
                The new argument gives the user control over the order in which
                the src terms are summed up.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>dynamicMask</TT>.
                The new argument supports the dynamic masking feature.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute the precomputed regrid operation stored in <TT>routehandle</TT> to 
     interpolate from <TT>srcField</TT> to <TT>dstField</TT>.  See <TT>ESMF_FieldRegridStore()</TT> on how to 
     precompute the <TT>routehandle</TT>. 

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> must match the respective Fields
     used during <TT>ESMF_FieldRegridStore()</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
The <TT>srcField</TT> and <TT>dstField</TT> arguments are optional in support of
     the situation where <TT>srcField</TT> and/or <TT>dstField</TT> are not defined on
     all PETs. The <TT>srcField</TT> and <TT>dstField</TT> must be specified on those
     PETs that hold source or destination DEs, respectively, but may be omitted
     on all other PETs. PETs that hold neither source nor destination DEs may
     omit both arguments.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstField</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstField</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section <A HREF="node9.html#const:region">54.48</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[termorderflag]</STRONG></DT>
<DD>Specifies the order of the source side terms in all of the destination
       sums. The <TT>termorderflag</TT> only affects the order of terms during 
       the execution of the RouteHandle. See the <A HREF="#RH:bfb">37.2.1</A> section for an
       in-depth discussion of <EM>all</EM> bit-for-bit reproducibility
       aspects related to route-based communication methods.
       See <A HREF="node9.html#const:termorderflag">54.58</A> for a full list of options.
       The default setting depends on whether the <TT>dynamicMask</TT> argument
       is present or not. With <TT>dynamicMask</TT> argument present, the default
       of <TT>termorderflag</TT> is <TT>ESMF_TERMORDER_SRCSEQ</TT>. This ensures
       that <TT>all</TT> source terms are present on the destination side, and 
       the interpolation can be calculated as a single sum. When 
       <TT>dynamicMask</TT> is absent, the default of <TT>termorderflag</TT> is
       <TT>ESMF_TERMORDER_FREE</TT>, allowing maximum flexibility and partial 
       sums for optimum performance.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[dynamicMask]</STRONG></DT>
<DD>Object holding dynamic masking information.
       See section <A HREF="#RH:DynMask">37.2.6</A> for a discussion of dynamic masking.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050366600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">66</SPAN> ESMF_FieldRegridRelease - Free resources used by a regridding operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_FieldRegridRelease(routehandle, &amp;
         noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(in),  optional :: noGarbage
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with a regrid operation. After this call
       <TT>routehandle</TT> becomes invalid.

<P>
The arguments are:
       <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
       
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050366700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">67</SPAN> ESMF_FieldRegridStore - Precompute a Field regridding operation and return a RouteHandle and weights</A>
</H3>

<P>
<A NAME="api:esmf_fieldregridstorenx"></A>
<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   !   Private name; call using ESMF_FieldRegridStore()
       subroutine ESMF_FieldRegridStoreNX(srcField, dstField, &amp;
                     srcMaskValues, dstMaskValues, &amp;
                     regridmethod, &amp;
                     polemethod, regridPoleNPnts, &amp; 
                     lineType, &amp;
                     normType, &amp;
                     extrapMethod, &amp;
                     extrapNumSrcPnts, &amp;
                     extrapDistExponent, &amp;
                     extrapNumLevels, &amp;
                     unmappedaction, ignoreDegenerate, &amp;
                     srcTermProcessing, &amp; 
                     pipeLineDepth, &amp;
                     routehandle, &amp;
                     factorList, factorIndexList, &amp; 
                     weights, indices, &amp;  ! DEPRECATED ARGUMENTS
                     srcFracField, dstFracField, &amp;
                     dstStatusField, &amp;
                     unmappedDstList, &amp;
                     checkFlag, &amp;
                     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field),               intent(in)              :: srcField
       type(ESMF_Field),               intent(inout)           :: dstField
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),          intent(in),    optional :: srcMaskValues(:)
       integer(ESMF_KIND_I4),          intent(in),    optional :: dstMaskValues(:)
       type(ESMF_RegridMethod_Flag),   intent(in),    optional :: regridmethod
       type(ESMF_PoleMethod_Flag),     intent(in),    optional :: polemethod
       integer,                        intent(in),    optional :: regridPoleNPnts
       type(ESMF_LineType_Flag),       intent(in),    optional :: lineType
       type(ESMF_NormType_Flag),       intent(in),    optional :: normType
       type(ESMF_ExtrapMethod_Flag),   intent(in),    optional :: extrapMethod
       integer,                        intent(in),    optional :: extrapNumSrcPnts
       real(ESMF_KIND_R4),             intent(in),    optional :: extrapDistExponent
       integer,                        intent(in),    optional :: extrapNumLevels
       type(ESMF_UnmappedAction_Flag), intent(in),    optional :: unmappedaction
       logical,                        intent(in),    optional :: ignoreDegenerate
       integer,                        intent(inout), optional :: srcTermProcessing
       integer,                        intent(inout), optional :: pipeLineDepth
       type(ESMF_RouteHandle),         intent(inout), optional :: routehandle
       real(ESMF_KIND_R8),             pointer,       optional :: factorList(:)
       integer(ESMF_KIND_I4),          pointer,       optional :: factorIndexList(:,:)
       real(ESMF_KIND_R8),    pointer, optional :: weights(:)   ! DEPRECATED ARG
       integer(ESMF_KIND_I4), pointer, optional :: indices(:,:) ! DEPRECATED ARG
       type(ESMF_Field),               intent(inout), optional :: srcFracField
       type(ESMF_Field),               intent(inout), optional :: dstFracField
       type(ESMF_Field),               intent(inout), optional :: dstStatusField
       integer(ESMF_KIND_I4),          pointer,       optional :: unmappedDstList(:)
       logical,                        intent(in),    optional :: checkFlag
       integer,                        intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.2.0rp1</STRONG></DT>
<DD>Added arguments <TT>factorList</TT> and <TT>factorIndexList</TT>.
                   Started to deprecate arguments <TT>weights</TT> and <TT>indices</TT>.
                   This corrects an inconsistency of this interface with all
                   other ESMF methods that take these same arguments.
   
</DD>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added arguments <TT>ignoreDegenerate</TT>, <TT>srcTermProcessing</TT>,
                <TT>pipelineDepth</TT>, and <TT>unmappedDstList</TT>.
                The argument <TT>ignoreDegenerate</TT> allows the user to skip degenerate
                cells in the regridding instead of stopping with an error.
                The two arguments <TT>srcTermProcessing</TT> and <TT>pipelineDepth</TT>
                provide access to the tuning parameters affecting the sparse matrix
                execution. The argument <TT>unmappedDstList</TT> allows the user to
                get a list of the destination items which the regridding couldn't
                map to a source.
   
</DD>
<DT><STRONG>6.3.0r</STRONG></DT>
<DD>Added argument <TT>lineType</TT>. This argument allows the user to
                 control the path of the line between two points on a sphere surface.
                 This allows the user to use their preferred line path for the calculation
                 of distances and the shape of cells during regrid weight calculation on
                 a sphere.
   
</DD>
<DT><STRONG>6.3.0rp1</STRONG></DT>
<DD>Added argument <TT>normType</TT>. This argument allows the user to
                 control the type of normalization done during conservative weight generation.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>dstStatusField</TT>. This argument allows the user to
                receive information about what happened to each location in the destination
                Field during regridding.

<P>
Added arguments <TT>extrapMethod</TT>, <TT>extrapNumSrcPnts</TT>, and
                <TT>extrapDistExponent</TT>. These three new extrapolation arguments allow the 
                user to extrapolate destination points not mapped by the regrid method. 
                <TT>extrapMethod</TT> allows the user to choose the extrapolation method.
                <TT>extrapNumSrcPnts</TT> and <TT>extrapDistExponent</TT> are parameters that
                allow the user to tune the behavior of the <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT> 
                method.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>extrapNumLevels</TT>. For level based extrapolation methods
                (e.g. <TT>ESMF_EXTRAPMETHOD_CREEP</TT>) this argument allows the user to
                set how many levels to extrapolate. 

<P>
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>checkFlag</TT> to enable the user to turn on more
                expensive error checking during regrid weight calculation. 

<P>
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a sparse matrix operation (stored in <TT>routehandle</TT>) that 
         contains the calculations and communications necessary to interpolate
         from <TT>srcField</TT> to <TT>dstField</TT>. The routehandle can then be 
         used in the call <TT>ESMF_FieldRegrid()</TT> to interpolate between the
         Fields. The user may also get the interpolation matrix in sparse 
         matrix form via the optional arguments <TT>factorList</TT> and <TT>factorIndexList</TT>.

<P>
The routehandle generated by this call is based just on the 
         coordinates in the spatial class (e.g. Grid) contained in the Fields.  If those
         coordinates don't change the routehandle can
         be used repeatedly to interpolate from the source Field to the 
         destination Field.  This is true even if the data in the Fields 
         changes. The routehandle may also be used to interpolate between any
         source and destination Field which are created on the same location 
         in the same Grid, LocStream, XGrid, or Mesh as the original Fields.        

<P>
When it's no longer needed the routehandle should be destroyed by 
         using <TT>ESMF_FieldRegridRelease()</TT> to free the memory it's using. 

<P>
Note, as a side effect, that this call may change the data in <TT>dstField</TT>. If
         this is undesirable, then an easy work around is to create a second temporary field
         with the same structure as <TT>dstField</TT> and pass that in instead. 

<P>
The arguments are:
       <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD>Source Field.
       
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>Destination Field. The data in this Field may be overwritten by this call. 
       
</DD>
<DT><STRONG>[srcMaskValues]</STRONG></DT>
<DD>Mask information can be set in the Grid (see&nbsp;<A HREF="#sec:usage:items">31.3.17</A>) or Mesh (see&nbsp;<A HREF="#sec:mesh:mask">33.3.11</A>) 
             upon which the <TT>srcField</TT> is built. The <TT>srcMaskValues</TT> argument specifies the values in that 
             mask information which indicate a source point should be masked out. In other words, a locati on is masked if and only if the
             value for that location in the mask information matches one of the values listed in <TT>srcMaskValues</TT>.  
             If <TT>srcMaskValues</TT> is not specified, no masking will occur. 
       
</DD>
<DT><STRONG>[dstMaskValues]</STRONG></DT>
<DD>Mask information can be set in the Grid (see&nbsp;<A HREF="#sec:usage:items">31.3.17</A>) or Mesh (see&nbsp;<A HREF="#sec:mesh:mask">33.3.11</A>) 
             upon which the <TT>dstField</TT> is built. The <TT>dstMaskValues</TT> argument specifies the values in that 
             mask information which indicate a destination point should be masked out. In other words, a location is masked if and only if the
             value for that location in the mask information matches one of the values listed in <TT>dstMaskValues</TT>.  
             If <TT>dstMaskValues</TT> is not specified, no masking will occur. 
       
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. Please see Section&nbsp;<A HREF="node9.html#opt:regridmethod">54.49</A> 
             for a list of valid options. If not specified, defaults to 
             <TT>ESMF_REGRIDMETHOD_BILINEAR</TT>.
       
</DD>
<DT><STRONG>[polemethod]</STRONG></DT>
<DD>Specifies the type of pole
             to construct on the source Grid during regridding. Please see 
             Section&nbsp;<A HREF="node9.html#const:polemethod">54.46</A> for a list of
             valid options. If not specified, defaults to <TT>ESMF_POLEMETHOD_ALLAVG</TT> for non-conservative regrid methods, 
             and <TT>ESMF_POLEMETHOD_NONE</TT> for conservative methods.
       
</DD>
<DT><STRONG>[regridPoleNPnts]</STRONG></DT>
<DD>If <TT>polemethod</TT> is <TT>ESMF_POLEMETHOD_NPNTAVG</TT>,
             then this parameter indicates the number of points over which to average.
             If <TT>polemethod</TT> is not ESMF_POLEMETHOD_NPNTAVG and <TT>regridPoleNPnts</TT> is specified, 
             then it will be ignored.  
             This subroutine will return an error if <TT>polemethod</TT> is ESMF_POLEMETHOD_NPNTAVG and 
             <TT>regridPoleNPnts</TT> is not specified. 
       
</DD>
<DT><STRONG>[lineType]</STRONG></DT>
<DD>This argument controls the path of the line which connects two points on a sphere surface. This in
             turn controls the path along which distances are calculated and the shape of the edges that make
             up a cell. Both of these quantities can influence how interpolation weights are calculated.
             As would be expected, this argument is only applicable when <TT>srcField</TT> and <TT>dstField</TT> are
             built on grids which lie on the surface of a sphere. Section&nbsp;<A HREF="node9.html#opt:lineType">54.34</A> shows a 
             list of valid options for this argument. Figure&nbsp;<A HREF="#line_type_support">24.2.16</A> shows
             which line types are supported for each regrid method as well as showing the default line type by regrid method.
             If not specified, defaults to <TT>ESMF_LINETYPE_CART</TT> for non-conservative regrid methods, 
             and <TT>ESMF_LINETYPE_GREAT_CIRCLE</TT> for conservative methods.

<P>
</DD>
<DT><STRONG>[normType]</STRONG></DT>
<DD>This argument controls the type of normalization used when generating conservative weights. This option
             only applies to weights generated with <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE</TT> or  <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE_2ND</TT>
             Please see  Section&nbsp;<A HREF="node9.html#opt:normType">54.43</A> for a 
             list of valid options. If not specified <TT>normType</TT> defaults to <TT>ESMF_NORMTYPE_DSTAREA</TT>. 
       
</DD>
<DT><STRONG>[extrapMethod]</STRONG></DT>
<DD>The type of extrapolation. Please see Section&nbsp;<A HREF="node9.html#opt:extrapmethod">54.17</A> 
             for a list of valid options. If not specified, defaults to 
             <TT>ESMF_EXTRAPMETHOD_NONE</TT>.
       
</DD>
<DT><STRONG>[extrapNumSrcPnts]</STRONG></DT>
<DD>The number of source points to use for the extrapolation methods that use more than one source point 
             (e.g. <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT>). If not specified, defaults to 8.
       
</DD>
<DT><STRONG>[extrapDistExponent]</STRONG></DT>
<DD>The exponent to raise the distance to when calculating weights for 
             the <TT>ESMF_EXTRAPMETHOD_NEAREST_IDAVG</TT> extrapolation method. A higher value reduces the influence 
             of more distant points. If not specified, defaults to 2.0.
       
</DD>
<DT><STRONG>[extrapNumLevels]</STRONG></DT>
<DD>The number of levels to output for the extrapolation methods that fill levels
             (e.g. <TT>ESMF_EXTRAPMETHOD_CREEP</TT>). When a method is used that requires this, then an error will be returned, if it 
             is not specified.
       
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Please see Section&nbsp;<A HREF="node9.html#const:unmappedaction">54.60</A> for a 
             list of valid options. If not specified, <TT>unmappedaction</TT> defaults to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. 
       
</DD>
<DT><STRONG>[ignoreDegenerate]</STRONG></DT>
<DD>Ignore degenerate cells when checking for errors. If this is set to true, then the 
             regridding proceeds, but degenerate cells will be skipped. If set to false, a degenerate cell produces an error. 
             If not specified, <TT>ignoreDegenerate</TT> defaults to false.
       
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
             located on the same PET and summing into the same destination element,
             are summed into partial sums on the source PET before being transferred
             to the destination PET. A value of 0 indicates that the entire arithmetic
             is done on the destination PET; source elements are neither multiplied 
             by their factors nor added into partial sums before being sent off by the
             source PET. A value of 1 indicates that source elements are multiplied
             by their factors on the source side before being sent to the destination
             PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
             of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_FieldRegridStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the 
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_FieldRegridStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.
       
</DD>
<DT><STRONG>[routehandle]</STRONG></DT>
<DD>The communication handle that implements the regrid operation and that can be used later in 
             the <TT>ESMF_FieldRegrid()</TT> call. The <TT>routehandle</TT> is optional so that if the 
             user doesn't need it, then they can indicate that by not requesting it. 
             The time to compute the <TT>routehandle</TT> can be a significant fraction of the time 
             taken by this method, so if it's not needed then not requesting it is worthwhile.  
       
</DD>
<DT><STRONG>[factorList]</STRONG></DT>
<DD>The list of coefficients for a sparse matrix which interpolates from <TT>srcField</TT> to 
             <TT>dstField</TT>. The array coming out of this variable is in the appropriate format to be used
             in other ESMF sparse matrix multiply calls, for example <TT>ESMF_FieldSMMStore()</TT>. 
             The <TT>factorList</TT> array is allocated by the method and the user is responsible for 
             deallocating it. 
       
</DD>
<DT><STRONG>[factorIndexList]</STRONG></DT>
<DD>The indices for a sparse matrix which interpolates from <TT>srcField</TT> to 
             <TT>dstField</TT>. This argument is a 2D array containing pairs of source and destination
             sequence indices corresponding to the coefficients in the <TT>factorList</TT> argument. 
             The first dimension of <TT>factorIndexList</TT> is of size 2. <TT>factorIndexList(1,:)</TT> specifies 
             the sequence index of the source element in the <TT>srcField</TT>. <TT>factorIndexList(2,:)</TT> specifies 
             the sequence index of the destination element in the <TT>dstField</TT>. The se cond dimension of 
             <TT>factorIndexList</TT> steps through the list of pairs, i.e. <TT>size(factorIndexList,2)==size(factorList)</TT>.
             The array coming out of this variable is in the appropriate format to be used
             in other ESMF sparse matrix multiply calls, for example <TT>ESMF_FieldSMMStore()</TT>. 
             The <TT>factorIndexList</TT> array is allocated by the method and the user is responsible for deallocating it. 
       
</DD>
<DT><STRONG>[weights]</STRONG></DT>
<DD><B>DEPRECATED ARGUMENT!</B> Please use the argument <TT>factorList</TT> instead.
       
</DD>
<DT><STRONG>[indices]</STRONG></DT>
<DD><B>DEPRECATED ARGUMENT!</B> Please use the argument <TT>factorIndexList</TT> instead.
       
</DD>
<DT><STRONG>[srcFracField]</STRONG></DT>
<DD>The fraction of each source cell participating in the regridding. Only 
             valid when regridmethod is <TT>ESMF_REGRIDMETHOD_CONSERVE</TT> or  <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE_2ND</TT>.
             This Field needs to be created on the same location (e.g staggerloc) 
             as the srcField.
       
</DD>
<DT><STRONG>[dstFracField]</STRONG></DT>
<DD>The fraction of each destination cell participating in the regridding. Only 
             valid when regridmethod is <TT>ESMF_REGRIDMETHOD_CONSERVE</TT> or  <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE_2ND</TT>.
             This Field needs to be created on the same location (e.g staggerloc) 
             as the dstField. It is important to note that the current implementation
             of conservative regridding doesn't normalize the interpolation weights by the destination fraction. This   means that for a destination
             grid which only partially overlaps the source grid the destination field which is output from the 
             regrid operation should be divided by the corresponding destination fraction to yield the 
             true interpolated values for cells which are only partially covered by the  source grid. 
       
</DD>
<DT><STRONG>[dstStatusField]</STRONG></DT>
<DD>An ESMF Field which outputs a regrid status value for each destination location.
             Section&nbsp;<A HREF="node9.html#opt:regridstatus">54.50</A> indicates the meaning of each value. The Field needs to 
             be built on the same location (e.g. staggerloc) in the same Grid, Mesh, XGrid, or LocStream as the <TT>dstField</TT> argument. 
             The Field also needs to be of typekind <TT>ESMF_TYPEKIND_I4</TT>.  This option currently doesn't work with 
             the <TT>ESMF_REGRIDMETHOD_NEAREST_DTOS</TT> regrid method.
       
</DD>
<DT><STRONG>[unmappedDstList]</STRONG></DT>
<DD>The list of the sequence indices for locations in <TT>dstField</TT> which couldn't be mapped the <TT>srcField</TT>. 
             The list on each PET only contains the unmapped locations for the piece of the <TT>dstField</TT> on that PET. 
             If a destination point is masked, it won't be put in this list. This option currently doesn't work with 
             the <TT>ESMF_REGRIDMETHOD_NEAREST_DTOS</TT> regrid method.
        
</DD>
<DT><STRONG>[checkFlag]</STRONG></DT>
<DD>If set to <TT>.FALSE.</TT> <EM>(default)</EM> only quick error checking
         will be performed. If set to <TT>.TRUE.</TT> more expensive error checking
         will be performed, possibly catching more errors. Set
         <TT>checkFlag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
         The checkFlag currently only turns on checking for conservative regrid methods 
         (e.g. <TT>ESMF_REGRIDMETHOD_CONSERVE</TT>). 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050366800000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">68</SPAN> ESMF_FieldRegridStore - Precompute a Field regridding operation between an XGrid and one of its side Grids or Meshes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   !   Private name; call using ESMF_FieldRegridStore()
     subroutine ESMF_FieldRegridStoreX(xgrid, srcField, dstField, &amp;
                     regridmethod, &amp;
                     srcTermProcessing, pipeLineDepth, &amp;
                     routehandle, &amp;
                     srcFracField, dstFracField, &amp;
                     srcMergeFracField, dstMergeFracField, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_XGrid),       intent(in)                      :: xgrid
       type(ESMF_Field),       intent(in)                      :: srcField
       type(ESMF_Field),       intent(inout)                   :: dstField
       type(ESMF_KeywordEnforcer), optional                    :: keywordEnforcer ! must use keywords below
       type(ESMF_RegridMethod_Flag),   intent(in),    optional :: regridmethod
       integer,                        intent(inout), optional :: srcTermProcessing
       integer,                        intent(inout), optional :: pipeLineDepth
       type(ESMF_RouteHandle), intent(inout), optional         :: routehandle
       type(ESMF_Field),       intent(inout), optional         :: srcFracField
       type(ESMF_Field),       intent(inout), optional         :: dstFracField
       type(ESMF_Field),       intent(inout), optional         :: srcMergeFracField
       type(ESMF_Field),       intent(inout), optional         :: dstMergeFracField
       integer,                intent(out),   optional         :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.3.0</STRONG></DT>
<DD>Added arguments <TT>srcFracField</TT>, <TT>dstFracField</TT>, <TT>srcMergeFracField</TT>, and <TT>dstMergeFracField</TT>.
   These fraction Fields allow a user to calculate correct flux regridded through <TT>ESMF_XGrid</TT>.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>regridmethod</TT>. This new argument allows the user to choose the regrid method
                 to apply when computing the routehandle. 
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a RouteHandle to do conservative interpolation specifically between a
         Field built on an XGrid and a Field build on one of the Grids or Meshes used to create that XGrid. 
         (To do more general interpolation use the <TT>ESMF_FieldRegridStore()</TT> method
         in section&nbsp;<A HREF="#api:esmf_fieldregridstorenx">26.6.67</A>.) The RouteHandle produced by this method can then be used in the call
         <TT>ESMF_FieldRegrid()</TT> to interpolate from the <TT>srcField</TT> to the <TT>dstField</TT>.

<P>
The RouteHandle generated by this call is based just on the 
         coordinates in the Grids, XGrids, or Meshes contained in the Fields.  If those
         coordinates don't change the RouteHandle can
         be used repeatedly to interpolate from the source Field to the 
         destination Field.  This is true even if the data in the Fields 
         changes. The RouteHandle may also be used to interpolate between any
         source and destination Field which are created 
         on the same Grid, XGrid, or Mesh as the original Fields.        

<P>
When it's no longer needed the RouteHandle should be destroyed by 
         using <TT>ESMF_FieldRegridRelease()</TT> to free the memory it's using. 

<P>
Note, as a side effect, that this call may change the data in <TT>dstField</TT>. If
         this is undesirable, then an easy work around is to create a second temporary Field
         with the same structure as <TT>dstField</TT> and pass that in instead. 

<P>
The arguments are:
       <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>Exchange Grid.
       
</DD>
<DT><STRONG>srcField</STRONG></DT>
<DD>Source Field built on either <TT>xgrid</TT> or one of the Grids or Meshes used to create <TT>xgrid</TT>.
       
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>Destination Field built on either <TT>xgrid</TT> or one of the Grids or Meshes used to create <TT>xgrid</TT>. 
             The data in this Field may be overwritten by this call. 
       
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. For this method only 
             <TT>ESMF_REGRIDMETHOD_CONSERVE</TT> and <TT>ESMF_REGRIDMETHOD_CONSERVE_2ND</TT> are
             supported. If not specified, defaults to <TT>ESMF_REGRIDMETHOD_CONSERVE</TT>.
       
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
             located on the same PET and summing into the same destination element,
             are summed into partial sums on the source PET before being transferred
             to the destination PET. A value of 0 indicates that the entire arithmetic
             is done on the destination PET; source elements are neither multiplied 
             by their factors nor added into partial sums before being sent off by the
             source PET. A value of 1 indicates that source elements are multiplied
             by their factors on the source side before being sent to the destination
             PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
             of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_FieldRegridStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the 
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_FieldRegridStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.
       
</DD>
<DT><STRONG>[routehandle]</STRONG></DT>
<DD>The handle that implements the regrid and that can be used in later 
             <TT>ESMF_FieldRegrid</TT>.
       
</DD>
<DT><STRONG>[srcFracField]</STRONG></DT>
<DD>The fraction of each source cell participating in the regridding returned from this call. 
             This Field needs to be created on the same Grid and location (e.g staggerloc) 
             as the srcField.
       
</DD>
<DT><STRONG>[dstFracField]</STRONG></DT>
<DD>The fraction of each destination cell participating in the regridding returned from this call. 
             This Field needs to be created on the same Grid and location (e.g staggerloc) 
             as the dstField.
       
</DD>
<DT><STRONG>[srcMergeFracField]</STRONG></DT>
<DD>The fraction of each source cell as a result of Grid merge returned from this call.
             This Field needs to be created on the same Grid and location (e.g staggerloc) 
             as the srcField.
       
</DD>
<DT><STRONG>[dstMergeFracField]</STRONG></DT>
<DD>The fraction of each destination cell as a result of Grid merge returned from this call.
             This Field needs to be created on the same Grid and location (e.g staggerloc) 
             as the dstField.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050366900000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">69</SPAN> ESMF_FieldRegridGetArea - Get the area of the cells used for conservative interpolation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_FieldRegridGetArea(areaField, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field), intent(inout)                 :: areaField
       integer, intent(out), optional                  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine gets the area of the cells used for conservative interpolation for the grid object 
       associated with <TT>areaField</TT> and puts them into <TT>areaField</TT>. If created on a 2D Grid, it must 
       be built on the <TT>ESMF_STAGGERLOC_CENTER</TT> stagger location. 
       If created on a 3D Grid, it must be built on the <TT>ESMF_STAGGERLOC_CENTER_VCENTER</TT> stagger 
       location. If created on a Mesh, it must be built on the <TT>ESMF_MESHLOC_ELEMENT</TT> mesh location. 

<P>
If the user has set the area in the Grid, Mesh, or XGrid under <TT>areaField</TT>, then that's the area that's
       returned in the units that the user set it in. If the user hasn't set the area, then the area is 
       calculated and returned. If the Grid, Mesh, or XGrid is on the surface of a sphere, then the calculated area is in
       units of square radians. If the Grid, Mesh, or XGrid is 
       Cartesian, then the calculated area is in square units of whatever unit the coordinates are in. 

<P>
The arguments are:
       <DL>
<DT><STRONG>areaField</STRONG></DT>
<DD>The Field to put the area values in. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050367000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">70</SPAN> ESMF_FieldScatter - Scatter a Fortran array across the ESMF_Field </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldScatter&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, farray, &amp; 
   rootPet, tile, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   mtype (ESMF_KIND_mtypekind),intent(in), target :: farray(mdim) 
   integer, intent(in) :: rootPet 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: tile 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Scatter the data of <TT>farray</TT> located on <TT>rootPET</TT> 
   across an ESMF_Field object. A single <TT>farray</TT> must be 
   scattered across a single DistGrid tile in Field. The optional <TT>tile</TT> 
   argument allows selection of the tile. For Fields defined on a single 
   tile DistGrid the default selection (tile 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the tile in Field. 

<P>
If the Field contains replicating DistGrid dimensions data will be 
   scattered across all of the replicated pieces. 

<P>
The implementation of Scatter and Gather is not sequence index based. 
   If the Field is built on arbitrarily distributed Grid, Mesh, LocStream or XGrid, 
   Scatter will not scatter data from rootPet 
   to the destination data points corresponding to the sequence index on the rootPet. 
   Instead Scatter will scatter a contiguous memory range from rootPet to 
   destination PET. The size of the memory range is equal to the number of 
   data elements on the destination PET. Vice versa for the Gather operation. 
   In this case, the user should use <TT>ESMF_FieldRedist</TT> to achieve 
   the same data operation result. For examples how to use <TT>ESMF_FieldRedist</TT> 
   to perform Gather and Scatter, please refer to 
   <A HREF="#sec:field:usage:redist_gathering">26.3.32</A> and 
   <A HREF="#sec:field:usage:redist_scattering">26.3.31</A>. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
For examples and associated documentation regarding this method see Section 
   <A HREF="#sec:field:usage:scatter_2dptr">26.3.29</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object across which data will be scattered. 
   
</DD>
<DT><STRONG>{farray}</STRONG></DT>
<DD>The Fortran array that is to be scattered. Only root 
   must provide a valid <TT>farray</TT>, the other PETs may treat 
   <TT>farray</TT> as an optional argument. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid data in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The DistGrid tile in <TT>field</TT> into which to scatter <TT>farray</TT>. 
   By default <TT>farray</TT> will be scattered into tile 1. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050367100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">71</SPAN> ESMF_FieldSet - Set object-wide Field information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldSet(field, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),   intent(inout)         :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len = *), intent(in),  optional :: name
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets adjustable settings in an <TT>ESMF_Field</TT> object. 

<P>
The arguments are:
       <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object for which to set properties.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The Field name.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050367200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">72</SPAN> ESMF_FieldSync - Synchronize DEs across the Field in case of sharing</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldSync(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Synchronizes access to DEs across <TT>field</TT> to make sure PETs correctly
       access the data for read and write when DEs are shared. 

<P>
The arguments are:
       <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Specified <TT>ESMF_Field</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050367300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">73</SPAN> ESMF_FieldSMM - Execute a Field sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldSMM(srcField, dstField, routehandle, &amp;
              zeroregion, termorderflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),          intent(in),    optional  :: srcField
         type(ESMF_Field),          intent(inout), optional  :: dstField
         type(ESMF_RouteHandle),    intent(inout)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         type(ESMF_Region_Flag),    intent(in),    optional  :: zeroregion
         type(ESMF_TermOrder_Flag), intent(in),    optional  :: termorderflag
         logical,                   intent(in),    optional  :: checkflag
         integer,                   intent(out),   optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>termorderflag</TT>.
                The new argument gives the user control over the order in which
                the src terms are summed up.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field sparse matrix multiplication from <TT>srcField</TT> to
     <TT>dstField</TT>. 
     Both <TT>srcField</TT> and <TT>dstField</TT> must match the respective Fields
     used during <TT>ESMF_FieldSMMStore()</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
The <TT>srcField</TT> and <TT>dstField</TT> arguments are optional in support of
     the situation where <TT>srcField</TT> and/or <TT>dstField</TT> are not defined on
     all PETs. The <TT>srcField</TT> and <TT>dstField</TT> must be specified on those
     PETs that hold source or destination DEs, respectively, but may be omitted
     on all other PETs. PETs that hold neither source nor destination DEs may
     omit both arguments.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
See <TT>ESMF_FieldSMMStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentation regarding this method see Section
     <A HREF="#sec:field:usage:smm_1dptr">26.3.33</A>. 

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstField</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstField</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Field that will be updated by the sparse matrix
       multiplication. See section <A HREF="node9.html#const:region">54.48</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[termorderflag]</STRONG></DT>
<DD>Specifies the order of the source side terms in all of the destination
       sums. The <TT>termorderflag</TT> only affects the order of terms during
       the execution of the RouteHandle. See the <A HREF="#RH:bfb">37.2.1</A> section for an
       in-depth discussion of <EM>all</EM> bit-for-bit reproducibility
       aspects related to route-based communication methods.
       See <A HREF="node9.html#const:termorderflag">54.58</A> for a full list of options.
       The default is <TT>ESMF_TERMORDER_FREE</TT>, allowing maximum flexibility
       in the order of terms for optimum performance.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050367400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">74</SPAN> ESMF_FieldSMMRelease - Release resources associated with Field </A>
</H3>

<P>
sparse matrix multiplication

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldSMMRelease(routehandle, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical,                intent(in),   optional  :: noGarbage
         integer,                intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with a Field sparse matrix multiplication. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050367500000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">75</SPAN> ESMF_FieldSMMStore - Precompute Field sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore() 
   subroutine ESMF_FieldSMMStore&lt;type&gt;&lt;kind&gt;(srcField, dstField, &amp; 
          routehandle, factorList, factorIndexList, &amp;
          ignoreUnmatchedIndices, srcTermProcessing, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(in)              :: srcField  
     type(ESMF_Field),         intent(inout)           :: dstField  
     type(ESMF_RouteHandle),   intent(inout)           :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)              :: factorList(:) 
     integer,                  intent(in),             :: factorIndexList(:,:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                  intent(in),    optional :: ignoreUnmatchedIndices
     integer,                  intent(inout), optional :: srcTermProcessing
     integer,                  intent(inout), optional :: pipeLineDepth
     integer,                  intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added arguments <TT>srcTermProcessing</TT>, <TT>pipelineDepth</TT>
                The two arguments <TT>srcTermProcessing</TT> and <TT>pipelineDepth</TT>
                provide access to the tuning parameters affecting the sparse matrix
                execution. 
   
</DD>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>transposeRoutehandle</TT> to allow a handle to
                the transposed matrix operation to be returned.
<BR>
Added argument <TT>ignoreUnmatchedIndices</TT> to support sparse 
                matrices that contain elements with indices that do not have a
                match within the source or destination Array.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Removed argument <TT>transposeRoutehandle</TT> and provide it
                via interface overloading instead. This allows argument 
                <TT>srcField</TT> to stay strictly intent(in) for this entry point.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a Field sparse matrix multiplication operation from <TT>srcField</TT>
   to <TT>dstField</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source Field vector to 
   the destination Field vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical Field object for srcField and dstField 
   arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldSMM()</TT> on any pair of Fields that matches 
     <TT>srcField</TT> and <TT>dstField</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:field:usage:smm_1dptr">26.3.33</A>. 

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.

<P>
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.

<P>
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.
       
       The second dimension of <TT>factorIndexList</TT> steps through the list of

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcField</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstField</TT>. For this format to be a valid
       option source and destination Fields must have matching number of
       tensor elements (the product of the sizes of all Field tensor dimensions).
       Under this condition an identity matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcField</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstField</TT>.

<P>
See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of 
       Field <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       <TT>srcField</TT> or <TT>dstField</TT> side. The default setting is 
       <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050367600000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">76</SPAN> ESMF_FieldSMMStore - Precompute Field sparse matrix multiplication and transpose with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore() 
   subroutine ESMF_FieldSMMStore&lt;type&gt;&lt;kind&gt;TR(srcField, dstField, &amp; 
          routehandle, transposeRoutehandle, factorList, factorIndexList, &amp;
          ignoreUnmatchedIndices, srcTermProcessing, &amp;
          pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(inout)           :: srcField  
     type(ESMF_Field),         intent(inout)           :: dstField  
     type(ESMF_RouteHandle),   intent(inout)           :: routehandle
     type(ESMF_RouteHandle),   intent(inout)           :: transposeRoutehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)              :: factorList(:) 
     integer,                  intent(in),             :: factorIndexList(:,:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                  intent(in),    optional :: ignoreUnmatchedIndices
     integer,                  intent(inout), optional :: srcTermProcessing
     integer,                  intent(inout), optional :: pipeLineDepth
     integer,                  intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a Field sparse matrix multiplication operation from <TT>srcField</TT>
   to <TT>dstField</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source Field vector to 
   the destination Field vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical Field object for srcField and dstField 
   arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldSMM()</TT> on any pair of Fields that matches 
     <TT>srcField</TT> and <TT>dstField</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:field:usage:smm_1dptr">26.3.33</A>. 

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>transposeRoutehandle</STRONG></DT>
<DD>A handle to the transposed matrix operation is returned. The
       transposed operation goes from <TT>dstArray</TT> to <TT>srcArray</TT>.

<P>
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.

<P>
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.
       
       The second dimension of <TT>factorIndexList</TT> steps through the list of

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcField</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstField</TT>. For this format to be a valid
       option source and destination Fields must have matching number of
       tensor elements (the product of the sizes of all Field tensor dimensions).
       Under this condition an identity matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcField</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstField</TT>.

<P>
See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of 
       Field <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       <TT>srcField</TT> or <TT>dstField</TT> side. The default setting is 
       <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050367700000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">77</SPAN> ESMF_FieldSMMStore - Precompute Field sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore() 
     subroutine ESMF_FieldSMMStoreNF(srcField, dstField, &amp;
         routehandle, ignoreUnmatchedIndices, &amp;
         srcTermProcessing, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),       intent(in)              :: srcField  
         type(ESMF_Field),       intent(inout)           :: dstField  
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical,                intent(in),    optional :: ignoreUnmatchedIndices
         integer,                intent(inout), optional :: srcTermProcessing
         integer,                intent(inout), optional :: pipeLineDepth
         integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added arguments <TT>srcTermProcessing</TT>, <TT>pipelineDepth</TT>
                The two arguments <TT>srcTermProcessing</TT> and <TT>pipelineDepth</TT>
                provide access to the tuning parameters affecting the sparse matrix
                execution. 
   
</DD>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>transposeRoutehandle</TT> to allow a handle to
                the transposed matrix operation to be returned.
<BR>
Added argument <TT>ignoreUnmatchedIndices</TT> to support sparse 
                matrices that contain elements with indices that do not have a
                match within the source or destination Array.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Removed argument <TT>transposeRoutehandle</TT> and provide it
                via interface overloading instead. This allows argument 
                <TT>srcField</TT> to stay strictly intent(in) for this entry point.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a Field sparse matrix multiplication operation from <TT>srcField</TT>
   to <TT>dstField</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source Field vector to 
   the destination Field vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical Field object for srcField and dstField 
   arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldSMM()</TT> on any pair of Fields that matches 
     <TT>srcField</TT> and <TT>dstField</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:field:usage:smm_1dptr">26.3.33</A>. 

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.

<P>
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       <TT>srcField</TT> or <TT>dstField</TT> side. The default setting is 
       <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050367800000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">78</SPAN> ESMF_FieldSMMStore - Precompute Field sparse matrix multiplication and transpose without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore() 
     subroutine ESMF_FieldSMMStoreNFTR(srcField, dstField, &amp;
         routehandle, transposeRoutehandle, ignoreUnmatchedIndices, &amp;
         srcTermProcessing, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),       intent(inout)           :: srcField  
         type(ESMF_Field),       intent(inout)           :: dstField  
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
         type(ESMF_RouteHandle), intent(inout)           :: transposeRoutehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical,                intent(in),    optional :: ignoreUnmatchedIndices
         integer,                intent(inout), optional :: srcTermProcessing
         integer,                intent(inout), optional :: pipeLineDepth
         integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store a Field sparse matrix multiplication operation from <TT>srcField</TT>
   to <TT>dstField</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source Field vector to 
   the destination Field vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical Field object for srcField and dstField 
   arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldSMM()</TT> on any pair of Fields that matches 
     <TT>srcField</TT> and <TT>dstField</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>gridded</EM> dimensions. However, the size, number, 
     and index order of <EM>ungridded</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentation regarding this method see Section
   <A HREF="#sec:field:usage:smm_1dptr">26.3.33</A>. 

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. The data in this Field may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>transposeRoutehandle</STRONG></DT>
<DD>A handle to the transposed matrix operation is returned. The
       transposed operation goes from <TT>dstArray</TT> to <TT>srcArray</TT>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       <TT>srcField</TT> or <TT>dstField</TT> side. The default setting is 
       <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050367900000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">79</SPAN> ESMF_FieldSMMStore - Precompute sparse matrix multiplication using factors read from file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore()
     subroutine ESMF_FieldSMMStoreFromFile(srcField, dstField, filename, &amp;
       routehandle, ignoreUnmatchedIndices, &amp;
       srcTermProcessing, pipelineDepth, rc)
 
   ! ARGUMENTS:
       type(ESMF_Field),       intent(in)              :: srcField  
       type(ESMF_Field),       intent(inout)           :: dstField
       character(len=*),       intent(in)              :: filename
       type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(in),    optional :: ignoreUnmatchedIndices
       integer,                intent(inout), optional :: srcTermProcessing
       integer,                intent(inout), optional :: pipeLineDepth
       integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute an <TT>ESMF_RouteHandle</TT> using factors read from file.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.

<P>
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
         destroyed by this call.

<P>
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Path to the file containing weights for creating an <TT>ESMF_RouteHandle</TT>.
         See&nbsp;(<A HREF="node3.html#sec:weightfileformat">12.9</A>) for a description of the SCRIP weight
         file format. Only "row", "col", and "S" variables are required. They
         must be one-dimensionsal with dimension "n_s".

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the <TT>ESMF_RouteHandle</TT>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices
       in the sparse matrix are encountered that do not have a match on the
       <TT>srcField</TT> or <TT>dstField</TT> side. The default setting is
       <TT>.false.</TT>, indicating that it is an error when such a situation is
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
       The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050368000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">80</SPAN> ESMF_FieldSMMStore - Precompute sparse matrix multiplication and transpose using factors read from file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore()
     subroutine ESMF_FieldSMMStoreFromFileTR(srcField, dstField, filename, &amp;
       routehandle, transposeRoutehandle, &amp;
       ignoreUnmatchedIndices, srcTermProcessing, pipelineDepth, rc)
 
   ! ARGUMENTS:
       type(ESMF_Field),       intent(inout)           :: srcField  
       type(ESMF_Field),       intent(inout)           :: dstField
       character(len=*),       intent(in)              :: filename
       type(ESMF_RouteHandle), intent(inout)           :: routehandle
       type(ESMF_RouteHandle), intent(inout)           :: transposeRoutehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(in),    optional :: ignoreUnmatchedIndices
       integer,                intent(inout), optional :: srcTermProcessing
       integer,                intent(inout), optional :: pipeLineDepth
       integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute an <TT>ESMF_RouteHandle</TT> using factors read from file.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. The data in this Array may be
         destroyed by this call.

<P>
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
         destroyed by this call.

<P>
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Path to the file containing weights for creating an <TT>ESMF_RouteHandle</TT>.
         See&nbsp;(<A HREF="node3.html#sec:weightfileformat">12.9</A>) for a description of the SCRIP weight
         file format. Only "row", "col", and "S" variables are required. They
         must be one-dimensionsal with dimension "n_s".

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the <TT>ESMF_RouteHandle</TT>.

<P>
</DD>
<DT><STRONG>transposeRoutehandle</STRONG></DT>
<DD>A handle to the transposed matrix operation is returned. The
       transposed operation goes from <TT>dstArray</TT> to <TT>srcArray</TT>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices
       in the sparse matrix are encountered that do not have a match on the
       <TT>srcField</TT> or <TT>dstField</TT> side. The default setting is
       <TT>.false.</TT>, indicating that it is an error when such a situation is
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
       The <TT>ESMF_FieldSMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050368100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">81</SPAN> ESMF_FieldValidate - Check validity of a Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_FieldValidate(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field), intent(in)            :: field 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>field</TT> is internally consistent.
        Currently this method determines if the <TT>field</TT> is uninitialized 
        or already destroyed. It validates the contained array and grid objects.
        The code also checks if the array and grid sizes agree.
        This check compares the distgrid contained in array and grid; 
        then it proceeds to compare the computational bounds contained 
        in array and grid. 

<P>
The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> to validate.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the <TT>field</TT> 
             is valid.
       
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050368200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">82</SPAN> ESMF_FieldWrite - Write Field data into a file</A>
</H3>

<P>
<A NAME="api:FieldWrite"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_FieldWrite(field, fileName,   &amp;
       variableName, convention, purpose, overwrite, status, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),           intent(in)             :: field 
     character(*),               intent(in)             :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*),               intent(in),  optional  :: variableName
     character(*),               intent(in),  optional  :: convention
     character(*),               intent(in),  optional  :: purpose
     logical,                    intent(in),  optional  :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional  :: status
     integer,                    intent(in),  optional  :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional  :: iofmt
     integer,                    intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write Field data into a file.  For this API to be functional, the 
     environment variable <TT>ESMF_PIO</TT> should be set to either "internal" or "external" when
     the ESMF library is built.  Please see the section on 
     Data I/O,&nbsp;<A HREF="#io:dataio">38.2</A>.

<P>
When <TT>convention</TT> and <TT>purpose</TT> arguments are specified,
     a NetCDF variable can be created with user-specified dimension labels and
     attributes.  Dimension labels may be defined for both gridded and
     ungridded dimensions.  Dimension labels for gridded dimensions are specified
     at the Grid level by attaching an ESMF Attribute package to it.  The Attribute
     package must contain an attribute named by the pre-defined ESMF parameter
     <TT>ESMF_ATT_GRIDDED_DIM_LABELS</TT>.  The corresponding value is an array of
     character strings specifying the desired names of the dimensions.  Likewise,
     for ungridded dimensions, an Attribute package is attached at the Field level.
     The name of the name must be <TT>ESMF_ATT_UNGRIDDED_DIM_LABELS</TT>.

<P>
NetCDF attributes for the variable can also be specified.  As with dimension labels,
     an Attribute package is added to the Field with the desired names and values.
     A value may be either a scalar character string, or a scalar or array of type
     integer, real, or double precision.  Dimension label attributes can co-exist with
     variable attributes within a common Attribute package.

<P>
Limitations:
     
<UL>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object that contains data to be written.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the output file to which Field data is written.
       If the Field is a multi-tile Array, then fileName must contain
       exactly one instance of "*"; this is a placeholder that will be replaced
       by the tile number, with each tile being written to a separate file. (For
       example, for a fileName of "myfile*.nc", tile 1 will be written to
       "myfile1.nc", tile 2 to "myfile2.nc", etc.)
       (This handling of the fileName for multi-tile I/O is subject to change.)
     
</DD>
<DT><STRONG>[variableName]</STRONG></DT>
<DD>Variable name in the output file; default is the "name" of field.
      Use this argument only in the I/O format (such as NetCDF) that
      supports variable name. If the I/O format does not support this
      (such as binary format), ESMF will return an error code.
     
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>Specifies an Attribute package associated with the Field, used to create NetCDF
       dimension labels and attributes for the variable in the file.  When this argument is present,
       the <TT>purpose</TT> argument must also be present.  Use this argument only with a NetCDF
       I/O format. If binary format is used, ESMF will return an error code.
     
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>Specifies an Attribute package associated with the Field, used to create NetCDF
       dimension labels and attributes for the variable in the file.  When this argument is present,
       the <TT>convention</TT> argument must also be present.  Use this argument only with a NetCDF
       I/O format. If binary format is used, ESMF will return an error code.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing field data may
        <EM>not</EM> be overwritten. If .true., only the data corresponding to the field's name
        will be overwritten.    
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.

</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Please see Section&nbsp;<A HREF="node9.html#const:filestatusflag">54.21</A> for
      the list of options. If not present, defaults to
      <TT>ESMF_FILESTATUS_UNKNOWN</TT>.

</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Some I/O formats (e.g. NetCDF) support the output of data in form of
      time slices.  An unlimited dimension called <TT>time</TT> is defined in the
      file variable for this capability.
      The <TT>timeslice</TT> argument provides access to the <TT>time</TT> dimension,
      and must have a positive value. The behavior of this
      option may depend on the setting of the <TT>overwrite</TT> flag:
      <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
      less than the maximum time already in the file, the write will fail.
      
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
      
</DD>
</DL>
      By default, i.e. by omitting the <TT>timeslice</TT> argument, no
      provisions for time slicing are made in the output file,
      however, if the file already contains a time axis for the variable,
      a timeslice one greater than the maximum will be written.

</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Please see Section&nbsp;<A HREF="node9.html#opt:iofmtflag">54.28</A> for the list
      of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H2><A NAME="SECTION05037000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: Field Utilities</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05037100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GridGetFieldBounds - Get precomputed DE-local Fortran data array bounds for creating a Field from a Grid and Fortran array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_GridGetFieldBounds(grid, &amp;
         localDe, staggerloc, gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLWidth, totalUWidth, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid),       intent(in)            :: grid     
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,               intent(in),  optional :: localDe
     type(ESMF_StaggerLoc), intent(in),  optional :: staggerloc 
     integer,               intent(in),  optional :: gridToFieldMap(:)    
     integer,               intent(in),  optional :: ungriddedLBound(:)
     integer,               intent(in),  optional :: ungriddedUBound(:)
     integer,               intent(in),  optional :: totalLWidth(:)
     integer,               intent(in),  optional :: totalUWidth(:)
     integer,               intent(out), optional :: totalLBound(:)
     integer,               intent(out), optional :: totalUBound(:)
     integer,               intent(out), optional :: totalCount(:)
     integer,               intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_Grid</TT> and the Fortran data array. For an example and
   associated documentation using this method see section 
   <A HREF="#sec:field:usage:create_5dgrid_7dptr_2dungridded">26.3.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT>.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
         For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
         in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells.  For valid
         predefined values and interpretation of results see
         section <A HREF="#const:staggerloc">31.2.6</A>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
         <TT>grid</TT>|s dimCount.  The list elements map each dimension
         of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
         specifying the appropriate <TT>field</TT> dimension index. The default is to
         map all of the <TT>grid</TT>|s dimensions against the lowest dimensions of
         the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
         The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
         to one and smaller than or equal to the <TT>field</TT> rank.
         It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
         multiple times. The total ungridded dimensions in the <TT>field</TT>
         are the total <TT>field</TT> dimensions less
         the dimensions in
         the <TT>grid</TT>.  Ungridded dimensions must be in the same order they are
         stored in the <TT>field</TT>.  
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than grid dimension count, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than grid dimension count, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region.  The size of this array is the number
         of dimensions in the <TT>grid</TT>.  However, ordering of the elements
         needs to be the same as they appear in the <TT>field</TT>.  Values default
         to 0.  If values for totalLWidth are specified they must be reflected in
         the size of the <TT>field</TT>.  That is, for each gridded dimension the
         <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
         + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region.  The size of this array is the number
         of dimensions in the <TT>grid</TT>.  However, ordering of the elements
         needs to be the same as they appear in the <TT>field</TT>.  Values default
         to 0.  If values for totalUWidth are specified they must be reflected in
         the size of the <TT>field</TT>.  That is, for each gridded dimension the
         <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
         + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Grid</TT> and Fortran data array.
         This is an output variable from this user interface.
         
         The relative lower bounds of Fortran data array to be used
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Grid</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Grid</TT> and Fortran data array.
         This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05037200000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LocStreamGetFieldBounds - Get precomputed DE-local Fortran data array bounds for creating a Field from a LocStream and Fortran array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_LocStreamGetFieldBounds(locstream, &amp;
         localDe, gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in)            :: locstream     
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(in),  optional :: localDe
     integer,              intent(in),  optional :: gridToFieldMap(:)    
     integer,              intent(in),  optional :: ungriddedLBound(:)
     integer,              intent(in),  optional :: ungriddedUBound(:)
     integer,              intent(out), optional :: totalLBound(:)
     integer,              intent(out), optional :: totalUBound(:)
     integer,              intent(out), optional :: totalCount(:)
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_LocStream</TT> and the Fortran data array.  For an example and
   associated documentation using this method see section 
   <A HREF="#sec:field:usage:create_5dgrid_7dptr_2dungridded">26.3.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT>.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
         For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
         in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to 1.
         The list elements map the dimension
         of the <TT>locstream</TT> to a dimension in the <TT>field</TT> by
         specifying the appropriate <TT>field</TT> dimension index. The default is to
         map the <TT>locstream</TT>|s dimension against the lowest dimension of
         the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1/).
         The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
         to one and smaller than or equal to the <TT>field</TT> rank.
         The total ungridded dimensions in the <TT>field</TT>
         are the total <TT>field</TT> dimensions less
         the dimensions in
         the <TT>grid</TT>.  Ungridded dimensions must be in the same order they are
         stored in the field.  
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than 1, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than 1, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05037300000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_MeshGetFieldBounds - Get precomputed DE-local Fortran data array bounds for creating a Field from a Mesh and a Fortran array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_MeshGetFieldBounds(mesh, &amp;
         meshloc, &amp;
         localDe, gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in)            :: mesh     
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_MeshLoc),intent(in),optional :: meshloc
     integer,         intent(in),  optional :: localDe
     integer,         intent(in),  optional :: gridToFieldMap(:)    
     integer,         intent(in),  optional :: ungriddedLBound(:)
     integer,         intent(in),  optional :: ungriddedUBound(:)
     integer,         intent(out), optional :: totalLBound(:)
     integer,         intent(out), optional :: totalUBound(:)
     integer,         intent(out), optional :: totalCount(:)
     integer,         intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_Mesh</TT> and the Fortran data array. For an example and
   associated documentation using this method see section 
   <A HREF="#sec:field:usage:create_5dgrid_7dptr_2dungridded">26.3.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT>.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either
         <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set,
         defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
         For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
         in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
         <TT>grid</TT>|s dimCount.  The list elements map each dimension
         of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
         specifying the appropriate <TT>field</TT> dimension index. The default is to
         map all of the <TT>grid</TT>|s dimensions against the lowest dimensions of
         the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
         The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
         to one and smaller than or equal to the <TT>field</TT> rank.
         It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
         multiple times. The total ungridded dimensions in the <TT>field</TT>
         are the total <TT>field</TT> dimensions less
         the dimensions in
         the <TT>grid</TT>.  Ungridded dimensions must be in the same order they are
         stored in the field.  
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than grid dimension count, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than grid dimension count, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Mesh</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Mesh</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Mesh</TT> and Fortran data array.
         This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05037400000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_XGridGetFieldBounds - Get precomputed DE-local Fortran data array bounds for creating a Field from an XGrid and a Fortran array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_XGridGetFieldBounds(xgrid, &amp;
         xgridside, gridindex, localDe, gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid),          intent(in)            :: xgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_XGridSide_Flag), intent(in),  optional :: xgridside
     integer,                   intent(in),  optional :: gridindex
     integer,                   intent(in),  optional :: localDe
     integer,                   intent(in),  optional :: gridToFieldMap(:)    
     integer,                   intent(in),  optional :: ungriddedLBound(:)
     integer,                   intent(in),  optional :: ungriddedUBound(:)
     integer,                   intent(out), optional :: totalLBound(:)
     integer,                   intent(out), optional :: totalUBound(:)
     integer,                   intent(out), optional :: totalCount(:)
     integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_XGrid</TT> and the Fortran data array.  For an example and
   associated documentation using this method see section 
   <A HREF="#sec:field:usage:create_5dgrid_7dptr_2dungridded">26.3.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
         ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
         defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on
         that side to create the Field on. If not provided, defaults to 1.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
         For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
         in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to 1.
         The list elements map the dimension
         of the <TT>locstream</TT> to a dimension in the <TT>field</TT> by
         specifying the appropriate <TT>field</TT> dimension index. The default is to
         map the <TT>locstream</TT>|s dimension against the lowest dimension of
         the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1/).
         The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
         to one and smaller than or equal to the <TT>field</TT> rank.
         The total ungridded dimensions in the <TT>field</TT>
         are the total <TT>field</TT> dimensions less
         the dimensions in
         the <TT>grid</TT>.  Ungridded dimensions must be in the same order they are
         stored in the field.  
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than 1, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than 1, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>


<H1><A NAME="SECTION05040000000000000000">
<SPAN CLASS="arabic">27</SPAN> ArrayBundle Class</A>
</H1>

<H2><A NAME="SECTION05041000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The <TT>ESMF_ArrayBundle</TT> class allows a set of Arrays to be bundled into a
single object. The Arrays in an ArrayBundle may be of different type, kind,
rank and distribution. Besides ease of use resulting from bundling, the
ArrayBundle class offers the opportunity for performance optimization when
operating on a bundle of Arrays as a single entity.  Communication methods are 
especially good candidates for performance optimization. Best optimization
results are expected for ArrayBundles that contain Arrays that share a common
distribution, i.e. DistGrid, and are of same type, kind and rank.

<P>
ArrayBundles are one of the data objects that can be added to States,
which are used for providing to or receiving data from other Components.

<H2><A NAME="SECTION05042000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
Examples of creating, destroying and accessing ArrayBundles and their
constituent Arrays are provided in this section, along with some
notes on ArrayBundle methods.

<P>

<P>

<P>

<H3><A NAME="SECTION05042100000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Creating an ArrayBundle from a list of Arrays</A>
</H3>

<P>
An ArrayBundle is created from a list of <TT>ESMF_Array</TT> objects.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
<PRE>
  allocate(arrayList(2))
  arrayList(1) = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
                 rc=rc)
</PRE>

<P>
<PRE>
  arrayList(2) = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
                 rc=rc)
</PRE>

<P>
Now <TT>arrayList</TT> is used to create an ArrayBundle object.
<P>
<PRE>
  arraybundle = ESMF_ArrayBundleCreate(arrayList=arrayList, &amp;
    name="MyArrayBundle", rc=rc)
</PRE>

<P>
Here the temporary <TT>arrayList</TT> can be deallocated. This will not affect
   the ESMF Array objects inside the ArrayBundle. However, the Array objects
   must not be deallocated while the ArrayBundle references them.
<P>
<PRE>
  deallocate(arrayList)
</PRE>

<P>

<H3><A NAME="SECTION05042200000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Adding, removing, replacing Arrays in the ArrayBundle</A>
</H3>

<P>
Individual Arrays can be added using the Fortran array constructor syntax
   <TT>(/ ... /)</TT>. Here an ESMF_Array is created on the fly and immediately
   added to the ArrayBundle.
<P>
<PRE>
  call ESMF_ArrayBundleAdd(arraybundle, arrayList=(/ &amp;
    ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, name="AonFly")/), &amp;
    rc=rc)
</PRE>

<P>
Items in the ArrayBundle can be replaced by items with the same name.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec2, typekind=ESMF_TYPEKIND_R4, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayBundleReplace(arraybundle, arrayList=(/ &amp;
    ESMF_ArrayCreate(arrayspec=arrayspec2, distgrid=distgrid, name="AonFly")/), &amp;
    rc=rc)
</PRE>

<P>
Items can be removed from the ArrayBundle by providing their name.
<P>
<PRE>
  call ESMF_ArrayBundleRemove(arraybundle, arrayNameList=(/"AonFly"/), rc=rc)
</PRE>

<P>
The ArrayBundle AddReplace() method can be used to conveniently add an
   item to the ArrayBundle, or replacing an existing item of the same name.
<P>
<PRE>
  call ESMF_ArrayBundleAddReplace(arraybundle, arrayList=(/ &amp;
    ESMF_ArrayCreate(arrayspec=arrayspec2, distgrid=distgrid, name="AonFly")/), &amp;
    rc=rc)
</PRE>

<P>
The ArrayBundle object can be printed at any time to list its contents by name.
<P>
<PRE>
  call ESMF_ArrayBundlePrint(arraybundle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05042300000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Accessing Arrays inside the ArrayBundle</A>
</H3>

<P>
Individual items in the ArrayBundle can be accessed directly by their
   name.
<P>
<PRE>
  call ESMF_ArrayBundleGet(arraybundle, arrayName="AonFly", array=arrayOut, &amp;
    rc=rc)
</PRE>

<P>
A list containing all of the Arrays in the ArrayBundle can also be requested
   in a single call.
   This requires that a large enough list argument is passed into the
   <TT>ESMF_ArrayBundleGet()</TT> method. The exact number of items in the
   ArrayBundle can be queried using the <TT>arrayCount</TT> argument first.
<P>
<PRE>
  call ESMF_ArrayBundleGet(arraybundle, arrayCount=arrayCount, rc=rc)
</PRE>

<P>
Then use <TT>arrayCount</TT> to correctly allocate the <TT>arrayList</TT>
   variable for a second call to <TT>ESMF_ArrayBundleGet()</TT>.
   
<P>
<PRE>
  allocate(arrayList(arrayCount))
  call ESMF_ArrayBundleGet(arraybundle, arrayList=arrayList, rc=rc)
</PRE>

<P>
Now the <TT>arrayList</TT> variable can be used to access the individual Arrays,
   e.g. to print them.
<P>
<PRE>
  do i=1, arrayCount
    call ESMF_ArrayPrint(arrayList(i), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  enddo
</PRE>

<P>
By default the <TT>arrayList</TT> returned by <TT>ESMF_ArrayBundleGet()</TT>
   contains the items in alphabetical order. To instead return the items in the
   same order in which they were added to the ArrayBundle, the
   <TT>itemorderflag</TT> argument is passed with a value of 
   <TT>ESMF_ITEMORDER_ADDORDER</TT>.

<P>

<P>
<PRE>
  call ESMF_ArrayBundleGet(arraybundle, arrayList=arrayList, &amp;
    itemorderflag=ESMF_ITEMORDER_ADDORDER, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05042400000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Destroying an ArrayBundle and its constituents</A>
</H3>

<P>
Destroying an ArrayBundle does not destroy the Arrays. In fact, it leaves the
   Arrays totally unchanged.
<P>
<PRE>
  call ESMF_ArrayBundleDestroy(arraybundle, rc=rc)
</PRE>

<P>
The Arrays must be destroyed separately.
<P>
<PRE>
  call ESMF_ArrayDestroy(arrayList(1), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(arrayList(2), rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arrayList)
  
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION05042500000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Halo communication</A>
</H3>

<P>
One of the most fundamental communication pattern in domain decomposition
   codes is the <EM>halo</EM> operation. The ESMF Array class supports halos
   by allowing memory for extra elements to be allocated on each DE. See
   section <A HREF="#Array:Halo">28.2.15</A> for a discussion of the Array level halo operation.
   The ArrayBundle level extents the Array halo operation to bundles of Arrays.

<P>
First create an <TT>ESMF_ArrayBundle</TT> object containing a set of ESMF
   Arrays.
<P>
<PRE>
  arraybundle = ESMF_ArrayBundleCreate(arrayList=arrayList, &amp;
    name="MyArrayBundle", rc=rc)
</PRE>

<P>
The ArrayBundle object can be treated as a single entity. The
   <TT>ESMF_ArrayBundleHaloStore()</TT> call determines the most efficient
   halo exchange pattern for <EM>all</EM> Arrays that are part of
   <TT>arraybundle</TT>.
<P>
<PRE>
  call ESMF_ArrayBundleHaloStore(arraybundle=arraybundle, &amp;
    routehandle=haloHandle, rc=rc)
</PRE>

<P>
The halo exchange pattern stored in <TT>haloHandle</TT> can now be applied to
   the <TT>arraybundle</TT> object, or any other ArrayBundle that is compatible
   to the one used during the <TT>ESMF_ArrayBundleHaloStore()</TT> call.
<P>
<PRE>
  call ESMF_ArrayBundleHalo(arraybundle=arraybundle, routehandle=haloHandle, &amp;
    rc=rc)
</PRE>

<P>
Finally, when no longer needed, the resources held by <TT>haloHandle</TT> need
   to be returned to the system by calling <TT>ESMF_ArrayBundleHaloRelease()</TT>.
<P>
<PRE>
  call ESMF_ArrayBundleHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
Finally the ArrayBundle object can be destroyed.
<P>
<PRE>
  call ESMF_ArrayBundleDestroy(arraybundle, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION05043000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Non-blocking</B> ArrayBundle communications option is not yet implemented. In the future this functionality will be provided via the
<TT>routesyncflag</TT> option.

<P>
</LI>
</UL>

<H2><A NAME="SECTION05044000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The following is a list of implementation specific details about the current ESMF ArrayBundle.

<P>

<UL>
<LI>Implementation language is C++.
</LI>
<LI>All precomputed communication methods are based on sparse matrix
multiplication.
</LI>
</UL>

<H2><A NAME="SECTION05045000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05045100000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ArrayBundleAssignment(=) - ArrayBundle assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     arraybundle1 = arraybundle2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle) :: arraybundle1
     type(ESMF_ArrayBundle) :: arraybundle2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign arraybundle1 as an alias to the same ESMF ArrayBundle object in memory
     as arraybundle2. If arraybundle2 is invalid, then arraybundle1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle1</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>arraybundle2</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045200000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ArrayBundleOperator(==) - ArrayBundle equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (arraybundle1 == arraybundle2) then ... endif
               OR
     result = (arraybundle1 == arraybundle2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in) :: arraybundle1
     type(ESMF_ArrayBundle), intent(in) :: arraybundle2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether arraybundle1 and arraybundle2 are valid aliases to the same ESMF
     ArrayBundle object in memory. For a more general comparison of two ESMF ArrayBundles,
     going beyond the simple alias test, the ESMF_ArrayBundleMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle1</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>arraybundle2</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045300000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ArrayBundleOperator(/=) - ArrayBundle not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (arraybundle1 /= arraybundle2) then ... endif
               OR
     result = (arraybundle1 /= arraybundle2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in) :: arraybundle1
     type(ESMF_ArrayBundle), intent(in) :: arraybundle2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether arraybundle1 and arraybundle2 are <I>not</I> valid aliases to the
     same ESMF ArrayBundle object in memory. For a more general comparison of two ESMF
     ArrayBundles, going beyond the simple alias test, the ESMF_ArrayBundleMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle1</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>arraybundle2</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045400000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ArrayBundleAdd - Add Arrays to an ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleAdd(arraybundle, arrayList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
     type(ESMF_Array),       intent(in)            :: arrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add Array(s) to an ArrayBundle. It is an error if <TT>arrayList</TT> contains
     Arrays that match by name Arrays already contained in <TT>arraybundle</TT>.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be added to.
     
</DD>
<DT><STRONG>arrayList</STRONG></DT>
<DD>List of <TT>ESMF_Array</TT> objects to be added.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be added to <TT>arraybundle</TT>. For <TT>.false.</TT> added items must
       have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add"
       under <TT>multiflag=.false.</TT> mode, where it is <EM>not</EM> an error if 
       <TT>arrayList</TT> contains items with names that are also found in 
       <TT>arraybundle</TT>. The <TT>arraybundle</TT> is left unchanged for these items.
       For <TT>.false.</TT> this is treated as an error condition. 
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045500000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ArrayBundleAddReplace - Conditionally add or replace Arrays in an ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleAddReplace(arraybundle, arrayList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
     type(ESMF_Array),       intent(in)            :: arrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Arrays in <TT>arrayList</TT> that do not match any Arrays by name in 
     <TT>arraybundle</TT> are added to the ArrayBundle. Arrays in <TT>arraybundle</TT>
     that match by name Arrays in <TT>arrayList</TT> are replaced by those Arrays.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be manipulated.
     
</DD>
<DT><STRONG>arrayList</STRONG></DT>
<DD>List of <TT>ESMF_Array</TT> objects to be added or used as replacement.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045600000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ArrayBundleCreate - Create an ArrayBundle from a list of Arrays</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_ArrayBundleCreate(arrayList, multiflag, &amp;
     relaxedflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_ArrayBundle) :: ESMF_ArrayBundleCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Array), intent(in),  optional :: arrayList(:)
     logical,          intent(in),  optional :: multiflag
     logical,          intent(in),  optional :: relaxedflag
     character(len=*), intent(in),  optional :: name
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_ArrayBundle</TT> object from a list of existing Arrays.

<P>
The creation of an ArrayBundle leaves the bundled Arrays unchanged, they
     remain valid individual objects. An ArrayBundle is a light weight container
     of Array references. The actual data remains in place, there are no
     data movements or duplications associated with the creation of an 
     ArrayBundle.

<P>
<DL>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>List of <TT>ESMF_Array</TT> objects to be bundled.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be added to <TT>arraybundle</TT>. For <TT>.false.</TT> added items must
       have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add"
       under <TT>multiflag=.false.</TT> mode, where it is <EM>not</EM> an error if 
       <TT>arrayList</TT> contains items with names that are also found in 
       <TT>arraybundle</TT>. The <TT>arraybundle</TT> is left unchanged for these items.
       For <TT>.false.</TT> this is treated as an error condition. 
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the created <TT>ESMF_ArrayBundle</TT>. A default name is generated
       if not specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045700000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ArrayBundleDestroy - Release resources associated with an ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleDestroy(arraybundle, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)           :: arraybundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional  :: noGarbage
     integer,                intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_ArrayBundle</TT> object. The member Arrays are not
     touched by this operation and remain valid objects that need to be 
     destroyed individually if necessary. 

<P>
By default a small remnant of the object is kept in memory in order to 
     prevent problems with dangling aliases. The default garbage collection
     mechanism can be overridden with the <TT>noGarbage</TT> argument.

<P>
The arguments are:
   <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this 
        condition ESMF cannot protect against accessing the destroyed object 
        through dangling aliases - a situation which may lead to hard to debug 
        application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
        set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use 
        temporary ESMF objects. For situations where the repeated creation and 
        destruction of temporary objects leads to memory issues, it is 
        recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
        removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045800000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_ArrayBundleGet - Get object-wide information from an ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ArrayBundleGet()   
     subroutine ESMF_ArrayBundleGetListAll(arraybundle, &amp;
       itemorderflag, arrayCount, arrayList, arrayNameList, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),    intent(in)            :: arraybundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ItemOrder_Flag), intent(in),  optional :: itemorderflag
     integer,                   intent(out), optional :: arrayCount
     type(ESMF_Array),          intent(out), optional :: arrayList(:)
     character(len=*),          intent(out), optional :: arrayNameList(:)
     character(len=*),          intent(out), optional :: name
     integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>itemorderflag</TT>.
                The new argument gives the user control over the order in which
                the items are returned.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get general, i.e. not Array name specific information from the ArrayBundle.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be queried.
     
</DD>
<DT><STRONG>[itemorderflag]</STRONG></DT>
<DD>Specifies the order of the returned items in the <TT>arrayList</TT> and
       <TT>arrayNameList</TT>.
       The default is <TT>ESMF_ITEMORDER_ABC</TT>.
       See <A HREF="node9.html#const:itemorderflag">54.32</A> for a full list of options.
     
</DD>
<DT><STRONG>[arrayCount]</STRONG></DT>
<DD>Upon return holds the number of Arrays bundled in the ArrayBundle.
     
</DD>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>Upon return holds a list of Arrays bundled in <TT>arraybundle</TT>. The
       argument must be allocated to be at least of size <TT>arrayCount</TT>.
     
</DD>
<DT><STRONG>[arrayNameList]</STRONG></DT>
<DD>Upon return holds a list of the names of the Arrays bundled in 
       <TT>arraybundle</TT>. The argument must be allocated to be at least of
       size <TT>arrayCount</TT>.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the ArrayBundle object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045900000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_ArrayBundleGet - Get information about an Array by name and optionally return an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ArrayBundleGet()   
     subroutine ESMF_ArrayBundleGetItem(arraybundle, arrayName, &amp;
       array, arrayCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: arraybundle
     character(len=*),       intent(in)            :: arrayName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Array),       intent(out), optional :: array
     integer,                intent(out), optional :: arrayCount
     logical,                intent(out), optional :: isPresent
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get information about items that match <TT>arrayName</TT> in ArrayBundle.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be queried.
     
</DD>
<DT><STRONG>arrayName</STRONG></DT>
<DD>Specified name.
     
</DD>
<DT><STRONG>[array]</STRONG></DT>
<DD>Upon return holds the requested Array item. It is an error if this
       argument was specified and there is not exactly one Array item in 
       <TT>arraybundle</TT> that matches <TT>arrayName</TT>.
     
</DD>
<DT><STRONG>[arrayCount]</STRONG></DT>
<DD>Number of Arrays with <TT>arrayName</TT> in <TT>arraybundle</TT>.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Upon return indicates whether Array(s) with <TT>arrayName</TT> exist
       in <TT>arraybundle</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_ArrayBundleGet - Get a list of Arrays by name</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ArrayBundleGet()   
     subroutine ESMF_ArrayBundleGetList(arraybundle, arrayName, arrayList, &amp;
       itemorderflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),    intent(in)            :: arraybundle
     character(len=*),          intent(in)            :: arrayName
     type(ESMF_Array),          intent(out)           :: arrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ItemOrder_Flag), intent(in),  optional :: itemorderflag
     integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>itemorderflag</TT>.
                The new argument gives the user control over the order in which
                the items are returned.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the list of Arrays from ArrayBundle that match <TT>arrayName</TT>.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be queried.
     
</DD>
<DT><STRONG>arrayName</STRONG></DT>
<DD>Specified name.
     
</DD>
<DT><STRONG>arrayList</STRONG></DT>
<DD>List of Arrays in <TT>arraybundle</TT> that match <TT>arrayName</TT>. The
       argument must be allocated to be at least of size <TT>arrayCount</TT>
       returned for this <TT>arrayName</TT>.
     
</DD>
<DT><STRONG>[itemorderflag]</STRONG></DT>
<DD>Specifies the order of the returned items in the <TT>arrayList</TT>.
       The default is <TT>ESMF_ITEMORDER_ABC</TT>.
       See <A HREF="node9.html#const:itemorderflag">54.32</A> for a full list of options.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451100000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_ArrayBundleHalo - Execute an ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleHalo(arraybundle, routehandle, &amp;
     checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)          :: arraybundle
     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional :: checkflag
     integer,                intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle halo operation for the Arrays in
     <TT>arrayBundle</TT>.

<P>
See <TT>ESMF_ArrayBundleHaloStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451200000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_ArrayBundleHaloRelease - Release resources associated with an ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleHaloRelease(routehandle, &amp;
     noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional :: noGarbage
     integer,                intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with an ArrayBundle halo operation.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451300000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_ArrayBundleHaloStore - Precompute an ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleHaloStore(arraybundle, routehandle, &amp;
       startregion, haloLDepth, haloUDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),     intent(inout)         :: arraybundle
     type(ESMF_RouteHandle),     intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_StartRegion_Flag),intent(in),  optional :: startregion
     integer,                    intent(in),  optional :: haloLDepth(:)
     integer,                    intent(in),  optional :: haloUDepth(:)
     integer,                    intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle halo operation over the data in <TT>arraybundle</TT>. By 
     default, i.e. without specifying <TT>startregion</TT>, <TT>haloLDepth</TT>
     and <TT>haloUDepth</TT>, all elements in the total Array regions that lie
     outside the exclusive regions will be considered potential destination
     elements for the halo operation. However, only those elements that have a corresponding
     halo source element, i.e. an exclusive element on one of the DEs, will be
     updated under the halo operation. Elements that have no associated source
     remain unchanged under halo.

<P>
Specifying <TT>startregion</TT> allows to change the shape of the 
     effective halo region from the inside. Setting this flag to
     <TT>ESMF_STARTREGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region for each Array are considered for potential
     destination elements for the halo operation. The default is
     <TT>ESMF_STARTREGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>startregion</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total region for each Array, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Array regions are
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for the halo operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleHalo()</TT> on any pair of ArrayBundles that matches 
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
     and memory layout of the <EM>distributed</EM> dimensions. However, the size, 
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> containing data to be haloed. The data in the halo
       regions may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[startregion]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elements.
       See section <A HREF="node9.html#const:startregion">54.54</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>startregion</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>startregion</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451400000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_ArrayBundleIsCreated - Check whether an ArrayBundle object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_ArrayBundleIsCreated(arraybundle, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_ArrayBundleIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: arraybundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>arraybundle</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451500000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_ArrayBundlePrint - Print ArrayBundle information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundlePrint(arraybundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: arraybundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMF_ArrayBundle</TT>
     object to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451600000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_ArrayBundleRead - Read Arrays to an ArrayBundle from file(s)</A>
</H3>

<P>
<A NAME="api:ArrayBundleRead"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleRead(arraybundle, fileName, &amp;
     singleFile, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)          :: arraybundle
     character(*),           intent(in)             :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional  :: singleFile
     integer,                intent(in),  optional  :: timeslice
     type(ESMF_IOFmt_Flag),  intent(in),  optional  :: iofmt
     integer,                intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Read Array data to an ArrayBundle object from file(s).
     For this API to be functional, the environment variable <TT>ESMF_PIO</TT> 
     should be set to either "internal" or "external" when the ESMF library is built.
     Please see the section on Data I/O,&nbsp;<A HREF="#io:dataio">38.2</A>.

<P>
Limitations:
     
<UL>
<LI>For multi-tile Arrays, all Arrays in the ArrayBundle must contain
       the same number of tiles.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD>An <TT>ESMF_ArrayBundle</TT> object.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file from which ArrayBundle data is read.
       If the ArrayBundle contains multi-tile Arrays, then fileName must contain
       exactly one instance of "*"; this is a placeholder that will be replaced
       by the tile number, with each tile being read from a separate file. (For
       example, for a fileName of "myfile*.nc", tile 1 will be read from
       "myfile1.nc", tile 2 from "myfile2.nc", etc.)
       (This handling of the fileName for multi-tile I/O is subject to change.)
     
</DD>
<DT><STRONG>[singleFile]</STRONG></DT>
<DD>A logical flag, the default is .true., i.e., all Arrays in the bundle 
       are stored in one single file. If .false., each Array is stored 
       in separate files; these files are numbered with the name based on the
       argument "file". That is, a set of files are named: [file_name]001,
       [file_name]002, [file_name]003,...
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>The time-slice number of the variable read from file.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Please see Section&nbsp;<A HREF="node9.html#opt:iofmtflag">54.28</A> for the list
      of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451700000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_ArrayBundleRedist - Execute an ArrayBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleRedist(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in),    optional :: srcArrayBundle
     type(ESMF_ArrayBundle), intent(inout), optional :: dstArrayBundle
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: checkflag
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle redistribution from the Arrays in
     <TT>srcArrayBundle</TT> to the Arrays in <TT>dstArrayBundle</TT>.

<P>
The <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> arguments are optional in
     support of the situation where <TT>srcArrayBundle</TT> and/or
     <TT>dstArrayBundle</TT> are not defined on all PETs. The <TT>srcArrayBundle</TT>
     and <TT>dstArrayBundle</TT> must be specified on those PETs that hold source
     or destination DEs, respectively, but may be omitted on all other PETs.
     PETs that hold neither source nor destination DEs may omit both arguments.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451800000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_ArrayBundleRedistRelease - Release resources associated with ArrayBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleRedistRelease(routehandle, &amp;
     noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional :: noGarbage
     integer,                intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with an ArrayBundle redistribution.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451900000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_ArrayBundleRedistStore - Precompute an ArrayBundle redistribution with local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleRedistStore()
   subroutine ESMF_ArrayBundleRedistStore&lt;type&gt;&lt;kind&gt;(srcArrayBundle, &amp;
     dstArrayBundle, routehandle, factor, ignoreUnmatchedIndicesFlag, &amp;
     srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),  intent(in)            :: srcArrayBundle
     type(ESMF_ArrayBundle),  intent(inout)         :: dstArrayBundle
     type(ESMF_RouteHandle),  intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;),intent(in)            :: factor
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(in),  optional :: ignoreUnmatchedIndicesFlag(:)
     integer,                 intent(in),  optional :: srcToDstTransposeMap(:)
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndicesFlag</TT> to support cases
      where source and destination side do not cover the exact same index space.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle redistribution operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The redistribution
     between ArrayBundles is defined as the sequence of
     individual Array redistributions over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify a <TT>factor</TT> argument must use the
     &lt;type&gt;&lt;kind&gt; overloaded interface. Other PETs call into the interface
     without <TT>factor</TT> argument. If multiple PETs specify the <TT>factor</TT>
     argument its type and kind as well as its value must match across all
     PETs. If none of the PETs specifies a <TT>factor</TT> argument the default
     will be a factor of 1.

<P>
See the description of method <TT>ESMF_ArrayRedistStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleRedist()</TT> on any pair of ArrayBundles that matches 
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
     and memory layout of the <EM>distributed</EM> dimensions. However, the size, 
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data. The data in these Arrays
       may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multiply source data.
     
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
       cover the identical index space, using precisely matching sequence
       indices. If set to .true., mismatching sequence indices between source
       and destination side are silently ignored.
       The size of this array argument must either be 1 or equal the number of
       Arrays in the <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> arguments. In
       the latter case, the handling of unmatched indices is specified for each
       Array pair separately. If only one element is specified, it is
       used for <EM>all</EM> Array pairs.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in the Arrays in
       <TT>srcArrayBundle</TT>. Each
       entry maps the corresponding source Array dimension against the 
       specified destination Array dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_ArrayBundleRedistStore - Precompute an ArrayBundle redistribution without local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleRedistStore()
   subroutine ESMF_ArrayBundleRedistStoreNF(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, ignoreUnmatchedIndicesFlag, &amp;
     srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: srcArrayBundle
     type(ESMF_ArrayBundle), intent(inout)         :: dstArrayBundle
     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: ignoreUnmatchedIndicesFlag(:)
     integer,                intent(in),  optional :: srcToDstTransposeMap(:)
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndicesFlag</TT> to support cases
      where source and destination side do not cover the exact same index space.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle redistribution operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The redistribution
     between ArrayBundles is defined as the sequence of
     individual Array redistributions over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify a <TT>factor</TT> argument must use the
     &lt;type&gt;&lt;kind&gt; overloaded interface. Other PETs call into the interface
     without <TT>factor</TT> argument. If multiple PETs specify the <TT>factor</TT>
     argument its type and kind as well as its value must match across all
     PETs. If none of the PETs specifies a <TT>factor</TT> argument the default
     will be a factor of 1.

<P>
See the description of method <TT>ESMF_ArrayRedistStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleRedist()</TT> on any pair of ArrayBundles that matches 
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
     and memory layout of the <EM>distributed</EM> dimensions. However, the size, 
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data. The data in these Arrays
       may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
       cover the identical index space, using precisely matching sequence
       indices. If set to .true., mismatching sequence indices between source
       and destination side are silently ignored.
       The size of this array argument must either be 1 or equal the number of
       Arrays in the <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> arguments. In
       the latter case, the handling of unmatched indices is specified for each
       Array pair separately. If only one element is specified, it is
       used for <EM>all</EM> Array pairs.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in the Arrays in
       <TT>srcArrayBundle</TT>. Each
       entry maps the corresponding source Array dimension against the 
       specified destination Array dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452100000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_ArrayBundleRemove - Remove Arrays from ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleRemove(arraybundle, arrayNameList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
     character(len=*),       intent(in)            :: arrayNameList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove Array(s) by name from ArrayBundle. In the relaxed setting it is 
     <EM>not</EM> an error if <TT>arrayNameList</TT> contains names that are not 
     found in <TT>arraybundle</TT>.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> from which to remove items.
     
</DD>
<DT><STRONG>arrayNameList</STRONG></DT>
<DD>List of items to remove.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple Arrays with the same name
       to be removed from <TT>arraybundle</TT>. For <TT>.false.</TT>, items to be
       removed must have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "remove"
       where it is <EM>not</EM> an error if <TT>arrayNameList</TT> contains item
       names that are not found in <TT>arraybundle</TT>. For <TT>.false.</TT> this is 
       treated as an error condition. 
       Further, in <TT>multiflag=.false.</TT> mode, the relaxed definition of
       "remove" also covers the case where there are multiple items in
       <TT>arraybundle</TT> that match a single entry in <TT>arrayNameList</TT>.
       For <TT>relaxedflag=.false.</TT> this is treated as an error condition.
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452200000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_ArrayBundleReplace - Replace Arrays in ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleReplace(arraybundle, arrayList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
     type(ESMF_Array),       intent(in)            :: arrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Replace Array(s) by name in ArrayBundle. In the relaxed setting it is not
     an error if <TT>arrayList</TT> contains Arrays that do not match by name any
     item in <TT>arraybundle</TT>. These Arrays are simply ignored in this case.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> in which to replace items.
     
</DD>
<DT><STRONG>arrayList</STRONG></DT>
<DD>List of items to replace.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be replaced in <TT>arraybundle</TT>. For <TT>.false.</TT>, items to be
       replaced must have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "replace"
       where it is <EM>not</EM> an error if <TT>arrayList</TT> contains items with
       names that are not found in <TT>arraybundle</TT>. These items in 
       <TT>arrayList</TT> are ignored in the relaxed mode. For <TT>.false.</TT> this
       is treated as an error condition.
       Further, in <TT>multiflag=.false.</TT> mode, the relaxed definition of
       "replace" also covers the case where there are multiple items in
       <TT>arraybundle</TT> that match a single entry by name in <TT>arrayList</TT>.
       For <TT>relaxedflag=.false.</TT> this is treated as an error condition.
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452300000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_ArrayBundleSMM - Execute an ArrayBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleSMM(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, &amp;
     zeroregion, &amp; ! DEPRECATED ARGUMENT
     zeroregionflag, termorderflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),    intent(in),         optional :: srcArrayBundle
     type(ESMF_ArrayBundle),    intent(inout),      optional :: dstArrayBundle
     type(ESMF_RouteHandle),    intent(inout)                :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Region_Flag),    intent(in), optional :: zeroregion ! DEPRECATED ARGUMENT
     type(ESMF_Region_Flag),    intent(in), target, optional :: zeroregionflag(:)
     type(ESMF_TermOrder_Flag), intent(in), target, optional :: termorderflag(:)
     logical,                   intent(in),         optional :: checkflag
     integer,                   intent(out),        optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>termorderflag</TT>.
                The new argument gives the user control over the order in which
                the src terms are summed up.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>zeroregionflag</TT>, and deprecated
                <TT>zeroregion</TT>. The new argument allows greater flexibility
                in setting the zero region for individual ArrayBundle members.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle sparse matrix multiplication from the
     Arrays in <TT>srcArrayBundle</TT> to the Arrays in <TT>dstArrayBundle</TT>.

<P>
The <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> arguments are optional in
     support of the situation where <TT>srcArrayBundle</TT> and/or
     <TT>dstArrayBundle</TT> are not defined on all PETs. The <TT>srcArrayBundle</TT>
     and <TT>dstArrayBundle</TT> must be specified on those PETs that hold source
     or destination DEs, respectively, but may be omitted on all other PETs.
     PETs that hold neither source nor destination DEs may omit both arguments.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of 
       all DEs in all Arrays in <TT>dstArrayBundle</TT> will be initialized to zero 
       before updating the elements with the results of the sparse matrix 
       multiplication. If set to <TT>ESMF_REGION_EMPTY</TT> the elements in the
       Arrays in <TT>dstArrayBundle</TT> will not be modified prior to the sparse
       matrix multiplication and results will be added to the incoming element
       values. Setting <TT>zeroregion</TT> to <TT>ESMF_REGION_SELECT</TT> will only
       zero out those elements in the destination Arrays that will be updated
       by the sparse matrix multiplication. See section <A HREF="node9.html#const:region">54.48</A>
       for a complete list of valid settings.
     
</DD>
<DT><STRONG>[zeroregionflag]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of 
       all DEs in the destination Array will be initialized to zero 
       before updating the elements with the results of the sparse matrix 
       multiplication. If set to <TT>ESMF_REGION_EMPTY</TT> the elements in the
       destination Array will not be modified prior to the sparse
       matrix multiplication and results will be added to the incoming element
       values. A setting of <TT>ESMF_REGION_SELECT</TT> will only
       zero out those elements in the destination Array that will be updated
       by the sparse matrix multiplication. See section <A HREF="node9.html#const:region">54.48</A>
       for a complete list of valid settings.
       The size of this array argument must either be 1 or equal the number of
       Arrays in the <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> arguments. In
       the latter case, the zero region for each Array SMM operation is
       indicated separately. If only one zero region element is specified, it is
       used for <EM>all</EM> Array pairs.
     
</DD>
<DT><STRONG>[termorderflag]</STRONG></DT>
<DD>Specifies the order of the source side terms in all of the destination
       sums. The <TT>termorderflag</TT> only affects the order of terms during 
       the execution of the RouteHandle. See the <A HREF="#RH:bfb">37.2.1</A> section for an
       in-depth discussion of <EM>all</EM> bit-for-bit reproducibility
       aspects related to route-based communication methods.
       See <A HREF="node9.html#const:termorderflag">54.58</A> for a full list of options.
       The size of this array argument must either be 1 or equal the number of
       Arrays in the <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> arguments. In
       the latter case, the term order for each Array SMM operation is
       indicated separately. If only one term order element is specified, it is
       used for <EM>all</EM> Array pairs.
       The default is <TT>(/ESMF_TERMORDER_FREE/)</TT>, allowing maximum 
       flexibility in the order of terms for optimum performance.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452400000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_ArrayBundleSMMRelease - Release resources associated with ArrayBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleSMMRelease(routehandle, &amp;
     noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional :: noGarbage
     integer,                intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with an ArrayBundle sparse matrix multiplication. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452500000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_ArrayBundleSMMStore - Precompute an ArrayBundle sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleSMMStore()
   subroutine ESMF_ArrayBundleSMMStore&lt;type&gt;&lt;kind&gt;(srcArrayBundle, &amp;
     dstArrayBundle, routehandle, factorList, factorIndexList, &amp;
     ignoreUnmatchedIndicesFlag, srcTermProcessing, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),           intent(in)    :: srcArrayBundle
     type(ESMF_ArrayBundle),           intent(inout) :: dstArrayBundle
     type(ESMF_RouteHandle),           intent(inout) :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)    :: factorList(:)
     integer,                          intent(in)    :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndicesFlag(:)
     integer,                intent(inout), optional :: srcTermProcessing(:)
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>srcTermProcessing</TT>.
                The new argument gives the user access to the tuning parameter
                affecting the sparse matrix execution and bit-wise 
                reproducibility.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndicesFlag</TT> to support cases
      where the sparse matrix includes terms with source or destination sequence
      indices not present in the source or destination array.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle sparse matrix multiplication operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The sparse matrix
     multiplication between ArrayBundles is defined as the sequence of
     individual Array sparse matrix multiplications over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
See the description of method <TT>ESMF_ArraySMMStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleSMM()</TT> on any pair of ArrayBundles that matches 
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
     and memory layout of the <EM>distributed</EM> dimensions. However, the size, 
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data. The data in these Arrays
       may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
     
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the source Array while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in the destination Array. For this format to be a
       valid option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identity matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the source Array. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the destination Array.

<P>
See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of 
       Array <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
       cover all of the squence indices defined in the sparse matrix. An error
       will be returned if a sequence index in the sparse matrix does not match
       on either the source or destination side.
       If set to .true., mismatching sequence indices are silently ignored.
       The size of this array argument must either be 1 or equal the number of
       Arrays in the <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> arguments. In
       the latter case, the handling of unmatched indices is specified for each
       Array pair separately. If only one element is specified, it is
       used for <EM>all</EM> Array pairs.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>Source term summing options for route handle creation. See
         <TT>ESMF_ArraySMMStore</TT> documentation for a full parameter description.
         Two forms may be provided. If a single element list is provided, this
         integer value is applied across all bundle members. Otherwise, the list must
         contain as many elements as there are bundle members. For the special case
         of accessing the auto-tuned parameter (providing a negative integer value),
         the list length must equal the bundle member count.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452600000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_ArrayBundleSMMStore - Precompute an ArrayBundle sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleSMMStore()
   subroutine ESMF_ArrayBundleSMMStoreNF(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, ignoreUnmatchedIndicesFlag, srcTermProcessing, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),  intent(in)              :: srcArrayBundle
     type(ESMF_ArrayBundle),  intent(inout)           :: dstArrayBundle
     type(ESMF_RouteHandle),  intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(in),    optional :: ignoreUnmatchedIndicesFlag(:)
     integer,                 intent(inout), optional :: srcTermProcessing(:)
     integer,                 intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>srcTermProcessing</TT>.
                The new argument gives the user access to the tuning parameter
                affecting the sparse matrix execution and bit-wise 
                reproducibility.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>ignoreUnmatchedIndicesFlag</TT> to support cases
      where the sparse matrix includes terms with source or destination sequence
      indices not present in the source or destination array.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle sparse matrix multiplication operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The sparse matrix
     multiplication between ArrayBundles is defined as the sequence of
     individual Array sparse matrix multiplications over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
See the description of method <TT>ESMF_ArraySMMStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleSMM()</TT> on any pair of ArrayBundles that matches 
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> in <EM>type</EM>, <EM>kind</EM>,
     and memory layout of the <EM>distributed</EM> dimensions. However, the size, 
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data. The data in these Arrays
       may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndicesFlag]</STRONG></DT>
<DD>If set to .false., the <EM>default</EM>, source and destination side must
       cover all of the squence indices defined in the sparse matrix. An error
       will be returned if a sequence index in the sparse matrix does not match
       on either the source or destination side.
       If set to .true., mismatching sequence indices are silently ignored.
       The size of this array argument must either be 1 or equal the number of
       Arrays in the <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> arguments. In
       the latter case, the handling of unmatched indices is specified for each
       Array pair separately. If only one element is specified, it is
       used for <EM>all</EM> Array pairs.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>Source term summing options for route handle creation. See
         <TT>ESMF_ArraySMMStore</TT> documentation for a full parameter description.
         Two forms may be provided. If a single element list is provided, this
         integer value is applied across all bundle members. Otherwise, the list must
         contain as many elements as there are bundle members. For the special case
         of accessing the auto-tuned parameter (providing a negative integer value),
         the list length must equal the bundle member count.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452700000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_ArrayBundleWrite - Write the Arrays into a file</A>
</H3>

<P>
<A NAME="api:ArrayBundleWrite"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleWrite(arraybundle, fileName, &amp;
     convention, purpose, singleFile, overwrite, status, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),     intent(in)              :: arraybundle
     character(*),               intent(in)              :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*),               intent(in),  optional  :: convention
     character(*),               intent(in),  optional  :: purpose
     logical,                    intent(in),  optional  :: singleFile
     logical,                    intent(in),  optional  :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional  :: status
     integer,                    intent(in),  optional  :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional  :: iofmt
     integer,                    intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write the Arrays into a file. For this API to be functional,
     the environment variable <TT>ESMF_PIO</TT> should be set to either "internal" or "external"
     when the ESMF library is built. Please see the section on 
     Data I/O,&nbsp;<A HREF="#io:dataio">38.2</A>.

<P>
When <TT>convention</TT> and <TT>purpose</TT> arguments are specified, NetCDF dimension
     labels and variable attributes are written from each Array in the ArrayBundle
     from the corresponding Attribute package. Additionally, Attributes may be
     set on the ArrayBundle level under the same Attribute package.  This allows
     the specification of global attributes within the file.
     As with individual Arrays, the value associated with each name may be either
     a scalar character string, or a scalar or array of type integer, real, or
     double precision.

<P>
Limitations:
     
<UL>
<LI>For multi-tile Arrays,all Arrays in the ArrayBundle must contain
       the same number of tiles.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD>An <TT>ESMF_ArrayBundle</TT> object.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the output file to which array bundle data is written.
       If the ArrayBundle contains multi-tile Arrays, then fileName must contain
       exactly one instance of "*"; this is a placeholder that will be replaced
       by the tile number, with each tile being written to a separate file. (For
       example, for a fileName of "myfile*.nc", tile 1 will be written to
       "myfile1.nc", tile 2 to "myfile2.nc", etc.)
       (This handling of the fileName for multi-tile I/O is subject to change.)
     
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>Specifies an Attribute package associated with the ArrayBundle, and the
       contained Arrays, used to create NetCDF dimension labels and attributes
       in the file.  When this argument is present, the <TT>purpose</TT> 
       argument must also be present.  Use this argument only with a NetCDF
       I/O format. If binary format is used, ESMF will return an error code.
     
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>Specifies an Attribute package associated with the ArrayBundle, and the
       contained Arrays, used to create NetCDF dimension labels and attributes
       in the file.  When this argument is present, the <TT>convention</TT> 
       argument must also be present.  Use this argument only with a NetCDF
       I/O format. If binary format is used, ESMF will return an error code.
     
</DD>
<DT><STRONG>[singleFile]</STRONG></DT>
<DD>A logical flag, the default is .true., i.e., all arrays in the bundle 
       are written in one single file. If .false., each array will be written
       in separate files; these files are numbered with the name based on the
       argument "file". That is, a set of files are named: [file_name]001,
       [file_name]002, [file_name]003,...
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Array data may
        <EM>not</EM> be overwritten. If .true., only the
        data corresponding to each Array's name will be
        be overwritten. If the <TT>timeslice</TT> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.

</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Please see Section&nbsp;<A HREF="node9.html#const:filestatusflag">54.21</A> for
      the list of options. If not present, defaults to
      <TT>ESMF_FILESTATUS_UNKNOWN</TT>.

</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Some I/O formats (e.g. NetCDF) support the output of data in form of
      time slices. The <TT>timeslice</TT> argument provides access to this
      capability. <TT>timeslice</TT> must be positive. The behavior of this
      option may depend on the setting of the <TT>overwrite</TT> flag:
      <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
      less than the maximum time already in the file, the write will fail.
      
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
      
</DD>
</DL>
      By default, i.e. by omitting the <TT>timeslice</TT> argument, no
      provisions for time slicing are made in the output file,
      however, if the file already contains a time axis for the variable,
      a timeslice one greater than the maximum will be written.

</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Please see Section&nbsp;<A HREF="node9.html#opt:iofmtflag">54.28</A> for the list
      of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION05050000000000000000">
<SPAN CLASS="arabic">28</SPAN> Array Class</A>
</H1>

<H2><A NAME="SECTION05051000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The Array class is an alternative to the Field class for representing
distributed, structured data.  Unlike Fields, which are built to carry
grid coordinate information, Arrays only carry information about the
<I>indices</I> associated with grid cells.  Since they do not have coordinate
information, Arrays cannot be used to calculate interpolation weights.
However, if the user supplies interpolation weights, the Array sparse
matrix multiply (SMM) operation can be used to apply the weights and transfer
data to the new grid.  Arrays carry enough information to perform
redistribution, scatter, and gather communication operations.

<P>
Like Fields, Arrays can be added to a State and used in inter-Component
data communications.  Arrays can also be grouped together into ArrayBundles,
allowing operations to be performed collectively on the whole group.  One
motivation for this is convenience; another is the ability to schedule
optimized, collective data transfers.

<P>
From a technical standpoint, the ESMF Array class is an index space based,
distributed data storage class. Its purpose is to hold distributed user data.
Each decompositon element (DE) is associated with its own memory allocation. The
index space relationship between DEs is described by the ESMF DistGrid class.
DEs, and their associated memory allocation, are pinned either to a specific
perisistent execution thread (PET), virtual address space (VAS), or a single
system image (SSI). This aspect is managed by the ESMF DELayout class. Pinning
to PET is the most common mode and is the default.

<P>
The Array class offers common communication patterns within the index space
formalism. All RouteHandle based communication methods of the Field,
FieldBundle, and ArrayBundle layers are implemented via the Array SMM operation.

<H2><A NAME="SECTION05052000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
An <TT>ESMF_Array</TT> is a distributed object that must exist on all PETs of the current context. Each PET-local instance of an Array object contains memory allocations for all PET-local DEs. There may be 0, 1, or more DEs per PET and the number of DEs per PET can differ between PETs for the same Array object. Memory allocations may be provided for each PET by the user during Array creation or can be allocated as part of the Array create call. Many of the concepts of the <TT>ESMF_Array</TT> class are illustrated by the following examples.

<P>

<P>

<P>

<H3><A NAME="SECTION05052100000000000000"></A>
   <A NAME="Array_from_native_1_to_1"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Array from native Fortran array with 1 DE per PET
</H3>

<P>
The create call of the <TT>ESMF_Array</TT> class has been overloaded
   extensively to facilitate the need for generality while keeping simple
   cases simple. The following program demonstrates one of the simpler
   cases, where existing local Fortran arrays are to be used to provide
   the PET-local memory allocations for the Array object.
  
<P>
<PRE>
program ESMF_ArrayFarrayEx
</PRE>

<P>
<PRE>
  use ESMF
  use ESMF_TestMod
  
  implicit none
</PRE>

<P>
The Fortran language provides a variety of ways to define and allocate
   an array. Actual Fortran array objects must either be explicit-shape or
   deferred-shape. In the first case the memory allocation and deallocation is 
   automatic from the user's perspective and the details of the allocation 
   (static or dynamic, heap or stack) are left to the compiler. (Compiler flags
   may be used to control some of the details). In the second case, i.e. for 
   deferred-shape actual objects, the array definition must include the <TT>pointer</TT> 
   or <TT>allocatable</TT> attribute and it is the user's responsibility to allocate 
   memory. While it is also the user's responsibility to deallocate memory for
   arrays with the <TT>pointer</TT> attribute the compiler will automatically deallocate
   allocatable arrays under certain circumstances defined by the Fortran
   standard.

<P>
The <TT>ESMF_ArrayCreate()</TT> interface has been written to accept native
   Fortran arrays of any flavor as a means to allow user-controlled memory
   management. The Array create call will check on each PET if sufficient 
   memory has been provided by the specified Fortran arrays and will indicate 
   an error if a problem is detected. However, the Array create call cannot
   validate the lifetime of the provided memory allocations. If, for instance,
   an Array object was created in a subroutine from an automatic explicit-shape
   array or an allocatable array, the memory allocations referenced by the Array 
   object will be automatically deallocated on return from the subroutine unless
   provisions are made by the application writer to prevent such behavior. The
   Array object cannot control when memory that has been provided by the user
   during Array creation becomes deallocated, however, the Array will indicate
   an error if its memory references have been invalidated. 

<P>
The easiest, portable way to provide safe native Fortran memory allocations
   to Array create is to use arrays with the <TT>pointer</TT> attribute. Memory allocated
   for an array pointer will not be deallocated automatically. However, in this
   case the possibility of memory leaks becomes an issue of concern. The 
   deallocation of memory provided to an Array in form of a native Fortran
   allocation will remain the users responsibility.

<P>
None of the concerns discussed above are an issue in this example where the
   native Fortran array <TT>farray</TT> is defined in the main program. All
   different types of array memory allocation are demonstrated in this example.
   First <TT>farrayE</TT> is defined as a 2D explicit-shape array on each PET which 
   will automatically provide memory for <SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$10\times 10$"></SPAN> elements.
<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8)       :: farrayE(10,10)  ! explicit shape Fortran array
</PRE>

<P>
Then an allocatable array <TT>farrayA</TT> is declared which will be used
   to show user-controlled dynamic memory allocation.
<P>
<PRE>
  real(ESMF_KIND_R8), allocatable :: farrayA(:,:) ! allocatable Fortran array
</PRE>

<P>
Finally an array with pointer attribute <TT>farrayP</TT> is declared, also used
   for user-controlled dynamic memory allocation.
<P>
<PRE>
  real(ESMF_KIND_R8), pointer :: farrayP(:,:)   ! Fortran array pointer
</PRE>

<P>
A matching array pointer must also be available to gain access to the arrays
   held by an Array object.
<P>
<PRE>
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:) ! matching Fortran array ptr 
  type(ESMF_DistGrid)         :: distgrid       ! DistGrid object
  type(ESMF_Array)            :: array          ! Array object
  integer                     :: rc
</PRE>

<P>
<PRE>
  call ESMF_Initialize(defaultlogfilename="ArrayFarrayEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
On each PET <TT>farrayE</TT> can be accessed directly to initialize the entire
   PET-local array.
<P>
<PRE>
  farrayE = 12.45d0 ! initialize to some value
</PRE>

<P>
In order to create an Array object a DistGrid must first be created that 
   describes the total index space and how it is decomposed and distributed.
   In the simplest case only the <TT>minIndex</TT> and <TT>maxIndex</TT> of the 
   total space must be provided.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
This example is assumed to run on 4 PETs. The default 2D decomposition will 
   then be into 4 x 1 DEs as to ensure 1 DE per PET. 

<P>
Now the Array object can be created using the <TT>farrayE</TT> and the DistGrid
   just created.
<P>
<PRE>
  array = ESMF_ArrayCreate(farray=farrayE, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
The 40 x 10 index space defined by the <TT>minIndex</TT> and <TT>maxIndex</TT> 
   arguments paired with the default decomposition will result in the following
   distributed Array.

<P>
<PRE>
  
         +---------------------------&gt; 2nd dimension
         |   (1,1)-------+
         |     |         |
         |     |   DE 0  |   &lt;--- farray on PET 0
         |     |         |
         |     +------(10,10)
         |  (11,1)-------+
         |     |         |
         |     |   DE 1  |   &lt;--- farray on PET 1
         |     |         |
         |     +------(20,10)
         |  (21,1)-------+
         |     |         |
         |     |   DE 2  |   &lt;--- farray on PET 2
         |     |         |
         |     +------(30,10)
         |  (31,1)-------+
         |     |         |
         |     |   DE 3  |   &lt;--- farray on PET 3
         |     |         |
         |     +------(40,10)
         v
       1st dimension
</PRE>

<P>
Providing <TT>farrayE</TT> during Array creation does not change anything about
   the actual <TT>farrayE</TT> object. This means that each PET can use its
   local <TT>farrayE</TT> directly to access the memory referenced by the Array 
   object.
<P>
<PRE>
  print *, farrayE
</PRE>

<P>
Another way of accessing the memory associated with an Array object is to 
   use <TT>ArrayGet()</TT> to obtain an Fortran pointer that references the
   PET-local array.
<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayPtr
</PRE>

<P>
Finally the Array object must be destroyed. The PET-local memory of the
   <TT>farrayE</TT>s will remain in user control and will not be altered by 
   <TT>ArrayDestroy()</TT>.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Since the memory allocation for each <TT>farrayE</TT> is automatic there is
   nothing more to do.

<P>
The interaction between <TT>farrayE</TT> and the Array class is representative
   also for the two other cases <TT>farrayA</TT> and <TT>farrayP</TT>. The only
   difference is in the handling of memory allocations.
<P>
<PRE>
  allocate(farrayA(10,10))    ! user controlled allocation
  farrayA = 23.67d0           ! initialize to some value
  array = ESMF_ArrayCreate(farray=farrayA, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayA            ! print PET-local farrayA directly
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)! obtain array pointer
  print *, farrayPtr          ! print PET-local piece of Array through pointer
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the Array
  deallocate(farrayA)         ! user controlled de-allocation
</PRE>

<P>
The <TT>farrayP</TT> case is identical.
<P>
<PRE>
  allocate(farrayP(10,10))    ! user controlled allocation
  farrayP = 56.81d0           ! initialize to some value
  array = ESMF_ArrayCreate(farray=farrayP, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayP            ! print PET-local farrayA directly
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)! obtain array pointer
  print *, farrayPtr          ! print PET-local piece of Array through pointer
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the Array
  deallocate(farrayP)         ! user controlled de-allocation
</PRE>

<P>
To wrap things up the DistGrid object is destroyed and ESMF can be finalized.
<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc) ! destroy the DistGrid
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION05052200000000000000"></A>
   <A NAME="Array:fpadding"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Array from native Fortran array with extra elements for halo or padding
</H3>

<P>
The example of the previous section showed how easy it is to create an Array
   object from existing PET-local Fortran arrays. The example did, however, not
   define any halo elements around the DE-local regions. The following code
   demonstrates how an Array object with space for a halo can be set up.
<P>
<PRE>
program ESMF_ArrayFarrayHaloEx
</PRE>

<P>
<PRE>
  use ESMF
  use ESMF_TestMod
  
  implicit none
</PRE>

<P>
The allocatable array <TT>farrayA</TT> will be used to provide the PET-local
   Fortran array for this example.
<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8), allocatable :: farrayA(:,:) ! allocatable Fortran array
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:)   ! matching Fortran array ptr
  type(ESMF_DistGrid)         :: distgrid         ! DistGrid object
  type(ESMF_Array)            :: array            ! Array object
  integer                     :: rc, i, j
  real(ESMF_KIND_R8)          :: localSum
</PRE>

<P>
<PRE>
  call ESMF_Initialize(defaultlogfilename="ArrayFarrayHaloEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
The Array is to cover the exact same index space as in the previous
   example. Furthermore decomposition and distribution are also kept the same.
   Hence the same DistGrid object will be created and it is expected to 
   execute this example with 4 PETs.
  
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
This DistGrid describes a 40 x 10 index space that will be decomposed into 
   4 DEs when executed on 4 PETs, associating 1 DE per PET. Each DE-local 
   exclusive region contains 10 x 10 elements. The DistGrid also stores and provides
   information about the relationship between DEs in index space, however,
   DistGrid does not contain information about halos. Arrays contain halo 
   information and it is possible to create multiple Arrays covering the same
   index space with identical decomposition and distribution using the same
   DistGrid object, while defining different, Array-specific halo regions.

<P>
The extra memory required to cover the halo in the Array object must be 
   taken into account when allocating the PET-local <TT>farrayA</TT> arrays. For
   a halo of 2 elements in each direction the following allocation will suffice.
<P>
<PRE>
  allocate(farrayA(14,14))    ! Fortran array with halo: 14 = 10 + 2 * 2
</PRE>

<P>
The <TT>farrayA</TT> can now be used to create an Array object with enough space
   for a two element halo in each direction. The Array creation method checks for 
   each PET that the local Fortran array can accommodate the requested regions.

<P>
The default behavior of ArrayCreate() is to center the exclusive region within
   the total region. Consequently the following call will provide the 2 extra 
   elements on each side of the exclusive 10 x 10 region without having to specify
   any additional arguments.
<P>
<PRE>
  array = ESMF_ArrayCreate(farray=farrayA, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
The exclusive Array region on each PET can be accessed through a suitable
   Fortran array pointer. See section <A HREF="#Array_regions_and_default_bounds">28.2.6</A>
   for more details on Array regions.
<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
Following Array bounds convention, which by default puts the beginning of 
   the exclusive region at (1, 1, ...), the following loop will add up the 
   values of the local exclusive region for each DE, regardless of how the bounds
   were chosen for the original PET-local <TT>farrayA</TT> arrays.
<P>
<PRE>
  localSum = 0.
  do j=1, 10
    do i=1, 10
      localSum = localSum + farrayPtr(i, j)
    enddo
  enddo
</PRE>

<P>
Elements with <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$i$"></SPAN> or <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> in the [-1,0] or [11,12] ranges are located outside the
   exclusive region and may be used to define extra computational points or 
   halo operations.

<P>
Cleanup and shut down ESMF.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(farrayA)
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION05052300000000000000"></A>
   <A NAME="Array:LocalArray"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Array from <TT>ESMF_LocalArray</TT>
</H3>

<P>
Alternative to the direct usage of Fortran arrays during Array creation
   it is also possible to first create an <TT>ESMF_LocalArray</TT> and create the
   Array from it. While this may seem more burdensome for the 1 DE per PET cases
   discussed in the previous sections it allows a straightforward
   generalization to the multiple DE per PET case. The following example first
   recaptures the previous example using an <TT>ESMF_LocalArray</TT> and then
   expands to the multiple DE per PET case.
   
<P>
<PRE>
program ESMF_ArrayLarrayEx
</PRE>

<P>
<PRE>
  use ESMF
  use ESMF_TestMod
  
  implicit none
</PRE>

<P>
The current <TT>ESMF_LocalArray</TT> interface requires Fortran arrays to be 
   defined with pointer attribute.
<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8), pointer :: farrayP(:,:)   ! Fortran array pointer
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:) ! matching Fortran array ptr 
  type(ESMF_LocalArray)       :: larray         ! ESMF_LocalArray object
  type(ESMF_LocalArray)       :: larrayRef      ! ESMF_LocalArray object
  type(ESMF_DistGrid)         :: distgrid       ! DistGrid object
  type(ESMF_Array)            :: array          ! Array object
  integer                     :: rc, i, j, de
  real(ESMF_KIND_R8)          :: localSum
  type(ESMF_LocalArray), allocatable :: larrayList(:) ! LocalArray object list
  type(ESMF_LocalArray), allocatable :: larrayRefList(:)!LocalArray obj. list
  
  type(ESMF_VM):: vm
  integer:: localPet, petCount
</PRE>

<P>
<PRE>
  call ESMF_Initialize(vm=vm, defaultlogfilename="ArrayLarrayEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
  if (petCount /= 4) then
    finalrc = ESMF_FAILURE
    goto 10
  endif
</PRE>

<P>
DistGrid and array allocation remains unchanged.
  
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
<PRE>
  allocate(farrayP(14,14))    ! allocate Fortran array on each PET with halo
</PRE>

<P>
Now instead of directly creating an Array object using the PET-local 
   <TT>farrayP</TT>s an <TT>ESMF_LocalArray</TT> object will be created on each PET.
<P>
<PRE>
  larray = ESMF_LocalArrayCreate(farrayP, &amp;
               datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
</PRE>

<P>
The Array object can now be created from <TT>larray</TT>. The Array 
   creation method checks for each PET that the LocalArray can 
   accommodate the requested regions.
<P>
<PRE>
  array = ESMF_ArrayCreate(localarrayList=(/larray/), distgrid=distgrid, rc=rc)
</PRE>

<P>
Once created there is no difference in how the Array object can be used.
   The exclusive Array region on each PET can be accessed through a suitable
   Fortran array pointer as before.
<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
Alternatively it is also possible (independent of how the Array object was
   created) to obtain the reference to the array allocation held by Array in 
   form of an <TT>ESMF_LocalArray</TT> object. The <TT>farrayPtr</TT> can then be
   extracted using LocalArray methods.
<P>
<PRE>
  call ESMF_ArrayGet(array, localarray=larrayRef, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_LocalArrayGet(larrayRef, farrayPtr, rc=rc)
</PRE>

<P>
Either way the <TT>farrayPtr</TT> reference can be used now to add up the values
   of the local exclusive region for each DE. The following loop 
   works regardless of how the bounds were chosen for the original PET-local 
   <TT>farrayP</TT> arrays and consequently the PET-local <TT>larray</TT> objects.
<P>
<PRE>
  localSum = 0.
  do j=1, 10
    do i=1, 10
      localSum = localSum + farrayPtr(i, j)
    enddo
  enddo
  print *, "localSum=", localSum
</PRE>

<P>
Cleanup.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
  call ESMF_LocalArrayDestroy(larray, rc=rc)
  deallocate(farrayP)   ! use the pointer that was used in allocate statement
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
While the usage of LocalArrays is unnecessarily cumbersome for 1 DE per PET
   Arrays, it provides a straightforward path for extending the interfaces
   to multiple DEs per PET. 

<P>
In the following example a 8 x 8 index space will be decomposed into
   2 x 4 = 8 DEs. The situation is captured by the following DistGrid object.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/8,8/), &amp;
    regDecomp=(/2,4/), rc=rc)
</PRE>

<P>
The <TT>distgrid</TT> object created in this manner will contain 8 DEs no 
   matter how many PETs are available during execution. Assuming an execution
   on 4 PETs will result in the following distribution of the decomposition.

<P>
<PRE>
   
    +---------------------------------------&gt; 2nd dimension
    |  (1,1)
    |    +-----------+-----------+-----------+-----------+
    |    | DE0, PET0 | DE2, PET1 | DE4, PET2 | DE6, PET3 |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    +-----------+-----------+-----------+-----------+
    |    | DE1, PET0 | DE3, PET1 | DE5, PET2 | DE7, PET3 |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    +-----------+-----------+-----------+-----------+
    |                                                    (8,8)
    v 
   1st dimension
</PRE>

<P>
Obviously each PET is associated with 2 DEs. Each PET must allocate enough
   space for <EM>all</EM> its DEs. This is done by allocating 
   as many DE-local arrays as there are DEs on the PET. The reference to these
   array allocations is passed into ArrayCreate via a LocalArray list argument
   that holds as many elements as there are DEs on the PET. Here each PET must
   allocate for two DEs.
  
<P>
<PRE>
  allocate(larrayList(2))   ! 2 DEs per PET
  allocate(farrayP(4, 2))   ! without halo each DE is of size 4 x 2 
  farrayP = 123.456d0
  larrayList(1) = ESMF_LocalArrayCreate(farrayP, &amp;
    datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc) !1st DE
  allocate(farrayP(4, 2))   ! without halo each DE is of size 4 x 2 
  farrayP = 456.789d0
  larrayList(2) = ESMF_LocalArrayCreate(farrayP, &amp;
    datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc) !2nd DE
</PRE>

<P>
Notice that it is perfectly fine to <EM>re</EM>-use <TT>farrayP</TT> for all
   allocations of DE-local Fortran arrays. The allocated memory can be 
   deallocated at the end using the array pointer contained in the 
   <TT>larrayList</TT>.

<P>
With this information an Array object can be created. The <TT>distgrid</TT>
   object indicates 2 DEs for each PET and ArrayCreate() expects to find two
   LocalArray elements in <TT>larrayList</TT>.
<P>
<PRE>
  array = ESMF_ArrayCreate(localarrayList=larrayList, distgrid=distgrid, rc=rc)
</PRE>

<P>
Usage of a LocalArray list is the only way to provide a list of variable 
   length of Fortran array allocations to ArrayCreate() for each PET. The 
   <TT>array</TT> object created by the above call is an ESMF distributed 
   object. As such it must follow the ESMF convention that requires that 
   the call to <TT>ESMF_ArrayCreate()</TT> must be issued in unison by all 
   PETs of the current context. Each PET only calls ArrayCreate() once, even if
   there are multiple DEs per PET.

<P>
The ArrayGet() method provides access to the list of LocalArrays on each PET.
<P>
<PRE>
  allocate(larrayRefList(2))
  call ESMF_ArrayGet(array, localarrayList=larrayRefList, rc=rc)
</PRE>

<P>
Finally, access to the actual Fortran pointers is done on a per DE basis.
   Generally each PET will loop over its DEs.
<P>
<PRE>
  do de=1, 2
    call ESMF_LocalArrayGet(larrayRefList(de), farrayPtr, rc=rc)
    localSum = 0.
    do j=1, 2
      do i=1, 4
        localSum = localSum + farrayPtr(i, j)
      enddo
    enddo
    print *, "localSum=", localSum
  enddo
</PRE>

<P>
Note: If the VM associates multiple PEs with a PET the application writer 
   may decide to use OpenMP loop parallelization on the <TT>de</TT> loop.

<P>
Cleanup requires that the PET-local deallocations are done before the 
   pointers to the actual Fortran arrays are lost. Notice that <TT>larrayList</TT>
   is used to obtain the pointers used in the deallocate statement. Pointers
   obtained from the <TT>larrayRefList</TT>, while pointing to the same data, 
   <EM>cannot</EM> be used to deallocate the array allocations!
<P>
<PRE>
  do de=1, 2
    call ESMF_LocalArrayGet(larrayList(de), farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
    deallocate(farrayPtr)
    call ESMF_LocalArrayDestroy(larrayList(de), rc=rc)
</PRE>

<P>
<PRE>
  enddo
  deallocate(larrayList)
  deallocate(larrayRefList)
  call ESMF_ArrayDestroy(array, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  call ESMF_DistGridDestroy(distgrid, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
With that ESMF can be shut down cleanly.
<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION05052400000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Create Array with automatic memory allocation</A>
</H3>

<P>
In the examples of the previous sections the user provided memory allocations
   for each of the DE-local regions for an Array object. The user was able to 
   use any of the Fortran methods to allocate memory, or go through
   the <TT>ESMF_LocalArray</TT> interfaces to obtain memory allocations before
   passing them into ArrayCreate(). Alternatively ESMF offers methods that 
   handle Array memory allocations inside the library.

<P>
As before, to create an <TT>ESMF_Array</TT> object an <TT>ESMF_DistGrid</TT>
   must be created. The DistGrid object holds information about the entire 
   index space and how it is decomposed into DE-local exclusive regions. The 
   following line of code creates a DistGrid for a 5x5 global index space that 
   is decomposed into 2 x 3 = 6 DEs.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
The following is a representation of the index space and its decomposition into
   DEs. Each asterisk (*) represents a single element.

<P>
<PRE>
   
    +---------------------------------------&gt; 2nd dimension
    |  (1,1)
    |    +-----------+-----------+------+
    |    | DE 0      | DE 2      | DE 4 |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    +-----------+-----------+------+
    |    |           |           |      |
    |    | DE 1      | DE 3      | DE 5 |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    +-----------+-----------+------+
    |                                 (5,5)
    v 
   1st dimension
</PRE>

<P>
Besides the DistGrid it is the <EM>type, kind</EM> and <EM>rank</EM> information,
   "tkr" for short, that is required to create an Array object. It turns out that
   the rank of the Array object is fully determined by the DistGrid and other 
   (optional) arguments passed into ArrayCreate(), so that explicit 
   specification of the Array rank is redundant.

<P>
The simplest way to supply the type and kind information of the Array is
   directly through the <TT>typekind</TT> argument. Here a double precision Array
   is created on the previously created DistGrid. Since no other arguments are
   specified that could alter the rank of the Array it becomes equal to the 
   dimCount of the DistGrid, i.e a 2D Array is created on top of the DistGrid.
<P>
<PRE>
  array = ESMF_ArrayCreate(typekind=ESMF_TYPEKIND_R8, distgrid=distgrid, rc=rc)
</PRE>

<P>
The different methods on how an Array object is created have no effect on
   the use of <TT>ESMF_ArrayDestroy()</TT>.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Alternatively the same Array can be created specifying the "tkr" information
   in form of an ArraySpec variable. The ArraySpec explicitly contains the 
   Array rank and thus results in an over specification on the ArrayCreate()
   interface. ESMF checks all input information for consistency and returns 
   appropriate error codes in case any inconsistencies are found.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
The Array object created by the above call is an ESMF distributed 
   object. As such it must follow the ESMF convention that requires that 
   the call to <TT>ESMF_ArrayCreate()</TT> must be issued in unison by all 
   PETs of the current context. 

<P>

<H3><A NAME="SECTION05052500000000000000"></A>
   <A NAME="Array_native_language_localde"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Native language memory access
</H3>

<P>
There are two different methods by which the user can access the data held 
   inside an ESMF Array object. The first method provides direct access to a
   native language array object. Specifically, the <TT>farrayPtr</TT> argument
   returned by <TT>ESMF_ArrayGet()</TT> is a Fortran array pointer that can be
   used to access the PET-local data inside the Array object.

<P>
Many applications work in the 1 DE per PET mode, with exactly one DE on 
   every PET. Accessing the Array memory on each PET for this situation is 
   especially simple as is shown in section <A HREF="#Array_from_native_1_to_1">28.2.1</A>.
   However, the Array class is not restricted to the special 1 DE per PET case,
   but supports multiple separate memory allocations on each PET.
   The number of such PET-local allocations is given by the <TT>localDeCount</TT>,
   i.e. there is one memory allocation for every DE that is associated with the
   local PET.

<P>
Access to a specific local memory allocation of an Array object is still
   accomplished by returning the <TT>farrayPtr</TT> argument. However, for
   <!-- MATH
 $localDeCount > 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="132" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img63.png"
 ALT="$localDeCount &gt; 1 $"></SPAN> the formally optional <TT>localDe</TT> argument to
   <TT>ESMF_ArrayGet()</TT> turns into a practically required argument. While
   in general the <TT>localDe</TT> in ESMF is simply a local index variable that 
   enumerates the DEs that are associated with the local PET (e.g. see section
   <A HREF="node6.html#DELayout_general_mapping">50.3.7</A>), the bounds of this index variable are 
   strictly defined as <TT>[0,...,localDeCount-1]</TT> when it is used as an 
   input argument. The following code demonstrates this.

<P>
First query the Array for <TT>localDeCount</TT>. This number may be different
   on each PET and indicates how many DEs are mapped against the local PET.
<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
</PRE>

<P>
Looping the <TT>localDe</TT> index variable from 0 to <TT>localDeCount-1</TT> allows
   access to each of the local memory allocations of the Array object:
<P>
<PRE>
  do localDe=0, localDeCount-1
    call ESMF_ArrayGet(array, farrayPtr=myFarray, localDe=localDe, rc=rc)
</PRE>

<P>
<PRE>
    ! use myFarray to access local DE data
  enddo
</PRE>

<P>
The second method to access the memory allocations in an Array object is to
   go through the ESMF LocalArray object. To this end the Array is queried
   for a list of PET-local LocalArray objects. The LocalArray objects in the list
   correspond to the DEs on the local PET. Here the <TT>localDe</TT> argument is
   solely a user level index variable, and in principle the lower bound can be 
   chosen freely. However, for better alignment with the previous case (where 
   <TT>localDe</TT> served as an input argument to an ESMF method) the following
   example again fixes the lower bound at zero.
<P>
<PRE>
  allocate(larrayList(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
</PRE>

<P>
<PRE>
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
</PRE>

<P>
<PRE>
    ! use myFarray to access local DE data
  enddo
</PRE>

<P>
See section <A HREF="#Array:LocalArray">28.2.3</A> for more on LocalArray usage in Array. 
   In most cases memory access through a LocalArray list is less convenient than
   the direct <TT>farrayPtr</TT> method because it adds an extra object level 
   between the ESMF Array and the native language array.  

<P>

<H3><A NAME="SECTION05052600000000000000"></A>
   <A NAME="Array_regions_and_default_bounds"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Regions and default bounds
</H3>

<P>
Each <TT>ESMF_Array</TT> object is decomposed into DEs as specified by the
   associated <TT>ESMF_DistGrid</TT> object. Each piece of this decomposition, i.e.
   each DE, holds a chunk of the Array data in its own local piece of memory.
   The details of the Array decomposition are described in the following 
   paragraphs.

<P>
At the center of the Array decomposition is the <TT>ESMF_DistGrid</TT> class.
   The DistGrid object specified during Array creation contains three essential
   pieces of information:
   
<UL>
<LI>The extent and topology of the global domain covered by the Array object
         in terms of indexed elements. The total extent may be a composition of
         smaller logically rectangular (LR) domain pieces called tiles.
</LI>
<LI>The decomposition of the entire domain into "element exclusive" DE-local
         LR chunks. <EM>Element exclusive</EM> means that there is no element overlap
         between DE-local chunks. This, however, does not exclude degeneracies 
         on edge boundaries for certain topologies (e.g. bipolar).
</LI>
<LI>The layout of DEs over the available PETs and thus the distribution of
         the Array data.
   
</LI>
</UL>

<P>
Each element of an Array is associated with a <EM>single</EM> DE. The union of
   elements associated with a DE, as defined by the DistGrid above, corresponds
   to a LR chunk of index space, called the <EM>exclusive region</EM> of the DE.

<P>
There is a hierarchy of four regions that can be identified for each DE in an
   Array object. Their definition and relationship to each other is as follows:
   
<UL>
<LI><EM>Interior Region</EM>: Region that only contains local elements that are
         <EM>not</EM> mapped into the halo of any other DE. The shape and size of 
         this region for a particular DE depends non-locally on the halos defined
         by other DEs and may change during computation as halo operations are
         precomputed and released. Knowledge of the interior elements may be used
         to improve performance by overlapping communications with ongoing 
         computation for a DE.
</LI>
<LI><EM>Exclusive Region</EM>: Elements for which a DE claims exclusive
         ownership. Practically this means that the DE will be the sole source
         for these elements in halo and reduce operations. There are exceptions
         to this in some topologies. The exclusive region includes all elements
         of the interior region.
</LI>
<LI><EM>Computational Region</EM>: Region that can be set arbitrarily within
         the bounds of the total region (defined next). The typical use of the
         computation region is to define bounds that only include elements that
         are updated by a DE-local computation kernel. The computational region
         does not need to include all exclusive elements and it may also contain
         elements that lie outside the exclusive region.
</LI>
<LI><EM>Total (Memory) Region</EM>: Total of all DE-locally allocated elements.
         The size and shape of the total memory region must accommodate the
         union of exclusive and computational region but may contain 
         additional elements. Elements outside the exclusive region may overlap
         with the exclusive region of another DE which makes them potential 
         receivers for Array halo operations. Elements outside the exclusive
         region that do not overlap with the exclusive region of another DE
         can be used to set boundary conditions and/or serve as extra memory 
         padding.
   
</LI>
</UL>

<P>
<PRE>
  
     +-totalLBound(:)----------------------------------+
     |\                                                |
     | \ &lt;--- totalLWidth(:)                           |
     |  \                                              |
     |   +-computationalLBound(:)------------------+   |
     |   |\                                        |   |
     |   | \ &lt;--- computationalLWidth(:)           |   |
     |   |  \                                      |   |
     |   |   +-exclusiveLBound(:)-------------+    |   |
     |   |   |                                |    |   |
     |   |   |     +------+      +-----+      |    |   |
     |   |   |     |      |      |     |      |    |   |
     |   |   |     |      +------+     |      |    |   |
     |   |   |     | "Interior Region" |      |    |   |
     |   |   |     +-----+             |      |    |   |
     |   |   |           |             |      |    |   |
     |   |   |           +-------------+      |    |   |
     |   |   |                                |    |   |
     |   |   | "Exclusive Region"             |    |   |
     |   |   +-------------exclusiveUBound(:)-+    |   |
     |   |                                     \   |   |
     |   |           computationalUWidth(:) --&gt; \  |   |
     |   |                                       \ |   |
     |   | "Computational Region"                 \|   |
     |   +------------------computationalUBound(:)-+   |
     |                                              \  | 
     |                             totalUWidth(:) -&gt; \ | 
     | "Total Region"                                 \| 
     +--------------------------------- totalUBound(:)-+
</PRE>

<P>
With the following definitions:
   <PRE>
  
   computationalLWidth(:) = exclusiveLBound(:) - computationalLBound(:)
   computationalUWidth(:) = computationalUBound(:) - exclusiveUBound(:)
</PRE>
   and
   <PRE>
  
   totalLWidth(:) = exclusiveLBound(:) - totalLBound(:)
   totalUWidth(:) = totalUBound(:) - exclusiveUBound(:)
</PRE>

<P>
The <EM>exclusive region</EM> is determined during Array creation by the 
   DistGrid argument. Optional arguments may be used to specify the 
   <EM>computational region</EM> when the Array is created, by default it will be
   set equal to the exclusive region. The <EM>total region</EM>, i.e. the actual
   memory allocation for each DE, is also determined during Array creation. When
   creating the Array object from existing Fortran arrays the total region is
   set equal to the memory provided by the Fortran arrays. Otherwise the 
   default is to allocate as much memory as is needed to accommodate the union
   of the DE-local exclusive and computational region. Finally it is also
   possible to use optional arguments to the ArrayCreate() call to specify the
   total region of the object explicitly.

<P>
The <TT>ESMF_ArrayCreate()</TT> call checks that the input parameters are
   consistent and will result in an Array that fulfills all of the above 
   mentioned requirements for its DE-local regions.

<P>
Once an Array object has been created the exclusive and total regions are
   fixed. The computational region, however, may be adjusted within the limits
   of the total region using the <TT>ArraySet()</TT> call.

<P>
The <EM>interior region</EM> is very different from the other regions in that
   it cannot be specified. The <EM>interior region</EM> for each DE is a <EM>   consequence</EM> of the choices made for the other regions collectively across
   all DEs into which an Array object is decomposed. An Array object can be
   queried for its DE-local <EM>interior regions</EM> as to offer additional
   information to the user necessary to write more efficient code.
   
<P>
By default the bounds of each DE-local <EM>total region</EM> are defined as
   to put the start of the DE-local <EM>exclusive region</EM> at the "origin" of 
   the local index space, i.e. at <TT>(1, 1, ..., 1)</TT>. With that definition the
   following loop will access each element of the DE-local memory segment for
   each PET-local DE of the Array object used in the previous sections and
   print its content.
<P>
<PRE>
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    do i=1, size(myFarray, 1)
      do j=1, size(myFarray, 2)
        print *, "localPET=", localPet, " localDE=", &amp;
            localDe, ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION05052700000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Array bounds</A>
</H3>

<P>
The loop over Array elements at the end of the last section only works
   correctly because of the default definition of the <EM>computational</EM> and
   <EM>total regions</EM> used in the example. In general, without such specific
   knowledge about an Array object, it is necessary to use a more formal approach
   to access its regions with DE-local indices.

<P>
The DE-local <EM>exclusive region</EM> takes a central role in the definition
   of Array bounds. Even as the <EM>computational region</EM> may adjust during 
   the course of execution the <EM>exclusive region</EM> remains unchanged.
   The <EM>exclusive region</EM> provides a unique reference frame
   for the index space of all Arrays associated with the same DistGrid.

<P>
There is a choice between two indexing options that needs to be made during 
   Array creation. By default each DE-local exclusive region starts at 
   <TT>(1, 1, ..., 1)</TT>. However, for some computational kernels it may be more
   convenient to choose the index bounds of the DE-local exclusive regions to 
   match the index space coordinates as they are defined in the corresponding
   DistGrid object. The second option is only available if the DistGrid object 
   does not contain any non-contiguous decompositions (such as cyclically
   decomposed dimensions).

<P>
The following example code demonstrates the safe way of dereferencing the
   DE-local exclusive regions of the previously created <TT>array</TT> object.

<P>
<PRE>
  allocate(exclusiveUBound(2, 0:localDeCount-1))  ! dimCount=2
  allocate(exclusiveLBound(2, 0:localDeCount-1))  ! dimCount=2
  call ESMF_ArrayGet(array, indexflag=indexflag, &amp;
    exclusiveLBound=exclusiveLBound, exclusiveUBound=exclusiveUBound, rc=rc)
  if (indexflag == ESMF_INDEX_DELOCAL) then
    ! this is the default
!    print *, "DE-local exclusive regions start at (1,1)"
    do localDe=0, localDeCount-1
      call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &amp;
          datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
      do i=1, exclusiveUBound(1, localDe)
        do j=1, exclusiveUBound(2, localDe)
!          print *, "DE-local exclusive region for localDE=", localDe, &amp;
!            ": array(",i,",",j,")=", myFarray(i,j)
        enddo
      enddo
    enddo
  else if (indexflag == ESMF_INDEX_GLOBAL) then
    ! only if set during ESMF_ArrayCreate()
!    print *, "DE-local exclusive regions of this Array have global bounds"
    do localDe=0, localDeCount-1
      call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &amp;
         datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
      do i=exclusiveLBound(1, localDe), exclusiveUBound(1, localDe)
        do j=exclusiveLBound(2, localDe), exclusiveUBound(2, localDe)
!          print *, "DE-local exclusive region for localDE=", localDe, &amp;
!            ": array(",i,",",j,")=", myFarray(i,j)
        enddo
      enddo
    enddo
  endif
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the array object
</PRE>

<P>
Obviously the second branch of this simple code will work for either case, 
   however, if a complex computational kernel was written assuming 
   <TT>ESMF_INDEX_DELOCAL</TT> type bounds the second branch would simply be 
   used to indicate the problem and bail out.

<P>
The advantage of the <TT>ESMF_INDEX_GLOBAL</TT> index option is that
   the Array bounds directly contain information on where the DE-local
   Array piece is located in a global index space sense. When the
   <TT>ESMF_INDEX_DELOCAL</TT> option is used the correspondence between local
   and global index space must be made by querying the associated DistGrid for
   the DE-local <TT>indexList</TT> arguments. 

<P>

<H3><A NAME="SECTION05052800000000000000"></A>
   <A NAME="Array:padding"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Computational region and extra elements for halo or padding
</H3>

<P>
In the previous examples the computational region of <TT>array</TT> was chosen 
   by default to be identical to the exclusive region defined by the DistGrid
   argument during Array creation. In the following the same <TT>arrayspec</TT> and
   <TT>distgrid</TT> objects as before will be used to create an Array but now a 
   larger computational region shall be defined around each DE-local exclusive 
   region. Furthermore, extra space will be defined around the computational
   region of each DE to accommodate a halo and/or serve as memory padding.

<P>
In this example the <TT>indexflag</TT> argument is set to 
   <TT>ESMF_INDEX_GLOBAL</TT> indicating that the bounds of the exclusive region
   correspond to the index space coordinates as they are defined by the DistGrid
   object.

<P>
The same <TT>arrayspec</TT> and <TT>distgrid</TT> objects as before are used
   which also allows the reuse of the already allocated <TT>larrayList</TT>
   variable.
<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    computationalLWidth=(/0,3/), computationalUWidth=(/1,1/), &amp;
    totalLWidth=(/1,4/), totalUWidth=(/3,1/), &amp;
    indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
Obtain the <TT>larrayList</TT> on every PET.
<P>
<PRE>
  allocate(localDeToDeMap(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, &amp;
    localDeToDeMap=localDeToDeMap, rc=rc)
</PRE>

<P>
The bounds of DE 1 for <TT>array</TT> are shown in the following 
   diagram to illustrate the situation. Notice that the <TT>totalLWidth</TT> and
   <TT>totalUWidth</TT> arguments in the ArrayCreate() call define the total region 
   with respect to the exclusive region given for each DE by the <TT>distgrid</TT> 
   argument.

<P>
<PRE>
        +-(3,-3)---------------------------------+ 
        |\                                       | 
        | +-(4,-2)-+-(4,1)--------------------+--+ 
        | |        |                          |  | 
        | |        |                          |  | 
        | |        |          DE 1            |  | 
        | |        |                          |  | 
        | |        |                          |  | 
        | |        | Exclusive Region         |  | 
        | |        +--------------------(5,2)-+  | 
        | | Computational Region                 | 
        | +-------------------------------(6,3)--+ 
        |                                        | 
        | Total Region                           | 
        +---------------------------------(8,3)--+
</PRE>

<P>
When working with this <TT>array</TT> it is possible for the computational
   kernel to overstep the exclusive region for both read/write access 
   (computational region) and potentially read-only access into the total region
   outside of the computational region, if a halo operation provides valid 
   entries for these elements. 

<P>
The Array object can be queried for absolute <EM>bounds</EM>
<P>
<PRE>
  allocate(computationalLBound(2, 0:localDeCount-1))  ! dimCount=2
  allocate(computationalUBound(2, 0:localDeCount-1))  ! dimCount=2
  allocate(totalLBound(2, 0:localDeCount-1))          ! dimCount=2
  allocate(totalUBound(2, 0:localDeCount-1))          ! dimCount=2
  call ESMF_ArrayGet(array, exclusiveLBound=exclusiveLBound, &amp;
    exclusiveUBound=exclusiveUBound, &amp;
    computationalLBound=computationalLBound, &amp;
    computationalUBound=computationalUBound, &amp;
    totalLBound=totalLBound, &amp;
    totalUBound=totalUBound, rc=rc)
</PRE>

<P>
or for the relative <EM>widths</EM>.
<P>
<PRE>
  allocate(computationalLWidth(2, 0:localDeCount-1))  ! dimCount=2
  allocate(computationalUWidth(2, 0:localDeCount-1))  ! dimCount=2
  allocate(totalLWidth(2, 0:localDeCount-1))          ! dimCount=2
  allocate(totalUWidth(2, 0:localDeCount-1))          ! dimCount=2
  call ESMF_ArrayGet(array, computationalLWidth=computationalLWidth, &amp;
    computationalUWidth=computationalUWidth, totalLWidth=totalLWidth, &amp;
    totalUWidth=totalUWidth, rc=rc)
</PRE>

<P>
Either way the dereferencing of Array data is centered around the DE-local
   exclusive region:
<P>
<PRE>
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    ! initialize the DE-local array
    myFarray = 0.1d0 * localDeToDeMap(localDe)
    ! first time through the total region of array    
!    print *, "myFarray bounds for DE=", localDeToDeMap(localDe), &amp;
!      lbound(myFarray),  ubound(myFarray)
    do j=exclusiveLBound(2, localDe), exclusiveUBound(2, localDe)
      do i=exclusiveLBound(1, localDe), exclusiveUBound(1, localDe)
!        print *, "Excl region DE=", localDeToDeMap(localDe), &amp;
!        ": array(",i,",",j,")=",  myFarray(i,j)
      enddo
    enddo
    do j=computationalLBound(2, localDe), computationalUBound(2, localDe)
      do i=computationalLBound(1, localDe), computationalUBound(1, localDe)
!        print *, "Excl region DE=", localDeToDeMap(localDe), &amp;
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
    do j=totalLBound(2, localDe), totalUBound(2, localDe)
      do i=totalLBound(1, localDe), totalUBound(1, localDe)
!        print *, "Total region DE=", localDeToDeMap(localDe), &amp;
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo

    ! second time through the total region of array    
    do j=exclusiveLBound(2, localDe)-totalLWidth(2, localDe), &amp;
      exclusiveUBound(2, localDe)+totalUWidth(2, localDe)
      do i=exclusiveLBound(1, localDe)-totalLWidth(1, localDe), &amp;
        exclusiveUBound(1, localDe)+totalUWidth(1, localDe)
!        print *, "Excl region DE=", localDeToDeMap(localDe), &amp;
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION05052900000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">9</SPAN> Create 1D and 3D Arrays</A>
</H3>

<P>
All previous examples were written for the 2D case. There is, however, no
   restriction within the Array or DistGrid class that limits the dimensionality
   of Array objects beyond the language-specific limitations (7D for Fortran).

<P>
In order to create an <TT>n</TT>-dimensional Array the rank indicated by both
   the <TT>arrayspec</TT> and the <TT>distgrid</TT> arguments specified during Array
   create must be equal to <TT>n</TT>. A 1D Array of double precision real data
   hence requires the following <TT>arrayspec</TT>.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=1, rc=rc)
</PRE>

<P>
The index space covered by the Array and the decomposition description is
   provided to the Array create method by the <TT>distgrid</TT> argument. The index
   space in this example has 16 elements and covers the interval <SPAN CLASS="MATH"><IMG
 WIDTH="56" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img64.png"
 ALT="$[-10, 5]$"></SPAN>. It is 
   decomposed into as many DEs as there are PETs in the current context.
<P>
<PRE>
  distgrid1D = ESMF_DistGridCreate(minIndex=(/-10/), maxIndex=(/5/), &amp;
    regDecomp=(/petCount/), rc=rc)
</PRE>

<P>
A 1D Array object with default regions can now be created.
<P>
<PRE>
  array1D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid1D, rc=rc)
</PRE>

<P>
The creation of a 3D Array proceeds analogous to the 1D case. The rank of the
   <TT>arrayspec</TT> must be changed to 3
 <PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
and an appropriate 3D DistGrid object must be created
 <PRE>
  distgrid3D = ESMF_DistGridCreate(minIndex=(/1,1,1/), &amp;
    maxIndex=(/16,16,16/), regDecomp=(/4,4,4/), rc=rc)
</PRE>

<P>
before an Array object can be created.
<P>
<PRE>
  array3D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid3D, rc=rc)
</PRE>

<P>
The <TT>distgrid3D</TT> object decomposes the 3-dimensional index space into
   <!-- MATH
 $4\times 4\times 4 = 64$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="104" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img65.png"
 ALT="$4\times 4\times 4 = 64$"></SPAN> DEs. These DEs are laid out across the computational
   resources (PETs) of the current component according to a default DELayout that
   is created during the DistGrid create call. Notice that in the index space 
   proposal a DELayout does not have a sense of dimensionality. The DELayout
   function is simply to map DEs to PETs. The DistGrid maps chunks of index space
   against DEs and thus its rank is equal to the number of index space 
   dimensions.

<P>
The previously defined DistGrid and the derived Array object decompose 
   the index space along all three dimension. It is, however, not a requirement
   that the decomposition be along all dimensions. An Array with the same 3D
   index space could as well be decomposed along just one or along two of the
   dimensions. The following example shows how for the same index space only the
   last two dimensions are decomposed while the first Array dimension has full
   extent on all DEs.
<P>
<PRE>
  call ESMF_ArrayDestroy(array3D, rc=rc)
  call ESMF_DistGridDestroy(distgrid3D, rc=rc)
  distgrid3D = ESMF_DistGridCreate(minIndex=(/1,1,1/), &amp;
    maxIndex=(/16,16,16/), regDecomp=(/1,4,4/), rc=rc)
  array3D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid3D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050521000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">10</SPAN> Working with Arrays of different rank</A>
</H3>
   Assume a computational kernel that involves the <TT>array3D</TT> object as it was
   created at the end of the previous section. Assume further that the kernel 
   also involves a 2D Array on a 16x16 index space where each point (j,k) was
   interacting with each (i,j,k) column of the 3D Array. An efficient formulation
   would require that the decomposition of the 2D Array must match that of the 3D
   Array and further the DELayout be identical. The following code shows how this
   can be accomplished.
<P>
<PRE>
  call ESMF_DistGridGet(distgrid3D, delayout=delayout, rc=rc) ! get DELayout
  distgrid2D = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/16,16/), &amp;
    regDecomp=(/4,4/), delayout=delayout, rc=rc)
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  array2D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid2D, rc=rc)
</PRE>

<P>
Now the following kernel is sure to work with <TT>array3D</TT> and <TT>array2D</TT>.
<P>
<PRE>
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
  allocate(larrayList1(0:localDeCount-1))
  call ESMF_ArrayGet(array3D, localarrayList=larrayList1, rc=rc)
  allocate(larrayList2(0:localDeCount-1))
  call ESMF_ArrayGet(array2D, localarrayList=larrayList2, rc=rc)
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList1(localDe), myFarray3D, &amp;
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D = 0.1d0 * localDe ! initialize
    call ESMF_LocalArrayGet(larrayList2(localDe), myFarray2D, &amp;
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray2D = 0.5d0 * localDe ! initialize
    do k=1, 4
      do j=1, 4
        dummySum = 0.d0
        do i=1, 16
          dummySum = dummySum + myFarray3D(i,j,k) ! sum up the (j,k) column
        enddo
        dummySum = dummySum * myFarray2D(j,k) ! multiply with local 2D element
!        print *, "dummySum(",j,k,")=",dummySum
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION050521100000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">11</SPAN> Array and DistGrid rank - 2D+1 Arrays</A>
</H3>

<P>
Except for the special Array create interface that implements a copy from
   an existing Array object all other Array create interfaces require the 
   specification of at least two arguments: <TT>farray</TT> and <TT>distgrid</TT>,
   <TT>larrayList</TT> and <TT>distgrid</TT>, or <TT>arrayspec</TT> and <TT>distgrid</TT>.
   In all these cases both required arguments contain a sense of dimensionality.
   The relationship between these two arguments deserves extra attention.

<P>
The first argument, <TT>farray</TT>, <TT>larrayList</TT> or <TT>arrayspec</TT>, 
   determines the rank of the created Array object, i.e. the dimensionality
   of the actual data storage. The rank of a native language array, extracted 
   from an Array object, is equal to the rank specified by either of these
   arguments. So is the <TT>rank</TT> that is returned by the <TT>ESMF_ArrayGet()</TT>
   call.

<P>
The rank specification contained in the <TT>distgrid</TT> argument, which is of 
   type <TT>ESMF_DistGrid</TT>, on the other hand has no effect on the
   rank of the Array. The <TT>dimCount</TT> specified by the DistGrid object,
   which may be equal, greater or less than the Array rank, determines the 
   dimensionality of the <EM>decomposition</EM>.

<P>
While there is no constraint between DistGrid <TT>dimCount</TT> and Array
   <TT>rank</TT>, there is an important relationship between the two, resulting in
   the concept of index space dimensionality. Array dimensions can be
   arbitrarily mapped against DistGrid dimension, rendering them <EM>decomposed</EM>
   dimensions. The index space dimensionality is equal to the number of 
   decomposed Array dimensions.

<P>
Array dimensions that are not mapped to DistGrid dimensions are the 
   <EM>undistributed</EM> dimensions of the Array. They are not part
   of the index space. The mapping is specified during <TT>ESMF_ArrayCreate()</TT>
   via the <TT>distgridToArrayMap</TT> argument. DistGrid dimensions that have
   not been associated with Array dimensions are <EM>replicating</EM> dimensions.
   The Array will be replicated across the DEs that lie along replication
   DistGrid dimensions.

<P>
Undistributed Array dimensions can be used to store multi-dimensional data for
   each Array index space element. One application of this is to store the 
   components of a vector quantity in a single Array. The same 2D <TT>distgrid</TT>
   object as before will be used.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
The rank in the <TT>arrayspec</TT> argument, however, must change from 2 to 3 in
   order to provide for the extra Array dimension.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
During Array creation with extra dimension(s) it is necessary to specify the
   bounds of these undistributed dimension(s). This requires two additional
   arguments, <TT>undistLBound</TT> and <TT>undistUBound</TT>, which are vectors in 
   order to accommodate multiple undistributed dimensions. The other arguments
   remain unchanged and apply across all undistributed components. 
  
<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/0,1/), totalUWidth=(/0,1/), &amp;
    undistLBound=(/1/), undistUBound=(/2/), rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
This will create <TT>array</TT> with 2+1 dimensions. The 2D DistGrid is used
   to describe decomposition into DEs with 2 Array dimensions mapped to the 
   DistGrid dimensions resulting in a 2D index space. The extra Array dimension
   provides storage for multi component user data within the Array object.

<P>
By default the <TT>distgrid</TT> dimensions are associated
   with the first Array dimensions in sequence. For the example above this means
   that the first 2 Array dimensions are decomposed according to the provided 2D
   DistGrid. The 3rd Array dimension does not have an associated DistGrid
   dimension, rendering it an undistributed Array dimension.

<P>
Native language access to an Array with undistributed dimensions is in
   principle the same as without extra dimensions.
<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
  allocate(larrayList(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
</PRE>

<P>
The following loop shows how a Fortran pointer to the DE-local data chunks
   can be obtained and used to set data values in the exclusive regions. The
   <TT>myFarray3D</TT> variable must be of rank 3 to match the Array rank of
   <TT>array</TT>. However, variables such as <TT>exclusiveUBound</TT> that store the
   information about the decomposition, remain to be allocated for the 2D 
   index space.
<P>
<PRE>
  call ESMF_ArrayGet(array, exclusiveLBound=exclusiveLBound, &amp;
    exclusiveUBound=exclusiveUBound, rc=rc)
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray3D, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D = 0.0 ! initialize
    myFarray3D(exclusiveLBound(1,localDe):exclusiveUBound(1,localDe), &amp;
      exclusiveLBound(2,localDe):exclusiveUBound(2,localDe), &amp;
      1) = 5.1 ! dummy assignment
    myFarray3D(exclusiveLBound(1,localDe):exclusiveUBound(1,localDe), &amp;
      exclusiveLBound(2,localDe):exclusiveUBound(2,localDe), &amp;
      2) = 2.5 ! dummy assignment
  enddo
  deallocate(larrayList)
</PRE>

<P>
For some applications the default association rules between DistGrid and Array
   dimensions may not satisfy the user's needs. The optional <TT>distgridToArrayMap</TT> 
   argument can be used during Array creation to explicitly specify the mapping 
   between DistGrid and Array dimensions. To demonstrate this the following lines
   of code reproduce the above example but with rearranged dimensions. Here the
   <TT>distgridToArrayMap</TT> argument is a list with two elements corresponding to
   the DistGrid <TT>dimCount</TT> of 2. The first element indicates which Array
   dimension the first DistGrid dimension is mapped against. Here the
   1st DistGrid dimension maps against the 3rd Array dimension and the 2nd 
   DistGrid dimension maps against the 1st Array dimension. This leaves the 2nd
   Array dimension to be the extra and undistributed dimension in the resulting
   Array object.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/3, 1/), totalLWidth=(/0,1/), totalUWidth=(/0,1/), &amp;
    undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
Operations on the Array object as a whole are unchanged by the different
   mapping of dimensions.

<P>
When working with Arrays that contain explicitly mapped Array and DistGrid 
   dimensions it is critical to know the order in which the entries of
   <EM>width</EM> and <EM>bound</EM> arguments that are associated with distributed
   Array dimensions are specified. The size of these arguments is equal to the
   DistGrid <TT>dimCount</TT>, because the maximum number of distributed Array
   dimensions is given by the dimensionality of the index space.

<P>
The order of dimensions in these arguments, however, is <EM>not</EM> that of
   the associated DistGrid. Instead each entry corresponds to the distributed
   Array dimensions in sequence. In the example above the entries in 
   <TT>totalLWidth</TT> and <TT>totalUWidth</TT> correspond to Array dimensions 1 and
   3 in this sequence. 

<P>
The <TT>distgridToArrrayMap</TT> argument optionally provided during Array create
   indicates how the DistGrid dimensions map to Array dimensions. The inverse
   mapping, i.e. Array to DistGrid dimensions, is just as important. The 
   <TT>ESMF_ArrayGet()</TT> call offers both mappings as <TT>distgridToArrrayMap</TT>
   and <TT>arrayToDistGridMap</TT>, respectively. The number of elements in 
   <TT>arrayToDistGridMap</TT> is equal to the rank of the Array. Each element
   corresponds to an Array dimension and indicates the associated DistGrid
   dimension by an integer number. An entry of "0" in <TT>arrayToDistGridMap</TT>
   indicates that the corresponding Array dimension is undistributed.

<P>
Correct understanding about the association between Array and DistGrid
   dimensions becomes critical for correct data access into the Array.
<P>
<PRE>
  allocate(arrayToDistGridMap(3))  ! arrayRank = 3
  call ESMF_ArrayGet(array, arrayToDistGridMap=arrayToDistGridMap, &amp;
    exclusiveLBound=exclusiveLBound, exclusiveUBound=exclusiveUBound, &amp;
    localDeCount=localDeCount, rc=rc)  
  if (arrayToDistGridMap(2) /= 0) then   ! check if extra dimension at 
    ! expected index indicate problem and bail out
  endif
  ! obtain larrayList for local DEs
  allocate(larrayList(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray3D, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D(exclusiveLBound(1,localDe):exclusiveUBound(1,localDe), &amp;
      1, exclusiveLBound(2,localDe):exclusiveUBound(2, &amp;
      localDe)) = 10.5 !dummy assignment
    myFarray3D(exclusiveLBound(1,localDe):exclusiveUBound(1,localDe), &amp;
      2, exclusiveLBound(2,localDe):exclusiveUBound(2, &amp;
      localDe)) = 23.3 !dummy assignment
  enddo
  deallocate(exclusiveLBound, exclusiveUBound)
  deallocate(arrayToDistGridMap)
  deallocate(larrayList)
  call ESMF_ArrayDestroy(array, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050521200000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">12</SPAN> Arrays with replicated dimensions</A>
</H3>

<P>
Thus far most examples demonstrated cases where the DistGrid <TT>dimCount</TT>
   was equal to the Array <TT>rank</TT>. The previous section introduced the
   concept of Array <EM>tensor</EM> dimensions when <TT>dimCount &lt; rank</TT>. In this
   section <TT>dimCount</TT> and <TT>rank</TT> are assumed completely unconstrained and
   the relationship to <TT>distgridToArrayMap</TT> and <TT>arrayToDistGridMap</TT> will
   be discussed.

<P>
The Array class allows completely arbitrary mapping between Array and
   DistGrid dimensions. Most cases considered in the previous sections used
   the default mapping which assigns the DistGrid dimensions in sequence to the
   lower Array dimensions. Extra Array dimensions, if present, are considered
   non-distributed tensor dimensions for which the optional <TT>undistLBound</TT>
   and <TT>undistUBound</TT> arguments must be specified.

<P>
The optional <TT>distgridToArrayMap</TT> argument provides the option to override
   the default DistGrid to Array dimension mapping. The entries of the
   <TT>distgridToArrayMap</TT> array correspond to the DistGrid dimensions in
   sequence and assign a unique Array dimension to each DistGrid dimension.
   DistGrid and Array dimensions are indexed starting at <TT>1</TT> for the lowest
   dimension. A value of <TT>"0"</TT> in the <TT>distgridToArrayMap</TT> array 
   indicates that the respective DistGrid dimension is <EM>not</EM> mapped against
   any Array dimension. What this means is that the Array will be replicated 
   along this DistGrid dimension.

<P>
As a first example consider the case where a 1D Array
 <PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=1, rc=rc)
</PRE>

<P>
is created on the 2D DistGrid used during the previous section.
<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
Here the default DistGrid to Array dimension mapping is used which assigns
   the Array dimensions in sequence to the DistGrid dimensions starting with
   dimension "1". Extra DistGrid dimensions are considered replicator dimensions
   because the Array will be replicated along those dimensions. In the above
   example the 2nd DistGrid dimension will cause 1D Array pieces to be
   replicated along the DEs of the 2nd DistGrid dimension. Replication in the
   context of <TT>ESMF_ArrayCreate()</TT> does not mean that data values are
   communicated and replicated between different DEs, but it means that different
   DEs provide memory allocations for <EM>identical</EM> exclusive elements.

<P>
Access to the data storage of an Array that has been replicated along 
   DistGrid dimensions is the same as for Arrays without replication.
<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
</PRE>

<P>
<PRE>
  allocate(larrayList(0:localDeCount-1))
  allocate(localDeToDeMap(0:localDeCount-1))
  call ESMF_ArrayGet(array, localarrayList=larrayList, &amp;
    localDeToDeMap=localDeToDeMap, rc=rc)
</PRE>

<P>
The <TT>array</TT> object was created without additional padding which means
   that the bounds of the Fortran array pointer correspond to the bounds of
   the exclusive region. The following loop will cycle through all local DEs, 
   print the DE number as well as the Fortran array pointer bounds. The bounds
   should be:
   <PRE>
            lbound       ubound
  
   DE 0:      1            3         --+
   DE 2:      1            3         --|  1st replication set
   DE 4:      1            3         --+
  
   DE 1:      1            2         --+
   DE 3:      1            2         --|  2nd replication set
   DE 5:      1            2         --+
</PRE>
<P>
<PRE>
  do localDe=0, localDeCount-1
    call ESMF_LocalArrayGet(larrayList(localDe), myFarray1D, &amp;
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
</PRE>

<P>
<PRE>
    print *, "localPet: ", localPet, "DE ",localDeToDeMap(localDe)," [", &amp;
      lbound(myFarray1D), ubound(myFarray1D),"]"
  enddo
  deallocate(larrayList)
  deallocate(localDeToDeMap)
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
The Fortran array pointer in the above loop was of rank 1 because the
   Array object was of rank 1. However, the <TT>distgrid</TT> object associated
   with <TT>array</TT> is 2-dimensional! Consequently DistGrid based information
   queried from <TT>array</TT> will be 2D. The <TT>distgridToArrayMap</TT> and
   <TT>arrayToDistGridMap</TT>
   arrays provide the necessary mapping to correctly associate DistGrid based 
   information with Array dimensions.

<P>
The next example creates a 2D Array
 <PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
on the previously used 2D DistGrid. By default, i.e. without the
   <TT>distgridToArrayMap</TT>
   argument, both DistGrid dimensions would be associated with the two Array
   dimensions. However, the <TT>distgridToArrayMap</TT> specified in the following
   call will only associate the second DistGrid dimension with the first Array 
   dimension. This will render the first DistGrid dimension a replicator
   dimension and the second Array dimension a tensor dimension for which 1D
   <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments must be supplied.
<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,1/), undistLBound=(/11/), &amp;
    undistUBound=(/14/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Finally, the same <TT>arrayspec</TT> and <TT>distgrid</TT> arguments are used to
   create a 2D Array that is fully replicated in both dimensions of the DistGrid.
   Both Array dimensions are now tensor dimensions and both DistGrid dimensions
   are replicator dimensions.
<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,0/), undistLBound=(/11,21/), &amp;
    undistUBound=(/14,22/), rc=rc)
</PRE>

<P>
The result will be an Array with local lower bound (/11,21/) and upper bound
   (/14,22/) on all 6 DEs of the DistGrid.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
Replicated Arrays can also be created from existing local Fortran arrays.
   The following Fortran array allocation will provide a 3 x 10 array on each
   PET. 
<P>
<PRE>
  allocate(myFarray2D(3,10))
</PRE>

<P>
Assuming a petCount of 4 the following DistGrid defines a 2D index space
   that is distributed across the PETs along the first dimension.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
The following call creates an Array object on the above distgrid using
   the locally existing <TT>myFarray2D</TT> Fortran arrays. The difference 
   compared to the case with automatic memory allocation is that instead of
   <TT>arrayspec</TT> the Fortran array is provided as argument. Furthermore,
   the <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments can be omitted,
   defaulting into Array tensor dimension lower bound of 1 and an upper
   bound equal to the size of the respective Fortran array dimension.
<P>
<PRE>
  array = ESMF_ArrayCreate(farray=myFarray2D, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, distgridToArrayMap=(/0,2/), rc=rc)
</PRE>

<P>
The <TT>array</TT> object associates the 2nd DistGrid dimension with the 2nd
   Array dimension. The first DistGrid dimension is not associated with any
   Array dimension and will lead to replication of the Array along the DEs of
   this direction.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050521300000000000000"></A>
   <A NAME="Array_shared_memory_features"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">13</SPAN> Shared memory features: DE pinning, sharing, and migration
</H3>

<P>
Practically all modern computer systems today utilize multi-core processors,
   supporting the concurrent execution of multiple hardware threads.
   A number of these multi-core processors are commonly packaged into the same
   compute node, having access to the same physical memory. Under ESMF each
   hardware thread (or core) is identified as a unique Processing Element (PE).
   The collection of PEs that share the same physical memory (i.e. compute node)
   is referred to as a Single System Image (SSI). The ESMF Array class implements
   features that allow the user to leverage the shared memory within each SSI to
   efficiently exchange data without copies or explicit communication calls.

<P>
The software threads executing an ESMF application on the hardware, and that
   ESMF is aware of, are referred to as Persistent Execution Threads (PETs). In
   practice a PET can typically be thought of as an MPI rank, i.e. an OS process,
   defining its own private virtual address space (VAS). 
   The ESMF Virtual Machine (VM) class keeps track of the mapping between PETs
   and PEs, and their location on the available SSIs.

<P>
When an ESMF Array object is created, the specified DistGrid indicates how
   many Decomposition Elements (DEs) are created. Each DE has its own memory
   allocation to hold user data. The DELayout, referenced by the DistGrid,
   determines which PET is considered the <EM>owner</EM> of each of the DEs. Queried
   for the local DEs, the Array object returns the list of DEs that are owned by
   the local PET making the query.

<P>
By default DEs are <EM>pinned</EM> to the PETs under which they were created.
   The memory allocation associated with a specific DE is only defined in the
   VAS of the PET to which the DE is pinned. As a consequence, only the PET
   owning a DE has access to its memory allocation.

<P>
On shared memory systems, however, ESMF allows DEs to be pinned to SSIs
   instead of PETs. In this case the PET under which a DE was created is still
   consider the owner, but now <EM>all</EM> PETs under the same SSI have access to
   the DE. For this the memory allocation associated with the DE is mapped into
   the VAS of all the PETs under the SSI.

<P>
To create an Array with each DE pinned to SSI instead of PET, first query the
   VM for the available level of support.
<P>
<PRE>
  call ESMF_VMGet(vm, ssiSharedMemoryEnabledFlag=ssiSharedMemoryEnabled, rc=rc)
</PRE>

<P>
<PRE>
  if (ssiSharedMemoryEnabled) then
</PRE>

<P>
Knowing that the SSI shared memory feature is available, it is now possible
   to create an Array object with DE to SSI pinning.
<P>
<PRE>
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
<PRE>
    array = ESMF_ArrayCreate(typekind=ESMF_TYPEKIND_R8, distgrid=distgrid, &amp;
      pinflag=ESMF_PIN_DE_TO_SSI, rc=rc)
</PRE>

<P>
Just as in the cases discussed before, where the same DistGrid was used, a
   default DELayout with as many DEs as PETs in the VM is constructed. Setting
   the <TT>pinflag</TT> to <TT>ESMF_PIN_DE_TO_SSI</TT> does not change the
   fact that each PET owns exactly one of the DEs. However, assuming that this
   code is run on a set of PETs that are all located under the same SSI, every
   PET now has <EM>access</EM> to all of the DEs. The situation can be observed by
   querying for both the <TT>localDeCount</TT>, and the <TT>ssiLocalDeCount</TT>.
<P>
<PRE>
    call ESMF_ArrayGet(array, localDeCount=localDeCount, &amp;
      ssiLocalDeCount=ssiLocalDeCount, rc=rc)
</PRE>

<P>
Assuming execution on 4 PETs, all located on the same SSI, the values of the
   returned variable are <TT>localDeCount==1</TT> and <TT>ssiLocalDeCount==4</TT> on 
   all of the PETs. The mapping between each PET's local DE, and the global DE
   index is provided through the <TT>localDeToDeMap</TT> array argument. The amount
   of mapping information returned is dependent on how large <TT>localDeToDeMap</TT>
   has been sized by the user. For <TT>size(localDeToDeMap)==localDeCount</TT>,
   only mapping information for those DEs <EM>owned</EM> by the local PET is filled
   in. However for <TT>size(localDeToDeMap)==ssiLocalDeCount</TT>, mapping
   information for all locally <EM>accessible</EM> DEs is returned, including
   those owned by other PETs on the same SSI.
   
<P>
<PRE>
    allocate(localDeToDeMap(0:ssiLocalDeCount-1))
    call ESMF_ArrayGet(array, localDeToDeMap=localDeToDeMap, rc=rc)
</PRE>

<P>
The first <TT>localDeCount</TT> entries of <TT>localDeToDeMap</TT> are always the
   global DE indices of the DEs <EM>owned</EM> by the local PET. The remaining 
   <TT>ssiLocalDeCount</TT>-<TT>localDeCount</TT> entries are the global DE indices of
   DEs <EM>shared</EM> by other PETs. The ordering of the shared DEs is from
   smallest to greatest, excluding the locally owned DEs, which were already
   listed at the beginning of <TT>localDeToDeMap</TT>. For the current case, again
   assuming execution on 4 PETs all located on the same SSI, we expect the
   following situation:

<P>
PET 0: <TT>localDeToDeMap</TT>==<TT>(/0,1,2,3/)</TT>
<BR>
PET 1: <TT>localDeToDeMap</TT>==<TT>(/1,0,2,3/)</TT>
<BR>
PET 2: <TT>localDeToDeMap</TT>==<TT>(/2,0,1,3/)</TT>
<BR>
PET 3: <TT>localDeToDeMap</TT>==<TT>(/3,0,1,2/)</TT>
<BR>

<P>
Each PET can access the memory allocations associated with <EM>all</EM> of the
   DEs listed in the <TT>localDeToDeMap</TT> returned by the Array object. Direct
   access to the Fortran array pointer of a specific memory allocation is
   available through <TT>ESMF_ArrayGet()</TT>. Here each PET queries for the
   <TT>farrayPtr</TT> of <TT>localDe==2</TT>, i.e. the 2nd shared DE.
<P>
<PRE>
    call ESMF_ArrayGet(array, farrayPtr=myFarray, localDe=2, rc=rc)
</PRE>

<P>
Now variable <TT>myFarray</TT> on PETs 0 and 1 both point to the <EM>same</EM>
   memory allocation for global DE 2. Both PETs have access to the same
   piece of shared memory! The same is true for PETs 2 and 3, pointing to the
   shared memory allocation of global DE 1.

<P>
It is important to note that all of the typical considerations surrounding
   shared memory programming apply when accessing shared DEs! Proper
   synchronization between PETs accessing shared DEs is critical to avoid
   <EM>race conditions</EM>. Also performance issues like <EM>false sharing</EM>
   need to be considered for optimal use.

<P>
For a simple demonstration, PETs 0 and 2 fill the entire memory allocation of
   DE 2 and 1, respectively, to a unique value.
<P>
<PRE>
    if (localPet==0) then
      myFarray = 12345.6789d0
    else if (localPet==2) then
      myFarray = 6789.12345d0
    endif
</PRE>

<P>
Here synchronization is needed before any PETs that share access to the same
   DEs can safely access the data without race condition. The Array class provides
   a simple synchronization method that can be used.
<P>
<PRE>
    call ESMF_ArraySync(array, rc=rc) ! prevent race condition
</PRE>

<P>
Now it is safe for PETs 1 and 3 to access the shared DEs. We expect to find
   the data that was set above. For simplicity of the code only the first
   array element is inspected here.
<P>
<PRE>
    if (localPet==1) then
      if (abs(myFarray(1,1)-12345.6789d0)&gt;1.d10) print *, "bad data detected"
    else if (localPet==3) then
      if (abs(myFarray(1,1)-6789.12345d0)&gt;1.d10) print *, "bad data detected"
    endif
</PRE>

<P>
Working with shared DEs requires additional bookkeeping on the user code
   level. In some situations, however, DE sharing is simply used as a mechanism
   to <EM>move</EM> DEs between PETs without requiring data copies. One practical
   application of this case is the transfer of an Array between two components,
   both of which use the same PEs, but run with different number of PETs.
   These would typically be sequential components that use OpenMP on the user
   level with varying threading levels.

<P>
DEs that are pinned to SSI can be moved or <EM>migrated</EM> to any PET within
   the SSI. This is accomplished by creating a new Array object from an
   existing Array that was created with <TT>pinflag=ESMF_PIN_DE_TO_SSI</TT>.
   The information of how the DEs are to migrate between the old and the new
   Array is provided through a DELayout object. This object must have the
   same number of DEs and describes how they map to the PETs on the current VM.
   If this is in the context of a different component, the number of PETs might
   differ from the original VM under which the existing Array was created. This
   situation is explicitly supported, still the number of DEs must match.

<P>
Here a simple DELayout is created on the same 4 PETs, but with rotated
   DE ownerships:

<P>
DE 0 -&gt; PET 1 (old PET 0)
<BR>
DE 1 -&gt; PET 2 (old PET 1)
<BR>
DE 2 -&gt; PET 3 (old PET 2)
<BR>
DE 3 -&gt; PET 0 (old PET 3)
<BR>
 <PRE>
    delayout = ESMF_DELayoutCreate(petMap=(/1,2,3,0/), rc=rc) ! DE-&gt;PET mapping
</PRE>

<P>
The creation of the new Array is done by reference, i.e. 
   <TT>datacopyflag=ESMF_DATACOPY_REFERENCE</TT>, since the new Array does
   not create its own memory allocations. Instead the new Array references the
   shared memory resources held by the incoming Array object.
<P>
<PRE>
    arrayMigrated = ESMF_ArrayCreate(array, delayout=delayout, &amp;
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
</PRE>

<P>
Querying <TT>arrayMigrated</TT> for the number of local DEs will return 1 on
   each PET. Sizing the <TT>localDeToDeMap</TT> accordingly and querying for it.
<P>
<PRE>
    deallocate(localDeToDeMap) ! free previous allocation
    allocate(localDeToDeMap(0:1))
    call ESMF_ArrayGet(arrayMigrated, localDeToDeMap=localDeToDeMap, rc=rc)
</PRE>

<P>
This yields the following expected outcome:

<P>
PET 0: <TT>localDeToDeMap</TT>==<TT>(/1/)</TT>
<BR>
PET 1: <TT>localDeToDeMap</TT>==<TT>(/2/)</TT>
<BR>
PET 2: <TT>localDeToDeMap</TT>==<TT>(/3/)</TT>
<BR>
PET 3: <TT>localDeToDeMap</TT>==<TT>(/0/)</TT>
<BR>

<P>
On each PET the respective Fortran array pointer is returned by the Array.
<P>
<PRE>
    call ESMF_ArrayGet(arrayMigrated, farrayPtr=myFarray, rc=rc)
</PRE>

<P>
The same situation could have been achieved with the original <TT>array</TT>.
   However, it would have required first finding the correct local DE
   for the target global DE on each PET, and then querying <TT>array</TT>
   accordingly. If needed more repeatedly, this bookkeeping would need to be
   kept in a user code data structure. The DE migration feature on the other
   hand provides a formal way to create a standard ESMF Array object that can be
   used directly in any Array level method as usual, letting ESMF handle the
   extra bookkeeping needed. 

<P>
Before destroying an Array whose DEs are shared between PETs, it is
   advisable to issue one more synchronization. This prevents cases where a
   PET still might be accessing a shared DE, while the owner PET is already
   destroying the Array, therefore deallocating the shared memory resource.
<P>
<PRE>
    call ESMF_ArraySync(array, rc=rc) ! prevent race condition
</PRE>

<P>
<PRE>
    call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Remember that <TT>arrayMigrated</TT> shares the same memory allocations that were
   held by <TT>array</TT>. Array <TT>arrayMigrated</TT> must therefore not be used
   beyond the life time of <TT>array</TT>. Best to destroy it now.
<P>
<PRE>
    call ESMF_ArrayDestroy(arrayMigrated, rc=rc)
</PRE>

<P>
<PRE>
  endif ! ending the ssiSharedMemoryEnabled conditional
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050521400000000000000"></A>
   <A NAME="Array:ScatterGather"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">14</SPAN> Communication - Scatter and Gather
</H3>

<P>
It is a common situation, particularly in legacy code, that an ESMF Array
   object must be filled with data originating from a large Fortran array stored
   on a single PET.
<P>
<PRE>
  if (localPet == 0) then
    allocate(farray(10,20,30))
    do k=1, 30
      do j=1, 20
        do i=1, 10
          farray(i, j, k) = k*1000 + j*100 +  i
        enddo
      enddo
    enddo
  else
    allocate(farray(0,0,0))
  endif
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1,1/), maxIndex=(/10,20,30/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=3, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
The <TT>ESMF_ArrayScatter()</TT> method provides a convenient way of scattering
   array data from a single root PET across the DEs of an ESMF Array object.
<P>
<PRE>
  call ESMF_ArrayScatter(array, farray=farray, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(farray)
</PRE>

<P>
The destination of the ArrayScatter() operation are all the DEs of a single
   tile. For multi-tile Arrays the destination tile can be specified. The 
   shape of the scattered Fortran array must match the shape of the destination
   tile in the ESMF Array.

<P>
Gathering data decomposed and distributed across the DEs of an ESMF Array
   object into a single Fortran array on root PET is accomplished by calling
   <TT>ESMF_ArrayGather()</TT>.
<P>
<PRE>
  if (localPet == 3) then
    allocate(farray(10,20,30))
  else
    allocate(farray(0,0,0))
  endif
  
  call ESMF_ArrayGather(array, farray=farray, rootPet=3, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(farray)
</PRE>

<P>
The source of the ArrayGather() operation are all the DEs of a single
   tile. For multi-tile Arrays the source tile can be specified. The 
   shape of the gathered Fortran array must match the shape of the source
   tile in the ESMF Array. 

<P>
The <TT>ESMF_ArrayScatter()</TT> operation allows to fill entire replicated
   Array objects with data coming from a single root PET.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,0/), undistLBound=(/11,21/), &amp;
    undistUBound=(/14,22/), rc=rc)
</PRE>

<P>
The shape of the Fortran source array used in the Scatter() call must be
   that of the contracted Array, i.e. contracted DistGrid dimensions do not
   count. For the <TT>array</TT> just created this means that the source array
   on <TT>rootPet</TT> must be of shape 4 x 2.
<P>
<PRE>
  if (localPet == 0) then
    allocate(myFarray2D(4,2))
    do j=1,2
      do i=1,4
        myFarray2D(i,j) = i * 100.d0 + j * 1.2345d0 ! initialize
      enddo
    enddo
  else
    allocate(myFarray2D(0,0))
  endif
  
  call ESMF_ArrayScatter(array, farray=myFarray2D, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(myFarray2D)
</PRE>

<P>
This will have filled each local 4 x 2 Array piece with the replicated
   data of <TT>myFarray2D</TT>.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
As a second example for the use of Scatter() and Gather() consider the
   following replicated Array created from existing local Fortran arrays.
<P>
<PRE>
  allocate(myFarray2D(3,10))
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=myFarray2D, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, distgridToArrayMap=(/0,2/), rc=rc)
</PRE>

<P>
The <TT>array</TT> object associates the 2nd DistGrid dimension with the 2nd
   Array dimension. The first DistGrid dimension is not associated with any
   Array dimension and will lead to replication of the Array along the DEs of
   this direction. Still, the local arrays that comprise the <TT>array</TT> 
   object refer to independent pieces of memory and can be initialized 
   independently.
<P>
<PRE>
  myFarray2D = localPet ! initialize
</PRE>

<P>
However, the notion of replication becomes visible when an array of shape
   3 x 10 on root PET 0 is scattered across the Array object.
<P>
<PRE>
  if (localPet == 0) then
    allocate(myFarray2D2(5:7,11:20))
  
    do j=11,20
      do i=5,7
        myFarray2D2(i,j) = i * 100.d0 + j * 1.2345d0 ! initialize
      enddo
    enddo
  else
    allocate(myFarray2D2(0,0))
  endif
  
  call ESMF_ArrayScatter(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(myFarray2D2)
</PRE>

<P>
The Array pieces on every DE will receive the same source data, resulting
   in a replication of data along DistGrid dimension 1. 

<P>
When the inverse operation, i.e. <TT>ESMF_ArrayGather()</TT>, is applied to
   a replicated Array an intrinsic ambiguity needs to be considered. ESMF 
   defines the gathering of data of a replicated Array as the collection of data
   originating from the numerically higher DEs. This means that data in
   replicated elements associated with numerically lower DEs will be ignored
   during <TT>ESMF_ArrayGather()</TT>. For the current example this means that
   changing the Array contents on PET 1, which here corresponds to DE 1,
<P>
<PRE>
  if (localPet == 1) then
    myFarray2D = real(1.2345, ESMF_KIND_R8)
  endif
</PRE>

<P>
will <EM>not</EM> affect the result of
 <PRE>
  allocate(myFarray2D2(3,10))
  myFarray2D2 = 0.d0    ! initialize to a known value
  call ESMF_ArrayGather(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
The result remains completely defined by the unmodified values of Array in 
   DE 3, the numerically highest DE. However, overriding the DE-local Array
   piece on DE 3
 <PRE>
  if (localPet==3) then
    myFarray2D = real(5.4321, ESMF_KIND_R8)
  endif
</PRE>

<P>
will change the outcome of
 <PRE>
  call ESMF_ArrayGather(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
as expected.
<P>
<PRE>
  deallocate(myFarray2D2)

  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050521500000000000000"></A>
   <A NAME="Array:Halo"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">15</SPAN> Communication - Halo
</H3>

<P>
One of the most fundamental communication pattern in domain decomposition
   codes is the <EM>halo</EM> operation. The ESMF Array class supports halos
   by allowing memory for extra elements to be allocated on each DE. See
   sections <A HREF="#Array:fpadding">28.2.2</A> and <A HREF="#Array:padding">28.2.8</A> for examples and
   details on how to create an Array with extra DE-local elements.

<P>
Here we consider an Array object that is created on a DistGrid that 
   defines a 10 x 20 index space, decomposed into 4 DEs using a regular
   2 x 2 decomposition.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/2,2/), rc=rc)
</PRE>

<P>
The Array holds 2D double precision float data.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
The <TT>totalLWidth</TT> and <TT>totalUWidth</TT> arguments are used during Array
   creation to allocate 2 extra elements along every direction outside the 
   exclusive region defined by the DistGrid for every DE. (The <TT>indexflag</TT>
   set to <TT>ESMF_INDEX_GLOBAL</TT> in this example does not affect the halo
   behavior of Array. The setting is simply more convenient for the following
   code.)
<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/2,2/), totalUWidth=(/2,2/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
Without the explicit definition of boundary conditions in the DistGrid
   the following inner connections are defined.

<P>
<PRE>
   
            +-------------------+       +-------------------+
            | \       2       / |       | \       2       / |
            |  +-------------+  |       |  +-------------+  |
            |  |     DE 0    |  |       |  |     DE 2    |  |
            |  |             |  |       |  |             |  |
            |2 |    5 x 10   | 2|  &lt;-&gt;  |2 |    5 x 10   | 2|
            |  |             |  |       |  |             |  |
            |  |             |  |       |  |             |  |
            |  +-------------+  |       |  +-------------+  |
            | /       2       \ |       | /       2       \ |
            +-------------------+       +-------------------+
  
                      ^            \/             ^
                      |            /\             |
                      v                           v
  
            +-------------------+       +-------------------+
            | \       2       / |       | \       2       / |
            |  +-------------+  |       |  +-------------+  |
            |  |     DE 1    |  |       |  |     DE 3    |  |
            |  |             |  |       |  |             |  |
            |2 |    5 x 10   | 2|  &lt;-&gt;  |2 |    5 x 10   | 2|
            |  |             |  |       |  |             |  |
            |  |             |  |       |  |             |  |
            |  +-------------+  |       |  +-------------+  |
            | /       2       \ |       | /       2       \ |
            +-------------------+       +-------------------+
</PRE>

<P>
The exclusive region on each DE is of shape 5 x 10, while the total region
   on each DE is of shape (5+2+2) x (10+2+2) = 9 x 14. In a typical application
   the elements in the exclusive region are updated exclusively by the PET that
   owns the DE. In this example the exclusive elements on every DE are
   initialized to the value <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$f(i,j)$"></SPAN> of the geometric function
   <BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
f(i,j) = \sin(\alpha i)\cos(\beta j),
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="168" HEIGHT="29" BORDER="0"
 SRC="img67.png"
 ALT="\begin{displaymath}
f(i,j) = \sin(\alpha i)\cos(\beta j),
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">1</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
where
   <BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\alpha = 2\pi/N_i, i=1,...N_i
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="153" HEIGHT="29" BORDER="0"
 SRC="img68.png"
 ALT="\begin{displaymath}
\alpha = 2\pi/N_i, i=1,...N_i
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">2</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
and
   <BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\beta = 2\pi/N_j, j=1,...N_j,
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="162" HEIGHT="30" BORDER="0"
 SRC="img69.png"
 ALT="\begin{displaymath}
\beta = 2\pi/N_j, j=1,...N_j,
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">3</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
with <SPAN CLASS="MATH"><IMG
 WIDTH="59" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img70.png"
 ALT="$N_i = 10$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="61" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img71.png"
 ALT="$N_j = 20$"></SPAN>.
<P>
<PRE>
  a = 2. * 3.14159 / 10.
  b = 2. * 3.14159 / 20.
  
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  
  call ESMF_ArrayGet(array, exclusiveLBound=eLB, exclusiveUBound=eUB, rc=rc)
</PRE>

<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo
</PRE>

<P>
The above loop only initializes the exclusive elements on each DE. The extra
   elements, outside the exclusive region, are left untouched, holding undefined
   values. Elements outside the exclusive region that correspond to 
   exclusive elements in neighboring DEs can be filled with the data values 
   in those neighboring elements. This is the definition of the halo operation.

<P>
In ESMF the halo communication pattern is first precomputed and stored in
   a RouteHandle object. This RouteHandle can then be used repeatedly to 
   perform the same halo operation in the most efficient way.

<P>
The default halo operation for an Array is precomputed by the following call.
<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
The <TT>haloHandle</TT> now holds the default halo operation for <TT>array</TT>, 
   which matches as many elements as possible outside the exclusive region to 
   their corresponding halo source elements in neighboring DEs. Elements that
   could not be matched, e.g. at the edge of the global domain with open
   boundary conditions, will not be updated by the halo operation.

<P>
The <TT>haloHandle</TT> is applied through the <TT>ESMF_ArrayHalo()</TT> method.
<P>
<PRE>
  call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
Finally the resources held by <TT>haloHandle</TT> need to be released.
<P>
<PRE>
  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
The <TT>array</TT> object created above defines a 2 element wide rim around the
   exclusive region on each DE. Consequently the default halo operation used
   above will have resulted in updating both elements along the inside edges.
   For simple numerical kernels often a single halo element is 
   sufficient. One way to achieve this would be to reduce the size of the 
   rim surrounding the exclusive region to 1 element along each direction. 
   However, if the same Array object is also used for higher order kernels
   during a different phase of the calculation, a larger element rim is
   required. For this case <TT>ESMF_ArrayHaloStore()</TT> offers two optional
   arguments <TT>haloLDepth</TT> and <TT>haloUDepth</TT>. Using these arguments a
   reduced halo depth can be specified.
<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, &amp;
    haloLDepth=(/1,1/), haloUDepth=(/1,1/), rc=rc)
</PRE>

<P>
This halo operation with a depth of 1 is sufficient to support a simple
   quadratic differentiation kernel.
<P>
<PRE>
  allocate(farrayTemp(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)))

  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        if (i==1) then
          ! global edge
          farrayTemp(i,j) = 0.5 * (-farrayPtr(i+2,j) + 4.*farrayPtr(i+1,j) &amp;
            - 3.*farrayPtr(i,j)) / a
        else if (i==10) then
          ! global edge
          farrayTemp(i,j) = 0.5 * (farrayPtr(i-2,j) - 4.*farrayPtr(i-1,j) &amp;
            + 3.*farrayPtr(i,j)) / a
        else
          farrayTemp(i,j) = 0.5 * (farrayPtr(i+1,j) - farrayPtr(i-1,j)) / a
        endif
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
  
  deallocate(farrayTemp)

  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
The special treatment of the global edges in the above kernel is due to the 
   fact that the underlying DistGrid object does not define any special 
   boundary conditions. By default open global boundaries are assumed which
   means that the rim elements on the global edges are untouched during
   the halo operation, and cannot be used in the symmetric numerical derivative
   formula. The kernel can be simplified (and the calculation is more precise)
   with periodic boundary conditions along the first Array dimension.

<P>
First destroy the current Array and DistGrid objects.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
Create a DistGrid with periodic boundary condition along the first dimension.
<P>
<PRE>
  allocate(connectionList(1))  ! one connection
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp;
     tileIndexA=1, tileIndexB=1, positionVector=(/10, 0/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/2,2/), connectionList=connectionList, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(connectionList)
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/2,2/), totalUWidth=(/2,2/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
Initialize the exclusive elements to the same geometric function as before.
<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  
  call ESMF_ArrayGet(array, exclusiveLBound=eLB, exclusiveUBound=eUB, rc=rc)
</PRE>

<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo
</PRE>

<P>
The numerical kernel only operates along the first dimension. An
   asymmetric halo depth can be used to take this fact into account.
<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, &amp;
    haloLDepth=(/1,0/), haloUDepth=(/1,0/), rc=rc)
</PRE>

<P>
Now the same numerical kernel can be used without special treatment of
   global edge elements. The symmetric derivative formula can be used for
   all exclusive elements.
<P>
<PRE>
  allocate(farrayTemp(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)))

  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        farrayTemp(i,j) = 0.5 * (farrayPtr(i+1,j) - farrayPtr(i-1,j)) / a
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
</PRE>

<P>
The precision of the above kernel can be improved by going to 
   a higher order interpolation. Doing so requires that the halo depth must be
   increased. The following code resets the exclusive Array elements
   to the test function, precomputes a RouteHandle for a halo operation
   with depth 2 along the first dimension, and finally uses the deeper halo
   in the higher order kernel.
<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo

  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle2, &amp;
    haloLDepth=(/2,0/), haloUDepth=(/2,0/), rc=rc)
</PRE>

<P>
<PRE>
  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle2, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        farrayTemp(i,j) = (-farrayPtr(i+2,j) + 8.*farrayPtr(i+1,j) &amp;
          - 8.*farrayPtr(i-1,j) + farrayPtr(i-2,j)) / (12.*a)
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
  
  deallocate(farrayTemp)
</PRE>

<P>
ESMF supports having multiple halo operations defined on the same Array
   object at the same time. Each operation can be accessed through its unique
   RouteHandle. The above kernel could have made <TT>ESMF_ArrayHalo()</TT> calls
   with a depth of 1 along the first dimension using the previously precomputed
   <TT>haloHandle</TT> if it needed to. Both RouteHandles need to release their
   resources when no longer used.
<P>
<PRE>
  

  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHaloRelease(routehandle=haloHandle2, rc=rc)
</PRE>

<P>
Finally the Array and DistGrid objects can be destroyed.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050521600000000000000"></A>
   <A NAME="Array:ArbHalo"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN> Communication - Halo for arbitrary distribution
</H3>

<P>
In the previous section the Array <EM>halo</EM> operation was demonstrated 
   for regularly decomposed ESMF Arrays. However, the ESMF halo operation
   is not restricted to regular decompositions. The same Array halo methods
   apply unchanged to Arrays that are created on arbitrarily distributed
   DistGrids. This includes the non-blocking features discussed in section
   <A HREF="#Array:CommNB">28.2.20</A>.

<P>
All of the examples in this section are based on the same arbitrarily
   distributed DistGrid. Section <A HREF="#DistGrid:ArbitrarySeqInd">36.3.5</A> discusses
   DistGrids with user-supplied, arbitrary sequence indices in detail. Here
   a global index space range from 1 through 20 is decomposed across 4 DEs. 
   There are 4 PETs in this example with 1 DE per PET. Each PET constructs
   its local <TT>seqIndexList</TT> variable.
<P>
<PRE>
  do i=1, 5
#ifdef TEST_I8RANGE_on
    seqIndexList(i) = localPet + (i - 1) * petCount + 1 + seqIndexOffset
#else
    seqIndexList(i) = localPet + (i - 1) * petCount + 1
#endif
  enddo
</PRE>

<P>
This results in the following cyclic distribution scheme:
   <PRE>
   DE 0 on PET 0: seqIndexList = (/1, 5, 9, 13, 17/)
   DE 1 on PET 1: seqIndexList = (/2, 6, 10, 14, 18/)
   DE 2 on PET 2: seqIndexList = (/3, 7, 11, 15, 19/)
   DE 3 on PET 3: seqIndexList = (/4, 8, 12, 16, 20/)
</PRE>

<P>
The local <TT>seqIndexList</TT> variables are then used to create a
   DistGrid with the indicated arbitrary distribution pattern.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=seqIndexList, rc=rc)
</PRE>

<P>
The resulting DistGrid is one-dimensional, although the user code may
   interpret the sequence indices as a 1D map into a problem of higher
   dimensionality. 

<P>
In this example the local DE on each PET is associated with a 5 element
   exclusive region. Providing <TT>seqIndexList</TT> of different size on the
   different PETs is supported and would result in different number of
   exclusive elements on each PET.

<P>

<H4><A NAME="SECTION050521610000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Halo for a 1D Array from existing memory allocation, created on
   the 1D arbitrary DistGrid.</A>
</H4>
    
<BR>
<P>
Creating an ESMF Array on top of a DistGrid with arbitrary sequence indices
   is in principle no different from creating an Array on a regular DistGrid. 
   However, while an Array that was created on a regular DistGrid automatically
   inherits the index space topology information that is contained within the
   DistGrid object, there is no such topology information available for
   DistGrid objects with arbitrary sequence indices. As a consequence of
   this, Arrays created on arbitrary DistGrids do not automatically have
   the information that is required to associated halo elements with the
   exclusive elements across DEs. Instead the user must supply this information
   explicitly during Array creation.

<P>
Multiple ArrayCreate() interfaces exist that allow the creation of an Array
   on a DistGrid with arbitrary sequence indices. The sequence indices for the
   halo region of the local DE are supplied through an additional argument
   with dummy name <TT>haloSeqIndexList</TT>. As in the regular case, the
   ArrayCreate() interfaces differ in the way that the memory allocations for
   the Array elements are passed into the call. The following code shows how 
   an ESMF Array can be wrapped around existing PET-local memory allocations.
   The allocations are of different size on each PET as to accommodate the correct
   number of local Array elements (exclusive region + halo region).
<P>
<PRE>
  allocate(farrayPtr1d(5+localPet+1)) !use explicit Fortran allocate statement
  
  if (localPet==0) then
    allocate(haloList(1))
#ifdef TEST_I8RANGE_on
    haloList(:)=(/1099511627782_ESMF_KIND_I8/)
#else    
    haloList(:)=(/6/)
#endif
    array = ESMF_ArrayCreate(distgrid, farrayPtr1d, &amp;
      haloSeqIndexList=haloList, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    allocate(haloList(2))
#ifdef TEST_I8RANGE_on
    haloList(:)=(/1099511627777_ESMF_KIND_I8,&amp;
                  1099511627795_ESMF_KIND_I8/)
#else
    haloList(:)=(/1,19/)
#endif
    array = ESMF_ArrayCreate(distgrid, farrayPtr1d, &amp;
      haloSeqIndexList=haloList, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    allocate(haloList(3))
#ifdef TEST_I8RANGE_on
    haloList(:)=(/1099511627792_ESMF_KIND_I8,&amp;
                  1099511627782_ESMF_KIND_I8,&amp;
                  1099511627785_ESMF_KIND_I8/)
#else
    haloList(:)=(/16,6,9/)
#endif
    array = ESMF_ArrayCreate(distgrid, farrayPtr1d, &amp;
      haloSeqIndexList=haloList, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    allocate(haloList(4))
#ifdef TEST_I8RANGE_on
    haloList(:)=(/1099511627777_ESMF_KIND_I8,&amp;
                  1099511627779_ESMF_KIND_I8,&amp;
                  1099511627777_ESMF_KIND_I8,&amp;
                  1099511627780_ESMF_KIND_I8/)
#else
    haloList(:)=(/1,3,1,4/)
#endif
    array = ESMF_ArrayCreate(distgrid, farrayPtr1d, &amp;
      haloSeqIndexList=haloList, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
The <TT>haloSeqIndexList</TT> arguments are 1D arrays of sequence indices.
   It is through this argument that the user associates the halo elements with
   exclusive Array elements covered by the DistGrid. In this example there
   are different number of halo elements on each DE. They are associated
   with exclusive elements as follows:

<P>
<PRE>
   halo on DE 0 on PET 0: &lt;seqIndex=6&gt;  2nd exclusive element on DE 1
   halo on DE 1 on PET 1: &lt;seqIndex=1&gt;  1st exclusive element on DE 0
                          &lt;seqIndex=19&gt; 5th exclusive element on DE 2
   halo on DE 2 on PET 2: &lt;seqIndex=16&gt; 4th exclusive element on DE 3
                          &lt;seqIndex=6&gt;  2nd exclusive element on DE 1
                          &lt;seqIndex=9&gt;  3rd exclusive element on DE 0
   halo on DE 3 on PET 3: &lt;seqIndex=1&gt;  1st exclusive element on DE 0
                          &lt;seqIndex=3&gt;  1st exclusive element on DE 2
                          &lt;seqIndex=1&gt;  1st exclusive element on DE 0
                          &lt;seqIndex=4&gt;  1st exclusive element on DE 3
</PRE>

<P>
The above <TT>haloSeqIndexList</TT> arguments were constructed very artificially
   in order to show the following general features:
   
<UL>
<LI>There is no restriction on the order in which the indices in a
   <TT>haloSeqIndexList</TT> can appear.
</LI>
<LI>The same sequence index may appear in multiple <TT>haloSeqIndexList</TT>
   arguments.
</LI>
<LI>The same sequence index may appear multiple times in the same 
   <TT>haloSeqIndexList</TT> argument.
</LI>
<LI>A local sequence index may appear in a <TT>haloSeqIndexList</TT> argument.
   
</LI>
</UL>

<P>
The ArrayCreate() call checks that the provided Fortran memory allocation
   is correctly sized to hold the exclusive elements, as indicated by the
   DistGrid object, plus the halo elements as indicated by the local
   <TT>haloSeqIndexList</TT> argument. The size of the Fortran allocation must
   match exactly or a runtime error will be returned.

<P>
Analogous to the case of Arrays on regular DistGrids, it is the exclusive
   region of the local DE that is typically modified by the code running on 
   each PET. All of the ArrayCreate() calls that accept the
   <TT>haloSeqIndexList</TT> argument place the exclusive region at the beginning
   of the memory allocation on each DE and use the remaining space for the halo
   elements. The following loop demonstrates this by filling the exclusive 
   elements on each DE with initial values. Remember that in this example each 
   DE holds 5 exclusive elements associated with different arbitrary sequence 
   indices.
<P>
<PRE>
  farrayPtr1d = 0 ! initialize
  do i=1, 5
    farrayPtr1d(i) = real(seqIndexList(i), ESMF_KIND_R8)
  enddo
  print *, "farrayPtr1d: ", farrayPtr1d
</PRE>

<P>
Now the exclusive elements of <TT>array</TT> are initialized on each DE, however,
   the halo elements remain unchanged. A RouteHandle can be set up that encodes
   the required communication pattern for a halo exchange. The halo exchange
   is precomputed according to the arbitrary sequence indices specified for the
   exclusive elements by the DistGrid and the sequence indices provided by the 
   user for each halo element on the local DE in form of the 
   <TT>haloSeqIndexList</TT> argument during ArrayCreate(). 
   
<P>
<PRE>
  call ESMF_ArrayHaloStore(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
Executing this halo operation will update the local halo elements according
   to the associated sequence indices.
<P>
<PRE>
  call ESMF_ArrayHalo(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
As always it is good practice to release the RouteHandle when done with it.
<P>
<PRE>
  call ESMF_ArrayHaloRelease(haloHandle, rc=rc)
</PRE>

<P>
Also the Array object should be destroyed when no longer needed.
<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Further, since the memory allocation was done explicitly using the Fortran
   <TT>allocate()</TT> statement, it is necessary to explicitly deallocate in order
   to prevent memory leaks in the user application.
<P>
<PRE>
  deallocate(farrayPtr1d)
</PRE>

<P>

<H4><A NAME="SECTION050521620000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Halo for a 1D Array with ESMF managed memory allocation, created on
   the 1D arbitrary DistGrid.</A>
</H4>
    
<BR>
<P>
Alternatively the exact same Array can be created where ESMF does the
   memory allocation and deallocation. In this case the <TT>typekind</TT> of the 
   Array must be specified explicitly.
<P>
<PRE>
  if (localPet==0) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=haloList, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=haloList, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=haloList, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=haloList, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
Use <TT>ESMF_ArrayGet()</TT> to gain access to the local memory allocation.
<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr1d, rc=rc)
</PRE>

<P>
The returned Fortran pointer can now be used to initialize the exclusive
   elements on each DE as in the previous case.
<P>
<PRE>
  do i=1, 5
    farrayPtr1d(i) = real(seqIndexList(i),ESMF_KIND_R8) / 10.d0
  enddo
</PRE>

<P>
Identical halo operations are constructed and used.
<P>
<PRE>
  call ESMF_ArrayHaloStore(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHalo(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHaloRelease(haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>

<H4><A NAME="SECTION050521630000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Halo for an Array with undistributed dimensions, created on
   the 1D arbitrary DistGrid, with default Array to DistGrid dimension mapping.</A>
</H4>
    
<BR>
<P>
A current limitation of the Array implementation restricts DistGrids that
   contain user-specified, arbitrary sequence indices to be exactly 1D
   when used to create Arrays. See section <A HREF="#Array:rest">28.3</A> for a list of 
   current implementation restrictions. However, an Array created on such a
   1D arbitrary DistGrid is allowed to have undistributed dimensions. The
   following example creates an Array on the same arbitrary DistGrid, with the
   same arbitrary sequence indices for the halo elements as before, but with
   one undistributed dimension with a size of 3.
<P>
<PRE>
  if (localPet==0) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=haloList, undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=haloList, undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=haloList, undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=haloList, undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
By default the DistGrid dimension is mapped to the first Array dimension, 
   associating the remaining Array dimensions with the undistributed dimensions
   in sequence. The dimension order is important when accessing the individual
   Array elements. Here the same initialization as before is extended to 
   cover the undistributed dimension.
<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr2d, rc=rc)
</PRE>

<P>
<PRE>
  do j=1, 3
    do i=1, 5
      farrayPtr2d(i,j) = real(seqIndexList(i),ESMF_KIND_R8) / 10.d0 + 100.d0*j
    enddo
  enddo
</PRE>

<P>
In the context of the Array halo operation additional undistributed dimensions
   are treated in a simple factorized manner. The same halo association between
   elements that is encoded in the 1D arbitrary sequence index scheme is
   applied to each undistributed element separately. This is completely 
   transparent on the user level and the same halo methods are used as before.
<P>
<PRE>
  call ESMF_ArrayHaloStore(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHalo(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHaloRelease(haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>

<H4><A NAME="SECTION050521640000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Halo for an Array with undistributed dimensions, created on
   the 1D arbitrary DistGrid, mapping the undistributed dimension first.</A>
</H4>
    
<BR>
<P>
In some situations it is more convenient to associate some or all of
   the undistributed dimensions with the first Array dimensions. This can be
   done easily by explicitly mapping the DistGrid dimension to an Array dimension
   other than the first one. The <TT>distgridToArrayMap</TT> argument is used to
   provide this information. The following code creates essentially the same
   Array as before, but with swapped dimension order - now the first Array
   dimension is the undistributed one.
<P>
<PRE>
  if (localPet==0) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=haloList, &amp;
      undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=haloList, &amp;
      undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=haloList, &amp;
      undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
#ifdef TEST_I8RANGE_on
    haloList(:)=(/1099511627777_ESMF_KIND_I8,&amp;
                  1099511627780_ESMF_KIND_I8,&amp;
                  1099511627779_ESMF_KIND_I8,&amp;
                  1099511627778_ESMF_KIND_I8/)
#else
    haloList(:)=(/1,3,5,4/)
#endif
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=haloList, &amp;
      undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
Notice that the <TT>haloList</TT> constructed on PET 3 is different from the
   previous examples. All other PETs reuse the same <TT>haloList</TT> as before.
   In the previous examples the list loaded into PET 3's
   <TT>haloSeqIndexList</TT> argument contained a duplicate sequence index.
   However, now that the undistributed dimension is placed first, the 
   <TT>ESMF_ArrayHaloStore()</TT> call will try to optimize the data exchange by
   vectorizing it. Duplicate sequence indices are currently <EM>not</EM> supported
   during vectorization.

<P>
When accessing the Array elements, the swapped dimension order results in 
   a swapping of <TT>i</TT> and <TT>j</TT>. This can be seen in the following
   initialization loop.
<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr2d, rc=rc)
</PRE>

<P>
<PRE>
  do j=1, 3
    do i=1, 5
      farrayPtr2d(j,i) = real(seqIndexList(i),ESMF_KIND_R8) / 10.d0 + 100.d0*j
    enddo
  enddo
</PRE>

<P>
Once set up, there is no difference in how the the halo operations are applied.
<P>
<PRE>
  call ESMF_ArrayHaloStore(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHalo(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>

<H4><A NAME="SECTION050521650000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">5</SPAN> Halo for an Array with undistributed dimensions, created on
   the 1D arbitrary DistGrid, re-using the RouteHandle.</A>
</H4>
    
<BR>
<P>
Arrays can reuse the same RouteHandle, saving the overhead that is caused by
   the precompute step. In order to demonstrate this the RouteHandle of the
   previous halo call was not yet released and will be applied to a new Array.

<P>
The following code creates an Array that is compatible to the 
   previous Array by using the same input information as before, only that
   the size of the undistributed dimension is now 6 instead of 3.
<P>
<PRE>
  if (localPet==0) then
    array2 = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=haloList, &amp;
      undistLBound=(/1/), undistUBound=(/6/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array2 = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=haloList, &amp;
      undistLBound=(/1/), undistUBound=(/6/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array2 = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=haloList, &amp;
      undistLBound=(/1/), undistUBound=(/6/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    array2 = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=haloList, &amp;
      undistLBound=(/1/), undistUBound=(/6/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
Again the exclusive Array elements must be initialized.
<P>
<PRE>
  call ESMF_ArrayGet(array2, farrayPtr=farrayPtr2d, rc=rc)
</PRE>

<P>
<PRE>
  do j=1, 6
    do i=1, 5
      farrayPtr2d(j,i) = real(seqIndexList(i),ESMF_KIND_R8) / 10.d0 + 100.d0*j
    enddo
  enddo
</PRE>

<P>
Now the <TT>haloHandle</TT> that was previously pre-computed for <TT>array</TT> can
   be used directly for <TT>array2</TT>.
<P>
<PRE>
  call ESMF_ArrayHalo(array2, routehandle=haloHandle, rc=rc)
</PRE>

<P>
Release the RouteHandle after its last use and clean up the remaining
   Array and DistGrid objects.
<P>
<PRE>
  call ESMF_ArrayHaloRelease(haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array2, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050521700000000000000"></A>
   <A NAME="Array:Redist"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">17</SPAN> Communication - Redist
</H3>

<P>
Arrays used in different models often cover the same index space region,
   however, the distribution of the Arrays may be different, e.g. the models
   run on exclusive sets of PETs. Even if the Arrays are defined on the same
   list of PETs the decomposition may be different.
<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/4,1/), rc=rc)
</PRE>

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/1,4/), rc=rc)
</PRE>

<P>
The number of elements covered by <TT>srcDistgrid</TT> is identical to the number
   of elements covered by <TT>dstDistgrid</TT> - in fact the index space regions
   covered by both DistGrid objects are congruent. However, the decomposition
   defined by <TT>regDecomp</TT>, and consequently the distribution of source and
   destination, are different.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>

<H4><A NAME="SECTION050521710000000000000"></A>
   <A NAME="Array:Redist:DefaultMode"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Default Mode
</H4>

<P>
By construction <TT>srcArray</TT> and <TT>dstArray</TT> are of identical type and
   kind. Further the number of exclusive elements matches between both Arrays.
   These are the prerequisites for the application of an Array redistribution
   in <EM>default</EM> mode. In order to increase performance of the actual 
   redistribution the communication pattern is precomputed once, and stored in
   an <TT>ESMF_RouteHandle</TT> object.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The <TT>redistHandle</TT> can now be used repeatedly to transfer data from
   <TT>srcArray</TT> to <TT>dstArray</TT>.
<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The use of the precomputed <TT>redistHandle</TT> is <EM>not</EM> restricted to
   the (<TT>srcArray</TT>, <TT>dstArray</TT>) pair. Instead the <TT>redistHandle</TT>
   can be used to redistribute data between any two Arrays that are compatible
   with the Array pair used during precomputation. I.e. any pair of Arrays that
   matches <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
   memory layout of the <EM>distributed</EM> dimensions. However, the size, number, 
   and index order of <EM>undistributed</EM> dimensions may be different.
   See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
   RouteHandle reusability.

<P>
The transferability of RouteHandles between Array pairs can greatly reduce
   the number of communication store calls needed.
   In a typical application Arrays are often defined on the same decomposition,
   typically leading to congruent distributed dimensions. For these Arrays, while
   they may not have the same shape or size in the undistributed dimensions,
   RouteHandles are reusable.

<P>
For the current case, the <TT>redistHandle</TT> was precomputed for simple 2D
   Arrays without undistributed dimensions. The RouteHandle transferability
   rule allows us to use this same RouteHandle to redistribute between two 
   3D Array that are built on the same 2D DistGrid, but have an undistributed
   dimension. Note that the undistributed dimension does not have to be in the
   same position on source and destination. Here the undistributed dimension is
   in position 2 for <TT>srcArray1</TT>, and in position 1 for <TT>dstArray1</TT>.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec3d, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
<PRE>
  srcArray1 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=srcDistgrid, &amp;
    distgridToArrayMap=(/1,3/), undistLBound=(/1/), undistUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
  dstArray1 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray1, dstArray=dstArray1, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The following variation of the code shows that the same RouteHandle can be
   applied to an Array pair even when the number of undistributed dimensions does
   not match between source and destination Array, as long as to the total
   <EM>number</EM> of undistributed <EM>elements</EM> matches.

<P>
We prepare a source Array with <EM>two</EM> undistributed dimensions, in position
   1 and 3, of size <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img72.png"
 ALT="$2$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$5$"></SPAN>, respectively. Thus there are <SPAN CLASS="MATH"><IMG
 WIDTH="77" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img74.png"
 ALT="$2 \times 5=10$"></SPAN>
   undistributed source elements. The destination array is the same as before
   with only a <EM>single</EM> undistributed dimension in position 1
   of size <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$10$"></SPAN>.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec4d, typekind=ESMF_TYPEKIND_R8, rank=4, rc=rc)
</PRE>

<P>
<PRE>
  srcArray2 = ESMF_ArrayCreate(arrayspec=arrayspec4d, distgrid=srcDistgrid, &amp;
    distgridToArrayMap=(/2,4/), undistLBound=(/1,1/), undistUBound=(/2,5/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray2, dstArray=dstArray1, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
When done, the resources held by <TT>redistHandle</TT> need to be deallocated
   by the user code before the RouteHandle becomes inaccessible.
<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=redistHandle, rc=rc)
</PRE>

<P>

<H4><A NAME="SECTION050521720000000000000"></A>
   <A NAME="Array:Redist:TransposeMode"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Transpose Mode
</H4>

<P>
In default mode, i.e. without providing the optional
   <TT>srcToDstTransposeMap</TT> argument, <TT>ESMF_ArrayRedistStore()</TT> does not
   require equal number of dimensions in source and destination Array. Only the
   total number of elements must match.
   Specifying <TT>srcToDstTransposeMap</TT> switches <TT>ESMF_ArrayRedistStore()</TT>
   into <EM>transpose</EM> mode. In this mode each dimension of <TT>srcArray</TT>
   is uniquely associated with a dimension in <TT>dstArray</TT>, and the sizes of 
   associated dimensions must match for each pair.
   
   
<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/20,10/), &amp;
      rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>
This <TT>dstArray</TT> object covers a 20 x 10 index space while the
   <TT>srcArray</TT>, defined further up, covers a 10 x 20 index space. Setting
   <TT>srcToDstTransposeMap = (/2,1/)</TT> will associate the first and second 
   dimension of <TT>srcArray</TT> with the second and first dimension of
   <TT>dstArray</TT>, respectively. This corresponds to a transpose of dimensions.
   Since the decomposition and distribution of dimensions may be different for
   source and destination redistribution may occur at the same time.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/2,1/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The transpose mode of <TT>ESMF_ArrayRedist()</TT> is not limited to
   distributed dimensions of Arrays. The <TT>srcToDstTransposeMap</TT> argument
   can be used to transpose undistributed dimensions in the same manner.
   Furthermore transposing distributed and undistributed dimensions between
   Arrays is also supported.

<P>
The <TT>srcArray</TT> used in the following examples is of rank 4 with 2 
   distributed and 2 undistributed dimensions. The distributed dimensions
   are the two first dimensions of the Array and are distributed according to the
   <TT>srcDistgrid</TT> which describes a total index space region of 100 x 200
   elements. The last two Array dimensions are undistributed dimensions of size
   2 and 3, respectively.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=4, rc=rc)
</PRE>

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/2,3/), rc=rc)
</PRE>

<P>
The first <TT>dstArray</TT> to consider is defined on a DistGrid that also 
   describes a 100 x 200 index space region. The distribution indicated
   by <TT>dstDistgrid</TT> may be different from the source distribution. Again
   the first two Array dimensions are associated with the DistGrid dimensions in
   sequence. Furthermore, the last two Array dimensions are undistributed
   dimensions, however, the sizes are 3 and 2, respectively.
<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/3,2/), rc=rc)
</PRE>

<P>
The desired mapping between <TT>srcArray</TT> and <TT>dstArray</TT> dimensions
   is expressed by <TT>srcToDstTransposeMap = (/1,2,4,3/)</TT>, transposing only
   the two undistributed dimensions.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/1,2,4,3/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Next consider a <TT>dstArray</TT> that is defined on the same <TT>dstDistgrid</TT>,
   but with a different order of Array dimensions. The desired order is
   specified during Array creation using the argument 
   <TT>distgridToArrayMap = (/2,3/)</TT>. This map associates the first and second
   DistGrid dimensions with the second and third Array dimensions, respectively,
   leaving Array dimensions one and four undistributed.
<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1,1/), undistUBound=(/3,2/), &amp;
    rc=rc)
</PRE>

<P>
Again the sizes of the undistributed dimensions are chosen in reverse order
   compared to <TT>srcArray</TT>. The desired transpose mapping in this case will
   be <TT>srcToDstTransposeMap = (/2,3,4,1/)</TT>.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/2,3,4,1/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Finally consider the case where <TT>dstArray</TT> is constructed on a 
   200 x 3 index space and where the undistributed dimensions are of size
   100 and 2.
<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/200,3/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/100,2/), rc=rc)
</PRE>

<P>
By construction <TT>srcArray</TT> and <TT>dstArray</TT> hold the same number of
   elements, albeit in a very different layout. Nevertheless, with a
   <TT>srcToDstTransposeMap</TT> that maps matching dimensions from source to
   destination, the following Array redistribution becomes a well defined
   operation between <TT>srcArray</TT> and <TT>dstArray</TT>.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/3,1,4,2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The <TT>srcToDstTransposeMap</TT> mechanism supports negative map entries.
   Negative entries indicate that the order of elements is to be reversed when
   going from source to destination.
   Using the same <TT>srcArray</TT> and <TT>dstArray</TT> objects as in the previous
   example, the following code maps the first <TT>srcArray</TT> dimension to the
   third <TT>dstArray</TT> dimension, as before. However, the ordering of
   the elements along this dimension is reversed between source and destination.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/-3,1,4,2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Redistribution of multi-tile Arrays is supported, although not shown as an
   example here. In <EM>default</EM> mode, the
   index space defined by both source and destination Arrays must match,
   regardless of how it is comprised by tiles. In particular, there is no
   restriction on the number of source and desination tiles, as long as both
   sides define the same global index space.

<P>
The situation is different in <EM>transpose</EM> mode. Here the number of source
   and destination tiles must match. In this case, the redistribution is defined
   tile-by-tile in order. If the provided 
   <TT>srcToDstTransposeMap</TT> is of size <TT>rank</TT>, it is used for all of the
   tiles. The other supported option is where <TT>srcToDstTransposeMap</TT> is of
   size <!-- MATH
 $rank \times tileCount$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$rank \times tileCount$"></SPAN>. In that case each source-destination tile-pair
   has its own transpose map.


<P>

<P>

<P>

<H3><A NAME="SECTION050521800000000000000"></A>
   <A NAME="Array:SparseMatMul"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">18</SPAN> Communication - SparseMatMul
</H3>

<P>
Sparse matrix multiplication is a fundamental Array communication method. One
   frequently used application of this method is the interpolation between pairs
   of Arrays. The principle is this: the value of each element in the exclusive 
   region of the destination Array is expressed as a linear combination of <EM>   potentially all</EM> the exclusive elements of the source Array. Naturally most of
   the coefficients of these linear combinations will be zero and it is more 
   efficient to store explicit information about the non-zero elements than to 
   keep track of all the coefficients.

<P>
There is a choice to be made with respect to the format in which to store the
   information about the non-zero elements. One option is to store the value
   of each coefficient together with the corresponding destination element index
   and source element index. Destination and source indices could be expressed in
   terms of the corresponding DistGrid tile index together with the coordinate
   tuple within the tile. While this format may be the most natural way to
   express elements in the source and destination Array, it has two major drawbacks.
   First the coordinate tuple is <TT>dimCount</TT> specific and second the format
   is extremely bulky. For 2D source and destination Arrays it would require 6
   integers to store the source and destination element information for each
   non-zero coefficient and matters get worse for higher dimensions.

<P>
Both problems can be circumvented by <EM>interpreting</EM> source and destination
   Arrays as sequentialized strings or <EM>vectors</EM> of elements. This is done
   by assigning a unique <EM>sequence index</EM> to each exclusive element in both
   Arrays. With that the operation of updating the elements in the destination Array
   as linear combinations of source Array elements takes the form of a <EM>sparse
   matrix multiplication</EM>.

<P>
The default sequence index rule assigns index <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$1$"></SPAN> to the <TT>minIndex</TT> corner
   element of the first tile of the DistGrid on which the Array is defined. It then
   increments the sequence index by <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$1$"></SPAN> for each element running through the
   DistGrid dimensions by order. The index space position of the DistGrid tiles
   does not affect the sequence labeling of elements. The default sequence indices
   for
 <PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/-1,0/), maxIndex=(/1,3/), rc=rc)
</PRE>

<P>
for each element are:
   <PRE>
     -------------------------------------&gt; 2nd dim
     |
     |   +------+------+------+------+
     |   |(-1,0)|      |      |(-1,3)|
     |   |      |      |      |      |
     |   |   1  |   4  |   7  |  10  |
     |   +------+------+------+------+
     |   |      |      |      |      |
     |   |      |      |      |      |
     |   |   2  |   5  |   8  |  11  |
     |   +------+------+------+------+
     |   | (1,0)|      |      | (1,3)|
     |   |      |      |      |      |
     |   |   3  |   6  |   9  |  12  |
     |   +------+------+------+------+
     |
     v
    1st dim
</PRE>

<P>
The assigned sequence indices are decomposition and distribution invariant by
   construction. Furthermore, when an Array is created with extra elements per DE on
   a DistGrid the sequence indices (which only cover the exclusive elements) remain
   unchanged.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
The extra padding of 1 element in each direction around the exclusive elements on
   each DE are "invisible" to the Array sparse matrix multiplication method. These
   extra elements are either updated by the computational kernel or by Array halo
   operations.

<P>
An alternative way to assign sequence indices to all the elements in the tiles
   covered by a DistGrid object is to use a special <TT>ESMF_DistGridCreate()</TT>
   call. This call has been specifically designed for 1D cases with arbitrary,
   user-supplied sequence indices.
<P>
<PRE>
  seqIndexList(1) = localPet*10
  seqIndexList(2) = localPet*10 + 1
  dstDistgrid = ESMF_DistGridCreate(arbSeqIndexList=seqIndexList, rc=rc)
</PRE>

<P>
This call to <TT>ESMF_DistGridCreate()</TT> is collective across the current VM.
   The <TT>arbSeqIndexList</TT> argument specifies the PET-local arbitrary sequence
   indices that need to be covered by the local DE. The resulting DistGrid has
   one local DE per PET which covers the entire PET-local index range. The user
   supplied sequence indices must be unique, but the sequence may be interrupted.
   The four DEs of <TT>dstDistgrid</TT> have the following local 1D index space
   coordinates (given between "()") and sequence indices:
   <PRE>
    covered by DE 0    covered by DE 1   covered by DE 2   covered by DE 3
    on PET 0           on PET 1          on PET 2          on PET 3
    ----------------------------------------------------------------------
    (1) : 0            (1) : 10          (1) : 20          (1) : 30
    (2) : 1            (2) : 11          (2) : 21          (2) : 31
</PRE>

<P>
Again the DistGrid object provides the sequence index labeling for the
   exclusive elements of an Array created on the DistGrid regardless of extra,
   non-exclusive elements.
<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>
With the definition of sequence indices, either by the default rule or as user
   provided arbitrary sequence indices, it is now possible to uniquely identify
   each exclusive element in the source and destination Array by a single integer
   number. Specifying a pair of source and destination elements takes two integer
   number regardless of the number of dimensions.

<P>
The information required to carry out a sparse matrix multiplication are the
   pair of source and destination sequence indices and the associated
   multiplication factor for each pair. ESMF requires this information in form of
   two Fortran arrays. The factors are stored in a 1D array of the appropriate
   type and kind, e.g. <TT>real(ESMF_KIND_R8)::factorList(:)</TT>. Array sparse
   matrix multiplications are supported between Arrays of different type and
   kind. The type and kind of the factors can also be chosen freely. The 
   sequence index pairs associated with the factors provided by <TT>factorList</TT> 
   are stored in a 2D Fortran array of default integer kind of the shape <TT>   integer::factorIndexList(2,:)</TT>. The sequence indices of the source Array elements
   are stored in the first row of <TT>   factorIndexList</TT> while the sequence indices of the destination Array elements are
   stored in the second row.

<P>
Each PET in the current VM must call into <TT>ESMF_ArraySMMStore()</TT>
   to precompute and store the communication pattern for the sparse matrix
   multiplication. The multiplication factors may be provided in parallel, i.e.
   multiple PETs may specify <TT>factorList</TT> and <TT>factorIndexList</TT> arguments
   when calling into <TT>ESMF_ArraySMMStore()</TT>. PETs that do not
   provide factors either call with <TT>factorList</TT> and <TT>factorIndexList</TT>
   arguments containing zero elements or issue the call omitting both arguments.
<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(2,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/30/)         ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
</PRE>

<P>
<PRE>
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(2,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/11, 11, 30/) ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
</PRE>

<P>
<PRE>
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
<PRE>
      
  endif
</PRE>

<P>
The RouteHandle object <TT>sparseMatMulHandle</TT> produced by 
   <TT>ESMF_ArraySMMStore()</TT> can now be used to call <TT>   ESMF_ArraySMM()</TT> collectively across all PETs of the current VM to
   perform
   <PRE>
     dstArray = 0.0
     do n=1, size(combinedFactorList)
         dstArray(combinedFactorIndexList(2, n)) += 
           combinedFactorList(n) * srcArray(combinedFactorIndexList(1, n))
     enddo
</PRE>
   in parallel. Here <TT>combinedFactorList</TT> and <TT>combinedFactorIndexList</TT>
   are the combined lists defined by the respective local lists provided by 
   PETs 0 and 1 in parallel. For this example
 <PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
will initialize the entire <TT>dstArray</TT> to 0.0 and then update two elements:

<P>
<PRE>
   on DE 1:
   dstArray(2) = 0.5 * srcArray(0,0)  +  0.5 * srcArray(0,2)
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray(1) = 0.2 * srcArray(0,1)  +  0.8 * srcArray(1,3).
</PRE>

<P>
The call to <TT>ESMF_ArraySMM()</TT> does provide the option to turn
   the default <TT>dstArray</TT> initialization off. If argument <TT>zeroregion</TT>
   is set to <TT>ESMF_REGION_EMPTY</TT>
<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, zeroregion=ESMF_REGION_EMPTY, rc=rc)
</PRE>

<P>
skips the initialization and elements in <TT>dstArray</TT> are updated according to:

<P>
<PRE>
     do n=1, size(combinedFactorList)
         dstArray(combinedFactorIndexList(2, n)) += 
           combinedFactorList(n) * srcArray(combinedFactorIndexList(1, n)).
     enddo
</PRE>

<P>
The <TT>ESMF_RouteHandle</TT> object returned by <TT>ESMF_ArraySMMStore()</TT>
   can be applied to any src/dst Array pairs that is compatible with the
   Array pair used during precomputation, i.e. any pair of Arrays that matches 
   <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
   memory layout of the <EM>distributed</EM> dimensions. However, the size, number, 
   and index order of <EM>undistributed</EM> dimensions may be different.
   See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
   RouteHandle reusability.

<P>
The resources held by <TT>sparseMatMulHandle</TT> need to be deallocated by the
   user code before the handle becomes inaccessible.
<P>
<PRE>
  call ESMF_ArraySMMRelease(routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
The Array sparse matrix multiplication also applies to Arrays with
   undistributed dimensions. The undistributed dimensions are interpreted
   in a sequentialized manner, much like the distributed dimensions,
   introducing a second sequence index for source and destination elements.
   Sequence index 1 is assigned to the first element in the first 
   (i.e. fastest varying in memory) undistributed dimension. The following
   undistributed elements are labeled in consecutive order as they are stored in
   memory.

<P>
In the simplest case the Array sparse matrix multiplication will apply an
   identity matrix to the vector of sequentialized undistributed Array elements
   for every non-zero element in the sparse matrix. The requirement in this case
   is that the total undistributed element count, i.e. the product of the sizes 
   of all undistributed dimensions, be the same for source and destination Array.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    distgridToArrayMap=(/1,2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
Setting up <TT>factorList</TT> and <TT>factorIndexList</TT> is identical to the 
   case for Arrays without undistributed dimensions. Also the call to 
   <TT>ESMF_ArraySMMStore()</TT> remains unchanged. Internally, however,
   the source and destination Arrays are checked to make sure the total
   undistributed element count matches.
<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(2,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/30/)         ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
</PRE>

<P>
<PRE>
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(2,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/11, 11, 30/) ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
</PRE>

<P>
<PRE>
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
The call into the <TT>ESMF_ArraySMM()</TT> operation is completely
   transparent with respect to whether source and/or destination Arrays contain
   undistributed dimensions.
<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
This operation will initialize the entire <TT>dstArray</TT> to 0.0 and then 
   update four elements:

<P>
<PRE>
   on DE 1:
   dstArray[1](2) = 0.5 * srcArray(0,0)[1]  +  0.5 * srcArray(0,2)[1],
   dstArray[2](2) = 0.5 * srcArray(0,0)[2]  +  0.5 * srcArray(0,2)[2]
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray[1](1) = 0.2 * srcArray(0,1)[1]  +  0.8 * srcArray(1,3)[1],
   dstArray[2](1) = 0.2 * srcArray(0,1)[2]  +  0.8 * srcArray(1,3)[2].
</PRE>

<P>
Here indices between "()" refer to distributed dimensions while indices
   between "[]" correspond to undistributed dimensions. 

<P>
In a more general version of the Array sparse matrix multiplication the
   total undistributed element count, i.e. the product of the sizes 
   of all undistributed dimensions, need not be the same for source and
   destination Array. In this formulation each non-zero element of the sparse
   matrix is identified with a unique element in the source and destination
   Array. This requires a generalization of the <TT>factorIndexList</TT> argument
   which now must contain four integer numbers for each element. These numbers
   in sequence are the sequence index of the distributed dimensions and the
   sequence index of the undistributed dimensions of the element in the source
   Array, followed by the sequence index of the distributed dimensions and
   the sequence index of the undistributed dimensions of the element in the
   destination Array.
<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    distgridToArrayMap=(/1,2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2/), undistLBound=(/1/), undistUBound=(/4/), rc=rc)
</PRE>

<P>
Setting up <TT>factorList</TT> is identical to the previous cases since there is
   still only one value associated with each non-zero matrix element. However,
   each entry in <TT>factorIndexList</TT> now has 4 instead of just 2 components.
<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(4,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/1/)          ! undistr. seq indices into srcArray
    factorIndexList(3,:) = (/30/)         ! seq indices into dstArray
    factorIndexList(4,:) = (/2/)          ! undistr. seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
</PRE>

<P>
<PRE>
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(4,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/2, 1, 1/)    ! undistr. seq indices into srcArray
    factorIndexList(3,:) = (/11, 11, 30/) ! seq indices into dstArray
    factorIndexList(4,:) = (/4, 4, 2/)    ! undistr. seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
</PRE>

<P>
<PRE>
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
The call into the <TT>ESMF_ArraySMM()</TT> operation remains
   unchanged.
<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
This operation will initialize the entire <TT>dstArray</TT> to 0.0 and then 
   update two elements:

<P>
<PRE>
   on DE 1:
   dstArray[4](2) = 0.5 * srcArray(0,0)[1]  +  0.5 * srcArray(0,2)[2],
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray[2](1) = 0.2 * srcArray(0,1)[1]  +  0.8 * srcArray(1,3)[1],
</PRE>

<P>
Here indices in <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img77.png"
 ALT="$()$"></SPAN> refer to distributed dimensions while indices in <SPAN CLASS="MATH"><IMG
 WIDTH="13" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="$[]$"></SPAN>
   correspond to undistributed dimensions.


<P>

<P>

<P>

<H3><A NAME="SECTION050521900000000000000"></A>
   <A NAME="Array:ScatterGatherRevisited"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">19</SPAN> Communication - Scatter and Gather, revisited
</H3>

<P>
The <TT>ESMF_ArrayScatter()</TT> and <TT>ESMF_ArrayGather()</TT> calls, 
   introduced in section <A HREF="#Array:ScatterGather">28.2.14</A>, provide a convenient
   way of communicating data between a Fortran array and all of the DEs of
   a single Array tile. A key requirement of <TT>ESMF_ArrayScatter()</TT>
   and <TT>ESMF_ArrayGather()</TT> is that the <EM>shape</EM> of the Fortran array
   and the Array tile must match. This means that the <TT>dimCount</TT> must be
   equal, and that the size of each dimension must match. Element reordering
   during scatter and gather is only supported on a per dimension level,
   based on the <TT>decompflag</TT> option available during DistGrid creation.

<P>
While the <TT>ESMF_ArrayScatter()</TT> and <TT>ESMF_ArrayGather()</TT> methods
   cover a broad, and important spectrum of cases, there are situations that
   require a different set of rules to scatter and gather data between a
   Fortran array and an ESMF Array object. For instance, it is often convenient
   to create an Array on a DistGrid that was created with arbitrary,
   user-supplied sequence indices. See section <A HREF="#DistGrid:ArbitrarySeqInd">36.3.5</A>
   for more background on DistGrids with arbitrary sequence indices.
<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet+1 ! initialize unique 
                                                     ! seq. indices
  enddo
  
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arbSeqIndexList)
  
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=1, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
This <TT>array</TT> object holds 10 elements on each DE, and there is one DE
   per PET, for a total element count of 10 x <TT>petCount</TT>. The
   <TT>arbSeqIndexList</TT>, used during DistGrid creation, was constructed cyclic
   across all DEs. DE 0, for example, on a 4 PET run, would hold sequence
   indices 1, 5, 9, ... . DE 1 would hold 2, 6, 10, ..., and so on.

<P>
The usefulness of the user-specified arbitrary sequence indices becomes
   clear when they are interpreted as global element ids. The ArrayRedist()
   and ArraySMM() communication methods are based on sequence index mapping
   between source and destination Arrays. Other than providing a canonical
   sequence index order via the default sequence scheme, outlined in
   <A HREF="#Array:SparseMatMul">28.2.18</A>, ESMF does not place any restrictions on the
   sequence indices. Objects that were not created with user supplied
   sequence indices default to the ESMF sequence index order.

<P>
A common, and useful interpretation of the arbitrary sequence indices, 
   specified during DistGrid creation, is that of relating them to the 
   canonical ESMF sequence index order of another data object. Within this
   interpretation the <TT>array</TT> object created above could be viewed as an
   arbitrary distribution of a (<TT>petCount</TT> x 10) 2D array. 
  
<P>
<PRE>
  if (localPet == 0) then
    allocate(farray(petCount,10)) ! allocate 2D Fortran array petCount x 10
    do j=1, 10
      do i=1, petCount
        farray(i,j) = 100 + (j-1)*petCount + i    ! initialize to something
      enddo
    enddo
  else
    allocate(farray(0,0)) ! must allocate an array of size 0 on all other PETs
  endif
</PRE>

<P>
For a 4 PET run, <TT>farray</TT> on PET 0 now holds the following data.
   <PRE>
     -----1----2----3------------10-----&gt; j
     |
     1   101, 105, 109, ....  , 137
     |
     2   102, 106, 110, ....  , 138
     |
     3   103, 107, 111, ....  , 139
     |
     4   104, 108, 112, ....  , 140
     |
     |
     v
    i
</PRE>

<P>
On all other PETs <TT>farray</TT> has a zero size allocation.

<P>
Following the sequence index interpretation from above, scattering the data
   contained in <TT>farray</TT> on PET 0 across the <TT>array</TT> object created
   further up, seems like a well defined operation. Looking at it a bit closer,
   it becomes clear that it is in fact more of a redistribution than a simple
   scatter operation. The general rule for such a "redist-scatter"  operation,
   of a Fortran array, located on a single PET, into an ESMF Array, is to 
   use the canonical ESMF sequence index scheme to label the elements of the
   Fortran array, and to send the data to the Array element with the same
   sequence index.

<P>
The just described "redist-scatter" operation is much more general than
   the standard <TT>ESMF_ArrayScatter()</TT> method. It does not require shape
   matching, and supports full element reordering based on the sequence indices.
   Before <TT>farray</TT> can be scattered across <TT>array</TT> in the described way,
   it must be wrapped into an ESMF Array object itself, essentially labeling the
   array elements according to the canonical sequence index scheme.
   
<P>
<PRE>
  distgridAux = ESMF_DistGridCreate(minIndex=(/1,1/), &amp;
    maxIndex=(/petCount,10/), &amp;
    regDecomp=(/1,1/), rc=rc) ! DistGrid with only 1 DE
</PRE>

<P>
The first step is to create a DistGrid object with only a single DE. This
   DE must be located on the PET on which the Fortran data array resides.
   In this example <TT>farray</TT> holds data on PET 0, which is where the default
   DELayout will place the single DE defined in the DistGrid. If the <TT>farray</TT>
   was setup on a different PET, an explicit DELayout would need to be created
   first, mapping the only DE to the PET on which the data is defined.

<P>
Next the Array wrapper object can be created from the <TT>farray</TT> and the
   just created DistGrid object.
<P>
<PRE>
  arrayAux = ESMF_ArrayCreate(farray=farray, distgrid=distgridAux, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
At this point all of the pieces are in place to use <TT>ESMF_ArrayRedist()</TT>
   to do the "redist-scatter" operation. The typical store/execute/release
   pattern must be followed.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=arrayAux, dstArray=array, &amp;
    routehandle=scatterHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=arrayAux, dstArray=array, &amp;
    routehandle=scatterHandle, rc=rc)
</PRE>

<P>
In this example, after <TT>ESMF_ArrayRedist()</TT> was called, the content
   of <TT>array</TT> on a 4 PET run would look like this:
   <PRE>
    PET 0:   101, 105, 109, ....  , 137
    PET 1:   102, 106, 110, ....  , 138
    PET 2:   103, 107, 111, ....  , 139
    PET 3:   104, 108, 112, ....  , 140
</PRE>

<P>
Once set up, <TT>scatterHandle</TT> can be used repeatedly to scatter data
   from <TT>farray</TT> on PET 0 to all the DEs of <TT>array</TT>. All of the
   resources should be released once <TT>scatterHandle</TT> is no longer needed.
<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=scatterHandle, rc=rc)
</PRE>

<P>
The opposite operation, i.e. <EM>gathering</EM> of the <TT>array</TT> data
   into <TT>farray</TT> on PET 0, follows a very similar setup. In fact, the
   <TT>arrayAux</TT> object already constructed for the scatter direction, can
   directly be re-used. The only thing that is different for the "redist-gather",
   are the <TT>srcArray</TT> and <TT>dstArray</TT> argument assignments, reflecting
   the opposite direction of data movement.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=array, dstArray=arrayAux, &amp;
    routehandle=gatherHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=array, dstArray=arrayAux, &amp;
    routehandle=gatherHandle, rc=rc)
</PRE>

<P>
Just as for the scatter case, the <TT>gatherHandle</TT> can be used repeatedly
   to gather data from <TT>array</TT> into <TT>farray</TT> on PET 0. All of the
   resources should be released once <TT>gatherHandle</TT> is no longer needed.
<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=gatherHandle, rc=rc)
</PRE>

<P>
Finally the wrapper Array <TT>arrayAux</TT> and the associated DistGrid object
   can also be destroyed.
<P>
<PRE>
  call ESMF_ArrayDestroy(arrayAux, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgridAux, rc=rc)
</PRE>

<P>
Further, the primary data objects of this example must be deallocated
   and destroyed.
<P>
<PRE>
  deallocate(farray)
  
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050522000000000000000"></A>
   <A NAME="Array:CommNB"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">20</SPAN> Non-blocking Communications
</H3>

<P>
All <TT>ESMF_RouteHandle</TT> based communication methods, like 
   <TT>ESMF_ArrayRedist()</TT>, <TT>ESMF_ArrayHalo()</TT> and <TT>ESMF_ArraySMM()</TT>, 
   can be executed in blocking or non-blocking mode. The non-blocking feature is
   useful, for example, to overlap computation with communication, or to
   implement a more loosely synchronized inter-Component interaction scheme than
   is possible with the blocking communication mode.

<P>
Access to the non-blocking execution mode is provided uniformly across all
   RouteHandle based communication calls. Every such call contains the optional
   <TT>routesyncflag</TT> argument of type <TT>ESMF_RouteSync_Flag</TT>. Section
   <A HREF="node9.html#const:routesync">54.51</A> lists all of the valid settings for this flag.

<P>
It is an execution time decision to select whether to invoke a precomputed
   communication pattern, stored in a RouteHandle, in the blocking or
   non-blocking mode. Neither requires specifically precomputed RouteHandles
   - i.e. a RouteHandle is neither specifically blocking nor specifically
   non-blocking.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
The returned RouteHandle <TT>routehandle</TT> can be used in blocking or 
   non-blocking execution calls. The application is free to switch between
   both modes for the same RouteHandle.

<P>
By default <TT>routesyncflag</TT> is set to <TT>ESMF_ROUTESYNC_BLOCKING</TT> in all of the
   RouteHandle execution methods, and the behavior is that of the VM-wide
   collective communication calls described in the previous sections. In the
   blocking mode the user must assume that the communication call will not
   return until all PETs have exchanged the precomputed information. On the
   other hand, the user has no guarantee about the exact synchronization 
   behavior, and it is unsafe to make specific assumptions. What is guaranteed
   in the blocking communication mode is that when the call returns on the
   local PET, all data exchanges associated with all local DEs have finished.
   This means that all in-bound data elements are valid and that all out-bound
   data elements can safely be overwritten by the user.
<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, routesyncflag=ESMF_ROUTESYNC_BLOCKING, rc=rc)
</PRE>

<P>
The same exchange pattern, that is encoded in <TT>routehandle</TT>, can be 
   executed in non-blocking mode, simply by setting the appropriate
   <TT>routesyncflag</TT> when calling into <TT>ESMF_ArrayRedist()</TT>.

<P>
At first sight there are obvious similarities between the non-blocking
   RouteHandle based execution paradigm and the non-blocking message passing
   calls provided by MPI. However, there are significant differences in
   the behavior of the non-blocking point-to-point calls that MPI defines and
   the non-blocking mode of the collective exchange patterns described by ESMF
   RouteHandles.

<P>
Setting <TT>routesyncflag</TT> to <TT>ESMF_ROUTESYNC_NBSTART</TT> in any RouteHandle
   execution call returns immediately after all out-bound data has been moved
   into ESMF internal transfer buffers and the exchange has been initiated.
<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, routesyncflag=ESMF_ROUTESYNC_NBSTART, rc=rc)
</PRE>

<P>
Once a call with <TT>routesyncflag = ESMF_ROUTESYNC_NBSTART</TT> returns, it is safe
   to modify the out-bound data elements in the <TT>srcArray</TT> object. However,
   no guarantees are made for the in-bound data elements in <TT>dstArray</TT> at
   this phase of the non-blocking execution. It is unsafe to access these
   elements until the exchange has finished locally.

<P>
One way to ensure that the exchange has finished locally is to call 
   with <TT>routesyncflag</TT> set to <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT>.
   
<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, routesyncflag=ESMF_ROUTESYNC_NBWAITFINISH, rc=rc)
</PRE>

<P>
Calling with <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT> instructs the
   communication method to wait and block until the previously started
   exchange has finished, and has been processed locally according to 
   the RouteHandle. Once the call returns, it is safe to access both in-bound
   and out-bound data elements in <TT>dstArray</TT> and <TT>srcArray</TT>, 
   respectively.

<P>
Some situations require more flexibility than is provided by the 
   <TT>ESMF_ROUTESYNC_NBSTART</TT> - <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> pair. For
   instance, a Component that needs to interact with several other Components,
   virtually simultaneously, would initiated several different exchanges with 
   <TT>ESMF_ROUTESYNC_NBSTART</TT>. Calling with <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> for
   any of the outstanding exchanges may potentially block for a long time, 
   lowering the throughput. In the worst case a dead lock situation may arise.
   Calling with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT> addresses this problem.
   
<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, routesyncflag=ESMF_ROUTESYNC_NBTESTFINISH, &amp;
    finishedflag=finishflag, rc=rc)
</PRE>

<P>
This call tests the locally outstanding data transfer operation in 
   <TT>routehandle</TT>, and finishes the exchange as much as currently possible.
   It does not block until the entire exchange has finished locally, instead
   it returns immediately after one round of testing has been
   completed. The optional return argument <TT>finishedflag</TT> is set to 
   <TT>.true.</TT> if the exchange is completely finished locally, and set to 
   <TT>.false.</TT> otherwise.

<P>
The user code must decide, depending on the value of the returned
   <TT>finishedflag</TT>, whether additional calls are required to finish an
   outstanding non-blocking exchange. If so, it can be done by 
   calling <TT>ESMF_ArrayRedist()</TT> repeatedly with 
   <TT>ESMF_ROUTESYNC_NBTESTFINISH</TT> until 
   <TT>finishedflag</TT> comes back with a value of <TT>.true.</TT>. Such a loop
   allows other pieces of user code to be executed between the calls. 
   A call with <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> can alternatively be used to
   block until the exchange has locally finished.

<P>
<EM>Noteworthy property.</EM>
   It is allowable to invoke a RouteHandle based communication call
   with <TT>routesyncflag</TT> set to 
   <TT>ESMF_ROUTESYNC_NBTESTFINISH</TT> or
   <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> on a specific RouteHandle without there 
   being an outstanding non-blocking exchange. As a matter of fact, it is not
   required that there was ever a call made with <TT>ESMF_ROUTESYNC_NBSTART</TT> for
   the RouteHandle. In these cases the calls made with
   <TT>ESMF_ROUTESYNC_NBTESTFINISH</TT> or <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT>  will
   simply return immediately (with <TT>finishedflag</TT> set to <TT>.true.</TT>).

<P>
<EM>Noteworthy property.</EM>
   It is fine to mix blocking and non-blocking invocations of the same 
   RouteHandle based communication call across the PETs. This means that it is
   fine for some PETs to issue the call with <TT>ESMF_ROUTESYNC_BLOCKING</TT>
   (or using the default), while other PETs call the same communication call
   with <TT>ESMF_ROUTESYNC_NBSTART</TT>.

<P>
<EM>Noteworthy restriction.</EM>
   A RouteHandle that is currently involved in an outstanding non-blocking
   exchange may <EM>not</EM> be used to start any further exchanges, neither
   blocking nor non-blocking. This restriction is independent of whether the
   newly started RouteHandle based exchange is made for the same or for 
   different data objects.

<P>


<H2><A NAME="SECTION05053000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<A NAME="Array:rest"></A>

<UL>
<LI><B>CAUTION:</B> Depending on the specific <TT>ESMF_ArrayCreate()</TT> entry point used during Array creation, certain Fortran operations are not supported on the Fortran array pointer <TT>farrayPtr</TT>, returned by <TT>ESMF_ArrayGet()</TT>. Only if the <TT>ESMF_ArrayCreate()</TT> <EM>from pointer</EM> variant was used, will the returned <TT>farrayPtr</TT> variable contain the original bounds information, and be suitable for the Fortran <TT>deallocate()</TT> call. This limitation is a direct consequence of the Fortran 95 standard relating to the passing of array arguments. Fortran array pointers returned from an Array that was created through the <EM>assumed shape array</EM> variant of <TT>ESMF_ArrayCreate()</TT> will have bounds that are consistent with the other arguments specified during Array creation. These pointers are not suitable for deallocation in accordance to the Fortran 95 standard.

<P>
</LI>
<LI><B>1D limit:</B> ArrayHalo(), ArrayRedist() and ArraySMM() operations on Arrays created on DistGrids with arbitrary sequence indices are currently limited to 1D arbitrary DistGrids. There is no restriction on the number, size
and mapping of undistributed Array dimensions in the presence of such a 1D
arbitrary DistGrid.

<P>
</LI>
</UL>

<H2><A NAME="SECTION05054000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The Array class is part of the ESMF index space layer and is built on top of the DistGrid and DELayout classes. The DELayout class introduces the notion of 
<EM>decomposition elements</EM> (DEs) and their layout across the available PETs. The DistGrid describes how index space is decomposed by assigning <EM>logically rectangular index space pieces</EM> or <EM>DE-local tiles</EM> to the DEs. The Array finally associates a <EM>local memory allocation</EM> with each local DE.

<P>
The following is a list of implementation specific details about the current ESMF Array.

<P>

<UL>
<LI>Implementation language is C++.
</LI>
<LI>Local memory allocations are internally held in <TT>ESMF_LocalArray</TT>
objects.
</LI>
<LI>All precomputed communication methods are based on sparse matrix
multiplication.
</LI>
</UL>

<H2><A NAME="SECTION05055000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05055100000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ArrayAssignment(=) - Array assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface assignment(=)
   array1 = array2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array) :: array1
   type(ESMF_Array) :: array2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign array1 as an alias to the same ESMF Array object in memory
   as array2. If array2 is invalid, then array1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>array1</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>array2</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055200000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ArrayOperator(==) - Array equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
   if (array1 == array2) then ... endif
   OR
   result = (array1 == array2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array1
   type(ESMF_Array), intent(in) :: array2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether array1 and array2 are valid aliases to the same ESMF
   Array object in memory. For a more general comparison of two ESMF Arrays,
   going beyond the simple alias test, the ESMF_ArrayMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>array1</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>array2</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055300000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ArrayOperator(/=) - Array not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
   if (array1 /= array2) then ... endif
   OR
   result = (array1 /= array2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array1
   type(ESMF_Array), intent(in) :: array2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether array1 and array2 are <I>not</I> valid aliases to the
   same ESMF Array object in memory. For a more general comparison of two ESMF
   Arrays, going beyond the simple alias test, the ESMF_ArrayMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>array1</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>array2</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055400000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ArrayCopy - Copy data from one Array object to another</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayCopy(arrayOut, arrayIn, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Array), intent(inout) :: arrayOut
        type(ESMF_Array), intent(in) :: arrayIn
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Copy data from one <TT>ESMF_Array</TT> object to another.

<P>
The arguments are:
   <DL>
<DT><STRONG>arrayOut</STRONG></DT>
<DD><TT>ESMF_Array</TT> object into which to copy the data. The incoming
   <TT>arrayOut</TT> must already references a matching memory allocation.
   
</DD>
<DT><STRONG>arrayIn</STRONG></DT>
<DD><TT>ESMF_Array</TT> object that holds the data to be copied.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055500000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ArrayCreate - Create Array object from Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateFrmPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(distgrid, farrayPtr, &amp; 
   datacopyflag, distgridToArrayMap, computationalEdgeLWidth, &amp; 
   computationalEdgeUWidth, computationalLWidth, &amp; 
   computationalUWidth, totalLWidth, &amp; 
   totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing local native Fortran 
   arrays with pointer attribute. The decomposition and distribution is 
   specified by the <TT>distgrid</TT> argument. Each PET must issue this call 
   with identical arguments in order to create a consistent Array object. 
   The only exception is the <TT>farrayPtr</TT> argument which will be different 
   on each PET. The bounds of the local arrays are preserved by this call and 
   determine the bounds of the total region of the 
   resulting Array object. Bounds of the DE-local exclusive regions are set 
   to be consistent with the total regions and the specified <TT>distgrid</TT> 
   argument. Bounds for Array dimensions that are not distributed are 
   automatically set to the bounds provided by <TT>farrayPtr</TT>. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Valid native Fortran array with pointer attribute. Memory must be 
   associated with the actual argument. The type/kind/rank information of 
   <TT>farrayPtr</TT> will be used to set <TT>Array</TT>'s properties 
   accordingly. The shape of <TT>farrayPtr</TT> will be checked against the 
   information contained in the <TT>distgrid</TT>. The bounds of 
   <TT>farrayPtr</TT> will be preserved by this call and the bounds of the 
   resulting Array object are set accordingly. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farrayPtr</TT> directly or will copy the data from 
   <TT>farrayPtr</TT> into a new memory allocation. For valid values see 
   <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   Note that the <TT>ESMF_DATACOPY_REFERENCE</TT> option may not be safe 
   when providing an array slice in <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farrayPtr</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farrayPtr</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farrayPtr</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the exclusive region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the exclusive region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the <TT>farrayPtr</TT> argument. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05055600000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ArrayCreate - Create Array object from Fortran array pointer w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateFrmPtrArb&lt;indexkind&gt;&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(distgrid, &amp; 
   farrayPtr, haloSeqIndexList, datacopyflag, &amp; 
   distgridToArrayMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateDataPtrArb&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   integer(ESMF_KIND_&lt;indexkind&gt;), intent(in) :: haloSeqIndexList(:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing local native Fortran 
   arrays with pointer attribute, according to distgrid. Besides 
   <TT>farrayPtr</TT> each PET must issue this call with identical arguments in 
   order to create a consistent Array object. The bounds of the local arrays 
   are preserved by this call and determine the bounds of the total region of 
   the resulting Array object. Bounds of the DE-local exclusive regions are 
   set to be consistent with the total regions and the specified distgrid 
   argument. Bounds for Array dimensions that are not distributed are 
   automatically set to the bounds provided by <TT>farrayPtr</TT>. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Valid native Fortran array with pointer attribute. Memory must be 
   associated with the actual argument. The type/kind/rank information of 
   <TT>farrayPtr</TT> will be used to set <TT>Array</TT>'s properties 
   accordingly. The shape of <TT>farrayPtr</TT> will be checked against the 
   information contained in the <TT>distgrid</TT>. The bounds of 
   <TT>farrayPtr</TT> will be preserved by this call and the bounds of the 
   resulting Array object are set accordingly. 
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region. 
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will) 
   be different on each PET. 
   The <TT>haloSeqIndexList</TT> argument is of integer type, but can be of 
   different kind in order to support both 32-bit (<TT>ESMF_KIND_I4</TT>) 
   and 64-bit (<TT>ESMF_KIND_I8</TT>) indexing. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farrayPtr</TT> directly or will copy the data from 
   <TT>farrayPtr</TT> into a new memory allocation. For valid values see 
   <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   Note that the <TT>ESMF_DATACOPY_REFERENCE</TT> option may not be safe 
   when providing an array slice in <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farrayPtr</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farrayPtr</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farrayPtr</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05055700000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ArrayCreate - Create Array object from Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateAsmdSp&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(distgrid, farray, &amp; 
   indexflag, datacopyflag, distgridToArrayMap, &amp; 
   computationalEdgeLWidth, computationalEdgeUWidth, computationalLWidth, &amp; 
   computationalUWidth, totalLWidth, &amp; 
   totalUWidth, undistLBound, undistUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateDataAssmdShape&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(in), optional :: undistLBound(:) 
   integer, intent(in), optional :: undistUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from an existing local native Fortran 
   array. The decomposition and distribution is 
   specified by the <TT>distgrid</TT> argument. Each PET must issue this call 
   with identical arguments in order to create a consistent Array object. 
   The only exception is the <TT>farray</TT> argument which will be different 
   on each PET. The local arrays provided must be dimensioned according to 
   the DE-local total region. Bounds of the exclusive regions are set as 
   specified in the <TT>distgrid</TT> argument. Bounds for Array dimensions 
   that are not distributed can be chosen freely using the 
   <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of farray. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of <TT>farray</TT> will be 
   used to set <TT>Array</TT>'s properties accordingly. The shape of 
   <TT>farray</TT> will be checked against the information contained in the 
   <TT>distgrid</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farray</TT> directly or will copy the data from 
   <TT>farray</TT> into a new memory allocation. For valid values see 
   <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   Note that the <TT>ESMF_DATACOPY_REFERENCE</TT> option may not be safe 
   when providing an array slice in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farray</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farray</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farray</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the exclusive region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the exclusive region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the <TT>farray</TT> argument. 
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed. 
   By default lbound is 1. 
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed. 
   By default ubound is equal to the extent of the corresponding 
   dimension in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05055800000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_ArrayCreate - Create Array object from Fortran array w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateAsmdSpArb&lt;indexkind&gt;&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(distgrid, &amp; 
   farray, indexflag, haloSeqIndexList, datacopyflag, &amp; 
   distgridToArrayMap, computationalEdgeLWidth, computationalEdgeUWidth, &amp; 
   computationalLWidth, computationalUWidth, totalLWidth, totalUWidth, &amp; 
   undistLBound, undistUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateDataAssmdShapeArb&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
   integer(ESMF_KIND_&lt;indexkind&gt;), intent(in) :: haloSeqIndexList(:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(in), optional :: undistLBound(:) 
   integer, intent(in), optional :: undistUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from an existing local native Fortran 
   array. The decomposition and distribution is 
   specified by the <TT>distgrid</TT> argument. Each PET must issue this call 
   with identical arguments in order to create a consistent Array object. 
   The only exception is the <TT>farray</TT> argument which will be different 
   on each PET. The local arrays provided must be dimensioned according to 
   the DE-local total region. Bounds of the exclusive regions are set as 
   specified in the <TT>distgrid</TT> argument. Bounds for Array dimensions 
   that are not distributed can be chosen freely using the 
   <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of farray. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of <TT>farray</TT> will be 
   used to set <TT>Array</TT>'s properties accordingly. The shape of 
   <TT>farray</TT> will be checked against the information contained in the 
   <TT>distgrid</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node9.html#const:indexflag">54.27</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region. 
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will) 
   be different on each PET. 
   The <TT>haloSeqIndexList</TT> argument is of integer type, but can be of 
   different kind in order to support both 32-bit (<TT>ESMF_KIND_I4</TT>) 
   and 64-bit (<TT>ESMF_KIND_I8</TT>) indexing. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farray</TT> directly or will copy the data from 
   <TT>farray</TT> into a new memory allocation. For valid values see 
   <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   Note that the <TT>ESMF_DATACOPY_REFERENCE</TT> option may not be safe 
   when providing an array slice in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farray</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farray</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farray</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the exclusive region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the exclusive region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the <TT>farray</TT> argument. 
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed. 
   By default lbound is 1. 
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed. 
   By default ubound is equal to the extent of the corresponding 
   dimension in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05055900000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_ArrayCreate - Create Array object from a list of LocalArray objects</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateLocalArray(distgrid, localarrayList, &amp;
     indexflag, datacopyflag, distgridToArrayMap, computationalEdgeLWidth, &amp;
     computationalEdgeUWidth, computationalLWidth, computationalUWidth, &amp;
     totalLWidth, totalUWidth, undistLBound, undistUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateLocalArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_LocalArray), intent(in) :: localarrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        type(ESMF_DataCopy_Flag),intent(in), optional :: datacopyflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing <TT>ESMF_LocalArray</TT>
   objects. The decomposition and distribution is
   specified by the <TT>distgrid</TT> argument. Each PET must issue this call
   with identical arguments in order to create a consistent Array object.
   The only exception is the <TT>localarrayList</TT> argument which will be
   different on each PET. The local arrays provided must be dimensioned
   according to the DE-local total region. Bounds of the exclusive regions
   are set as specified in the <TT>distgrid</TT> argument. Bounds for Array
   dimensions that are not distributed can be chosen freely using the
   <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments.

<P>
This interface is able to handle multiple DEs per PET.

<P>
The not distributed Array dimensions form a tensor of rank = array.rank -
   distgrid.dimCount. The widths of the computational region are set to
   the provided value, or zero by default, for all tensor elements. Use
   <TT>ESMF_ArraySet()</TT> to change these default settings after the
   Array object has been created.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>localarrayList</STRONG></DT>
<DD>List of valid <TT>ESMF_LocalArray</TT> objects, i.e. memory must be
   associated with the actual arguments. The type/kind/rank information of
   all <TT>localarrayList</TT> elements must be identical and will
   be used to set <TT>Array</TT>'s properties accordingly. The shape of each
   <TT>localarrayList</TT> element will be checked against the information
   contained in the <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node9.html#const:indexflag">54.27</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation
   of the arrays provided in <TT>localarrayList</TT> directly, or will copy
   the actual data into new memory allocations. For valid values see
   <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the <TT>localarrayList</TT> elements
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the <TT>localarrayList</TT> elements in sequence, i.e.
   <TT>distgridToArrayMap = (/1, 2, .../)</TT>.
   Unmapped dimensions in the <TT>localarrayList</TT> elements are not
   decomposed dimensions and form a tensor of
   rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region exactly.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is a vector that contains the remaining number of elements
   in each direction as to fit the union of exclusive and computational
   region into the memory region provided by the <TT>localarrayList</TT> argument.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   By default lbound is 1.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   By default ubound is equal to the extent of the corresponding
   dimension in <TT>localarrayList</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_ArrayCreate - Create Array object from a list of LocalArray objects w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateLocalArrayArb&lt;indexkind&gt;(distgrid, localarrayList, &amp;
   haloSeqIndexList, indexflag, datacopyflag, &amp;
   distgridToArrayMap, computationalEdgeLWidth, computationalEdgeUWidth, &amp;
   computationalLWidth, computationalUWidth, &amp;
   totalLWidth, totalUWidth, undistLBound, undistUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateLocalArrayArb
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid
   type(ESMF_LocalArray), intent(in) :: localarrayList(:)
   integer(ESMF_KIND_&lt;indexkind&gt;), intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Index_Flag), intent(in), optional :: indexflag
   type(ESMF_DataCopy_Flag),intent(in), optional :: datacopyflag
   integer, intent(in), optional :: distgridToArrayMap(:)
   integer, intent(in), optional :: computationalEdgeLWidth(:)
   integer, intent(in), optional :: computationalEdgeUWidth(:)
   integer, intent(in), optional :: computationalLWidth(:)
   integer, intent(in), optional :: computationalUWidth(:)
   integer, intent(in), optional :: totalLWidth(:)
   integer, intent(in), optional :: totalUWidth(:)
   integer, intent(in), optional :: undistLBound(:)
   integer, intent(in), optional :: undistUBound(:)
   character (len=*), intent(in), optional :: name
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added arguments <TT>indexflag</TT>, <TT>computationalEdgeLWidth</TT>,
   <TT>computationalEdgeUWidth</TT>, <TT>computationalLWidth</TT>,
   <TT>computationalUWidth</TT>, <TT>totalLWidth</TT>, <TT>totalUWidth</TT>. These
   arguments were missed in previous versions by mistake.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing <TT>ESMF_LocalArray</TT>
   objects according to distgrid. Each PET must issue this call in unison
   in order to create a consistent Array object. The local arrays provided must
   be dimensioned according to the DE-local total region. Bounds of the
   exclusive regions are set as specified in the distgrid argument. Bounds
   for array dimensions that are not distributed can be chosen freely using
   the <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>localarrayList</STRONG></DT>
<DD>List of valid <TT>ESMF_LocalArray</TT> objects, i.e. memory must be
   associated with the actual arguments. The type/kind/rank information of
   all <TT>localarrayList</TT> elements must be identical and will
   be used to set <TT>Array</TT>'s properties accordingly. The shape of each
   <TT>localarrayList</TT> element will be checked against the information
   contained in the <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region.
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will)
   be different on each PET.
   The <TT>haloSeqIndexList</TT> argument is of integer type, but can be of
   different kind in order to support both 32-bit (<TT>ESMF_KIND_I4</TT>)
   and 64-bit (<TT>ESMF_KIND_I8</TT>) indexing.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node9.html#const:indexflag">54.27</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation
   of the arrays provided in <TT>localarrayList</TT> directly, or will copy
   the actual data into new memory allocations. For valid values see
   <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the <TT>localarrayList</TT> elements
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the <TT>localarrayList</TT> elements in sequence, i.e.
   <TT>distgridToArrayMap = (/1, 2, .../)</TT>.
   Unmapped dimensions in the <TT>localarrayList</TT> elements are not
   decomposed dimensions and form a tensor of
   rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region exactly.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is a vector that contains the remaining number of elements
   in each direction as to fit the union of exclusive and computational
   region into the memory region provided by the <TT>localarrayList</TT> argument.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   By default lbound is 1.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   By default ubound is equal to the extent of the corresponding
   dimension in <TT>localarrayList</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551100000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_ArrayCreate - Create Array object from typekind (allocate memory)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocate(distgrid, typekind, &amp;
     indexflag, pinflag, distgridToArrayMap, computationalEdgeLWidth, &amp;
     computationalEdgeUWidth, computationalLWidth, computationalUWidth, &amp;
     totalLWidth, totalUWidth, undistLBound, undistUBound, name, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateAllocate
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        type(ESMF_Pin_Flag), intent(in), optional :: pinflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        type(ESMF_VM), intent(in), optional :: vm
        integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.3.0r</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
   different VM than that of the current context.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to typekind and distgrid. The Array rank is indirectly determined
   by the incoming information. Each PET must issue this call in unison in order
   to create a consistent Array object. DE-local allocations are made according
   to the total region defined by the <TT>distgrid</TT> and the optional <TT>Width</TT>
   arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Array. See section <A HREF="node9.html#const:typekind">54.59</A>
   for a list of valid typekind options.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node9.html#const:indexflag">54.27</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. <TT>distgridToArrayMap =
   (/1, 2, .../)</TT>.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Array object is created on the specified
   <TT>ESMF_VM</TT> object. The default is to create on the VM of the
   current context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551200000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_ArrayCreate - Create Array object from typekind (allocate memory) w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateArb&lt;indexkind&gt;(distgrid, typekind, &amp;
   haloSeqIndexList, pinflag, distgridToArrayMap, &amp;
   undistLBound, undistUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateAllocateArb
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid
   type(ESMF_TypeKind_Flag), intent(in) :: typekind
   integer(ESMF_KIND_&lt;indexkind&gt;), intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Pin_Flag), intent(in), optional :: pinflag
   integer, intent(in), optional :: distgridToArrayMap(:)
   integer, intent(in), optional :: undistLBound(:)
   integer, intent(in), optional :: undistUBound(:)
   character (len=*), intent(in), optional :: name
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to typekind and distgrid. The Array rank is indirectly determined
   by the incoming information. Each PET must issue this call in unison in order
   to create a consistent Array object. DE-local allocations are made according
   to the total region defined by the <TT>distgrid</TT> and <TT>haloSeqIndexList</TT>
   arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Array. See section <A HREF="node9.html#const:typekind">54.59</A>
   for a list of valid typekind options.
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region.
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will)
   be different on each PET.
   The <TT>haloSeqIndexList</TT> argument is of integer type, but can be of
   different kind in order to support both 32-bit (<TT>ESMF_KIND_I4</TT>)
   and 64-bit (<TT>ESMF_KIND_I8</TT>) indexing.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. <TT>distgridToArrayMap =
   (/1, 2, .../)</TT>.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551300000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_ArrayCreate - Create Array object from ArraySpec (allocate memory)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateAS(distgrid, arrayspec, &amp;
     indexflag, pinflag, distgridToArrayMap, computationalEdgeLWidth, &amp;
     computationalEdgeUWidth, computationalLWidth, computationalUWidth, &amp;
     totalLWidth, totalUWidth, undistLBound, undistUBound, name, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateAllocateAS
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        type(ESMF_Pin_Flag), intent(in), optional :: pinflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        type(ESMF_VM), intent(in), optional :: vm
        integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.3.0r</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
   different VM than that of the current context.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to arrayspec and distgrid. Each PET must issue
   this call with identical arguments in order to create a consistent Array
   object. DE-local allocations are made according to the total region defined
   by the arguments to this call: <TT>distgrid</TT> and the optional <TT>Width</TT>
   arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node9.html#const:indexflag">54.27</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. <TT>distgridToArrayMap =
   (/1, 2, .../)</TT>.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Array object is created on the specified
   <TT>ESMF_VM</TT> object. The default is to create on the VM of the
   current context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551400000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_ArrayCreate - Create Array object from ArraySpec (allocate memory) w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateASArb&lt;indexkind&gt;(distgrid, arrayspec, &amp;
   haloSeqIndexList, pinflag, distgridToArrayMap, &amp;
   undistLBound, undistUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateAllocateASArb
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid
   type(ESMF_ArraySpec), intent(in) :: arrayspec
   integer(ESMF_KIND_&lt;indexkind&gt;), intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Pin_Flag), intent(in), optional :: pinflag
   integer, intent(in), optional :: distgridToArrayMap(:)
   integer, intent(in), optional :: undistLBound(:)
   integer, intent(in), optional :: undistUBound(:)
   character (len=*), intent(in), optional :: name
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>pinflag</TT> to provide access to DE sharing
   between PETs.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to arrayspec and distgrid. Each PET must issue this call in unison
   in order to create a consistent Array object. DE-local allocations are made
   according to the total region defined by the arguments to this call:
   <TT>distgrid</TT> and <TT>haloSeqIndexList</TT> arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information.
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region.
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will)
   be different on each PET.
   The <TT>haloSeqIndexList</TT> argument is of integer type, but can be of
   different kind in order to support both 32-bit (<TT>ESMF_KIND_I4</TT>)
   and 64-bit (<TT>ESMF_KIND_I8</TT>) indexing.
   
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Specify which type of resource DEs are pinned to. See section
   <A HREF="node6.html#const:pin_flag">50.2.1</A> for a list of valid pinning options.
   The default is to pin DEs to PETs, i.e. only the PET on which a DE
   was created considers the DE as local.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. <TT>distgridToArrayMap =
   (/1, 2, .../)</TT>.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551500000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_ArrayCreate - Create Array object as copy of existing Array object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateCopy(array, datacopyflag, delayout, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
        type(ESMF_DELayout), intent(in), optional :: delayout
        integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>datacopyflag</TT> to select between different
   copy options.
<BR>
Added argument <TT>delayout</TT> to create Array with different localDe -&gt; DE
   mapping. This is identical to a change in DE -&gt; PET mapping.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object as the copy of an existing Array.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object to be copied.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the created Array object references the memory
   allocation provided by <TT>array</TT> directly or copies the data from
   <TT>array</TT> into a new memory allocation. For valid values see
   <A HREF="node9.html#const:datacopyflag">54.12</A>. The default is <TT>ESMF_DATACOPY_VALUE</TT>.
   
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>If present, override the DELayout of the incoming <TT>distgrid</TT>.
   By default use the DELayout defined in <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551600000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_ArrayDestroy - Release resources associated with an Array object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayDestroy(array, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(inout) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical, intent(in), optional :: noGarbage
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
   The argument provides a mechanism to override the default garbage collection
   mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_Array</TT>, releasing the resources associated with
   the object.

<P>
By default a small remnant of the object is kept in memory in order to
   prevent problems with dangling aliases. The default garbage collection
   mechanism can be overridden with the <TT>noGarbage</TT> argument.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
   from the ESMF garbage collection system. Note however that under this
   condition ESMF cannot protect against accessing the destroyed object
   through dangling aliases - a situation which may lead to hard to debug
   application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
   set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
   garbage collection system which will prevent problems with dangling
   aliases or incorrect sequences of destroy calls. However this level of
   support requires that a small remnant of the object is kept in memory
   past the destroy call. This can lead to an unexpected increase in memory
   consumption over the course of execution in applications that use
   temporary ESMF objects. For situations where the repeated creation and
   destruction of temporary objects leads to memory issues, it is
   recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
   removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050551700000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_ArrayGather - Gather a Fortran array from an ESMF_Array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayGather(array, farray, rootPet, tile, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array 
   &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(out), target :: farray(&lt;rank&gt;) 
   integer, intent(in) :: rootPet 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: tile 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gather the data of an ESMF_Array object into the <TT>farray</TT> located on 
   <TT>rootPET</TT>. A single DistGrid tile of <TT>array</TT> must be 
   gathered into <TT>farray</TT>. The optional <TT>tile</TT> 
   argument allows selection of the tile. For Arrays defined on a single 
   tile DistGrid the default selection (tile 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the tile in Array. 

<P>
If the Array contains replicating DistGrid dimensions data will be 
   gathered from the numerically higher DEs. Replicated data elements in 
   numerically lower DEs will be ignored. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object from which data will be gathered. 
   
</DD>
<DT><STRONG>{farray}</STRONG></DT>
<DD>The Fortran array into which to gather data. Only root 
   must provide a valid <TT>farray</TT>, the other PETs may treat 
   <TT>farray</TT> as an optional argument. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid destination array, i.e. <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The DistGrid tile in <TT>array</TT> from which to gather <TT>farray</TT>. 
   By default <TT>farray</TT> will be gathered from tile 1. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050551800000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_ArrayGet - Get object-wide Array information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetDefault(array, arrayspec, typekind, &amp;
     rank, localarrayList, indexflag, distgridToArrayMap, &amp;
     distgridToPackedArrayMap, arrayToDistGridMap, undistLBound, &amp;
     undistUBound, exclusiveLBound, exclusiveUBound, computationalLBound, &amp;
     computationalUBound, totalLBound, totalUBound, computationalLWidth, &amp;
     computationalUWidth, totalLWidth, totalUWidth, distgrid, dimCount, &amp;
     tileCount, minIndexPTile, maxIndexPTile, deToTileMap, indexCountPDe, &amp;
     delayout, deCount, localDeCount, ssiLocalDeCount, localDeToDeMap, &amp;
     localDeList, &amp; ! DEPRECATED ARGUMENT
     isESMFAllocated, name, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ArraySpec), intent(out), optional :: arrayspec
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer, intent(out), optional :: rank
     type(ESMF_LocalArray), target, intent(out), optional :: localarrayList(:)
     type(ESMF_Index_Flag), intent(out), optional :: indexflag
     integer, target, intent(out), optional :: distgridToArrayMap(:)
     integer, target, intent(out), optional :: distgridToPackedArrayMap(:)
     integer, target, intent(out), optional :: arrayToDistGridMap(:)
     integer, target, intent(out), optional :: undistLBound(:)
     integer, target, intent(out), optional :: undistUBound(:)
     integer, target, intent(out), optional :: exclusiveLBound(:,:)
     integer, target, intent(out), optional :: exclusiveUBound(:,:)
     integer, target, intent(out), optional :: computationalLBound(:,:)
     integer, target, intent(out), optional :: computationalUBound(:,:)
     integer, target, intent(out), optional :: totalLBound(:,:)
     integer, target, intent(out), optional :: totalUBound(:,:)
     integer, target, intent(out), optional :: computationalLWidth(:,:)
     integer, target, intent(out), optional :: computationalUWidth(:,:)
     integer, target, intent(out), optional :: totalLWidth(:,:)
     integer, target, intent(out), optional :: totalUWidth(:,:)
     type(ESMF_DistGrid), intent(out), optional :: distgrid
     integer, intent(out), optional :: dimCount
     integer, intent(out), optional :: tileCount
     integer, intent(out), optional :: minIndexPTile(:,:)
     integer, intent(out), optional :: maxIndexPTile(:,:)
     integer, intent(out), optional :: deToTileMap(:)
     integer, intent(out), optional :: indexCountPDe(:,:)
     type(ESMF_DELayout), intent(out), optional :: delayout
     integer, intent(out), optional :: deCount
     integer, intent(out), optional :: localDeCount
     integer, intent(out), optional :: ssiLocalDeCount
     integer, intent(out), optional :: localDeToDeMap(:)
     integer, intent(out), optional :: localDeList(:) ! DEPRECATED ARGUMENT
     logical, intent(out), optional :: isESMFAllocated
     character(len=*), intent(out), optional :: name
     type(ESMF_VM), intent(out), optional :: vm
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.2.0rp1</STRONG></DT>
<DD>Added argument <TT>localDeToDeMap</TT>.
   Started to deprecate argument <TT>localDeList</TT>.
   The new argument name correctly uses the <TT>Map</TT> suffix and
   better describes the returned information.
   This was pointed out by user request.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>ssiLocalDeCount</TT> to support DE sharing
   between PETs on the same single system image (SSI).
<BR>
Added argument <TT>vm</TT> in order to offer information about the
   VM on which the Array was created.
   
</DD>
<DT><STRONG>8.5.0</STRONG></DT>
<DD>Added argument <TT>isESMFAllocated</TT> to support user query of
   whether ESMF or user is responsible for the data allocation
   referenced by this object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get internal information.

<P>
This interface works for any number of DEs per PET.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[arrayspec]</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information
   of the Array object.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind of the Array object.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Rank of the Array object.
   
</DD>
<DT><STRONG>[localarrayList]</STRONG></DT>
<DD>Upon return this holds a list of the associated <TT>ESMC_LocalArray</TT>
   objects. <TT>localarrayList</TT> must be allocated to be of size
   <TT>localDeCount</TT> or <TT>ssiLocalDeCount</TT>.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Upon return this flag indicates how the DE-local indices are defined.
   See section <A HREF="node9.html#const:indexflag">54.27</A> for a list of possible return values.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>Upon return this list holds the Array dimensions against which the
   DistGrid dimensions are mapped. <TT>distgridToArrayMap</TT> must be allocated
   to be of size <TT>dimCount</TT>. An entry of zero indicates that the
   respective DistGrid dimension is replicating the Array across the DEs
   along this direction.
   
</DD>
<DT><STRONG>[distgridToPackedArrayMap]</STRONG></DT>
<DD>Upon return this list holds the indices of the Array dimensions in packed
   format against which the DistGrid dimensions are mapped.
   <TT>distgridToPackedArrayMap</TT> must be allocated to be of size
   <TT>dimCount</TT>. An entry of zero indicates that the respective DistGrid
   dimension is replicating the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[arrayToDistGridMap]</STRONG></DT>
<DD>Upon return this list holds the DistGrid dimensions against which the
   Array dimensions are mapped. <TT>arrayToDistGridMap</TT> must be allocated
   to be of size <TT>rank</TT>. An entry of zero indicates that the respective
   Array dimension is not decomposed, rendering it a tensor dimension.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Upon return this array holds the lower bounds of the undistributed
   dimensions of the Array. <TT>UndistLBound</TT> must be allocated to be
   of size <TT>rank-dimCount</TT>.

</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upon return this array holds the upper bounds of the undistributed
   dimensions of the Array. <TT>UndistUBound</TT> must be allocated to be
   of size <TT>rank-dimCount</TT>.

</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive regions for
   all PET-local DEs. <TT>exclusiveLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.

</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive regions for
   all PET-local DEs. <TT>exclusiveUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.

</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational regions for
   all PET-local DEs. <TT>computationalLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational regions for
   all PET-local DEs. <TT>computationalUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total regions for
   all PET-local DEs. <TT>totalLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total regions for
   all PET-local DEs. <TT>totalUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>Upon return this holds the lower width of the computational regions for
   all PET-local DEs. <TT>computationalLWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>Upon return this holds the upper width of the computational regions for
   all PET-local DEs. <TT>computationalUWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Upon return this holds the lower width of the total memory regions for
   all PET-local DEs. <TT>totalLWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.

</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upon return this holds the upper width of the total memory regions for
   all PET-local DEs. <TT>totalUWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT> or
   <TT>(dimCount, ssiLocalDeCount)</TT>.

</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>Upon return this holds the associated <TT>ESMF_DistGrid</TT> object.
   
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of dimensions (rank) of <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[tileCount]</STRONG></DT>
<DD>Number of tiles in <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[minIndexPTile]</STRONG></DT>
<DD>Lower index space corner per <TT>dim</TT>, per <TT>tile</TT>, with
   <TT>size(minIndexPTile) == (/dimCount, tileCount/)</TT>.
   
</DD>
<DT><STRONG>[maxIndexPTile]</STRONG></DT>
<DD>Upper index space corner per <TT>dim</TT>, per <TT>tile</TT>, with
   <TT>size(maxIndexPTile) == (/dimCount, tileCount/)</TT>.
   
</DD>
<DT><STRONG>[deToTileMap]</STRONG></DT>
<DD>List of tile id numbers, one for each DE, with
   <TT>size(deToTileMap) == (/deCount/)</TT>
   
</DD>
<DT><STRONG>[indexCountPDe]</STRONG></DT>
<DD>Array of extents per <TT>dim</TT>, per <TT>de</TT>, with
   <TT>size(indexCountPDe) == (/dimCount, deCount/)</TT>.

</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>The associated <TT>ESMF_DELayout</TT> object.
   
</DD>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>The total number of DEs in the Array.
   
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>The number of DEs in the Array associated with the local PET.
   
</DD>
<DT><STRONG>[ssiLocalDeCount]</STRONG></DT>
<DD>The number of DEs in the Array available to the local PET. This
   includes DEs that are local to other PETs on the same SSI, that are
   accessible via shared memory.
   
</DD>
<DT><STRONG>[localDeToDeMap]</STRONG></DT>
<DD>Mapping between localDe indices and the (global) DEs associated with
   the local PET. The localDe index variables are discussed in sections
   <A HREF="node6.html#DELayout_general_mapping">50.3.7</A> and <A HREF="#Array_native_language_localde">28.2.5</A>.
   The provided actual argument must be of size <TT>localDeCount</TT>, or
   <TT>ssiLocalDeCount</TT>, and will be filled accordingly.
   
</DD>
<DT><STRONG>[localDeList]</STRONG></DT>
<DD><B>DEPRECATED ARGUMENT!</B> Please use the argument <TT>localDeToDeMap</TT> instead.
   
</DD>
<DT><STRONG>[isESMFAllocated]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for data allocations held by ESMF. Set to
   <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[vm</STRONG></DT>
<DD>The VM on which the Array object was created.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551900000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_ArrayGet - Get DE-local Array information for a specific dimension</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetPLocalDePDim(array, dim, localDe, &amp;
     indexCount, indexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
     integer, intent(in) :: dim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: localDe
     integer, intent(out), optional :: indexCount
     integer, intent(out), optional :: indexList(:)
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get internal information per local DE, per dim.

<P>
This interface works for any number of DEs per PET.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension for which information is requested. <TT>[1,..,dimCount]</TT>
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[indexCount]</STRONG></DT>
<DD>DistGrid indexCount associated with <TT>localDe, dim</TT>.
   
</DD>
<DT><STRONG>[indexList]</STRONG></DT>
<DD>List of DistGrid tile-local indices for <TT>localDe</TT> along dimension
   <TT>dim</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_ArrayGet - Get a DE-local Fortran array pointer from an Array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet() 
   subroutine ESMF_ArrayGetFPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(array, localDe, &amp; 
   farrayPtr, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: localDe 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access Fortran array pointer to the specified DE-local memory allocation of 
   the Array object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object. 
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>. 
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted, 
   in which case it will default to <TT>localDe=0</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Upon return, <TT>farrayPtr</TT> points to the DE-local data allocation of 
   <TT>localDe</TT> in <TT>array</TT>. It depends on the specific entry point 
   of <TT>ESMF_ArrayCreate()</TT> used during <TT>array</TT> creation, which 
   Fortran operations are supported on the returned <TT>farrayPtr</TT>. See 
   <A HREF="#Array:rest">28.3</A> for more details. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050552100000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_ArrayGet - Get a DE-local LocalArray object from an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetLocalArray(array, localDe, localarray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: localDe
     type(ESMF_LocalArray), intent(inout) :: localarray
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Provide access to <TT>ESMF_LocalArray</TT> object that holds data for
   the specified local DE.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>localarray</STRONG></DT>
<DD>Upon return <TT>localarray</TT> refers to the DE-local data allocation of
   <TT>array</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050552200000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_ArrayHalo - Execute an Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayHalo(array, routehandle, &amp;
     routesyncflag, finishedflag, cancelledflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),          intent(inout)         :: array
     type(ESMF_RouteHandle),    intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag), intent(in),  optional :: routesyncflag
     logical,                   intent(out), optional :: finishedflag
     logical,                   intent(out), optional :: cancelledflag
     logical,                   intent(in),  optional :: checkflag
     integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array halo operation for <TT>array</TT>.
     The <TT>array</TT> argument must match the respective Array
     used during <TT>ESMF_ArrayHaloStore()</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
See <TT>ESMF_ArrayHaloStore()</TT> on how to precompute <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[routesyncflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_ROUTESYNC_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node9.html#const:routesync">54.51</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>, or a final call with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT>. For all other <TT>routesyncflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.

</DD>
<DT><STRONG>[cancelledflag]</STRONG></DT>
<DD>A value of <TT>.true.</TT> indicates that were cancelled communication
       operations. In this case the data in the <TT>dstArray</TT> must be considered
       invalid. It may have been partially modified by the call. A value of
       <TT>.false.</TT> indicates that none of the communication operations was
       cancelled. The data in <TT>dstArray</TT> is valid if <TT>finishedflag</TT> 
       returns equal <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552300000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_ArrayHaloRelease - Release resources associated with Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayHaloRelease(routehandle, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: noGarbage
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with an Array halo operation. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552400000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_ArrayHaloStore - Precompute an Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayHaloStore(array, routehandle, &amp;
       startregion, haloLDepth, haloUDepth, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),            intent(inout)           :: array
     type(ESMF_RouteHandle),      intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_StartRegion_Flag), intent(in),    optional :: startregion
     integer,                     intent(in),    optional :: haloLDepth(:)
     integer,                     intent(in),    optional :: haloUDepth(:)
     integer,                     intent(inout), optional :: pipelineDepth
     integer,                     intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>pipelineDepth</TT>.
                The new argument provide access to the tuning parameter
                affecting the sparse matrix execution.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Store an Array halo operation over the data in <TT>array</TT>. By default,
     i.e. without specifying <TT>startregion</TT>, <TT>haloLDepth</TT> and
     <TT>haloUDepth</TT>, all elements in the total Array region that lie outside
     the exclusive region will be considered potential destination elements for
     halo. However, only those elements that have a corresponding halo source
     element, i.e. an exclusive element on one of the DEs, will be updated under
     the halo operation. Elements that have no associated source remain 
     unchanged under halo.

<P>
Specifying <TT>startregion</TT> allows the shape of the effective halo region 
     to be changed from the inside. Setting this flag to
     <TT>ESMF_STARTREGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region of the Array are considered for potential
     destination elements for the halo operation. The default is 
     <TT>ESMF_STARTREGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>startregion</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total Array region, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Array region is
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for the halo operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayHalo()</TT> on any Array that matches 
     <TT>array</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> containing data to be haloed. The data in the halo
       region may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[startregion]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elements.
       See section <A HREF="node9.html#const:startregion">54.54</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>startregion</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>startregion</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a halo exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552500000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_ArrayIsCreated - Check whether an Array object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_ArrayIsCreated(array, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_ArrayIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>array</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552600000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_ArrayPrint - Print Array information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayPrint(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMF_Array</TT> object. 
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552700000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_ArrayRead - Read Array data from a file</A>
</H3>

<P>
<A NAME="api:ArrayRead"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayRead(array, fileName, variableName, &amp;
     timeslice, iofmt, rc)
     ! We need to terminate the strings on the way to C++
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),      intent(inout)         :: array
     character(*),          intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*),          intent(in),  optional :: variableName
     integer,               intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag), intent(in),  optional :: iofmt
     integer,               intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Read Array data from file and put it into an <TT>ESMF_Array</TT> object.
     For this API to be functional, the environment variable <TT>ESMF_PIO</TT>
     should be set to either "internal" or "external" when the ESMF library is built.
     Please see the section on Data I/O,&nbsp;<A HREF="#io:dataio">38.2</A>.

<P>
Limitations:
     
<UL>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object in which the read data is returned.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file from which Array data is read.
      If this is a multi-tile Array, then fileName must contain
      exactly one instance of "*"; this is a placeholder that will be replaced
      by the tile number, with each tile being read from a separate file. (For
      example, for a fileName of "myfile*.nc", tile 1 will be read from
      "myfile1.nc", tile 2 from "myfile2.nc", etc.)
      (This handling of the fileName for multi-tile I/O is subject to change.)
     
</DD>
<DT><STRONG>[variableName]</STRONG></DT>
<DD>Variable name in the file; default is the "name" of Array.
      Use this argument only in the I/O format (such as NetCDF) that
      supports variable name. If the I/O format does not support this
      (such as binary format), ESMF will return an error code.
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>The time-slice number of the variable read from file.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Please see Section&nbsp;<A HREF="node9.html#opt:iofmtflag">54.28</A> for the list
      of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552800000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_ArrayRedist - Execute an Array redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayRedist(srcArray, dstArray, routehandle, &amp;
     routesyncflag, finishedflag, cancelledflag, zeroregion, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),          intent(in),    optional :: srcArray
     type(ESMF_Array),          intent(inout), optional :: dstArray
     type(ESMF_RouteHandle),    intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag), intent(in),    optional :: routesyncflag
     logical,                   intent(out),   optional :: finishedflag
     logical,                   intent(out),   optional :: cancelledflag
     type(ESMF_Region_Flag),    intent(in),    optional :: zeroregion
     logical,                   intent(in),    optional :: checkflag
     integer,                   intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>zeroregion</TT> to allow user to control
                how the destination array is zero'ed out. This is especially
                useful in cases where the source and destination arrays do not
                cover the identical index space.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array redistribution from <TT>srcArray</TT>
     to <TT>dstArray</TT>.
     Both <TT>srcArray</TT> and <TT>dstArray</TT> must match the respective Arrays
     used during <TT>ESMF_ArrayRedisttore()</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
The <TT>srcArray</TT> and <TT>dstArray</TT> arguments are optional in support of
     the situation where <TT>srcArray</TT> and/or <TT>dstArray</TT> are not defined on
     all PETs. The <TT>srcArray</TT> and <TT>dstArray</TT> must be specified on those
     PETs that hold source or destination DEs, respectively, but may be omitted
     on all other PETs. PETs that hold neither source nor destination DEs may
     omit both arguments.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
See <TT>ESMF_ArrayRedistStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>[dstArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[routesyncflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_ROUTESYNC_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node9.html#const:routesync">54.51</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>, or a final call with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT>. For all other <TT>routesyncflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.

</DD>
<DT><STRONG>[cancelledflag]</STRONG></DT>
<DD>A value of <TT>.true.</TT> indicates that were cancelled communication
       operations. In this case the data in the <TT>dstArray</TT> must be considered
       invalid. It may have been partially modified by the call. A value of
       <TT>.false.</TT> indicates that none of the communication operations was
       cancelled. The data in <TT>dstArray</TT> is valid if <TT>finishedflag</TT> 
       returns equal <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> the total regions of
       all DEs in <TT>dstArray</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstArray</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section <A HREF="node9.html#const:region">54.48</A> for a complete list of
       valid settings. The default is <TT>ESMF_REGION_SELECT</TT>.

</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552900000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_ArrayRedistRelease - Release resources associated with Array redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayRedistRelease(routehandle, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: noGarbage
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with an Array redistribution. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_ArrayRedistStore - Precompute Array redistribution with local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayRedistStore()
   subroutine ESMF_ArrayRedistStore&lt;type&gt;&lt;kind&gt;(srcArray, dstArray, &amp;
     routehandle, factor, srcToDstTransposeMap, &amp;
     ignoreUnmatchedIndices, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(in)              :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;),intent(in)             :: factor
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),    optional :: srcToDstTransposeMap(:)
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: pipelineDepth
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>pipelineDepth</TT>.
                The new argument provide access to the tuning parameter
                affecting the sparse matrix execution.
   
</DD>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>transposeRoutehandle</TT> to allow a handle to
                the transposed redist operation to be returned.
<BR>
Added argument <TT>ignoreUnmatchedIndices</TT> to support situations 
                where not all elements between source and destination Arrays 
                match.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Removed argument <TT>transposeRoutehandle</TT> and provide it
                via interface overloading instead. This allows argument 
                <TT>srcArray</TT> to stay strictly intent(in) for this entry point.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ArrayRedistStoreTK"></A>   <TT>ESMF_ArrayRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArrayRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArrayRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#ArrayRedistStoreTK">28.5.30</A> and
   <A HREF="#ArrayRedistStoreNF">28.5.32</A>, is described in the following paragraphs as a whole.

<P>
Store an Array redistribution operation from <TT>srcArray</TT> to <TT>dstArray</TT>.
   Interface <A HREF="#ArrayRedistStoreTK">28.5.30</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="#ArrayRedistStoreNF">28.5.32</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Array, destination Array, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Arrays may differ in shape,
   however, the number of elements must match. 

<P>
The default redistribution operation, when <TT>srcToDstTransposeMap</TT> is not
   specified, corresponds to the identity mapping: each element of the
   sequentialized source Array is copied to the sequentialized
   destination Array element in order.

<P>
If the <TT>srcToDstTransposeMap</TT> argument is provided it must be identical
   across all PETs. The <TT>srcToDstTransposeMap</TT> allows source and destination
   Array dimensions to be transposed during the redistribution. To support this
   option, the number of source and destination Array dimensions must be equal
   and the size of the associated dimensions must match.
   See section <A HREF="#Array:Redist:TransposeMode">28.2.17</A> for more details about the
   use of the <TT>srcToDstTransposeMap</TT> argument.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
   <TT>dstArray</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayRedist()</TT> on any pair of Arrays that matches 
     <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multiply source data.

<P>
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>A list with as many entries as there are dimensions in <TT>srcArray</TT>, or
       <TT>tileCount</TT> times this many entries.
       Each entry maps the corresponding <TT>srcArray</TT> dimension against the
       specified <TT>dstArray</TT> dimension. Mixing distributed and
       undistributed dimensions is supported.
       Negative entries reverse the order of elements along the specified
       dimension when going from source to destination.
       When providing <!-- MATH
 $rank \times tileCount$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$rank \times tileCount$"></SPAN> elements in
       <TT>srcToDstTransposeMap</TT>,  each block of size <TT>rank</TT> is associated
       with the corresponding tile (in order), and interpreted as the
       tile-specific transpose map.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when not all elements match
       between the <TT>srcArray</TT> and <TT>dstArray</TT> side. The default setting
       is <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       unmatched indices.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a redist exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553100000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_ArrayRedistStore - Precompute Array redistribution and transpose with local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayRedistStore()
   subroutine ESMF_ArrayRedistStore&lt;type&gt;&lt;kind&gt;TP(srcArray, dstArray, &amp;
     routehandle, transposeRoutehandle, factor, &amp;
     srcToDstTransposeMap, ignoreUnmatchedIndices, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(inout)           :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_RouteHandle), intent(inout)           :: transposeRoutehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;),intent(in)             :: factor
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),    optional :: srcToDstTransposeMap(:)
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: pipelineDepth
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ArrayRedistStoreTKTP"></A>   <TT>ESMF_ArrayRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArrayRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArrayRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#ArrayRedistStoreTKTP">28.5.31</A> and
   <A HREF="#ArrayRedistStoreNFTP">28.5.33</A>, is described in the following paragraphs as a whole.

<P>
Store an Array redistribution operation from <TT>srcArray</TT> to <TT>dstArray</TT>.
   Interface <A HREF="#ArrayRedistStoreTKTP">28.5.31</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="#ArrayRedistStoreNFTP">28.5.33</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Array, destination Array, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Arrays may differ in shape,
   however, the number of elements must match. 

<P>
The default redistribution operation, when <TT>srcToDstTransposeMap</TT> is not
   specified, corresponds to the identity mapping: each element of the
   sequentialized source Array is copied to the sequentialized
   destination Array element in order.

<P>
If the <TT>srcToDstTransposeMap</TT> argument is provided it must be identical
   across all PETs. The <TT>srcToDstTransposeMap</TT> allows source and destination
   Array dimensions to be transposed during the redistribution. To support this
   option, the number of source and destination Array dimensions must be equal
   and the size of the associated dimensions must match.
   See section <A HREF="#Array:Redist:TransposeMode">28.2.17</A> for more details about the
   use of the <TT>srcToDstTransposeMap</TT> argument.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
   <TT>dstArray</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayRedist()</TT> on any pair of Arrays that matches 
     <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>transposeRoutehandle</STRONG></DT>
<DD>Handle to the transposed matrix operation. The transposed operation goes
       from <TT>dstArray</TT> to <TT>srcArray</TT>.

<P>
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multiply source data.

<P>
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>A list with as many entries as there are dimensions in <TT>srcArray</TT>, or
       <TT>tileCount</TT> times this many entries.
       Each entry maps the corresponding <TT>srcArray</TT> dimension against the
       specified <TT>dstArray</TT> dimension. Mixing distributed and
       undistributed dimensions is supported.
       Negative entries reverse the order of elements along the specified
       dimension when going from source to destination.
       When providing <!-- MATH
 $rank \times tileCount$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$rank \times tileCount$"></SPAN> elements in
       <TT>srcToDstTransposeMap</TT>,  each block of size <TT>rank</TT> is associated
       with the corresponding tile (in order), and interpreted as the
       tile-specific transpose map.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when not all elements match
       between the <TT>srcArray</TT> and <TT>dstArray</TT> side. The default setting
       is <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       unmatched indices.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a redist exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553200000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_ArrayRedistStore - Precompute Array redistribution without local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayRedistStore()
   subroutine ESMF_ArrayRedistStoreNF(srcArray, dstArray, routehandle, &amp;
     srcToDstTransposeMap, ignoreUnmatchedIndices, &amp;
     pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(in)              :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),    optional :: srcToDstTransposeMap(:)
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: pipelineDepth
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>pipelineDepth</TT>.
                The new argument provide access to the tuning parameter
                affecting the sparse matrix execution.
   
</DD>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>transposeRoutehandle</TT> to allow a handle to
                the transposed redist operation to be returned.
<BR>
Added argument <TT>ignoreUnmatchedIndices</TT> to support situations 
                where not all elements between source and destination Arrays 
                match.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Removed argument <TT>transposeRoutehandle</TT> and provide it
                via interface overloading instead. This allows argument 
                <TT>srcArray</TT> to stay strictly intent(in) for this entry point.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ArrayRedistStoreNF"></A>   <TT>ESMF_ArrayRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArrayRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArrayRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#ArrayRedistStoreTK">28.5.30</A> and
   <A HREF="#ArrayRedistStoreNF">28.5.32</A>, is described in the following paragraphs as a whole.

<P>
Store an Array redistribution operation from <TT>srcArray</TT> to <TT>dstArray</TT>.
   Interface <A HREF="#ArrayRedistStoreTK">28.5.30</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="#ArrayRedistStoreNF">28.5.32</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Array, destination Array, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Arrays may differ in shape,
   however, the number of elements must match. 

<P>
The default redistribution operation, when <TT>srcToDstTransposeMap</TT> is not
   specified, corresponds to the identity mapping: each element of the
   sequentialized source Array is copied to the sequentialized
   destination Array element in order.

<P>
If the <TT>srcToDstTransposeMap</TT> argument is provided it must be identical
   across all PETs. The <TT>srcToDstTransposeMap</TT> allows source and destination
   Array dimensions to be transposed during the redistribution. To support this
   option, the number of source and destination Array dimensions must be equal
   and the size of the associated dimensions must match.
   See section <A HREF="#Array:Redist:TransposeMode">28.2.17</A> for more details about the
   use of the <TT>srcToDstTransposeMap</TT> argument.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
   <TT>dstArray</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayRedist()</TT> on any pair of Arrays that matches 
     <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>A list with as many entries as there are dimensions in <TT>srcArray</TT>, or
       <TT>tileCount</TT> times this many entries.
       Each entry maps the corresponding <TT>srcArray</TT> dimension against the
       specified <TT>dstArray</TT> dimension. Mixing distributed and
       undistributed dimensions is supported.
       Negative entries reverse the order of elements along the specified
       dimension when going from source to destination.
       When providing <!-- MATH
 $rank \times tileCount$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$rank \times tileCount$"></SPAN> elements in
       <TT>srcToDstTransposeMap</TT>,  each block of size <TT>rank</TT> is associated
       with the corresponding tile (in order), and interpreted as the
       tile-specific transpose map.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when not all elements match
       between the <TT>srcArray</TT> and <TT>dstArray</TT> side. The default setting
       is <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       unmatched indices.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a redist exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553300000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_ArrayRedistStore - Precompute Array redistribution and transpose without local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayRedistStore()
   subroutine ESMF_ArrayRedistStoreNFTP(srcArray, dstArray, routehandle, &amp;
     transposeRoutehandle, srcToDstTransposeMap, &amp;
     ignoreUnmatchedIndices, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(inout)           :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_RouteHandle), intent(inout)           :: transposeRoutehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),    optional :: srcToDstTransposeMap(:)
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: pipelineDepth
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ArrayRedistStoreNFTP"></A>   <TT>ESMF_ArrayRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArrayRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArrayRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#ArrayRedistStoreTKTP">28.5.31</A> and
   <A HREF="#ArrayRedistStoreNFTP">28.5.33</A>, is described in the following paragraphs as a whole.

<P>
Store an Array redistribution operation from <TT>srcArray</TT> to <TT>dstArray</TT>.
   Interface <A HREF="#ArrayRedistStoreTKTP">28.5.31</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="#ArrayRedistStoreNFTP">28.5.33</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Array, destination Array, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Arrays may differ in shape,
   however, the number of elements must match. 

<P>
The default redistribution operation, when <TT>srcToDstTransposeMap</TT> is not
   specified, corresponds to the identity mapping: each element of the
   sequentialized source Array is copied to the sequentialized
   destination Array element in order.

<P>
If the <TT>srcToDstTransposeMap</TT> argument is provided it must be identical
   across all PETs. The <TT>srcToDstTransposeMap</TT> allows source and destination
   Array dimensions to be transposed during the redistribution. To support this
   option, the number of source and destination Array dimensions must be equal
   and the size of the associated dimensions must match.
   See section <A HREF="#Array:Redist:TransposeMode">28.2.17</A> for more details about the
   use of the <TT>srcToDstTransposeMap</TT> argument.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
   <TT>dstArray</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayRedist()</TT> on any pair of Arrays that matches 
     <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>transposeRoutehandle</STRONG></DT>
<DD>Handle to the transposed matrix operation. The transposed operation goes
       from <TT>dstArray</TT> to <TT>srcArray</TT>.

<P>
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>A list with as many entries as there are dimensions in <TT>srcArray</TT>, or
       <TT>tileCount</TT> times this many entries.
       Each entry maps the corresponding <TT>srcArray</TT> dimension against the
       specified <TT>dstArray</TT> dimension. Mixing distributed and
       undistributed dimensions is supported.
       Negative entries reverse the order of elements along the specified
       dimension when going from source to destination.
       When providing <!-- MATH
 $rank \times tileCount$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="126" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$rank \times tileCount$"></SPAN> elements in
       <TT>srcToDstTransposeMap</TT>,  each block of size <TT>rank</TT> is associated
       with the corresponding tile (in order), and interpreted as the
       tile-specific transpose map.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when not all elements match
       between the <TT>srcArray</TT> and <TT>dstArray</TT> side. The default setting
       is <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       unmatched indices.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a redist exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050553400000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_ArrayScatter - Scatter a Fortran array across the ESMF_Array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayScatter(array, farray, rootPet, tile, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(inout) :: array 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   integer, intent(in) :: rootPet 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: tile 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Scatter the data of <TT>farray</TT> located on <TT>rootPET</TT> 
   across an ESMF_Array object. A single <TT>farray</TT> must be 
   scattered across a single DistGrid tile in Array. The optional <TT>tile</TT> 
   argument allows selection of the tile. For Arrays defined on a single 
   tile DistGrid the default selection (tile 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the tile in Array. 

<P>
If the Array contains replicating DistGrid dimensions data will be 
   scattered across all of the replicated pieces. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object across which data will be scattered. 
   
</DD>
<DT><STRONG>{farray}</STRONG></DT>
<DD>The Fortran array that is to be scattered. Only root 
   must provide a valid <TT>farray</TT>, the other PETs may treat 
   <TT>farray</TT> as an optional argument. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid data in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The DistGrid tile in <TT>array</TT> into which to scatter <TT>farray</TT>. 
   By default <TT>farray</TT> will be scattered into tile 1. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050553500000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_ArraySet - Set object-wide Array information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySet()
   subroutine ESMF_ArraySetDefault(array, computationalLWidth, &amp;
     computationalUWidth, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),   intent(inout)         :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: computationalLWidth(:,:)
     integer,            intent(in),  optional :: computationalUWidth(:,:)
     character(len = *), intent(in),  optional :: name
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets adjustable settings in an <TT>ESMF_Array</TT> object. Arrays with
       tensor dimensions will set values for <EM>all</EM> tensor components.

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object for which to set properties.
       
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This argument must have of size <TT>(dimCount, localDeCount)</TT>.
         <TT>computationalLWidth</TT> specifies the lower corner of the
         computational region with respect to the lower corner of the exclusive
         region for all local DEs.

</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This argument must have of size <TT>(dimCount, localDeCount)</TT>.
         <TT>computationalUWidth</TT> specifies the upper corner of the
         computational region with respect to the upper corner of the exclusive
         region for all local DEs.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The Array name.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553600000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_ArraySet - Set DE-local Array information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySet()
   subroutine ESMF_ArraySetPLocalDe(array, localDe, rimSeqIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),   intent(inout)         :: array
     integer,            intent(in)            :: localDe
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: rimSeqIndex(:)
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets adjustable settings in an <TT>ESMF_Array</TT> object for a specific
       localDe.

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object for which to set properties.
       
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which to set values.
       
</DD>
<DT><STRONG>[rimSeqIndex]</STRONG></DT>
<DD>Sequence indices in the halo rim of localDe.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553700000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_ArraySMM - Execute an Array sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySMM(srcArray, dstArray, routehandle, &amp;
     routesyncflag, finishedflag, cancelledflag, zeroregion, termorderflag, &amp;
     checkflag, dynamicMask, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),               intent(in),    optional :: srcArray
     type(ESMF_Array),               intent(inout), optional :: dstArray
     type(ESMF_RouteHandle),         intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag),      intent(in),    optional :: routesyncflag
     logical,                        intent(out),   optional :: finishedflag
     logical,                        intent(out),   optional :: cancelledflag
     type(ESMF_Region_Flag),         intent(in),    optional :: zeroregion
     type(ESMF_TermOrder_Flag),      intent(in),    optional :: termorderflag
     logical,                        intent(in),    optional :: checkflag
     type(ESMF_DynamicMask), target, intent(in),    optional :: dynamicMask
     integer,                        intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>termorderflag</TT>.
                The new argument gives the user control over the order in which
                the src terms are summed up.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>dynamicMask</TT>.
                The new argument supports the dynamic masking feature.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array sparse matrix multiplication from <TT>srcArray</TT>
     to <TT>dstArray</TT>.
     Both <TT>srcArray</TT> and <TT>dstArray</TT> must match the respective Arrays
     used during <TT>ESMF_ArraySMMStore()</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size, 
     number, and index order of <EM>undistributed</EM> dimensions may be different. See section
     <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of RouteHandle 
     reusability.

<P>
The <TT>srcArray</TT> and <TT>dstArray</TT> arguments are optional in support of
     the situation where <TT>srcArray</TT> and/or <TT>dstArray</TT> are not defined on
     all PETs. The <TT>srcArray</TT> and <TT>dstArray</TT> must be specified on those
     PETs that hold source or destination DEs, respectively, but may be omitted
     on all other PETs. PETs that hold neither source nor destination DEs may
     omit both arguments.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
See <TT>ESMF_ArraySMMStore()</TT> on how to precompute 
     <TT>routehandle</TT>. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the
     operation <TT>ESMF_ArraySMM()</TT> performs.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>[dstArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[routesyncflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_ROUTESYNC_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node9.html#const:routesync">54.51</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>, or a final call with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT>. For all other <TT>routesyncflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.

</DD>
<DT><STRONG>[cancelledflag]</STRONG></DT>
<DD>A value of <TT>.true.</TT> indicates that were cancelled communication
       operations. In this case the data in the <TT>dstArray</TT> must be considered
       invalid. It may have been partially modified by the call. A value of
       <TT>.false.</TT> indicates that none of the communication operations was
       cancelled. The data in <TT>dstArray</TT> is valid if <TT>finishedflag</TT> 
       returns equal <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstArray</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstArray</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section <A HREF="node9.html#const:region">54.48</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[termorderflag]</STRONG></DT>
<DD>Specifies the order of the source side terms in all of the destination
       sums. The <TT>termorderflag</TT> only affects the order of terms during 
       the execution of the RouteHandle. See the <A HREF="#RH:bfb">37.2.1</A> section for an
       in-depth discussion of <EM>all</EM> bit-for-bit reproducibility
       aspects related to route-based communication methods.
       See <A HREF="node9.html#const:termorderflag">54.58</A> for a full list of options.
       The default setting depends on whether the <TT>dynamicMask</TT> argument
       is present or not. With <TT>dynamicMask</TT> argument present, the default
       of <TT>termorderflag</TT> is <TT>ESMF_TERMORDER_SRCSEQ</TT>. This ensures
       that <TT>all</TT> source terms are present on the destination side, and 
       the interpolation can be calculated as a single sum. When 
       <TT>dynamicMask</TT> is absent, the default of <TT>termorderflag</TT> is
       <TT>ESMF_TERMORDER_FREE</TT>, allowing maximum flexibility and partial 
       sums for optimum performance.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[dynamicMask]</STRONG></DT>
<DD>Object holding dynamic masking information.
       See section <A HREF="#RH:DynMask">37.2.6</A> for a discussion of dynamic masking.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553800000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_ArraySMMRelease - Release resources associated with Array sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySMMRelease(routehandle, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: noGarbage
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Release resources associated with an Array sparse matrix multiplication. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this 
       condition ESMF cannot protect against accessing the destroyed object 
       through dangling aliases - a situation which may lead to hard to debug 
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use 
       temporary ESMF objects. For situations where the repeated creation and 
       destruction of temporary objects leads to memory issues, it is 
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553900000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_ArraySMMStore - Precompute Array sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStore&lt;type&gt;&lt;kind&gt;(srcArray, dstArray, &amp;
     routehandle, factorList, factorIndexList, &amp;
     ignoreUnmatchedIndices, srcTermProcessing, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),          intent(in)              :: srcArray
     type(ESMF_Array),          intent(inout)           :: dstArray
     type(ESMF_RouteHandle),    intent(inout)           :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)       :: factorList(:)
     integer(ESMF_KIND_&lt;kind&gt;), intent(in)              :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                   intent(in),    optional :: ignoreUnmatchedIndices
     integer,                   intent(inout), optional :: srcTermProcessing
     integer,                   intent(inout), optional :: pipelineDepth
     integer,                   intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>srcTermProcessing</TT>.
                Added argument <TT>pipelineDepth</TT>.
                The new arguments provide access to the tuning parameters
                affecting the sparse matrix execution.
   
</DD>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>transposeRoutehandle</TT> to allow a handle to
                the transposed matrix operation to be returned.
<BR>
Added argument <TT>ignoreUnmatchedIndices</TT> to support sparse 
                matrices that contain elements with indices that do not have a
                match within the source or destination Array.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Removed argument <TT>transposeRoutehandle</TT> and provide it
                via interface overloading instead. This allows argument 
                <TT>srcArray</TT> to stay strictly intent(in) for this entry point.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ArraySMMStoreTK"></A>   <TT>ESMF_ArraySMMStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArraySMMStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArraySMMStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#ArraySMMStoreTK">28.5.39</A> and
   <A HREF="#ArraySMMStoreNF">28.5.41</A>, is described in the following paragraphs as a whole.

<P>
Store an Array sparse matrix multiplication operation from <TT>srcArray</TT>
     to <TT>dstArray</TT>. PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the
     definition of <EM>sequence indices</EM>.

<P>
Source and destination Arrays, as well as the supplied <TT>factorList</TT>
     argument, may be of different &lt;type&gt;&lt;kind&gt;. Further source and
     destination Arrays may differ in shape and number of elements.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArraySMM()</TT> on any pair of Arrays that matches 
     <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of 
     RouteHandle reusability.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.

<P>
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcArray</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstArray</TT>. For this format to be a valid
       option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identity matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcArray</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstArray</TT>.

<P>
See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of 
       Array <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       <TT>srcArray</TT> or <TT>dstArray</TT> side. The default setting is 
       <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied 
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the 
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050554000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">40</SPAN> ESMF_ArraySMMStore - Precompute Array sparse matrix multiplication and transpose with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStore&lt;type&gt;&lt;kind&gt;TP(srcArray, dstArray, &amp;
     routehandle, transposeRoutehandle, factorList, factorIndexList, &amp;
     ignoreUnmatchedIndices, srcTermProcessing, pipelineDepth, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),          intent(inout)           :: srcArray
     type(ESMF_Array),          intent(inout)           :: dstArray
     type(ESMF_RouteHandle),    intent(inout)           :: routehandle
     type(ESMF_RouteHandle),    intent(inout)           :: transposeRoutehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)       :: factorList(:)
     integer(ESMF_KIND_&lt;kind&gt;), intent(in)              :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                   intent(in),    optional :: ignoreUnmatchedIndices
     integer,                   intent(inout), optional :: srcTermProcessing
     integer,                   intent(inout), optional :: pipelineDepth
     integer,                   intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ArraySMMStoreTKTP"></A>   <TT>ESMF_ArraySMMStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArraySMMStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArraySMMStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#ArraySMMStoreTKTP">28.5.40</A> and
   <A HREF="#ArraySMMStoreNFTP">28.5.42</A>, is described in the following paragraphs as a whole.

<P>
Store an Array sparse matrix multiplication operation from <TT>srcArray</TT>
     to <TT>dstArray</TT>. PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the
     definition of <EM>sequence indices</EM>.

<P>
Source and destination Arrays, as well as the supplied <TT>factorList</TT>
     argument, may be of different &lt;type&gt;&lt;kind&gt;. Further source and
     destination Arrays may differ in shape and number of elements.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArraySMM()</TT> on any pair of Arrays that matches 
     <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>[transposeRoutehandle]</STRONG></DT>
<DD>Handle to the transposed matrix operation. The transposed operation goes
       from <TT>dstArray</TT> to <TT>srcArray</TT>.

<P>
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.

<P>
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcArray</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstArray</TT>. For this format to be a valid
       option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identity matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcArray</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstArray</TT>.

<P>
See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the definition of 
       Array <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       <TT>srcArray</TT> or <TT>dstArray</TT> side. The default setting is 
       <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied 
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the 
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050554100000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">41</SPAN> ESMF_ArraySMMStore - Precompute Array sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreNF(srcArray, dstArray, routehandle, &amp;
     ignoreUnmatchedIndices, srcTermProcessing, pipelineDepth, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(in)              :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: srcTermProcessing
     integer,                intent(inout), optional :: pipelineDepth
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added argument <TT>srcTermProcessing</TT>.
                Added argument <TT>pipelineDepth</TT>.
                The new arguments provide access to the tuning parameters
                affecting the sparse matrix execution.
   
</DD>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>transposeRoutehandle</TT> to allow a handle to
                the transposed matrix operation to be returned.
<BR>
Added argument <TT>ignoreUnmatchedIndices</TT> to support sparse 
                matrices that contain elements with indices that do not have a
                match within the source or destination Array.
   
</DD>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Removed argument <TT>transposeRoutehandle</TT> and provide it
                via interface overloading instead. This allows argument 
                <TT>srcArray</TT> to stay strictly intent(in) for this entry point.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ArraySMMStoreNF"></A>   <TT>ESMF_ArraySMMStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArraySMMStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArraySMMStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#ArraySMMStoreTK">28.5.39</A> and
   <A HREF="#ArraySMMStoreNF">28.5.41</A>, is described in the following paragraphs as a whole.

<P>
Store an Array sparse matrix multiplication operation from <TT>srcArray</TT>
     to <TT>dstArray</TT>. PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the
     definition of <EM>sequence indices</EM>.

<P>
Source and destination Arrays, as well as the supplied <TT>factorList</TT>
     argument, may be of different &lt;type&gt;&lt;kind&gt;. Further source and
     destination Arrays may differ in shape and number of elements.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArraySMM()</TT> on any pair of Arrays that matches 
     <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       <TT>srcArray</TT> or <TT>dstArray</TT> side. The default setting is 
       <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied 
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the 
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050554200000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">42</SPAN> ESMF_ArraySMMStore - Precompute Array sparse matrix multiplication and transpose without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreNFTP(srcArray, dstArray, routehandle, &amp;
     transposeRoutehandle, ignoreUnmatchedIndices, &amp;
     srcTermProcessing, pipelineDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(inout)           :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_RouteHandle), intent(inout)           :: transposeRoutehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: srcTermProcessing
     integer,                intent(inout), optional :: pipelineDepth
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="ArraySMMStoreNFTP"></A>   <TT>ESMF_ArraySMMStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArraySMMStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArraySMMStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="#ArraySMMStoreTKTP">28.5.40</A> and
   <A HREF="#ArraySMMStoreNFTP">28.5.42</A>, is described in the following paragraphs as a whole.

<P>
Store an Array sparse matrix multiplication operation from <TT>srcArray</TT>
     to <TT>dstArray</TT>. PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section <A HREF="#Array:SparseMatMul">28.2.18</A> for details on the
     definition of <EM>sequence indices</EM>.

<P>
Source and destination Arrays, as well as the supplied <TT>factorList</TT>
     argument, may be of different &lt;type&gt;&lt;kind&gt;. Further source and
     destination Arrays may differ in shape and number of elements.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArraySMM()</TT> on any pair of Arrays that matches 
     <TT>srcArray</TT> and <TT>dstArray</TT> in <EM>type</EM>, <EM>kind</EM>, and 
     memory layout of the <EM>distributed</EM> dimensions. However, the size,
     number, and index order of <EM>undistributed</EM> dimensions may be different.
     See section <A HREF="#RH:Reusability">37.2.5</A> for a more detailed discussion of
     RouteHandle reusability.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.

<P>
</DD>
<DT><STRONG>[transposeRoutehandle]</STRONG></DT>
<DD>Handle to the transposed matrix operation. The transposed operation goes
       from <TT>dstArray</TT> to <TT>srcArray</TT>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices 
       in the sparse matrix are encountered that do not have a match on the 
       <TT>srcArray</TT> or <TT>dstArray</TT> side. The default setting is 
       <TT>.false.</TT>, indicating that it is an error when such a situation is 
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied 
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the 
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the 
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to 
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the 
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional 
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050554300000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">43</SPAN> ESMF_ArraySMMStore - Precompute sparse matrix multiplication using factors read from file.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreFromFile(srcArray, dstArray, filename, &amp;
     routehandle, ignoreUnmatchedIndices, &amp;
     srcTermProcessing, pipelineDepth, rc)
 
   ! ARGUMENTS:
     type(ESMF_Array),       intent(in)              :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     character(len=*),       intent(in)              :: filename
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: srcTermProcessing
     integer,                intent(inout), optional :: pipeLineDepth
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute an <TT>ESMF_RouteHandle</TT> using factors read from file.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
         destroyed by this call.

<P>
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Path to the file containing weights for creating an <TT>ESMF_RouteHandle</TT>.
         See&nbsp;(<A HREF="node3.html#sec:weightfileformat">12.9</A>) for a description of the SCRIP weight
         file format. Only "row", "col", and "S" variables are required. They
         must be one-dimensionsal with dimension "n_s".

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the <TT>ESMF_RouteHandle</TT>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices
       in the sparse matrix are encountered that do not have a match on the
       <TT>srcArray</TT> or <TT>dstArray</TT> side. The default setting is
       <TT>.false.</TT>, indicating that it is an error when such a situation is
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
       The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050554400000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">44</SPAN> ESMF_ArraySMMStore - Precompute sparse matrix multiplication and transpose using factors read from file.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreFromFileTP(srcArray, dstArray, filename, &amp;
     routehandle, transposeRoutehandle, ignoreUnmatchedIndices,&amp;
     srcTermProcessing, pipelineDepth, rc)
 
   ! ARGUMENTS:
     type(ESMF_Array),       intent(inout)           :: srcArray
     type(ESMF_Array),       intent(inout)           :: dstArray
     character(len=*),       intent(in)              :: filename
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
     type(ESMF_RouteHandle), intent(inout)           :: transposeRoutehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: ignoreUnmatchedIndices
     integer,                intent(inout), optional :: srcTermProcessing
     integer,                intent(inout), optional :: pipeLineDepth
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compute an <TT>ESMF_RouteHandle</TT> using factors read from file.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data. The data in this Array may be
       destroyed by this call.

<P>
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
         destroyed by this call.

<P>
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Path to the file containing weights for creating an <TT>ESMF_RouteHandle</TT>.
         See&nbsp;(<A HREF="node3.html#sec:weightfileformat">12.9</A>) for a description of the SCRIP weight
         file format. Only "row", "col", and "S" variables are required. They
         must be one-dimensionsal with dimension "n_s".

<P>
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the <TT>ESMF_RouteHandle</TT>.

<P>
</DD>
<DT><STRONG>[transposeRoutehandle]</STRONG></DT>
<DD>Handle to the transposed matrix operation. The transposed operation goes
       from <TT>dstArray</TT> to <TT>srcArray</TT>.

<P>
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices
       in the sparse matrix are encountered that do not have a match on the
       <TT>srcArray</TT> or <TT>dstArray</TT> side. The default setting is
       <TT>.false.</TT>, indicating that it is an error when such a situation is
       encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
       entries with unmatched indices.

<P>
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
       located on the same PET and summing into the same destination element,
       are summed into partial sums on the source PET before being transferred
       to the destination PET. A value of 0 indicates that the entire arithmetic
       is done on the destination PET; source elements are neither multiplied
       by their factors nor added into partial sums before being sent off by the
       source PET. A value of 1 indicates that source elements are multiplied
       by their factors on the source side before being sent to the destination
       PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
       of terms in the partial sums on the source side.

<P>
Note that partial sums may lead to bit-for-bit differences in the results.
       See section <A HREF="#RH:bfb">37.2.1</A> for an in-depth discussion of <EM>all</EM>
       bit-for-bit reproducibility aspects related to route-based communication
       methods.

<P>
The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>srcTermProcessing</TT> parameter. The intent on the
       <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>srcTermProcessing</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>srcTermProcessing</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>srcTermProcessing</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
       may have outstanding during a sparse matrix exchange. Larger values
       of <TT>pipelineDepth</TT> typically lead to better performance. However,
       on some systems too large a value may lead to performance degradation,
       or runtime errors.

<P>
Note that the pipeline depth has no effect on the bit-for-bit
       reproducibility of the results. However, it may affect the performance
       reproducibility of the exchange.
       The <TT>ESMF_ArraySMMStore()</TT> method implements an auto-tuning scheme
       for the <TT>pipelineDepth</TT> parameter. The intent on the
       <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
       support both overriding and accessing the auto-tuning parameter.
       If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
       <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
       In this case the <TT>pipelineDepth</TT> argument is not modified on
       return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img42.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
       parameter is determined internally using the auto-tuning scheme. In this
       case the <TT>pipelineDepth</TT> argument is re-set to the internally
       determined value on return. Auto-tuning is also used if the optional
       <TT>pipelineDepth</TT> argument is omitted.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050554500000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">45</SPAN> ESMF_ArraySync - Synchronize DEs across the Array in case of sharing</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySync(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Synchronizes access to DEs across <TT>array</TT> to make sure PETs correctly
       access the data for read and write when DEs are shared. 

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Specified <TT>ESMF_Array</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050554600000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">46</SPAN> ESMF_ArrayValidate - Validate object-wide Array information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayValidate(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>Array</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Specified <TT>ESMF_Array</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050554700000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">47</SPAN> ESMF_ArrayWrite - Write Array data into a file</A>
</H3>

<P>
<A NAME="api:ArrayWrite"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayWrite(array, fileName, &amp;
       variableName, convention, purpose,  &amp;
       overwrite, status, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),           intent(in)            :: array
     character(*),               intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*),               intent(in),  optional :: variableName
     character(*),               intent(in),  optional :: convention
     character(*),               intent(in),  optional :: purpose
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     integer,                    intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write Array data into a file. For this API to be functional, the 
     environment variable <TT>ESMF_PIO</TT> should be set to either "internal" or "external" when
     the ESMF library is built.  Please see the section on 
     Data I/O,&nbsp;<A HREF="#io:dataio">38.2</A>. 

<P>
When <TT>convention</TT> and <TT>purpose</TT> arguments are specified,
     a NetCDF variable can be created with user-specified dimension labels and
     attributes.  Dimension labels may be defined for both gridded and
     ungridded dimensions.  Dimension labels for gridded dimensions are specified
     at the DistGrid level by attaching an ESMF Attribute package to it.  The Attribute
     package must contain an attribute named by the pre-defined ESMF parameter
     <TT>ESMF_ATT_GRIDDED_DIM_LABELS</TT>.  The corresponding value is an array of
     character strings specifying the desired names of the dimensions.  Likewise,
     for ungridded dimensions, an Attribute package is attached at the Array level.
     The name of the name must be <TT>ESMF_ATT_UNGRIDDED_DIM_LABELS</TT>.

<P>
NetCDF attributes for the variable can also be specified.  As with dimension labels,
     an Attribute package is added to the Array with the desired names and values.
     A value may be either a scalar character string, or a scalar or array of type
     integer, real, or double precision.  Dimension label attributes can co-exist with
     variable attributes within a common Attribute package.

<P>
Limitations:
     
<UL>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object that contains data to be written.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the output file to which Array data is written.
      If this is a multi-tile Array, then fileName must contain
      exactly one instance of "*"; this is a placeholder that will be replaced
      by the tile number, with each tile being written to a separate file. (For
      example, for a fileName of "myfile*.nc", tile 1 will be written to
      "myfile1.nc", tile 2 to "myfile2.nc", etc.)
      (This handling of the fileName for multi-tile I/O is subject to change.)
     
</DD>
<DT><STRONG>[variableName]</STRONG></DT>
<DD>Variable name in the output file; default is the "name" of Array.
      Use this argument only in the I/O format (such as NetCDF) that
      supports variable name. If the I/O format does not support this
      (such as binary format), ESMF will return an error code.
     
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>Specifies an Attribute package associated with the Array, used to create NetCDF
       dimension labels and attributes for the variable in the file.  When this argument is present,
       the <TT>purpose</TT> argument must also be present.  Use this argument only with a NetCDF
       I/O format. If binary format is used, ESMF will return an error code.
     
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>Specifies an Attribute package associated with the Array, used to create NetCDF
       dimension labels and attributes for the variable in the file.  When this argument is present,
       the <TT>convention</TT> argument must also be present.  Use this argument only with a NetCDF
       I/O format. If binary format is used, ESMF will return an error code.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Array data may
        <EM>not</EM> be overwritten. If .true., only the
        data corresponding to the Array's name will be
        be overwritten. If the <TT>timeslice</TT> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.

</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Please see Section&nbsp;<A HREF="node9.html#const:filestatusflag">54.21</A> for
      the list of options. If not present, defaults to
      <TT>ESMF_FILESTATUS_UNKNOWN</TT>.

</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Some I/O formats (e.g. NetCDF) support the output of data in form of
      time slices.  An unlimited dimension called <TT>time</TT> is defined in the
      file variable for this capability.
      The <TT>timeslice</TT> argument provides access to the <TT>time</TT> dimension,
      and must have a positive value. The behavior of this
      option may depend on the setting of the <TT>overwrite</TT> flag:
      <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
      less than the maximum time already in the file, the write will fail.
      
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
      
</DD>
</DL>
      By default, i.e. by omitting the <TT>timeslice</TT> argument, no
      provisions for time slicing are made in the output file,
      however, if the file already contains a time axis for the variable,
      a timeslice one greater than the maximum will be written.

</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Please see Section&nbsp;<A HREF="node9.html#opt:iofmtflag">54.28</A> for the list
      of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050554800000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">48</SPAN> ESMF_SparseMatrixWrite - Write a sparse matrix to file</A>
</H3>

<P>
<A NAME="api:SparseMatrixWrite"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_SparseMatrixWrite(factorList, factorIndexList, fileName, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8),    intent(in)            :: factorList(:)
     integer(ESMF_KIND_I4), intent(in)            :: factorIndexList(:,:)
     character(*),          intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,               intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write the <TT>factorList</TT> and <TT>factorIndexList</TT> into a NetCDF file.
     The data is stored in SCRIP format documented under section 
&nbsp;(<A HREF="node3.html#sec:weightfileformat">12.9</A>).

<P>
Limitations:
     
<UL>
<LI>Only <TT>real(ESMF_KIND_R8) factorList</TT> and 
             <TT>integer(ESMF_KIND_I4) factorIndexList</TT> supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
    <DL>
<DT><STRONG>factorList</STRONG></DT>
<DD>The sparse matrix factors to be written.
     
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>The sparse matrix sequence indices to be written.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the output file to be written.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>


<H2><A NAME="SECTION05056000000000000000"></A>
<A NAME="ref:dynamicmask"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API: DynamicMask Methods
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05056100000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DynamicMaskSetR8R8R8 - Set DynamicMask for R8R8R8</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DynamicMaskSetR8R8R8(dynamicMask, dynamicMaskRoutine, &amp;
     handleAllElements, dynamicSrcMaskValue, &amp;
     dynamicDstMaskValue, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DynamicMask), intent(out)           :: dynamicMask
     procedure(ESMF_DynamicMaskRoutineR8R8R8)      :: dynamicMaskRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: handleAllElements
     real(ESMF_KIND_R8),     intent(in),  optional :: dynamicSrcMaskValue
     real(ESMF_KIND_R8),     intent(in),  optional :: dynamicDstMaskValue
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DynamicMaskSetR8R8R8"></A>     Set an <TT>ESMF_DynamicMask</TT> object suitable for 
     destination element typekind <TT>ESMF_TYPEKIND_R8</TT>,
     factor typekind <TT>ESMF_TYPEKIND_R8</TT>, and
     source element typekind <TT>ESMF_TYPEKIND_R8</TT>.

<P>
All values in <TT>dynamicMask</TT> will be reset by this call.

<P>
See section <A HREF="#RH:DynMask">37.2.6</A> for a general discussion of dynamic masking.

<P>
The arguments are:
     <DL>
<DT><STRONG>dynamicMask</STRONG></DT>
<DD>DynamicMask object.
     
</DD>
<DT><STRONG>dynamicMaskRoutine</STRONG></DT>
<DD>The routine responsible for handling dynamically masked source and 
       destination elements. See section <A HREF="#RH:DynMask">37.2.6</A> for the precise
       definition of the <TT>dynamicMaskRoutine</TT> procedure interface.
       The routine is only called on PETs where <EM>at least one</EM> interpolation 
       element is identified for special handling.
     
</DD>
<DT><STRONG>[handleAllElements]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, all local elements, regardless of their dynamic
       masking status, are made available to <TT>dynamicMaskRoutine</TT> for
       handling. This option can be used to implement fully customized
       interpolations based on the information provided by ESMF.
       The default is <TT>.false.</TT>, meaning that only elements affected by
       dynamic masking will be handed to <TT>dynamicMaskRoutine</TT>.
     
</DD>
<DT><STRONG>[dynamicSrcMaskValue]</STRONG></DT>
<DD>The value for which a source element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any source elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[dynamicDstMaskValue]</STRONG></DT>
<DD>The value for which a destination element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any destination elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05056200000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_DynamicMaskSetR8R8R8V - Set DynamicMask for R8R8R8 with vectorization</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DynamicMaskSetR8R8R8V(dynamicMask, dynamicMaskRoutine, &amp;
     handleAllElements, dynamicSrcMaskValue, &amp;
     dynamicDstMaskValue, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DynamicMask), intent(out)           :: dynamicMask
     procedure(ESMF_DynamicMaskRoutineR8R8R8V)     :: dynamicMaskRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: handleAllElements
     real(ESMF_KIND_R8),     intent(in),  optional :: dynamicSrcMaskValue
     real(ESMF_KIND_R8),     intent(in),  optional :: dynamicDstMaskValue
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DynamicMaskSetR8R8R8V"></A>     Set an <TT>ESMF_DynamicMask</TT> object suitable for 
     destination element typekind <TT>ESMF_TYPEKIND_R8</TT>,
     factor typekind <TT>ESMF_TYPEKIND_R8</TT>, and
     source element typekind <TT>ESMF_TYPEKIND_R8</TT>.

<P>
All values in <TT>dynamicMask</TT> will be reset by this call.

<P>
See section <A HREF="#RH:DynMask">37.2.6</A> for a general discussion of dynamic masking.

<P>
The arguments are:
     <DL>
<DT><STRONG>dynamicMask</STRONG></DT>
<DD>DynamicMask object.
     
</DD>
<DT><STRONG>dynamicMaskRoutine</STRONG></DT>
<DD>The routine responsible for handling dynamically masked source and 
       destination elements. See section <A HREF="#RH:DynMask">37.2.6</A> for the precise
       definition of the <TT>dynamicMaskRoutine</TT> procedure interface.
       The routine is only called on PETs where <EM>at least one</EM> interpolation 
       element is identified for special handling.
     
</DD>
<DT><STRONG>[handleAllElements]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, all local elements, regardless of their dynamic
       masking status, are made available to <TT>dynamicMaskRoutine</TT> for
       handling. This option can be used to implement fully customized
       interpolations based on the information provided by ESMF.
       The default is <TT>.false.</TT>, meaning that only elements affected by
       dynamic masking will be handed to <TT>dynamicMaskRoutine</TT>.
     
</DD>
<DT><STRONG>[dynamicSrcMaskValue]</STRONG></DT>
<DD>The value for which a source element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any source elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[dynamicDstMaskValue]</STRONG></DT>
<DD>The value for which a destination element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any destination elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05056300000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_DynamicMaskSetR4R8R4 - Set DynamicMask for R4R8R4</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DynamicMaskSetR4R8R4(dynamicMask, dynamicMaskRoutine, &amp;
     handleAllElements, dynamicSrcMaskValue, &amp;
     dynamicDstMaskValue, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DynamicMask), intent(out)           :: dynamicMask
     procedure(ESMF_DynamicMaskRoutineR4R8R4)      :: dynamicMaskRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: handleAllElements
     real(ESMF_KIND_R4),     intent(in),  optional :: dynamicSrcMaskValue
     real(ESMF_KIND_R4),     intent(in),  optional :: dynamicDstMaskValue
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DynamicMaskSetR4R8R4"></A>     Set an <TT>ESMF_DynamicMask</TT> object suitable for 
     destination element typekind <TT>ESMF_TYPEKIND_R4</TT>,
     factor typekind <TT>ESMF_TYPEKIND_R8</TT>, and
     source element typekind <TT>ESMF_TYPEKIND_R4</TT>.

<P>
All values in <TT>dynamicMask</TT> will be reset by this call.

<P>
See section <A HREF="#RH:DynMask">37.2.6</A> for a general discussion of dynamic masking.

<P>
The arguments are:
     <DL>
<DT><STRONG>dynamicMask</STRONG></DT>
<DD>DynamicMask object.
     
</DD>
<DT><STRONG>dynamicMaskRoutine</STRONG></DT>
<DD>The routine responsible for handling dynamically masked source and 
       destination elements. See section <A HREF="#RH:DynMask">37.2.6</A> for the precise
       definition of the <TT>dynamicMaskRoutine</TT> procedure interface.
       The routine is only called on PETs where <EM>at least one</EM> interpolation 
       element is identified for special handling.
     
</DD>
<DT><STRONG>[handleAllElements]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, all local elements, regardless of their dynamic
       masking status, are made available to <TT>dynamicMaskRoutine</TT> for
       handling. This option can be used to implement fully customized
       interpolations based on the information provided by ESMF.
       The default is <TT>.false.</TT>, meaning that only elements affected by
       dynamic masking will be handed to <TT>dynamicMaskRoutine</TT>.
     
</DD>
<DT><STRONG>[dynamicSrcMaskValue]</STRONG></DT>
<DD>The value for which a source element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any source elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[dynamicDstMaskValue]</STRONG></DT>
<DD>The value for which a destination element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any destination elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05056400000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_DynamicMaskSetR4R8R4V - Set DynamicMask for R4R8R4 with vectorization</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DynamicMaskSetR4R8R4V(dynamicMask, dynamicMaskRoutine, &amp;
     handleAllElements, dynamicSrcMaskValue, &amp;
     dynamicDstMaskValue, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DynamicMask), intent(out)           :: dynamicMask
     procedure(ESMF_DynamicMaskRoutineR4R8R4V)     :: dynamicMaskRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: handleAllElements
     real(ESMF_KIND_R4),     intent(in),  optional :: dynamicSrcMaskValue
     real(ESMF_KIND_R4),     intent(in),  optional :: dynamicDstMaskValue
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DynamicMaskSetR4R8R4V"></A>     Set an <TT>ESMF_DynamicMask</TT> object suitable for 
     destination element typekind <TT>ESMF_TYPEKIND_R4</TT>,
     factor typekind <TT>ESMF_TYPEKIND_R8</TT>, and
     source element typekind <TT>ESMF_TYPEKIND_R4</TT>.

<P>
All values in <TT>dynamicMask</TT> will be reset by this call.

<P>
See section <A HREF="#RH:DynMask">37.2.6</A> for a general discussion of dynamic masking.

<P>
The arguments are:
     <DL>
<DT><STRONG>dynamicMask</STRONG></DT>
<DD>DynamicMask object.
     
</DD>
<DT><STRONG>dynamicMaskRoutine</STRONG></DT>
<DD>The routine responsible for handling dynamically masked source and 
       destination elements. See section <A HREF="#RH:DynMask">37.2.6</A> for the precise
       definition of the <TT>dynamicMaskRoutine</TT> procedure interface.
       The routine is only called on PETs where <EM>at least one</EM> interpolation 
       element is identified for special handling.
     
</DD>
<DT><STRONG>[handleAllElements]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, all local elements, regardless of their dynamic
       masking status, are made available to <TT>dynamicMaskRoutine</TT> for
       handling. This option can be used to implement fully customized
       interpolations based on the information provided by ESMF.
       The default is <TT>.false.</TT>, meaning that only elements affected by
       dynamic masking will be handed to <TT>dynamicMaskRoutine</TT>.
     
</DD>
<DT><STRONG>[dynamicSrcMaskValue]</STRONG></DT>
<DD>The value for which a source element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any source elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[dynamicDstMaskValue]</STRONG></DT>
<DD>The value for which a destination element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any destination elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05056500000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_DynamicMaskSetR4R4R4 - Set DynamicMask for R4R4R4</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DynamicMaskSetR4R4R4(dynamicMask, dynamicMaskRoutine, &amp;
     handleAllElements, dynamicSrcMaskValue, &amp;
     dynamicDstMaskValue, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DynamicMask), intent(out)           :: dynamicMask
     procedure(ESMF_DynamicMaskRoutineR4R4R4)      :: dynamicMaskRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: handleAllElements
     real(ESMF_KIND_R4),     intent(in),  optional :: dynamicSrcMaskValue
     real(ESMF_KIND_R4),     intent(in),  optional :: dynamicDstMaskValue
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DynamicMaskSetR4R4R4"></A>     Set an <TT>ESMF_DynamicMask</TT> object suitable for 
     destination element typekind <TT>ESMF_TYPEKIND_R4</TT>,
     factor typekind <TT>ESMF_TYPEKIND_R4</TT>, and
     source element typekind <TT>ESMF_TYPEKIND_R4</TT>.

<P>
All values in <TT>dynamicMask</TT> will be reset by this call.

<P>
See section <A HREF="#RH:DynMask">37.2.6</A> for a general discussion of dynamic masking.

<P>
The arguments are:
     <DL>
<DT><STRONG>dynamicMask</STRONG></DT>
<DD>DynamicMask object.
     
</DD>
<DT><STRONG>dynamicMaskRoutine</STRONG></DT>
<DD>The routine responsible for handling dynamically masked source and 
       destination elements. See section <A HREF="#RH:DynMask">37.2.6</A> for the precise
       definition of the <TT>dynamicMaskRoutine</TT> procedure interface.
       The routine is only called on PETs where <EM>at least one</EM> interpolation 
       element is identified for special handling.
     
</DD>
<DT><STRONG>[handleAllElements]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, all local elements, regardless of their dynamic
       masking status, are made available to <TT>dynamicMaskRoutine</TT> for
       handling. This option can be used to implement fully customized
       interpolations based on the information provided by ESMF.
       The default is <TT>.false.</TT>, meaning that only elements affected by
       dynamic masking will be handed to <TT>dynamicMaskRoutine</TT>.
     
</DD>
<DT><STRONG>[dynamicSrcMaskValue]</STRONG></DT>
<DD>The value for which a source element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any source elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[dynamicDstMaskValue]</STRONG></DT>
<DD>The value for which a destination element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any destination elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05056600000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_DynamicMaskSetR4R4R4V - Set DynamicMask for R4R4R4 with vectorization</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DynamicMaskSetR4R4R4V(dynamicMask, dynamicMaskRoutine, &amp;
     handleAllElements, dynamicSrcMaskValue, &amp;
     dynamicDstMaskValue, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DynamicMask), intent(out)           :: dynamicMask
     procedure(ESMF_DynamicMaskRoutineR4R4R4V)     :: dynamicMaskRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: handleAllElements
     real(ESMF_KIND_R4),     intent(in),  optional :: dynamicSrcMaskValue
     real(ESMF_KIND_R4),     intent(in),  optional :: dynamicDstMaskValue
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DynamicMaskSetR4R4R4V"></A>     Set an <TT>ESMF_DynamicMask</TT> object suitable for 
     destination element typekind <TT>ESMF_TYPEKIND_R4</TT>,
     factor typekind <TT>ESMF_TYPEKIND_R4</TT>, and
     source element typekind <TT>ESMF_TYPEKIND_R4</TT>.

<P>
All values in <TT>dynamicMask</TT> will be reset by this call.

<P>
See section <A HREF="#RH:DynMask">37.2.6</A> for a general discussion of dynamic masking.

<P>
The arguments are:
     <DL>
<DT><STRONG>dynamicMask</STRONG></DT>
<DD>DynamicMask object.
     
</DD>
<DT><STRONG>dynamicMaskRoutine</STRONG></DT>
<DD>The routine responsible for handling dynamically masked source and 
       destination elements. See section <A HREF="#RH:DynMask">37.2.6</A> for the precise
       definition of the <TT>dynamicMaskRoutine</TT> procedure interface.
       The routine is only called on PETs where <EM>at least one</EM> interpolation 
       element is identified for special handling.
     
</DD>
<DT><STRONG>[handleAllElements]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, all local elements, regardless of their dynamic
       masking status, are made available to <TT>dynamicMaskRoutine</TT> for
       handling. This option can be used to implement fully customized
       interpolations based on the information provided by ESMF.
       The default is <TT>.false.</TT>, meaning that only elements affected by
       dynamic masking will be handed to <TT>dynamicMaskRoutine</TT>.
     
</DD>
<DT><STRONG>[dynamicSrcMaskValue]</STRONG></DT>
<DD>The value for which a source element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any source elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[dynamicDstMaskValue]</STRONG></DT>
<DD>The value for which a destination element is considered dynamically
       masked.
       The default is to <EM>not</EM> consider any destination elements as
       dynamically masked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION05060000000000000000">
<SPAN CLASS="arabic">29</SPAN> LocalArray Class</A>
</H1>

<H2><A NAME="SECTION05061000000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The <TT>ESMF_LocalArray</TT> class provides a language independent 
representation of data in array format. One of the major functions 
of the LocalArray class is to bridge the Fortran/C/C++ language 
difference that exists with respect to array representation. All 
ESMF Field and Array data is internally stored in ESMF LocalArray 
objects allowing transparent access from Fortran and C/C++.

<P>
In the ESMF Fortran API the LocalArray becomes visible in those cases 
where a local PET may be associated with multiple pieces of an Array, 
e.g. if there are multiple DEs associated with a single PET. The Fortran 
language standard does not provide an array of arrays construct, however 
arrays of derived types holding arrays are possible. ESMF calls use 
arguments that are of type <TT>ESMF_LocalArray</TT> with <TT>dimension</TT> 
attributes where necessary.

<H2><A NAME="SECTION05062000000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">2</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>The TKR (type/kind/rank) overloaded LocalArray interfaces declare the dummy Fortran array arguments with the pointer attribute. The advantage of doing this is that it allows ESMF to inquire information about the provided Fortran array. The disadvantage of this choice is that actual Fortran arrays passed into these interfaces <EM>must</EM> also be defined with pointer attribute in the user code.
</LI>
</UL>

<H2><A NAME="SECTION05063000000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05063100000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LocalArrayAssignment(=) - LocalArray assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface assignment(=)
   localarray1 = localarray2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray) :: localarray1
   type(ESMF_LocalArray) :: localarray2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign localarray1 as an alias to the same ESMF LocalArray object in memory
   as localarray2. If localarray2 is invalid, then localarray1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray1</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>localarray2</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063200000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LocalArrayOperator(==) - LocalArray equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
   if (localarray1 == localarray2) then ... endif
   OR
   result = (localarray1 == localarray2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray), intent(in) :: localarray1
   type(ESMF_LocalArray), intent(in) :: localarray2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether localarray1 and localarray2 are valid aliases to the same ESMF
   LocalArray object in memory. For a more general comparison of two ESMF LocalArrays,
   going beyond the simple alias test, the ESMF_LocalArrayMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray1</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>localarray2</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063300000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LocalArrayOperator(/=) - LocalArray not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
   if (localarray1 /= localarray2) then ... endif
   OR
   result = (localarray1 /= localarray2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray), intent(in) :: localarray1
   type(ESMF_LocalArray), intent(in) :: localarray2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether localarray1 and localarray2 are <I>not</I> valid aliases to the
   same ESMF LocalArray object in memory. For a more general comparison of two ESMF
   LocalArrays, going beyond the simple alias test, the ESMF_LocalArrayMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray1</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>localarray2</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063400000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_LocalArrayCreate - Create a LocalArray by explicitly specifying typekind and rank arguments</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateByTKR(typekind, rank, totalCount, &amp;
     totalLBound, totalUBound, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateByTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_TypeKind_Flag), intent(in) :: typekind
     integer, intent(in) :: rank
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: totalCount(:)
     integer, intent(in), optional :: totalLBound(:)
     integer, intent(in), optional :: totalUBound(:)
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_LocalArray</TT> and allocate data space, which remains
   uninitialized. The return value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind. See section <A HREF="node9.html#const:typekind">54.59</A> for valid values.
   
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality, 1D, 2D, etc). Maximum allowed is 7D.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D
   integer array the same length as the rank. The <TT>count</TT> argument may
   be omitted if both <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments are present.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>An integer array of length rank, with the lower index for each dimension.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>An integer array of length rank, with the upper index for each dimension.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063500000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_LocalArrayCreate - Create a LocalArray by specifying an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateBySpec(arrayspec, totalCount, &amp;
     totalLBound, totalUBound, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateBySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: totalCount(:)
     integer, intent(in), optional :: totalLBound(:)
     integer, intent(in), optional :: totalUBound(:)
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_LocalArray</TT> and allocate data space, which remains
   uninitialized. The return value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>ArraySpec object specifying typekind and rank.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D
   integer array the same length as the rank. The <TT>count</TT> argument may
   be omitted if both <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments are present.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>An integer array of length rank, with the lower index for each dimension.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>An integer array of length rank, with the upper index for each dimension.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063600000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_LocalArrayCreate - Create a LocalArray from pre-existing LocalArray</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateCopy(localarray, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(in) :: localarray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Perform a deep copy of an existing <TT>ESMF_LocalArray</TT> object. The return
   value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD>Existing LocalArray to be copied.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063700000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_LocalArrayCreate - Create a LocalArray from a Fortran pointer (associated or unassociated) </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate() 
   function ESMF_LocalArrCreateByPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(farrayPtr, &amp; 
   datacopyflag, totalCount, totalLBound, totalUBound, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_LocalArray) :: ESMF_LocalArrCreateByPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: totalCount(:) 
   integer, intent(in), optional :: totalLBound(:) 
   integer, intent(in), optional :: totalUBound(:) 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates an <TT>ESMF_LocalArray</TT> based on a Fortran array pointer. 
   Two cases must be distinguished. 

<P>
First, if <TT>farrayPtr</TT> is associated 
   the optional <TT>datacopyflag</TT> argument may be used to indicate whether the 
   associated data is to be copied or referenced. For associated <TT>farrayPtr</TT> 
   the optional <TT>totalCount</TT>, <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments need 
   not be specified. However, all present arguments will be checked against 
   <TT>farrayPtr</TT> for consistency. 

<P>
Second, if <TT>farrayPtr</TT> is unassociated the optional argument <TT>datacopyflag</TT> 
   must not be specified. However, in this case a complete set of totalCount and 
   bounds information must be provided. Any combination of present <TT>totalCount</TT> 
   <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments that provides a complete 
   specification is valid. All input information will be checked for 
   consistency. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>A Fortran array pointer (associated or unassociated). 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicate copy vs. reference behavior in case of associated <TT>farrayPtr</TT>. 
   This argument must <EM>not</EM> be present for unassociated <TT>farrayPtr</TT>. 
   Default to <TT>ESMF_DATACOPY_REFERENCE</TT>, makes the <TT>ESMF_LocalArray</TT> 
   reference the associated data array. If set to <TT>ESMF_DATACOPY_VALUE</TT> this 
   routine allocates new memory and copies the data from the pointer into 
   the new LocalArray allocation. 
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D 
   integer array the same length as the rank. The <TT>count</TT> argument may 
   be omitted if both <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments are present. 
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>An integer array of lower index values. Must be the same length as the rank. 
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>An integer array of upper index values. Must be the same length as the rank. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05063800000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_LocalArrayDestroy - Release resources associated with a LocalArray</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_LocalArrayDestroy(localarray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(inout) :: localarray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_LocalArray</TT>, releasing all resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD>Destroy contents of this <TT>ESMF_LocalArray</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION05063900000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_LocalArrayGet - Get object-wide LocalArray information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayGet()
   subroutine ESMF_LocalArrayGetDefault(localarray, &amp;
     typekind, rank, totalCount, totalLBound, totalUBound, isESMFAllocated, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(in) :: localarray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer, intent(out), optional :: rank
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     logical, intent(out), optional :: isESMFAllocated
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.5.0</STRONG></DT>
<DD>Added argument <TT>isESMFAllocated</TT> to support user query of
   whether ESMF or user is responsible for the data allocation
   referenced by this object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns information about the <TT>ESMF_LocalArray</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD>Queried <TT>ESMF_LocalArray</TT> object.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind of the LocalArray object.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Rank of the LocalArray object.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Count per dimension.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Lower bound per dimension.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upper bound per dimension.
   
</DD>
<DT><STRONG>[isESMFAllocated]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for data allocations held by ESMF. Set to
   <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050631000000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_LocalArrayGet - Get a Fortran array pointer from a LocalArray </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayGet() 
   subroutine ESMF_LocalArrayGetData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(localarray, farrayPtr, &amp; 
   datacopyflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray) :: localarray 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>

<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version. 
   
</LI>
</UL> 

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return a Fortran pointer to the data buffer, or return a Fortran pointer 
   to a new copy of the data. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> to get the value from. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>An unassociated or associated Fortran pointer correctly allocated.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>An optional copy flag which can be specified. 
   Can either make a new copy of the data or reference existing data. 
   See section <A HREF="node9.html#const:datacopyflag">54.12</A> for a list of possible values. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050631100000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_LocalArrayIsCreated - Check whether a LocalArray object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_LocalArrayIsCreated(localarray, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_LocalArrayIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(in) :: localarray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>localarray</TT> has been created. Otherwise return
   <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
   returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD><TT>ESMF_LocalArray</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<P>

<P>

<P>


<H1><A NAME="SECTION05070000000000000000">
<SPAN CLASS="arabic">30</SPAN> ArraySpec Class</A>
</H1>

<H2><A NAME="SECTION05071000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
An ArraySpec is a very simple class that contains type, kind, and
rank information about an Array.  This information is stored in two
parameters.  <B>TypeKind</B> describes the data type of the elements
in the Array and their precision.  <B>Rank</B> is the number of dimensions
in the Array.

<P>
The only methods that are associated with the ArraySpec class are those 
that allow you to set and retrieve this information.

<P>

<H2><A NAME="SECTION05072000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The ArraySpec is passed in as an argument at Field and 
FieldBundle creation in order to describe an Array that will 
be allocated or attached at a later time.  There are any
number of situations in which this approach is useful.  
One common example is a case in which the user wants to create
a very flexible export State with many diagnostic variables 
predefined, but only a subset desired and consequently 
allocated for a particular run.  

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_ArraySpecEx - ArraySpec manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of ArraySpec set and get usage
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! local variables
      type(ESMF_ArraySpec) :: arrayDS
      integer :: myrank
      type(ESMF_TypeKind_Flag) :: mytypekind


      ! return code
      integer:: rc, result
      character(ESMF_MAXSTR) :: testname
      character(ESMF_MAXSTR) :: failMsg
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultlogfilename="ArraySpecEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<P>

<H3><A NAME="SECTION05072100000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Set ArraySpec values</A>
</H3>

<P>
This example shows how to set values in an <TT>ESMF_ArraySpec</TT>.
<P>
<PRE>
      call ESMF_ArraySpecSet(arrayDS, rank=2, &amp;
                             typekind=ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>

<P>

<H3><A NAME="SECTION05072200000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Get ArraySpec values</A>
</H3>

<P>
This example shows how to query an <TT>ESMF_ArraySpec</TT>.
<P>
<PRE>
      call ESMF_ArraySpecGet(arrayDS, rank=myrank, &amp;
        typekind=mytypekind, rc=rc)
      print *, "Returned values from ArraySpec:"
      print *, "rank =", myrank
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_ArraySpecEx
</PRE>

<P>


<H2><A NAME="SECTION05073000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limit on rank.</B>  The values for type, kind and rank passed 
into the ArraySpec
class are subject to the same limitations as Arrays.  The maximum
array rank is 7, which is the highest rank supported by Fortran.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION05074000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The information contained in an <TT>ESMF_ArraySpec</TT> is used to create 
<TT>ESMF_Array</TT> objects. 

<P>
<TT>ESMF_ArraySpec</TT> is a shallow class, and only set and get methods
are needed.  They do not need to be created or destroyed.

<H2><A NAME="SECTION05075000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05075100000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ArraySpecAssignment(=) - Assign an ArraySpec to another ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface assignment(=)
     arrayspec1 = arrayspec2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec) :: arrayspec1
     type(ESMF_ArraySpec) :: arrayspec2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set <TT>arrayspec1</TT> equal to <TT>arrayspec2</TT>. This is the default 
     Fortran assignment, which creates a complete, independent copy of 
     <TT>arrayspec2</TT> as <TT>arrayspec1</TT>. If <TT>arrayspec2</TT> is an 
     invalid <TT>ESMF_ArraySpec</TT> object then <TT>arrayspec1</TT> will be 
     equally invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec1</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to be set.
     
</DD>
<DT><STRONG>arrayspec2</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to be copied.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075200000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ArraySpecOperator(==) - Test if ArraySpec 1 is equal to ArraySpec 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (arrayspec1 == arrayspec2) then ... endif
                  OR
     result = (arrayspec1 == arrayspec2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in) :: arrayspec1
     type(ESMF_ArraySpec), intent(in) :: arrayspec2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_ArraySpec</TT> class to return 
     <TT>.true.</TT> if <TT>arrayspec1</TT> and <TT>arrayspec2</TT> specify the same
     type, kind and rank, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec1</STRONG></DT>
<DD>First <TT>ESMF_ArraySpec</TT> in comparison.
     
</DD>
<DT><STRONG>arrayspec2</STRONG></DT>
<DD>Second <TT>ESMF_ArraySpec</TT> in comparison.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075300000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ArraySpecOperator(/=) - Test if ArraySpec 1 is not equal to ArraySpec 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (arrayspec1 /= arrayspec2) then ... endif
                  OR
     result = (arrayspec1 /= arrayspec2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in) :: arrayspec1
     type(ESMF_ArraySpec), intent(in) :: arrayspec2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_ArraySpec</TT> class to return 
     <TT>.true.</TT> if <TT>arrayspec1</TT> and <TT>arrayspec2</TT> do not specify the
     same type, kind or rank, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec1</STRONG></DT>
<DD>First <TT>ESMF_ArraySpec</TT> in comparison.
     
</DD>
<DT><STRONG>arrayspec2</STRONG></DT>
<DD>Second <TT>ESMF_ArraySpec</TT> in comparison.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075400000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ArraySpecGet - Get values from an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecGet(arrayspec, rank, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec),     intent(in)            :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: rank
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns information about the contents of an <TT>ESMF_ArraySpec</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to query.
     
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum possible is 7D.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>Array typekind.  See section <A HREF="node9.html#const:typekind">54.59</A> for valid values.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075500000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ArraySpecPrint - Print ArraySpec information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecPrint(arrayspec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in)            :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print ArraySpec internals. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Specified <TT>ESMF_ArraySpec</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075600000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ArraySpecSet - Set values for an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecSet(arrayspec, rank, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec),     intent(out)           :: arrayspec
     integer,                  intent(in)            :: rank
     type(ESMF_TypeKind_Flag), intent(in)            :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a description of the data - the typekind, the rank,
     and the dimensionality.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to set.
     
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum allowed is 7D.
     
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind.  See section <A HREF="node9.html#const:typekind">54.59</A> for valid values.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075700000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ArraySpecValidate - Validate ArraySpec internals</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecValidate(arrayspec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in)            :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>arrayspec</TT> is internally consistent.
     The method returns an error code if problems are found.  

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Specified <TT>ESMF_ArraySpec</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION05080000000000000000">
<SPAN CLASS="arabic">31</SPAN> Grid Class</A>
</H1>

<H2><A NAME="SECTION05081000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF Grid class is used to describe the geometry and discretization
of logically rectangular physical grids.  It also contains the
description of the grid's underlying topology and the decomposition
of the physical grid across the available computational resources.
The most frequent use of the Grid class is to describe physical grids
in user code so that sufficient information is available to perform ESMF
methods such as regridding.  

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Representation of grids formed by logically rectangular regions,
including uniform and rectilinear grids (e.g. lat-lon grids),
curvilinear grids (e.g. displaced pole grids), and grids formed
by connected logically rectangular regions (e.g. cubed sphere grids).</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for 1D, 2D, 3D, and higher dimension grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Distribution of grids across computational resources for parallel
operations - users set which grid dimensions are distributed.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Grids can be created already distributed, so that no single
resource needs global information during the creation process.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options to define periodicity and other edge connectivities either 
explicitly or implicitly via shape shortcuts.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for users to define grid coordinates themselves or to call
prefabricated coordinate generation routines for standard grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for incremental construction of grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for using a set of pre-defined stagger locations or for setting
custom stagger locations.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION05081100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Representation in ESMF</A>
</H3>

<P>
ESMF Grids are based on the concepts described in <I>A Standard
Description of Grids Used in Earth System Models</I> [Balaji 2006].  In this document
Balaji introduces the mosaic concept as a means of describing
a wide variety of Earth system model grids.  A <B>mosaic</B> is
composed of grid tiles connected at their edges.  Mosaic grids
includes simple, single tile grids as a special case.  

<P>
The ESMF Grid class is a representation of a mosaic grid.  Each ESMF
Grid is constructed of one or more logically rectangular <B>Tiles</B>.
A Tile will usually have some physical significance (e.g. the region
of the world covered by one face of a cubed sphere grid).

<P>
The piece of a Tile that resides on one DE (for simple cases, a DE
can be thought of as a processor - see section on the DELayout)
is called a <B>LocalTile</B>.  For example, the six faces of a cubed
sphere grid are each Tiles, and each Tile can be divided into many
LocalTiles.  

<P>
Every ESMF Grid contains a DistGrid object, which defines the Grid's
index space, topology, distribution, and connectivities.  It enables
the user to define the complex edge relationships of tripole and other
grids.  The DistGrid can be created explicitly and passed into a Grid
creation routine, or it can be created implicitly if the user takes
a Grid creation shortcut. The DistGrid used
in Grid creation describes the properties of the Grid cells. In addition
to this one, the Grid internally creates DistGrids for each stagger location. 
These stagger DistGrids are related to the original DistGrid, but may 
contain extra padding to represent the extent of the index space of
the stagger. These DistGrids are what are used when a Field is created 
on a Grid. 

<P>

<H3><A NAME="SECTION05081200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Grids</A>
</H3>

<P>
The range of supported grids in ESMF can be defined by:

<UL>
<LI>Types of topologies and shapes supported.  ESMF supports one or
more logically rectangular grid Tiles with connectivities specified
between cells.  For more details see section <A HREF="#sec:ShapeShortcut">31.1.3</A>.
</LI>
<LI>Types of distributions supported.  ESMF supports  regular,
irregular, or arbitrary distributions of data.  
For more details see section <A HREF="#sec:desc:dist">31.1.4</A>.
</LI>
<LI>Types of coordinates supported.  ESMF supports uniform, rectilinear,
and curvilinear coordinates.  For more details see section <A HREF="#sec:coordspec">31.1.5</A>.
</LI>
</UL>

<P>

<H3><A NAME="SECTION05081300000000000000"></A>
<A NAME="sec:ShapeShortcut"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Grid Topologies and Periodicity
</H3>

ESMF has shortcuts for the creation of standard Grid topologies 
or <B>shapes</B> up to 3D.  In many cases, these enable the user to
bypass the step of creating a DistGrid before creating the Grid. 
There are two sets of methods which allow the user to do this. These two sets of methods cover the same set of topologies, but
allow the user to specify them in different ways.

<P>
The first set of these are a group of overloaded
calls broken up by the number of periodic dimensions they specify. With these the user can pick 
the method which creates a Grid with the number of periodic dimensions they need, and then specify other connectivity 
options via arguments to the method. The following is a description of these methods:

<P>

<P>
<BR>

<P>
<DL>
<DT><STRONG>ESMF_GridCreateNoPeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with no edge connections, for example, a regional Grid with closed boundaries.

<P>
</DD>
<DT><STRONG>ESMF_GridCreate1PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 1 periodic dimension and supports a range of options for what to do at the pole (see&nbsp;Section&nbsp;<A HREF="#const:polekind">31.2.5</A>). Some examples of Grids which can be created here are tripole spheres, bipole spheres, cylinders with open poles. 

<P>
</DD>
<DT><STRONG>ESMF_GridCreate2PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 2 periodic dimensions, for example a torus, or a regional Grid with
doubly periodic boundaries. 
</DD>
</DL>

<P>
More detailed information can be found in the API description of each.

<P>

<P>
<BR>

<P>
The second set of shortcut methods is a set of methods overloaded under the name <TT>ESMF_GridCreate()</TT>. These methods
allow the user to specify the connectivites at the end of each dimension, by using the ESMF_GridConn_Flag flag. The table below shows the ESMF_GridConn_Flag settings used to create 
standard shapes in 2D using the ESMF_GridCreate() call.  Two values
are specified for each dimension, one for the low end and one for 
the high end of the dimension's index values.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">2D Shape</TD>
<TD ALIGN="CENTER"><B>connflagDim1(1)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim1(2)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim2(1)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim2(2)</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Rectangle</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Bipole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Tripole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">BIPOLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Cylinder</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Torus</B></TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
</TABLE>

<P>
<BR>

<P>
If the user's grid shape is too complex for an ESMF shortcut routine,
or involves more than three dimensions, a DistGrid can be created
to specify the shape in detail.  This DistGrid is then passed
into a Grid create call.

<P>

<H3><A NAME="SECTION05081400000000000000"></A>
<A NAME="sec:desc:dist"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Grid Distribution
</H3>

<P>
ESMF Grids have several options for data distribution (also referred to
as decomposition).  As ESMF Grids are cell based, these 
options are all specified  in terms of how the cells in the Grid
are broken up between DEs. 

<P>
The main distribution options are regular, irregular, and arbitrary.
A <B>regular</B> distribution is one in which the same number of
contiguous grid cells are assigned to each DE in the
distributed dimension.  An <B>irregular</B> distribution is one in which
unequal numbers of contiguous grid cells are assigned to each
DE in the distributed dimension.  An <B>arbitrary</B> distribution is
one in which any grid cell can be assigned to any DE.  Any of these
distribution options can be applied to any of the grid shapes (i.e.,
rectangle) or types (i.e., rectilinear).  Support for arbitrary distribution 
is limited in the current version of ESMF, see Section <A HREF="#example:ArbGridWithUndistDim">31.3.7</A> for
an example of creating a Grid with an arbitrary distribution.

<P>
Figure <A HREF="#fig:GridDecomps">13</A> illustrates options for distribution.

<DIV ALIGN="CENTER"><A NAME="fig:GridDecomps"></A><A NAME="57149"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 13:</STRONG>
Examples of regular and irregular decomposition of
a grid <B>a</B> that is 6x6, and an arbitrary decomposition of
a grid <B>b</B> that is 6x3.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{GridDecomps}}$
 -->
<IMG
 WIDTH="630" HEIGHT="192" ALIGN="BOTTOM" BORDER="0"
 SRC="img79.png"
 ALT="\scalebox{0.9}{\includegraphics{GridDecomps}}"></TD></TR>
</TABLE>
</DIV>

<P>
A distribution can also be specified using the DistGrid, by passing
object into a Grid create call.

<P>

<H3><A NAME="SECTION05081500000000000000"></A>
<A NAME="sec:coordspec"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Coordinates
</H3>
Grid Tiles can have uniform, rectilinear, or curvilinear
coordinates.  The coordinates of <B>uniform</B> grids are equally spaced along
their axes, and can be fully specified by the coordinates of the two opposing points
that define the grid's physical span.  The coordinates of <B>rectilinear</B> grids
are unequally spaced along their axes, and can be fully specified by giving
the spacing of grid points along each axis.  The coordinates of <B>curvilinear 
grids</B> must be specified by giving the explicit set of coordinates for each
grid point.  Curvilinear grids are often uniform or rectilinear grids that 
have been warped; for example, to place a pole over a land mass so that it
does not affect the computations performed on an ocean model grid.  Figure
<A HREF="#fig:LogRectGrids">14</A> shows examples of each type of grid.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:LogRectGrids"></A><A NAME="57121"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 14:</STRONG>
Types of logically rectangular grid tiles.  Red circles show the
values needed to specify grid coordinates for each type.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{LogRectGrids}}$
 -->
<IMG
 WIDTH="636" HEIGHT="210" ALIGN="BOTTOM" BORDER="0"
 SRC="img80.png"
 ALT="\scalebox{0.9}{\includegraphics{LogRectGrids}}"></TD></TR>
</TABLE>
</DIV>

<P>
Each of these coordinate types can be set for each of the standard grid shapes
described in section <A HREF="#sec:ShapeShortcut">31.1.3</A>.  

<P>
The table below shows how examples of common single Tile grids fall 
into this shape and coordinate taxonomy.  Note that any
of the grids in the table can have a regular or arbitrary distribution.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Uniform</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Rectilinear</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Curvilinear</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58><B>Sphere</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Global uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Gaussian grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Displaced pole grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58><B>Rectangle</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Regional uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Gaussian grid section</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Polar stereographic grid section</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION05081600000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Coordinate Specification and Generation</A>
</H3>

<P>
There are two ways of specifying coordinates in ESMF.  The
first way is for the user to <B>set</B> the coordinates.  The second 
way is to take a shortcut and have the framework <B>generate</B>
the coordinates.  

<P>
See Section&nbsp;<A HREF="#sec:usage:staggerloc">31.3.13</A> for more description and examples of
setting coordinates.

<P>

<H3><A NAME="SECTION05081700000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> Staggering</A>
</H3>

<P>
<B>Staggering</B> is a finite difference technique in which the values 
of different physical quantities are placed at different locations
within a grid cell. 

<P>
The ESMF Grid class supports a variety of stagger locations, including
cell centers, corners, and edge centers. The default stagger location in 
ESMF is the cell center, and cell counts in Grid are based on this assumption.
Combinations of the 2D ESMF stagger locations are sufficient to specify any of the
Arakawa staggers.  ESMF also supports staggering in 3D and higher dimensions.
There are shortcuts for standard staggers, and interfaces through which users 
can create custom staggers.  

<P>
As a default the ESMF Grid class provides symmetric staggering, so
that cell centers are enclosed by cell perimeter (e.g. corner) 
stagger locations. This means the coordinate arrays for stagger
locations other than the center will have an additional element of 
padding in order to enclose the cell center locations.
However, to achieve other types of staggering, the user may alter 
or eliminate this padding by using the appropriate options when adding
coordinates to a Grid. 

<P>
In the current release, only the cell center stagger location is supported for an
arbitrarily distributed grid. For examples and a full description of the stagger interface 
see Section&nbsp;<A HREF="#sec:usage:staggerloc">31.3.13</A>. 

<P>

<H3><A NAME="SECTION05081800000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> Masking</A>
</H3>

<P>
Masking is the process whereby parts of a Grid can be marked to be
ignored during an operation.  For a description of how to set mask information in
the Grid, see here <A HREF="#sec:usage:items">31.3.17</A>. For a description of how masking works
in regridding, see here <A HREF="#regrid:masking">24.2.10</A>.

<H2><A NAME="SECTION05082000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05082100000000000000"></A>
<A NAME="const:gridconn"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GRIDCONN
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

The <TT>ESMF_GridCreateShapeTile</TT> command has three specific arguments
<TT>connflagDim1</TT>, <TT>connflagDim2</TT>, and <TT>connflagDim3</TT>. These can be used
to setup different types of connections at the ends of each dimension
of a Tile.  Each of these parameters is a two element array. The first
element is the connection type at the minimum end of the dimension
and the second is the connection type at the maximum end. The default
value for all the connections is ESMF_GRIDCONN_NONE, specifying no
connection.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GridConn_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDCONN_NONE</STRONG></DT>
<DD>No connection.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_PERIODIC</STRONG></DT>
<DD>Periodic connection.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_POLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element ((i+n/2) mod n).

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i+1.
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082200000000000000"></A>
<A NAME="const:griditem"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GRIDITEM
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
The ESMF Grid can contain other kinds of data besides coordinates. 
This data is referred to as Grid &ldquo;items&rdquo;. Some items may be used
by ESMF for calculations involving the Grid. The following
are the valid values of ESMF_GridItem_Flag.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GridItem_Flag)</TT>

<P>
The valid values are:
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Item Label</TD>
<TD ALIGN="CENTER"><B>Type Restriction</B></TD>
<TD ALIGN="CENTER"><B>Type Default</B></TD>
<TD ALIGN="CENTER"><B>ESMF Uses</B></TD>
<TD ALIGN="CENTER"><B>Controls</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_GRIDITEM_MASK</B></TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_I4</TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_I4</TD>
<TD ALIGN="CENTER">YES</TD>
<TD ALIGN="CENTER">Masking in Regrid</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_GRIDITEM_AREA</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_R8</TD>
<TD ALIGN="CENTER">YES</TD>
<TD ALIGN="CENTER">Conservation in Regrid</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<B>NOTE:</B> One important thing to consider when setting areas in the Grid using <TT>ESMF_GRIDITEM_AREA</TT>,
  ESMF doesn't currently do unit conversion on areas. If these areas are going to be used
 in a process that also involves the areas of another Grid or Mesh (e.g. conservative regridding), then
 it is the user's responsibility to make sure that the area units are consistent between the two sides.
 If ESMF calculates an area on the surface of a sphere, then it is in units of square radians. If 
 it calculates the area for a Cartesian grid, then it is in the same units as the coordinates, but squared. 

<P>

<H3><A NAME="SECTION05082300000000000000"></A>
<A NAME="const:gridmatch"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GRIDMATCH
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
 This type is used to indicate the level to which two grids match.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GridMatch_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDMATCH_INVALID:</STRONG></DT>
<DD>Indicates a non-valid matching level. Returned
      if an error occurs in the matching function. If a higher matching level
      is returned then no error occurred.
</DD>
<DT><STRONG>ESMF_GRIDMATCH_NONE:</STRONG></DT>
<DD>The lowest level of grid matching. 
      This indicates that the Grid's don't match at any of the higher levels. 
</DD>
<DT><STRONG>ESMF_GRIDMATCH_EXACT:</STRONG></DT>
<DD>All the pieces of the Grid (e.g. distgrids, 
      coordinates, etc.) except the name, match between the two Grids. 
</DD>
<DT><STRONG>ESMF_GRIDMATCH_ALIAS:</STRONG></DT>
<DD>Both Grid variables are aliases to the exact
      same Grid object in memory. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082400000000000000"></A>
<A NAME="const:gridstatus"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GRIDSTATUS
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
The ESMF Grid class can exist in two states. These states are
present so that the library code can detect if a Grid has been
appropriately setup for the task at hand. The following
are the valid values of ESMF_GRIDSTATUS.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GridStatus_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDSTATUS_EMPTY:</STRONG></DT>
<DD>Status after a Grid has been created with 
      <TT>ESMF_GridEmptyCreate</TT>.  A Grid object container is allocated but
      space for internal objects is not.  Topology information and coordinate
      information is incomplete.  This object can be used in <TT>ESMF_GridEmptyComplete()</TT>
      methods in which additional information is added to the Grid.
</DD>
<DT><STRONG>ESMF_GRIDSTATUS_COMPLETE:</STRONG></DT>
<DD>The Grid has a specific topology and
      distribution, but incomplete coordinate arrays.  The Grid can be used
      as the basis for allocating a Field, and coordinates can be added
      via <TT>ESMF_GridCoordAdd()</TT> to allow other functionality. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082500000000000000"></A>
<A NAME="const:polekind"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_POLEKIND
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
This type describes the type of connection that occurs at the pole when a Grid is 
created with <TT>ESMF_GridCreate1PeriodicDim()</TT>.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_PoleKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_POLEKIND_NONE</STRONG></DT>
<DD>No connection at pole.

<P>
</DD>
<DT><STRONG>ESMF_POLEKIND_MONOPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element i+n/2.

<P>
</DD>
<DT><STRONG>ESMF_POLEKIND_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i+1.
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082600000000000000"></A>
<A NAME="const:staggerloc"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_STAGGERLOC
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
 In the ESMF Grid class, data can be located at different positions in a
 Grid cell.  When setting or retrieving coordinate data the stagger location is
 specified to tell the Grid method  from where in the cell to get the data. 
 Although the user may define their own custom stagger locations, 
 ESMF provides a set of predefined locations for ease of use. The
following are the valid predefined stagger locations. 

<P>

<P>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridstaggerloc2d"></A><A NAME="57366"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 15:</STRONG>
2D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}$
 -->
<IMG
 WIDTH="465" HEIGHT="275" ALIGN="BOTTOM" BORDER="0"
 SRC="img81.png"
 ALT="\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The 2D predefined stagger locations (illustrated in figure&nbsp;<A HREF="#fig:gridstaggerloc2d">15</A>) are:
<BR><DL>
<DT><STRONG>ESMF_STAGGERLOC_CENTER:</STRONG></DT>
<DD>The center of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER:</STRONG></DT>
<DD>The corners of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1:</STRONG></DT>
<DD>The edges offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2:</STRONG></DT>
<DD>The edges offset from the center in the 2nd dimension.
</DD>
</DL>

<P>

<P>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridstaggerloc3d"></A><A NAME="57377"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 16:</STRONG>
3D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}$
 -->
<IMG
 WIDTH="433" HEIGHT="333" ALIGN="BOTTOM" BORDER="0"
 SRC="img82.png"
 ALT="\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The 3D predefined stagger locations (illustrated in figure&nbsp;<A HREF="#fig:gridstaggerloc3d">16</A>) are:
<BR><DL>
<DT><STRONG>ESMF_STAGGERLOC_CENTER_VCENTER:</STRONG></DT>
<DD>The center of the 3D cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER_VCENTER:</STRONG></DT>
<DD>Half way up the vertical edges of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 1 and the vertical dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 2 and the vertical dimension. 
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER_VFACE:</STRONG></DT>
<DD>The corners of the 3D cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 2nd dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CENTER_VFACE:</STRONG></DT>
<DD>The center of the top and bottom face. The face bounded by the 1st and 2nd dimensions. 
</DD>
</DL>

<H2><A NAME="SECTION05083000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
This section describes the use of the ESMF Grid class. It first discusses
the more user friendly shape specific interface to the Grid. 
During this discussion it covers creation and options, 
adding stagger locations, coordinate data access, and other grid 
functionality. After this initial phase the document discusses 
the more advanced options which the user can employ should they
need more customized interaction with the Grid class.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05083100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Create single-tile Grid shortcut method</A>
</H3>

<P>
The set of methods <TT>ESMF_GridCreateNoPeriDim()</TT>, <TT>ESMF_GridCreate1PeriDim()</TT>,
   <TT>ESMF_GridCreate2PeriDim()</TT>, and <TT>ESMF_GridCreate()</TT> are shortcuts
   for building 2D or 3D single tile logically rectangular Grids.
   These methods support all three types of distributions described in
   Section&nbsp;<A HREF="#sec:desc:dist">31.1.4</A>: regular, irregular and arbitrary.

<P>
The ESMF Grid is cell based and so for all distribution
   options the methods take as input the number of cells to describe
   the total index space and the number of cells to specify distribution.

<P>
To create a Grid
   with a regular distribution the user specifies the global
   maximum and minimum ranges of the Grid cell index space (<TT>maxIndex</TT> and
   <TT>minIndex</TT>), and the number of pieces in which to partition
   each dimension (via a <TT>regDecomp</TT> argument).
   ESMF then divides the index space as evenly as possible
   into the specified number of pieces. If there are cells
   left over then they are distributed one per DE starting from
   the first DE until they are gone.

<P>
If <TT>minIndex</TT> is
   not specified, then the bottom of the Grid cell index range is assumed
   to be (1,1,...,1). If <TT>regDecomp</TT> is not specified, then
   by default ESMF creates a distribution that partitions the
   grid cells in the first dimension (e.g. NPx1x1...1) as evenly
   as possible by  the number of PETs NP.
   The remaining dimensions are not partitioned.
   The dimension of the Grid is the size of <TT>maxIndex</TT>.
   The following is an example of creating a 10x20x30 3D grid
   where the first dimensions is broken into 2 pieces, the second
   is broken into 4 pieces, and the third is not divided (i.e. every DE will
   have length 30 in the 3rd dimension).
<P>
<PRE>
  grid3D=ESMF_GridCreateNoPeriDim(regDecomp=(/2,4,1/), maxIndex=(/10,20,30/), &amp;
           rc=rc)
</PRE>

<P>
Irregular distribution requires the user to specify the
   exact number of Grid cells per DE in each dimension.  In the
   <TT>ESMF_GridCreateNoPeriDim()</TT> call the <TT>countsPerDEDim1</TT>,
   <TT>countsPerDim2</TT>, and <TT>countsPerDim3</TT>
   arguments are used to specify a rectangular distribution
   containing size(countsPerDEDim1) by size(countsPerDEDim2) by
   size(countsPerDEDim3) DEs. The entries in each of these arrays
   specify the number of grid cells per DE in that dimension.
   The dimension of the grid is determined by the presence of
   <TT>countsPerDEDim3</TT>.  If it's present the Grid
   will be 3D. If just <TT>countsPerDEDim1</TT> and
   <TT>countsPerDEDim2</TT> are specified the Grid
   will be 2D.

<P>
The following call illustrates the creation of
   a 10x20 two dimensional rectangular Grid distributed across six DEs
   that are arranged 2x3.  In the first dimension there are 3 grid
   cells on the first DE and 7 cells on the second DE.  The second
   dimension has 3 DEs with 11,2, and 7 cells, respectively.
<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/3,7/), &amp;
          countsPerDEDim2=(/11,2,7/), rc=rc)
</PRE>

<P>
To add a distributed third dimension of size 30, broken up into
   two groups of 15, the above call would be altered as follows.
<P>
<PRE>
   grid3d=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/3,7/), &amp;
          countsPerDEDim2=(/11,2,7/), countsPerDEDim3=(/15,15/), rc=rc)
</PRE>

<P>
To make a third dimension distributed across only 1 DE, then
   <TT>countsPerDEDim3</TT> in the call should only have a single term.
<P>
<PRE>
   grid3D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/3,7/),  &amp;
          countsPerDEDim2=(/11,2,7/), countsPerDEDim3=(/30/), rc=rc)
</PRE>

<P>
The <TT>petMap</TT> parameter may be used to specify on to which specific PETs
   the DEs in the Grid are assigned. Each entry in <TT>petMap</TT> specifies to which PET the corresponding
   DE should be assigned. For example, <TT>petMap(3,2)=4</TT> tells the Grid
   create call to put the DE located at column 3 row 2 on PET 4.
   Note that this parameter is only available for the
   regular and irregular distribution types. The <TT>petMap</TT>
   array is a 3D array, for a 3D Grid each of its dimensions correspond to a
   Grid dimension. If the Grid is 2D, then the first two dimensions correspond
   to Grid dimensions and the last dimension should be of size 1.
   The size of each <TT>petMap</TT> dimension is
   the number of DE's along that dimension in the Grid. For a
   regular Grid, the size is equal to the number in regDecomp
   (i.e. <TT>size(petMap,d)=regDecomp(d)</TT> for all dimensions <TT>d</TT> in the Grid). For
   an irregular Grid the size is equal to the number of items in
   the corresponding <TT>countsPerDEDim</TT> variable (i.e.
   <TT>size(petMap,d)=size(countsPerDEDimd)</TT> for all dimensions <TT>d</TT> in the Grid).
   The following example demonstrates how to specify the PET to DE association
   for an <TT>ESMF_GridCreateNoPeriDim()</TT> call.
   
  
<P>
<PRE>
   ! allocate memory for petMap
   allocate( petMap(2,2,1) )

   ! Set petMap
   petMap(:,1,1) = (/3,2/) ! DE (1,1,1) on PET 3 and DE (2,1,1) on PET 2
   petMap(:,2,1) = (/1,0/) ! DE (1,2,1) on PET 1 and DE (2,2,1) on PET 0


   ! Let the 3D grid be be distributed only in the first two dimensions.
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/3,7/), &amp;
           countsPerDEDim2=(/7,6/), petMap=petMap, rc=rc)
</PRE>

<P>
To create an grid with arbitrary distribution, the user specifies the global minimum and maximum
   ranges of the index space with the
   arguments <TT>minIndex</TT> and <TT>maxIndex</TT>, the total number of cells and their index space locations
   residing on the local PET through a <TT>localArbIndexCount</TT> and a <TT>localArbIndex</TT>
   argument. <TT>localArbIndex</TT> is a 2D array with size <TT>(localArbIndexCount, n)</TT> where n is the total number
   dimensions distributed arbitrarily.
   Again, if <TT>minIndex</TT> is  not specified, then the bottom of the
   index range is assumed to be (1,1,...).
   The dimension of the Grid is equal to the size of <TT>maxIndex</TT>.
   If n (number of arbitrarily distributed dimension) is less than the grid dimension, an optional
   argument <TT>distDim</TT> is used to specify which of the grid dimension is arbitrarily distributed.
   If not given, the first n dimensions are assumed to be distributed.

<P>
The following example creates a 2D Grid of dimensions 5x5, and places
   the diagonal elements (i.e. indices (i,i) where i goes from 1 to 5)
   on the local PET. The remaining PETs would individually declare
   the remainder of the Grid locations.
<P>
<PRE>
   ! allocate memory for localArbIndex
   allocate( localArbIndex(5,2) )
   ! Set local indices
   localArbIndex(1,:)=(/1,1/)
   localArbIndex(2,:)=(/2,2/)
   localArbIndex(3,:)=(/3,3/)
   localArbIndex(4,:)=(/4,4/)
   localArbIndex(5,:)=(/5,5/)

   ! Create a 2D Arbitrarily distributed Grid
   grid2D=ESMF_GridCreateNoPeriDim(maxIndex=(/5,5/), &amp;
         arbIndexList=localArbIndex, arbIndexCount=5, rc=rc)
</PRE>

<P>
To create a 3D Grid of dimensions 5x6x5 with the first and the third dimensions distributed arbitrarily,
   <TT>distDim</TT> is used.
<P>
<PRE>
   ! Create a 3D Grid with the 1st and 3rd dimension arbitrarily distributed
   grid3D=ESMF_GridCreateNoPeriDim(maxIndex=(/5,6,5/), &amp;
         arbIndexList=localArbIndex, arbIndexCount=5, &amp;
         distDim=(/1,3/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05083200000000000000"></A>
   <A NAME="example:2DRegUniGrid"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Create a 2D regularly distributed rectilinear Grid
                    with uniformly spaced coordinates
</H3>

<P>
The following is an example of creating a simple rectilinear grid
   and loading in a set of coordinates. It illustrates a straightforward use
   of the <TT>ESMF_GridCreateNoPeriDim()</TT> call described in the previous section.
   This code creates a 10x20 2D grid with uniformly spaced coordinates varying from (10,10) to (100,200).
   The grid is partitioned using a regular distribution. The first dimension
   is divided into two pieces, and the second dimension is divided into 3.
   This example assumes that the code is being run with a 1-1 mapping between
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs.
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user.
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! topology and distribution of the Grid, and specify that it
   ! will have global indices.  Note that here aperiodic bounds are
   ! specified by the argument name. In this call the minIndex hasn't
   ! been set, so it defaults to (1,1,...). The default is to
   ! divide the index range as equally as possible among the DEs
   ! specified in regDecomp. This behavior can be changed by
   ! specifying decompFlag.
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateNoPeriDim(          &amp;
         ! Define a regular distribution
         maxIndex=(/10,20/), &amp; ! define index space
         regDecomp=(/2,3/),  &amp; ! define how to divide among DEs
         coordSys=ESMF_COORDSYS_CART, &amp;
         ! Specify mapping of coords dim to Grid dim
         coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
         coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
         indexflag=ESMF_INDEX_GLOBAL, &amp;
         rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordX, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
        coordX(i) = i*10.0
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordY, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
        coordY(j) = j*10.0
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083300000000000000"></A>
   <A NAME="example:2DPeriRegUniGrid"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Create a periodic 2D regularly distributed rectilinear Grid
</H3>

<P>
The following is an example of creating a simple rectilinear grid
   with a periodic dimension and loading in a set of coordinates. It illustrates a straightforward use
   of the <TT>ESMF_GridCreate1PeriDim()</TT> call described in the previous section.
   This code creates a 360x180 2D grid with uniformly spaced coordinates varying from (1,1) to (360,180).
   The grid is partitioned using a regular distribution. The first dimension
   is divided into two pieces, and the second dimension is divided into 3.
   This example assumes that the code is being run with a 1-1 mapping between
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs.
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user.
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! topology and distribution of the Grid, and specify that it
   ! will have global indices.  Note that here a single periodic connection
   ! is specified by the argument name. In this call the minIndex hasn't
   ! been set, so it defaults to (1,1,...). The default is to
   ! divide the index range as equally as possible among the DEs
   ! specified in regDecomp. This behavior can be changed by
   ! specifying decompFlag. Since the coordinate system is
   ! not specified, it defaults to ESMF_COORDSYS_SPH_DEG.
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreate1PeriDim(          &amp;
         ! Define a regular distribution
         maxIndex=(/360,180/), &amp; ! define index space
         regDecomp=(/2,3/),  &amp; ! define how to divide among DEs
         ! Specify mapping of coords dim to Grid dim
         coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
         coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
         indexflag=ESMF_INDEX_GLOBAL, &amp;
         rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordX, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
        coordX(i) = i*1.0
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordY, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
        coordY(j) = j*1.0
   enddo
</PRE>

<P>
The remaining examples in this section will use the irregular
   distribution because of its greater generality. To create code similar to these, but
   using a regular distribution, replace the <TT>countsPerDEDim</TT> arguments
   in the Grid create with the appropriate <TT>maxIndex</TT> and <TT>regDecomp</TT> arguments.

<P>

<H3><A NAME="SECTION05083400000000000000"></A>
   <A NAME="example:2DIrregUniGrid"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Create a 2D irregularly distributed rectilinear Grid
                    with uniformly spaced coordinates
</H3>

<P>
This example serves as an illustration of the difference between using
   a regular and irregular distribution. It repeats the previous example
   except using an irregular distribution to give the user more control
   over how the cells are divided between the DEs. As before, this code
   creates a 10x20 2D Grid with uniformly spaced coordinates  varying from (10,10) to (100,200).
   In this example, the Grid is partitioned using an irregular distribution. The first dimension
   is divided into two pieces, the first with 3 Grid cells per
   DE and the second with 7 Grid cells per DE. In the second dimension,
   the Grid is divided into 3 pieces, with 11, 2, and 7 cells per DE respectively.
   This example assumes that the code is being run with a 1-1 mapping between
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs.
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user.
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! topology and distribution of the Grid, and specify that it
   ! will have global coordinates.  Note that aperiodic bounds are
   ! indicated by the method name. In this call the minIndex hasn't
   ! been set, so it defaults to (1,1,...).
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateNoPeriDim(          &amp;
            ! Define an irregular distribution
            countsPerDEDim1=(/3,7/),    &amp;
            countsPerDEDim2=(/11,2,7/), &amp;
            ! Specify mapping of coords dim to Grid dim
            coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
            coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
            indexflag=ESMF_INDEX_GLOBAL, &amp;
            rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordX, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
        coordX(i) = i*10.0
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordY, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
        coordY(j) = j*10.0
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083500000000000000"></A>
   <A NAME="example:2DIrregCurviGrid"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Create a 2D irregularly distributed Grid
                    with curvilinear coordinates
</H3>

<P>
The following is an example of creating a simple curvilinear Grid and
   loading in a set of coordinates. It creates a 10x20
   2D Grid where the coordinates vary along every dimension.
   The Grid is partitioned using an irregular distribution. The first dimension
   is divided into two pieces, the first with 3 Grid cells per
   DE and the second with 7 Grid cells per DE. In the second dimension,
   the Grid is divided into 3 pieces, with 11, 2, and 7 cells per DE respectively.
   This example assumes that the code is being run with a 1-1 mapping between
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs.
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user.
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! distribution of the Grid, and specify that it
   ! will have global indices.  Note that aperiodic bounds are
   ! indicated by the method name. If periodic bounds were desired they
   ! could be specified by using the ESMF_GridCreate1PeriDim() call.
   ! In this call the minIndex hasn't been set, so it defaults to (1,1,...).
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateNoPeriDim(      &amp;
        ! Define an irregular distribution
        countsPerDEDim1=(/3,7/),     &amp;
        countsPerDEDim2=(/11,2,7/),   &amp;
        ! Specify mapping of coords dim to Grid dim
        coordDep1=(/1,2/), &amp; ! 1st coord is 2D and depends on both Grid dim
        coordDep2=(/1,2/), &amp; ! 2nd coord is 2D and depends on both Grid dim
        indexflag=ESMF_INDEX_GLOBAL, &amp;
        rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordX2D, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do j=lbnd(2),ubnd(2)
   do i=lbnd(1),ubnd(1)
        coordX2D(i,j) = i+j
   enddo
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordY2D, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(2),ubnd(2)
   do i=lbnd(1),ubnd(1)
        coordY2D(i,j) = j-i/100.0
   enddo
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083600000000000000"></A>
   <A NAME="example:CurviGridWithUndistDim"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create an irregularly distributed rectilinear Grid with
                  a non-distributed vertical dimension
</H3>

<P>
This example demonstrates how a user can build a rectilinear
   horizontal Grid with a non-distributed vertical dimension. The Grid
   contains both the center and corner stagger locations (i.e. Arakawa
   B-Grid). In contrast to the previous examples, this example doesn't
   assume that the code is being run with a 1-1 mapping between
   PETs and DEs. It should work when run on any number of PETs.
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object.  The
   ! Grid is defined to be 180 Grid cells in the first dimension
   ! (e.g. longitude), 90 Grid cells in the second dimension
   ! (e.g. latitude), and 40 Grid cells in the third dimension
   ! (e.g. height).  The first dimension is decomposed over 4 DEs,
   ! the second over 3 DEs, and the third is not distributed.
   ! The connectivities in each dimension are set to aperiodic
   ! by this method. In this call the minIndex hasn't been set,
   ! so it defaults to (1,1,...).
   !-------------------------------------------------------------------
   grid3D=ESMF_GridCreateNoPeriDim( &amp;
            ! Define an irregular distribution
            countsPerDEDim1=(/45,75,40,20/), &amp;
            countsPerDEDim2=(/30,40,20/),    &amp;
            countsPerDEDim3=(/40/),          &amp;
            ! Specify mapping of coords dim to Grid dim
            coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
            coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
            coordDep3=(/3/), &amp; ! 3rd coord is 1D and depends on 3rd Grid dim
            indexflag=ESMF_INDEX_GLOBAL,     &amp; ! Use global indices
            rc=rc)
</PRE>

<P>
<PRE>
        

   !-------------------------------------------------------------------
   ! Allocate coordinate storage for both center and corner stagger
   ! locations.  Since no coordinate values are specified in this
   ! call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER, rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER_VCENTER, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get the number of DEs on this PET, so that the program
   ! can loop over them when accessing data.
   !-------------------------------------------------------------------
   call ESMF_GridGet(grid3D, localDECount=localDECount, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Loop over each localDE when accessing data
   !-------------------------------------------------------------------
   do lDE=0,localDECount-1

    !------------------------------------------------------------------
    ! Fill in the coordinates for the corner stagger location first.
    !------------------------------------------------------------------
      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the first
      ! coordinate array on the local DE. If the number of PETs
      ! is less than the total number of DEs then the rest of this
      ! example would be in a loop over the local DEs.  Also get the
      ! pointer to the first coordinate array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=lDE, &amp;
             staggerLoc=ESMF_STAGGERLOC_CORNER_VCENTER,       &amp;
             computationalLBound=lbnd_corner,                 &amp;
             computationalUBound=ubnd_corner,                 &amp;
             farrayPtr=cornerX, rc=rc)
</PRE>

<P>
<PRE>
      !----------------------------------------------------------------
      ! Calculate and set coordinates in the first dimension.
      !----------------------------------------------------------------
      do i=lbnd_corner(1),ubnd_corner(1)
         cornerX(i) = (i-1)*(360.0/180.0)
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the second
      ! coordinate array on the local DE.  Also get the pointer to the
      ! second coordinate array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=lDE,   &amp;
             staggerLoc=ESMF_STAGGERLOC_CORNER_VCENTER,         &amp;
             computationalLBound=lbnd_corner,                   &amp;
             computationalUBound=ubnd_corner,                   &amp;
             farrayPtr=cornerY, rc=rc)
</PRE>

<P>
<PRE>
      !----------------------------------------------------------------
      ! Calculate and set coordinates in the second dimension.
      !----------------------------------------------------------------
      do j=lbnd_corner(1),ubnd_corner(1)
         cornerY(j) = (j-1)*(180.0/90.0)
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the third
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=lDE,   &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,         &amp;
             computationalLBound=lbnd, computationalUBound=ubnd,&amp;
             farrayPtr=cornerZ, rc=rc)
</PRE>

<P>
<PRE>
      !----------------------------------------------------------------
      ! Calculate and set the vertical coordinates
      !----------------------------------------------------------------
      do k=lbnd(1),ubnd(1)
         cornerZ(k) = 4000.0*( (1./39.)*(k-1)  )**2
      enddo

    !------------------------------------------------------------------
    ! Now fill the coordinates for the center stagger location with
    ! the average of the corner coordinate location values.
    !------------------------------------------------------------------
      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the first
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=lDE,    &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,          &amp;
             computationalLBound=lbnd, computationalUBound=ubnd, &amp;
             farrayPtr=centerX, rc=rc)
</PRE>

<P>
<PRE>
      !----------------------------------------------------------------
      ! Calculate and set coordinates in the first dimension.
      !----------------------------------------------------------------
      do i=lbnd(1),ubnd(1)
         centerX(i) = 0.5*(i-1 + i)*(360.0/180.0)
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the second
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
       call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=lDE,    &amp;
              staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,          &amp;
              computationalLBound=lbnd, computationalUBound=ubnd, &amp;
              farrayPtr=centerY, rc=rc)
</PRE>

<P>
<PRE>
      !----------------------------------------------------------------
      ! Calculate and set coordinates in the second dimension.
      !----------------------------------------------------------------
      do j=lbnd(1),ubnd(1)
         centerY(j) = 0.5*(j-1 + j)*(180.0/90.0)
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the third
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=lDE,   &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,         &amp;
             computationalLBound=lbnd, computationalUBound=ubnd,&amp;
             farrayPtr=centerZ, rc=rc)
</PRE>

<P>
<PRE>
      !----------------------------------------------------------------
      ! Calculate and set the vertical coordinates
      !----------------------------------------------------------------
      do k=lbnd(1),ubnd(1)
         centerZ(k) = 4000.0*( (1./39.)*(k-1)  )**2
      enddo

   !-------------------------------------------------------------------
   ! End of loop over DEs
   !-------------------------------------------------------------------
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083700000000000000"></A>
   <A NAME="example:ArbGridWithUndistDim"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Create an arbitrarily distributed rectilinear Grid with
                  a non-distributed vertical dimension
</H3>

<P>
There are more restrictions in defining an arbitrarily distributed grid.
   First, there is always one DE per PET.  Secondly, only local index (<TT>ESMF_INDEX_LOCAL</TT>)
   is supported. Third, only one stagger location, i.e. <TT>ESMF_STAGGERLOC_CENTER</TT> is allowed
   and last there is no extra paddings on the edge of the grid.

<P>
This example demonstrates how a user can build a 3D grid with its rectilinear
   horizontal Grid distributed arbitrarily and a non-distributed vertical dimension.
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Set up the local index array:  Assuming the grid is 360x180x10.  First
   ! calculate the localArbIndexCount and localArbIndex array for each PET
   ! based on the total number of PETs. The cells are evenly distributed in
   ! all the PETs. If the total number of cells are not divisible by the
   ! total PETs, the remaining cells are assigned to the last PET.  The
   ! cells are card dealt to each PET in y dimension first,
   ! i.e. (1,1) -&gt; PET 0, (1,2)-&gt;  PET 1, (1,3)-&gt; PET 2, and so forth.
   !-------------------------------------------------------------------
   xdim = 360
   ydim = 180
   zdim = 10
   localArbIndexCount = (xdim*ydim)/petCount
   remain = (xdim*ydim)-localArbIndexCount*petCount
   if (localPet == petCount-1) localArbIndexCount = localArbIndexCount+remain

   allocate(localArbIndex(localArbIndexCount,2))
   ind = localPet
   do i=1, localArbIndexCount
      localArbIndex(i,1)=mod(ind,ydim)+1
      localArbIndex(i,2)=ind/ydim + 1
      ind = ind + petCount
   enddo
   if (localPet == petCount-1) then
      ind = xdim*ydim-remain+1
      do i=localArbIndexCount-remain+1,localArbIndexCount
         localArbIndex(i,1)=mod(ind,ydim)+1
         localArbIndex(i,2)=ind/ydim+1
         ind = ind + 1
      enddo
   endif

   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object.
   ! the minIndex hasn't been set, so it defaults to (1,1,...). The
   ! default coordDep1 and coordDep2 are (/ESMF_DIM_ARB/) where
   ! ESMF_DIM_ARB represents the collapsed dimension for the
   ! arbitrarily distributed grid dimensions.  For the undistributed
   ! grid dimension, the default value for coordDep3 is (/3/).  The
   ! default values for coordDepX in the arbitrary distribution are
   ! different from the non-arbitrary distributions.
   !-------------------------------------------------------------------
   grid3D=ESMF_GridCreateNoPeriDim( &amp;
            maxIndex = (/xdim, ydim, zdim/), &amp;
            arbIndexList = localArbIndex, &amp;
            arbIndexCount = localArbIndexCount, &amp;
            rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate coordinate storage for the center stagger location, the
   ! only stagger location supported for the arbitrary distribution.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER, rc=rc)
</PRE>

<P>
<PRE>
   !------------------------------------------------------------------
   ! Fill in the coordinates for the center stagger location. There is
   ! always one DE per PET, so localDE is always 0
   !------------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=0, &amp;
          staggerLoc=ESMF_STAGGERLOC_CENTER,       &amp;
          computationalLBound=lbnd,                 &amp;
          computationalUBound=ubnd,                 &amp;
          farrayPtr=centerX, rc=rc)
</PRE>

<P>
<PRE>
   !----------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension.
   !----------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
      centerX(i) = (localArbIndex(i,1)-0.5)*(360.0/xdim)
   enddo


   !----------------------------------------------------------------
   ! Get the local bounds of the global indexing for the second
   ! coordinate array on the local DE, and the pointer to the array.
   !----------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=0,    &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER,                  &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=centerY, rc=rc)
</PRE>

<P>
<PRE>
   !----------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension.
   !----------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
      centerY(j) = (localArbIndex(j,2)-0.5)*(180.0/ydim)-90.0
   enddo

   !----------------------------------------------------------------
   ! Get the local bounds of the global indexing for the third
   ! coordinate array on the local DE, and the pointer to the array.
   !----------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=0,   &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER,               &amp;
          computationalLBound=lbnd, computationalUBound=ubnd,&amp;
          farrayPtr=centerZ, rc=rc)
</PRE>

<P>
<PRE>
   !----------------------------------------------------------------
   ! Calculate and set the vertical coordinates
   !----------------------------------------------------------------
   do k=lbnd(1),ubnd(1)
      centerZ(k) = 4000.0*( (1./zdim)*(k-1))**2
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083800000000000000"></A><A NAME="sec:example:2DLogRecFromScrip"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Create a curvilinear Grid using the coordinates defined
   in a SCRIP file
</H3>

<P>
ESMF supports the creation of a 2D curvilinear Grid using the coordinates
   defined in a SCRIP format Grid file&nbsp;[<A
 HREF="node8.html#ref:SCRIP">13</A>]. The grid contained in the
   file must be a 2D logically rectangular grid with <TT>grid_rank</TT> in the file set
   to 2.  The center coordinates variables <TT>grid_center_lat</TT> and <TT>grid_center_lon</TT> in the file
   are placed in the ESMF_STAGGERLOC_CENTER location.  If the parameter <TT>addCornerStagger</TT>
   in the <TT>ESMF_GridCreate</TT> call is set to .true., then
   the variables <TT>grid_corner_lat</TT> and <TT>grid_corner_lon</TT> in the file
   are used to set the ESMF_STAGGERLOC_CORNER coordinates, otherwise they are ignored.
   The values in the <TT>grid_imask</TT> variable in the file are used to set the ESMF_GRIDITEM_MASK in the Grid.

<P>
The following example code shows you how to create a 2D Grid with both center and corner coordinates
   using a SCRIP file and a row only regular distribution:
<P>
<PRE>
   grid2D = ESMF_GridCreate(filename="data/T42_grid.nc",  &amp;
              fileFormat=ESMF_FILEFORMAT_SCRIP,  &amp;
              regDecomp=(/PetCount,1/), addCornerStagger=.true., rc=rc)
</PRE>

<P>
where T42_grid.nc is a 2D global grid of size (128x64) and the resulting Grid is distributed
    by partitioning the rows evenly over all the PETs. 

<P>
ESMF also support the creation of a 2D Grid from the SCRIP format Grid file using a user specified
    ESMF_DistGrid.  The following example code demonstrates the creation of an Grid object using a pre-defined
    DistGrid.  The resulting Grid is the same as the one created above:
<P>
<PRE>
   distgrid = ESMF_DistGridCreate((/1,1/), (/128,64/), &amp;
              regDecomp=(/PetCount,1/), rc=rc)
   grid2D = ESMF_GridCreate(filename="data/T42_grid.nc",  &amp;
              fileFormat=ESMF_FILEFORMAT_SCRIP,  &amp;
              distGrid=distgrid, addCornerStagger=.true., rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05083900000000000000"></A><A NAME="sec:usage:setcommit"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Create an empty Grid in a parent Component
   for completion in a child Component
</H3>

<P>
ESMF Grids can be created incrementally. To do this,
   the user first calls <TT>ESMF_GridEmptyCreate()</TT> to allocate the shell of
   a Grid. Next, we use the <TT>ESMF_GridEmptyComplete()</TT>
   call that fills in the Grid and does an internal commit to make it usable.
   For consistency's sake the <TT>ESMF_GridSetCommitShapeTile()</TT>
   call must occur on the same or a subset of the PETs as the
    <TT>ESMF_GridEmptyCreate()</TT> call. The
   <TT>ESMF_GridEmptyComplete()</TT> call uses the VM for
   the context in which it's executed and the "empty" Grid contains
   no information about the VM in which its create was run.  This
   means that if the <TT>ESMF_GridEmptyComplete()</TT> call occurs
   in a subset of the PETs in which the <TT>ESMF_GridEmptyCreate()</TT> was
   executed that the Grid is created only in that subset. Inside the subset
   the Grid will be fine, but outside the subset the Grid objects will
   still be "empty" and not usable. The following example uses the
   incremental technique to create a rectangular 10x20 Grid with coordinates at
   the center and corner stagger locations.
   
<P>
<PRE>
!---------------------------------------------------------------------------
! IN THE PARENT COMPONENT:
! Create an empty Grid in the parent component for use in a child component.
! The parent may be defined on more PETs than the child component.
! The child's [vm or pet list] is passed into the create call so that
! the Grid is defined on the appropriate subset of the parent's PETs.
!---------------------------------------------------------------------------
   grid2D=ESMF_GridEmptyCreate(rc=rc)
</PRE>

<P>
<PRE>
!---------------------------------------------------------------------------
! IN THE CHILD COMPONENT:
! Set the Grid topology.  Here we define an irregularly distributed
! rectangular Grid.
!---------------------------------------------------------------------------
   call ESMF_GridEmptyComplete(grid2D,             &amp;
                          countsPerDEDim1=(/6,4/),      &amp;
                          countsPerDEDim2=(/10,3,7/), rc=rc)
</PRE>

<P>
<PRE>
!---------------------------------------------------------------------------
! Add Grid coordinates at the cell center location.
!---------------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CENTER, rc=rc)
</PRE>

<P>
<PRE>
!---------------------------------------------------------------------------
! Add Grid coordinates at the corner stagger location.
!---------------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831000000000000000"></A>
  <A NAME="sec:usage:cubedsphere"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Create a six-tile cubed sphere Grid
</H3>

<P>
This example creates a multi-tile Grid to represent a cubed sphere grid.
  Each of the six tiles making up the cubed sphere has 45 elements on
  each side, so the total number of elements is 45x45x6=12150.  Each tile is
  decomposed using a regular decomposition.  The first two tiles are decomposed into
  2x2 blocks each and the remaining 4 tiles are decomposed into 1x2 block.
  A total of 16 DEs are used.

<P>
In this example, both the center and corner coordinates will be added to the grid.
<P>
<PRE>
     ! Set up decomposition for each tile
     allocate(decomptile(2,6))
     decomptile(:,1)=(/2,2/) ! Tile 1
     decomptile(:,2)=(/2,2/) ! Tile 2
     decomptile(:,3)=(/1,2/) ! Tile 3
     decomptile(:,4)=(/1,2/) ! Tile 4
     decomptile(:,5)=(/1,2/) ! Tile 5
     decomptile(:,6)=(/1,2/) ! Tile 6

     ! Create cubed sphere grid
     grid2D = ESMF_GridCreateCubedSphere(tileSize=45, regDecompPTile=decomptile, &amp;
                 staggerLocList=(/ESMF_STAGGERLOC_CENTER, ESMF_STAGGERLOC_CORNER/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831100000000000000"></A>
  <A NAME="sec:usage:cubedspherewttransform"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Create a six-tile cubed sphere Grid and apply Schmidt transform
</H3>

<P>
This example creates the same cubed sphere grid with the same regular
  decomposition as in <A HREF="#sec:usage:cubedsphere">31.3.10</A> with a few differences.
  First, the coordinates of the grid are of type <TT>ESMF_TYPEKIND_R4</TT>
  instead of the default <TT>ESMF_TYPEKIND_R8</TT>. Secondly, the coordinate
  system is <TT>ESMF_COORDSYS_SPH_RAD</TT> instead of the default <TT>ESMF_COORDSYS_SPH_DEG</TT>.
  Lastly, the grid was then
  transformed using Schmidt Transformation algorithm on an arbitrary
  target point and a streatching factor.  An optional argument <TT>TransformArgs</TT> of 
  type <TT>ESMF_CubedSphereTransform_Args</TT> is used to pass the Schmidt
  Transform arguments.  <TT>ESMF_CubedSphereTransform_Args</TT> is defined as
  follows:
  <PRE>
     type ESMF_CubedSphereTransform_Args
        real(ESMF_KIND_R8) :: stretch_factor, target_lat, target_lon
     end type
</PRE>

<P>
Note <TT>target_lat</TT> and <TT>target_lon</TT> are in radians.
<P>
<PRE>
     transformArgs%stretch_factor = 0.5;
     transformArgs%target_lon = 0.0; ! in radians
     transformArgs%target_lat = 1.3; ! in radians
     grid2D = ESMF_GridCreateCubedSphere(tileSize=45, regDecompPTile=decomptile, &amp;
                 staggerLocList = (/ESMF_STAGGERLOC_CENTER, ESMF_STAGGERLOC_CORNER/), &amp;
                 coordTypeKind = ESMF_TYPEKIND_R4, &amp;
                 coordSys = ESMF_COORDSYS_SPH_RAD, &amp;
                 transformArgs=transformArgs, &amp;
                 rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831200000000000000"></A>
  <A NAME="sec:usage:cubedspherefromfile"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Create a six-tile cubed sphere Grid from a GRIDSPEC Mosaic file
</H3>

<P>
This example creates a six-tile Grid to represent a cubed sphere grid defined
  in a GRIDSPEC Mosaic file <TT>C48_mosaic.nc</TT>. The GRIDSPEC mosaic file format is defined in
  the document <A NAME="tex2html35"
  HREF="http://extranet.gfdl.noaa.gov/~vb/gridstd/gridstdse3.html#x5-220003.2">GRIDSPEC: A standard for the description of grids used in Earth System models</A>
by V. Balaji, Alistair Adcroft and Zhi Liang.

<P>
The mosaic file contains the following information:

<P>
<PRE>
  netcdf C48_mosaic {
  dimensions:
         ntiles = 6 ;
         ncontact = 12 ;
         string = 255 ;
  variables:
         char mosaic(string) ;
                 mosaic:standard_name = "grid_mosaic_spec" ;
                 mosaic:children = "gridtiles" ;
                 mosaic:contact_regions = "contacts" ;
                 mosaic:grid_descriptor = "" ;
         char gridlocation(string) ;
                 gridlocation:standard_name = "grid_file_location" ;
         char gridfiles(ntiles, string) ;
         char gridtiles(ntiles, string) ;
         char contacts(ncontact, string) ;
                 contacts:standard_name = "grid_contact_spec" ;
                 contacts:contact_type = "boundary" ;
                 contacts:alignment = "true" ;
                 contacts:contact_index = "contact_index" ;
                 contacts:orientation = "orient" ;
         char contact_index(ncontact, string) ;
                 contact_index:standard_name = "starting_ending_point_index_of_contact" ;
 
  // global attributes:
                 :grid_version = "0.2" ;
                 :code_version = "$Name: testing $" ;
  data:
  
  mosaic = "C48_mosaic" ;
  
  gridlocation = "/archive/z1l/tools/test_20091028/output_all/" ;
  
  gridfiles =
    "horizontal_grid.tile1.nc",
    "horizontal_grid.tile2.nc",
    "horizontal_grid.tile3.nc",
    "horizontal_grid.tile4.nc",
    "horizontal_grid.tile5.nc",
    "horizontal_grid.tile6.nc" ;
  
  gridtiles =
    "tile1",
    "tile2",
    "tile3",
    "tile4",
    "tile5",
    "tile6" ;
  
  contacts =
    "C48_mosaic:tile1::C48_mosaic:tile2",
    "C48_mosaic:tile1::C48_mosaic:tile3",
    "C48_mosaic:tile1::C48_mosaic:tile5",
    "C48_mosaic:tile1::C48_mosaic:tile6",
    "C48_mosaic:tile2::C48_mosaic:tile3",
    "C48_mosaic:tile2::C48_mosaic:tile4",
    "C48_mosaic:tile2::C48_mosaic:tile6",
    "C48_mosaic:tile3::C48_mosaic:tile4",
    "C48_mosaic:tile3::C48_mosaic:tile5",
    "C48_mosaic:tile4::C48_mosaic:tile5",
    "C48_mosaic:tile4::C48_mosaic:tile6",
    "C48_mosaic:tile5::C48_mosaic:tile6" ;
  
   contact_index =
    "96:96,1:96::1:1,1:96",
    "1:96,96:96::1:1,96:1",
    "1:1,1:96::96:1,96:96",
    "1:96,1:1::1:96,96:96",
    "1:96,96:96::1:96,1:1",
    "96:96,1:96::96:1,1:1",
    "1:96,1:1::96:96,96:1",
    "96:96,1:96::1:1,1:96",
    "1:96,96:96::1:1,96:1",
    "1:96,96:96::1:96,1:1",
    "96:96,1:96::96:1,1:1",
    "96:96,1:96::1:1,1:96" ;
  }
</PRE>

<P>
A dummy variable with its <TT>standard_name</TT> attribute set to <TT>grid_mosaic_spec</TT> is required.
  The <TT>children</TT> attribute of this dummy variable provides the variable name that contains the tile names and the
  <TT>contact_region</TT> attribute points to the variable name that defines a list of tile pairs that are connected
  to each other.  For a Cubed Sphere grid, there are six tiles and 12 connections.  The <TT>contacts</TT> variable
  has three required attributes: <TT>standard_name</TT>, <TT>contact_type</TT>, and <TT>contact_index</TT>.  <TT>startand_name</TT>
  has to be set to <TT>grid_contact_spec</TT>.  <TT>contact_type</TT> has to be <TT>boundary</TT>.  ESMF does not support
  overlapping contact regions. <TT>contact_index</TT> defines the variable name that contains the information how the
  two adjacent tiles are connected to each other.  The <TT>contact_index</TT> variable contains 12 entries.  Each entry
  contains the index of four points that defines the two edges that contact to
   each other from the two neighboring tiles.  Assuming the four points are A, B, C, and D.
   A and B defines the edge of tile 1 and C and D defines the edge of tile2.  A is the same point
   as C and B is the same as D.  (Ai, Aj) is the index for point A. The entry looks like this:
  <PRE>
    Ai:Bi,Aj:Bj::Ci:Di,Cj:Dj
</PRE>

<P>
The associated tile file names are defined in variable <TT>gridfiles</TT> and the directory path is defined in
  variable <TT>gridlocation</TT>.
  The <TT>gridlocation</TT> can be overwritten with an optional arguemnt <TT>TileFilePath</TT>.  Each tile is
  decomposed using a regular decomposition.  The first two tiles are decomposed into
  2x2 blocks each and the remaining 4 tiles are decomposed into 1x2 block.
  A total of 16 DEs are used.

<P>
<TT>ESMF_GridCreateMosaic()</TT> first reads in the mosaic file and defines the tile connections in the
  <TT>ESMF_DistGrid</TT>  using the information
  defined in variables <TT>contacts</TT> and <TT>contact_index</TT>. Then it reads in the coordinates defined in
  the tile files if the optional argument <TT>staggerLocList</TT> is provided.  The coordinates defined in the tile file are a
  <TT>supergrid</TT>.  A supergrid contains all the stagger locations in one grid.
  It contains the corner, edge and center coordinates all in one 2D array.
  In this example, there are 48 elements in each side of a tile, therefore, the size of the supergrid is
  48*2+1=97, i.e. 97x97.

<P>
Here is the header of one of the tile files:

<P>
<PRE>
  netcdf horizontal_grid.tile1 {
  dimensions:
         string = 255 ;
         nx = 96 ;
         ny = 96 ;
         nxp = 97 ;
         nyp = 97 ;
  variables:
         char tile(string) ;
                 tile:standard_name = "grid_tile_spec" ;
                 tile:geometry = "spherical" ;
                 tile:north_pole = "0.0 90.0" ;
                 tile:projection = "cube_gnomonic" ;
                 tile:discretization = "logically_rectangular" ;
                 tile:conformal = "FALSE" ;
         double x(nyp, nxp) ;
                 x:standard_name = "geographic_longitude" ;
                 x:units = "degree_east" ;
         double y(nyp, nxp) ;
                 y:standard_name = "geographic_latitude" ;
                 y:units = "degree_north" ;
         double dx(nyp, nx) ;
                 dx:standard_name = "grid_edge_x_distance" ;
                 dx:units = "meters" ;
         double dy(ny, nxp) ;
                 dy:standard_name = "grid_edge_y_distance" ;
                 dy:units = "meters" ;
         double area(ny, nx) ;
                 area:standard_name = "grid_cell_area" ;
                 area:units = "m2" ;
         double angle_dx(nyp, nxp) ;
                 angle_dx:standard_name = "grid_vertex_x_angle_WRT_geographic_east" ;
                 angle_dx:units = "degrees_east" ;
         double angle_dy(nyp, nxp) ;
                 angle_dy:standard_name = "grid_vertex_y_angle_WRT_geographic_north" ;
                 angle_dy:units = "degrees_north" ;
         char arcx(string) ;
                 arcx:standard_name = "grid_edge_x_arc_type" ;
                 arcx:north_pole = "0.0 90.0" ;
  
  // global attributes:
                 :grid_version = "0.2" ;
                 :code_version = "$Name: testing $" ;
                 :history = "/home/z1l/bin/tools_20091028/make_hgrid --grid_type gnomonic_ed --nlon 96" ;
  }
</PRE>

<P>
The tile file not only defines the coordinates at all staggers, it also has a complete specification of
  distances, angles, and areas.  In ESMF, we currently only use the <TT>geographic_longitude</TT> and <TT>geographic_latitude</TT>
  variables.
<P>
<PRE>
     ! Set up decomposition for each tile
     allocate(decomptile(2,6))
     decomptile(:,1)=(/2,2/) ! Tile 1
     decomptile(:,2)=(/2,2/) ! Tile 2
     decomptile(:,3)=(/1,2/) ! Tile 3
     decomptile(:,4)=(/1,2/) ! Tile 4
     decomptile(:,5)=(/1,2/) ! Tile 5
     decomptile(:,6)=(/1,2/) ! Tile 6

     ! Create cubed sphere grid without reading in the coordinates
     grid2D = ESMF_GridCreateMosaic(filename='data/C48_mosaic.nc', &amp;
                tileFilePath='./data/', regDecompPTile=decomptile, rc=rc)
</PRE>

<P>
<PRE>
     ! Create cubed sphere grid and read in the center and corner stagger coordinates
     ! from the tile files

     grid2D = ESMF_GridCreateMosaic(filename='data/C48_mosaic.nc', &amp;
                staggerLocList=(/ESMF_STAGGERLOC_CENTER, ESMF_STAGGERLOC_CORNER/), &amp;
                tileFilePath='./data/', regDecompPTile=decomptile, rc=rc)
</PRE>

<P>
<PRE>
     ! Create cubed sphere grid and read in the edge staggers' coordinates
     ! from the tile files, set the coordTypeKind to ESMF_TYPEKIND_R4

     grid2D = ESMF_GridCreateMosaic(filename='data/C48_mosaic.nc', &amp;
                staggerLocList=(/ESMF_STAGGERLOC_EDGE1, ESMF_STAGGERLOC_EDGE2/), &amp;
                coordTypeKind = ESMF_TYPEKIND_R4, &amp;
                tileFilePath='./data/', regDecompPTile=decomptile, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831300000000000000"></A>
  <A NAME="sec:usage:staggerloc"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> Grid stagger locations
</H3>

<P>
A useful finite difference technique is to place different physical
   quantities at different locations within a grid cell. This
   <EM>staggering</EM> of the physical variables on the mesh is introduced so
   that the difference of a field is naturally defined at the location of
   another variable. This method was first formalized by Mesinger and Arakawa
   (1976).

<P>
To support the staggering of variables, the Grid provides
   the idea of <EM>stagger locations</EM>.
   Stagger locations refer to the places in a Grid cell that
   can contain coordinates or other data and once a Grid is associated with a
   Field object, field data. Typically Grid data can be located
   at the cell center, at the cell corners, or at the cell faces, in 2D, 3D, and
   higher dimensions. (Note that any Arakawa stagger can be constructed
   of a set of Grid stagger locations.)  There are predefined stagger locations
   (see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A>), or,
   should the user wish to specify their own, there
   is also a set of methods for generating custom locations
   (See Section&nbsp;<A HREF="#sec:usage:staggerloc:adv">31.3.25</A>).
   Users can put Grid data (e.g. coordinates)
   at multiple stagger locations in a Grid. In addition, the user can create a Field
   at any of the stagger locations in a Grid.

<P>
By default the Grid data array at the center stagger location
   starts at the bottom index of the Grid (default (1,1..,1)) and extends
   up to the maximum cell index in the Grid (e.g. given by the <TT>maxIndex</TT> argument).
   Other stagger locations also start at the bottom index of the Grid, however,
   they can extend to +1 element beyond the center in some dimensions to allow
   for the extra space to surround the center elements. See Section&nbsp;<A HREF="#sec:usage:staggerloc:adv">31.3.25</A>
   for a description of this extra space and how to adjust if it necessary.
   There are <TT>ESMF_GridGet</TT> subroutines (e.g. <TT>ESMF_GridGetCoord()</TT> or <TT>ESMF_GridGetItem()</TT>)
   which can be used to retrieve the stagger bounds for the piece of Grid data
   on a particular DE. 

<P>

<H3><A NAME="SECTION050831400000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> Associate coordinates with stagger locations</A>
</H3>

<P>
The primary type of data the Grid is responsible for storing is coordinates.
   The coordinate values in a Grid can be employed by the user in calculations or
   to describe the geometry of a Field. The Grid coordinate values are also used by
   <TT>ESMF_FieldRegridStore()</TT> when calculating the interpolation
   matrix between two Fields. The user can allocate coordinate arrays without setting coordinate values
   using the <TT>ESMF_GridAddCoord()</TT> call. (See Section&nbsp;<A HREF="#sec:usage:coords:accessing">31.3.16</A> for a discussion of
   setting/getting coordinate values.) When adding or accessing
   coordinate data, the stagger location is specified to tell the Grid method
   where in the cell to get the data. The different stagger locations may also have slightly different
   index ranges and sizes.  Please see Section&nbsp;<A HREF="#sec:usage:staggerloc">31.3.13</A> for a discussion of
   Grid stagger locations.

<P>
The following example adds coordinate storage to the corner stagger location in a Grid using one
   of the predefined stagger locations.
<P>
<PRE>
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, rc=rc)
</PRE>

<P>
Note only the center stagger location <TT>ESMF_STAGGERLOC_CENTER</TT> is supported
   in an arbitrarily distributed Grid. 

<P>

<H3><A NAME="SECTION050831500000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> Specify the relationship of coordinate Arrays
                 to index space dimensions</A>
</H3>

<P>
To specify how the coordinate arrays are mapped to the
   index dimensions the arguments <TT>coordDep1</TT>,
   <TT>coordDep2</TT>, and <TT>coordDep3</TT> are used, each
   of which is a Fortran array. The values of the elements
   in a <TT>coordDep</TT> array specify which index dimension
   the corresponding coordinate dimension
   maps to.  For example, <TT>coordDep1=(/1,2/)</TT> means that
   the first dimension of coordinate 1 maps to index
   dimension 1 and the second maps to index dimension 2.
   For a grid with non-arbitrary distribution, the default
   values for <TT>coordDep1</TT>, <TT>coordDep2</TT> and <TT>coordDep3</TT>
   are <TT>/1,2..,gridDimCount/</TT>.  This default
   thus specifies a curvilinear grid.

<P>
The following call demonstrates the creation of a
   10x20 2D rectilinear grid where the first coordinate
   component is mapped to the second index dimension
   (i.e. is of size 20) and the second coordinate component
   is mapped to the first index dimension (i.e. is of size
   10).
<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/5,5/), &amp;
          countsPerDEDim2=(/7,7,6/),                    &amp;
          coordDep1=(/2/),                              &amp;
          coordDep2=(/1/), rc=rc)
</PRE>

<P>
The following call demonstrates the creation of a
   10x20x30 2D plus 1 curvilinear grid where
   coordinate component 1 and 2 are still 10x20, but
   coordinate component 3 is mapped just to the
   third index dimension.
<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/6,4/), &amp;
          countsPerDEDim2=(/10,7,3/), countsPerDEDim3=(/30/), &amp;
          coordDep1=(/1,2/), coordDep2=(/1,2/), &amp;
          coordDep3=(/3/), rc=rc)
</PRE>

<P>
By default the local piece of the array on each PET starts at
   (1,1,..), however, the indexing for each grid coordinate array
   on each DE may be shifted to the global indices by using the <TT>indexflag</TT>.
   For example, the following call switches the grid to use global indices.
<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/6,4/), &amp;
           countsPerDEDim2=(/10,7,3/), indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
For an arbitrarily distributed grid, the default value of a coordinate
   array dimension is <TT>ESMF_DIM_ARB</TT> if the index dimension is arbitrarily
   distributed and is <TT>n</TT> where <TT>n</TT> is the index dimension itself when it is not
   distributed. The following call is equivalent to the example in
   Section <A HREF="#example:ArbGridWithUndistDim">31.3.7</A>
<P>
<PRE>
   grid3D=ESMF_GridCreateNoPeriDim( &amp;
            maxIndex = (/xdim, ydim, zdim/), &amp;
            arbIndexList = localArbIndex, &amp;
            arbIndexCount = localArbIndexCount,          &amp;
            coordDep1 = (/ESMF_DIM_ARB/), &amp;
            coordDep2 = (/ESMF_DIM_ARB/), &amp;
            coordDep3 = (/3/), &amp;
            rc=rc)
</PRE>

<P>
The following call uses non-default <TT>coordDep1</TT>, <TT>coordDep2</TT>,
   and <TT>coordDep3</TT> to create a 3D curvilinear grid with its horizontal
   dimensions arbitrarily distributed.
<P>
<PRE>
   grid3D=ESMF_GridCreateNoPeriDim( &amp;
            maxIndex = (/xdim, ydim, zdim/), &amp;
            arbIndexList = localArbIndex, &amp;
            arbIndexCount = localArbIndexCount,          &amp;
            coordDep1 = (/ESMF_DIM_ARB, 3/), &amp;
            coordDep2 = (/ESMF_DIM_ARB, 3/), &amp;
            coordDep3 = (/ESMF_DIM_ARB, 3/), &amp;
            rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831600000000000000"></A>
  <A NAME="sec:usage:coords:accessing"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">16</SPAN> Access coordinates
</H3>

<P>
Once a Grid has been created, the user has several options to access
   the Grid coordinate data. The first of these, <TT>ESMF_GridSetCoord()</TT>,
   enables the user to use ESMF Arrays to set data
   for one stagger location across the whole Grid.
   For example, the following sets the coordinates in the first dimension
   (e.g. x) for the corner stagger location to
   those in the ESMF Array <TT>arrayCoordX</TT>.
<P>
<PRE>
   call ESMF_GridSetCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          coordDim=1, array=arrayCoordX, rc=rc)
</PRE>

<P>
The method <TT>ESMF_GridGetCoord()</TT> allows the user
   to obtain a reference to an ESMF Array which
   contains the coordinate data for a stagger location in a Grid. The user
   can then employ any of the standard <TT>ESMF_Array</TT> tools to operate
   on the data. The following copies the coordinates from the second
   component of the corner and puts it into the ESMF Array <TT>arrayCoordY</TT>.
<P>
<PRE>
   call ESMF_GridGetCoord(grid2D,    &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,    &amp;
          coordDim=2,                           &amp;
          array=arrayCoordY, rc=rc)
</PRE>

<P>
Alternatively, the call <TT>ESMF_GridGetCoord()</TT> gets a Fortran pointer to
   the coordinate data. The user can then operate on this array in the usual
   manner. The following call gets a reference to the
   Fortran array which holds the data for the second coordinate (e.g. y).
<P>
<PRE>
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER, farrayPtr=coordY2D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831700000000000000"></A>
  <A NAME="sec:usage:items"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">17</SPAN> Associate items with stagger locations
</H3>

<P>
The ESMF Grids contain the ability to store other kinds of
   data beyond coordinates. These kinds of data are referred to
   as "items". Although the user is free to use this
   data as they see fit, the user should be aware that
   this data may also be used by other parts of ESMF (e.g. the
   ESMF_GRIDITEM_MASK item is used in regridding).
   Please see Section&nbsp;<A HREF="#const:griditem">31.2.2</A> for a list of valid
   items.

<P>
Like coordinates items are also created on stagger locations.
   When adding or accessing item data, the stagger location is specified to tell the Grid method
   where in the cell to get the data. The different stagger locations may also have slightly different
   index ranges and sizes.  Please see Section&nbsp;<A HREF="#sec:usage:staggerloc">31.3.13</A> for a discussion of
   Grid stagger locations.  The user can
   allocate item arrays without setting item values using the <TT>ESMF_GridAddItem()</TT> call.
   (See Section&nbsp;<A HREF="#sec:usage:items:accessing">31.3.18</A> for a discussion of setting/getting item values.)

<P>
The following example adds mask item storage to the corner stagger location in a grid.
<P>
<PRE>
   call ESMF_GridAddItem(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          itemflag=ESMF_GRIDITEM_MASK, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831800000000000000"></A>
  <A NAME="sec:usage:items:accessing"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">18</SPAN> Access items
</H3>
   
   Once an item has been added to a Grid, the user has several options to access
   the data. The first of these, <TT>ESMF_GridSetItem()</TT>,
   enables the user to use ESMF Arrays to set data for one stagger location across the whole Grid.
   For example, the following sets the mask item in the corner stagger location to
   those in the ESMF Array <TT>arrayMask</TT>.
   
<P>
<PRE>
   call ESMF_GridSetItem(grid2D,             &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          itemflag=ESMF_GRIDITEM_MASK, array=arrayMask, rc=rc)
</PRE>

<P>
The method <TT>ESMF_GridGetItem()</TT> allows the user
   to get a reference to the Array which
   contains item data for a stagger location on a Grid. The user
   can then employ any of the standard <TT>ESMF_Array</TT> tools to operate
   on the data. The following gets the mask data from the corner
   and puts it into the ESMF Array <TT>arrayMask</TT>.
<P>
<PRE>
   call ESMF_GridGetItem(grid2D,             &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          itemflag=ESMF_GRIDITEM_MASK,           &amp;
          array=arrayMask, rc=rc)
</PRE>

<P>
Alternatively, the call <TT>ESMF_GridGetItem()</TT> gets a Fortran pointer to
   the item data. The user can then operate on this array in the usual
   manner. The following call gets a reference to the
   Fortran array which holds the data for the mask data.
<P>
<PRE>
   call ESMF_GridGetItem(grid2D, localDE=0,   &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER,  &amp;
          itemflag=ESMF_GRIDITEM_MASK, farrayPtr=mask2D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831900000000000000"></A>
  <A NAME="sec:grid:usage:bounds"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">19</SPAN> Grid regions and bounds
</H3>

<P>
Like an Array or a Field, the index space of each
   stagger location in the Grid contains an exclusive region, a
   computational region and a total region. Please
   see Section&nbsp;<A HREF="#Array_regions_and_default_bounds">28.2.6</A>
   for an in depth description of these regions.

<P>
The exclusive region is the index space defined by the
   distgrid of each stagger location of the Grid. This region
   is the region which is owned by the DE and is the region
   operated on by communication methods such as <TT>ESMF_FieldRegrid()</TT>.
   The exclusive region for a stagger location is based on the
   exclusive region defined by the DistGrid used to create the Grid.
   The size of the stagger exclusive region is the index space for the
   Grid cells, plus the stagger padding.

<P>
The default stagger padding depends on the topology of the Grid.
   For an unconnected dimension the stagger padding is a width
   of 1 on the upper side (i.e. <TT>gridEdgeUWidth=(1,1,1,1...)</TT>).
   For a periodic dimension there is no stagger padding.
   By adjusting <TT>gridEdgeLWidth</TT> and <TT>gridEdgeUWidth</TT>, the
   user can set the stagger padding for the whole Grid and
   thus the exclusive region can be adjusted at will around the
   index space corresponding to the cells. The user can
   also use <TT>staggerEdgeLWidth</TT> and <TT>staggerEdgeUWidth</TT> to
   adjust individual stagger location padding within the
   Grid's padding (Please see Section&nbsp;<A HREF="#sec:usage:staggerpadding:adv">31.3.26</A> for
   further discussion of customizing the stagger padding).

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridexreg"></A><A NAME="57928"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 17:</STRONG>
An example of a Grid's exclusive region for the corner stagger</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridExclusiveReg}}$
 -->
<IMG
 WIDTH="577" HEIGHT="234" ALIGN="BOTTOM" BORDER="0"
 SRC="img83.png"
 ALT="\scalebox{0.75}{\includegraphics{GridExclusiveReg}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
Figure&nbsp;<A HREF="#fig:gridexreg">17</A> shows an example of a Grid exclusive region for the
   <TT>ESMF_STAGGERLOC_CORNER</TT> stagger with default
   stagger padding. This exclusive region would be for a Grid generated by either of the
   following calls:
<P>
<PRE>
  grid2D=ESMF_GridCreateNoPeriDim(regDecomp=(/2,4/), maxIndex=(/5,15/), &amp;
           indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
<PRE>
  grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/4,4,4,3/), &amp;
           countsPerDEDim2=(/3,2/), indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
Each rectangle in this diagram represents a DE and the numbers along the sides
   are the index values of the locations in the DE. Note that the exclusive region
   has one extra index location in each dimension than the number of cells
   because of the padding for the larger corner stagger location.

<P>
The computational region is a user-settable region which can be used
   to distinguish a particular area for computation. The Grid doesn't
   currently contain functionality to let the user set the computational
   region so it defaults to the exclusive region. However, if the
   user sets an Array holding different computational bounds into the
   Grid then that Array's computational bounds will be used.

<P>
The total region is the outermost boundary of the memory allocated
   on each DE to hold the data for the stagger location on that DE. This region
   can be as small as the exclusive region, but may be larger to
   include space for halos, memory padding, etc. The total region is
   what is enlarged to include space for halos, and the total region
   must be large enough to contain the maximum halo operation on the
   Grid. The Grid doesn't currently contain functionality to let the
   user set the total region so it defaults to the exclusive region.
   However, if the
   user sets an Array holding different total bounds into the
   Grid then that Array's total bounds will be used.

<P>
The user can retrieve a set of bounds for each index space region
   described above: exclusive bounds, computational bounds,
   and total bounds. Note that although some of these are similar
   to bounds provided by ESMF_Array subroutines
   (see Section&nbsp;<A HREF="#Array_regions_and_default_bounds">28.2.6</A>)
   the format here is different. The Array bounds are only for
   distributed dimensions and are ordered to correspond
   to the dimension order in the associated DistGrid. The bounds
   provided by the Grid are ordered according to the order of dimensions of the data
   in question. This means that the bounds provided should be usable
   "as is" to access the data.

<P>
Each of the three types of bounds refers to the maximum and minimum
   per dimension of the index ranges of a particular region. The parameters
   referring to the maximums contain a 'U' for upper. The parameters referring
   to the minimums contain an 'L' for lower. The bounds and associated
   quantities are almost always given on a per DE basis. The three types of
   bounds <TT>exclusiveBounds</TT>, <TT>computationalBounds</TT>, and <TT>totalBounds</TT> refer
   to the ranges of the exclusive region, the computational region, and the
   total region. Each of these bounds also has a corresponding count parameter
   which gives the number of items across that region (on a DE) in each dimension.
   (e.g. <TT>totalCount(d)=totallUBound(i)-totalLBound(i)+1</TT>). Width parameters
   give the spacing between two different types of region. The
   <TT>computationalWidth</TT> argument gives the spacing between the exclusive
   region and the computational region. The <TT>totalWidth</TT> argument gives the
   spacing between the total region and the computational region. Like the
   other bound information these are typically on a per DE basis, for example
   specifying <TT>totalLWidth=(1,1)</TT> makes the bottom of the total
   region one lower in each dimension than the computational region on
   each DE. The exceptions to the per DE rule are
   <TT>staggerEdgeWidth</TT>, and <TT>gridEdgeWidth</TT>
   which give the spacing only on the DEs along the boundary of the Grid.

<P>
All the above bound discussions only apply to the grid with non-arbitrary distributions,
   i.e., regular or irregular distributions.  For an arbitrarily distributed grid,
   only center stagger location is supported and there is no padding around the grid.
   Thus, the exclusive bounds, the total bounds and the computational bounds are identical
   and <TT>staggerEdgeWidth</TT>, and <TT>gridEdgeWidth</TT> are all zeros. 

<P>

<H3><A NAME="SECTION050832000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">20</SPAN> Get Grid coordinate bounds</A>
</H3>

<P>
When operating on coordinates the user may often wish to
   retrieve the bounds of the piece of coordinate data on
   a particular local DE. This is useful for iterating through the
   data to set coordinates, retrieve coordinates, or do calculations.
   The method <TT>ESMF_GridGetCoord</TT> allows the user
   to retrieve bound information for a particular coordinate
   array.

<P>
As described in the previous section there are three types of bounds the user can
   get: exclusive bounds, computational bounds,
   and total bounds. The bounds
   provided by <TT>ESMF_GridGetCoordBounds</TT> are for both distributed
   and undistributed dimensions and are ordered according to the
   order of dimensions in the  coordinate. This means that the bounds
    provided should be usable
   "as is" to access data in the coordinate array. In the case
   of factorized coordinate Arrays where a coordinate may
   have a smaller dimension than its associated Grid, then
   the dimension of the coordinate's bounds are the dimension of
   the coordinate, not the Grid.

<P>
The following is an example of retrieving the bounds for localDE 0 for the first
   coordinate array from the corner stagger location.
<P>
<PRE>
   call ESMF_GridGetCoordBounds(grid2D, coordDim=1, localDE=0,  &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,                         &amp;
          exclusiveLBound=elbnd, exclusiveUBound=eubnd,              &amp;
          computationalLBound=clbnd, computationalUBound=cubnd,      &amp;
          totalLBound=tlbnd, totalUBound=tubnd, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">21</SPAN> Get Grid stagger location bounds</A>
</H3>

<P>
When operating on data stored at a particular stagger
   in a Grid the user may find it useful to be able
   to retrieve the bounds of the data on a particular local DE.
   This is useful for iterating through the
   data for computations or allocating arrays to hold the data.
   The method <TT>ESMF_GridGet</TT> allows the user
   to retrieve bound information for a particular stagger location.

<P>
As described in Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> there are three types of bounds
   the user can typically get, however, the Grid doesn't hold data at
   a stagger location (that is the job of the Field), and so
   no Array is contained there and so no total region exists, so the
   user may only retrieve exclusive and computational bounds from
   a stagger location.  The bounds
   provided by <TT>ESMF_GridGet</TT> are ordered according to the
   order of dimensions in the Grid.

<P>
The following is an example of retrieving the bounds for localDE 0
   from the corner stagger location.
<P>
<PRE>
   call ESMF_GridGet(grid2D, localDE=0,                         &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,                    &amp;
          exclusiveLBound=elbnd, exclusiveUBound=eubnd,         &amp;
          computationalLBound=clbnd, computationalUBound=cubnd, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">22</SPAN> Get Grid stagger location information</A>
</H3>

<P>
In addition to the per DE information that can be accessed about
   a stagger location there is some global information that can
   accessed by using <TT>ESMF_GridGet</TT> without specifying a
   localDE. One of the uses of this information is to create
   an ESMF Array to hold data for a stagger location.

<P>
The information currently available from a stagger
   location is the <TT>distgrid</TT>. The <TT>distgrid</TT> gives the
   distgrid which describes the size and distribution of the elements in the stagger location.

<P>
The following is an example of retrieving information for localDE 0
   from the corner stagger location.
<P>
<PRE>
    ! Get info about staggerloc
    call ESMF_GridGet(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER,  &amp;
           distgrid=staggerDistgrid, &amp;
           rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832300000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">23</SPAN> Create an Array at a stagger location</A>
</H3>

<P>
In order to create an Array to correspond to a Grid stagger location
   several pieces of information need to be obtained from both the
   Grid and the stagger location in the Grid.

<P>
The information that needs to be obtained from the Grid
   is the <TT>distgridToGridMap</TT> to ensure that the new Array
   has its  dimensions are mapped correctly to the Grid. These
   are obtained using the <TT>ESMF_GridGet</TT> method.

<P>
The information that needs to be obtained from the stagger
   location is the distgrid that describes the size and distribution
   of the elements in the stagger location. This information can
   be obtained using the stagger location specific <TT>ESMF_GridGet</TT> method.

<P>
The following is an example of using information from a 2D Grid with non-arbitrary
   distribution to create an Array corresponding to a stagger location.
  
<P>
<PRE>
    ! Get info from Grid
    call ESMF_GridGet(grid2D, distgridToGridMap=distgridToGridMap, rc=rc)
</PRE>

<P>
<PRE>
    ! Get info about staggerloc
    call ESMF_GridGet(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
           distgrid=staggerDistgrid, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
    ! construct ArraySpec
    call ESMF_ArraySpecSet(arrayspec, rank=2, typekind=ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>
<PRE>
    ! Create an Array based on info from grid
    array=ESMF_ArrayCreate(arrayspec=arrayspec, &amp;
            distgrid=staggerDistgrid, distgridToArrayMap=distgridToGridMap, &amp;
            rc=rc)
</PRE>

<P>
Creating an Array for a Grid with arbitrary distribution is different.
   For a 2D Grid with both dimension arbitrarily distributed, the Array dimension
   is 1.  For a 3D Grid with two arbitrarily distributed dimensions and one
   undistributed dimension, the Array dimension is 2.  In general,
   if the Array does not have any ungridded dimension, the Array dimension
   should be 1 plus the number of undistributed dimensions of the Grid.

<P>
The following is an example of creating an Array for a 3D Grid with 2
   arbitrarily distributed dimensions such as the one defined in Section&nbsp;<A HREF="#example:ArbGridWithUndistDim">31.3.7</A>.
<P>
<PRE>
    ! Get distGrid from Grid
    call ESMF_GridGet(grid3D, distgrid=distgrid, rc=rc)
</PRE>

<P>
<PRE>
    ! construct ArraySpec
    call ESMF_ArraySpecSet(arrayspec, rank=2, typekind=ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>
<PRE>
    ! Create an Array based on the presence of distributed dimensions
    array=ESMF_ArrayCreate(arrayspec=arrayspec,distgrid=distgrid, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832400000000000000"></A>
  <A NAME="sec:usage:adv:create"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">24</SPAN> Create more complex Grids using DistGrid
</H3>

<P>
Besides the shortcut methods for creating a Grid object such as
   <TT>ESMF_GridCreateNoPeriDim()</TT>, there is
   a set of methods which give the user more control over the
   specifics of the grid.  The following describes the more
   general interface, using DistGrid.
   The basic idea is to first create an ESMF DistGrid object describing
   the distribution and shape of the Grid, and then to employ that to either directly
   create the Grid or first create Arrays and then create the Grid from those.
   This method gives the user maximum control over the topology and distribution of the Grid.
   See the DistGrid documentation in Section&nbsp;<A HREF="#sec:DistGrid">36.1</A> for an
   in-depth description of its interface and use.

<P>
As an example, the following call constructs
   a 10x20 Grid with a lower bound of (1,2).
<P>
<PRE>
   ! Create DistGrid
   distgrid2D = ESMF_DistGridCreate(minIndex=(/1,2/), maxIndex=(/11,22/), &amp;
           rc=rc)
</PRE>

<P>
<PRE>
   ! Create Grid
   grid3D=ESMF_GridCreate(distGrid=distgrid2D, rc=rc)
</PRE>

<P>
To alter which dimensions are distributed, the <TT>distgridToGridMap</TT>
   argument can be used. The <TT>distgridToGridMap</TT> is used to set
   which dimensions of the Grid are mapped to the dimensions
   described by <TT>maxIndex</TT>. In other words, it describes how the dimensions of
   the underlying default DistGrid are mapped to the Grid. Each entry
   in <TT>distgridToGridMap</TT> contains the Grid dimension to which the corresponding
   DistGrid dimension should be mapped.
   The following example illustrates the creation of a Grid where the largest
   dimension is first. To accomplish this the two dimensions are swapped.
   
<P>
<PRE>
   ! Create DistGrid
   distgrid2D = ESMF_DistGridCreate(minIndex=(/1,2/), maxIndex=(/11,22/), &amp;
        rc=rc)
</PRE>

<P>
<PRE>
   ! Create Grid
   grid2D=ESMF_GridCreate(distGrid=distgrid2D, distgridToGridMap=(/2,1/), &amp;
        rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832500000000000000"></A>
  <A NAME="sec:usage:staggerloc:adv"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">25</SPAN> Specify custom stagger locations
</H3>

<P>
Although ESMF provides a set of predefined stagger locations (See Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A>),
   the user may need one outside this set. This section describes the construction of
   custom stagger locations.

<P>
To completely specify a stagger for an arbitrary number of dimensions, we define the
   stagger location in terms of a set of cartesian coordinates. The cell is represented
   by a n-dimensional cube with sides of length 2, and the coordinate origin located at
   the center of the cell. The geometry of the cell is for reference purposes only,
   and does not literally represent the actual shape of the cell. Think of this method
   instead as an easy way to specify a part (e.g. center, corner, face) of a higher
   dimensional cell which is extensible to any number of dimensions.

<P>
To illustrate this approach, consider a 2D cell. In 2 dimensions
   the cell is represented by a square. An xy axis is placed at its center, with the
   positive x-axis oriented <EM>East</EM> and the positive y-axis oriented <EM>North</EM>.
   The resulting coordinate for the lower left corner is at <SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img84.png"
 ALT="$(-1,-1)$"></SPAN>, and upper right
   corner at <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img85.png"
 ALT="$(1,1)$"></SPAN>.
   However, because our staggers are symmetric they don't need to distinguish between
   the <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img86.png"
 ALT="$-1$"></SPAN>, and the <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$1$"></SPAN>, so we only need to concern ourselves with the first quadrant of
   this cell. We only need to use the <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$1$"></SPAN>, and the <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="$0$"></SPAN>, and many of the cell locations
   collapse together (e.g. we only need to represent one corner). See figure&nbsp;<A HREF="#fig:gridcuststaggerloc">18</A>
   for an illustration of these concepts.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridcuststaggerloc"></A><A NAME="58016"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 18:</STRONG>
An example of specifying 2D stagger locations using coordinates.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridCustStaggerLoc}}$
 -->
<IMG
 WIDTH="544" HEIGHT="268" ALIGN="BOTTOM" BORDER="0"
 SRC="img88.png"
 ALT="\scalebox{0.75}{\includegraphics{GridCustStaggerLoc}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The cell center is represented by the coordinate pair <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img89.png"
 ALT="$(0,0)$"></SPAN> indicating the origin.
   The cell corner is <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$+1$"></SPAN> in each direction, giving a coordinate pair of <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img85.png"
 ALT="$(1,1)$"></SPAN>.
   The edges are each <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$+1$"></SPAN> in one dimension and <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="$0$"></SPAN> in the other indicating that
   they're even with the center in one dimension and offset in the other.

<P>
For three dimensions, the vertical component of the stagger location can be added by
   simply adding an additional coordinate. The three dimensional generalization of the
   cell center becomes <SPAN CLASS="MATH"><IMG
 WIDTH="54" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img91.png"
 ALT="$(0,0,0)$"></SPAN> and the cell corner becomes <SPAN CLASS="MATH"><IMG
 WIDTH="54" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img92.png"
 ALT="$(1,1,1)$"></SPAN>. The rest of
   the 3D stagger locations are combinations of <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$+1$"></SPAN> offsets from the center.

<P>
To generalize this to <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$d$"></SPAN> dimensions, to represent a <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$d$"></SPAN> dimensional stagger
   location. A set of <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img26.png"
 ALT="$d$"></SPAN> <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="$0$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$1$"></SPAN> is used to specify for each dimension
   whether a stagger location is aligned with the cell center in that dimension (<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img87.png"
 ALT="$0$"></SPAN>),
   or offset by <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img90.png"
 ALT="$+1$"></SPAN> in that dimension (<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$1$"></SPAN>). Using this scheme we can represent
   any symmetric stagger location.

<P>
To construct a custom stagger location in ESMF the subroutine
   <TT>ESMF_StaggerLocSet()</TT> is used to specify,
   for each dimension, whether the stagger is located at the interior (0)
   or on the boundary (1) of the cell. This method allows users
   to construct stagger locations for which
   there is no predefined value. In this example, it's used to
   set the 4D center and 4D corner locations.
  
<P>
<PRE>
   ! Set Center
   call ESMF_StaggerLocSet(staggerLoc,loc=(/0,0,0,0/),rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_GridAddCoord(grid4D, staggerLoc=staggerLoc, rc=rc)
</PRE>

<P>
<PRE>
   ! Set Corner
   call ESMF_StaggerLocSet(staggerLoc,loc=(/1,1,1,1/),rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_GridAddCoord(grid4D, staggerLoc=staggerLoc, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832600000000000000"></A>
  <A NAME="sec:usage:staggerpadding:adv"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">26</SPAN> Specify custom stagger padding
</H3>

<P>
There is an added complication with the data (e.g. coordinates) stored at stagger locations in
  that they can require different amounts of storage depending
  on the underlying Grid type.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridcellsandcorners"></A><A NAME="58035"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 19:</STRONG>
An example 2D Grid with cell centers and corners.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridCellsAndCorners}}$
 -->
<IMG
 WIDTH="351" HEIGHT="179" ALIGN="BOTTOM" BORDER="0"
 SRC="img93.png"
 ALT="\scalebox{0.75}{\includegraphics{GridCellsAndCorners}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
Consider the example 2D grid in figure&nbsp;<A HREF="#fig:gridcellsandcorners">19</A>, where the dots represent the cell corners
   and the &ldquo;+&rdquo; represents the cell centers. For the corners to completely
   enclose the cell centers (symmetric stagger), the number of corners in each
   dimension needs to be one greater then the number of cell centers. In the above
   figure, there are two rows and three columns of cell centers. To enclose the
   cell centers, there must be three rows and four columns of cell corners.
   This is true in general for Grids without periodicity or
   other connections.  In fact, for a symmetric stagger, given that the center
   location requires n x m storage, the corresponding corner location
   requires n+1 x m+1, and the edges, depending on the side, require n+1 x m or
   m+1 x n.  In order to add the extra storage, a new DistGrid is
   created at each stagger location. This Distgrid is similar to the DistGrid
   used to create the Grid, but has an extra set of elements added to hold the
   index locations for the stagger padding.
   By default, when the coordinate arrays are created, one extra
   layer of padding is added to the index space to create symmetric staggers
   (i.e. the center location is surrounded). The default is to add this padding
   on the positive side, and to only add this padding where needed
   (e.g. no padding for the center, padding
   on both dimensions for the corner, in only one dimension for the
   edge in 2D.) There are two ways for the user to change
   these defaults.

<P>
One way is to use the <TT>GridEdgeWidth</TT> or <TT>GridAlign</TT> arguments
   when creating a Grid. These arguments can be used to change the default padding
   around the Grid cell index space. This extra padding is used by default
   when setting the padding for a stagger location.

<P>
The <TT>gridEdgeLWidth</TT> and
   <TT>gridEdgeUWidth</TT> arguments are both 1D arrays of the
   same size as the Grid dimension. The entries in the arrays
   give the extra offset from the outer boundary of
   the grid cell index space. The following example shows the
   creation of a Grid with all the extra space to hold stagger padding
   on the negative side of a Grid. This is the reverse of
   the default behavior. The resulting Grid will have
   an exclusive region which extends from <SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img84.png"
 ALT="$(-1,-1)$"></SPAN> to
   <SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img94.png"
 ALT="$(10,10)$"></SPAN>, however, the cell center stagger location
   will still extend from <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img85.png"
 ALT="$(1,1)$"></SPAN> to <SPAN CLASS="MATH"><IMG
 WIDTH="55" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img94.png"
 ALT="$(10,10)$"></SPAN>.
<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(minIndex=(/1,1/),maxIndex=(/10,10/), &amp;
            gridEdgeLWidth=(/1,1/), gridEdgeUWidth=(/0,0/), rc=rc)
</PRE>

<P>
To indicate how the data in a Grid's stagger locations are aligned with the
   cell centers, the optional <TT>gridAlign</TT> parameter
   may be used. This parameter indicates which stagger elements
   in a cell share the same index values as the cell center.
   For example, in a 2D cell, it would indicate which of the four corners has
   the same index value as the center. To set <TT>gridAlign</TT>,
   the values -1,+1 are used to indicate the alignment in
   each dimension. This parameter is mostly
   informational, however, if the <TT>gridEdgeWidth</TT> parameters
   are not set then its value determines where the default padding
   is placed. If not specified, then the default is to align all
   staggers to the most negative, so the padding is on the positive side.
   The following code illustrates creating a Grid aligned to the reverse of
   default (with everything to the positive side). This creates a
   Grid identical to that created in the previous example.
<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(minIndex=(/1,1/),maxIndex=(/10,10/), &amp;
            gridAlign=(/1,1/), rc=rc)
</PRE>

<P>
The <TT>gridEdgeWidth</TT> and <TT>gridAlign</TT> arguments both
   allow the user to set the default padding to be used
   by stagger locations in a Grid. By default, stagger locations
   allocated in a Grid set their stagger padding based on these
   values.  A stagger location's padding in each dimension is
   equal to the value of <TT>gridEdgeWidth</TT> (or the value implied
   by <TT>gridAlign</TT>), unless the stagger location is centered
   in a dimension in which case the stagger padding is 0. For example,
   the cell center stagger location has 0 stagger padding in all
   dimensions, whereas the edge stagger location lower padding
   is equal to <TT>gridEdgeLWidth</TT> and the upper padding is equal
   to <TT>gridEdgeUWidth</TT> in one dimension, but both are 0 in the other,
   centered, dimension.  If the user wishes to set the stagger padding
   individually for each stagger location they may use the
   <TT>staggerEdgeWidth</TT> and <TT>staggerAlign</TT> arguments.

<P>
The <TT>staggerEdgeLWidth</TT> and
   <TT>staggerEdgeUWidth</TT> arguments are both 1D arrays of the
   same size as the Grid dimension. The entries in the arrays
   give the extra offset from the Grid cell index space
   for a stagger location. The following example shows the
   addition of two stagger locations. The
   corner location has no extra boundary and the
   center has a single layer of extra padding on
   the negative side and none on the positive.  This is the reverse of
   the default behavior.
<P>
<PRE>
   grid2D=ESMF_GridCreate(distgrid=distgrid2D, &amp;
            gridEdgeLWidth=(/1,1/), gridEdgeUWidth=(/0,0/), rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          staggerEdgeLWidth=(/0,0/), staggerEdgeUWidth=(/0,0/), rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CENTER, &amp;
          staggerEdgeLWidth=(/1,1/), staggerEdgeUWidth=(/0,0/), rc=rc)
</PRE>

<P>
To indicate how the data at a particular stagger location is aligned with the
   cell center, the optional <TT>staggerAlign</TT> parameter
   may be used. This parameter indicates which stagger elements
   in a cell share the same index values as the cell center.
   For example, in a 2D cell, it would indicate which of the four corners has
   the same index value as the center. To set <TT>staggerAlign</TT>,
   the values -1,+1 are used to indicate the alignment in
   each dimension. If a stagger location is
   centered in a dimension (e.g. an edge in 2D), then that
   dimension is ignored in the alignment. This parameter is mostly
   informational, however, if the <TT>staggerEdgeWidth</TT> parameters
   are not set then its value determines where the default padding
   is placed. If not specified, then the default is to align all
   staggers to the most negative, so the padding is on the positive side.
   The following code illustrates aligning the positive (northeast in 2D)
   corner with the center.
<P>
<PRE>
   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, staggerAlign=(/1,1/), rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION05084000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Grids with factorized coordinates can only be redisted when they are 2D.</B>
Using the ESMF_GridCreate() interface that allows the user to create a copy of an existing Grid with a new distribution will give incorrect results when used on a Grid with 3 or more dimensions and whose coordinate arrays are less than the full dimension of the Grid (i.e. it contains factorized coordinates).

<P>
</LI>
<LI><B>7D limit.</B>  Only grids up to 7D will be supported.

<P>
</LI>
<LI><B>Future adaptation.</B>  Currently Grids
are created and then remain unchanged. In the future, it would
be useful to provide support for the various forms of grid
adaptation. This would allow the grids to dynamically change
their resolution to more closely match what is needed at a particular
time and position during a computation for front tracking or adaptive meshes.

<P>
</LI>
<LI><B>Future Grid generation.</B> This class for now only contains
the basic functionality for operating on the grid. In the future
methods will be added to enable the automatic generation of various types of
grids. 

<P>
</LI>
</UL>

<H2><A NAME="SECTION05085000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<H3><A NAME="SECTION05085100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Topology</A>
</H3> 

<P>
The <TT>ESMF_Grid</TT> class depends upon the <TT>ESMF_DistGrid</TT> class
for the specification of its topology. That is, when 
creating a Grid, first an <TT>ESMF_DistGrid</TT> is created to describe the 
appropriate index space topology. This decision was
made because it seemed redundant to have a system for doing this
in both classes. It also seems most appropriate for
the machinary for topology creation to be located at the lowest
level possible so that it can be used by other
classes (e.g. the <TT>ESMF_Array</TT> class). Because of this, however,
the authors recommend that as a natural part of the 
implementation of subroutines to generate standard grid shapes
(e.g. <TT>ESMF_GridGenSphere</TT>) a set of standard
topology generation subroutines be implemented (e.g. <TT>ESMF_DistGridGenSphere</TT>) for users who want to create a standard topology, but a custom geometry.

<P>

<H2><A NAME="SECTION05086000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API: General Grid Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05086100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GridAssignment(=) - Grid assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     grid1 = grid2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid) :: grid1
     type(ESMF_Grid) :: grid2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign grid1 as an alias to the same ESMF Grid object in memory
     as grid2. If grid2 is invalid, then grid1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GridOperator(==) - Grid equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (grid1 == grid2) then ... endif
               OR
     result = (grid1 == grid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid1
     type(ESMF_Grid), intent(in) :: grid2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether grid1 and grid2 are valid aliases to the same ESMF
     Grid object in memory. For a more general comparison of two ESMF Grids,
     going beyond the simple alias test, the ESMF_GridMatch() function
     must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086300000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GridOperator(/=) - Grid not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (grid1 /= grid2) then ... endif
               OR
     result = (grid1 /= grid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid1
     type(ESMF_Grid), intent(in) :: grid2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether grid1 and grid2 are <I>not</I> valid aliases to the
     same ESMF Grid object in memory. For a more general comparison of two ESMF
     Grids, going beyond the simple alias test, the ESMF_GridMatch() function
     (not yet fully implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086400000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GridAddCoord - Allocate coordinate arrays but don't set their values</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridAddCoord()
      subroutine ESMF_GridAddCoordNoValues(grid, staggerloc,  &amp;
        staggerEdgeLWidth, staggerEdgeUWidth, staggerAlign, &amp;
        staggerLBound,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: staggerEdgeLWidth(:)
       integer,                intent(in),  optional :: staggerEdgeUWidth(:)
       integer,                intent(in),  optional :: staggerAlign(:)
       integer,                intent(in),  optional :: staggerLBound(:)
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
When a Grid is created all of its potential stagger locations can hold coordinate
    data, but none of them have storage allocated. This call allocates coordinate
    storage (creates internal ESMF_Arrays and associated memory) for  a particular
    stagger location. Note that this
    call doesn't assign any values to the storage, it only allocates it. The
    remaining options <TT>staggerEdgeLWidth</TT>, etc. allow the user to adjust the
    padding on the coordinate arrays.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to allocate coordinate storage in.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to add. Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
   
</DD>
<DT><STRONG>[staggerEdgeLWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerEdgeUWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerAlign]</STRONG></DT>
<DD>This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example,
        for a 2D cell with corner stagger it specifies which
        of the 4 corners has the same index as the center.
        If this is set and either staggerEdgeUWidth or staggerEdgeLWidth is not,
        this determines the default array padding for a stagger.
        If not set, then this defaults to all negative. (e.g.
        The most negative part of the stagger in a cell is aligned with the
        center and the padding is all on the positive side.)
   
</DD>
<DT><STRONG>[staggerLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this staggerloc in this Grid.
        Only used when Grid indexflag is <TT>ESMF_INDEX_USER</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086500000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_GridAddItem - Allocate item array but don't set their values</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridAddItem()
      subroutine ESMF_GridAddItemNoValues(grid, itemflag,  &amp;
        staggerloc, itemTypeKind, staggerEdgeLWidth, staggerEdgeUWidth, &amp;
        staggerAlign, staggerLBound,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),          intent(in)           :: grid
       type (ESMF_GridItem_Flag),intent(in)           :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc)  , intent(in), optional :: staggerloc
       type (ESMF_TypeKind_Flag),intent(in), optional :: itemTypeKind
       integer,                  intent(in), optional :: staggerEdgeLWidth(:)
       integer,                  intent(in), optional :: staggerEdgeUWidth(:)
       integer,                  intent(in), optional :: staggerAlign(:)
       integer,                  intent(in), optional :: staggerLBound(:)
       integer,                  intent(out),optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
When a Grid is created all of its potential stagger locations can hold item
    data, but none of them have storage allocated. This call allocates item
    storage (creates an internal ESMF_Array and associated memory) for  a particular
    stagger location. Note that this
    call doesn't assign any values to the storage, it only allocates it. The
    remaining options <TT>staggerEdgeLWidth</TT>, etc. allow the user to adjust the
    padding on the item array.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to allocate coordinate storage in.
   
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The grid item to add. Please see Section&nbsp;<A HREF="#const:griditem">31.2.2</A> for a list of valid items.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to add. Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
   
</DD>
<DT><STRONG>[itemTypeKind]</STRONG></DT>
<DD>The typekind of the  item to add.
   
</DD>
<DT><STRONG>[staggerEdgeLWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerEdgeUWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerAlign]</STRONG></DT>
<DD>This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example,
        for a 2D cell with corner stagger it specifies which
        of the 4 corners has the same index as the center.
        If this is set and either staggerEdgeUWidth or staggerEdgeLWidth is not,
        this determines the default array padding for a stagger.
        If not set, then this defaults to all negative. (e.g.
        The most negative part of the stagger in a cell is aligned with the
        center and the padding is all on the positive side.)
   
</DD>
<DT><STRONG>[staggerLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this staggerloc in this Grid.
        Only used when Grid indexflag is <TT>ESMF_INDEX_USER</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086600000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_GridCreate - Create a copy of a Grid with a new DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateCopyFromNewDG(grid, distgrid, &amp;
         name, copyAttributes, routehandle, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateCopyFromNewDG
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Grid),       intent(in)              :: grid
        type(ESMF_DistGrid),   intent(in)              :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        character (len=*),     intent(in),   optional  :: name
        logical,               intent(in),   optional  :: copyAttributes
        type(ESMF_RouteHandle),intent(out),  optional  :: routehandle
        integer,               intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>copyAttributes</TT> to support attribute
                 propagation from the existing to the newly created grid object. <BR>
   
</DD>
<DT><STRONG>8.2.1</STRONG></DT>
<DD>Added argument <TT>routehandle</TT> providing the user with a convenient
                way to execute <TT>ESMF_GridRedist()</TT> repeatedly, e.g. when coordinates
                on the source grid have changed.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call allows the user to copy an existing ESMF Grid, but with a new distribution.
   All internal data from the old Grid (coords, items) are redistributed to the new Grid.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The existing <TT>ESMF_Grid</TT> being redistributed, i.e. the "source" grid.
   
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object which describes how the newly created Grid is
        decomposed and distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the new Grid. If not specified, a new unique name will be created
        for the Grid.
   
</DD>
<DT><STRONG>[copyAttributes]</STRONG></DT>
<DD>A flag to indicate whether to copy the attributes of the existing grid
        to the new grid.  The default value is .false..
   
</DD>
<DT><STRONG>[routehandle]</STRONG></DT>
<DD>If provided holds the mapping of coordinates between the two grids. This can
        be used in the companion method <TT>ESMF_GridRedist()</TT> to update coordinates.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086700000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_GridCreate - Create a copy of a Grid with a different regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateCopyFromReg(grid, &amp;
         regDecomp, decompFlag, name, copyAttributes, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateCopyFromReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Grid),        intent(in)              :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                intent(in),   optional  :: regDecomp(:)
        type(ESMF_Decomp_Flag), intent(in),   optional  :: decompflag(:)
        character (len=*),      intent(in),   optional  :: name
        logical,                intent(in),   optional  :: copyAttributes
        integer,                intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>copyAttributes</TT> to support attribute
                 propagation from the existing to the newly created grid object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a copy of an existing Grid, the new Grid is
   regularly distributed (see Figure <A HREF="#fig:GridDecomps">13</A>).
   To specify the new distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to copy.
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
        possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the new Grid. If not specified, a new unique name will be
        created for the Grid.
   
</DD>
<DT><STRONG>[copyAttributes]</STRONG></DT>
<DD>A flag to indicate whether to copy the attributes of the existing grid
        to the new grid.  The default value is .false..
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086800000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_GridCreate - Create a Grid with user set edge connections and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnI(minIndex,         &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         connflagDim1, connflagDim2, connflagDim3,         &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnI
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: countsPerDEDim1(:)
        integer,                  intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                  intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>).
   To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.  Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
   cells on the DE in that dimension.

<P>
Section <A HREF="#example:2DIrregUniGrid">31.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location).
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   
</DD>
<DT><STRONG>[connflagDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connflagDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connflagDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086900000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_GridCreate - Create a Grid with user set edge connections and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnR(regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                    &amp;
         connflagDim1, connflagDim2, connflagDim3,                       &amp;
         coordSys, coordTypeKind,                            &amp;
         coordDep1, coordDep2, coordDep3,                    &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,          &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                  intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),   intent(in),  optional :: decompflag(:)
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>).
   To specify the distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The arguments are:
   <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
        possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[connflagDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connflagDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connflagDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_GridCreate - Create a Grid with user set edge connections and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnA(minIndex, maxIndex,  &amp;
         arbIndexCount, arbIndexList,                         &amp;
         connflagDim1, connflagDim2, connflagDim3,                     &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         distDim, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnA
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
        integer,                  intent(in)            :: arbIndexCount
        integer,                  intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: distDim(:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>).
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The
   size of <TT>distDim</TT> has to agree with the size of the second dimension of
   <TT>localArbIndex</TT>.

<P>
Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   
</DD>
<DT><STRONG>arbIndexList</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[connflagDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connflagDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connflagDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
        Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_GridCreate - Create a Grid from a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateFrmDistGrid(distgrid, &amp;
         distgridToGridMap, &amp;
         coordSys, coordTypeKind, coordDimCount, coordDimMap, &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign, &amp;
         gridMemLBound, indexflag, name, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFrmDistGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid),     intent(in)            :: distgrid
        integer,                 intent(in),  optional :: distgridToGridMap(:)
        type(ESMF_CoordSys_Flag),intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),intent(in),  optional :: coordTypeKind
        integer,                 intent(in),  optional :: coordDimCount(:)
        integer,                 intent(in),  optional :: coordDimMap(:,:)
        integer,                 intent(in),  optional :: gridEdgeLWidth(:)
        integer,                 intent(in),  optional :: gridEdgeUWidth(:)
        integer,                 intent(in),  optional :: gridAlign(:)
        integer,                 intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),   intent(in),  optional :: indexflag
        character (len=*),       intent(in),  optional :: name
        type(ESMF_VM),           intent(in),  optional :: vm
        integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This is the most general form of creation for an <TT>ESMF_Grid</TT>
   object. It allows the user to fully specify the topology and index space
   using the DistGrid methods and then build a grid out
   of the resulting DistGrid. Note that since the Grid created by this call
   uses <TT>distgrid</TT> as a description of its index space, the resulting Grid
   will have exactly the same number of dimensions (i.e. the same dimCount) as
   <TT>distgrid</TT>. The <TT>distgridToGridMap</TT> argument
   specifies how the Grid dimensions are mapped to the <TT>distgrid</TT>.
   The <TT>coordDimCount</TT> and <TT>coordDimMap</TT> arguments
   allow the user to specify how the coordinate arrays should map to the grid
   dimensions. (Note, though, that creating a grid does not allocate coordinate
   storage. A method such as <TT>ESMF_GridAddCoord()</TT> must be called
   before adding coordinate values.)

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
        distributed over DEs.
   
</DD>
<DT><STRONG>[distgridToGridMap]</STRONG></DT>
<DD>List that has dimCount elements.
        The elements map each dimension of distgrid to a dimension in the grid.
         (i.e. the values should range from 1 to dimCount). If not specified, the default
         is to map all of distgrid's dimensions against the dimensions of the
         grid in sequence.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>List that has dimCount elements.
        Gives the dimension of each component (e.g. x) array. This is
        to allow factorization of the coordinate arrays. If not specified
        all arrays are the same size as the grid.
   
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size dimCount x  dimCount. This array describes the
        map of each component array's dimensions onto the grids
        dimensions. Each entry <TT>coordDimMap(i,j)</TT> tells which
        grid dimension component i's, jth dimension maps to.
        Note that if j is bigger than <TT>coordDimCount(i)</TT> it is ignored.
        The default for each row i is <TT>coordDimMap(i,:)=(1,2,3,4,...)</TT>.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Grid object is created on the specified
       <TT>ESMF_VM</TT> object. The default is to create on the VM of the
       current context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_GridCreate - Create a Arbitrary Grid from a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateFrmDistGridArb(distgrid, &amp;
         indexArray, distDim, &amp;
         coordSys, coordTypeKind, coordDimCount, coordDimMap, &amp;
         name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFrmDistGridArb
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid),      intent(in)              :: distgrid
        integer,                  intent(in)              :: indexArray(:,:)
        integer,                  intent(in),   optional  :: distDim(:)
        type(ESMF_CoordSys_Flag), intent(in),   optional  :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),   optional  :: coordTypeKind
        integer,                  intent(in),   optional  :: coordDimCount(:)
        integer,                  intent(in),   optional  :: coordDimMap(:,:)
        character (len=*),        intent(in),   optional  :: name
        integer,                  intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This is the lower level function to create an arbitrarily distributed <TT>ESMF_Grid</TT>
   object. It allows the user to fully specify the topology and index space
   (of the distributed dimensions) using the DistGrid methods and then build a grid out
   of the resulting <TT>distgrid</TT>.  The <TT>indexArray(2,dimCount)</TT>,
   argument is required to specifies the topology of the grid.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
        distributed over DEs.
   
</DD>
<DT><STRONG>indexArray</STRONG></DT>
<DD>The minIndex and maxIndex array of size <TT>2</TT> x <TT>dimCount</TT>
        <TT>indexArray(1,:)</TT> is the minIndex and <TT>indexArray(2,:)</TT> is the maxIndex
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, the default is that all dimensions will be arbitrarily
         distributed.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>List that has dimCount elements.
        Gives the dimension of each component (e.g. x) array. This is
        to allow factorization of the coordinate arrays. If not specified
        each component is assumed to be size 1. Note, the default value is different
        from the same argument for a non-arbitrarily distributed grid.
   
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size dimCount x dimCount. This array describes the
        map of each coordinate array's dimensions onto the grids
        dimensions.  <TT>coordDimMap(i,j)</TT> is the grid dimension of the jth dimension
        of the i'th coordinate array.  If not specified, the default value of
        <TT>coordDimMap(i,1)</TT> is /ESMF_DIM_ARB/ if the ith dimension of the grid is
        arbitrarily distributed, or <TT>i</TT> if the ith dimension is not distributed.
        Note that if j is bigger than <TT>coordDimCount(i)</TT> then it's ignored.
        Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861300000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_GridCreate - Create a Grid from a SCRIP or GRIDSPEC format grid file with a user specified distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
      function ESMF_GridCreateFrmNCFileDG(filename, fileformat, distgrid, &amp;
        isSphere, polekindflag, addCornerStagger, coordTypeKind, addUserArea, indexflag, &amp;
        addMask, varname, coordNames, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFrmNCFileDG
</PRE><EM>ARGUMENTS:</EM>
<PRE> 
     character(len=*),       intent(in)             :: filename
     type(ESMF_FileFormat_Flag), intent(in), optional :: fileformat
     type(ESMF_DistGrid),    intent(in)             :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional  :: isSphere
     type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
     logical,                intent(in),  optional  :: addCornerStagger
     type(ESMF_TypeKind_Flag),intent(in), optional  :: coordTypeKind
     logical,                intent(in),  optional  :: addUserArea
     type(ESMF_Index_Flag),  intent(in),  optional  :: indexflag
     logical,                intent(in),  optional  :: addMask
     character(len=*),       intent(in),  optional  :: varname
     character(len=*),       intent(in),  optional  :: coordNames(:)
     integer,                intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This function creates a <TT>ESMF_Grid</TT> object using the grid definition from
   a grid file in NetCDF that is either in the SCRIP format or in the CF convention.
   To specify the distribution, the user passes in a <TT>distGrid</TT>.
   The grid defined in the file has to be a 2D logically rectangular grid.
   This function first call <TT>ESMF_GridCreateFrmNCFile()</TT> to create a <TT>ESMF_Grid</TT>
   object using a pre-calculated block distribution, then redistribute the Grid to
   create a new Grid object using the user specified <TT>distGrid</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
The arguments are:
   <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The NetCDF Grid filename.
   
</DD>
<DT><STRONG>[fileformat]</STRONG></DT>
<DD>The file format.  The valid options are <TT>ESMF_FILEFORMAT_SCRIP</TT> and <TT>ESMF_FILEFORMAT_GRIDSPEC</TT>.
       If it is the SCRIP format, the dimension <TT>grid_rank</TT> in the file has to be equal to 2.
        Please see section&nbsp;<A HREF="node9.html#const:fileformatflag">54.19</A> for a detailed description of the options.  
        If not specified, the file type will be detected automatically.
   
</DD>
<DT><STRONG>distGrid</STRONG></DT>
<DD>A distGrid defines how the grid is distributed
   
</DD>
<DT><STRONG>[isSphere]</STRONG></DT>
<DD>If .true., create a periodic Grid. If .false., create a regional Grid. Defaults to .true.
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section&nbsp;<A HREF="#const:polekind">31.2.5</A> for a full list of options. If not specified,
        the default is <TT>ESMF_POLEKIND_MONOPOLE</TT> for both.
   
</DD>
<DT><STRONG>[addCornerStagger]</STRONG></DT>
<DD>Uses the information in the grid file to add the Corner stagger to
        the Grid. The coordinates for the corner stagger is required for conservative
        regridding. If not specified, defaults to false.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. Only ESMF_TYPEKIND_R4
            and ESMF_TYPEKIND_R8 are allowed.  Currently, ESMF_TYPEKIND_R4 is only
            supported for the GRIDSPEC fileformat. 
            If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[addUserArea]</STRONG></DT>
<DD>If .true., read in the cell area from the Grid file, otherwise, ESMF will calculate it. The feature
        is only supported when the grid file is in the SCRIP format.  If not set, the default value is
        .false.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to <TT>ESMF_INDEX_DELOCAL</TT>.
   
</DD>
<DT><STRONG>[addMask]</STRONG></DT>
<DD>If .true., generate the mask using the missing_value attribute defined in 'varname'.
        This flag is only needed for the GRIDSPEC file format.  If not set, the default value is .false.
   
</DD>
<DT><STRONG>[varname]</STRONG></DT>
<DD>If addMask is true, provide a variable name stored in the grid file and
        the mask will be generated using the missing value of the data value of
        this variable.  The first two dimensions of the variable has to be the
        the longitude and the latitude dimension and the mask is derived from the
        first 2D values of this variable even if this data is 3D, or 4D array.
  
</DD>
<DT><STRONG>[coordNames]</STRONG></DT>
<DD>a two-element array containing the longitude and latitude variable names in a
        GRIDSPEC file if there are multiple coordinates defined in the file
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>
<A NAME="API:GridCreateFrmNCFile"></A>
<H3><A NAME="SECTION050861400000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_GridCreate - Create a Grid from a SCRIP or GRIDSPEC format grid file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
      function ESMF_GridCreateFrmNCFile(filename, fileformat, regDecomp, &amp;
        decompflag, delayout, isSphere, polekindflag, addCornerStagger, coordTypeKind, &amp;
        addUserArea, indexflag, addMask, varname, coordNames, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFrmNCFile
</PRE><EM>ARGUMENTS:</EM>
<PRE> 
     character(len=*),       intent(in)                :: filename
     type(ESMF_FileFormat_Flag), intent(in), optional  :: fileformat
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional     :: regDecomp(:)
     type(ESMF_Decomp_Flag), intent(in),  optional     :: decompflag(:)
     type(ESMF_DELayout),    intent(in),  optional     :: delayout
     logical,                intent(in),  optional     :: isSphere
     type(ESMF_PoleKind_Flag),  intent(in),  optional  :: polekindflag(2)
     logical,                intent(in),  optional     :: addCornerStagger 
     type(ESMF_TypeKind_Flag),intent(in), optional     :: coordTypeKind
     logical,                intent(in),  optional     :: addUserArea
     type(ESMF_Index_Flag),  intent(in),  optional     :: indexflag
     logical,                intent(in),  optional     :: addMask
     character(len=*),       intent(in),  optional     :: varname
     character(len=*),       intent(in),  optional     :: coordNames(:)
     integer,                intent(out), optional     :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This function creates a <TT>ESMF_Grid</TT> object using the grid definition from
   a grid file in NetCDF that is either in the SCRIP format or in the CF convention.
   To specify the distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompflag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.
   The grid defined in the file has to be a 2D logically rectangular
   grid.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
The arguments are:
   <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The NetCDF Grid filename.
   
</DD>
<DT><STRONG>[fileformat]</STRONG></DT>
<DD>The file format.  The valid options are <TT>ESMF_FILEFORMAT_SCRIP</TT> and <TT>ESMF_FILEFORMAT_GRIDSPEC</TT>.
       If it is the SCRIP format, the dimension <TT>grid_rank</TT> in the file has to be equal to 2.
       Please see section&nbsp;<A HREF="node9.html#const:fileformatflag">54.19</A> for a detailed
       description of the options. If not specified, the filetype will be automatically detected.
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>A 2 element array specifying how the grid is decomposed.
        Each entry is the number of decounts for that dimension.
        The total decounts cannot exceed the total number of PETs.  In other
        word, at most one DE is allowed per processor.
        If not specified, the default decomposition will be petCountx1.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
        possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>The DELayout that determines DE layout of DEs across PETs. The default is to create a default
        DELayout with the correct number of DEs according to the <TT>regDecomp</TT>. See the documentation of
        the <TT>ESMF_DELayoutCreate()</TT> method for details about the default DELayout.
   
</DD>
<DT><STRONG>[isSphere]</STRONG></DT>
<DD>If .true., create a periodic Grid. If .false., create a regional Grid. Defaults to .true.
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section&nbsp;<A HREF="#const:polekind">31.2.5</A> for a full list of options. If not specified,
        the default is <TT>ESMF_POLEKIND_MONOPOLE</TT> for both.
   
</DD>
<DT><STRONG>[addCornerStagger]</STRONG></DT>
<DD>Uses the information in the grid file to add the Corner stagger to
        the Grid. The coordinates for the corner stagger is required for conservative
        regridding. If not specified, defaults to false.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. Only ESMF_TYPEKIND_R4
            and ESMF_TYPEKIND_R8 are allowed.  Currently, ESMF_TYPEKIND_R4 is only
            supported for the GRIDSPEC fileformat. 
            If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[addUserArea]</STRONG></DT>
<DD>If .true., read in the cell area from the Grid file, otherwise, ESMF will calculate it.  The feature
        is only supported when the grid file is in the SCRIP format.  If not set, the default value is
        .false.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to <TT>ESMF_INDEX_DELOCAL</TT>.
   
</DD>
<DT><STRONG>[addMask]</STRONG></DT>
<DD>If .true., generate the mask using the missing_value attribute defined in 'varname'. This flag
        is only needed for the GRIDSPEC file format.  If not set, the default value is .false.
   
</DD>
<DT><STRONG>[varname]</STRONG></DT>
<DD>If addMask is true, provide a variable name stored in the grid file and
        the mask will be generated using the missing value of the data value of
        this variable.  The first two dimensions of the variable has to be the
        the longitude and the latitude dimension and the mask is derived from the
        first 2D values of this variable even if this data is 3D, or 4D array.
  
</DD>
<DT><STRONG>[coordNames]</STRONG></DT>
<DD>a two-element array containing the longitude and latitude variable names in a
        GRIDSPEC file if there are multiple coordinates defined in the file
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861500000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_GridCreate1PeriDim - Create a Grid with one periodic dim and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimI(minIndex,         &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         polekindflag, periodicDim, poleDim,                   &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimI
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with one periodic dimension.
   To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension. Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
   cells on the DE in that dimension.

<P>
Section <A HREF="#example:2DIrregUniGrid">31.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location).
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section&nbsp;<A HREF="#const:polekind">31.2.5</A> for a full list of options. If not specified,
        the default is <TT>ESMF_POLEKIND_MONOPOLE</TT> for both.
   
</DD>
<DT><STRONG>[periodicDim]</STRONG></DT>
<DD>The periodic dimension. If not specified, defaults to 1.
   
</DD>
<DT><STRONG>[poleDim]</STRONG></DT>
<DD>The dimension at who's ends the poles are located. If not specified defaults to 2.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861600000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_GridCreate1PeriDim - Create a Grid with one periodic dim and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimR(regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                    &amp;
         polekindflag, periodicDim, poleDim,                        &amp;
         coordSys, coordTypeKind,                               &amp;
         coordDep1, coordDep2, coordDep3,                       &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,             &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with one periodic dimension.
   To specify the distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The arguments are:
   <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
  !      possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section&nbsp;<A HREF="#const:polekind">31.2.5</A> for a full list of options. If not specified,
        the default is <TT>ESMF_POLEKIND_MONOPOLE</TT> for both.
   
</DD>
<DT><STRONG>[periodicDim]</STRONG></DT>
<DD>The periodic dimension. If not specified, defaults to 1.
   
</DD>
<DT><STRONG>[poleDim]</STRONG></DT>
<DD>The dimension at who's ends the poles are located. If not specified defaults to 2.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861700000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_GridCreate1PeriDim - Create a Grid with one periodic dim and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimA(minIndex, maxIndex,  &amp;
         arbIndexCount, arbIndexList,                         &amp;
         polekindflag, periodicDim, poleDim,                      &amp;
         coordSys, coordTypeKind,                             &amp;
         coordDep1, coordDep2, coordDep3,                     &amp;
         distDim, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimA
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
         integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)                    :: arbIndexCount
        integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with one periodic dimension.
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The
   size of <TT>distDim</TT> has to agree with the size of the second dimension of
   <TT>localArbIndex</TT>.

<P>
Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   
</DD>
<DT><STRONG>arbIndexList</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section&nbsp;<A HREF="#const:polekind">31.2.5</A> for a full list of options. If not specified,
        the default is <TT>ESMF_POLEKIND_MONOPOLE</TT> for both.
   
</DD>
<DT><STRONG>[periodicDim]</STRONG></DT>
<DD>The periodic dimension. If not specified, defaults to 1.
   
</DD>
<DT><STRONG>[poleDim]</STRONG></DT>
<DD>The dimension at who's ends the poles are located. If not specified defaults to 2.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
  !     arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861800000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_GridCreate2PeriDim - Create a Grid with two periodic dims and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimI(minIndex,         &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimI
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with two periodic dimensions.
   To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension. Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
  ! cells on the DE in that dimension.

<P>
Section <A HREF="#example:2DIrregUniGrid">31.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location).
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
  ! 
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>!      Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861900000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_GridCreate2PeriDim - Create a Grid with two periodic dims and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimR(regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                    &amp;
         coordSys, coordTypeKind,                               &amp;
         coordDep1, coordDep2, coordDep3,                       &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,             &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with two periodic dimensions.
   To specify the distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The arguments are:
   <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
        possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_GridCreate2PeriDim - Create a Grid with two periodic dims and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimA(minIndex, maxIndex, &amp;
         arbIndexCount, arbIndexList,                        &amp;
         coordSys, coordTypeKind,                            &amp;
         coordDep1, coordDep2, coordDep3,                    &amp;
         distDim, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimA
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)                    :: arbIndexCount
         integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with two periodic dimensions.
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The
   size of <TT>distDim</TT> has to agree with the size of the second dimension of
   <TT>localArbIndex</TT>.

<P>
Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   
</DD>
<DT><STRONG>arbIndexList</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
  ! 
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_GridCreateNoPeriDim - Create a Grid with no periodic dim and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateNoPeriDim()
       function ESMF_GridCreateNoPeriDimI(minIndex,        &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimI
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) without a periodic dimension.
   To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension. Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
   cells on the DE in that dimension.

<P>
Section <A HREF="#example:2DIrregUniGrid">31.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
  !     for the exclusive region (center stagger location).
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
  ! 
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_GridCreateNoPeriDim - Create a Grid with no periodic dim and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateNoPeriDim()
       function ESMF_GridCreateNoPeriDimR(regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                     &amp;
         coordSys, coordTypeKind,                                &amp;
         coordDep1, coordDep2, coordDep3,                        &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,              &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
         integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with no periodic dimension.
   To specify the distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The arguments are:
   <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
        possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
  !     of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
  !       should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862300000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_GridCreateNoPeriDim - Create a Grid with no periodic dim and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateNoPeriodic()
       function ESMF_GridCreateNoPeriDimA(minIndex, maxIndex, &amp;
         arbIndexCount, arbIndexList,                         &amp;
         coordSys, coordTypeKind,                             &amp;
         coordDep1, coordDep2, coordDep3,                     &amp;
         distDim, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>        type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimA
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)                    :: arbIndexCount
        integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with no periodic dimension.
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The
   size of <TT>distDim</TT> has to agree with the size of the second dimension of
   <TT>localArbIndex</TT>.

<P>
Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   
</DD>
<DT><STRONG>arbIndexList</STRONG></DT>
<DD>!      This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
  !      where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_DIM_ARB.
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
   !       The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862400000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_GridCreate1PeriDimUfrm - Create a uniform Grid with one periodic dim and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate1PeriDimUfrm()
       function ESMF_GridCreate1PeriDimUfrmR(minIndex, maxIndex, &amp;
            minCornerCoord, maxCornerCoord, &amp;
            regDecomp, decompFlag, &amp;
            polekindflag, coordSys, staggerLocList, &amp;
            ignoreNonPeriCoord, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>        type(ESMF_Grid) :: ESMF_GridCreate1PeriDimUfrmR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        real(ESMF_KIND_R8),        intent(in)            :: minCornerCoord(:)
        real(ESMF_KIND_R8),        intent(in)            :: maxCornerCoord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_StaggerLoc),     intent(in),  optional :: staggerLocList(:)
        logical,                   intent(in),  optional :: ignoreNonPeriCoord
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with one periodic dimension.
   The periodic dimension in the resulting grid will be dimension 1.
   The dimension with the poles at either end (i.e. the pole dimension)
   will be dimension 2.

<P>
The grid will have its coordinates uniformly spread between the
   ranges specified by the user. The coordinates are ESMF_TYPEKIND_R8.
   Currently, this method only fills the center stagger with coordinates, and
   the <TT>minCornerCoord</TT> and <TT>maxCornerCoord</TT> arguments give the boundaries of
   the center stagger.

<P>
To specify the distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The following arguments have been set to non-typical values and so
    there is a reasonable possibility that they may change in the future
    to be inconsistent with other Grid create interfaces:

<P>
The arguments coordDep1, coordDep2, and coordDep3 have internally
    been set to 1, 2, and 3 respectively.
    This was done because this call creates a uniform grid and so only 1D arrays
    are needed to hold the coordinates. This means the coordinate arrays
    will be 1D.

<P>
The argument indexFlag has internally been set to ESMF_INDEX_GLOBAL. This
    means that the grid created from this function will have a global index space.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>minCornerCoord</STRONG></DT>
<DD>The coordinates of the corner of the grid that corresponds to <TT>minIndex</TT>.
        size(minCornerCoord) must be equal to size(maxIndex).
   
</DD>
<DT><STRONG>maxCornerCoord</STRONG></DT>
<DD>The coordinates of the corner of the grid that corresponds to <TT>maxIndex</TT>.
        size(maxCornerCoord) must be equal to size(maxIndex).
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>A ndims-element array specifying how the grid is decomposed.
        Each entry is the number of decounts for that dimension.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
        possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section&nbsp;<A HREF="#const:polekind">31.2.5</A> for a full list of options. If not specified,
        the default is <TT>ESMF_POLEKIND_MONOPOLE</TT> for both.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[staggerLocList]</STRONG></DT>
<DD>The list of stagger locations to fill with coordinates. Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A>
       for a description of the available stagger locations. If not present, then
       no staggers are added or filled.
   
</DD>
<DT><STRONG>[ignoreNonPeriCoord]</STRONG></DT>
<DD>If .true., do not check if the coordinates for the periodic dimension (i.e. dim=1) specify a full periodic range (e.g. 0 to 360 degrees).
       If not specified, defaults to .false. .
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862500000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_GridCreate1PeriDimUfrm - Create a uniform Grid with one periodic dim and a block distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate1PeriDimUfrm()
   function ESMF_GridCreate1PeriDimUfrmB(minIndex, maxIndex, &amp;
             minCornerCoord, maxCornerCoord, &amp;
             deBlockList, deLabelList, &amp;
             polekindflag, coordSys, staggerLocList, &amp;
             ignoreNonPeriCoord, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Grid) :: ESMF_GridCreate1PeriDimUfrmB
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                   intent(in),  optional :: minIndex(:)
     integer,                   intent(in)            :: maxIndex(:)
     real(ESMF_KIND_R8),        intent(in)            :: minCornerCoord(:)
     real(ESMF_KIND_R8),        intent(in)            :: maxCornerCoord(:)
     integer,                   intent(in)            :: deBlockList(:,:,:)
     integer,                   intent(in),  optional :: deLabelList(:)
     type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
     type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
     type(ESMF_StaggerLoc),     intent(in),  optional :: staggerLocList(:)
     logical,                   intent(in),  optional :: ignoreNonPeriCoord
     integer,                   intent(in),  optional :: petMap(:,:,:)
     character (len=*),         intent(in),  optional :: name
     integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with one periodic dimension.
   The periodic dimension in the resulting grid will be dimension 1.
   The dimension with the poles at either end (i.e. the pole dimension)
   will be dimension 2.

<P>
The grid will have its coordinates uniformly spread between the
   ranges specified by the user. The coordinates are ESMF_TYPEKIND_R8.
   Currently, this method only fills the center stagger with coordinates, and
   the <TT>minCornerCoord</TT> and <TT>maxCornerCoord</TT> arguments give the boundaries of
   the center stagger.

<P>
To specify the distribution, the user passes in an array
   (<TT>deBlockList</TT>) specifying index space blocks for each DE.

<P>
The following arguments have been set to non-typical values and so
    there is a reasonable possibility that they may change in the future
    to be inconsistent with other Grid create interfaces:

<P>
The arguements coordDep1, coordDep2, and coordDep3 have internally
    been set to 1, 2, and 3 respectively.
    This was done because this call creates a uniform grid and so only 1D arrays
    are needed to hold the coordinates. This means the coordinate arrays
    will be 1D.

<P>
The argument indexFlag has internally been set to ESMF_INDEX_GLOBAL. This
    means that the grid created from this function will have a global index space.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>minCornerCoord</STRONG></DT>
<DD>The coordinates of the corner of the grid that corresponds to <TT>minIndex</TT>.
        size(minCornerCoord) must be equal to size(maxIndex).
   
</DD>
<DT><STRONG>maxCornerCoord</STRONG></DT>
<DD>The coordinates of the corner of the grid that corresponds to <TT>maxIndex</TT>.
        size(maxCornerCoord) must be equal to size(maxIndex).
   
</DD>
<DT><STRONG>deBlockList</STRONG></DT>
<DD>List of DE-local LR blocks. The third index of <TT>deBlockList</TT>
        steps through the deBlock elements, which are defined by the first
        two indices. The first index must be of size <TT>dimCount</TT> and the
        second index must be of size 2. Each 2D element of <TT>deBlockList</TT>
        defined by the first two indices hold the following information.
        <PRE>
                 +---------------------------------------&gt; 2nd index
                 |    1               2
                 | 1  minIndex(1)    maxIndex(1)
                 | 2  minIndex(2)    maxIndex(2)
                 | .  minIndex(.)    maxIndex(.)
                 | .
                 v
                1st index
</PRE>
        It is required that there be no overlap between the LR segments
        defined by deBlockList.
   
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
        sequence is given by the order of DEs in the <TT>deBlockList</TT>
        argument.
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. The value in polekindflag(1)
        specifies the connection that occurs at the minimum end of the pole dimension. The value in polekindflag(2)
        specifies the connection that occurs at the maximum end of the pole dimension. Please see
        Section&nbsp;<A HREF="#const:polekind">31.2.5</A> for a full list of options. If not specified,
        the default is <TT>ESMF_POLEKIND_MONOPOLE</TT> for both.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[staggerLocList]</STRONG></DT>
<DD>The list of stagger locations to fill with coordinates. Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A>
       for a description of the available stagger locations. If not present, then
       no staggers are added or filled.
   
</DD>
<DT><STRONG>[ignoreNonPeriCoord]</STRONG></DT>
<DD>If .true., do not check if the coordinates for the periodic dimension (i.e. dim=1) specify a full periodic range (e.g. 0 to 360 degrees).
       If not specified, defaults to .false. .
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862600000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_GridCreateNoPeriDimUfrm - Create a uniform Grid with no periodic dim and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  ! Private name; call using ESMF_GridCreateNoPeriDimUfrm()
       function ESMF_GridCreateNoPeriDimUfrmR(minIndex, maxIndex, &amp;
         minCornerCoord, maxCornerCoord, &amp;
         regDecomp, decompFlag, &amp;
         coordSys, staggerLocList, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimUfrmR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        real(ESMF_KIND_R8),        intent(in)            :: minCornerCoord(:)
        real(ESMF_KIND_R8),        intent(in)            :: maxCornerCoord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_StaggerLoc),     intent(in),  optional :: staggerLocList(:)
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name
        integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>) with no periodic dimension.

<P>
The resulting grid will have its coordinates uniformly spread between the
   ranges specified by the user. The coordinates are ESMF_TYPEKIND_R8.
   Currently, this method only fills the center stagger with coordinates, and
   the <TT>minCornerCoord</TT> and <TT>maxCornerCoord</TT> arguments give the boundaries of
   the center stagger.

<P>
To specify the distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
The following arguments have been set to non-typical values and so
    there is a reasonable possibility that they may change in the future
    to be inconsistent with other Grid create interfaces:

<P>
The arguements coordDep1, coordDep2, and coordDep3 have internally
    been set to 1, 2, and 3 respectively.
    This was done because this call creates a uniform grid and so only 1D arrays
    are needed to hold the coordinates. This means the coordinate arrays
    will be 1D.

<P>
The argument indexFlag has internally been set to ESMF_INDEX_GLOBAL. This
    means that the grid created from this function will have a global index space.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>minCornerCoord</STRONG></DT>
<DD>The coordinates of the corner of the grid that corresponds to <TT>minIndex</TT>.
        size(minCornerCoord) must be equal to size(maxIndex).
   
</DD>
<DT><STRONG>maxCornerCoord</STRONG></DT>
<DD>The coordinates of the corner of the grid that corresponds to <TT>maxIndex</TT>.
        size(maxCornerCoord) must be equal to size(maxIndex).
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>A ndims-element array specifying how the grid is decomposed.
        Each entry is the number of decounts for that dimension.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
        possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[staggerLocList]</STRONG></DT>
<DD>The list of stagger locations to fill with coordinates. Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A>
       for a description of the available stagger locations. If not present, then
       no staggers are added or filled.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862700000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_GridCreateCubedSphere - Create a multi-tile cubed sphere Grid with regular decomposition</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateCubedSphere()
   function ESMF_GridCreateCubedSphereReg(tileSize,&amp;
         regDecompPTile, decompflagPTile,                        &amp;
         coordSys, coordTypeKind,                                &amp;
         deLabelList, staggerLocList,                            &amp;
         delayout, indexflag, name, transformArgs, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Grid) :: ESMF_GridCreateCubedSphereReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                        intent(in)            :: tilesize
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                        intent(in),  optional :: regDecompPTile(:,:)
     type(ESMF_Decomp_Flag), target, intent(in),  optional :: decompflagPTile(:,:)
     type(ESMF_CoordSys_Flag),       intent(in),  optional :: coordSys
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: coordTypeKind
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_StaggerLoc),          intent(in),  optional :: staggerLocList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     character(len=*),               intent(in),  optional :: name
     type(ESMF_CubedSphereTransform_Args), intent(in),  optional :: transformArgs
     integer,                        intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a six-tile <TT>ESMF_Grid</TT> for a Cubed Sphere grid using regular decomposition.  Each tile can
     have different decomposition.  The grid coordinates are generated based on the algorithm used by GEOS-5,
     The tile resolution is defined by tileSize.

<P>
The arguments are:
       <DL>
<DT><STRONG>tilesize</STRONG></DT>
<DD>The number of elements on each side of the tile of the Cubed Sphere grid.
       
</DD>
<DT><STRONG>[regDecompPTile]</STRONG></DT>
<DD>List of DE counts for each dimension. The second index steps through
            the tiles. The total <TT>deCount</TT> is determined as the sum over
            the products of <TT>regDecompPTile</TT> elements for each tile.
            By default every tile is decomposed in the same way.  If the total
            PET count is less than 6, one tile will be assigned to one DE and the DEs
            will be assigned to PETs sequentially, therefore, some PETs may have
            more than one DE.  If the total PET count is greater than 6, the total
            number of DEs will be a multiple of 6 and less than or equal to the total
            PET count.  For instance, if the total PET count is 16, the total DE count
            will be 12 with each tile decomposed into 1x2 blocks.  The 12 DEs are mapped
            to the first 12 PETs and the remaining 4 PETs have no DEs locally, unless
            an optional <TT>delayout</TT> is provided.
       
</DD>
<DT><STRONG>[decompflagPTile]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of each
            tile is to be divided between the DEs. The default setting
            is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions for all tiles.
            See section <A HREF="node9.html#const:decompflag">54.13</A> for a list of valid decomposition
            flag options. The second index indicates the tile number.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecompPTile</TT>
            elements in the sequence as they appear following the tile index.
       
</DD>
<DT><STRONG>[staggerLocList]</STRONG></DT>
<DD>The list of stagger locations to fill with coordinates. Only <TT>ESMF_STAGGERLOC_CENTER</TT>
            and <TT>ESMF_STAGGERLOC_CORNER</TT> are supported.  If not present, no coordinates
            will be added or filled.
       
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
            Only ESMF_COORDSYS_SPH_DEG and ESMF_COORDSYS_SPH_RAD are supported. 
            If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
       
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. Only ESMF_TYPEKIND_R4
            and ESMF_TYPEKIND_R8 are supported.
            If not specified then defaults to ESMF_TYPEKIND_R8.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with as many DEs as there are PETs,
            or tiles, which ever is greater. If a DELayout object is specified,
            the number of DEs must match <TT>regDecompPTile</TT>, if present. In the
            case that <TT>regDecompPTile</TT> was not specified, the <TT>deCount</TT>
            must be at least that of the default DELayout. The
            <TT>regDecompPTile</TT> will be constructed accordingly.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
            Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
            defaults to ESMF_INDEX_DELOCAL.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
       
</DD>
<DT><STRONG>[transformArgs]</STRONG></DT>
<DD>A data type containing the stretch factor, target longitude, and target latitude
            to perform a Schmidt transformation on the Cubed-Sphere grid. See section
            <A HREF="#sec:usage:cubedspherewttransform">31.3.11</A> for details.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862800000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_GridCreateCubedSphere - Create a multi-tile cubed sphere Grid with irregular decomposition</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateCubedSphere()
   function ESMF_GridCreateCubedSphereIReg(tileSize,             &amp;
         countsPerDEDim1PTile, countsPerDEDim2PTile,             &amp;
                                                &amp;        
         coordSys, coordTypeKind,                                &amp;
         deLabelList, staggerLocList,                            &amp;
         delayout, indexflag, name, transformArgs, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Grid) :: ESMF_GridCreateCubedSphereIReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                        intent(in)            :: tilesize
     integer,                        intent(in)            :: countsPerDEDim1PTile(:,:)
     integer,                        intent(in)            :: countsPerDEDim2PTile(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_CoordSys_Flag),       intent(in),  optional :: coordSys
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: coordTypeKind
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_StaggerLoc),          intent(in),  optional :: staggerLocList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     character(len=*),               intent(in),  optional :: name
     type(ESMF_CubedSphereTransform_Args), intent(in),  optional :: transformArgs
     integer,                        intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a six-tile <TT>ESMF_Grid</TT> for a Cubed Sphere grid using irregular decomposition.  Each tile can
     have different decomposition.  The grid coordinates are generated based on the algorithm used by GEOS-5,
     The tile resolution is defined by tileSize.

<P>
The arguments are:
       <DL>
<DT><STRONG>tilesize</STRONG></DT>
<DD>The number of elements on each side of the tile of the Cubed Sphere grid.
       
</DD>
<DT><STRONG>countsPerDEDim1PTile</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 1 for the
            center stagger location. The second index steps through the tiles. If each tile is 
            decomposed into different number of DEs, the first dimension is the maximal DEs of 
            all the tiles.  
       
</DD>
<DT><STRONG>countsPerDEDim2PTile</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2 for the
            center stagger location. The second index steps through the tiles. If each tile is 
            decomposed into different number of DEs, the first dimension is the maximal DEs of 
            all the tiles.  
       
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
            Only ESMF_COORDSYS_SPH_DEG and ESMF_COORDSYS_SPH_RAD are supported. 
            If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
       
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. Only ESMF_TYPEKIND_R4
            and ESMF_TYPEKIND_R8 are supported.
            If not specified then defaults to ESMF_TYPEKIND_R8.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order in the sequence as they appear
            in <TT>countsPerDEDim1PTile</TT>, followed by <TT>countsPerDEDim2PTile</TT>, then the 
            tile index.
       
</DD>
<DT><STRONG>[staggerLocList]</STRONG></DT>
<DD>The list of stagger locations to fill with coordinates. Only <TT>ESMF_STAGGERLOC_CENTER</TT>
            and <TT>ESMF_STAGGERLOC_CORNER</TT> are supported.  If not present, no coordinates
            will be added or filled.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional ESMF_DELayout object to be used. If a delayout object is specified,
            the number of DEs must match with the total DEs defined in <TT>countsPerDEDim1PTile</TT>
            and <TT>countsPerDEDim2PTile</TT>.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
            Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
            defaults to ESMF_INDEX_DELOCAL.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
       
</DD>
<DT><STRONG>[transformArgs]</STRONG></DT>
<DD>A data type containing the stretch factor, target longitude, and target latitude
            to perform a Schmidt transformation on the Cubed-Sphere grid. See section
            <A HREF="#sec:usage:cubedspherewttransform">31.3.11</A> for details.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>
<A NAME="API:GridCreateMosaicReg"></A>
<H3><A NAME="SECTION050862900000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_GridCreateMosaic - Create a multi-tile Grid object with regular decomposition using the grid definition from a GRIDSPEC Mosaic file.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_GridCreateMosaicReg(filename,regDecompPTile, decompflagPTile, &amp;
         coordTypeKind, deLabelList, staggerLocList, delayout, indexflag, name, tileFilePath, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Grid) :: ESMF_GridCreateMosaicReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),               intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                        intent(in),  optional :: regDecompPTile(:,:)
     type(ESMF_Decomp_Flag), target, intent(in),  optional :: decompflagPTile(:,:)
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: coordTypeKind
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_StaggerLoc),          intent(in),  optional :: staggerLocList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     character(len=*),               intent(in),  optional :: name
     character(len=*),               intent(in),  optional :: tileFilePath
     integer,                        intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a multiple-tile <TT>ESMF_Grid</TT> based on the definition from a GRIDSPEC Mosaic file and its associated
     tile files using regular decomposition.  Each tile can have different decomposition.  The tile connections
     are defined in a GRIDSPEC format Mosaic file.
     And each tile's coordination is defined in a separate NetCDF file.  The coordinates defined
     in the tile file is so-called "Super Grid".  In other words, the dimensions of the coordinate variables are
     <TT>(2*xdim+1, 2*ydim+1)</TT> if <TT>(xdim, ydim)</TT> is the size of the tile.  The Super Grid combines the corner,
     the edge and the center coordinates in one big array.  A Mosaic file may contain just one tile.  If a Mosaic contains
     multiple tiles.  Each tile is a logically rectangular lat/lon grid.  Currently, all the tiles have to be the same size.
     We will remove this limitation in the future release.

<P>
The arguments are:
       <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The name of the GRIDSPEC Mosaic file.
       
</DD>
<DT><STRONG>[regDecompPTile]</STRONG></DT>
<DD>List of DE counts for each dimension. The second index steps through
            the tiles. The total <TT>deCount</TT> is determined as the sum over
            the products of <TT>regDecompPTile</TT> elements for each tile.
            By default every tile is decomposed in the same way.  If the total
            PET count is less than the tile count, one tile will be assigned to one DE and the DEs
            will be assigned to PETs sequentially, therefore, some PETs may have
            more than one DE.  If the total PET count is greater than the tile count, the total
            number of DEs will be a multiple of the tile count and less than or equal to the total
            PET count.  For instance, if the total PET count is 16 and the tile count is 6, the total DE count
            will be 12 with each tile decomposed into 1x2 blocks.  The 12 DEs are mapped
            to the first 12 PETs and the remaining 4 PETs have no DEs locally, unless
            an optional <TT>delayout</TT> is provided.
       
</DD>
<DT><STRONG>[decompflagPTile]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of each
            tile is to be divided between the DEs. The default setting
            is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions for all tiles.
            See section <A HREF="node9.html#const:decompflag">54.13</A> for a list of valid decomposition
            flag options. The second index indicates the tile number.
       
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. Only ESMF_TYPEKIND_R4
            and ESMF_TYPEKIND_R8 are supported.
            If not specified then defaults to ESMF_TYPEKIND_R8.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecompPTile</TT>
            elements in the sequence as they appear following the tile index.
       
</DD>
<DT><STRONG>[staggerLocList]</STRONG></DT>
<DD>The list of stagger locations to fill with coordinates. Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A>
            for a description of the available stagger locations. If not present, no coordinates
            will be added or filled.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with as many DEs as there are PETs,
            or tiles, which ever is greater. If a DELayout object is specified,
            the number of DEs must match <TT>regDecompPTile</TT>, if present. In the
            case that <TT>regDecompPTile</TT> was not specified, the <TT>deCount</TT>
            must be at least that of the default DELayout. The
            <TT>regDecompPTile</TT> will be constructed accordingly.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
            Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
            defaults to ESMF_INDEX_DELOCAL.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
       
</DD>
<DT><STRONG>[tileFilePath]</STRONG></DT>
<DD>Optional argument to define the path where the tile files reside. If it
            is given, it overwrites the path defined in <TT>gridlocation</TT> variable
            in the mosaic file.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_GridCreateMosaic - Create a multi-tile Grid object with irregular decomposition using the grid definition from a GRIDSPEC Mosaic file.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_GridCreateMosaicIReg(filename,                  &amp;
           countsPerDEDim1PTile, countsPerDEDim2PTile,           &amp;
                                                &amp;
           coordTypeKind,                                        &amp;
           deLabelList, staggerLocList,                          &amp;
           delayout, indexflag, name, tileFilePath, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Grid) :: ESMF_GridCreateMosaicIReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),               intent(in)            :: filename
     integer,                        intent(in)            :: countsPerDEDim1PTile(:,:)
     integer,                        intent(in)            :: countsPerDEDim2PTile(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: coordTypeKind
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_StaggerLoc),          intent(in),  optional :: staggerLocList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     character(len=*),               intent(in),  optional :: name
     character(len=*),               intent(in),  optional :: tileFilePath
     integer,                        intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a multiple-tile <TT>ESMF_Grid</TT> based on the definition from a GRIDSPEC Mosaic file and its associated
     tile files using irregular decomposition.  Each tile can have different decomposition.  The tile connections
     are defined in a GRIDSPEC format Mosaic file.
     And each tile's coordination is defined in a separate NetCDF file.  The coordinates defined
     in the tile file is so-called "Super Grid".  In other words, the dimensions of the coordinate variables are
     <TT>(2*xdim+1, 2*ydim+1)</TT> if <TT>(xdim, ydim)</TT> is the size of the tile.  The Super Grid combines the corner,
     the edge and the center coordinates in one big array.  A Mosaic file may contain just one tile.  If a Mosaic contains
     multiple tiles.  Each tile is a logically rectangular lat/lon grid.  Currently, all the tiles have to be the same size.
     We will remove this limitation in the future release.

<P>
The arguments are:
       <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The name of the GRIDSPEC Mosaic file.
       
</DD>
<DT><STRONG>countsPerDEDim1PTile</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 1 for the
            center stagger location. The second index steps through the tiles. If each tile is 
            decomposed into different number of DEs, the first dimension is the maximal DEs of 
            all the tiles.  
       
</DD>
<DT><STRONG>countsPerDEDim2PTile</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2 for the
            center stagger location. The second index steps through the tiles. If each tile is 
            decomposed into different number of DEs, the first dimension is the maximal DEs of 
            all the tiles.  
       
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. Only ESMF_TYPEKIND_R4
            and ESMF_TYPEKIND_R8 are supported.
            If not specified then defaults to ESMF_TYPEKIND_R8.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order in the sequence as they appear
            in <TT>countsPerDEDim1PTile</TT>, followed by <TT>countsPerDEDim2PTile</TT>, then the 
            tile index.
       
</DD>
<DT><STRONG>[staggerLocList]</STRONG></DT>
<DD>The list of stagger locations to fill with coordinates. Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A>
            for a description of the available stagger locations. If not present, no coordinates
            will be added or filled.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional ESMF_DELayout object to be used. If a delayout object is specified,
            the number of DEs must match with the total DEs defined in <TT>countsPerDEDim1PTile</TT>
            and <TT>countsPerDEDim2PTile</TT>.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
            Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
            defaults to ESMF_INDEX_DELOCAL.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
       
</DD>
<DT><STRONG>[tileFilePath]</STRONG></DT>
<DD>Optional argument to define the path where the tile files reside. If it
            is given, it overwrites the path defined in <TT>gridlocation</TT> variable
            in the mosaic file.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_GridDestroy - Release resources associated with a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_GridDestroy(grid, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid), intent(inout)         :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,         intent(in),  optional :: noGarbage
       integer,         intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_Grid</TT> object and related internal structures.
   This call does destroy internally created DistGrid and DELayout classes,
   for example those created by <TT>ESMF_GridCreateShapeTile()</TT>. It also
   destroys internally created coordinate/item Arrays, for example those
   created by <TT>ESMF_GridAddCoord()</TT>. However, if the user uses an
   externally created class, for example creating an Array and setting it
   using <TT>ESMF_GridSetCoord()</TT>, then that class is not destroyed by
   this method.

<P>
By default a small remnant of the object is kept in memory in order to
     prevent problems with dangling aliases. The default garbage collection
     mechanism can be overridden with the <TT>noGarbage</TT> argument.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to be destroyed.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this
        condition ESMF cannot protect against accessing the destroyed object
        through dangling aliases - a situation which may lead to hard to debug
        application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
        set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use
        temporary ESMF objects. For situations where the repeated creation and
        destruction of temporary objects leads to memory issues, it is
        recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
        removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_GridEmptyComplete - Complete a Grid with user set edge connections and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridEmptyComplete()
       subroutine ESMF_GridEmptyCompleteEConnI(grid, minIndex,         &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         connDim1, connDim2, connDim3,                     &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: countsPerDEDim1(:)
        integer,                  intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                  intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method takes in an empty Grid created by <TT>ESMF_GridEmptyCreate()</TT>.
   It then completes the grid to form a single tile, irregularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>). To specify the irregular distribution, the user passes in an array
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension. Currently this call only
   supports creating 2D or 3D Grids. A 2D Grid can be specified using the
   countsPerDEDim1 and countsPerDEDim2 arguments.  A 3D Grid can
   be specified by also using the optional countsPerDEDim3 argument.
   The index of each array element in these arguments corresponds to
   a DE number.  The array value at the index is the number of grid
   cells on the DE in that dimension.

<P>
Section <A HREF="#example:2DIrregUniGrid">31.3.4</A> shows an example
   of using an irregular distribution to create a 2D Grid with uniformly spaced
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
For consistency's sake the <TT>ESMF_GridEmptyComplete()</TT> call
   should be executed in the same set or a subset of the PETs in which the
   <TT>ESMF_GridEmptyCreate()</TT> call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The empty <TT>ESMF_Grid</TT> to set information into and then commit.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location).
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).
       If not specified  then grid is 2D.
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863300000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_GridEmptyComplete - Complete a Grid with user set edge connections and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridEmptyComplete()
      subroutine ESMF_GridEmptyCompleteEConnR(grid, regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                    &amp;
         connDim1, connDim2, connDim3,                       &amp;
         coordSys, coordTypeKind,                            &amp;
         coordDep1, coordDep2, coordDep3,                    &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,          &amp;
         gridMemLBound, indexflag, petMap, name, rc)
 
  !
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),   intent(in),  optional :: decompflag(:)
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method takes in an empty Grid created by <TT>ESMF_GridEmptyCreate()</TT>.
   It then completes the grid to form a single tile, regularly distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>).
   To specify the distribution, the user passes in an array
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible. Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
For consistency's sake the <TT>ESMF_GridEmptyComplete()</TT> call
   should be executed in the same set or a subset of the PETs in which the
   <TT>ESMF_GridEmptyCreate()</TT> call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The empty <TT>ESMF_Grid</TT> to set information into and then commit.
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the
        possible options. Note that currently the option
        <TT>ESMF_DECOMP_CYCLIC</TT> isn't supported in Grid creation.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 0, 0, ..., 0 (all zeros).
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. If this and gridAlign are not present then
        defaults to 1, 1, ..., 1 (all ones).
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the gridEdgeWidths are not specified than this argument
       implies the gridEdgeWidths. If the gridEdgeWidths are specified and this argument isn't
       then this argument is implied by the gridEdgeWidths.
       If this and the gridEdgeWidths are not specified, then defaults to
      -1, -1, ..., -1 (all negative ones).
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid.
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863400000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_GridEmptyComplete - Complete a Grid with user set edge connections and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridEmptyComplete()
       subroutine ESMF_GridEmptyCompleteEConnA(grid, minIndex, maxIndex,  &amp;
         arbIndexCount, arbIndexList,                         &amp;
         connDim1, connDim2, connDim3,                     &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         distDim, name, rc)
  !
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
        integer,                  intent(in)            :: arbIndexCount
        integer,                  intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: distDim(:)
        character (len=*),        intent(in),  optional :: name
        integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method takes in an empty Grid created by <TT>ESMF_GridEmptyCreate()</TT>.
   It then completes the grid to form a single tile, arbitrarily distributed grid
   (see Figure <A HREF="#fig:GridDecomps">13</A>).
   To specify the arbitrary distribution, the user passes in an 2D array
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The
   size of <TT>distDim</TT> has to agree with the size of the second dimension of
   <TT>localArbIndex</TT>.

<P>
Currently this call
   only supports creating a 2D or 3D Grid, and thus, for example, <TT>maxIndex</TT> must be of size 2 or 3.

<P>
For consistency's sake the <TT>ESMF_GridEmptyComplete()</TT> call
   should be executed in the same set or a subset of the PETs in which the
   <TT>ESMF_GridEmptyCreate()</TT> call was made. If the call
   is made in a subset, the Grid objects outside that subset will
   still be "empty" and not usable.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The empty <TT>ESMF_Grid</TT> to set information into and then commit.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.
   
</DD>
<DT><STRONG>arbIndexList</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end.
        Please see Section&nbsp;<A HREF="#const:gridconn">31.2.1</A> for a list of valid
        options. If not present, defaults to ESMF_GRIDCONN_NONE.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
       For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
       listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
       If not specified then defaults to ESMF_TYPEKIND_R8.
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_GRID_ARBDIM/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_GRID_ARBDIM.
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_GRID_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_GRID_ARBDIM.
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that
       is not distributed (if exists).
       If not present the default is /ESMF_GRID_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
        Please see Section&nbsp;<A HREF="node9.html#const:arbdim">54.2</A> for a definition of ESMF_GRID_ARBDIM.
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863500000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_GridEmptyCreate - Create a Grid that has no contents</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>      function ESMF_GridEmptyCreate(vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_Grid) :: ESMF_GridEmptyCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_VM),           intent(in),  optional :: vm
        integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
                 different VM than that of the current context.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Partially create an <TT>ESMF_Grid</TT> object. This function allocates
   an <TT>ESMF_Grid</TT> object, but doesn't allocate any coordinate storage or other
   internal structures. The <TT>ESMF_GridEmptyComplete()</TT> calls
   can be used to set the values in the grid object and to construct the
   internal structure.

<P>
The arguments are:
   <DL>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Grid object is created on the specified
       <TT>ESMF_VM</TT> object. The default is to create on the VM of the
       current context.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGet"></A>
<H3><A NAME="SECTION050863600000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_GridGet - Get object-wide Grid information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetDefault(grid, coordTypeKind, &amp;
         dimCount, tileCount, staggerlocCount, localDECount, distgrid, &amp;
         distgridToGridMap, coordSys, coordDimCount, coordDimMap, arbDim, &amp;
         rank, arbDimCount, gridEdgeLWidth, gridEdgeUWidth, gridAlign,  &amp;
         indexFlag, status, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),            intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TypeKind_Flag),  intent(out), optional :: coordTypeKind
       integer,                   intent(out), optional :: dimCount
       integer,                   intent(out), optional :: tileCount
       integer,                   intent(out), optional :: staggerlocCount
       integer,                   intent(out), optional :: localDECount
       type(ESMF_DistGrid),       intent(out), optional :: distgrid
       integer,       target,     intent(out), optional :: distgridToGridMap(:)
       type(ESMF_CoordSys_Flag),  intent(out), optional :: coordSys
       integer,       target,     intent(out), optional :: coordDimCount(:)
       integer,       target,     intent(out), optional :: coordDimMap(:,:)
       integer,                   intent(out), optional :: arbDim
       integer,                   intent(out), optional :: rank
       integer,                   intent(out), optional :: arbDimCount
       integer,       target,     intent(out), optional :: gridEdgeLWidth(:)
       integer,       target,     intent(out), optional :: gridEdgeUWidth(:)
       integer,       target,     intent(out), optional :: gridAlign(:)
       type(ESMF_Index_Flag),     intent(out), optional :: indexflag
       type(ESMF_GridStatus_Flag),intent(out), optional :: status
       character (len=*),         intent(out), optional :: name
       integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets various types of information about a grid.

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. All <EM>numerical</EM> types
     listed under section&nbsp;<A HREF="node9.html#const:typekind">54.59</A> are supported.
  
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>DimCount of the Grid object.
  
</DD>
<DT><STRONG>[tileCount]</STRONG></DT>
<DD>The number of logically rectangular tiles in the grid.
  
</DD>
<DT><STRONG>[staggerlocCount]</STRONG></DT>
<DD>The number of stagger locations.
  
</DD>
<DT><STRONG>[localDECount]</STRONG></DT>
<DD>The number of DEs in this grid on this PET.
  
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The structure describing the distribution of the grid.
  
</DD>
<DT><STRONG>[distgridToGridMap]</STRONG></DT>
<DD>List that has as many elements as the distgrid dimCount. This array describes
     mapping between the grids dimensions and the distgrid.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>This argument needs to be of size equal to the Grid's dimCount.
     Each entry in the argument will be filled with the dimCount of the corresponding coordinate component (e.g. the
     dimCount of coordDim=1 will be put into entry 1).
     This is useful because it describes the factorization of the coordinate components in the Grid.
  
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size grid dimCount x grid dimCount. This array describes the
     map of each component array's dimensions onto the grids
     dimensions.
   
</DD>
<DT><STRONG>[arbDim]</STRONG></DT>
<DD>The distgrid dimension that is mapped by the arbitrarily distributed grid dimensions.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>The count of the memory dimensions, it is the same as dimCount for a non-arbitrarily distributed grid,
     and equal or less for a arbitrarily distributed grid.
   
</DD>
<DT><STRONG>[arbDimCount]</STRONG></DT>
<DD>The number of dimensions distributed arbitrarily for an arbitrary grid, 0 if the grid is non-arbitrary.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. The array should
     be of size greater or equal to the Grid dimCount.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. The array should
     be of size greater or equal to the Grid dimCount.
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space. The array should be of size greater or equal to the Grid dimCount.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag indicating the indexing scheme being used in the Grid. Please
      see Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A> for the list of options.
   
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>Flag indicating the status of the Grid. Please
      see Section&nbsp;<A HREF="#const:gridstatus">31.2.4</A> for the list of options.
  
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetPLocalDe"></A>
<H3><A NAME="SECTION050863700000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_GridGet - Get DE-local Grid information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPLocalDe(grid, localDE, &amp;
         isLBound,isUBound, arbIndexCount, arbIndexList, tile, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: localDE
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(out), optional :: isLBound(:)
       logical,                intent(out), optional :: isUBound(:)
       integer,                intent(out), optional :: arbIndexCount
       integer,        target, intent(out), optional :: arbIndexList(:,:)
       integer,                intent(out), optional :: tile
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>tile</TT>. This new argument allows the user to 
                 query the tile within which the localDE is contained. 
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call gets information about a particular local DE in a Grid.

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDECount-1]</TT>
  
</DD>
<DT><STRONG>[isLBound]</STRONG></DT>
<DD>Upon return, for each dimension this indicates if the DE is a lower bound of the Grid.
       <TT>isLBound</TT> must be allocated to be of size equal to the Grid dimCount.
  
</DD>
<DT><STRONG>[isUBound]</STRONG></DT>
<DD>Upon return, for each dimension this indicates if the DE is an upper bound of the Grid.
       <TT>isUBound</TT> must be allocated to be of size equal to the Grid dimCount.
   
</DD>
<DT><STRONG>[arbIndexCount]</STRONG></DT>
<DD>The number of local cells for an arbitrarily distributed grid
   
</DD>
<DT><STRONG>[arbIndexList]</STRONG></DT>
<DD>The 2D array storing the local cell indices for an arbitrarily distributed grid. The size of the array
     is arbIndexCount * arbDimCount
  
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The number of the tile in which localDE is contained. Tile numbers range from 1 to TileCount.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetPLocalDePSloc"></A>
<H3><A NAME="SECTION050863800000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_GridGet - Get DE-local information for a specific stagger location in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPLocalDePSloc(grid, staggerloc, localDE, &amp;
         exclusiveLBound, exclusiveUBound, exclusiveCount,  &amp;
         computationalLBound, computationalUBound, computationalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
       integer,                intent(in)            :: localDE
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a
    particular stagger location occupies. This call differs from the coordinate
    bound calls (e.g. <TT>ESMF_GridGetCoord</TT>) in that a given coordinate
    array may only occupy a subset of the Grid's dimensions, and
    so these calls may not give all the bounds of the stagger location.
    The bounds from this call are the full bounds, and so
    for example, give the appropriate bounds for allocating a Fortran array to hold
    data residing on the stagger location.
    Note that unlike the output from the Array, these values also include the
    undistributed dimensions and are
    ordered to reflect the order of the indices in the Grid. This call will
    still give correct values even if the stagger location does not contain
    coordinate arrays (e.g. if  <TT>ESMF_GridAddCoord</TT> hasn't yet
    been called on the stagger location).

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for.
       Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
       of predefined stagger locations.
  
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDECount-1]</TT>
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items,<TT>exclusiveUBound-exclusiveLBound+1</TT>,
       in the exclusive region per dimension.
       <TT>exclusiveCount</TT> must
       be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension.
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT> must
        be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetPSloc"></A>
<H3><A NAME="SECTION050863900000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_GridGet - Get information about a specific stagger location in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPSloc(grid, staggerloc, &amp;
         distgrid, &amp;
         staggerEdgeLWidth, staggerEdgeUWidth, &amp;
         staggerAlign, staggerLBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_DistGrid),    intent(out), optional :: distgrid
       integer,                intent(out), optional :: staggerEdgeLWidth(:)
       integer,                intent(out), optional :: staggerEdgeUWidth(:)
       integer,                intent(out), optional :: staggerAlign(:)
       integer,                intent(out), optional :: staggerLBound(:)
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added arguments <TT>staggerEdgeLWidth</TT>, <TT>staggerEdgeUWidth</TT>,
                 <TT>staggerAlign</TT>, and <TT>staggerLBound</TT>. These new arguments 
                  allow the user to get width, alignment, and bound information for
                  the given stagger location. 
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets information about a particular stagger location.
    This information is useful for creating an ESMF Array to hold
    the data at the stagger location.

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for.
       Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
       of predefined stagger locations.
  
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The structure describing the distribution of this staggerloc in this grid.
   
</DD>
<DT><STRONG>[staggerEdgeLWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerEdgeUWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerAlign]</STRONG></DT>
<DD>This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example,
        for a 2D cell with corner stagger it specifies which
        of the 4 corners has the same index as the center.
   
</DD>
<DT><STRONG>[staggerLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this staggerloc in this Grid.
        Only used when Grid indexflag is <TT>ESMF_INDEX_USER</TT>.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetPSlocPTile"></A>
<H3><A NAME="SECTION050864000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> ESMF_GridGet - Get information about a specific stagger location and tile in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPSlocPTile(grid, tile, staggerloc, &amp;
         minIndex, maxIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: tile
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        target, intent(out), optional :: minIndex(:)
       integer,        target, intent(out), optional :: maxIndex(:)
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets information about a particular stagger location.
    This information is useful for creating an ESMF Array to hold
    the data at the stagger location.

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>tile</STRONG></DT>
<DD>The tile number to get the data from. Tile numbers range from 1 to TileCount.
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for.
       Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
       of predefined stagger locations.
  
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Upon return this holds the global lower index of this stagger location.
       <TT>minIndex</TT> must be allocated to be of size equal to the grid DimCount.
       Note that this value is only for the first Grid tile, as multigrid support
       is added, this interface will likely be changed or moved to adapt.
  
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>Upon return this holds the global upper index of this stagger location.
       <TT>maxIndex</TT> must be allocated to be of size equal to the grid DimCount.
       Note that this value is only for the first Grid tile, as multigrid support
       is added, this interface will likely be changed or moved to adapt.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetCoord"></A>
<H3><A NAME="SECTION050864100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> ESMF_GridGetCoord - Get a DE-local Fortran array pointer to Grid coord data and coord bounds</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>        subroutine ESMF_GridGetCoord&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(grid, coordDim,    &amp;
          staggerloc, localDE, farrayPtr, datacopyflag,                  &amp;
          exclusiveLBound, exclusiveUBound, exclusiveCount,              &amp;
          computationalLBound, computationalUBound, computationalCount,  &amp;
          totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),       intent(in)              :: grid
       integer,               intent(in)              :: coordDim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc) intent(in),    optional :: staggerloc
       integer,               intent(in),    optional :: localDE
       &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer             :: farrayPtr(&lt;rank&gt;)
       type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
       integer,               intent(out),   optional :: exclusiveLBound(:)
       integer,               intent(out),   optional :: exclusiveUBound(:)
       integer,               intent(out),   optional :: exclusiveCount(:)
       integer,               intent(out),   optional :: computationalLBound(:)
       integer,               intent(out),   optional :: computationalUBound(:)
       integer,               intent(out),   optional :: computationalCount(:)
       integer,               intent(out),   optional :: totalLBound(:)
       integer,               intent(out),   optional :: totalUBound(:)
       integer,               intent(out),   optional :: totalCount(:)
       integer,               intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the
       coordinate data on the local DE for the given coordinate dimension and stagger
       locations.
       This is useful, for example, for setting the coordinate values in a Grid, or
       for reading the coordinate values.  Currently this method supports up to three
       coordinate dimensions, of either R4 or R8 datatype.  See below for specific
       supported values.  If the coordinates that you are trying to retrieve are of
       higher dimension, use the <TT>ESMF_GetCoord()</TT> interface that returns coordinate
       values in an <TT>ESMF_Array</TT> instead.  That interface supports the retrieval of
       coordinates up to 7D.

<P>
Supported values for the farrayPtr argument are:
       <DL>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:,:,:)
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the data from (e.g. 1=x).
       
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to get the information for.
            Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE for which information is requested. <TT>[0,..,localDECount-1]</TT>.
           For <TT>localDECount==1</TT> the <TT>localDE</TT> argument may be omitted,
            in which case it will default to <TT>localDE=0</TT>.
       
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>The pointer to the coordinate data.
       
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATACOPY_REFERENCE</TT>, in this case
            farrayPtr is a reference to the data in the Grid coordinate arrays.
            Please see Section&nbsp;<A HREF="node9.html#const:datacopyflag">54.12</A> for further description and a
            list of valid values.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
            <TT>exclusiveLBound</TT> must be allocated to be of size equal to the coord dimCount.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>,
            in the exclusive region per dimension.
            <TT>exclusiveCount</TT> must
            be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
            <TT>computationalLBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
            must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
            <TT>totalLBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
            <TT>totalUBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
            (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
            be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetCoordIntoArray"></A>
<H3><A NAME="SECTION050864200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> ESMF_GridGetCoord - Get coordinates and put into an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordIntoArray(grid, coordDim, staggerloc, &amp;
         array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       type(ESMF_Array),       intent(out)           :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method allows the user to get access to the ESMF Array holding
      coordinate data at a particular stagger location. This is useful, for example,
      to set the coordinate values. To have an Array to access, the coordinate Arrays
      must have already been allocated, for example by <TT>ESMF_GridAddCoord</TT> or
      <TT>ESMF_GridSetCoord</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The grid to get the coord array from.
       
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the data from (e.g. 1=x).
       
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location from which to get the arrays.
            Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array into which to put the coordinate information.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetCoordR4"></A>
<H3><A NAME="SECTION050864300000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">43</SPAN> ESMF_GridGetCoord - Get DE-local coordinates from a specific index location in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordR4(grid, staggerloc, localDE, &amp;
         index, coord, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,                intent(in)            :: index(:)
       real(ESMF_KIND_R4),     intent(out)           :: coord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Given a specific index location in a Grid, this method returns the full set
     of coordinates from that index location. This method should work no matter what
     the factorization of the Grid's coordinate components.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to get the information for.
            Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
            of predefined stagger locations. If not present, defaults to
            ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE for which information is requested. <TT>[0,..,localDECount-1]</TT>.
            For <TT>localDECount==1</TT> the <TT>localDE</TT> argument may be omitted,
            in which case it will default to <TT>localDE=0</TT>.
       
</DD>
<DT><STRONG>index</STRONG></DT>
<DD>This array holds the index location to be queried in the Grid. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>coord</STRONG></DT>
<DD>This array will be filled with the coordinate data. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetCoordR8"></A>
<H3><A NAME="SECTION050864400000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">44</SPAN> ESMF_GridGetCoord - Get DE-local coordinates from a specific index location in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordR8(grid, staggerloc, localDE, &amp;
         index, coord, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,                intent(in)            :: index(:)
       real(ESMF_KIND_R8),     intent(out)           :: coord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Given a specific index location in a Grid, this method returns the full set
     of coordinates from that index location. This method should work no matter what
     the factorization of the Grid's coordinate components.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to get the information for.
            Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
            of predefined stagger locations. If not present, defaults to
            ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE for which information is requested. <TT>[0,..,localDECount-1]</TT>.
            For <TT>localDECount==1</TT> the <TT>localDE</TT> argument may be omitted,
            in which case it will default to <TT>localDE=0</TT>.
       
</DD>
<DT><STRONG>index</STRONG></DT>
<DD>This array holds the index location to be queried in the Grid. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>coord</STRONG></DT>
<DD>This array will be filled with the coordinate data. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetCoordInfo"></A>
<H3><A NAME="SECTION050864500000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">45</SPAN> ESMF_GridGetCoord - Get information about the coordinates at a particular stagger location</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordInfo(grid, &amp;
         staggerloc, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),           intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       logical,                   intent(out), optional :: isPresent
       integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method allows the user to get information about the coordinates on a given
      stagger.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location from which to get information.
            Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>If .true. then coordinates have been added on this staggerloc.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050864600000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">46</SPAN> ESMF_GridGetCoordBounds - Get Grid coordinate bounds</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_GridGetCoordBounds(grid, coordDim,   &amp;
         staggerloc, localDE, exclusiveLBound, exclusiveUBound, &amp;
         exclusiveCount, computationalLBound, computationalUBound , &amp;
         computationalCount, totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,        target, intent(out), optional :: totalLBound(:)
       integer,        target, intent(out), optional :: totalUBound(:)
       integer,        target, intent(out), optional :: totalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a particular
    piece of coordinate data occupies.  In other words, this method returns the
    bounds of the coordinate arrays.  Note that unlike the output from the
    Array, these values also include the undistributed dimensions and are
    ordered to reflect the order of the indices in the coordinate. So, for example,
    <TT>totalLBound</TT> and <TT>totalUBound</TT> should match the bounds of the Fortran array
    retrieved by <TT>ESMF_GridGetCoord</TT>.

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the information for (e.g. 1=x).
  
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to get the information for.
       Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
       of predefined stagger locations. If not present, defaults to
       ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE for which information is requested. <TT>[0,..,localDECount-1]</TT>.
            For <TT>localDECount==1</TT> the <TT>localDE</TT> argument may be omitted,
            in which case it will default to <TT>localDE=0</TT>.
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>,
       in the exclusive region per dimension.
       <TT>exclusiveCount</TT> must
       be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
        must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       <TT>totalLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       <TT>totalUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
       (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
        be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetItem"></A>
<H3><A NAME="SECTION050864700000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">47</SPAN> ESMF_GridGetItem - Get a DE-local Fortran array pointer to Grid item data and item bounds</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>        subroutine ESMF_GridGetItem&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(grid, itemflag,  &amp;
          staggerloc, localDE, farrayPtr, datacopyflag,                  &amp;
          exclusiveLBound, exclusiveUBound, exclusiveCount,              &amp;
          computationalLBound, computationalUBound, computationalCount,  &amp;
          totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),      intent(in)               :: grid
       type (ESMF_GridItem_Flag),intent(in)           :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional  :: staggerloc
       integer,              intent(in),    optional  :: localDE
       &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer             :: farrayPtr(&lt;rank&gt;)
       type(ESMF_DataCopy_Flag),intent(in), optional  :: datacopyflag
       integer,              intent(out),   optional  :: exclusiveLBound(:)
       integer,              intent(out),   optional  :: exclusiveUBound(:)
       integer,              intent(out),   optional  :: exclusiveCount(:)
       integer,              intent(out),   optional  :: computationalLBound(:)
       integer,              intent(out),   optional  :: computationalUBound(:)
       integer,              intent(out),   optional  :: computationalCount(:)
       integer,              intent(out),   optional  :: totalLBound(:)
       integer,              intent(out),   optional  :: totalUBound(:)
       integer,              intent(out),   optional  :: totalCount(:)
       integer,              intent(out),   optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the
       item data on the local DE for the given stagger locations.
       This is useful, for example, for setting the item values in a Grid, or
       for reading the item values.  Currently this method supports up to three
       grid dimensions, but is limited to the I4 datatype.  See below for specific
       supported values.  If the item values that you are trying to retrieve are of
       higher dimension, use the <TT>ESMF_GetItem()</TT> interface that returns coordinate
       values in an <TT>ESMF_Array</TT> instead.  That interface supports the retrieval of
       coordinates up to 7D.

<P>
Supported values for the farrayPtr argument are:
       <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: farrayPtr(:,:)
       
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: farrayPtr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4),    pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4),    pointer :: farrayPtr(:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4),    pointer :: farrayPtr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8),    pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8),    pointer :: farrayPtr(:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8),    pointer :: farrayPtr(:,:,:)
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item to get the information for. Please see Section&nbsp;<A HREF="#const:griditem">31.2.2</A> for a
            list of valid items.
       
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to get the information for.
            Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE for which information is requested. <TT>[0,..,localDECount-1]</TT>.
            For <TT>localDECount==1</TT> the <TT>localDE</TT> argument may be omitted,
            in which case it will default to <TT>localDE=0</TT>.
       
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>The pointer to the item data.
       
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATACOPY_REFERENCE</TT>, in this case
            farrayPtr is a reference to the data in the Grid item arrays.
            Please see Section&nbsp;<A HREF="node9.html#const:datacopyflag">54.12</A> for further description and a
            list of valid values.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
            <TT>exclusiveLBound</TT> must be allocated to be of size equal to the grid dimCount.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the grid dimCount.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must
            be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
            <TT>computationalLBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
            must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
            <TT>totalLBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
            <TT>totalUBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
            (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
            be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
            of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetItemIntoArray"></A>
<H3><A NAME="SECTION050864800000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">48</SPAN> ESMF_GridGetItem - Get a Grid item and put into an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetItem()
       subroutine ESMF_GridGetItemIntoArray(grid, itemflag,  staggerloc, &amp;
         array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),           intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)            :: itemflag
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       type(ESMF_Array),          intent(out)           :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method allows the user to get access to the ESMF Array holding
      item data at a particular stagger location. This is useful, for example,
      to set the item values. To have an Array to access, the item Array
      must have already been allocated, for example by <TT>ESMF_GridAddItem</TT> or
      <TT>ESMF_GridSetItem</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item from which to get the arrays. Please see Section&nbsp;<A HREF="#const:griditem">31.2.2</A> for a
            list of valid items.
       
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location from which to get the arrays.
            Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array into which to put the item information.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>
<A NAME="API:GridGetItemInfo"></A>
<H3><A NAME="SECTION050864900000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">49</SPAN> ESMF_GridGetItem - Get information about an item at a particular stagger location</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetItem()
       subroutine ESMF_GridGetItemInfo(grid, itemflag, &amp;
         staggerloc, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),           intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)            :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       logical,                   intent(out), optional :: isPresent
       integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method allows the user to get information about a given item on a given
      stagger.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item for which to get information. Please see Section&nbsp;<A HREF="#const:griditem">31.2.2</A> for a
            list of valid items.
       
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location for which to get information.
            Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>If .true. then an item of type itemflag has been added to this staggerloc.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050865000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">50</SPAN> ESMF_GridGetItemBounds - Get DE-local item bounds from a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_GridGetItemBounds(grid, itemflag,  &amp;
         staggerloc, localDE, &amp;
         exclusiveLBound, exclusiveUBound, exclusiveCount, &amp;
         computationalLBound, computationalUBound, computationalCount,  &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)         :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,        target, intent(out), optional :: totalLBound(:)
       integer,        target, intent(out), optional :: totalUBound(:)
       integer,        target, intent(out), optional :: totalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a particular
    piece of item data occupies.  In other words, this method returns the
    bounds of the item arrays.  Note that unlike the output from the
    Array, these values also include the undistributed dimensions and are
    ordered to reflect the order of the indices in the item. So, for example,
    <TT>totalLBound</TT> and <TT>totalUBound</TT> should match the bounds of the Fortran array
    retrieved by <TT>ESMF_GridGetItem</TT>.

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item to get the information for. Please see Section&nbsp;<A HREF="#const:griditem">31.2.2</A> for a
       list of valid items.
  
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to get the information for.
       Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
       of predefined stagger locations. If not present, defaults to
       ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE for which information is requested. <TT>[0,..,localDECount-1]</TT>.
            For <TT>localDECount==1</TT> the <TT>localDE</TT> argument may be omitted,
            in which case it will default to <TT>localDE=0</TT>.
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>,
       in the exclusive region per dimension.
       <TT>exclusiveCount</TT> must
       be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
        must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       <TT>totalLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       <TT>totalUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.
  
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
       (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
        be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="#sec:grid:usage:bounds">31.3.19</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050865100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">51</SPAN> ESMF_GridIsCreated - Check whether a Grid object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_GridIsCreated(grid, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_GridIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>grid</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050865200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">52</SPAN> ESMF_GridMatch - Check if two Grid objects match</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_GridMatch(grid1, grid2, globalflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_GridMatch_Flag) :: ESMF_GridMatch
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid),  intent(in)              :: grid1
     type(ESMF_Grid),  intent(in)              :: grid2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,          intent(in),   optional  :: globalflag
     integer,          intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Check if <TT>grid1</TT> and <TT>grid2</TT> match. Returns a range of values of type
    ESMF_GridMatch indicating how closely the Grids match. For a description of
    the possible return values, please see&nbsp;<A HREF="#const:gridmatch">31.2.3</A>.
    Please also note that by default this call is not collective and only
    returns the match for the piece of the Grids on the local PET. In this case,
    it is possible for this call to return a different match on different PETs
    for the same Grids. To do a global match operation set the <TT>globalflag</TT>
    argument to .true.. In this case, the call becomes collective across the
    current VM, ensuring the same result is returned on all PETs.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>[globalflag]</STRONG></DT>
<DD>By default this flag is set to false. When it's set to true, the
            function performs the match check globally. In this case,
            the method becomes collective across the current VM.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050865300000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">53</SPAN> ESMF_GridRedist - Redistribute the coordinates of a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_GridRedist(srcGrid, dstGrid, routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Grid),       intent(in)              :: srcGrid
        type(ESMF_Grid),       intent(inout)           :: dstGrid
        type(ESMF_RouteHandle),intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,               intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call is companion to the <TT>ESMF_GridCreate()</TT> that allows the user to copy an
   existing ESMF Grid, but with a new distribution. The <TT>ESMF_GridRedist()</TT> allows
   the user to repeatedly redistribute the coordinates from <TT>srcGrid</TT> to <TT>dstGrid</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>srcGrid</STRONG></DT>
<DD>The source grid providing the coordinates.
   
</DD>
<DT><STRONG>srcGrid</STRONG></DT>
<DD>The destination grid receiving the coordinates from <TT>srcGrid</TT>.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>The <TT>ESMF_RouteHandle</TT> object returned by the companion method
        <TT>ESMF_GridCreate()</TT> used to create <TT>dstGrid</TT> from <TT>srcGrid</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050865400000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">54</SPAN> ESMF_GridSetCoord - Set coordinates using Arrays</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_GridSetCoordFromArray(grid, coordDim, staggerloc, &amp;
         array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       type(ESMF_Array),       intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method sets the passed in Array as the holder of the coordinate
   data for stagger location staggerloc and coordinate coord. This method
   can be used in place of ESMF_GridAddCoord(). In fact, if the Grid
   location already contains an Array for this coordinate, then this one
   replaces it. For this method to replace ESMF_GridAddCoord() and produce
   a valid set of coordinates, then this method must be used to set
   an Array for each coordDim ranging from 1 to the dimCount of the passed in Grid.

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The grid to set the coord in.
  
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to put the data in (e.g. 1=x).
  
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location into which to copy the arrays.
      Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
      of predefined stagger locations. If not present, defaults to
      ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array to set the grid coordinate information from.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050865500000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">55</SPAN> ESMF_GridSetItem - Set an item using an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridSetItem()
       subroutine ESMF_GridSetItemFromArray(grid, itemflag,  staggerloc, &amp;
         array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),           intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)            :: itemflag
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       type(ESMF_Array),          intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method sets the passed in Array as the holder of the item data
     for stagger location <TT>staggerloc</TT> and item <TT>itemflag</TT>. If the location
     already contains an Array, then this one overwrites it. This method can
     be used as a replacement for ESMF_GridAddItem().

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The grid in which to set the array.
  
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item into which to copy the arrays. Please see Section&nbsp;<A HREF="#const:griditem">31.2.2</A> for a
      list of valid items.
  
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location into which to copy the arrays.
      Please see Section&nbsp;<A HREF="#const:staggerloc">31.2.6</A> for a list
      of predefined stagger locations. If not present, defaults to
      ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array to set the grid item information from.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050865600000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">56</SPAN> ESMF_GridValidate - Validate Grid internals</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_GridValidate(grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in)              :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,         intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>Grid</TT> is internally consistent.
        Note that one of the checks that the Grid validate does
        is the Grid status. Currently, the validate will return
        an error if the grid is not at least
        <TT>ESMF_GRIDSTATUS_COMPLETE</TT>. This means that
        if a Grid was created with the <TT>ESMF_GridEmptyCreate</TT>
        method, it must also have been finished with
        <TT>ESMF_GridEmptyComplete()</TT>
        to be valid. If a Grid was created with another create
        call it should automatically have the correct status level
        to pass the status part of the validate.
        The Grid validate at this time doesn't check for the presence
        or consistency of the Grid coordinates.
        The method returns an error code if problems are found.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Specified <TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H2><A NAME="SECTION05087000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: StaggerLoc Methods</A>
</H2>&nbsp;<A NAME="ref:stagsub"></A>
<P>

<P>

<P>

<H3><A NAME="SECTION05087100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_StaggerLocGet - Get the value of one dimension of a StaggerLoc</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StaggerLocGet() 
       subroutine ESMF_StaggerLocGetDim(staggerloc, dim, loc, &amp;
            rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(in)  :: staggerloc
       integer,                intent(in)  :: dim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional,      intent(out) :: loc
       integer, optional                   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the position of a particular dimension of a cell <TT>staggerloc</TT>
     The argument <TT>loc</TT> will be only be 0,1. 
      If <TT>loc</TT> is 0 it means the position 
      should be in the center in that dimension. If <TT>loc</TT> is +1 then
      for the dimension, the position should be on the positive side of the cell. 
      Please see Section&nbsp;<A HREF="#sec:usage:staggerloc:adv">31.3.25</A> for diagrams.

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Stagger location for which to get information. 
       
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension for which to get information (1-7).
       
</DD>
<DT><STRONG>[loc]</STRONG></DT>
<DD>Output position data (should be either 0,1).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05087200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_StaggerLocSet - Set a StaggerLoc to a particular position in the cell</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StaggerLocSet() 
      subroutine ESMF_StaggerLocSetAllDim(staggerloc, loc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(inout) :: staggerloc
       integer,                intent(in)    :: loc(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional                     :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets a custom <TT>staggerloc</TT> to a position in a cell by using the array
      <TT>loc</TT>. The values in the array should only be 0,1. If loc(i) is 0 it 
  !    means the position should be in the center in that dimension. If loc(i) is 1 then
      for dimension i, the position should be on the side of the cell. 
      Please see Section&nbsp;<A HREF="#sec:usage:staggerloc:adv">31.3.25</A>
      for diagrams and further discussion of custom stagger locations. 

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Grid location to be initialized
       
</DD>
<DT><STRONG>loc</STRONG></DT>
<DD>Array holding position data. Each entry in <TT>loc</TT> should only
            be  0 or 1. note that dimensions beyond those specified are set to 0. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05087300000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_StaggerLocSet - Set one dimension of a StaggerLoc to a particular position</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StaggerLocSet() 
        subroutine ESMF_StaggerLocSetDim(staggerloc, dim, loc, &amp;
             rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(inout) :: staggerloc
       integer,                intent(in)    :: dim
       integer,                intent(in)    :: loc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional                     :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets a particular dimension of a custom <TT>staggerloc</TT> to a position in a cell 
      by using the variable <TT>loc</TT>. The variable <TT>loc</TT> should only be 0,1. 
      If <TT>loc</TT> is 0 it means the position 
      should be in the center in that dimension. If <TT>loc</TT> is +1 then
      for the dimension, the position should be on the positive side of the cell. 
      Please see Section&nbsp;<A HREF="#sec:usage:staggerloc:adv">31.3.25</A>
      for diagrams and further discussion of custom stagger locations. 

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Stagger location to be initialized
       
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension to be changed (1-7).
       
</DD>
<DT><STRONG>loc</STRONG></DT>
<DD>Position data should be either 0,1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05087400000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_StaggerLocString - Return a StaggerLoc as a string</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_StaggerLocString(staggerloc, string, &amp;
            rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_StaggerLoc), intent(in)  :: staggerloc
       character (len = *),   intent(out) :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional,     intent(out) :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return an <TT>ESMF_StaggerLoc</TT> as a printable string.

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The <TT>ESMF_StaggerLoc</TT> to be turned into a string.
       
</DD>
<DT><STRONG>string</STRONG></DT>
<DD>Return string.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05087500000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_StaggerLocPrint - Print StaggerLoc information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_StaggerLocPrint(staggerloc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(in)  :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional,      intent(out) :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print the internal data members of an <TT>ESMF_StaggerLoc</TT> object. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>ESMF_StaggerLoc object as the method input
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION05090000000000000000">
<SPAN CLASS="arabic">32</SPAN> LocStream Class</A>
</H1>

<H2><A NAME="SECTION05091000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
A location stream (LocStream) can be used to represent the locations of
a set of data points.  For example, in the data assimilation world, 
LocStreams can be used to represent a set of observations.  The values 
of the data points are stored within a Field or FieldBundle created 
using the LocStream.

<P>
The locations are generally described using Cartesian (x, y, z), or 
(lat, lon, radius) coordinates.  The coordinates are stored using 
constructs called <I>keys</I>.  A Key is essentially a list of point 
descriptors, one for each data point.  They may hold other information 
besides the coordinates - a mask, for example.  They may also hold a 
second set of coordinates.    Keys are referenced by name - see 
<A HREF="#const:coordkeyname">32.2.1</A> and <A HREF="#const:maskkeyname">32.2.2</A> for specific 
keynames required in regridding.  Each key must contain the same 
number of elements as there are data points in the LocStream.  While 
there is no assumption in the ordering of the points, the order 
chosen must be maintained in each of the keys.

<P>
LocStreams can be very large. Data assimilation systems might use
LocStreams with up to <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img95.png"
 ALT="$10^{8}$"></SPAN> observations, so efficiency is critical.
LocStreams can be created from file, see <A HREF="#locstream:createfromfile">32.4.14</A>.

<P>
Common operations involving LocStreams are similar to those involving Grids.
For example, LocStreams allow users to:

<P>

<OL>
<LI>Create a Field or FieldBundle on a LocStream
</LI>
<LI>Regrid data in Fields defined on LocStreams
</LI>
<LI>Redistribute data between Fields defined on LocStreams
</LI>
<LI>Gather or scatter a FieldBundle defined on a LocStream from/to a root DE
</LI>
<LI>Extract Fortran array from Field which was defined on a LocStream
</LI>
</OL>

<P>
A LocStream differs from a Grid in that no topological structure is
maintained between the points
(e.g. the class contains no information about which point is the neighbor
of which other point).

<P>
A LocStream is similar to a Mesh in that both are collections of irregularly positioned 
points.  However, the two structures differ because a Mesh also has connectivity: 
each data point represents either a center or corner of a cell. There is no requirement that the
points in a LocStream have connectivity, in fact there is no requirement that any two points 
have any particular spatial relationship at all.

<H2><A NAME="SECTION05092000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05092100000000000000"></A>
<A NAME="const:coordkeyname"></A>
<BR>
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Coordinate keyNames
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
For ESMF to be able to use coordinates specified in a LocStream key (e.g. in regridding) 
they need to be named with the appropriate identifiers. The particular identifiers depend 
on the coordinate system (i.e. coordSys argument) used to create the LocStream containing 
the keys.  ESMF regridding expects these keys to be of type ESMF_TYPEKIND_R8. 

<P>
The valid values are:
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Coordinate System</TD>
<TD ALIGN="CENTER"><B>dimension 1</B></TD>
<TD ALIGN="CENTER"><B>dimension 2</B></TD>
<TD ALIGN="CENTER"><B>dimension 3 (if used)</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_COORDSYS_SPH_DEG</B></TD>
<TD ALIGN="CENTER">ESMF:Lon</TD>
<TD ALIGN="CENTER">ESMF:Lat</TD>
<TD ALIGN="CENTER">ESMF:Radius</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_COORDSYS_SPH_RAD</B></TD>
<TD ALIGN="CENTER">ESMF:Lon</TD>
<TD ALIGN="CENTER">ESMF:Lat</TD>
<TD ALIGN="CENTER">ESMF:Radius</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_COORDSYS_CART</B></TD>
<TD ALIGN="CENTER">ESMF:X</TD>
<TD ALIGN="CENTER">ESMF:Y</TD>
<TD ALIGN="CENTER">ESMF:Z</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION05092200000000000000"></A>
<A NAME="const:maskkeyname"></A>
<BR>
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Masking keyName
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Points within a LocStream can be marked and then potentially ignored during certain 
operations, like regridding.  This masking information must be contained in a key 
named with the appropriate identifier.  ESMF regridding expects this key to be 
of type ESMF_TYPEKIND_I4.

<P>
The valid value is:
<DL>
<DT><STRONG>ESMF:Mask</STRONG></DT>
<DD>
</DD>
</DL>

<H2><A NAME="SECTION05093000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05093100000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Create a LocStream with user allocated memory</A>
</H3>

<P>
The following is an example of creating a LocStream object.
   After creation, key data is added, and a Field is created to hold data
   (temperature) at each location. 
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get parallel information. Here petCount is the total number of 
   ! running PETs, and localPet is the number of this particular PET.
   !-------------------------------------------------------------------
   call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate and set example location information. Locations on a PET
   ! are wrapped around sphere. Each PET occupies a different latitude
   ! ranging from +50.0 to -50.0.
   !-------------------------------------------------------------------
   numLocations = 20
   allocate(lon(numLocations))
   allocate(lat(numLocations))

   do i=1,numLocations
      lon(i)=360.0*i/numLocations
      lat(i)=100*REAL(localPet,ESMF_KIND_R8)/REAL(petCount,ESMF_KIND_R8)-50.0
   enddo

   !-------------------------------------------------------------------
   ! Allocate and set example Field data
   !-------------------------------------------------------------------
   allocate(temperature(numLocations))

   do i=1,numLocations
      temperature(i)= 300 - abs(lat(i))
   enddo

   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Temperature Measurements",   &amp;
                                  localCount=numLocations, &amp;
                                  coordSys=ESMF_COORDSYS_SPH_DEG,   &amp;
                                  rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Add key data, referencing a user data pointer. By changing the 
   ! datacopyflag to ESMF_DATACOPY_VALUE an internally allocated copy of the 
   ! user data may also be set.  
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,              &amp;
                             keyName="ESMF:Lat",     &amp;
                             farray=lat,             &amp;
                             datacopyflag=ESMF_DATACOPY_REFERENCE, &amp;
                             keyUnits="Degrees",     &amp;
                             keyLongName="Latitude", rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_LocStreamAddKey(locstream,              &amp;
                             keyName="ESMF:Lon",     &amp;
                             farray=lon,             &amp;
                             datacopyflag=ESMF_DATACOPY_REFERENCE, &amp;
                             keyUnits="Degrees",     &amp;
                             keyLongName="Longitude", rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create a Field on the Location Stream. In this case the 
   ! Field is created from a user array, but any of the other
   ! Field create methods (e.g. from ArraySpec) would also apply.
   !-------------------------------------------------------------------       
   field_temperature=ESMF_FieldCreate(locstream,   &amp;
                                   temperature, &amp;
                                   name="temperature", &amp;
                                   rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05093200000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Create a LocStream with internally allocated memory</A>
</H3>

<P>
The following is an example of creating a LocStream object.
   After creation, key data is internally allocated,
   the pointer is retrieved, and the data is set.
   A Field is also created on the LocStream to hold data
   (temperature) at each location. 
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get parallel information. Here petCount is the total number of 
   ! running PETs, and localPet is the number of this particular PET.
   !-------------------------------------------------------------------
   call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
</PRE>

<P>
<PRE>
   numLocations = 20

   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Temperature Measurements",   &amp;
                                  localCount=numLocations, &amp;
                                  coordSys=ESMF_COORDSYS_SPH_DEG,   &amp;
                                  rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Add key data (internally allocating memory).
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="ESMF:Lat",           &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Latitude", rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="ESMF:Lon",           &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Longitude", rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get key data. 
   !-------------------------------------------------------------------
   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             keyName="ESMF:Lat",           &amp;
                             farray=lat,                   &amp;
                             rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             keyName="ESMF:Lon",           &amp;
                             farray=lon,                   &amp;
                             rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Set example location information. Locations on a PET are wrapped 
   ! around sphere. Each PET occupies a different latitude ranging 
   ! from +50.0 to -50.0.
   !-------------------------------------------------------------------
   do i=1,numLocations
      lon(i)=360.0*i/numLocations
      lat(i)=100*REAL(localPet,ESMF_KIND_R8)/REAL(petCount,ESMF_KIND_R8)-50.0
   enddo


   !-------------------------------------------------------------------
   ! Allocate and set example Field data
   !-------------------------------------------------------------------
   allocate(temperature(numLocations))
   do i=1,numLocations
      temperature(i)= 300 - abs(lat(i))
   enddo

   !-------------------------------------------------------------------
   ! Create a Field on the Location Stream. In this case the 
   ! Field is created from a user array, but any of the other
   ! Field create methods (e.g. from ArraySpec) would also apply.
   !-------------------------------------------------------------------    
   field_temperature=ESMF_FieldCreate(locstream,   &amp;
                                 temperature, &amp;
                                 name="temperature", &amp;
                                 rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05093300000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Create a LocStream with a distribution based on a Grid</A>
</H3>

<P>
The following is an example of using the LocStream create from background
   Grid capability. Using this capability, the newly created LocStream 
   is a copy of the old LocStream, but with a new distribution. The new LocStream 
   is distributed such that if the coordinates of a location in the LocStream lie 
   within a Grid cell, then that location is put on the same PET as the Grid cell. 
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get parallel information. Here petCount is the total number of 
   ! running PETs, and localPet is the number of this particular PET.
   !-------------------------------------------------------------------
   call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   numLocations = 20
   locstream=ESMF_LocStreamCreate(name="Temperature Measurements",   &amp;
                                  localCount=numLocations, &amp;
                                  coordSys=ESMF_COORDSYS_SPH_DEG,   &amp;
                                  rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Add key data (internally allocating memory).
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="ESMF:Lon",           &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Longitude", rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="ESMF:Lat",           &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Latitude", rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get Fortran arrays which hold the key data, so that it can be set. 
   !-------------------------------------------------------------------
   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             keyName="ESMF:Lon",           &amp;
                             farray=lon,                   &amp;
                             rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             keyName="ESMF:Lat",           &amp;
                             farray=lat,                   &amp;
                             rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Set example location information. Locations on a PET are wrapped 
   ! around sphere. Each PET occupies a different latitude ranging 
   ! from +50.0 to -50.0.
   !-------------------------------------------------------------------
   do i=1,numLocations
      lon(i)=360.0*i/numLocations
      lat(i)=100*REAL(localPet,ESMF_KIND_R8)/REAL(petCount,ESMF_KIND_R8)-50.0
   enddo

   !-------------------------------------------------------------------
   ! Create a Grid to use as the background. The Grid is 
   ! GridLonSize by GridLatSize with the default distribution 
   ! (The first dimension split across the PETs). The coordinate range
   ! is  0 to 360 in longitude and -90 to 90 in latitude. Note that we 
   ! use indexflag=ESMF_INDEX_GLOBAL for the Grid creation. At this time 
   ! this is required for a Grid to be usable as a background Grid.
   ! Note that here the points are treated as cartesian.
   !-------------------------------------------------------------------
   grid=ESMF_GridCreateNoPeriDim(maxIndex=(/GridLonSize,GridLatSize/), &amp;
                                 coordSys=ESMF_COORDSYS_SPH_DEG,       &amp;
                                 indexflag=ESMF_INDEX_GLOBAL,          &amp;
                                 rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate the corner stagger location in which to put the coordinates. 
   ! (The corner stagger must be used for the Grid to be usable as a
   !  background Grid.)
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid, staggerloc=ESMF_STAGGERLOC_CORNER, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get access to the Fortran array pointers that hold the Grid 
   ! coordinate information and then set the coordinates to be uniformly 
   ! distributed around the globe. 
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid,                                  &amp;
                          staggerLoc=ESMF_STAGGERLOC_CORNER,     &amp;
                          coordDim=1, computationalLBound=clbnd, &amp;
                          computationalUBound=cubnd,             &amp; 
                          farrayPtr=farrayPtrLonC, rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_GridGetCoord(grid,                                  &amp;
                         staggerLoc=ESMF_STAGGERLOC_CORNER,      &amp;
                          coordDim=2, farrayPtr=farrayPtrLatC, rc=rc)
</PRE>

<P>
<PRE>
   do i1=clbnd(1),cubnd(1)
   do i2=clbnd(2),cubnd(2)
      ! Set Grid longitude coordinates as 0 to 360
      farrayPtrLonC(i1,i2) = REAL(i1-1)*360.0/REAL(GridLonSize)

      ! Set Grid latitude coordinates as -90 to 90
      farrayPtrLatC(i1,i2) = -90. + REAL(i2-1)*180.0/REAL(GridLatSize) + &amp;
                                      0.5*180.0/REAL(GridLatSize)
   enddo
   enddo


   !-------------------------------------------------------------------
   ! Create newLocstream on the background Grid using the 
   ! "Lon" and "Lat" keys as the coordinates for the entries in 
   ! locstream. The entries in newLocstream with coordinates (lon,lat)
   ! are on the same PET as the piece of grid which contains (lon,lat). 
   !-------------------------------------------------------------------
   newLocstream=ESMF_LocStreamCreate(locstream, &amp;
                  background=grid, rc=rc)


   !-------------------------------------------------------------------
   ! A Field can now be created on newLocstream and 
   ! ESMF_FieldRedist() can be used to move data between Fields built 
   ! on locstream and Fields built on newLocstream.
   !-------------------------------------------------------------------
</PRE>

<P>

<H3><A NAME="SECTION05093400000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Regridding from a Grid to a LocStream</A>
</H3>

<P>
The following is an example of how a LocStream object can be used in regridding.
  
<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create a global Grid to use as the regridding source. The Grid is 
   ! GridLonSize by GridLatSize with the default distribution 
   ! (The first dimension split across the PETs). The coordinate range
   ! is  0 to 360 in longitude and -90 to 90 in latitude. Note that we 
   ! use indexflag=ESMF_INDEX_GLOBAL for the Grid creation to calculate
   ! coordinates across PETs.
   !-------------------------------------------------------------------
   grid=ESMF_GridCreate1PeriDim(maxIndex=(/GridLonSize,GridLatSize/), &amp;
                                coordSys=ESMF_COORDSYS_SPH_DEG,       &amp;
                                indexflag=ESMF_INDEX_GLOBAL,          &amp;
                                rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate the center stagger location in which to put the coordinates. 
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid, staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get access to the Fortran array pointers that hold the Grid 
   ! coordinate information.
   !------------------------------------------------------------------- 
   ! Longitudes 
   call ESMF_GridGetCoord(grid,                                  &amp;
                          staggerLoc=ESMF_STAGGERLOC_CENTER,     &amp;
                          coordDim=1, computationalLBound=clbnd, &amp;
                          computationalUBound=cubnd,             &amp;
                          farrayPtr=farrayPtrLonC, rc=rc)
</PRE>

<P>
<PRE>
   ! Latitudes
   call ESMF_GridGetCoord(grid,                                  &amp;
                          staggerLoc=ESMF_STAGGERLOC_CENTER,     &amp;
                          coordDim=2, computationalLBound=clbnd, &amp;
                          computationalUBound=cubnd,             &amp;
                          farrayPtr=farrayPtrLatC, rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create a source Field to hold the data to be regridded to the 
   ! destination
   !-------------------------------------------------------------------
   srcField = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_R8,   &amp;
                               staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                               name="source", rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Set the Grid coordinates to be uniformly distributed around the globe. 
   !-------------------------------------------------------------------
   do i1=clbnd(1),cubnd(1)
   do i2=clbnd(2),cubnd(2)
      ! Set Grid longitude coordinates as 0 to 360
      farrayPtrLonC(i1,i2) = REAL(i1-1)*360.0/REAL(GridLonSize)

      ! Set Grid latitude coordinates as -90 to 90
      farrayPtrLatC(i1,i2) = -90. + REAL(i2-1)*180.0/REAL(GridLatSize) + &amp;
                                       0.5*180.0/REAL(GridLatSize)
</PRE>

<P>
<PRE>
   enddo
   enddo

   !-------------------------------------------------------------------
   ! Set the number of points the destination LocStream will have
   ! depending on the PET. 
   !-------------------------------------------------------------------
   if (petCount .eq. 1) then
     numLocationsOnThisPet=7
   else
     if (localpet .eq. 0) then
       numLocationsOnThisPet=2
     else if (localpet .eq. 1) then
       numLocationsOnThisPet=2
     else if (localpet .eq. 2) then
       numLocationsOnThisPet=2
     else if (localpet .eq. 3) then
       numLocationsOnThisPet=1
     endif
   endif

   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object,
   ! define the number of locations on this PET. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Test Data",                 &amp;
                                  localCount=numLocationsOnThisPet, &amp;
                                  coordSys=ESMF_COORDSYS_SPH_DEG,   &amp;
                                  rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Add key data to LocStream(internally allocating memory).
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="ESMF:Lat",           &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="degrees",           &amp;
                             keyLongName="Latitude", rc=rc)
</PRE>

<P>
<PRE>
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="ESMF:Lon",           &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="degrees",           &amp;
                             keyLongName="Longitude", rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Get access to the Fortran array pointers that hold the key data.
   !-------------------------------------------------------------------
   ! Longitudes
   call ESMF_LocStreamGetKey(locstream,           &amp;
                             keyName="ESMF:Lon",  &amp;
                             farray=lonArray,     &amp;
                             rc=rc)
</PRE>

<P>
<PRE>
   ! Latitudes
   call ESMF_LocStreamGetKey(locstream,           &amp;
                             keyName="ESMF:Lat",  &amp;
                             farray=latArray,     &amp;
                             rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Set coordinates in key arrays depending on the PET.
   ! For this example use an arbitrary set of points around globe.  
   !-------------------------------------------------------------------
   if (petCount .eq. 1) then
     latArray = (/-87.75, -56.25, -26.5, 0.0, 26.5, 56.25, 87.75 /)
     lonArray = (/51.4, 102.8, 154.2, 205.6, 257.0, 308.4, 359.8 /)
   else
     if (localpet .eq. 0) then
       latArray = (/ -87.75, -56.25 /)
       lonArray = (/ 51.4, 102.8 /)
     else if (localpet .eq.1) then
       latArray = (/ -26.5, 0.0 /)
       lonArray = (/ 154.2, 205.6 /)
     else if (localpet .eq.2) then
       latArray = (/ 26.5, 56.25 /)
       lonArray = (/ 257.0, 308.4 /)
     else if (localpet .eq.3) then
       latArray = (/ 87.75 /)
       lonArray = (/ 359.8 /)
     endif
   endif

   !-------------------------------------------------------------------
   ! Create the destination Field on the LocStream to hold the 
   ! result of the regridding. 
   !-------------------------------------------------------------------
   dstField = ESMF_FieldCreate(locstream, typekind=ESMF_TYPEKIND_R8, &amp;
                               name="dest", rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Calculate the RouteHandle that represents the regridding from 
   ! the source to destination Field using the Bilinear regridding method.
   !-------------------------------------------------------------------
   call ESMF_FieldRegridStore( srcField=srcField,                       &amp;
                               dstField=dstField,                       &amp;
                               routeHandle=routeHandle,                 &amp;
                               regridmethod=ESMF_REGRIDMETHOD_BILINEAR, &amp;
                               rc=rc)
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Regrid from srcField to dstField
   !-------------------------------------------------------------------
   ! Can loop here regridding from srcField to dstField as src data changes
   ! do i=1,...

        ! (Put data into srcField)

        !-------------------------------------------------------------------
        ! Use the RouteHandle to regrid data from srcField to dstField.
        !-------------------------------------------------------------------
        call ESMF_FieldRegrid(srcField, dstField, routeHandle, rc=rc)

        ! (Can now use the data in dstField)

   ! enddo
</PRE>

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Now that we are done, release the RouteHandle freeing its memory. 
   !-------------------------------------------------------------------
   call ESMF_FieldRegridRelease(routeHandle, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION05094000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05094100000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LocStreamAssignment(=) - LocStream assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     locstream1 = locstream2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream) :: locstream1
     type(ESMF_LocStream) :: locstream2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign locstream1 as an alias to the same ESMF LocStream object in memory
     as locstream2. If locstream2 is invalid, then locstream1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>locstream1</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>locstream2</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05094200000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LocStreamOperator(==) - LocStream equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (locstream1 == locstream2) then ... endif
               OR
     result = (locstream1 == locstream2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream1
     type(ESMF_LocStream), intent(in) :: locstream2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether locstream1 and locstream2 are valid aliases to the same ESMF
     LocStream object in memory. For a more general comparison of two ESMF LocStreams,
     going beyond the simple alias test, the ESMF_LocStreamMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>locstream1</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>locstream2</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05094300000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LocStreamOperator(/=) - LocStream not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (locstream1 /= locstream2) then ... endif
               OR
     result = (locstream1 /= locstream2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream1
     type(ESMF_LocStream), intent(in) :: locstream2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether locstream1 and locstream2 are <I>not</I> valid aliases to the
     same ESMF LocStream object in memory. For a more general comparison of two ESMF
     LocStreams, going beyond the simple alias test, the ESMF_LocStreamMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>locstream1</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>locstream2</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05094400000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_LocStreamAddKey - Add a key Array and allocate the internal memory</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyAlloc(locstream, keyName, &amp;
                keyTypeKind, keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream),     intent(in)            :: locstream
     character (len=*),        intent(in)            :: keyName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_TypeKind_Flag), intent(in),  optional :: keyTypeKind
     character (len=*),        intent(in),  optional :: keyUnits 
     character (len=*),        intent(in),  optional :: keyLongName 
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream with a required keyName. Once a key has 
   been added, a pointer to its internally allocated memory can be 
   retrieved and used to set key values. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>[keyTypeKind]</STRONG></DT>
<DD>The type/kind of the key data. 
   If not specified then the type/kind will default to 8 byte reals.  
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05094500000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_LocStreamAddKey - Add a key Array </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyArray(locstream, keyName, keyArray, &amp;
                destroyKey, keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)             :: locstream
     character (len=*),    intent(in)             :: keyName
     type(ESMF_Array),     intent(in)             :: keyArray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,              intent(in),  optional  :: destroyKey
     character (len=*),    intent(in),  optional  :: keyUnits 
     character (len=*),    intent(in),  optional  :: keyLongName 
     integer,              intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream with a required keyName and a required 
   <TT>ESMF_Array</TT>.  The user is responsible for the creation of the 
   <TT>ESMF_Array</TT> that will hold the key values.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>keyArray</STRONG></DT>
<DD>An ESMF Array which contains the key data
   
</DD>
<DT><STRONG>[destroyKey]</STRONG></DT>
<DD>if .true. destroy this key array when the locstream is destroyed.
   Defaults to .false.
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05094600000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_LocStreamAddKey - Add a key Array created around user memory </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
    subroutine ESMF_LocStreamAddKeyI4(locstream, keyName, farray, &amp;
                 datacopyflag, keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_Locstream), intent(in) :: locstream
      character (len=*), intent(in) :: keyName
      &lt;farray&gt;
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
      character (len=*), intent(in), optional :: keyUnits
      character (len=*), intent(in), optional :: keyLongName
      integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream with a required keyName and a required 
      Fortran array.  The user is responsible for the creation of the 
      Fortran array that will hold the key values, including 
      the maintenance of any allocated memory.

<P>
Supported values for &lt;farray&gt; are:
      <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in) :: farray(:)
      
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4),    intent(in) :: farray(:)
      
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8),    intent(in) :: farray(:)
      
</DD>
</DL>

<P>
The arguments are:
      <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
      
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
      
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
      actual argument. The type/kind/rank information of <TT>farray</TT> will be 
      used to set the key Array's properties accordingly. 
      
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
      provided by <TT>farray</TT> directly or will copy the data from 
      <TT>farray</TT> into a new memory allocation. Valid options are 
  !    <TT>ESMF_DATACOPY_REFERENCE</TT> (default) or <TT>ESMF_DATACOPY_VALUE</TT>. 
      Depending on the specific situation the <TT>ESMF_DATACOPY_REFERENCE</TT> option 
      may be unsafe when specifying an array slice for <TT>farray</TT>. 
      
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
      If not specified, then the item remains blank.  
      
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
      If not specified, then the item remains blank.  
      
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
      
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05094700000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_LocStreamCreate - Create a new LocStream by projecting onto a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateByBkgGrid(locstream, &amp;
                  background, maskValues, &amp;
                  unmappedaction, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateByBkgGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),           intent(in)            :: locstream
       type(ESMF_Grid),                intent(in)            :: background
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),          intent(in),  optional :: maskValues(:)
       type(ESMF_UnmappedAction_Flag), intent(in),  optional :: unmappedaction
       character (len=*),              intent(in),  optional :: name
       integer,                        intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an location stream from an existing one in accordance with 
       the distribution of the background Grid.  The entries
       in the new location stream are redistributed, so that they lie on the same PET
       as the piece of Grid which contains the coordinates of the entries. The coordinates
       of the entries are the data in the keys named ESMF:Lon, ESMF:Lat, ESMF:Radius in the 
       case of a spherical system and ESMF:X, ESMF:Y, ESMF:Z for cartesian. To copy data in
       Fields or FieldBundles built on <TT>locstream</TT> to the new one simply use <TT>ESMF_FieldRedist()</TT>
       or <TT>ESMF_FieldBundleRedist()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>Location stream from which the new location stream is to be created
        
</DD>
<DT><STRONG>background</STRONG></DT>
<DD>Background Grid which determines the distribution of the entries in the new location stream.
            The background Grid 
            Note also that this subroutine uses the corner stagger location in the Grid for determining 
            where a point lies, because this is the stagger location which fully contains the cell. 
            A Grid must have coordinate data in this stagger location to be used in this subroutine. 
            For a 2D Grid this stagger location is ESMF_STAGGERLOC_CORNER for a 3D Grid this 
            stagger location is ESMF_STAGGERLOC_CORNER_VFACE. Note that currently the background 
            Grid also needs to have been created with indexflag=ESMF_INDEX_GLOBAL to be usable here. 
       
</DD>
<DT><STRONG>[maskValues]</STRONG></DT>
<DD>List of values that indicate a background grid point should be masked out. 
             If not specified, no masking will occur. 
       
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Please see Section&nbsp;<A HREF="node9.html#const:unmappedaction">54.60</A> for a 
             list of valid options. If not specified, <TT>unmappedaction</TT> defaults to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. [NOTE: the <TT>unmappedaction=ESMF_UNMAPPEDACTION_IGNORE</TT> option is currently not implemented.]
        
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the resulting location stream
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05094800000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_LocStreamCreate - Create a new LocStream by projecting onto a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateByBkgMesh(locstream, &amp;
                  background, unmappedaction, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateByBkgMesh
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),           intent(in)           :: locstream
       type(ESMF_Mesh),                intent(in)           :: background
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_UnmappedAction_Flag), intent(in), optional :: unmappedaction
       character (len=*),              intent(in), optional :: name
       integer,                        intent(out),optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an location stream from an existing one in accordance with 
       the distribution of the background Mesh.  The entries
       in the new location stream are redistributed, so that they lie on the same PET
       as the piece of Mesh which contains the coordinates of the entries. The coordinates
       of the entries are the data in the keys named ESMF:Lon, ESMF:Lat, ESMF:Radius in the 
       case of a spherical system and ESMF:X, ESMF:Y, ESMF:Z for cartesian. To copy data in
       Fields or FieldBundles built on <TT>locstream</TT> to the new one simply use <TT>ESMF_FieldRedist()</TT>
       or <TT>ESMF_FieldBundleRedist()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>Location stream from which the new location stream is to be created
        
</DD>
<DT><STRONG>background</STRONG></DT>
<DD>Background Mesh which determines the distribution of entries in the new locatiion stream.
       
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Please see Section&nbsp;<A HREF="node9.html#const:unmappedaction">54.60</A> for a 
             list of valid options. If not specified, <TT>unmappedaction</TT> defaults to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. [NOTE: the <TT>unmappedaction=ESMF_UNMAPPEDACTION_IGNORE</TT> option is currently not implemented.]
        
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the resulting location stream
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05094900000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_LocStreamCreate - Create a new LocStream from a distgrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateFromDG(distgrid, &amp;
         indexflag, coordSys, name, vm, rc )
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateFromDG
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_DistGrid),      intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Index_Flag),    intent(in),  optional :: indexflag    
       type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
       character (len=*),        intent(in),  optional :: name
       type(ESMF_VM),            intent(in),  optional :: vm
       integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types. 

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Distgrid specifying size and distribution. Only 1D distgrids are allowed.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the location stream coordinate data.
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the LocStream object is created on the specified 
           <TT>ESMF_VM</TT> object. The default is to create on the VM of the 
           current context.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050941000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_LocStreamCreate - Create a new LocStream from an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateIrreg(minIndex, countsPerDE, &amp;
                   indexflag, coordSys, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateIrreg
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer, intent(in), optional                   :: minIndex
       integer, intent(in)                             :: countsPerDE(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Index_Flag), intent(in), optional     :: indexflag
       type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
       character (len=*), intent(in), optional         :: name
       integer, intent(out), optional                  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. 

<P>
The arguments are:
       <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>If indexflag=<TT>ESMF_INDEX_DELOCAL</TT>, this setting is used to indicate
            the number to start the index ranges at. If not present, defaults to 1.
       
</DD>
<DT><STRONG>countsPerDE</STRONG></DT>
<DD>This array has an element for each DE, specifying the number of locations 
            for that DE.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the location stream coordinate data.
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050941100000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_LocStreamCreate - Create a new LocStream from a local count</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateFromLocal(localCount, &amp;
                   indexflag, coordSys, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateFromLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer, intent(in)                             :: localCount
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Index_Flag), intent(in), optional     :: indexflag
       type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
       character (len=*), intent(in), optional         :: name
       integer, intent(out), optional                  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. The assumed layout is one DE per PET.

<P>
The arguments are:
       <DL>
<DT><STRONG>localCount</STRONG></DT>
<DD>Number of grid cells to be distributed to this DE/PET.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the location stream coordinate data.
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050941200000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_LocStreamCreate - Create a new LocStream from an old one and a distgrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateFromNewDG(locstream, distgrid, &amp;
            name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateFromNewDG
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in)                :: locstream
       type(ESMF_DistGrid),  intent(in)                :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*),    intent(in), optional      :: name
       integer,              intent(out), optional     :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new location stream that is a copy of an old one, but with a new
       distribution. The new distribution is given by a distgrid passed into the call.
       Key and other class information is copied from the old locstream to the new one. 
       Information contained in Fields build on the location streams can be copied over
       by using the Field redistribution calls (e.g. <TT>ESMF_FieldRedistStore()</TT> 
       and <TT>ESMF_FieldRedist()</TT>).   

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>Location stream from which the new location stream is to be created
        
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Distgrid for new distgrid
        
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the resulting location stream
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050941300000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_LocStreamCreate - Create a new LocStream using a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateReg(regDecomp, decompFlag, &amp;
                     minIndex, maxIndex, &amp;
                     coordSys, indexflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,                  intent(in),  optional  :: regDecomp
       type(ESMF_Decomp_Flag),   intent(in),  optional  :: decompflag
       integer,                  intent(in),  optional  :: minIndex
       integer,                  intent(in)             :: maxIndex
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_CoordSys_Flag), intent(in),  optional  :: coordSys
       type(ESMF_Index_Flag),    intent(in),  optional  :: indexflag
       character (len=*),        intent(in),  optional  :: name
       integer,                  intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. 

<P>
The arguments are:
       <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>Specify into how many chunks to divide the locations. 
            If not specified, defaults to the number of PETs.
       
</DD>
<DT><STRONG>[decompFlag]</STRONG></DT>
<DD>Specify what to do with leftover locations after division.
            If not specified, defaults to <TT>ESMF_DECOMP_BALANCED</TT>. Please
            see Section&nbsp;<A HREF="node9.html#const:decompflag">54.13</A> for a full description of the 
            possible options.

</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>If indexflag=<TT>ESMF_INDEX_DELOCAL</TT>, this setting is used to indicate
            the number to start the index ranges at. If not present, defaults to 1.
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The maximum index across all PETs.
       
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the location stream coordinate data.
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050941400000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_LocStreamCreate - Create a new LocStream from a grid file</A>
</H3>

<P>
<A NAME="locstream:createfromfile"></A>
<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateFromFile(filename, &amp;
            fileformat, varname, indexflag, centerflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateFromFile
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*),          intent(in)           :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_FileFormat_Flag), intent(in), optional :: fileformat
       character(len=*),           intent(in), optional :: varname
       type(ESMF_Index_Flag),      intent(in), optional :: indexflag
       logical,                    intent(in), optional :: centerflag
       character (len=*),          intent(in), optional :: name
       integer,                    intent(out),optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_LocStream</TT> object and add the coordinate keys and mask key
       to the LocStream using the coordinates defined in a grid file.  Currently, it 
       supports the SCRIP format, the ESMF unstructured grid format and the UGRID format.
       For a 2D or 3D grid in ESMF or UGRID format, it can construct the LocStream using either 
       the center coordinates or the corner coordinates.  For a SCRIP format grid file, the
       LocStream can only be constructed using the center coordinates.  In
       addition, it supports 1D network topology in UGRID format.  When
       construction a LocStream using a 1D UGRID, it always uses node
       coordinates (i.e., corner coordinates). 

<P>
The arguments are:
       <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of grid file to be used to create the location stream.  
       
</DD>
<DT><STRONG>[fileformat]</STRONG></DT>
<DD>The file format.  The valid options are <TT>ESMF_FILEFORMAT_SCRIP</TT>,
       <TT>ESMF_FILEFORMAT_ESMFMESH</TT>, and <TT>ESMF_FILEFORMAT_UGRID</TT>.
        Please see section&nbsp;<A HREF="node9.html#const:fileformatflag">54.19</A> for a detailed description of the options.
       If not specified, the default is <TT>ESMF_FILEFORMAT_SCRIP</TT>.
       
</DD>
<DT><STRONG>[varname]</STRONG></DT>
<DD>An optional variable name stored in the UGRID file to be used to
           generate the mask using the missing value of the data value of
           this variable.  The first two dimensions of the variable has to be the
           the longitude and the latitude dimension and the mask is derived from the
           first 2D values of this variable even if this data is 3D, or 4D array. If not 
           specified, no mask is used for a UGRID file.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node9.html#const:indexflag">54.27</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[centerflag]</STRONG></DT>
<DD>Flag that indicates whether to use the center coordinates to construct the location stream.
            If true, use center coordinates, otherwise, use the corner coordinates.  If not specified,
            use center coordinates as default.  For SCRIP files, only center coordinate 
            is supported.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050941500000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_LocStreamDestroy - Release resources associated with a LocStream </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamDestroy(locstream, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(inout)          :: locstream 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,              intent(in),   optional :: noGarbage
       integer,              intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Deallocate an <TT>ESMF_LocStream</TT> object and appropriate 
       internal structures.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>locstream to destroy
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this
        condition ESMF cannot protect against accessing the destroyed object
        through dangling aliases - a situation which may lead to hard to debug
        application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
        set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use
        temporary ESMF objects. For situations where the repeated creation and
        destruction of temporary objects leads to memory issues, it is
        recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
        removing the entire temporary object from memory.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050941600000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_LocStreamGet - Return object-wide information from a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_LocStreamGet(locstream, &amp;
        distgrid, keyCount, keyNames, localDECount, indexflag, &amp;
        coordSys, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream),         intent(in)            :: locstream
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DistGrid),          intent(out), optional :: distgrid
     integer,                      intent(out), optional :: keyCount
     character(len=ESMF_MAXSTR),                optional :: keyNames(:) 
     integer,                      intent(out), optional :: localDECount
     type(ESMF_Index_Flag),        intent(out), optional :: indexflag
     type(ESMF_CoordSys_Flag),     intent(out), optional :: coordSys
     character(len=*),             intent(out), optional :: name
     integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query an <TT>ESMF_LocStream</TT> for various information. All arguments after
   the <TT>locstream</TT> are optional. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to query.
   
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object that describes 
   
</DD>
<DT><STRONG>[keyCount]</STRONG></DT>
<DD>Number of keys in the <TT>locstream</TT>.
   
</DD>
<DT><STRONG>[keyNames]</STRONG></DT>
<DD>The names of the keys in the <TT>locstream</TT>. Keynames should
   be an array of character strings. The character strings should
   be of length ESMF_MAXSTR and the array's length should be
   at least keyCount. 
   
</DD>
<DT><STRONG>[localDECount]</STRONG></DT>
<DD>Number of DEs on this PET in the <TT>locstream</TT>.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>The indexflag for this indexflag.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system for this location stream.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of queried item.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050941700000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_LocStreamGetBounds - Get DE-local bounds of a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamGetBounds(locstream,   &amp;
           localDE, exclusiveLBound, exclusiveUBound, exclusiveCount,   &amp;
           computationalLBound, computationalUBound, computationalCount,&amp;
           rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),   intent(in) :: locstream
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(in),  optional :: localDE
       integer,                intent(out), optional :: exclusiveLBound
       integer,                intent(out), optional :: exclusiveUBound
       integer,                intent(out), optional :: exclusiveCount
       integer,                intent(out), optional :: computationalLBound
       integer,                intent(out), optional :: computationalUBound
       integer,                intent(out), optional :: computationalCount
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets the bounds of a localDE for a locstream.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE for which information is requested. <TT>[0,..,localDECount-1]</TT>.
           For <TT>localDECount==1</TT> the <TT>localDE</TT> argument may be omitted,
            in which case it will default to <TT>localDE=0</TT>.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>!          Upon return this holds the number of items in the exclusive region
       <BR>
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
       <BR>
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050941800000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_LocStreamGetKey - Get an Array associated with a key</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
   subroutine ESMF_LocStreamGetKeyArray(locstream, keyName, keyArray, &amp;
        rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)            :: locstream
     character (len=*),    intent(in)            :: keyName
     type(ESMF_Array),     intent(out)           :: keyArray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get ESMF Array associated with key.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to get key from.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to get. 
   
</DD>
<DT><STRONG>keyArray</STRONG></DT>
<DD>Array associated with key.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050941900000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_LocStreamGetKey - Get info associated with a key</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
   subroutine ESMF_LocStreamGetKeyInfo(locstream, keyName, &amp;
        keyUnits, keyLongName, typekind, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream),     intent(in)            :: locstream
     character (len=*),        intent(in)            :: keyName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character (len=*),        intent(out), optional :: keyUnits 
     character (len=*),        intent(out), optional :: keyLongName 
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     logical,                  intent(out), optional :: isPresent
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get ESMF Array associated with key.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to get key from.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to get. 
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the key data
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Whether or not the keyname is present 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050942000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_LocStreamGetKey - Get a DE-local Fortran array pointer to key values</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
        subroutine ESMF_LocStreamGetKey(locstream, keyName, &amp;
            localDE, exclusiveLBound, exclusiveUBound, exclusiveCount,       &amp;
            computationalLBound, computationalUBound, computationalCount,    &amp;
            totalLBound, totalUBound, totalCount,                            &amp;
            farray, datacopyflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_LocStream),   intent(in)            :: locstream
        character (len=*),      intent(in)            :: keyName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                intent(in),  optional :: localDE
        integer,                intent(out), optional :: exclusiveLBound
        integer,                intent(out), optional :: exclusiveUBound
        integer,                intent(out), optional :: exclusiveCount
        integer,                intent(out), optional :: computationalLBound
        integer,                intent(out), optional :: computationalUBound
        integer,                intent(out), optional :: computationalCount
        integer,                intent(out), optional :: totalLBound
        integer,                intent(out), optional :: totalUBound
        integer,                intent(out), optional :: totalCount
        &lt;farray&gt;
        type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
        integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
      key data for a particular key on the given local DE. 
      This is useful, for example, for setting the key values in a LocStream, or
      for reading the values. 

<P>
Supported values for &lt;farray&gt; are:
      <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: farray(:)
      
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farray(:)
      
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farray(:)
      
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The key to get the information from.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE for which information is requested. <TT>[0,..,localDECount-1]</TT>.
           For <TT>localDECount==1</TT> the <TT>localDE</TT> argument may be omitted,
            in which case it will default to <TT>localDE=0</TT>.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region <BR>
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
            <BR>
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region
            (i.e. <TT>totalUBound-totalLBound+1</TT>). 
       
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>The pointer to the coordinate data.
       
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATACOPY_REFERENCE</TT>, in this case
            farray is a reference to the data in the Grid coordinate arrays. 
            Please see Section&nbsp;<A HREF="node9.html#const:datacopyflag">54.12</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050942100000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_LocStreamIsCreated - Check whether a LocStream object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_LocStreamIsCreated(locstream, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_LocStreamIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in)            :: locstream
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>locstream</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050942200000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_LocStreamPrint - Print the contents of a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamPrint(locstream, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in)             :: locstream 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len = *),  intent(in),   optional :: options
       integer,              intent(out),  optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>locstream</TT> to <TT>stdout</TT>.
    This subroutine goes through the internal data members of a locstream
  !  data type and prints information of each data member.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options are not yet supported.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050942300000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_LocStreamValidate - Check validity of a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamValidate(locstream, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(in)            :: locstream 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>locstream</TT> is internally consistent.
        Currently this method determines if the <TT>locstream</TT> is uninitialized 
        or already destroyed. 

<P>
The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> to validate.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the <TT>locstream</TT> 
             is valid.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION050100000000000000000">
<SPAN CLASS="arabic">33</SPAN> Mesh Class</A>
</H1>

<H2><A NAME="SECTION050101000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
Unstructured grids are commonly used in the computational solution of partial differential 
equations.  These are especially useful for problems that involve complex geometry, where 
using the less flexible structured grids can result in grid representation of regions 
where no computation is needed.  Finite element and finite volume methods map naturally 
to unstructured grids and are used commonly in hydrology, ocean modeling, and many other 
applications.

<P>
In order to provide support for application codes using unstructured grids, the ESMF library 
provides a class for representing unstructured grids called the <B>Mesh</B>. Fields can be 
created on a Mesh to hold data. Fields created on a Mesh can also be used as either the 
source or destination or both of an interpolation (i.e. an <TT>ESMF_FieldRegridStore()</TT> call) 
which allows data to be moved between unstructured grids. This section describes the Mesh 
and how to create and use them in ESMF. 

<P>

<H3><A NAME="SECTION050101100000000000000"></A><A NAME="sec:meshrep"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh representation in ESMF
</H3>

<P>
A Mesh in ESMF is constructed of <B>nodes</B> and <B>elements</B>.

<P>
A <B>node</B>, also known as a vertex or corner, is a part of a Mesh which represents a single point. Coordinate information is
set in a node.

<P>
An <B>element</B>, also known as a cell, is a part of a mesh which represents a small 
region of space. Elements are described in terms of a connected set of nodes which represent locations along their boundaries.

<P>
Field data may be located on either the nodes or elements of a Mesh. 

<P>

<P>
<BR>

<P>
The dimension of a Mesh in ESMF is specified with two parameters: the <B>parametric dimension</B> and the <B>spatial dimension</B>.

<P>
The <B>parametric dimension</B> of a Mesh is the dimension of the topology of the Mesh. This can be thought of as the dimension of 
the elements which make up the Mesh. For example, a Mesh composed of triangles would have a parametric dimension of 2, whereas
a Mesh composed of tetrahedra would have a parametric dimension of 3. 

<P>
The <B>spatial dimension</B> of a Mesh is the dimension of the space the Mesh is embedded in. In other words, it is the number of coordinate dimensions needed to describe the location of the nodes making up the Mesh. 

<P>
For example, a Mesh constructed of squares on a plane would have a parametric dimension of 2 and a spatial dimension of 2. 
If that same Mesh were used to represent the 2D surface of a sphere, then the Mesh would still have a parametric dimension 
of 2, but now its spatial dimension would be 3. 

<P>

<H3><A NAME="SECTION050101200000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Meshes</A>
</H3>

<P>
The range of Meshes supported by ESMF are defined by several factors: dimension, element 
types, and distribution.

<P>
ESMF currently only supports Meshes whose number of coordinate dimensions (spatial dimension) 
is 2 or 3. The dimension of the elements in a Mesh (parametric dimension) must be less than 
or equal to the spatial dimension, but also must be either 2 or 3. This means that a Mesh may 
be either 2D elements in 2D space, 3D elements in 3D space, or a manifold constructed of 2D 
elements embedded in 3D space. 

<P>
ESMF supports a range of elements for each Mesh parametric dimension. For a 
parametric dimension of 2, the native supported element types are triangles and quadrilaterals.
In addition to these, ESMF supports 2D polygons with any number of sides. Internally these
are represented as sets of triangles, but to the user should behave like any other element. 
For a parametric dimension of 3, the supported element types are tetrahedrons
and hexahedrons. See Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for diagrams of these. The Mesh 
supports any combination of element types within a particular dimension, but types from 
different dimensions may not be mixed.  For example, a Mesh cannot be constructed of both 
quadrilaterals and tetrahedra.

<P>
ESMF currently only supports distributions where every node on a PET must be a part of an 
element on that PET. In other words, there must not be nodes without a corresponding element 
on any PET.

<H2><A NAME="SECTION050102000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION050102100000000000000"></A>
<A NAME="const:meshelemtype"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_MESHELEMTYPE
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
 An ESMF Mesh can be constructed from a combination of different elements. The type of elements that can
be used in a Mesh depends on the Mesh's parameteric dimension, which is set during Mesh creation. The
following are the valid Mesh element types for each valid Mesh parametric dimension (2D or 3D) .

<P>

<P>
<BR>

<P>
<PRE>
                     3                          4 ---------- 3
                    / \                         |            |  
                   /   \                        |            |
                  /     \                       |            |
                 /       \                      |            |
                /         \                     |            |
               1 --------- 2                    1 ---------- 2

           ESMF_MESHELEMTYPE_TRI            ESMF_MESHELEMTYPE_QUAD

     2D element types (numbers are the order for elementConn during Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 2 ESMF supports two native element types (illustrated above),
but also supports polygons with more sides. Internally these polygons are represented as a set of 
triangles, but to the user should behave like other elements. 
To specify the non-native polygons in the <TT>elementType</TT> argument use the number of corners 
of the polygon (e.g. for a pentagon use 5). The connectivity for a polygon should be specified in counterclockwise order.
The following table summarizes this information:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_TRI</TD>
<TD ALIGN="CENTER">3</TD>
<TD ALIGN="LEFT">A triangle</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_QUAD</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A quadrilateral (e.g. a rectangle)</TD>
</TR>
<TR><TD ALIGN="LEFT">N</TD>
<TD ALIGN="CENTER">N</TD>
<TD ALIGN="LEFT">An N-gon  (e.g. if N=5 a pentagon)</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<BR>

<P>
<PRE>
                                            
                 3                               8---------------7
                /|\                             /|              /|
               / | \                           / |             / |
              /  |  \                         /  |            /  |
             /   |   \                       /   |           /   |
            /    |    \                     5---------------6    |
           4-----|-----2                    |    |          |    |
            \    |    /                     |    4----------|----3
             \   |   /                      |   /           |   /
              \  |  /                       |  /            |  /
               \ | /                        | /             | /
                \|/                         |/              |/
                 1                          1---------------2

       ESMF_MESHELEMTYPE_TETRA             ESMF_MESHELEMTYPE_HEX  

  3D element types (numbers are the order for elementConn during Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 3 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_TETRA</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A tetrahedron (NOT VALID IN BILINEAR OR PATCH REGRID)</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_HEX</TD>
<TD ALIGN="CENTER">8</TD>
<TD ALIGN="LEFT">A hexahedron (e.g. a cube)</TD>
</TR>
</TABLE>

<H2><A NAME="SECTION050103000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>

<P>

<P>
This section describes the use of the ESMF Mesh class. It starts with an explanation and examples of 
   creating a Mesh and then goes through other Mesh methods. This set of sections covers the use of the 
   Mesh class interfaces. For further detail which applies to creating a Field on a Mesh, please see
   Section&nbsp;<A HREF="#sec:field:usage:create_mesh_arrayspec">26.3.19</A>.

<P>

<H3><A NAME="SECTION050103100000000000000"></A>
  <A NAME="sec:mesh:usage:meshCreation"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh creation
</H3>

<P>
To create a Mesh we need to set some properties of the Mesh as a whole, some properties of each node in the mesh and 
   then some properties of each element which connects the nodes (for a definition of node and element please see 
   Section&nbsp;<A HREF="#sec:meshrep">33.1.1</A>).

<P>
For the Mesh as a whole we set its parametric dimension (<TT>parametricDim</TT>) and spatial dimension (<TT>spatialDim</TT>). 
   A Mesh's parametric dimension can be thought of as the dimension of the elements which make up the Mesh.
   A Mesh's spatial dimension, on the other hand, is the is the number of coordinate dimensions needed to describe the location of 
   the nodes making up the Mesh. (For a fuller definition of these terms please see Section&nbsp;<A HREF="#sec:meshrep">33.1.1</A>.)

<P>
The structure of the per node and element information used to create a Mesh is influenced by the Mesh distribution strategy. 
   The Mesh class is distributed by elements. This means that a node must be present on any PET that contains an element 
   associated with that node, but not on any other PET (a node can't be on a PET without an element "home"). Since a node may be used
   by two or more elements located on different PETs, a node may be duplicated on multiple PETs. When a node is duplicated in this manner, 
   one and only one of the PETs that contain the node must "own" the node. The user sets this ownership when they define the nodes during Mesh creation.
   When a Field is created on a Mesh (i.e. on  the Mesh nodes), on each PET the Field is only created on the nodes which are owned by that PET.
   This means that the size of the Field memory on the PET can be smaller than the number of nodes used to create the Mesh on 
   that PET. Please see Section&nbsp;<A HREF="#sec:field:usage:create_mesh_arrayspec">26.3.19</A> in Field for further explanation and examples of this
   issue and others in working with Fields on Meshes. 

<P>
For each node in the Mesh we set three properties: the global id of the node (<TT>nodeIds</TT>), node coordinates 
   (<TT>nodeCoords</TT>), and which PET owns the node (<TT>nodeOwners</TT>). The node id is a unique (across all PETs) integer 
   attached to the particular node. It is used to indicate which nodes are the same when connecting together pieces of the 
   Mesh on different processors. The node coordinates indicate the location of a node in space and are used in the
   <TT>ESMF_FieldRegrid()</TT> functionality when interpolating. The node owner indicates which PET is in charge of the node. This
   is used when creating a Field on the Mesh to indicate which PET should contain a Field location for the data.

<P>
For each element in the Mesh we set three properties: the global id of the element (<TT>elementIds</TT>), the topology type of
   the element (<TT>elementTypes</TT>), and which nodes are connected together to form the element (<TT>elementConn</TT>). The element id is
   a unique (across all PETs) integer attached to the particular element. The element type describes the topology of the element 
   (e.g. a triangle vs. a quadrilateral). The range of choices for the topology of the elements in a Mesh are restricted by the 
   Mesh's parametric dimension (e.g. a Mesh can't contain a 2D element like a triangle, when its parametric dimension is 3D), but it can contain
   any combination of elements appropriate to its dimension. In particular, in 2D ESMF supports two native element types triangle and quadrilateral, but
   also provides support for polygons with any number of sides. These polygons are represented internally as sets of triangles, but to the user
   should behave like other elements. To specify a polygon with more than four sides, the element type should be set to the number of corners of 
   the polygon (e.g. element type=6 for a hexagon). 
   The element connectivity indicates which nodes are to be connected together to
   form the element. The number of nodes connected together for each element is implied by the elements topology type (<TT>elementTypes</TT>). 
   It is IMPORTANT to note, that the entries in this list are NOT the global ids of the nodes, but are indices into the PET local lists of
   node info used in the Mesh Create. In other words, the element connectivity isn't specified in terms of the global list of nodes, but instead
   is specified in terms of the locally described node info. One other important point about connectivities is that the order of the nodes in the 
   connectivity list of an element is important. Please see Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for diagrams illustrating the correct order of
   nodes in an element. In general, when specifying an element with parametric dimension 2, the nodes should be given in counterclockwise order
   around the element. 

<P>
Mesh creation may either be performed as a one step process using the full <TT>ESMF_MeshCreate()</TT> call, or may be done in three steps. The
   three step process starts with a more minimal <TT>ESMF_MeshCreate()</TT> call. It is then followed by the <TT>ESMF_MeshAddNodes()</TT> to 
   specify nodes, and then the <TT>ESMF_MeshAddElements()</TT> call to specify elements. This three step sequence is useful to conserve memory
   because the node arrays being used for the <TT>ESMF_MeshAddNodes()</TT> call can be deallocated before creating the arrays to be used in the <TT>ESMF_MeshAddElements()</TT> call.

<P>

<H3><A NAME="SECTION050103200000000000000"></A><A NAME="sec:mesh:1pet1step"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Create a small single PET Mesh in one step
</H3>
  <TABLE  WIDTH="100%">
<TR><TD> 
  <PRE>
  
   
    2.0   7 ------- 8 ------- 9
          |         |         |
          |    4    |    5    |
          |         |         |
    1.0   4 ------- 5 ------- 6
          |         |  \   3  |
          |    1    |    \    |
          |         |  2   \  |
    0.0   1 ------- 2 ------- 3
  
         0.0       1.0        2.0 
   
          Node Id labels at corners
         Element Id labels in centers
         (Everything owned by PET 0)
</PRE></TD></TR>
</TABLE>

<P>
This example is intended to illustrate the creation of a small Mesh on one PET. The reason for starting with a single PET
   case is so that the user can start to familiarize themselves with the concepts of Mesh creation without the added complication of 
   multiple processors. Later examples illustrate the multiple processor case. This example creates the small 2D Mesh which can be 
   seen in the figure above. Note that this Mesh consists of 9 nodes and 5 elements, where the elements are a mixture of 
   quadrilaterals and triangles.  The coordinates of the nodes in the Mesh range from 0.0 to 2.0 in both dimensions. The node ids are 
   in the corners of the elements whereas the element ids are in the centers. The following section of code illustrates the creation of
   this Mesh. 
  
<P>
<PRE>
  ! Set number of nodes
  numNodes=9

  ! Allocate and fill the node id array.
  allocate(nodeIds(numNodes))
  nodeIds=(/1,2,3,4,5,6,7,8,9/) 

  ! Allocate and fill node coordinate array.
  ! Since this is a 2D Mesh the size is 2x the
  ! number of nodes.
  allocate(nodeCoords(2*numNodes))
  nodeCoords=(/0.0,0.0, &amp; ! node id 1
               1.0,0.0, &amp; ! node id 2
               2.0,0.0, &amp; ! node id 3
               0.0,1.0, &amp; ! node id 4
               1.0,1.0, &amp; ! node id 5
               2.0,1.0, &amp; ! node id 6
               0.0,2.0, &amp; ! node id 7
               1.0,2.0, &amp; ! node id 8
               2.0,2.0 /) ! node id 9

  ! Allocate and fill the node owner array.
  ! Since this Mesh is all on PET 0, it's just set to all 0.
  allocate(nodeOwners(numNodes))
  nodeOwners=0 ! everything on PET 0


  ! Set the number of each type of element, plus the total number.
  numQuadElems=3
  numTriElems=2
  numTotElems=numQuadElems+numTriElems


  ! Allocate and fill the element id array.
  allocate(elemIds(numTotElems))
  elemIds=(/1,2,3,4,5/) 


  ! Allocate and fill the element topology type array.
  allocate(elemTypes(numTotElems))
  elemTypes=(/ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 1
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 2
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 3
              ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 4
              ESMF_MESHELEMTYPE_QUAD/)  ! elem id 5


  ! Allocate and fill the element connection type array.
  ! Note that entries in this array refer to the 
  ! positions in the nodeIds, etc. arrays and that
  ! the order and number of entries for each element
  ! reflects that given in the Mesh options 
  ! section for the corresponding entry
  ! in the elemTypes array. The number of 
  ! entries in this elemConn array is the
  ! number of nodes in a quad. (4) times the 
  ! number of quad. elements plus the number
  ! of nodes in a triangle (3) times the number
  ! of triangle elements. 
  allocate(elemConn(4*numQuadElems+3*numTriElems))
  elemConn=(/1,2,5,4, &amp;  ! elem id 1
             2,3,5,   &amp;  ! elem id 2
             3,6,5,   &amp;  ! elem id 3
             4,5,8,7, &amp;  ! elem id 4
             5,6,9,8/)   ! elem id 5


  ! Create Mesh structure in 1 step
  mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         coordSys=ESMF_COORDSYS_CART, &amp;
         nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
         nodeOwners=nodeOwners, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)


  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, ESMF_TYPEKIND_R8,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103300000000000000"></A><A NAME="sec:mesh:1pet3step"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Create a small single PET Mesh in three steps
</H3>

<P>
This example is intended to illustrate the creation of a small Mesh in three steps on one PET. The Mesh being created is exactly
   the same one as in the last example (Section&nbsp;<A HREF="#sec:mesh:1pet1step">33.3.2</A>), but the three step process allows the creation to occur in 
   a more memory efficient manner. 
   
<P>
<PRE>
  ! Create the mesh structure setting the dimensions
  ! and coordinate system
  mesh = ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
                         coordSys=ESMF_COORDSYS_CART, &amp;
                         rc=localrc)

  ! Set number of nodes
  numNodes=9

  ! Allocate and fill the node id array.
  allocate(nodeIds(numNodes))
  nodeIds=(/1,2,3,4,5,6,7,8,9/) 

  ! Allocate and fill node coordinate array.
  ! Since this is a 2D Mesh the size is 2x the
  ! number of nodes.
  allocate(nodeCoords(2*numNodes))
  nodeCoords=(/0.0,0.0, &amp; ! node id 1
               1.0,0.0, &amp; ! node id 2
               2.0,0.0, &amp; ! node id 3
               0.0,1.0, &amp; ! node id 4
               1.0,1.0, &amp; ! node id 5
               2.0,1.0, &amp; ! node id 6
               0.0,2.0, &amp; ! node id 7
               1.0,2.0, &amp; ! node id 8
               2.0,2.0 /) ! node id 9

  ! Allocate and fill the node owner array.
  ! Since this Mesh is all on PET 0, it's just set to all 0.
  allocate(nodeOwners(numNodes))
  nodeOwners=0 ! everything on PET 0

  ! Add the nodes to the Mesh
  call ESMF_MeshAddNodes(mesh, nodeIds=nodeIds, &amp;
         nodeCoords=nodeCoords, nodeOwners=nodeOwners, rc=localrc)

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! HERE IS THE POINT OF THE THREE STEP METHOD
  ! WE CAN DELETE THESE NODE ARRAYS BEFORE 
  ! ALLOCATING THE ELEMENT ARRAYS, THEREBY
  ! REDUCING THE AMOUNT OF MEMORY NEEDED 
  ! AT ONE TIME. 
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)


  ! Set the number of each type of element, plus the total number.
  numQuadElems=3
  numTriElems=2
  numTotElems=numQuadElems+numTriElems

  ! Allocate and fill the element id array.
  allocate(elemIds(numTotElems))
  elemIds=(/1,2,3,4,5/) 

  ! Allocate and fill the element topology type array.
  allocate(elemTypes(numTotElems))
  elemTypes=(/ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 1
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 2
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 3
              ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 4
              ESMF_MESHELEMTYPE_QUAD/)  ! elem id 5


  ! Allocate and fill the element connection type array.
  ! Note that entries in this array refer to the 
  ! positions in the nodeIds, etc. arrays and that
  ! the order and number of entries for each element
  ! reflects that given in the Mesh options 
  ! section for the corresponding entry
  ! in the elemTypes array. The number of 
  ! entries in this elemConn array is the
  ! number of nodes in a quad. (4) times the 
  ! number of quad. elements plus the number
  ! of nodes in a triangle (3) times the number
  ! of triangle elements. 
  allocate(elemConn(4*numQuadElems+3*numTriElems))
  elemConn=(/1,2,5,4, &amp;  ! elem id 1
             2,3,5,   &amp;  ! elem id 2
             3,6,5,   &amp;  ! elem id 3
             4,5,8,7, &amp;  ! elem id 4
             5,6,9,8/)   ! elem id 5


  ! Finish the creation of the Mesh by adding the elements
  call ESMF_MeshAddElements(mesh, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)

  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, ESMF_TYPEKIND_R8,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103400000000000000"></A>
  <A NAME="sec:mesh:4pet1step"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Create a small Mesh on 4 PETs in one step
</H3>
  <TABLE  WIDTH="100%">
<TR><TD> 
  <PRE>
  
    2.0   7 ------- 8        [8] ------ 9          
          |         |         |         |
          |    4    |         |    5    |
          |         |         |         |
    1.0  [4] ----- [5]       [5] ----- [6]
          
         0.0       1.0       1.0       2.0
  
             PET 2               PET 3
  
  
    1.0   4 ------- 5        [5] ------ 6
          |         |         |  \   3  |
          |    1    |         |    \    |
          |         |         | 2    \  |
    0.0   1 ------- 2        [2] ------ 3
  
         0.0       1.0       1.0      2.0 
   
             PET 0               PET 1
  
                 Node Id labels at corners
                Element Id labels in centers
</PRE></TD></TR>
</TABLE>

<P>
This example is intended to illustrate the creation of a small Mesh on multiple PETs. This example creates the same small 2D Mesh as the 
   previous two examples (See Section&nbsp;<A HREF="#sec:mesh:1pet1step">33.3.2</A> for a diagram), however, in this case the Mesh is broken up across 4 PETs. 
   The figure above illustrates the distribution of the Mesh across the PETs. As in the previous diagram, the node ids are in
   the corners of the elements and the element ids are in the centers. In this figure '[' and ']' around a character indicate a node which
   is owned by another PET. The nodeOwner parameter indicates which PET owns the node.  Note that the three step creation 
   illustrated in Section&nbsp;<A HREF="#sec:mesh:1pet3step">33.3.3</A> could also be used in a parallel Mesh creation such as this by simply interleaving 
   the three calls in the appropriate places between the node and element array definitions. 
  
<P>
<PRE>
 ! Break up what's being set by PET
 if (localPET .eq. 0) then !!! This part only for PET 0
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/1,2,4,5/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/0.0,0.0, &amp; ! node id 1
                 1.0,0.0, &amp; ! node id 2
                 0.0,1.0, &amp; ! node id 4
                 1.0,1.0 /) ! node id 5

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 1
                 0, &amp; ! node id 2
                 0, &amp; ! node id 4
                 0/)  ! node id 5

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/1/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 1

    ! Allocate and fill the element connection type array.
    ! Note that entry are local indices
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 1

  else if (localPET .eq. 1) then !!! This part only for PET 1
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/2,3,5,6/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/1.0,0.0, &amp; ! node id 2
                 2.0,0.0, &amp; ! node id 3
                 1.0,1.0, &amp; ! node id 5
                 2.0,1.0 /) ! node id 6

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 2
                 1, &amp; ! node id 3
                 0, &amp; ! node id 5
                 1/)  ! node id 6

    ! Set the number of each type of element, plus the total number.
    numQuadElems=0
    numTriElems=2
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/2,3/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_TRI, &amp; ! elem id 2
                ESMF_MESHELEMTYPE_TRI/)  ! elem id 3

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,3, &amp; ! elem id 2
               2,4,3/)  ! elem id 3

  else if (localPET .eq. 2) then !!! This part only for PET 2
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/4,5,7,8/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/0.0,1.0, &amp; ! node id 4
                 1.0,1.0, &amp; ! node id 5
                 0.0,2.0, &amp; ! node id 7
                 1.0,2.0 /) ! node id 8

    ! Allocate and fill the node owner array.
    ! Since this Mesh is all on PET 0, it's just set to all 0.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 4
                 0, &amp; ! node id 5
                 2, &amp; ! node id 7
                 2/)  ! node id 8

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/4/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 4

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 4

  else if (localPET .eq. 3) then !!! This part only for PET 3
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/5,6,8,9/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/1.0,1.0, &amp;  ! node id 5
                 2.0,1.0, &amp;  ! node id 6
                 1.0,2.0, &amp;  ! node id 8
                 2.0,2.0 /)  ! node id 9

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 5
                 1, &amp; ! node id 6
                 2, &amp; ! node id 8
                 3/)  ! node id 9

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/5/)  

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 5

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 5
  endif

  
  ! Create Mesh structure in 1 step
  mesh=ESMF_MeshCreate(parametricDim=2, spatialDim=2, &amp;
         coordSys=ESMF_COORDSYS_CART, &amp;
         nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
         nodeOwners=nodeOwners, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)


  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, ESMF_TYPEKIND_R8,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103500000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Create a copy of a Mesh with a new distribution</A>
</H3>
  <TABLE  WIDTH="100%">
<TR><TD> 
  <PRE>
  
    2.0   7 -------[8]               8 ------- 9          
          |         |                |         |
          |    4    |                |    5    |
          |         |                |         |
    1.0   4 ------ [5]               5 ------- 6
          
         0.0       1.0              1.0       2.0
  
             PET 1                      PET 0
  
  
    1.0  [4] ----- [5]              [5] ----- [6]
          |         |  \                \      |
          |    1    | 2  \                \  3 |
          |         |      \                \  |
    0.0   1 ------- 2 -----[3]                 3
  
         0.0       1.0               1.0      2.0 
   
             PET 2                      PET 3
  
                 Node Id labels at corners
                Element Id labels in centers
</PRE></TD></TR>
</TABLE>

<P>
This example demonstrates the creation of a new Mesh which is a copy of an existing Mesh
   with a new distribution of the original Mesh's nodes and elements. To create the new Mesh 
   in this manner the user needs two DistGrids. One to describe the new distribution of the nodes. 
   The other to describe the new distribution of the elements. In this example we create new 
   DistGrids from a list of indices. The DistGrids are then used in the redistribution 
   Mesh create interface which is overloaded to <TT>ESMF_MeshCreate()</TT>. In this example
   we redistribute the Mesh created in the previous example (Section&nbsp;<A HREF="#sec:mesh:4pet1step">33.3.4</A>) 
   to the distribution pictured above. Note that for simplicity's sake, the position of the
   Mesh in the diagram is basically the same, but the PET positions and node owners 
   have been changed. 
  
<P>
<PRE>
  ! Setup the new location of nodes and elements depending on the processor
  if (localPet .eq. 0) then !!! This part only for PET 0
     allocate(elemIds(1))
     elemIds=(/5/)
     
     allocate(nodeIds(4))
     nodeIds=(/5,6,8,9/)
     
  else if (localPet .eq. 1) then !!! This part only for PET 1
     allocate(elemIds(1))
     elemIds=(/4/)
     
     allocate(nodeIds(2))
     nodeIds=(/7,4/)        
     
  else if (localPet .eq. 2) then !!! This part only for PET 2
     allocate(elemIds(2))
     elemIds=(/1,2/)
     
     allocate(nodeIds(2))
     nodeIds=(/1,2/)
     
  else if (localPet .eq. 3) then !!! This part only for PET 3
     allocate(elemIds(1))
     elemIds=(/3/)
     
     allocate(nodeIds(1))
     nodeIds=(/3/)
     
  endif


  ! Create new node DistGrid
  nodedistgrid=ESMF_DistGridCreate(nodeIds, rc=localrc)
  if (localrc .ne. ESMF_SUCCESS) rc=ESMF_FAILURE

 
  ! Create new element DistGrid
  elemdistgrid=ESMF_DistGridCreate(elemIds, rc=localrc)
  if (localrc .ne. ESMF_SUCCESS) rc=ESMF_FAILURE


  ! Can now deallocate distribution lists
  deallocate(elemIds)
  deallocate(nodeIds)


  ! Create new redisted Mesh based on DistGrids
  mesh2=ESMF_MeshCreate(mesh,                         &amp;
                        nodalDistgrid=nodedistgrid,   &amp; 
                        elementDistgrid=elemdistgrid, &amp;
                        rc=localrc)
  if (localrc .ne. ESMF_SUCCESS) rc=ESMF_FAILURE


  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh2, ESMF_TYPEKIND_R8,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103600000000000000"></A>
  <A NAME="sec:mesh:4pet1stepee1type"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create a small Mesh of all one element type on 4 PETs using easy element method
</H3>
  <TABLE  WIDTH="100%">
<TR><TD> 
  <PRE>
  
    2.0   * ------- *         * ------- *          
          |         |         |         |
          |    3    |         |    4    |
          |         |         |         |
    1.0   * ------- *         * ------- *
          
         0.0       1.0       1.0       2.0
  
             PET 2               PET 3
  
  
    1.0   * ------- *         * ------- *
          |         |         |         |
          |    1    |         |    2    |
          |         |         |         |
    0.0   * ------- *         * ------- *
  
         0.0       1.0       1.0      2.0 
   
             PET 0               PET 1
  
             Element Id labels in centers
</PRE></TD></TR>
</TABLE>

<P>
This example is intended to illustrate the creation of a small Mesh on multiple PETs using the easy element creation interface. 
   Here the Mesh consists of only one type of element, so we can use a slightly more convenient interface. In this interface the user
   only needs to specify the element type once and the elementCornerCoords argument has three dimensions. This means that the corners for all
   elements are not collapsed into a 1D list as happens with the next example. 

<P>
The figure above shows the Mesh to be created and it's distribution across the PETs. As in the previous diagrams, the element ids are in the centers. 
   Note that in the example code below the user doesn't specify the element ids. In this case, they are assigned sequentially
   through the local elements on each PET starting with 1 for the first element on PET 0. (It isn't shown in the example below, but there is
   an optional argument that enables the user to set the element ids if they wish.) 
   Unlike some of the previous examples of Mesh creation, here the user doesn't specify node ids or ownership, so that information is shown by a "*" in 
   the diagram. 
  
<P>
<PRE>
 ! Break up what's being set by PET
 if (localPET .eq. 0) then !!! This part only for PET 0

    ! Set the number of elements on this PET
    numTotElems=1

    ! Allocate and fill element corner coordinate array.
    allocate(elemCornerCoords3(2,4,numTotElems))
    elemCornerCoords3(:,1,1)=(/0.0,0.0/) ! elem id 1 corner 1 
    elemCornerCoords3(:,2,1)=(/1.0,0.0/) ! elem id 1 corner 2
    elemCornerCoords3(:,3,1)=(/1.0,1.0/) ! elem id 1 corner 3
    elemCornerCoords3(:,4,1)=(/0.0,1.0/) ! elem id 1 corner 4

  else if (localPET .eq. 1) then !!! This part only for PET 1

    ! Set the number of elements on this PET
    numTotElems=1

    ! Allocate and fill element corner coordinate array.
    allocate(elemCornerCoords3(2,4,numTotElems))
    elemCornerCoords3(:,1,1)=(/1.0,0.0/) ! elem id 2 corner 1 
    elemCornerCoords3(:,2,1)=(/2.0,0.0/) ! elem id 2 corner 2
    elemCornerCoords3(:,3,1)=(/2.0,1.0/) ! elem id 2 corner 3
    elemCornerCoords3(:,4,1)=(/1.0,1.0/) ! elem id 2 corner 4 


  else if (localPET .eq. 2) then !!! This part only for PET 2

    ! Set the number of elements on this PET
    numTotElems=1

    ! Allocate and fill element corner coordinate array.
    allocate(elemCornerCoords3(2,4,numTotElems))
    elemCornerCoords3(:,1,1)=(/0.0,1.0/) ! elem id 3 corner 1 
    elemCornerCoords3(:,2,1)=(/1.0,1.0/) ! elem id 3 corner 2
    elemCornerCoords3(:,3,1)=(/1.0,2.0/) ! elem id 3 corner 3
    elemCornerCoords3(:,4,1)=(/0.0,2.0/) ! elem id 3 corner 4


  else if (localPET .eq. 3) then !!! This part only for PET 3

    ! Set the number of elements on this PET
    numTotElems=1

    ! Allocate and fill element corner coordinate array.
    allocate(elemCornerCoords3(2,4,numTotElems))
    elemCornerCoords3(:,1,1)=(/1.0,1.0/) ! elem id 4 corner 1 
    elemCornerCoords3(:,2,1)=(/2.0,1.0/) ! elem id 4 corner 2
    elemCornerCoords3(:,3,1)=(/2.0,2.0/) ! elem id 4 corner 3
    elemCornerCoords3(:,4,1)=(/1.0,2.0/) ! elem id 4 corner 4

  endif
  
  ! Create Mesh structure in 1 step
  mesh=ESMF_MeshCreate(parametricDim=2, &amp;
         coordSys=ESMF_COORDSYS_CART,   &amp;
         elementType=ESMF_MESHELEMTYPE_QUAD, &amp;
         elementCornerCoords=elemCornerCoords3, &amp;
         rc=localrc)


  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(elemCornerCoords3)

  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for elements owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, ESMF_TYPEKIND_R8, &amp;
       meshloc=ESMF_MESHLOC_ELEMENT, rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103700000000000000"></A>
  <A NAME="sec:mesh:4pet1stepee"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Create a small Mesh of multiple element types on 4 PETs using easy element method
</H3>
  <TABLE  WIDTH="100%">
<TR><TD> 
  <PRE>
  
    2.0   * ------- *         * ------- *          
          |         |         |         |
          |    4    |         |    5    |
          |         |         |         |
    1.0   * ------- *         * ------- *
          
         0.0       1.0       1.0       2.0
  
             PET 2               PET 3
  
  
    1.0   * ------- *         * ------- *
          |         |         |  \   3  |
          |    1    |         |    \    |
          |         |         | 2    \  |
    0.0   * ------- *         * ------- *
  
         0.0       1.0       1.0      2.0 
   
             PET 0               PET 1
  
             Element Id labels in centers
</PRE></TD></TR>
</TABLE>

<P>
This example is intended to illustrate the creation of a small Mesh on multiple PETs using the easy element creation interface. 
   In this example, the Mesh being created contains elements of multiple types.
   To support the specification of a set of elements containing different types and thus different 
   numbers of corners, the elementCornerCoords argument has the 
   corner and element dimensions collapsed together into one dimension.

<P>
The figure above shows the Mesh to be created and it's distribution across the PETs. As in the previous diagrams, the element ids are in the centers. 
   Note that in the example code below the user doesn't specify the element ids. In this case, they are assigned sequentially
   through the local elements on each PET starting with 1 for the first element on PET 0. (It isn't shown in the example below, but there is
   an optional argument that enables the user to set the element ids if they wish.) 
   Unlike some of the previous examples of Mesh creation, here the user doesn't specify node ids or ownership, so that information is shown by a "*" in 
   the diagram. 

<P>
<PRE>
 ! Break up what's being set by PET
 if (localPET .eq. 0) then !!! This part only for PET 0

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems
    numElemCorners=4*numQuadElems+3*numTriElems

    ! Allocate and fill the element type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 1

    ! Allocate and fill element corner coordinate array.
    allocate(elemCornerCoords2(2,numElemCorners))
    elemCornerCoords2(:,1)=(/0.0,0.0/) ! elem id 1 corner 1 
    elemCornerCoords2(:,2)=(/1.0,0.0/) ! elem id 1 corner 2
    elemCornerCoords2(:,3)=(/1.0,1.0/) ! elem id 1 corner 3
    elemCornerCoords2(:,4)=(/0.0,1.0/) ! elem id 1 corner 4

  else if (localPET .eq. 1) then !!! This part only for PET 1

    ! Set the number of each type of element, plus the total number.
    numQuadElems=0
    numTriElems=2
    numTotElems=numQuadElems+numTriElems
    numElemCorners=4*numQuadElems+3*numTriElems

    ! Allocate and fill the element type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_TRI, &amp; ! elem id 2
                ESMF_MESHELEMTYPE_TRI/)  ! elem id 3

    ! Allocate and fill element corner coordinate array.
    allocate(elemCornerCoords2(2,numElemCorners))
    elemCornerCoords2(:,1)=(/1.0,0.0/) ! elem id 2 corner 1 
    elemCornerCoords2(:,2)=(/2.0,0.0/) ! elem id 2 corner 2
    elemCornerCoords2(:,3)=(/1.0,1.0/) ! elem id 2 corner 3
    elemCornerCoords2(:,4)=(/2.0,0.0/) ! elem id 3 corner 1 
    elemCornerCoords2(:,5)=(/2.0,1.0/) ! elem id 3 corner 2
    elemCornerCoords2(:,6)=(/1.0,1.0/) ! elem id 3 corner 3

  else if (localPET .eq. 2) then !!! This part only for PET 2

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems
    numElemCorners=4*numQuadElems+3*numTriElems


    ! Allocate and fill the element type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 4

    ! Allocate and fill element corner coordinate array.
    allocate(elemCornerCoords2(2,numElemCorners))
    elemCornerCoords2(:,1)=(/0.0,1.0/) ! elem id 4 corner 1 
    elemCornerCoords2(:,2)=(/1.0,1.0/) ! elem id 4 corner 2
    elemCornerCoords2(:,3)=(/1.0,2.0/) ! elem id 4 corner 3
    elemCornerCoords2(:,4)=(/0.0,2.0/) ! elem id 4 corner 4


  else if (localPET .eq. 3) then !!! This part only for PET 3

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems
    numElemCorners=4*numQuadElems+3*numTriElems

    ! Allocate and fill the element type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 5

    ! Allocate and fill element corner coordinate array.
    allocate(elemCornerCoords2(2,numElemCorners))
    elemCornerCoords2(:,1)=(/1.0,1.0/) ! elem id 5 corner 1 
    elemCornerCoords2(:,2)=(/2.0,1.0/) ! elem id 5 corner 2
    elemCornerCoords2(:,3)=(/2.0,2.0/) ! elem id 5 corner 3
    elemCornerCoords2(:,4)=(/1.0,2.0/) ! elem id 5 corner 4

  endif
  
  ! Create Mesh structure in 1 step
  mesh=ESMF_MeshCreate(parametricDim=2, &amp;
         coordSys=ESMF_COORDSYS_CART,   &amp;
         elementTypes=elemTypes, &amp;
         elementCornerCoords=elemCornerCoords2, &amp;
         rc=localrc)


  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(elemTypes)
  deallocate(elemCornerCoords2)

  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for elements owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, ESMF_TYPEKIND_R8, &amp;
       meshloc=ESMF_MESHLOC_ELEMENT, rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103800000000000000"></A>
  <A NAME="sec:example:UnstructFromFile"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Create a Mesh from an unstructured grid file
</H3>

<P>
ESMF supports the creation of a Mesh from three grid file formats: the SCRIP format&nbsp;<A HREF="node3.html#sec:fileformat:scrip">12.8.1</A>, the 
   ESMF format&nbsp;<A HREF="node3.html#sec:fileformat:esmf">12.8.2</A> or the
   proposed CF unstructured grid UGRID format&nbsp;<A HREF="node3.html#sec:fileformat:ugrid">12.8.4</A>.  All three of these grid file formats
   are NetCDF files. 

<P>
When creating a Mesh from a SCRIP format file, there are a number of options to control the output Mesh.
   The data is located at the center of the grid cell in a SCRIP grid; whereas
   the data is located at the corner of a cell in an ESMF Mesh object.  Therefore,
   we create a Mesh object by default by constructing a "dual" mesh using the coordinates in the file. 
   If the user wishes to not construct the dual mesh, the optional argument <TT>convertToDual</TT> may be 
   used to control this behavior. When <TT>comvertToDual</TT> is 
   set to .false. the Mesh constructed from the file will not be the dual. This is necessary when using the 
   Mesh as part of a conservative regridding operation in the <TT>ESMF_FieldRegridStore()</TT> call, so the
   weights are properly generated for the cell centers in the file. 

<P>
The following example code depicts how to create a Mesh using a SCRIP file. Note that
   you have to set the <TT>fileformat</TT> to ESMF_FILEFORMAT_SCRIP.  
<P>
<PRE>
   mesh = ESMF_MeshCreate(filename="data/ne4np4-pentagons.nc", &amp;
        fileformat=ESMF_FILEFORMAT_SCRIP, rc=localrc)
</PRE>

<P>
As mentioned above ESMF also supports creating Meshes from the ESMF format.
   The ESMF format works better with the methods used to create an ESMF Mesh object, so less conversion needs 
   to be done to create a Mesh, and thus this format is more efficient than SCRIP to use within ESMF. 
   The ESMF format is also more general than the SCRIP format because it supports higher dimension coordinates and more general
   topologies.  Currently, ESMF_MeshCreate() does not support conversion to a dual mesh for this format. All regrid methods
   are supported on Meshes in this format. 

<P>
Here is an example of creating a Mesh from an ESMF unstructured grid file. Note that you have to set the <TT>fileformat</TT> to
   ESMF_FILEFORMAT_ESMFMESH.  
<P>
<PRE>
   mesh = ESMF_MeshCreate(filename="data/ne4np4-esmf.nc", &amp;
            fileformat=ESMF_FILEFORMAT_ESMFMESH, &amp;
            rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103900000000000000"></A>
  <A NAME="sec:example:MeshCubedSphere"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Create a Mesh representation of a cubed sphere grid
</H3>

<P>
This example demostrates how to create a <TT>ESMF_Mesh</TT> object representing a cubed sphere grid with
  identical regular decomposition for every tile. 
  In this example, the tile resolution is 45, so there will be a total 45x45x6=12150 elements in the mesh.
  <TT>nx</TT> and <TT>ny</TT> are the regular decomposition of each tile.  
  The total number of DEs is nx x ny x 6. If the number of PETs are less than the total
  number of DEs, the DEs will be distributed to the PETs using the default cyclic distribution.
<P>
<PRE>
   ! Decompose each tile into 2 x 1 blocks
   nx=2
   ny=1

   ! Create Mesh
   mesh = ESMF_MeshCreateCubedSphere(tileSize=45, nx=nx,ny=ny, rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION0501031000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Remove Mesh memory</A>
</H3>

<P>
There are two different levels that the memory in a Mesh can be removed. The first of these is the standard destroy call, 
   <TT>ESMF_MeshDestroy()</TT>. As with other classes, this call removes all memory associated with the object, and afterwards  
   the object can not be used further (i.e. should not be used in any methods). The second, which is unique to Mesh, is the 
   <TT>ESMF_MeshFreeMemory()</TT> call. This call removes the connection and coordinate information associated with the Mesh, but
   leaves the distgrid information. The coordinate and connection information held in the Mesh can consume a large amount of memory
   for a big Mesh, so using this call can very significantly reduce the amount of memory used. However, once this method
   has been used on a Mesh there are some restriction on what may be done with it. Once a Mesh has had its memory freed using this method, 
   any Field built on the Mesh can no longer be used as part of an <TT>ESMF_FieldRegridStore()</TT> call. However, because the distgrid 
   information is still part of the Mesh, Fields built on such a Mesh can still be part of an <TT>ESMF_FieldRegrid()</TT>
   call (where the routehandle was generated previous to the <TT>ESMF_MeshFreeMemory()</TT> operation). Fields may also 
   still be created on these Meshes. The following short piece of code illustrates the use of this call.
  
<P>
<PRE>
   ! Here a Field built on a mesh may be used
   ! as part of a ESMF_FieldRegridStore() call

   ! This call removes connection and coordinate 
   ! information, significantly reducing the memory used by
   ! mesh, but limiting what can be done with it.
   call ESMF_MeshFreeMemory(mesh, rc=localrc)

   ! Here a new Field may be built on mesh, or
   ! a field built on a mesh may be used as part
   ! of an ESMF_FieldRegrid() call

   ! Destroy the mesh
   call ESMF_MeshDestroy(mesh, rc=localrc)

   ! Here mesh can't be used for anything
</PRE>

<P>

<H3><A NAME="SECTION0501031100000000000000"></A><A NAME="sec:mesh:mask"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Mesh Masking
</H3>

<P>
There are two types of masking available in Mesh: node masking and element masking. These both work
   in a similar manner, but vary slightly in the details of setting the mask information during mesh creation. 

<P>
For node masking, the mask information is set using the <TT>nodeMask</TT> argument to either <TT>ESMF_MeshCreate()</TT> or 
   <TT>ESMF_MeshAddNodes()</TT>. When a regrid store method is called (e.g. <TT>ESMF_FieldRegridStore()</TT>) the mask values arguments 
   (<TT>srcMaskValues</TT> and <TT>dstMaskValues</TT>) can 
   then be used to indicate which particular values set in the <TT>nodeMask</TT> array indicate that the node should be masked. For example, when 
   calling <TT>ESMF_FieldRegridStore()</TT> if <TT>dstMaskValues</TT> has been set to 1, then any node in the destination Mesh whose 
   corresponding <TT>nodeMask</TT> value is 1 will be masked out (a node with any other value than 1 will not be masked). 

<P>
For element masking, the mask information is set using the <TT>elementMask</TT> argument to either <TT>ESMF_MeshCreate()</TT> or 
   <TT>ESMF_MeshAddElements()</TT>. In a similar manner to node masking, when a regrid store method is called (e.g. <TT>ESMF_FieldRegridStore()</TT>) 
   the mask values arguments 
   (<TT>srcMaskValues</TT> and <TT>dstMaskValues</TT>) can 
   then be used to indicate which particular values set in the <TT>elementMask</TT> array indicate that the element should be masked. For example, when 
   calling <TT>ESMF_FieldRegridStore()</TT> if <TT>dstMaskValues</TT> has been set to 1, then any element in the destination Mesh whose 
   corresponding <TT>elementMask</TT> value is 1 will be masked out (an element with any other value than 1 will not be masked). 

<P>

<H3><A NAME="SECTION0501031200000000000000"></A>
  <A NAME="sec:mesh:halo"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Mesh Halo Communication
</H3>
  <TABLE  WIDTH="100%">
<TR><TD> 
  <PRE>
  
    2.0   7 ------- 8        [8] ------ 9          
          |         |         |         |
          |    4    |         |    5    |
          |         |         |         |
    1.0  [4] ----- [5]       [5] ----- [6]
          
         0.0       1.0       1.0       2.0
  
             PET 2               PET 3
  
  
    1.0   4 ------- 5        [5] ------ 6
          |         |         |  \   3  |
          |    1    |         |    \    |
          |         |         | 2    \  |
    0.0   1 ------- 2        [2] ------ 3
  
         0.0       1.0       1.0      2.0 
   
             PET 0               PET 1
  
              Node Id labels at corners
             Element Id labels in centers
</PRE></TD></TR>
</TABLE>

<P>
This section illustrates the process of setting up halo communication for a Field built on the nodes of a Mesh.
   The Mesh used in this example is the one that was created in section&nbsp;<A HREF="#sec:mesh:4pet1step">33.3.4</A>. The diagram for 
   that Mesh is repeated above for convenience's sake. The halo method used here is the one described in 
   section&nbsp;<A HREF="#Array:ArbHalo">28.2.16</A>, but made more specific to the case of a Mesh. 
   This example shows how to set up haloing for nodes which are owned by another processor (e.g. the node with id
   5 on PET 1 above). However, it could be expanded to halo other nodes simply by including them in the 
   halo arrays below on the PET where their values are needed. 

<P>
The first step in setting up the halo communication is to create arrays containing 
   the ids of the haloed nodes on the PETs where they 
   are needed. 

<P>
The following illustrates that for the Mesh diagramed above. 
   
<P>
<PRE>
  ! Create halo lists based on PET id.
  if (localPET .eq. 0) then !!! This part only for PET 0

    ! Allocate and fill the halo list.
    allocate(haloSeqIndexList(0))  ! There are no haloed points on PET 0

  else if (localPET .eq. 1) then !!! This part only for PET 1

    ! Allocate and fill the halo list.
    allocate(haloSeqIndexList(2)) 
    haloSeqIndexList=(/2,5/)

  else if (localPET .eq. 2) then !!! This part only for PET 2

    ! Allocate and fill the halo list.
    allocate(haloSeqIndexList(2)) 
    haloSeqIndexList=(/4,5/)

  else if (localPET .eq. 3) then !!! This part only for PET 3

    ! Allocate and fill the halo list.
    allocate(haloSeqIndexList(3)) 
    haloSeqIndexList=(/5,6,8/)

  endif
</PRE>

<P>
The next step is to create an ESMF Array with a halo region to hold the data being haloed. 
  
<P>
<PRE>
  ! Get node DistGrid from the Mesh. 
  call ESMF_MeshGet(mesh, nodalDistgrid=nodeDistgrid, rc=localrc)

  ! Create an ESMF Array with a halo region from a node DistGrid.
  array=ESMF_ArrayCreate(nodeDistgrid, typekind=ESMF_TYPEKIND_R8, &amp;
       haloSeqIndexList=haloSeqIndexList, rc=localrc)
</PRE>

<P>
Note that currently the halo data is stored at the end of the Array data on each PET in the order specified
   by the haloSeqIndexList argument (e.g. for PET 3 the halo information will be in the order 5,6,8 
   at the end of the piece of array on PET 3). This means that if the halo information needs to be in the order of    
   nodes specified when you create the Mesh, then the nodes owned by another processor need to 
   be at the end of the node information when the Mesh is created (e.g. when creating
   the piece of the Mesh on PET 3, then nodes 5,6,8 would need to be at the end of the node information lists).

<P>
At this point haloing could be done on the ESMF Array by using the <TT>ESMF_ArrayHaloStore()</TT> call
   followed by <TT>ESMF_ArrayHalo()</TT>. However, in this example we wrap the Array in an ESMF Field. 
   This allows it to be used in Field specific calls (e.g. <TT>ESMF_FieldRegridStore()</TT>) as well
   as for haloing. 
 
<P>
<PRE>
  ! Wrap the ESMF Array in a Field created on the nodes of the Mesh. 
  field=ESMF_FieldCreate(mesh, array=array, &amp;
       meshLoc=ESMF_MESHLOC_NODE, rc=localrc)
</PRE>

<P>
We can now proceed with haloing the Field by using the <TT>ESMF_FieldHaloStore()</TT> call to 
   create a RouteHandle, and then the <TT>ESMF_FieldHalo()</TT> call to apply the RouteHandle. Note 
   that once the RouteHandle has been created it can be applied repeatedly to redo the halo 
   communication as data changes in the Field. 
  
<P>
<PRE>
  ! Create the RouteHandle for the halo communication.
  call ESMF_FieldHaloStore(field, routehandle=haloHandle, rc=localrc)

  ! Can repeatedly do halo as data in field changes.
  ! do t=...
 
    ! Data set in non-halo field locations. 

    ! Do the halo communication.
    call ESMF_FieldHalo(field, routehandle=haloHandle, rc=localrc)

    ! Halo locations now filled in field.

  ! enddo 

  ! After its last use the RouteHandle can be released.
  call ESMF_FieldHaloRelease(haloHandle, rc=localrc)
</PRE>

<P>
<PRE>
  ! The Field can now be destroyed.
  call ESMF_FieldDestroy(field, rc=localrc)

  ! The Array can now be destroyed.
  call ESMF_ArrayDestroy(array, rc=localrc)
</PRE>

<P>


<H2><A NAME="SECTION050104000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050104100000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_MeshAssignment(=) - Mesh assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     mesh1 = mesh2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh) :: mesh1
     type(ESMF_Mesh) :: mesh2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign mesh1 as an alias to the same ESMF Mesh object in memory
     as mesh2. If mesh2 is invalid, then mesh1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>mesh1</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>mesh2</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104200000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_MeshOperator(==) - Mesh equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    interface operator(==)
     if (mesh1 == mesh2) then ... endif
               OR
     result = (mesh1 == mesh2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh1
     type(ESMF_Mesh), intent(in) :: mesh2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether mesh1 and mesh2 are valid aliases to the same ESMF
     Mesh object in memory. For a more general comparison of two ESMF Meshes,
     going beyond the simple alias test, the ESMF_MeshMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>mesh1</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>mesh2</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104300000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_MeshOperator(/=) - Mesh not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (mesh1 /= mesh2) then ... endif
               OR
     result = (mesh1 /= mesh2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh1
     type(ESMF_Mesh), intent(in) :: mesh2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether mesh1 and mesh2 are <I>not</I> valid aliases to the
     same ESMF Mesh object in memory. For a more general comparison of two ESMF
     Meshes, going beyond the simple alias test, the ESMF_MeshMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>mesh1</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>mesh2</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104400000000000000"></A><A NAME="sec:mesh:api:meshaddelements"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_MeshAddElements - Add elements to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_MeshAddElements(mesh, elementIds, elementTypes, &amp;
                  elementConn, elementMask, elementArea, elementCoords, &amp;
                  elementDistgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh),    intent(inout)         :: mesh
     integer,            intent(in)            :: elementIds(:)
     integer,            intent(in)            :: elementTypes(:)
     integer,            intent(in)            :: elementConn(:)
     integer,            intent(in),  optional :: elementMask(:)
     real(ESMF_KIND_R8), intent(in),  optional :: elementArea(:)
     real(ESMF_KIND_R8), intent(in),  optional :: elementCoords(:)
     type(ESMF_DistGrid), intent(in), optional :: elementDistgrid
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call is the third and last part of the three part mesh create
     sequence and should be called after the mesh is created with <TT>ESMF_MeshCreate()</TT>
     (<A HREF="#sec:mesh:api:meshcreate">33.4.6</A>)
     and after the nodes are added with <TT>ESMF_MeshAddNodes()</TT> (<A HREF="#sec:mesh:api:meshaddnodes">33.4.5</A>).
     This call adds the elements to the
     mesh and finalizes the create. After this call the Mesh is usable, for
     example a Field may be built on the created Mesh object and
     this Field may be used in a <TT>ESMF_FieldRegridStore()</TT> call.

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementConn</TT> describe the elements to be created. The description
     for a particular element lies at the same index location in <TT>elementIds</TT>
     and <TT>elementTypes</TT>. Each entry in <TT>elementConn</TT> consists of the list of
     nodes used to create that element, so the connections for element <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img96.png"
 ALT="$e$"></SPAN> in the
     <TT>elementIds</TT> array will start at <!-- MATH
 $number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
     \cdots + number\_of\_nodes\_in\_element(e-1) + 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="840" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img97.png"
 ALT="$number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
\cdots + number\_of\_nodes\_in\_element(e-1) + 1$"></SPAN> in <TT>elementConn</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>elementIds</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET.
            This input consists of a 1D array the size of the number of elements on this PET.
            Each element id must be a number equal to or greater than 1. An id should be
            unique in the sense that different elements must have different ids (the same element
            that appears on different processors must have the same id). There may be gaps in the sequence
            of ids, but if these gaps are the same scale as the length of the sequence it can lead to
            inefficiencies when the Mesh is used (e.g. in <TT>ESMF_FieldRegridStore()</TT>).
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for the list of options. This input consists of
            a 1D array the size of the number of elements on this PET.
     
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids,
           but rather each entry is a local index (1 based) into the list of nodes which were
           created on this PET by the previous <TT>ESMF_MeshAddNodes()</TT> call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. passed into the
           <TT>ESMF_MeshAddNodes()</TT> call on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with
           a total size equal to the sum of the number of nodes in each element on
           this PET. The number of nodes in each element is implied by its element type in
           <TT>elementTypes</TT>. The nodes for each element
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.).
     
</DD>
<DT><STRONG>[elementMask]</STRONG></DT>
<DD>An array containing values which can be used for element masking. Which values indicate
            masking are chosen via the <TT>srcMaskValues</TT> or <TT>dstMaskValues</TT> arguments to
            <TT>ESMF_FieldRegridStore()</TT> call. This input consists of a 1D array the
            size of the number of elements on this PET.
     
</DD>
<DT><STRONG>[elementArea]</STRONG></DT>
<DD>An array containing element areas. If not specified, the element areas are internally calculated.
            This input consists of a 1D array the size of the number of elements on this PET.
            <B>NOTE:</B> ESMF doesn't currently do unit conversion on areas. If these areas are going to be used
                  in a process that also involves the areas of another Grid or Mesh (e.g. conservative regridding), then
                  it is the user's responsibility to make sure that the area units are consistent between the two sides.
                  If ESMF calculates an area on the surface of a sphere, then it is in units of square radians. If
                  it calculates the area for a Cartesian grid, then it is in the same units as the coordinates, but squared.
     
</DD>
<DT><STRONG>[elementCoords]</STRONG></DT>
<DD>An array containing the physical coordinates of the elements to be created on this
            PET. This input consists of a 1D array the size of the number of elements on this PET times the Mesh's
            spatial dimension. The coordinates in this array are ordered
            so that the coordinates for an element lie in sequence in memory. (e.g. for a
            Mesh with spatial dimension 2, the coordinates for element 1 are in elementCoords(1) and
            elementCoords(2), the coordinates for element 2 are in elementCoords(3) and elementCoords(4),
            etc.).
     
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>If present, use this as the element Distgrid for the Mesh.
            The passed in Distgrid
            needs to contain a local set of sequence indices matching the set of local element ids (i.e. those in <TT>elementIds</TT>).
            However, specifying an externally created Distgrid gives the user more control over aspects of
            the Distgrid containing those sequence indices (e.g. how they are broken into DEs).
            If not present, a 1D Distgrid will be created internally consisting of one DE per PET.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104500000000000000"></A><A NAME="sec:mesh:api:meshaddnodes"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_MeshAddNodes - Add nodes to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_MeshAddNodes(mesh, nodeIds, nodeCoords, nodeOwners, &amp;
                                  nodeMask, nodalDistgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh),    intent(inout)         :: mesh
     integer,            intent(in)            :: nodeIds(:)
     real(ESMF_KIND_R8), intent(in)            :: nodeCoords(:)
     integer,            intent(in),  optional :: nodeOwners(:)
     integer,            intent(in),  optional :: nodeMask(:)
     type(ESMF_DistGrid), intent(in), optional :: nodalDistgrid
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call is the second part of the three part mesh create
     sequence and should be called after the mesh's dimensions are set
     using <TT>ESMF_MeshCreate()</TT> (<A HREF="#sec:mesh:api:meshcreate">33.4.6</A>).
     This call adds the nodes to the
     mesh. The next step is to call <TT>ESMF_MeshAddElements()</TT> (<A HREF="#sec:mesh:api:meshaddelements">33.4.4</A>).

<P>
The parameters to this call <TT>nodeIds</TT>, <TT>nodeCoords</TT>, and
     <TT>nodeOwners</TT> describe the nodes to be created on this PET.
     The description for a particular node lies at the same index location in
     <TT>nodeIds</TT> and <TT>nodeOwners</TT>. Each entry
     in <TT>nodeCoords</TT> consists of spatial dimension coordinates, so the coordinates
     for node <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img98.png"
 ALT="$n$"></SPAN> in the <TT>nodeIds</TT> array will start at <!-- MATH
 $(n-1)*spatialDim+1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="177" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img99.png"
 ALT="$(n-1)*spatialDim+1$"></SPAN>.

<P>
<DL>
<DT><STRONG>nodeIds</STRONG></DT>
<DD>An array containing the global ids of the nodes to be created on this PET.
           This input consists of a 1D array the size of the number of nodes on this PET.
            Each node id must be a number equal to or greater than 1. An id should be
            unique in the sense that different nodes must have different ids (the same node
            that appears on different processors must have the same id). There may be gaps in the sequence
            of ids, but if these gaps are the same scale as the length of the sequence it can lead to
            inefficiencies when the Mesh is used (e.g. in <TT>ESMF_FieldRegridStore()</TT>).
     
</DD>
<DT><STRONG>nodeCoords</STRONG></DT>
<DD>An array containing the physical coordinates of the nodes to be created on this
            PET. This input consists of a 1D array the size of the number of nodes on this PET times the Mesh's
            spatial dimension (<TT>spatialDim</TT>). The coordinates in this array are ordered
            so that the coordinates for a node lie in sequence in memory. (e.g. for a
            Mesh with spatial dimension 2, the coordinates for node 1 are in nodeCoords(1) and
            nodeCoords(2), the coordinates for node 2 are in nodeCoords(3) and nodeCoords(4),
            etc.).
     
</DD>
<DT><STRONG>[nodeOwners]</STRONG></DT>
<DD>An array containing the PETs that own the nodes to be created on this PET.
           If the node is shared with another PET, the value
           may be a PET other than the current one. Only nodes owned by this PET
           will have PET local entries in a Field created on the Mesh. This input consists of
           a 1D array the size of the number of nodes on this PET. If not provided by the user, 
           then ESMF will calculate node ownership. 
     
</DD>
<DT><STRONG>[nodeMask]</STRONG></DT>
<DD>An array containing values which can be used for node masking. Which values indicate
            masking are chosen via the <TT>srcMaskValues</TT> or <TT>dstMaskValues</TT> arguments to
            <TT>ESMF_FieldRegridStore()</TT> call. This input consists of a 1D array the
            size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>[nodalDistgrid]</STRONG></DT>
<DD>If present, use this as the node Distgrid for the Mesh.
            The passed in Distgrid
            needs to contain a local set of sequence indices matching the set of local node ids (i.e. the ids in
            <TT>nodeIds</TT> with <TT>nodeOwners</TT> equal to the current PET).
            However, specifying an externally created Distgrid gives the user more control over aspects of
            the Distgrid containing those sequence indices (e.g. how they are broken into DEs).
            If not present, a 1D Distgrid will be created internally consisting of one DE per PET.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104600000000000000"></A><A NAME="sec:mesh:api:meshcreate"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_MeshCreate - Create a Mesh as a 3 step process 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreate3Part(parametricDim, spatialDim, coordSys, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)                                 :: ESMF_MeshCreate3Part
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                  intent(in)            :: parametricDim
     integer,                  intent(in)            :: spatialDim
     type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
     character(len=*),         intent(in),  optional :: name
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call is the first part of the three part mesh create
     sequence. This call sets the dimension of the elements in the mesh
     (<TT>parametricDim</TT>) and the number of coordinate dimensions in the mesh
     (<TT>spatialDim</TT>). The next step is to call <TT>ESMF_MeshAddNodes()</TT> (<A HREF="#sec:mesh:api:meshaddnodes">33.4.5</A>)
     to add the nodes and then <TT>ESMF_MeshAddElements()</TT> (<A HREF="#sec:mesh:api:meshaddelements">33.4.4</A>) to add
     the elements and finalize the mesh.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
           have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
           of 3.)
     
</DD>
<DT><STRONG>spatialDim</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes
           making up the Mesh. For a manifold, the spatial dimension can be larger than the
           parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller.
     
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Mesh.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104700000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_MeshCreate - Create a Mesh all at once</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreate1Part(parametricDim, spatialDim, &amp;
                    nodeIds, nodeCoords, nodeOwners, nodeMask, nodalDistgrid, &amp;
                    elementIds, elementTypes, elementConn, &amp;
                    elementMask, elementArea, elementCoords, &amp;
                    elementDistgrid, coordSys, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)                                 :: ESMF_MeshCreate1Part
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                  intent(in)            :: parametricDim
     integer,                  intent(in)            :: spatialDim
     integer,                  intent(in)            :: nodeIds(:)
     real(ESMF_KIND_R8),       intent(in)            :: nodeCoords(:)
     integer,                  intent(in),  optional :: nodeOwners(:)
     integer,                  intent(in),  optional :: nodeMask(:)
     type(ESMF_DistGrid),      intent(in),  optional :: nodalDistgrid
     integer,                  intent(in)            :: elementIds(:)
     integer,                  intent(in)            :: elementTypes(:)
     integer,                  intent(in)            :: elementConn(:)
     integer,                  intent(in),  optional :: elementMask(:)
     real(ESMF_KIND_R8),       intent(in),  optional :: elementArea(:)
     real(ESMF_KIND_R8),       intent(in),  optional :: elementCoords(:)
     type(ESMF_DistGrid),      intent(in),  optional :: elementDistgrid
     type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
     character(len=*),         intent(in),  optional :: name
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a Mesh object in one step. After this call the Mesh is usable, for
     example, a Field may be built on the created Mesh object and
     this Field may be used in a <TT>ESMF_FieldRegridStore()</TT> call.

<P>
This call sets the dimension of the elements in the mesh
     (<TT>parametricDim</TT>) and the number of coordinate dimensions in the mesh
     (<TT>spatialDim</TT>). It then creates the nodes, and
     then creates the elements by connecting together the nodes.

<P>
The parameters to this call <TT>nodeIds</TT>, <TT>nodeCoords</TT>, and
     <TT>nodeOwners</TT> describe the nodes to be created on this PET.
     The description for a particular node lies at the same index location in
     <TT>nodeIds</TT> and <TT>nodeOwners</TT>. Each entry
     in <TT>nodeCoords</TT> consists of spatial dimension coordinates, so the coordinates
     for node <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img98.png"
 ALT="$n$"></SPAN> in the <TT>nodeIds</TT> array will start at <!-- MATH
 $(n-1)*spatialDim+1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="177" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img99.png"
 ALT="$(n-1)*spatialDim+1$"></SPAN>.

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementConn</TT> describe the elements to be created. The description
     for a particular element lies at the same index location in <TT>elementIds</TT>
     and <TT>elementTypes</TT>. Each entry in <TT>elementConn</TT> consists of the list of
     nodes used to create that element, so the connections for element <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img96.png"
 ALT="$e$"></SPAN> in the
     <TT>elementIds</TT> array will start at <!-- MATH
 $number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
     \cdots + number\_of\_nodes\_in\_element(e-1) + 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="840" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img97.png"
 ALT="$number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
\cdots + number\_of\_nodes\_in\_element(e-1) + 1$"></SPAN> in <TT>elementConn</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
           have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
           of 3.)
     
</DD>
<DT><STRONG>spatialDim</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes
           making up the Mesh. For a manifold, the spatial dimension can be larger than the
           parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller.
     
</DD>
<DT><STRONG>nodeIds</STRONG></DT>
<DD>An array containing the global ids of the nodes to be created on this PET.
           This input consists of a 1D array the size of the number of nodes on this PET.
            Each node id must be a number equal to or greater than 1. An id should be
            unique in the sense that different nodes must have different ids (the same node
            that appears on different processors must have the same id). There may be gaps in the sequence
            of ids, but if these gaps are the same scale as the length of the sequence it can lead to
            inefficiencies when the Mesh is used (e.g. in <TT>ESMF_FieldRegridStore()</TT>).
     
</DD>
<DT><STRONG>nodeCoords</STRONG></DT>
<DD>An array containing the physical coordinates of the nodes to be created on this
            PET. This input consists of a 1D array the size of the number of nodes on this PET times the Mesh's
            spatial dimension (<TT>spatialDim</TT>). The coordinates in this array are ordered
            so that the coordinates for a node lie in sequence in memory. (e.g. for a
            Mesh with spatial dimension 2, the coordinates for node 1 are in nodeCoords(1) and
            nodeCoords(2), the coordinates for node 2 are in nodeCoords(3) and nodeCoords(4),
            etc.).
     
</DD>
<DT><STRONG>[nodeOwners]</STRONG></DT>
<DD>An array containing the PETs that own the nodes to be created on this PET.
           If the node is shared with another PET, the value
           may be a PET other than the current one. Only nodes owned by this PET
           will have PET local entries in a Field created on the Mesh. This input consists of
           a 1D array the size of the number of nodes on this PET. If not provided by the user, 
           then ESMF will calculate node ownership. 
     
</DD>
<DT><STRONG>[nodeMask]</STRONG></DT>
<DD>An array containing values which can be used for node masking. Which values indicate
            masking are chosen via the <TT>srcMaskValues</TT> or <TT>dstMaskValues</TT> arguments to
            <TT>ESMF_FieldRegridStore()</TT> call. This input consists of a 1D array the
            size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>[nodalDistgrid]</STRONG></DT>
<DD>If present, use this as the node Distgrid for the Mesh.
            The passed in Distgrid
            needs to contain a local set of sequence indices matching the set of local node ids (i.e. the ids in
            <TT>nodeIds</TT> with <TT>nodeOwners</TT> equal to the current PET).
            However, specifying an externally created Distgrid gives the user more control over aspects of
            the Distgrid containing those sequence indices (e.g. how they are broken into DEs).
            If not present, a 1D Distgrid will be created internally consisting of one DE per PET.
     
</DD>
<DT><STRONG>elementIds</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET.
            This input consists of a 1D array the size of the number of elements on this PET.
            Each element id must be a number equal to or greater than 1. An id should be
            unique in the sense that different elements must have different ids (the same element
            that appears on different processors must have the same id). There may be gaps in the sequence
            of ids, but if these gaps are the same scale as the length of the sequence it can lead to
            inefficiencies when the Mesh is used (e.g. in <TT>ESMF_FieldRegridStore()</TT>).
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for the list of options. This input consists of
            a 1D array the size of the number of elements on this PET.
     
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids,
           but rather each entry is a local index (1 based) into the list of nodes to be
           created on this PET by this call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with
           a total size equal to the sum of the number of nodes contained in each element on
           this PET. The number of nodes in each element is implied by its element type in
           <TT>elementTypes</TT>. The nodes for each element
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.).
     
</DD>
<DT><STRONG>[elementMask]</STRONG></DT>
<DD>An array containing values which can be used for element masking. Which values indicate
            masking are chosen via the <TT>srcMaskValues</TT> or <TT>dstMaskValues</TT> arguments to
            <TT>ESMF_FieldRegridStore()</TT> call. This input consists of a 1D array the
            size of the number of elements on this PET.
     
</DD>
<DT><STRONG>[elementArea]</STRONG></DT>
<DD>An array containing element areas. If not specified, the element areas are internally calculated.
            This input consists of a 1D array the size of the number of elements on this PET.
            <B>NOTE:</B> ESMF doesn't currently do unit conversion on areas. If these areas are going to be used
                  in a process that also involves the areas of another Grid or Mesh (e.g. conservative regridding), then
                  it is the user's responsibility to make sure that the area units are consistent between the two sides.
                  If ESMF calculates an area on the surface of a sphere, then it is in units of square radians. If
                  it calculates the area for a Cartesian grid, then it is in the same units as the coordinates, but squared.
     
</DD>
<DT><STRONG>[elementCoords]</STRONG></DT>
<DD>An array containing the physical coordinates of the elements to be created on this
            PET. This input consists of a 1D array the size of the number of elements on this PET times the Mesh's
            spatial dimension (<TT>spatialDim</TT>). The coordinates in this array are ordered
            so that the coordinates for an element lie in sequence in memory. (e.g. for a
            Mesh with spatial dimension 2, the coordinates for element 1 are in elementCoords(1) and
            elementCoords(2), the coordinates for element 2 are in elementCoords(3) and elementCoords(4),
            etc.).
     
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>If present, use this as the element Distgrid for the Mesh.
            The passed in Distgrid
            needs to contain a local set of sequence indices matching the set of local element ids (i.e. those in <TT>elementIds</TT>).
            However, specifying an externally created Distgrid gives the user more control over aspects of
            the Distgrid containing those sequence indices (e.g. how they are broken into DEs).
            If not present, a 1D Distgrid will be created internally consisting of one DE per PET.
     
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Mesh.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104800000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_MeshCreate - Create a Mesh from a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreateFromGrid(grid, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)         :: ESMF_MeshCreateFromGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid),        intent(in)            :: grid
     character(len=*),       intent(in),  optional :: name
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an ESMF Mesh from an ESMF Grid. This method creates the elements of
    the Mesh from the cells of the Grid, and the nodes of the Mesh from the corners of
    the Grid. Corresponding locations in the Grid and new Mesh will have the same
    coordinates, sequence indices, masking, and area information.

<P>
This method currently only works for 2D Grids. In addition, this method requires
     the input Grid to have coordinates in the corner stagger location.

<P>
<DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The ESMF Grid from which to create the Mesh.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Mesh.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>
<A NAME="API:MeshCreateFromFile"></A>
<H3><A NAME="SECTION050104900000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_MeshCreate - Create a Mesh from a file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreateFromFile(filename, fileformat, &amp;
                  convertToDual, addUserArea, maskFlag, varname, &amp;
                  nodalDistgrid, elementDistgrid, &amp;
                  coordSys, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)         :: ESMF_MeshCreateFromFile
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),           intent(in)            :: filename
     type(ESMF_FileFormat_Flag), intent(in)            :: fileformat
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                    intent(in),  optional :: convertToDual
     logical,                    intent(in),  optional :: addUserArea
     type(ESMF_MeshLoc),         intent(in),  optional :: maskFlag
     character(len=*),           intent(in),  optional :: varname
     type(ESMF_DistGrid),        intent(in),  optional :: nodalDistgrid
     type(ESMF_DistGrid),        intent(in),  optional :: elementDistgrid
     type(ESMF_CoordSys_Flag),   intent(in),  optional :: coordSys
     character(len=*),           intent(in),  optional :: name
     integer,                    intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a Mesh from a file. Provides options to convert to 3D and in the case of SCRIP
     format files, allows the dual of the mesh to be created.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The name of the grid file
     
</DD>
<DT><STRONG>fileformat</STRONG></DT>
<DD>The file format. The valid options are <TT>ESMF_FILEFORMAT_SCRIP</TT>, <TT>ESMF_FILEFORMAT_ESMFMESH</TT> and
           <TT>ESMF_FILEFORMAT_UGRID</TT>.
           Please see Section&nbsp;<A HREF="node9.html#const:fileformatflag">54.19</A> for a detailed description of the options.
     
</DD>
<DT><STRONG>[convertToDual]</STRONG></DT>
<DD>if <TT>.true.</TT>, the mesh will be converted to its dual. If not specified,
           defaults to <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[addUserArea]</STRONG></DT>
<DD>if <TT>.true.</TT>, the cell area will be read in from the GRID file.  This feature is
           only supported when the grid file is in the SCRIP or ESMF format. If not specified,
           defaults to <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[maskFlag]</STRONG></DT>
<DD>If maskFlag is present, generate the mask using the missing_value attribute defined in 'varname'
           This flag is only supported when the grid file is in the UGRID format.
           The value could be either <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>.  If the value is
           <TT>ESMF_MESHLOC_NODE</TT>, the node mask will be generated and the variable has to be
           defined on the "node" (specified by its <TT>location</TT> attribute).  If the value is
           <TT>ESMF_MESHLOC_ELEMENT</TT>, the element mask will be generated and the variable has to be
           defined on the "face" of the mesh.  If the variable is not defined on the right location,
           no mask will be generated.  If not specified, no mask will be generated.
     
</DD>
<DT><STRONG>[varname]</STRONG></DT>
<DD>If maskFlag is present, provide a variable name stored in the UGRID file and
           the mask will be generated using the missing value of the data value of
           this variable.  The first two dimensions of the variable has to be the
           the longitude and the latitude dimension and the mask is derived from the
           first 2D values of this variable even if this data is 3D, or 4D array. If not
           specified, defaults to empty string.
     
</DD>
<DT><STRONG>[nodalDistgrid]</STRONG></DT>
<DD>A Distgrid describing the user-specified distribution of
           the nodes across the PETs.
     
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>A Distgrid describing the user-specified distribution of
           the elements across the PETs.
     
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system in which to store the mesh coordinate data.
           If this setting doesn't match the coordinate system in the file, then
           the coordinates in the file will be converted to this system during mesh
           creation. It is currently an error to convert Cartesian file coordinates
           into a spherical coordinate system.  
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified, then defaults to the coordinate system in the file.  
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Mesh.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_MeshCreate - Create a copy of a Mesh with a new distribution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreateRedist(mesh, nodalDistgrid, &amp;
       elementDistgrid, vm, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)                            :: ESMF_MeshCreateRedist
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh),          intent(in)            :: mesh
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DistGrid),      intent(in),  optional :: nodalDistgrid
     type(ESMF_DistGrid),      intent(in),  optional :: elementDistgrid
     type(ESMF_VM),            intent(in),  optional :: vm
     character(len=*),         intent(in),  optional :: name
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a copy of an existing Mesh with a new distribution. Information
   in the Mesh such as connections, coordinates, areas, masks, etc. are
   automatically redistributed to the new Mesh. To redistribute
   data in Fields built on the original Mesh create a Field on the new Mesh
    and then use the Field redistribution functionality
   (<TT>ESMF_FieldRedistStore()</TT>, etc.). The equivalent methods
   can also be used for data in FieldBundles.

<P>
<DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>The source Mesh to be redistributed.
    
</DD>
<DT><STRONG>[nodalDistgrid]</STRONG></DT>
<DD>A Distgrid describing the new distribution of
           the nodes across the PETs.
    
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>A Distgrid describing the new distribution of
           the elements across the PETs.
    
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Mesh object is created on the specified
           <TT>ESMF_VM</TT> object. The default is to create on the VM of the
           current context.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Mesh.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041100000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_MeshCreate - Create a Mesh of just one element type using corner coordinates</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function  ESMF_MeshCreateEasyElems1Type(parametricDim, coordSys, &amp;
                    elementIds, elementType, elementCornerCoords, &amp;
                    elementMask, elementArea, elementCoords, &amp;
                    elementDistgrid, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh) :: ESMF_MeshCreateEasyElems1Type
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                  intent(in)            :: parametricDim
     type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
     integer,                  intent(in),  optional :: elementIds(:)
     integer,                  intent(in)            :: elementType
     real(ESMF_KIND_R8),       intent(in)            :: elementCornerCoords(:,:,:)
     integer,                  intent(in),  optional :: elementMask(:)
     real(ESMF_KIND_R8),       intent(in),  optional :: elementArea(:)
     real(ESMF_KIND_R8),       intent(in),  optional :: elementCoords(:,:)
     type(ESMF_DistGrid),      intent(in),  optional :: elementDistgrid
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a Mesh object in one step by just specifying the corner coordinates of each element.
     Internally these corners are turned into nodes forming the outside edges of the elements.
     This call assumes that each element is the same type to make the specification of the elements
     a bit easier.
     After this call the Mesh is usable, for
     example, a Field may be built on the created Mesh object and
     this Field may be used in <TT>ESMF_FieldRegridStore()</TT>. However, the Mesh created by this
     call consists of a set of disconnected elements, and so shouldn't be used in a situation where
     connections between elements are necessary (e.g. bilinear regridding on element centers, patch regridding,
     or second-order conservative regridding). 

<P>
This call sets the dimension of the elements in the Mesh
     via <TT>parametricDim</TT> and the number of coordinate dimensions in the mesh
     is determined from the first dimension of <TT>elementCornerCoords</TT>.

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementCornerCoords</TT> describe the elements to be created. The description
     for a particular element lies at the same index location in <TT>elementIds</TT>
     and <TT>elementTypes</TT>. The argument <TT>elementCornerCoords</TT> contains the coordinates of the
     corners used to create each element. The first dimension of this argument are across the coordinate dimensions.
     The second dimension of this argument is across the corners of a
     particular element. The last dimension of this argument is across the list
     of elements on this PET, so the coordinates of corner c in element e on this PET
     would be in <TT>elementCornerCoords(:,c,e)</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
           have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
           of 3.)
     
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
     
</DD>
<DT><STRONG>[elementIds]</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET.
            This input consists of a 1D array the size of the number of elements on this PET.
            Each element id must be a number equal to or greater than 1. An id should be
            unique in the sense that different elements must have different ids (the same element
            that appears on different processors must have the same id). There may be gaps in the sequence
            of ids, but if these gaps are the same scale as the length of the sequence it can lead to
            inefficiencies when the Mesh is used (e.g. in <TT>ESMF_FieldRegridStore()</TT>).
            If not specified, then elements are numbered in sequence starting with the first element
            on PET 0.
     
</DD>
<DT><STRONG>elementType</STRONG></DT>
<DD>An variable containing the type of the elements to be created in this Mesh. The type used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for the list of options.
     
</DD>
<DT><STRONG>elementCornerCoords</STRONG></DT>
<DD>A 3D array containing the coordinates of the corners of the elements
           to be created on this PET. The first dimension of this array is for the
           coordinates and should be of size 2 or 3. The size of this dimension will be
           used to determine the spatialDim of the Mesh. The second dimension is the number
           of corners for an element. The 3rd dimension is a list of all the elements on this PET.
     
</DD>
<DT><STRONG>[elementMask]</STRONG></DT>
<DD>An array containing values which can be used for element masking. Which values indicate
            masking are chosen via the <TT>srcMaskValues</TT> or <TT>dstMaskValues</TT> arguments to
            <TT>ESMF_FieldRegridStore()</TT> call. This input consists of a 1D array the
            size of the number of elements on this PET.
     
</DD>
<DT><STRONG>[elementArea]</STRONG></DT>
<DD>An array containing element areas. If not specified, the element areas are internally calculated.
            This input consists of a 1D array the size of the number of elements on this PET.
            <B>NOTE:</B> ESMF doesn't currently do unit conversion on areas. If these areas are going to be used
                  in a process that also involves the areas of another Grid or Mesh (e.g. conservative regridding), then
                  it is the user's responsibility to make sure that the area units are consistent between the two sides.
                  If ESMF calculates an area on the surface of a sphere, then it is in units of square radians. If
                  it calculates the area for a Cartesian grid, then it is in the same units as the coordinates, but squared.
     
</DD>
<DT><STRONG>[elementCoords]</STRONG></DT>
<DD>An array containing the physical coordinates of the elements to be created on this
            PET. This input consists of a 2D array with the first dimension that same size as the first dimension of <TT>elementCornerCoords</TT>.
            The second dimension should be the same size as the <TT>elementTypes</TT> argument.
     
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>If present, use this as the element Distgrid for the Mesh.
            The passed in Distgrid
            needs to contain a local set of sequence indices matching the set of local element ids (i.e. those in <TT>elementIds</TT>).
            However, specifying an externally created Distgrid gives the user more control over aspects of
            the Distgrid containing those sequence indices (e.g. how they are broken into DEs).
            If not present, a 1D Distgrid will be created internally consisting of one DE per PET.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041200000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_MeshCreate - Create a Mesh using element corner coordinates</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function  ESMF_MeshCreateEasyElemsGen(parametricDim, coordSys, &amp;
                    elementIds, elementTypes, elementCornerCoords, &amp;
                    elementMask, elementArea, elementCoords, &amp;
                    elementDistgrid, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh) :: ESMF_MeshCreateEasyElemsGen
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                  intent(in)            :: parametricDim
     type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
     integer,                  intent(in),  optional :: elementIds(:)
     integer,                  intent(in)            :: elementTypes(:)
     real(ESMF_KIND_R8),       intent(in)            :: elementCornerCoords(:,:)
     integer,                  intent(in),  optional :: elementMask(:)
     real(ESMF_KIND_R8),       intent(in),  optional :: elementArea(:)
     real(ESMF_KIND_R8),       intent(in),  optional :: elementCoords(:,:)
     type(ESMF_DistGrid),      intent(in),  optional :: elementDistgrid
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a Mesh object in one step by just specifying the corner coordinates of each element.
     Internally these corners are turned into nodes forming the outside edges of the elements.
     After this call the Mesh is usable, for
     example, a Field may be built on the created Mesh object and
     this Field may be used in <TT>ESMF_FieldRegridStore()</TT>. However, the Mesh created by this
     call consists of a set of disconnected elements, and so shouldn't be used in a situation where
     connections between elements are necessary (e.g. bilinear regridding on element centers, patch regridding,
     or second-order conservative regridding). 

<P>
This call sets the dimension of the elements in the Mesh
     via <TT>parametricDim</TT> and the number of coordinate dimensions in the mesh
     is determined from the first dimension of <TT>elementCornerCoords</TT>.

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementCornerCoords</TT> describe the elements to be created. The description
     for a particular element lies at the same index location in <TT>elementIds</TT>
     and <TT>elementTypes</TT>. The argument <TT>elementCornerCoords</TT> consists of a list of
     all the corners used to create all the elements, so the corners for element <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img96.png"
 ALT="$e$"></SPAN> in the
     <TT>elementTypes</TT> array will start at <!-- MATH
 $number\_of\_corners\_in\_element(1)
      + number\_of\_corners\_in\_element(2) +
     \cdots + number\_of\_corners\_in\_element(e-1) + 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="882" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img100.png"
 ALT="$number\_of\_corners\_in\_element(1)
+ number\_of\_corners\_in\_element(2) +
\cdots + number\_of\_corners\_in\_element(e-1) + 1$"></SPAN> in <TT>elementCornerCoords</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
           have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
           of 3.)
     
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
           For a full list of options, please see Section&nbsp;<A HREF="node9.html#const:coordsys">54.11</A>.
           If not specified then defaults to ESMF_COORDSYS_SPH_DEG.
     
</DD>
<DT><STRONG>[elementIds]</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET.
            This input consists of a 1D array the size of the number of elements on this PET.
            Each element id must be a number equal to or greater than 1. An id should be
            unique in the sense that different elements must have different ids (the same element
            that appears on different processors must have the same id). There may be gaps in the sequence
            of ids, but if these gaps are the same scale as the length of the sequence it can lead to
            inefficiencies when the Mesh is used (e.g. in <TT>ESMF_FieldRegridStore()</TT>).
            If not specified, then elements are numbered in sequence starting with the first element
            on PET 0.
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for the list of options. This input consists of
            a 1D array the size of the number of elements on this PET.
     
</DD>
<DT><STRONG>elementCornerCoords</STRONG></DT>
<DD>A 2D array containing the coordinates of the corners of the elements
           to be created on this PET. The first dimension of this array is for the
           coordinates and should be of size 2 or 3. The size of this dimension will be
           used to determine the spatialDim of the Mesh. The second dimension is a collapsed
           list of all the corners in all the elements. The list of corners has been collapsed
           to 1D to enable elements with different number of corners to be supported in the
           same list without wasting space.
           The number of corners in each element is implied by its element type in
           <TT>elementTypes</TT>. The corners for each element
           are in sequence in this array (e.g. If element 1 has 3 corners then they are in elementCornerCoords(:,1),
           elementCornerCoords(:,2), elementCornerCoords(:,3) and the corners for the next element start in elementCornerCoords(:,4)).
     
</DD>
<DT><STRONG>[elementMask]</STRONG></DT>
<DD>An array containing values which can be used for element masking. Which values indicate
            masking are chosen via the <TT>srcMaskValues</TT> or <TT>dstMaskValues</TT> arguments to
            <TT>ESMF_FieldRegridStore()</TT> call. This input consists of a 1D array the
            size of the number of elements on this PET.
     
</DD>
<DT><STRONG>[elementArea]</STRONG></DT>
<DD>An array containing element areas. If not specified, the element areas are internally calculated.
            This input consists of a 1D array the size of the number of elements on this PET.
            <B>NOTE:</B> ESMF doesn't currently do unit conversion on areas. If these areas are going to be used
                  in a process that also involves the areas of another Grid or Mesh (e.g. conservative regridding), then
                  it is the user's responsibility to make sure that the area units are consistent between the two sides.
                  If ESMF calculates an area on the surface of a sphere, then it is in units of square radians. If
                  it calculates the area for a Cartesian grid, then it is in the same units as the coordinates, but squared.
     
</DD>
<DT><STRONG>[elementCoords]</STRONG></DT>
<DD>An array containing the physical coordinates of the elements to be created on this
            PET. This input consists of a 2D array with the first dimension that same size as the first dimension of <TT>elementCornerCoords</TT>.
            The second dimension should be the same size as the <TT>elementTypes</TT> argument.
     
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>If present, use this as the element Distgrid for the Mesh.
            The passed in Distgrid
            needs to contain a local set of sequence indices matching the set of local element ids (i.e. those in <TT>elementIds</TT>).
            However, specifying an externally created Distgrid gives the user more control over aspects of
            the Distgrid containing those sequence indices (e.g. how they are broken into DEs).
            If not present, a 1D Distgrid will be created internally consisting of one DE per PET.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041300000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_MeshCreateCubedSphere - Create a Mesh representation of a cubed sphere grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> function ESMF_MeshCreateCubedSphere(tileSize, nx, ny, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)         :: ESMF_MeshCreateCubedSphere
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                  intent(in)            :: tileSize
     integer,                  intent(in)            :: nx
     integer,                  intent(in)            :: ny
     character(len=*),         intent(in),  optional :: name
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a <TT>ESMF_Mesh</TT> object for a cubed sphere grid using identical regular decomposition for every tile.
     The grid coordinates are generated based on the algorithm used by GEOS-5, The tile resolution is defined by
     <TT>tileSize</TT>.  Each tile is decomposed into nx x ny blocks and the total number of DEs used
     is nx x ny x 6.  If the total PET is not equal to the number of DEs, the DEs are distributed
     into PETs in the default cyclic distribution.  Internally, the nodes and the elements from multiple DEs are
     collapsed into a 1D array.  Therefore, the nodal distgrid or the element distgrid attached to the Mesh object
     is always a one DE arbitrarily distributed distgrid.  The sequential indices of the nodes and the elements
     are derived based on the location of the point in the Cubed Sphere grid.  If an element is located at <TT>(x, y)</TT> of
     tile <TT>n</TT>.  Its sequential index would be <TT>(n-1)*tileSize*tileSize+(y-1)*tileSize+x</TT>.  If it is a node, its
     sequential index would be <TT>(n-1)*(tileSize+1)*(tileSize+1)+(y-1)*(tileSize+1)+x</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>tilesize</STRONG></DT>
<DD>The number of elements on each side of the tile of the Cubed Sphere grid
       
</DD>
<DT><STRONG>nx</STRONG></DT>
<DD>The number of blocks on the horizontal size of each tile
       
</DD>
<DT><STRONG>ny</STRONG></DT>
<DD>The number of blocks on the vertical size of each tile
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Mesh.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041400000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_MeshDestroy - Release resources associated with a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_MeshDestroy(mesh, noGarbage, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)          :: mesh
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,         intent(in),   optional :: noGarbage
     integer,         intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call removes internal memory associated with <TT>mesh</TT>.
    After this call <TT>mesh</TT> will no longer be usable.
  !
  ! The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object to be destroyed.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this 
        condition ESMF cannot protect against accessing the destroyed object 
        through dangling aliases - a situation which may lead to hard to debug 
        application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
        set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use 
        temporary ESMF objects. For situations where the repeated creation and 
        destruction of temporary objects leads to memory issues, it is 
        recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
        removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041500000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_MeshEmptyCreate - Create a Mesh to hold Distgrid information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     function ESMF_MeshEmptyCreate(nodalDistgrid, elementDistgrid, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)         :: ESMF_MeshEmptyCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),      intent(in),  optional :: elementdistgrid
     type(ESMF_DistGrid),      intent(in),  optional :: nodalDistgrid
     character(len=*),         intent(in),  optional :: name
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a Mesh to hold distribution information (i.e. Distgrids).
     Such a mesh will have no coordinate or connectivity information stored.
     Aside from holding distgrids the Mesh created by this call can't be used in other
     ESMF functionality (e.g. it can't be used to create a Field or in regridding).

<P>
<DL>
<DT><STRONG>[nodalDistgrid]</STRONG></DT>
<DD>The nodal distgrid.
     
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>The elemental distgrid.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Mesh.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041600000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_MeshFreeMemory - Remove a Mesh and its memory</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_MeshFreeMemory(mesh, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)        :: mesh
     integer,        intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call removes the portions of <TT>mesh</TT> which contain connection and coordinate
      information. After this call, Fields build on <TT>mesh</TT> will no longer be usable
      as part of an <TT>ESMF_FieldRegridStore()</TT> operation. However, after this call
      Fields built on <TT>mesh</TT> can still be used in an <TT>ESMF_FieldRegrid()</TT>
      operation if the routehandle was generated beforehand. New Fields may also
      be built on <TT>mesh</TT> after this call.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object whose memory is to be freed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041700000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_MeshGet - Get Mesh information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_MeshGet(mesh, parametricDim, spatialDim, &amp;
                    nodeCount, nodeIds, nodeCoords, nodeOwners, &amp;
                    nodeMaskIsPresent, nodeMask,&amp;
                    elementCount, elementIds, elementTypes, &amp;
                    elementConnCount, elementConn, &amp;
                    elementMaskIsPresent,elementMask, &amp;
                    elementAreaIsPresent, elementArea, &amp;
                    elementCoordsIsPresent, elementCoords, &amp;
                    nodalDistgridIsPresent, nodalDistgrid, &amp;
                    elementDistgridIsPresent, elementDistgrid, &amp;
                    numOwnedNodes, ownedNodeCoords, &amp;
                    numOwnedElements, ownedElemCoords, &amp;
                    elemMaskArray, elemAreaArray, &amp;
                    isMemFreed, coordSys, status, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh),          intent(in)            :: mesh
     integer,                  intent(out), optional :: parametricDim
     integer,                  intent(out), optional :: spatialDim
     integer,                  intent(out), optional :: nodeCount
     integer,                  intent(out), optional :: nodeIds(:)
     real(ESMF_KIND_R8),       intent(out), optional :: nodeCoords(:)
     integer,                  intent(out), optional :: nodeOwners(:)
     logical,                  intent(out), optional :: nodeMaskIsPresent
     integer,                  intent(out), optional :: nodeMask(:)
     integer,                  intent(out), optional :: elementCount
     integer,                  intent(out), optional :: elementIds(:)
     integer,                  intent(out), optional :: elementTypes(:)
     integer,                  intent(out), optional :: elementConnCount
     integer,                  intent(out), optional :: elementConn(:)
     logical,                  intent(out), optional :: elementMaskIsPresent
     integer,                  intent(out), optional :: elementMask(:)
     logical,                  intent(out), optional :: elementAreaIsPresent
     real(ESMF_KIND_R8),       intent(out), optional :: elementArea(:)
     logical,                  intent(out), optional :: elementCoordsIsPresent
     real(ESMF_KIND_R8),       intent(out), optional :: elementCoords(:)
     logical,                  intent(out), optional :: nodalDistgridIsPresent
     type(ESMF_DistGrid),      intent(out), optional :: nodalDistgrid
     logical,                  intent(out), optional :: elementDistgridIsPresent
     type(ESMF_DistGrid),      intent(out), optional :: elementDistgrid
     integer,                  intent(out), optional :: numOwnedNodes
     real(ESMF_KIND_R8),       intent(out), optional :: ownedNodeCoords(:)
     integer,                  intent(out), optional :: numOwnedElements
     real(ESMF_KIND_R8),       intent(out), optional :: ownedElemCoords(:)
     logical,                  intent(out), optional :: isMemFreed
     type(ESMF_Array),         intent(inout), optional :: elemMaskArray
     type(ESMF_Array),         intent(inout), optional :: elemAreaArray
     type(ESMF_CoordSys_Flag), intent(out), optional :: coordSys
     type(ESMF_MeshStatus_Flag),intent(out), optional :: status
     character(len=*),         intent(out), optional :: name
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get various information from a mesh.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object to retrieve information from.
   
</DD>
<DT><STRONG>[parametricDim]</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
   have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
   of 3.)
   
</DD>
<DT><STRONG>[spatialDim]</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes
   making up the Mesh. For a manifold, the spatial dimension can be larger than the
   parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller.
   
</DD>
<DT><STRONG>[nodeCount]</STRONG></DT>
<DD>The number of local nodes in the mesh (both owned and shared with another PET).
   
</DD>
<DT><STRONG>[nodeIds]</STRONG></DT>
<DD>An array of ids for each local node in the mesh. The nodeIds array should be of size nodeCount.
   
</DD>
<DT><STRONG>[nodeCoords]</STRONG></DT>
<DD>An array of  coordinates for each local node in the mesh. The nodeCoords array should be of size (spatialDim*nodeCount).
   
</DD>
<DT><STRONG>[nodeOwners]</STRONG></DT>
<DD>An array of the PET numbers that own each local node in the mesh. The nodeOwners array should be of size nodeCount.
   
</DD>
<DT><STRONG>[nodeMaskIsPresent]</STRONG></DT>
<DD>.true. if node masking was set in mesh, .false. otherwise.
   
</DD>
<DT><STRONG>[nodeMask]</STRONG></DT>
<DD>An array of mask values for each local node in the mesh. The nodeOwners array should be of size nodeCount.
   
</DD>
<DT><STRONG>[elementCount]</STRONG></DT>
<DD>The number of local elements in the mesh (both owned and shared with another PET).
   
</DD>
<DT><STRONG>[elementIds]</STRONG></DT>
<DD>An array of ids for each local element in the mesh. The elementIds array should be of size elementCount.
   
</DD>
<DT><STRONG>[elementTypes]</STRONG></DT>
<DD>An array of types for each local element in the mesh. Please see
   section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for the list of options. The elementTypes array should be of size elementCount.
   
</DD>
<DT><STRONG>[elementConnCount]</STRONG></DT>
<DD>The number of entries elementConn array. Provided as a convenience.
   
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids,
           but rather each entry is a local index (1 based) into the list of nodes to be
           created on this PET by this call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with
           a total size equal to the sum of the number of nodes contained in each element on
           this PET (also provided by elementConnCount). The number of nodes in each element 
           is implied by its element type in
           <TT>elementTypes</TT>. The nodes for each element
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.).
   
</DD>
<DT><STRONG>[elementMaskIsPresent]</STRONG></DT>
<DD>.true. if element masking was set in mesh, .false. otherwise.
   
</DD>
<DT><STRONG>[elementMask]</STRONG></DT>
<DD>An array of mask values for each local element in the mesh. The elementMask array should be of size elementCount.
   
</DD>
<DT><STRONG>[elementAreaIsPresent]</STRONG></DT>
<DD>.true. if element areas were set in mesh, .false. otherwise.
   
</DD>
<DT><STRONG>[elementArea]</STRONG></DT>
<DD>An array of area values for each local element in the mesh. The elementArea array should be of size elementCount.
   
</DD>
<DT><STRONG>[elementCoordsIsPresent]</STRONG></DT>
<DD>.true. if element coordinates were set in mesh, .false. otherwise.
   
</DD>
<DT><STRONG>[elementCoords]</STRONG></DT>
<DD>An array of coordinate values for each local element in the mesh. The elementCoord array should be of size (spatialDim*elementCount).
   
</DD>
<DT><STRONG>[nodalDistgridIsPresent]</STRONG></DT>
<DD>.true. if nodalDistgrid was set in Mesh object, .false. otherwise.
   
</DD>
<DT><STRONG>[nodalDistgrid]</STRONG></DT>
<DD>A Distgrid describing the distribution of the nodes across the PETs. Note that
   on each PET the distgrid will only contain entries for nodes owned by that PET.
   This is the DistGrid that would be used to construct the Array in a Field that is constructed
   on <TT>mesh</TT>.
   
</DD>
<DT><STRONG>[elementDistgridIsPresent]</STRONG></DT>
<DD>.true. if elementDistgrid was set in Mesh object, .false. otherwise.
   
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>A Distgrid describing the distribution of elements across the PETs. Note that
   on each PET the distgrid will only contain entries for elements owned by that PET.
   
</DD>
<DT><STRONG>[numOwnedNodes]</STRONG></DT>
<DD>The number of local nodes which are owned by this PET. This is the number of PET local entries in
   the nodalDistgrid.
   
</DD>
<DT><STRONG>[ownedNodeCoords]</STRONG></DT>
<DD>The coordinates for the local nodes. These coordinates will be in the proper order to correspond
   with the nodes in the <TT>nodalDistgrid</TT> returned by this call, and hence with a Field built on
   <TT>mesh</TT>. The size of the input array should be the spatial dim of <TT>mesh</TT> times
   <TT>numOwnedNodes</TT>.
   
</DD>
<DT><STRONG>[numOwnedElements]</STRONG></DT>
<DD>The number of local elements which are owned by this PET. Note that every element is owned by
   the PET it resides on, so unlike for nodes, <TT>numOwnedElements</TT> is identical to the number of elements on
   the PET. It is also the number of PET local entries in the elementDistgrid.
   
</DD>
<DT><STRONG>[ownedElemCoords]</STRONG></DT>
<DD>The center coordinates for the local elements. These coordinates will be in the proper order to correspond
   with the elements in the <TT>elementDistgrid</TT> returned by this call, and hence with a Field built on the
   center of <TT>mesh</TT>. The size of the input array should be the spatial dim of <TT>mesh</TT> times
   <TT>numOwnedElements</TT>.
   
</DD>
<DT><STRONG>[elemMaskArray]</STRONG></DT>
<DD>The mask information for elements put into an ESMF Array. The ESMF Array must be build on a DistGrid which
   matches the elementDistgrid.
   
</DD>
<DT><STRONG>[elemAreaArray]</STRONG></DT>
<DD>The area information for elements put into an ESMF Array. The ESMF Array must be build on a DistGrid which
   matches the elementDistgrid.
   
</DD>
<DT><STRONG>[isMemFreed]</STRONG></DT>
<DD>Indicates if the coordinate and connection memory been freed from <TT>mesh</TT>. If so, it
   can no longer be used as part of an <TT>ESMF_FieldRegridStore()</TT> call.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data.
   
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>Flag indicating the status of the Mesh. Please
      see Section&nbsp;<A HREF="node9.html#const:meshstatus">54.41</A> for the list of options.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Mesh object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041800000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_MeshGetMOAB - Check on status of using MOAB library internally.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_MeshGetMOAB(moabOn, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     logical, intent(out)                      :: moabOn
     integer, intent(out), optional            :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method is only temporary. It was created to enable testing during the stage in ESMF development while
     we have two internal mesh implementations. At some point it will be removed.

<P>
This method can be used to check whether the MOAB library is being used
     to hold the internal structure of the Mesh. When set to .true. the following
     Mesh create calls create a Mesh using MOAB internally. When set to .false. the following
     Mesh create calls use the ESMF native internal mesh respresentation. Note that ESMF Meshes
     created on MOAB are only supported in a limited set of operations and should be used
     with caution as they haven't yet been tested as thoroughly as the native version.
     Also, operations that use a pair of Meshes (e.g. regrid weight generation) are only supported between
     meshes of the same type (e.g. you can regrid between two MOAB meshes, but not between a MOAB and
     a native mesh).

<P>
<DL>
<DT><STRONG>moabOn</STRONG></DT>
<DD>Output variable which indicates current state of MOAB.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041900000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_MeshIsCreated - Check whether a Mesh object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_MeshIsCreated(mesh, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_MeshIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in)            :: mesh
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>mesh</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501042000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_MeshSet - Set some Mesh information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_MeshSet(mesh, &amp;
            elementMask, elementArea, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh),          intent(in)            :: mesh
     integer,                  intent(in), optional :: elementMask(:)
     real(ESMF_KIND_R8),       intent(in), optional :: elementArea(:)
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call allows the user to change the set of information that it's legal to alter after
     a mesh has been created. Currently, this call requires that the information has already
     been added to the mesh during creation. For example, you can only change the element mask
     information, if the mesh was initially created with element masking. 

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>
</DD>
<DT><STRONG>[elementMask]</STRONG></DT>
<DD>An array of mask values for each local element in the mesh. The elementMask array should be of size elementCount.
   
</DD>
<DT><STRONG>[elementArea]</STRONG></DT>
<DD>An array of area values for each local element in the mesh. The elementArea array should be of size elementCount.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501042100000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_MeshSetMOAB - Toggle using the MOAB library internally.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_MeshSetMOAB(moabOn, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     logical, intent(in)                        :: moabOn
     integer, intent(out) , optional            :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method is only temporary. It was created to enable testing during the stage in ESMF development while
     we have two internal mesh implementations. At some point it will be removed.

<P>
This method can be employed to turn on or off using the MOAB library
     to hold the internal structure of the Mesh. When set to .true. the following
     Mesh create calls create a Mesh using MOAB internally. When set to .false. the following
     Mesh create calls use the ESMF native internal mesh respresentation. Note that ESMF Meshes
     created on MOAB are only supported in a limited set of operations and should be used
     with caution as they haven't yet been tested as thoroughly as the native version.
     Also, operations that use a pair of Meshes (e.g. regrid weight generation) are only supported between
     meshes of the same type (e.g. you can regrid between two MOAB meshes, but not between a MOAB and
     a native mesh).

<P>
<DL>
<DT><STRONG>moabOn</STRONG></DT>
<DD>Variable used to turn MOAB on or off
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION050110000000000000000">
<SPAN CLASS="arabic">34</SPAN> XGrid Class</A>
</H1>

<H2><A NAME="SECTION050111000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:xgrid:desc"></A>An exchange grid represents the 2D boundary layer usually between the
atmosphere on one side and ocean and land on the other in an Earth
system model. There are dynamical and thermodynamical processes on
either side of the boundary layer and on the boundary layer itself.
The boundary layer exchanges fluxes from either side and adjusts
boundary conditions for the model components involved. For climate modeling,
it is critical that the fluxes transferred by the boundary layer are
conservative.

<P>
The ESMF exchange grid is implemented as the <TT>ESMF_XGrid</TT> class. 
Internally it's represented by a collection of the intersected cells
between atmosphere and ocean/land[<A
 HREF="node8.html#BalajiXGrid">17</A>] grids. 
These polygonal cells can have irregular shapes
and can be broken down into triangles facilitating a finite element
approach. 

<P>
There are two ways to create an <TT>ESMF_XGrid</TT> object from
user supplied information. The first way to create an <TT>ESMF_XGrid</TT> takes
two lists of <TT>ESMF_Grid</TT> or <TT>ESMF_Mesh</TT> that represent the model component grids on
either side of the exchange grid. From the two lists of <TT>ESMF_Grid</TT> or <TT>ESMF_Mesh</TT>,
information required for flux exchange calculation between any pair of the 
model components from either side of the exchange grid is computed. In addition, the
internal representation of the <TT>ESMF_XGrid</TT> is computed and can be optionally stored
as an <TT>ESMF_Mesh</TT>. This internal representation is the collection of the intersected
polygonal cells as a result of merged <TT>ESMF_Mesh</TT>es from both sides of the exchange grid.
<TT>ESMF_Field</TT> can be created on the <TT>ESMF_XGrid</TT> and used for weight generation
and regridding as the internal representation in the <TT>ESMF_XGrid</TT> has
a complete geometrical description of the exchange grid.

<P>
The second way 
to create an <TT>ESMF_XGrid</TT> requires users to supply all necessary information
to compute communication routehandle. A later
call to <TT>ESMF_FieldRegridStore()</TT> with the xgrid and source and destination
<TT>ESMF_Field</TT>s computes the <TT>ESMF_Routehandle</TT> object for matrix
multiply operation used in model remapping. 

<P>
<TT>ESMF_XGrid</TT> deals with 2 distinctive kinds of fraction for each Grid or Mesh cell
involved in its creation. The following description applies to both <TT>ESMF_Grid</TT> 
and <TT>ESMF_Mesh</TT> involved in the <TT>ESMF_XGrid</TT> creation process.
The first fraction quantity <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img101.png"
 ALT="$f_1$"></SPAN> is the same as defined in direct
Field regrid between a source and destination <TT>ESMF_Field</TT> pair, namely the fraction
of a total Grid cell area <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img102.png"
 ALT="$A$"></SPAN> that is used in weight generation. The second fraction quantity <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img103.png"
 ALT="$f_2$"></SPAN>
is a result of the Grid merging process when multiple <TT>ESMF_Grid</TT>s or model components
exist on one side of the exchange grid. To compute XGrid, the multiple <TT>ESMF_Grid</TT>s
are first merged together to form a super mesh. During the merging process, Grids that are
of a higher priority clips into lower priority Grids, creating fractional cells in the lower
priority Grids. Priority is a mechanism to resolve the claim of a surface region by multiple
Grids. To conserve flux, any surface area can only be claimed by a unique Grid. This is
a typical practice in earth system modelling, e.g. to handle land and ocean boundary.

<P>
In addition to the matrix multiply communication routehandle, 
<TT>ESMF_XGrid</TT> exports both <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img101.png"
 ALT="$f_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img103.png"
 ALT="$f_2$"></SPAN> to the user through the <TT>ESMF_FieldRegridStore()</TT> method
because each remapping pair has different <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img101.png"
 ALT="$f_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img103.png"
 ALT="$f_2$"></SPAN> associated with it. <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img103.png"
 ALT="$f_2$"></SPAN> from source Grid is 
folded directly in the calculated weight matrices since its used to calculate destination point flux
density <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img104.png"
 ALT="$F$"></SPAN>. The global source flux is defined as <!-- MATH
 $\sum_{g=1}^{g=n\_srcgrid}\sum_{s=1}^{s=n\_srccell}{ f_{1s} f_{2s} A_s F_s }$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="266" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img105.png"
 ALT="$\sum_{g=1}^{g=n\_srcgrid}\sum_{s=1}^{s=n\_srccell}{ f_{1s} f_{2s} A_s F_s }$"></SPAN>.
The global destination flux is defined as: 
<!-- MATH
 $\sum_{g=1}^{g=n\_dstgrid}\sum_{d=1}^{d=n\_dstcell}{ \sum_{s=1}^{s=n\_intersect}(w_{sd} F_s) f_{2d} A_d}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="384" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img106.png"
 ALT="$\sum_{g=1}^{g=n\_dstgrid}\sum_{d=1}^{d=n\_dstcell}{ \sum_{s=1}^{s=n\_intersect}(w_{sd} F_s) f_{2d} A_d}$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img107.png"
 ALT="$w_{sd}$"></SPAN> is the
<SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img103.png"
 ALT="$f_2$"></SPAN> modified weight intersecting s-th source Grid cell with d-th destination Grid cell.
It can be proved that this formulation of the fractions and 
weight calculation ensures first order global conservation of
flux <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img108.png"
 ALT="$\mathcal{F}$"></SPAN> transferred from source grids to exchange grid, and from exchange grid to destination grids.

<H2><A NAME="SECTION050112000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION050112100000000000000"></A>
<A NAME="const:xgridside"></A>
<BR>
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_XGRIDSIDE
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>  
Specify which side of the <TT>ESMF_XGrid</TT> the current operation is taking place.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_XGridSide_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_XGRIDSIDE_A</STRONG></DT>
<DD>A side of the eXchange Grid, corresponding to the A side of the Grids used to create an XGrid.
</DD>
<DT><STRONG>ESMF_XGRIDSIDE_B</STRONG></DT>
<DD>B side of the eXchange Grid, corresponding to the B side of the Grids used to create an XGrid.
</DD>
<DT><STRONG>ESMF_XGRIDSIDE_BALANCED</STRONG></DT>
<DD>The internally generated balanced side of the eXchange Grid in the middle.
</DD>
</DL>

<H2><A NAME="SECTION050113000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050113100000000000000"></A>
  <A NAME="sec:xgrid:usage:xgrid_create"></A>
<BR>
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Create an XGrid from Grids then use it for regridding
</H3>

<P>
An <TT>ESMF_XGrid</TT> object can be created from Grids on either side
   of the exchange grid. Internally the
   weight matrices and index mapping are computed and stored in the XGrid, along
   with other necessary information for flux exchange calculation between
   any pair of model components used for the XGrid creation.

<P>
In this example, we create an XGrid from overlapping Grids on
   either side of the XGrid. Then we perform a flux exchange from one side
   to the other side of the XGrid.

<P>
We start by creating the Grids on both sides and associate coordinates with
   the Grids on the corner stagger. The Grids use global indexing and padding
   for coordinates on the corner stagger.

<P>
For details of Grid creation and coordinate use,
   please refer to Grid class documentation: <A HREF="#example:2DRegUniGrid">31.3.2</A>.
<P>
<PRE>
    ! First Grid on side A
    sideA(1) = ESMF_GridCreateNoPeriDim(maxIndex=(/20, 20/), &amp;
      indexflag=ESMF_INDEX_GLOBAL, &amp;
      gridEdgeLWidth=(/0,0/), gridEdgeUWidth=(/1,1/), &amp;
      name='source Grid 1 on side A', rc=localrc)
</PRE>

<P>
<PRE>
    ! Second Grid on side A
    sideA(2) = ESMF_GridCreateNoPeriDim(maxIndex=(/20, 10/), &amp;
      indexflag=ESMF_INDEX_GLOBAL, &amp;
      gridEdgeLWidth=(/0,0/), gridEdgeUWidth=(/1,1/), &amp;
      name='source Grid 2 on side A', rc=localrc)
</PRE>

<P>
<PRE>
    ! Allocate coordinates for Grid corner stagger
    do i = 1, 2
      call ESMF_GridAddCoord(sideA(i), staggerloc=ESMF_STAGGERLOC_CORNER, &amp;
          rc=localrc)
</PRE>

<P>
<PRE>
    enddo
</PRE>

<P>
Assign coordinate for the Grids on sideA at corner stagger.
<P>
<PRE>
    ! SideA first grid spans (0-20, 0-20) with 1.0x1.0 degree resolution
    ! X corner
    call ESMF_GridGetCoord(sideA(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CORNER, coordDim=1, &amp;
        farrayPtr=coordX, rc=localrc)
</PRE>

<P>
<PRE>
    ! Y corner
    call ESMF_GridGetCoord(sideA(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CORNER, coordDim=2, &amp;
        farrayPtr=coordY, rc=localrc)
</PRE>

<P>
<PRE>
    do i = lbound(coordX,1), ubound(coordX,1)
      do j = lbound(coordX, 2), ubound(coordX, 2)
        coordX(i,j) = (i-1)*1.0
        coordY(i,j) = (j-1)*1.0
      enddo
    enddo
</PRE>

<P>
<PRE>
    ! SideA second grid spans (14.3-24.3, 14.2-24.2) with 0.5x1.0 degree
    ! resolution X corner
    call ESMF_GridGetCoord(sideA(2), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CORNER, coordDim=1, &amp;
        farrayPtr=coordX, rc=localrc)
</PRE>

<P>
<PRE>
    ! Y corner
    call ESMF_GridGetCoord(sideA(2), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CORNER, coordDim=2, &amp;
        farrayPtr=coordY, rc=localrc)
</PRE>

<P>
<PRE>
    do i = lbound(coordX,1), ubound(coordX,1)
      do j = lbound(coordX, 2), ubound(coordX, 2)
        coordX(i,j) = 14.3+(i-1)*0.5
        coordY(i,j) = 14.2+(j-1)*1.0
      enddo
    enddo
</PRE>

<P>
Create the destination grid on side B, only one Grid exists on side B. Also associate
   coordinate with the Grid:
<P>
<PRE>
    sideB(1) = ESMF_GridCreateNoPeriDim(maxIndex=(/30, 30/), &amp;
      indexflag=ESMF_INDEX_GLOBAL, &amp;
      gridEdgeLWidth=(/0,0/), gridEdgeUWidth=(/1,1/), &amp;
      name='source Grid 1 on side B', rc=localrc)
</PRE>

<P>
<PRE>
    do i = 1, 1
      call ESMF_GridAddCoord(sideB(i), staggerloc=ESMF_STAGGERLOC_CORNER, &amp;
          rc=localrc)
</PRE>

<P>
<PRE>
    enddo
</PRE>

<P>
<PRE>
    ! SideB grid spans (0-30, 0-30) with 1.0x1.0 degree resolution
    ! X corner
    call ESMF_GridGetCoord(sideB(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CORNER, coordDim=1, &amp;
        farrayPtr=coordX, rc=localrc)
</PRE>

<P>
<PRE>
    ! Y corner
    call ESMF_GridGetCoord(sideB(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CORNER, coordDim=2, &amp;
        farrayPtr=coordY, rc=localrc)
</PRE>

<P>
<PRE>
    do i = lbound(coordX,1), ubound(coordX,1)
      do j = lbound(coordX, 2), ubound(coordX, 2)
        coordX(i,j) = (i-1)*1.0
        coordY(i,j) = (j-1)*1.0
      enddo
    enddo
</PRE>

<P>
Create an <TT>ESMF_XGrid</TT> object from the two lists of Grids on side A and B.
   In this example both Grids on side A overlaps with the Grid on side B. It's an error to have a Grid
   on either side that is spatially disjoint with the XGrid. Neither of the Grid on side A is
   identical to the Grid on side B. Calling the <TT>ESMF_XGridCreate()</TT> method is straightforward:
<P>
<PRE>
    xgrid = ESMF_XGridCreate(sideAGrid=sideA, sideBGrid=sideB, rc=localrc)
</PRE>

<P>
Create an <TT>ESMF_Field</TT> on the XGrid:
<P>
<PRE>
    field = ESMF_FieldCreate(xgrid, typekind=ESMF_TYPEKIND_R8, &amp;
                rc=localrc)
</PRE>

<P>
Query the Field for its Fortran data pointer and its exclusive bounds:
<P>
<PRE>
    call ESMF_FieldGet(field, farrayPtr=xfarrayPtr, &amp;
        exclusiveLBound=xlb, exclusiveUBound=xub, rc=localrc)
</PRE>

<P>
Create src and dst Fields on side A and side B Grids.
<P>
<PRE>
    do i = 1, 2
        srcField(i) = ESMF_FieldCreate(sideA(i), &amp;
                typekind=ESMF_TYPEKIND_R8, rc=localrc)
</PRE>

<P>
<PRE>
    enddo
    do i = 1, 1
        dstField(i) = ESMF_FieldCreate(sideB(i), &amp;
                typekind=ESMF_TYPEKIND_R8, rc=localrc)
</PRE>

<P>
<PRE>
    enddo
</PRE>

<P>
The current implementation requires that Grids used to generate the XGrid
   must not match, i.e. they are different either topologically or geometrically or both.
   In this example, the first source Grid is topologically identical to the destination
   Grid but their geometric coordinates are different.

<P>
First we compute the regrid routehandles, these routehandles can be used repeatedly
   afterwards. Then we initialize the values in the Fields. Finally we execute the Regrid.
  
<P>
<PRE>
    ! Compute regrid routehandles. The routehandles can be used
    ! repeatedly afterwards.
    ! From A -&gt; X
    do i = 1, 2
      call ESMF_FieldRegridStore(xgrid, srcField(i), field, &amp;
        routehandle=rh_src2xgrid(i), rc = localrc)
</PRE>

<P>
<PRE>
    enddo
    ! from X -&gt; B, retrieve the destination fraction Fields.
    do i = 1, 1
      call ESMF_FieldRegridStore(xgrid, field, dstField(i), &amp;
        dstFracField=dstFrac, dstMergeFracField=dstFrac2, &amp;
        routehandle=rh_xgrid2dst(i), rc = localrc)
</PRE>

<P>
<PRE>
    enddo

    ! Initialize values in the source Fields on side A
    do i = 1, 2
      call ESMF_FieldGet(srcField(i), farrayPtr=farrayPtr, rc=localrc)
</PRE>

<P>
<PRE>
      farrayPtr = i
    enddo
    ! Initialize values in the destination Field on XGrid
    xfarrayPtr = 0.0
    ! Initialize values in the destination Field on Side B
    do i = 1, 1
      call ESMF_FieldGet(dstField(i), farrayPtr=farrayPtr, rc=localrc)
</PRE>

<P>
<PRE>
      farrayPtr = 0.0
    enddo
</PRE>

<P>
First we regrid from the Fields on side A to the Field on the XGrid:
<P>
<PRE>
    ! Execute regrid from A -&gt; X
    do i = 1, 2
      call ESMF_FieldRegrid(srcField(i), field, &amp;
        routehandle=rh_src2xgrid(i), &amp;
        zeroregion=ESMF_REGION_SELECT, rc = localrc)
</PRE>

<P>
<PRE>
    enddo
</PRE>

<P>
Next we regrid from the Field on XGrid to the destination Field on side B:
<P>
<PRE>
    ! Execute the regrid store
    do i = 1, 1
      call ESMF_FieldRegrid(field, dstField(i), &amp;
        routehandle=rh_xgrid2dst(i), &amp;
        rc = localrc)
</PRE>

<P>
<PRE>
    enddo
</PRE>

<P>
After the regridding calls, the routehandle can be released by calling the
   <TT>ESMF_FieldRegridRelease()</TT> method.
<P>
<PRE>
    do i = 1, 2
      call ESMF_FieldRegridRelease(routehandle=rh_src2xgrid(i), rc=localrc)
</PRE>

<P>
<PRE>
    enddo
    call ESMF_FieldRegridRelease(routehandle=rh_xgrid2dst(1), rc=localrc)
</PRE>

<P>
In the above example, we first set up all the required parameters to create an XGrid from user
   supplied input. Then we create Fields on the XGrid and the Grids on either side. Finally
   we use the <TT>ESMF_FieldRegrid()</TT> interface to perform a flux exchange from the source side
   to the destination side. 

<P>

<H3><A NAME="SECTION050113200000000000000"></A>
  <A NAME="sec:xgrid:usage:xgrid_create_masking"></A>
<BR>
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Using XGrid in Earth System modeling
</H3>

<P>
A typical application in Earth System Modeling is to calculate flux exchange
   through the planetary boundary layer that can be represented by <TT>ESMF_XGrid</TT>.
   Atmosphere is above the planetary boundary layer while land and ocean are below the boundary layer.
   To create an XGrid, the land and ocean Grids that are usually different in resolution
   need to be merged first to create a super Mesh. This merging process is enabled through the support
   of masking.

<P>
The global land and ocean Grids need to be created with masking enabled.
   In practice, each Grid cell has an integer masking value attached to it. For examples using masking in
   <TT>ESMF_Grid</TT> please refer to section <A HREF="#sec:usage:items">31.3.17</A>.

<P>
When calling the <TT>ESMF_XGridCreate()</TT> method, user can supply the optional arguments
   sideAMaskValues and sideBMaskValues.
   These arguments are one dimensional Fortran integer arrays. If any of the sideAMaskValues entry
   matches the masking value used in sideA Grid, the sideA Grid cell is masked out, vice versa for sideB.
   Thus by specifying different regions of a land and ocean Grids to be masked out, the two global Grids
   can be merged into a new global Mesh covering the entire Earth.

<P>
The following call shows how to use the <TT>ESMF_XGridCreate()</TT> method with the optional
   arguments sideAMaskValues and sideBMaskValues.
  
<P>
<PRE>
    xgrid = ESMF_XGridCreate(sideAGrid=sideA, sideBGrid=sideB, &amp;
      sideAMaskValues=(/2/), sideBMaskValues=(/3,4/), rc=localrc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050113300000000000000"></A>
  <A NAME="sec:xgrid:usage:xgrid_createfromsparsemat"></A>
<BR>
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Create an XGrid from user input data then use it for regridding
</H3>

<P>
Alternatively, XGrid can be created from Grids on either side,
   area and centroid information of XGrid cells, sparse matrix matmul information.
   The functionalities provided by the
   XGrid object is constrained by the user supplied input during its creation time.

<P>
In this example, we will set up a simple XGrid from overlapping Grids on
   either side of the XGrid. Then we perform a flux exchange from one side
   to the other side of the XGrid. The Grids are laid out in the following figure:
  <DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xgridsimple"></A><A NAME="68123"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 20:</STRONG>
Grid layout for simple XGrid creation example. Overlapping of 3 Grids
  (Green 2x2, Red 2x1, Blue 2x2). Green and red Grids on side A, blue Grid on side
  B, black indicates the resulting XGrid. Color coded sequence indices are shown.
  Physical coordinates are the tuples in parenthesis, e.g. at the four
  corners of rectangular computational domain.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.6}{\includegraphics{XGridEx1}}$
 -->
<IMG
 WIDTH="678" HEIGHT="453" ALIGN="BOTTOM" BORDER="0"
 SRC="img109.png"
 ALT="\scalebox{0.6}{\includegraphics{XGridEx1}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
We start by creating the Grids on both sides and associate coordinates with
   the Grids. For details of Grid creation and coordinate use, please refer to
   Grid class documentation.
<P>
<PRE>
    sideA(1) = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/2,2/), &amp;
        coordDep1=(/1/), &amp;
        coordDep2=(/2/), &amp;
        name='source Grid 1 on side A', rc=localrc)
</PRE>

<P>
<PRE>
    sideA(2) = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/2,1/), &amp;
        coordDep1=(/1/), &amp;
        coordDep2=(/2/), &amp;
        name='source Grid 2 on side A', rc=localrc)
</PRE>

<P>
<PRE>
    do i = 1, 2
        call ESMF_GridAddCoord(sideA(i), staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
            rc=localrc)
</PRE>

<P>
<PRE>
    enddo
</PRE>

<P>
Coordinate for the Grids on sideA, refer to the Grid layout diagram for the
   interpretation of the coordinate values:
<P>
<PRE>
    ! SideA first grid
    centroidA1X=(/0.5, 1.5/)
    centroidA1Y=(/0.5, 1.5/)
    call ESMF_GridGetCoord(sideA(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=1, &amp;
        farrayPtr=coordX, rc=localrc)
</PRE>

<P>
<PRE>
    coordX = centroidA1X
    call ESMF_GridGetCoord(sideA(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=2, &amp;
        farrayPtr=coordY, rc=localrc)
</PRE>

<P>
<PRE>
    coordY = centroidA1Y

    ! SideA second grid
    centroidA2X=(/0.5, 1.5/)
    centroidA2Y=(/2.5/)
    call ESMF_GridGetCoord(sideA(2), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=1, &amp;
        farrayPtr=coordX, rc=localrc)
</PRE>

<P>
<PRE>
    coordX = centroidA2X
    call ESMF_GridGetCoord(sideA(2), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=2, &amp;
        farrayPtr=coordY, rc=localrc)
</PRE>

<P>
<PRE>
    coordY = centroidA2Y
</PRE>

<P>
Create the destination grid on side B, only one Grid exists on side B. Also associate
   coordinate with the Grid:
<P>
<PRE>
    sideB(1) = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/2,2/), &amp;
        coordDep1=(/1/), coordDep2=(/2/), &amp;
        name='destination Grid on side B', rc=localrc)
</PRE>

<P>
<PRE>
    do i = 1, 1
        call ESMF_GridAddCoord(sideB(i), staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
            rc=localrc)
</PRE>

<P>
<PRE>
    enddo

    ! SideB grid
    centroidBX=(/0.75, 1.75/)
    centroidBY=(/0.75, 2.25/)
    call ESMF_GridGetCoord(sideB(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=1, farrayPtr=coordX, &amp;
                rc=localrc)
</PRE>

<P>
<PRE>
    coordX = centroidBX
    call ESMF_GridGetCoord(sideB(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=2, farrayPtr=coordY, &amp;
                rc=localrc)
</PRE>

<P>
<PRE>
    coordY = centroidBY
</PRE>

<P>
Set up the mapping indices and weights from A side to the XGrid. For details of
   sequence indices, factorIndexList, and factorList, please see section
   <A HREF="#Array:SparseMatMul">28.2.18</A> in the reference manual. Please refer to the figure above
   for interpretation of the sequence indices used here.

<P>
In order to compute the destination flux on sideB through the XGrid as an mediator,
   we need to set up the factorList (weights) and factorIndexList (indices)
   for sparse matrix multiplication in this formulation:
   dst_flux = W'*W*src_flux, where W' is the weight matrix from the XGrid to
   destination; and W is the weight matrix from source to the XGrid. The weight matrix
   is generated using destination area weighted algorithm. Please refer to figure
   <A HREF="#fig:xgridsimple">20</A> for details.
  
<P>
<PRE>
    ! Set up mapping from A1 -&gt; X
    sparseMatA2X(1)%factorIndexList(1,1)=1    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,2)=2    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,3)=2    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,4)=3    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,5)=4    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,6)=4    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,7)=3    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,8)=4    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,9)=4    ! src seq index (green)

    sparseMatA2X(1)%factorIndexList(2,1)=1    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,2)=2    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,3)=3    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,4)=4    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,5)=5    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,6)=6    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,7)=7    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,8)=8    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,9)=9    ! dst seq index (black)

    ! Set up mapping from A2 -&gt; X
    sparseMatA2X(2)%factorIndexList(1,1)=1    ! src seq index (red)
    sparseMatA2X(2)%factorIndexList(1,2)=2    ! src seq index (red)
    sparseMatA2X(2)%factorIndexList(1,3)=2    ! src seq index (red)

    sparseMatA2X(2)%factorIndexList(2,1)=10   ! dst seq index (black)
    sparseMatA2X(2)%factorIndexList(2,2)=11   ! dst seq index (black)
    sparseMatA2X(2)%factorIndexList(2,3)=12   ! dst seq index (black)
</PRE>

<P>
Set up the mapping weights from side A to the XGrid:
<P>
<PRE>
    ! Note that the weights are dest area weighted, they are ratio
    ! of areas with destination area as the denominator.
    ! Set up mapping weights from A1 -&gt; X
    sparseMatA2X(1)%factorList(:)=1.

    ! Set up mapping weights from A2 -&gt; X
    sparseMatA2X(2)%factorList(:)=1.
</PRE>

<P>
Set up the mapping indices and weights from the XGrid to B side:
<P>
<PRE>
    ! Set up mapping from X -&gt; B
    sparseMatX2B(1)%factorIndexList(1,1)=1    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,2)=2    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,3)=3    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,4)=4    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,5)=5    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,6)=6    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,7)=7    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,8)=8    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,9)=9    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,10)=10  ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,11)=11  ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,12)=12  ! src seq index (black)

    sparseMatX2B(1)%factorIndexList(2,1)=1    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,2)=1    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,3)=2    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,4)=1    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,5)=1    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,6)=2    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,7)=3    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,8)=3    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,9)=4    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,10)=3   ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,11)=3   ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,12)=4   ! dst seq index (blue)

    ! Set up mapping weights from X -&gt; B
    sparseMatX2B(1)%factorList(1)=4./9.
    sparseMatX2B(1)%factorList(2)=2./9.
    sparseMatX2B(1)%factorList(3)=2./3.
    sparseMatX2B(1)%factorList(4)=2./9.
    sparseMatX2B(1)%factorList(5)=1./9.
    sparseMatX2B(1)%factorList(6)=1./3.
    sparseMatX2B(1)%factorList(7)=2./9.
    sparseMatX2B(1)%factorList(8)=1./9.
    sparseMatX2B(1)%factorList(9)=1./3.
    sparseMatX2B(1)%factorList(10)=4./9.
    sparseMatX2B(1)%factorList(11)=2./9.
    sparseMatX2B(1)%factorList(12)=2./3.
</PRE>

<P>
Optionally the area can be setup to compute surface area weighted flux integrals:
<P>
<PRE>
    ! Set up destination areas to adjust weighted flux
    xgrid_area(1) = 1.
    xgrid_area(2) = 0.5
    xgrid_area(3) = 0.5
    xgrid_area(4) = 0.5
    xgrid_area(5) = 0.25
    xgrid_area(6) = 0.25
    xgrid_area(7) = 0.5
    xgrid_area(8) = 0.25
    xgrid_area(9) = 0.25
    xgrid_area(10) = 1.
    xgrid_area(11) = 0.5
    xgrid_area(12) = 0.5
</PRE>

<P>
Create an XGrid based on the user supplied regridding parameters:
<P>
<PRE>
    xgrid = ESMF_XGridCreateFromSparseMat(sideAGrid=sideA, &amp;
        sideBGrid=sideB, area=xgrid_area, &amp;
        centroid=centroid, sparseMatA2X=sparseMatA2X, &amp;
        sparseMatX2B=sparseMatX2B, rc=localrc)
</PRE>

<P>
Create an <TT>ESMF_Field</TT> on the XGrid:
<P>
<PRE>
    field = ESMF_FieldCreate(xgrid, typekind=ESMF_TYPEKIND_R8, &amp;
                rc=localrc)
</PRE>

<P>
Query the Field for its Fortran data pointer and its exclusive bounds:
<P>
<PRE>
    call ESMF_FieldGet(field, farrayPtr=xfarrayPtr, &amp;
        exclusiveLBound=xlb, exclusiveUBound=xub, rc=localrc)
</PRE>

<P>
Setup and initialize src and dst Fields on side A and side B Grids,
   source Fields have different source flux:
<P>
<PRE>
    do i = 1, 2
        srcField(i) = ESMF_FieldCreate(sideA(i), &amp;
                typekind=ESMF_TYPEKIND_R8, rc=localrc)
</PRE>

<P>
<PRE>
        call ESMF_FieldGet(srcField(i), farrayPtr=farrayPtr, rc=localrc)
</PRE>

<P>
<PRE>
        farrayPtr = i
    enddo
    do i = 1, 1
        dstField(i) = ESMF_FieldCreate(sideB(i), &amp;
                typekind=ESMF_TYPEKIND_R8, rc=localrc)
</PRE>

<P>
<PRE>
        call ESMF_FieldGet(dstField(i), farrayPtr=farrayPtr, rc=localrc)
</PRE>

<P>
<PRE>
        farrayPtr = 0.0
    enddo
</PRE>

<P>
The current implementation requires that Grids used to generate the XGrid
   must not match, i.e. they are different either topologically or geometrically or both.
   In this example, the first source Grid is topologically identical to the destination
   Grid but their geometric coordinates are different. This requirement will be relaxed
   in a future release.

<P>
First we compute the regrid routehandles, these routehandles can be used repeatedly
   afterwards. Then we initialize the values in the Fields. Finally we execute the Regrid.
  
<P>
<PRE>
    ! Compute regrid routehandles. The routehandles can be used
    ! repeatedly afterwards.
    ! From A -&gt; X
    do i = 1, 2
        call ESMF_FieldRegridStore(xgrid, srcField(i), field, &amp;
                routehandle=rh_src2xgrid(i), rc = localrc)
</PRE>

<P>
<PRE>
    enddo
    ! from X -&gt; B
    do i = 1, 1
        call ESMF_FieldRegridStore(xgrid, field, dstField(i), &amp;
                routehandle=rh_xgrid2dst(i), rc = localrc)
</PRE>

<P>
<PRE>
    enddo

    ! Initialize values in the source Fields on side A
    do i = 1, 2
        call ESMF_FieldGet(srcField(i), farrayPtr=farrayPtr, rc=localrc)
</PRE>

<P>
<PRE>
        farrayPtr = i
    enddo
    ! Initialize values in the destination Field on XGrid
    xfarrayPtr = 0.0
    ! Initialize values in the destination Field on Side B
    do i = 1, 1
        call ESMF_FieldGet(dstField(i), farrayPtr=farrayPtr, rc=localrc)
</PRE>

<P>
<PRE>
        farrayPtr = 0.0
    enddo
</PRE>

<P>
First we regrid from the Fields on side A to the Field on the XGrid:
<P>
<PRE>
    ! Execute regrid from A -&gt; X
    do i = 1, 2
        call ESMF_FieldRegrid(srcField(i), field, &amp;
            routehandle=rh_src2xgrid(i), &amp;
            zeroregion=ESMF_REGION_SELECT, rc = localrc)
</PRE>

<P>
<PRE>
    enddo
</PRE>

<P>
Next we regrid from the Field on XGrid to the destination Field on side B:
<P>
<PRE>
    ! Execute the regrid store
    do i = 1, 1
        call ESMF_FieldRegrid(field, dstField(i), &amp;
            routehandle=rh_xgrid2dst(i), rc = localrc)
</PRE>

<P>
<PRE>
    enddo
</PRE>

<P>
In the above example, we first set up all the required parameters to create an XGrid from user
   supplied input. Then we create Fields on the XGrid and the Grids on either side. Finally
   we use the <TT>ESMF_FieldRegrid()</TT> interface to perform a flux exchange from the source side
   to the destination side. 

<P>

<H3><A NAME="SECTION050113400000000000000"></A>
  <A NAME="sec:xgrid:usage:xgrid_get"></A>
<BR>
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Query the XGrid for its internal information
</H3>
   One can query the XGrid for its internal information:
<P>
<PRE>
    call ESMF_XGridGet(xgrid, &amp;
        sideAGridCount=ngridA, &amp;    ! number of Grids on side A
        sideBGridCount=ngridB, &amp;    ! number of Grids on side B
        sideAGrid=l_sideA, &amp;    ! list of Grids on side A
        sideBGrid=l_sideB, &amp;    ! list of Grids on side B
        area=l_area, &amp;      ! list of area of XGrid
        centroid=l_centroid, &amp;  ! list of centroid of XGrid
        distgridA=l_sideAdg, &amp;  ! list of Distgrids on side A
        distgridM = distgrid, &amp; ! balanced distgrid
        sparseMatA2X=l_sparseMatA2X, &amp; !sparse matrix matmul parameters A to X
        sparseMatX2B=l_sparseMatX2B, &amp; !sparse matrix matmul parameters X to B
        rc=localrc)
</PRE>

<P>
<PRE>
    call ESMF_XGridGet(xgrid, localDe=0, &amp;
        elementCount=eleCount, &amp;    ! elementCount on the localDE
        exclusiveCount=ec, &amp;        ! exclusive count
        exclusiveLBound=elb, &amp;      ! exclusive lower bound
        exclusiveUBound=eub, &amp;      ! exclusive upper bound
        rc=localrc)
</PRE>

<P>
<PRE>
    call ESMF_XGridGet(xgrid, &amp;
        xgridSide=ESMF_XGRIDSIDE_A, &amp; ! side of the XGrid to query
        gridIndex=1, &amp;              ! index of the distgrid
        distgrid=distgrid, &amp;        ! the distgrid returned
        rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050113500000000000000"></A>
  <A NAME="sec:xgrid:usage:xgrid_destroy"></A>
<BR>
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Destroying the XGrid and other resources
</H3>
   Clean up the resources by destroying the XGrid and other objects:
<P>
<PRE>
    ! After the regridding is successful.
    ! Clean up all the allocated resources:
    call ESMF_FieldDestroy(field, rc=localrc)
</PRE>

<P>
<PRE>
    call ESMF_XGridDestroy(xgrid, rc=localrc)
</PRE>

<P>
<PRE>
    do i = 1, 2
        call ESMF_FieldDestroy(srcField(i), rc = localrc)
</PRE>

<P>
<PRE>
        call ESMF_GridDestroy(sideA(i), rc = localrc)
</PRE>

<P>
<PRE>
    enddo

    do i = 1, 1
        call ESMF_FieldDestroy(dstField(i), rc = localrc)
</PRE>

<P>
<PRE>
        call ESMF_GridDestroy(sideB(i), rc = localrc)
</PRE>

<P>
<PRE>
    enddo

    deallocate(sparseMatA2X(1)%factorIndexList, sparseMatA2X(1)%factorList)
    deallocate(sparseMatA2X(2)%factorIndexList, sparseMatA2X(2)%factorList)
    deallocate(sparseMatX2B(1)%factorIndexList, sparseMatX2B(1)%factorList)
</PRE>

<P>


<H2><A NAME="SECTION050114000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<H3><A NAME="SECTION050114100000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Restrictions and Future Work</A>
</H3>

<P>

<A NAME="XGrid:rest"></A>

<OL>
<LI><B>CAUTION:</B> Any Grid or Mesh pair picked from the A side and B side of the XGrid 
cannot point to the same Grid or Mesh in memory on a local PET. This prevents Regrid from
selecting the right source and destination grid automatically to calculate the regridding routehandle.
It's okay for the Grid and Mesh to have identical topological and geographical properties as long
as they are stored in different memory.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION050115000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>The XGrid class is implemented in Fortran, and as such is
defined inside the framework by a XGrid derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The XGrid class contains information needed to create Grid, Field, and
communication routehandle.

<P>
</LI>
<LI>XGrid follows the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same XGrids at the same point in their execution. 
In addition to the unison rule, XGrid creation also performs inter-PET
communication within the current executing VM. 
</LI>
</OL>

<H2><A NAME="SECTION050116000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050116100000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_XGridAssignment(=) - XGrid assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     xgrid1 = xgrid2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid) :: xgrid1
     type(ESMF_XGrid) :: xgrid2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign xgrid1 as an alias to the same ESMF XGrid object in memory
     as xgrid2. If xgrid2 is invalid, then xgrid1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>xgrid1</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>xgrid2</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116200000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_XGridOperator(==) - XGrid equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface operator(==)
     if (xgrid1 == xgrid2) then ... endif
               OR
     result = (xgrid1 == xgrid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid1
     type(ESMF_XGrid), intent(in) :: xgrid2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether xgrid1 and xgrid2 are valid aliases to the same ESMF
     XGrid object in memory. For a more general comparison of two ESMF XGrids,
     going beyond the simple alias test, the ESMF_XGridMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>xgrid1</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>xgrid2</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116300000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_XGridOperator(/=) - XGrid not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface operator(/=)
     if (xgrid1 /= xgrid2) then ... endif
               OR
     result = (xgrid1 /= xgrid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid1
     type(ESMF_XGrid), intent(in) :: xgrid2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether xgrid1 and xgrid2 are <I>not</I> valid aliases to the
     same ESMF XGrid object in memory. For a more general comparison of two ESMF
     XGrids, going beyond the simple alias test, the ESMF_XGridMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>xgrid1</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>xgrid2</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116400000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_XGridCreate - Create an XGrid from lists of Grids and Meshes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> 
 function ESMF_XGridCreate(&amp;
     sideAGrid,              sideAMesh, &amp;
     sideBGrid,              sideBMesh, &amp;
     sideAGridPriority,      sideAMeshPriority, &amp;
     sideBGridPriority,      sideBMeshPriority, &amp;
     sideAMaskValues,        sideBMaskValues, &amp;
     storeOverlay, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_XGrid)                           :: ESMF_XGridCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_Grid),      intent(in), optional :: sideAGrid(:)
   type(ESMF_Mesh),      intent(in), optional :: sideAMesh(:)
   type(ESMF_Grid),      intent(in), optional :: sideBGrid(:)
   type(ESMF_Mesh),      intent(in), optional :: sideBMesh(:)
   integer,              intent(in), optional :: sideAGridPriority(:)
   integer,              intent(in), optional :: sideAMeshPriority(:)
   integer,              intent(in), optional :: sideBGridPriority(:)
   integer,              intent(in), optional :: sideBMeshPriority(:)
   integer(ESMF_KIND_I4),intent(in), optional :: sideAMaskValues(:)
   integer(ESMF_KIND_I4),intent(in), optional :: sideBMaskValues(:)
   logical,              intent(in), optional :: storeOverlay
   character(len=*),     intent(in), optional :: name
   integer,              intent(out),optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an XGrid from user supplied input: the list of Grids or Meshes on side A and side B, 
    and other optional arguments. A user can supply both Grids and Meshes on one side to create
    the XGrid. By default, the Grids have a higher priority over Meshes but the order of priority 
    can be adjusted by the optional GridPriority and MeshPriority arguments. The priority order
    of Grids and Meshes can also be interleaved by rearranging the optional 
    GridPriority and MeshPriority arguments accordingly.

<P>
Sparse matrix multiplication coefficients are internally computed and
    uniquely determined by the Grids or Meshes provided in <TT>sideA</TT> and <TT>sideB</TT>. User can supply
    a single <TT>ESMF_Grid</TT> or an array of <TT>ESMF_Grid</TT> on either side of the 
    <TT>ESMF_XGrid</TT>. For an array of <TT>ESMF_Grid</TT> or <TT>ESMF_Mesh</TT> in <TT>sideA</TT> or <TT>sideB</TT>,
    a merging process concatenates all the <TT>ESMF_Grid</TT>s and <TT>ESMF_Mesh</TT>es 
    into a super mesh represented
    by <TT>ESMF_Mesh</TT>. The super mesh is then used to compute the XGrid. 
    Grid or Mesh objects in <TT>sideA</TT> and <TT>sideB</TT> arguments must have coordinates defined for
    the corners of a Grid or Mesh cell. XGrid creation can be potentially memory expensive given the
    size of the input Grid and Mesh objects. By default, the super mesh is not stored
    to reduce memory usage. 
    Once communication routehandles are computed using <TT>ESMF_FieldRegridStore()</TT> method through
    XGrid, all memory can be released by destroying the XGrid.

<P>
If <TT>sideA</TT> and <TT>sideB</TT> have a single 
    Grid or Mesh object, it's erroneous
    if the two Grids or Meshes are spatially disjoint. 
    It is also erroneous to specify a Grid or Mesh object in <TT>sideA</TT> or <TT>sideB</TT>
    that is spatially disjoint from the <TT>ESMF_XGrid</TT>. 

<P>
This call is <EM>collective</EM> across the current VM. For more details please refer to the description 
    <A HREF="#sec:xgrid:desc">34.1</A> of the XGrid class. For an example and associated documentation using this method see section 
    <A HREF="#sec:xgrid:usage:xgrid_create">34.3.1</A>

<P>
The arguments are:
       <DL>
<DT><STRONG>[sideAGrid]</STRONG></DT>
<DD>Parametric 2D Grids on side A, for example, 
             these Grids can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideAMesh]</STRONG></DT>
<DD>Parametric 2D Meshes on side A, for example, 
             these Meshes can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideBGrid]</STRONG></DT>
<DD>Parametric 2D Grids on side B, for example, 
             these Grids can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideBMesh]</STRONG></DT>
<DD>Parametric 2D Meshes on side B, for example, 
             these Meshes can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideAGridPriority]</STRONG></DT>
<DD>Priority array of Grids on sideA during overlay generation.
             The <TT>sideAGridPriority</TT> array should be the same size as the <TT>sideAGrid</TT> array. The values
             in the array should range from 1 to size(sideAGrid)+size(sideAMesh). A Grid whose corresponding
             value in this array is lower than another side A Grid or Mesh, will take precedence over that Grid or Mesh
             during side A merging. In other words, if both have parts in the same region, then the object with the lower value will win, and
             the other Grid or Mesh part will be clipped away.
       
</DD>
<DT><STRONG>[sideAMeshPriority]</STRONG></DT>
<DD>Priority array of Meshes on sideA during overlay generation.
             The <TT>sideAMeshPriority</TT> array should be the same size as the <TT>sideAMesh</TT> array. The values
             in the array should range from 1 to size(sideAGrid)+size(sideAMesh). A Mesh whose corresponding
             value in this array is lower than another side A Grid or Mesh, will take precedence over that Grid or Mesh
             during side A merging. In other words, if both have parts in the same region, then the object with the lower value will win, and
             the other Grid or Mesh part will be clipped away.
       
</DD>
<DT><STRONG>[sideBGridPriority]</STRONG></DT>
<DD>Priority array of Grids on sideB during overlay generation.
             The <TT>sideBGridPriority</TT> array should be the same size as the <TT>sideBGrid</TT> array. The values
             in the array should range from 1 to size(sideBGrid)+size(sideBMesh). A Grid whose corresponding
             value in this array is lower than another side B Grid or Mesh, will take precedence over that Grid or Mesh
             during side B merging. In other words, if both have parts in the same region, then the object with the lower value will win, and
             the other Grid or Mesh part will be clipped away.
       
</DD>
<DT><STRONG>[sideBMeshPriority]</STRONG></DT>
<DD>Priority array of Meshes on sideB during overlay generation.
             The <TT>sideBMeshPriority</TT> array should be the same size as the <TT>sideBMesh</TT> array. The values
             in the array should range from 1 to size(sideBGrid)+size(sideBMesh). A Mesh whose corresponding
             value in this array is lower than another side B Grid or Mesh, will take precedence over that Grid or Mesh
             during side B merging. In other words, if both have parts in the same region, then the object with the lower value will win, and
             the other Grid or Mesh part will be clipped away.
       
</DD>
<DT><STRONG>[sideAMaskValues]</STRONG></DT>
<DD>Mask information can be set in the Grid (see&nbsp;<A HREF="#sec:usage:items">31.3.17</A>) or Mesh (see&nbsp;<A HREF="#sec:mesh:mask">33.3.11</A>) 
             upon which the <TT>Field</TT> is built. The <TT>sideAMaskValues</TT> argument specifies the values in that 
             mask information which indicate a point should be masked out. In other words, a location is masked if and only if the
             value for that location in the mask information matches one of the values listed in <TT>sideAMaskValues</TT>.  
             If <TT>sideAMaskValues</TT> is not specified, no masking on side A will occur. 
       
</DD>
<DT><STRONG>[sideBMaskValues]</STRONG></DT>
<DD>Mask information can be set in the Grid (see&nbsp;<A HREF="#sec:usage:items">31.3.17</A>) or Mesh (see&nbsp;<A HREF="#sec:mesh:mask">33.3.11</A>) 
             upon which the <TT>Field</TT> is built. The <TT>sideBMaskValues</TT> argument specifies the values in that 
             mask information which indicate a point should be masked out. In other words, a location is masked if and only if the
             value for that location in the mask information matches one of the values listed in <TT>sideBMaskValues</TT>.  
             If <TT>sideBMaskValues</TT> is not specified, no masking on side B will occur. 
       
</DD>
<DT><STRONG>[storeOverlay]</STRONG></DT>
<DD>Setting the <TT>storeOverlay</TT> optional argument to .false. (default) 
             allows a user to bypass storage of the <TT>ESMF_Mesh</TT> used to represent the XGrid.
             Only a <TT>ESMF_DistGrid</TT> is stored to allow Field to be built on the XGrid.
             If the temporary mesh object is of interest, <TT>storeOverlay</TT> can be set to .true.
             so a user can retrieve it for future use.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>name of the xgrid object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> only if the <TT>ESMF_XGrid</TT> 
             is created.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116500000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_XGridCreateFromSparseMat an XGrid from raw input parameters</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> 
 function ESMF_XGridCreateFromSparseMat(&amp;
     sideAGrid,              sideAMesh, &amp;
     sideBGrid,              sideBMesh, &amp;
     sideAGridPriority,      sideAMeshPriority, &amp;
     sideBGridPriority,      sideBMeshPriority, &amp;
     sparseMatA2X, sparseMatX2A, sparseMatB2X, sparseMatX2B, &amp;
     area, centroid, &amp;
     name, &amp;
     rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_XGrid) :: ESMF_XGridCreateFromSparseMat
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
 type(ESMF_Grid),      intent(in), optional :: sideAGrid(:)
 type(ESMF_Mesh),      intent(in), optional :: sideAMesh(:)
 type(ESMF_Grid),      intent(in), optional :: sideBGrid(:)
 type(ESMF_Mesh),      intent(in), optional :: sideBMesh(:)
 integer,              intent(in), optional :: sideAGridPriority(:)
 integer,              intent(in), optional :: sideAMeshPriority(:)
 integer,              intent(in), optional :: sideBGridPriority(:)
 integer,              intent(in), optional :: sideBMeshPriority(:)
 type(ESMF_XGridSpec), intent(in), optional :: sparseMatA2X(:)
 type(ESMF_XGridSpec), intent(in), optional :: sparseMatX2A(:)
 type(ESMF_XGridSpec), intent(in), optional :: sparseMatB2X(:)
 type(ESMF_XGridSpec), intent(in), optional :: sparseMatX2B(:)
 real(ESMF_KIND_R8),   intent(in), optional :: area(:)
 real(ESMF_KIND_R8),   intent(in), optional :: centroid(:,:)
 character (len=*),    intent(in), optional :: name
 integer,              intent(out),optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an XGrid directly from user supplied sparse matrix parameters. User
        is responsible to supply all information necessary for communication calculation. 
        For an example and associated documentation using this method see section 
        <A HREF="#sec:xgrid:usage:xgrid_createfromsparsemat">34.3.3</A>

<P>
The arguments are:
       <DL>
<DT><STRONG>[sideAGrid]</STRONG></DT>
<DD>Parametric 2D Grids on side A, for example, 
             these Grids can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideAMesh]</STRONG></DT>
<DD>Parametric 2D Meshes on side A, for example, 
             these Meshes can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideBGrid]</STRONG></DT>
<DD>Parametric 2D Grids on side B, for example, 
             these Grids can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideBMesh]</STRONG></DT>
<DD>Parametric 2D Meshes on side B, for example, 
             these Meshes can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideAGridPriority]</STRONG></DT>
<DD>Priority array of Grids on sideA during overlay generation.
             The <TT>sideAGridPriority</TT> array should be the same size as the <TT>sideAGrid</TT> array. The values
             in the array should range from 1 to size(sideAGrid)+size(sideAMesh). A Grid whose corresponding
             value in this array is lower than another side A Grid or Mesh, will take precedence over that Grid or Mesh
             during side A merging. In other words, if both have parts in the same region, then the object with the lower value will win, and
             the other Grid or Mesh part will be clipped away.
       
</DD>
<DT><STRONG>[sideAMeshPriority]</STRONG></DT>
<DD>Priority array of Meshes on sideA during overlay generation.
             The <TT>sideAMeshPriority</TT> array should be the same size as the <TT>sideAMesh</TT> array. The values
             in the array should range from 1 to size(sideAGrid)+size(sideAMesh). A Mesh whose corresponding
             value in this array is lower than another side A Grid or Mesh, will take precedence over that Grid or Mesh
             during side A merging. In other words, if both have parts in the same region, then the object with the lower value will win, and
             the other Grid or Mesh part will be clipped away.
       
</DD>
<DT><STRONG>[sideBGridPriority]</STRONG></DT>
<DD>Priority array of Grids on sideB during overlay generation.
             The <TT>sideBGridPriority</TT> array should be the same size as the <TT>sideBGrid</TT> array. The values
             in the array should range from 1 to size(sideBGrid)+size(sideBMesh). A Grid whose corresponding
             value in this array is lower than another side B Grid or Mesh, will take precedence over that Grid or Mesh
             during side B merging. In other words, if both have parts in the same region, then the object with the lower value will win, and
             the other Grid or Mesh part will be clipped away.
       
</DD>
<DT><STRONG>[sideBMeshPriority]</STRONG></DT>
<DD>Priority array of Meshes on sideB during overlay generation.
             The <TT>sideBMeshPriority</TT> array should be the same size as the <TT>sideBMesh</TT> array. The values
             in the array should range from 1 to size(sideBGrid)+size(sideBMesh). A Mesh whose corresponding
             value in this array is lower than another side B Grid or Mesh, will take precedence over that Grid or Mesh
             during side B merging. In other words, if both have parts in the same region, then the object with the lower value will win, and
             the other Grid or Mesh part will be clipped away.
       
</DD>
<DT><STRONG>[sparseMatA2X]</STRONG></DT>
<DD>indexlist from a Grid index space on side A to xgrid index space;
             indexFactorlist from a Grid index space on side A to xgrid index space.
       
</DD>
<DT><STRONG>[sparseMatX2A]</STRONG></DT>
<DD>indexlist from xgrid index space to a Grid index space on side A;
             indexFactorlist from xgrid index space to a Grid index space on side A.
       
</DD>
<DT><STRONG>[sparseMatB2X]</STRONG></DT>
<DD>indexlist from a Grid index space on side B to xgrid index space;
             indexFactorlist from a Grid index space on side B to xgrid index space.
       
</DD>
<DT><STRONG>[sparseMatX2B]</STRONG></DT>
<DD>indexlist from xgrid index space to a Grid index space on side B;
             indexFactorlist from xgrid index space to a Grid index space on side B.
       
</DD>
<DT><STRONG>[area]</STRONG></DT>
<DD>area of the xgrid cells.
       
</DD>
<DT><STRONG>[centroid]</STRONG></DT>
<DD>coordinates at the area weighted center of the xgrid cells.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>name of the xgrid object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> only if the <TT>ESMF_XGrid</TT> 
             is created.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116600000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_XGridIsCreated - Check whether a XGrid object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_XGridIsCreated(xgrid, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_XGridIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in)            :: xgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>xgrid</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116700000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_XGridDestroy - Release resources associated with an XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> 
   subroutine ESMF_XGridDestroy(xgrid, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(inout)          :: xgrid       
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,          intent(in),   optional :: noGarbage
     integer,          intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_XGrid</TT>, releasing the resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this
        condition ESMF cannot protect against accessing the destroyed object
        through dangling aliases - a situation which may lead to hard to debug
        application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
        set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use
        temporary ESMF objects. For situations where the repeated creation and
        destruction of temporary objects leads to memory issues, it is
        recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
        removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050116800000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_XGridGet - Get object-wide information from an XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_XGridGet()
 
 subroutine ESMF_XGridGetDefault(xgrid, &amp;
     sideAGridCount, sideBGridCount, sideAMeshCount, sideBMeshCount, &amp;
     coordSys, &amp;
     dimCount, elementCount, &amp;
     sideAGrid, sideBGrid, sideAMesh, sideBMesh, &amp;
     mesh, &amp;
     area, centroid, &amp;
     distgridA, distgridB, distgridM, &amp;
     sparseMatA2X, sparseMatX2A, sparseMatB2X, sparseMatX2B, &amp;
     name, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> type(ESMF_XGrid),     intent(in)            :: xgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
 integer,              intent(out), optional :: sideAGridCount, sideBGridCount
 integer,              intent(out), optional :: sideAMeshCount, sideBMeshCount
 type(ESMF_CoordSys_Flag), intent(out), optional :: coordSys
 integer,              intent(out), optional :: dimCount
 integer,              intent(out), optional :: elementCount
 type(ESMF_Grid),      intent(out), optional :: sideAGrid(:), sideBGrid(:)
 type(ESMF_Mesh),      intent(out), optional :: sideAMesh(:), sideBMesh(:)
 type(ESMF_Mesh),      intent(out), optional :: mesh
 real(ESMF_KIND_R8),   intent(out), optional :: area(:)
 real(ESMF_KIND_R8),   intent(out), optional :: centroid(:,:)
 type(ESMF_DistGrid),  intent(out), optional :: distgridA(:)
 type(ESMF_DistGrid),  intent(out), optional :: distgridB(:)
 type(ESMF_DistGrid),  intent(out), optional :: distgridM
 type(ESMF_XGridSpec), intent(out), optional :: sparseMatA2X(:)
 type(ESMF_XGridSpec), intent(out), optional :: sparseMatX2A(:)
 type(ESMF_XGridSpec), intent(out), optional :: sparseMatB2X(:)
 type(ESMF_XGridSpec), intent(out), optional :: sparseMatX2B(:)
 character (len=*),    intent(out), optional :: name
 integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get information about XGrid

<P>
The arguments are:
       <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object used to retrieve information from.
       
</DD>
<DT><STRONG>[sideAGridCount]</STRONG></DT>
<DD>Total Number of Grids on the A side.
       
</DD>
<DT><STRONG>[sideBGridCount]</STRONG></DT>
<DD>Total Number of Grids on the B side.
       
</DD>
<DT><STRONG>[sideAMeshCount]</STRONG></DT>
<DD>Total Number of Meshes on the A side.
       
</DD>
<DT><STRONG>[sideBMeshCount]</STRONG></DT>
<DD>Total Number of Meshes on the B side.
       
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the XGrid's coordinate data.
       
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of dimension of the xgrid.
       
</DD>
<DT><STRONG>[elementCount]</STRONG></DT>
<DD>Number of elements in exclusive region of the xgrid on this PET.
       
</DD>
<DT><STRONG>[sideAGrid]</STRONG></DT>
<DD>List of 2D Grids on side A. Must enter with shape(sideAGrid)=(/sideAGridCount/).
       
</DD>
<DT><STRONG>[sideBGrid]</STRONG></DT>
<DD>List of 2D Grids on side B. Must enter with shape(sideBGrid)=(/sideBGridCount/).
       
</DD>
<DT><STRONG>[sideAMesh]</STRONG></DT>
<DD>List of 2D Meshes on side A. Must enter with shape(sideAMesh)=(/sideAMeshCount/).
       
</DD>
<DT><STRONG>[sideBMesh]</STRONG></DT>
<DD>List of 2D Meshes on side B. Must enter with shape(sideBMesh)=(/sideBMeshCount/).
       
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>Super mesh stored in XGrid when storeOverlay is set true during XGrid creation.
       
</DD>
<DT><STRONG>[area]</STRONG></DT>
<DD>Area of the xgrid cells on this PET. Must enter with shape(area)=(/elementCount/).
       
</DD>
<DT><STRONG>[centroid]</STRONG></DT>
<DD>Coordinates at the area weighted center of the xgrid cells on this PET. Must enter with shape(centroid)=(/elementCount, dimCount/).
       
</DD>
<DT><STRONG>[distgridA]</STRONG></DT>
<DD>List of distgrids whose sequence index list is an overlap between a Grid
             on sideA and the xgrid object. Must enter with shape(distgridA)=(/sideAGridCount+sideAMeshCount/).
       
</DD>
<DT><STRONG>[distgridB]</STRONG></DT>
<DD>List of distgrids whose sequence index list is an overlap between a Grid
             on sideB and the xgrid object. Must enter with shape(distgridB)=(/sideBGridCount+sideBMeshCount/).
       
</DD>
<DT><STRONG>[distgridM]</STRONG></DT>
<DD>The distgrid whose sequence index list fully describes the xgrid object.
       
</DD>
<DT><STRONG>[sparseMatA2X]</STRONG></DT>
<DD>Indexlist from a Grid index space on side A to xgrid index space; 
             indexFactorlist from a Grid index space on side A to xgrid index space. Must enter with shape(sparsematA2X)=(/sideAGridCount+sideAMeshCount/).
       
</DD>
<DT><STRONG>[sparseMatX2A]</STRONG></DT>
<DD>Indexlist from xgrid index space to a Grid index space on side A; 
             indexFactorlist from xgrid index space to a Grid index space on side A. Must enter with shape(sparsematX2A)=(/sideAGridCount+sideAMeshCount/).
       
</DD>
<DT><STRONG>[sparseMatB2X]</STRONG></DT>
<DD>Indexlist from a Grid index space on side B to xgrid index space; 
             indexFactorlist from a Grid index space on side B to xgrid index space. Must enter with shape(sparsematB2X)=(/sideBGridCount+sideBMeshCount/).
       
</DD>
<DT><STRONG>[sparseMatX2B]</STRONG></DT>
<DD>Indexlist from xgrid index space to a Grid index space on side B; 
             indexFactorlist from xgrid index space to a Grid index space on side B. Must enter with shape(sparsematX2B)=(/sideBGridCount+sideBMeshCount/).
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the xgrid object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> only if the <TT>ESMF_XGrid</TT> 
             is created.
       
</DD>
</DL>

<P>


<P>

<P>

<P>


<H1><A NAME="SECTION050120000000000000000">
<SPAN CLASS="arabic">35</SPAN> Geom Class</A>
</H1>

<H2><A NAME="SECTION050121000000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF Geom class is used as a container for other ESMF geometry objects (e.g. an ESMF Grid). This allows a generic
representation of a geometry to be passed around (e.g. through a coupled system) without it's specific type being known.
Some operations are supported on a Geom object and more will be added over time as needed. However, if
an unsupported operation is needed, then the specific geometry object can always be pulled out and operated on that way.

<P>
In addition to the geometry object, a Geom can also contain information describing a location on a geometry. For example, in the case of
a Grid, a geometry object will also contain a stagger location. Having this location information allows the creation of Fields and
other capabilities to be performed in the most generic way on a Geom object. For geometries where it is appropriate, the user can
optionally specify this location information during the creation of a Geom object. However, if no location is specified, then default values for
this information are provided which match those which would be used when creating a Field with the specific geometry
(e.g. stagger location ESMF_STAGGERLOC_CENTER for a Grid).

<H2><A NAME="SECTION050122000000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API: Geom Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050122100000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GeomCreate - Create a Geom from a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GeomCreate()
       function ESMF_GeomCreateGrid(grid,staggerloc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Geom) :: ESMF_GeomCreateGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Grid),       intent(in)             :: grid
        type(ESMF_StaggerLoc), intent(in), optional   :: staggerloc
        integer,               intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Geom</TT> object from an <TT>ESMF_Grid</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object from which to create the Geom.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells.  For valid
         predefined values see section <A HREF="#const:staggerloc">31.2.6</A>.
         If not specified, defaults to <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050122200000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GeomCreate - Create a Geom from a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GeomCreate()
       function ESMF_GeomCreateMesh(mesh, meshLoc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Geom) :: ESMF_GeomCreateMesh
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Mesh),       intent(in)              :: mesh
        type(ESMF_MeshLoc),    intent(in),  optional   :: meshLoc
        integer,               intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Geom</TT> object from an <TT>ESMF_Mesh</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object from which to create the Geom.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>The part of the Mesh on which to build the Field. For valid
         predefined values see Section&nbsp;<A HREF="node9.html#const:meshloc">54.39</A>.
         If not set, defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050122300000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GeomCreate - Create a Geom from a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GeomCreate()
       function ESMF_GeomCreateLocStream(locstream, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Geom) :: ESMF_GeomCreateLocStream
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_LocStream),  intent(in)              :: locstream
        integer,               intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Geom</TT> object from an <TT>ESMF_LocStream</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object from which to create the Geom.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050122400000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GeomCreate - Create a Geom from an XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GeomCreate()
       function ESMF_GeomCreateXGrid(xgrid, xgridside, gridIndex, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Geom) :: ESMF_GeomCreateXGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_XGrid),     intent(in)                :: xgrid
        type(ESMF_XGridSide_Flag), intent(in), optional :: xgridSide
        integer,              intent(in), optional      :: gridIndex
        integer,              intent(out),optional      :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Geom</TT> object from an <TT>ESMF_XGrid</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object from which to create the Geom.
   
</DD>
<DT><STRONG>[xgridSide]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
         ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not specified, then
         defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridSide is  ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then
         this index tells which Grid or Mesh on that side is being
         referred to. If not provided, defaults to 1.      
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050122500000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_GeomDestroy - Release resources associated with a Geom</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_GeomDestroy(geom, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Geom)            :: geom
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_Geom</TT> object. This call does not destroy wrapped
     Grid, LocStream, or other objects.

<P>
The arguments are:
   <DL>
<DT><STRONG>geom</STRONG></DT>
<DD><TT>ESMF_Geom</TT> to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050122600000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_GeomGet - Get information about a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_GeomGet(geom, &amp;
           dimCount, rank, localDECount, distgrid, &amp;
           distgridToGridMap, indexFlag, geomtype, &amp;
           grid, staggerloc, mesh, meshloc, locstream, &amp;
           xgrid, xgridside, gridIndex,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Geom),   intent(in)            :: geom
       integer,               intent(out), optional :: dimCount
       integer,               intent(out), optional :: rank
       integer,               intent(out), optional :: localDECount
       type(ESMF_DistGrid),   intent(out), optional :: distgrid
       integer,               intent(out), optional :: distgridToGridMap(:)
       type(ESMF_Index_Flag),  intent(out), optional :: indexflag
       type(ESMF_GeomType_Flag),   intent(out), optional :: geomtype
       type(ESMF_Grid),       intent(out), optional :: grid
       type(ESMF_StaggerLoc), intent(out), optional :: staggerloc
       type(ESMF_Mesh),       intent(out), optional :: mesh
       type(ESMF_MeshLoc),    intent(out), optional :: meshloc
       type(ESMF_LocStream),  intent(out), optional :: locstream
       type(ESMF_XGrid),      intent(out), optional :: xgrid
       type(ESMF_XGridSide_Flag),  intent(out), optional :: xgridside
       integer,               intent(out), optional :: gridIndex
       integer,               intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get various types of information about a Geom.

<P>
The arguments are:
  <DL>
<DT><STRONG>geom</STRONG></DT>
<DD>Geom to get the information from.
  
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>The full number of dimensions of the Distgrid object underneath the Geom object.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>The count of the memory dimensions in this Geom object.
     Typically it's the same as dimCount.
     However, in some cases (e.g. arbitrarily distributed grids) it can be different.
  
</DD>
<DT><STRONG>[localDECount]</STRONG></DT>
<DD>The number of DEs in this Geom object on this PET.
  
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The structure describing the distribution of the Geom object.
  
</DD>
<DT><STRONG>[distgridToGridMap]</STRONG></DT>
<DD>List that has as many elements as the distgrid dimCount. This array describes
     mapping between the Geom object's dimensions and its Distgrid.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
   
</DD>
<DT><STRONG>[geomtype]</STRONG></DT>
<DD>The type of geometry on which the Field is built. See
      section&nbsp;<A HREF="node9.html#const:geomtype">54.22</A> for the range of values.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>If the Geom object holds a Grid, then this will pass out that Grid object.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>If the Geom object holds a Grid, then this will pass out the staggerloc.
   
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>If the Geom object holds a Mesh, then this will pass out that Mesh object.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>If the Geom object holds a Mesh, then this will pass out the meshloc.
   
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>If the Geom object holds a LocStream, then this will pass out that LocStream object.
   
</DD>
<DT><STRONG>[xgrid]</STRONG></DT>
<DD>If the Geom object holds an XGrid, then this will pass out that XGrid object.
   
</DD>
<DT><STRONG>[xgridSide]</STRONG></DT>
<DD>If the Geom object holds an XGrid, then this will pass out the XGrid side.
   
</DD>
<DT><STRONG>[gridIndex]</STRONG></DT>
<DD>If the Geom object holds an XGrid, then this will pass out the gridIndex. 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>


<H1><A NAME="SECTION050130000000000000000">
<SPAN CLASS="arabic">36</SPAN> DistGrid Class</A>
</H1>

<H2><A NAME="SECTION050131000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:DistGrid"></A>The ESMF DistGrid class sits on top of the DELayout class and holds domain
information in index space. A DistGrid object captures the index space topology
and describes its decomposition in terms of DEs. Combined with DELayout and VM
the DistGrid defines the data distribution of a domain decomposition across the
computational resources of an ESMF Component.

<P>
The global domain is defined as the union of logically
rectangular (LR) sub-domains or <EM>tiles</EM>. The DistGrid create methods allow
the specification of such a multi-tile global domain and its decomposition into
exclusive, DE-local LR regions according to various degrees of user specified
constraints. Complex index space topologies can be constructed by specifying
connection relationships between tiles during creation.

<P>
The DistGrid class holds domain information for all DEs. Each DE is associated
with a local LR region. No overlap of the regions is allowed. The DistGrid
offers query methods that allow DE-local topology information to be extracted,
e.g. for the construction of halos by higher classes.

<P>
A DistGrid object only contains decomposable dimensions. The minimum rank for a
DistGrid object is 1. A maximum rank does not exist for DistGrid objects, 
however, ranks greater than 7 may lead to difficulties with respect to the
Fortran API of higher classes based on DistGrid. The rank of a DELayout object
contained within a DistGrid object must be equal to the DistGrid rank. Higher
class objects that use the DistGrid, such as an Array object, may be of
different rank than the associated DistGrid object. The higher class object
will hold the mapping information between its dimensions and the DistGrid
dimensions.

<H2><A NAME="SECTION050132000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION050132100000000000000"></A>
<A NAME="const:distgridmatch"></A>
<BR>
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DISTGRIDMATCH
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Indicates the level to which two DistGrid variables match.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_DistGridMatch_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DISTGRIDMATCH_INVALID:</STRONG></DT>
<DD>Indicates a non-valid matching level. One
  or both DistGrid objects are invalid.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_NONE:</STRONG></DT>
<DD>The lowest valid level of DistGrid matching. 
  This indicates that the DistGrid objects don't match at any of the higher
  levels.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_INDEXSPACE:</STRONG></DT>
<DD>The index space covered by the two
  DistGrid objects is identical. However, differences between the two objects
  prevents a higher matching level.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_TOPOLOGY:</STRONG></DT>
<DD>The topology (i.e. index space and 
  connections) defined by the two DistGrid objects is identical. However, 
  differences between the two objects prevents a higher matching level.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_DECOMP:</STRONG></DT>
<DD>The index space decomposition defined by
   the two DistGrid objects is identical. However, differences between the two
   objects prevents a higher matching level.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_EXACT:</STRONG></DT>
<DD>The two DistGrid objects match in all 
  aspects, including sequence indices. The only aspect that may differ between
  the two objects is their name.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_ALIAS:</STRONG></DT>
<DD>Both DistGrid variables are aliases to the
  exact same DistGrid object in memory.
</DD>
</DL>

<H2><A NAME="SECTION050133000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to create, use and destroy DistGrid objects. In order to produce complete and valid DistGrid objects all of the <TT>ESMF_DistGridCreate()</TT> calls require to be called in unison i.e. on <EM>all</EM> PETs of a component with a complete set of valid arguments.

<P>

<P>

<P>

<H3><A NAME="SECTION050133100000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Single tile DistGrid with regular decomposition</A>
</H3>

<P>
The minimum information required to create an <TT>ESMF_DistGrid</TT> object
   for a single tile with default decomposition are the min and max of the tile
   in index space. The following call creates a DistGrid for a 
   1D index space tile with elements from 1 through 1000.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/1000/), rc=rc)
</PRE>

<P>
A default DELayout with 1 DE per PET will be created during the
   <TT>ESMF_DistGridCreate()</TT> call. The 1000 elements of the specified 1D tile
   are then block decomposed into the available DEs, and distributed across the
   PETs (same number as DEs by default).
   Assuming execution on 4 PETs, the (min) <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img110.png"
 ALT="$\sim$"></SPAN> (max) indices of the DE-local
   blocks will be:
   <PRE>
     DE 0 - (1) ~ (250)
     DE 1 - (251) ~ (500)
     DE 2 - (501) ~ (750)
     DE 3 - (751) ~ (1000)
</PRE>

<P>
DistGrids with rank &gt; 1 can also be created with default decompositions,
   specifying only the min and max indices of the tile. The following creates a
   2D DistGrid for a 5x5 tile with default decomposition.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), rc=rc)
</PRE>

<P>
The default decomposition for a DistGrid of rank <SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img111.png"
 ALT="$N$"></SPAN> will be <!-- MATH
 $(nDEs \times 1
   \times ... \times 1)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="147" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img112.png"
 ALT="$(nDEs \times 1
\times ... \times 1) $"></SPAN>, where <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img113.png"
 ALT="$nDEs$"></SPAN> is the number of DEs in the DELayout
   and there are <SPAN CLASS="MATH"><IMG
 WIDTH="46" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img114.png"
 ALT="$N-1$"></SPAN> factors of <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img76.png"
 ALT="$1$"></SPAN>. For the 2D example above this means
   a <SPAN CLASS="MATH"><IMG
 WIDTH="39" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img115.png"
 ALT="$4 \times 1$"></SPAN> regular decomposition if executed on 4 PETs and will result
   in the following DE-local LR regions:
   <PRE>
     DE 0 - (1,1) ~ (2,5)
     DE 1 - (3,1) ~ (3,5)
     DE 2 - (4,1) ~ (4,5)
     DE 3 - (5,1) ~ (5,5)
</PRE>

<P>
In many cases the default decomposition will not suffice for higher rank
   DistGrids (rank &gt; 1). For this reason a decomposition descriptor 
   <TT>regDecomp</TT> argument is available during <TT>ESMF_DistGridCreate()</TT>. The
   following call creates a DistGrid on the same 2D tile as before, but now with
   a user specified regular decomposition of <!-- MATH
 $2 \times 3 = 6$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="69" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img116.png"
 ALT="$2 \times 3 = 6 $"></SPAN> DEs.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
The default DE labeling sequence follows column major order for the
   <TT>regDecomp</TT> argument:
   <PRE>
     -----------&gt; 2nd dimension
     |  0  2  4
     |  1  3  5
     v
    1st dimension
</PRE>

<P>
By default grid points along all dimensions are homogeneously divided between
   the DEs. The maximum element count difference between DEs along any dimension
   is 1. The (min) <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img110.png"
 ALT="$\sim$"></SPAN> (max) indices of the DE-local blocks of the above
   example are as follows:
   <PRE>
     DE 0 - (1,1) ~ (3,2)
     DE 1 - (4,1) ~ (5,2)
     DE 2 - (1,3) ~ (3,4)
     DE 3 - (4,3) ~ (5,4)
     DE 4 - (1,5) ~ (3,5)
     DE 5 - (4,5) ~ (5,5)
</PRE>

<P>
The specifics of the tile decomposition into DE-local LR domains can be
   modified by the optional <TT>decompflag</TT> argument. The following line shows
   how this argument is used to keep ESMF's default decomposition in the first
   dimension but move extra grid points of the second dimension to the last DEs
   in that direction. Extra elements occur if the number of DEs for a certain
   dimension does not evenly divide its extent. In this example there are
   2 extra grid points for the second dimension because its extent is 5 but there
   are 3 DEs along this index space axis.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), decompflag=(/ESMF_DECOMP_BALANCED, &amp;
    ESMF_DECOMP_RESTLAST/), rc=rc)
</PRE>

<P>
Now DE 4 and DE 5 will hold the extra elements along the 2nd dimension.
   <PRE>
     DE 0 - (1,1) ~ (3,1)
     DE 1 - (4,1) ~ (5,1)
     DE 2 - (1,2) ~ (3,2)
     DE 3 - (4,2) ~ (5,2)
     DE 4 - (1,3) ~ (3,5)
     DE 5 - (4,3) ~ (5,5)
</PRE>

<P>
An alternative way of indicating the DE-local LR regions is to list the 
   index space coordinate as given by the associated DistGrid tile for each
   dimension. For this 2D example there are two lists (dim 1) / (dim 2) for each
   DE:
   <PRE>
     DE 0 - (1,2,3) / (1)
     DE 1 - (4,5)   / (1)
     DE 2 - (1,2,3) / (2)
     DE 3 - (4,5)   / (2)
     DE 4 - (1,2,3) / (3,4,5)
     DE 5 - (4,5)   / (3,4,5)
</PRE>

<P>
Information about DE-local LR regions in the latter format can be obtained 
   from the DistGrid object by use of <TT>ESMF_DistGridGet()</TT> methods:
  
<P>
<PRE>
  allocate(dimExtent(2, 0:5)) ! (dimCount, deCount)
  call ESMF_DistGridGet(distgrid, delayout=delayout, &amp;
    indexCountPDe=dimExtent, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  allocate(localDeToDeMap(0:localDeCount-1))
  call ESMF_DELayoutGet(delayout, localDeToDeMap=localDeToDeMap, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  do localDe=0, localDeCount-1
    de = localDeToDeMap(localDe)
    do dim=1, 2
      allocate(localIndexList(dimExtent(dim, de))) ! allocate list 
                                                   ! to hold indices
      call ESMF_DistGridGet(distgrid, localDe=localDe, dim=dim, &amp;
        indexList=localIndexList, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
      print *, "local DE ", localDe," - DE ",de, &amp;
        " localIndexList along dim=", dim," :: ", localIndexList
      deallocate(localIndexList)
    enddo
  enddo
  deallocate(localDeToDeMap)
  deallocate(dimExtent)
</PRE>

<P>
The advantage of the <TT>localIndexList</TT> format over the minIndex/maxIndex 
   format is that it can be used directly for DE-local to tile index 
   dereferencing. Furthermore the <TT>localIndexList</TT> allows to express very
   general decompositions such as the cyclic decompositions in the first
   dimension generated by the following call:
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), &amp;
    decompflag=(/ESMF_DECOMP_CYCLIC,ESMF_DECOMP_RESTLAST/), rc=rc)
</PRE>

<P>
with decomposition:
   <PRE>
     DE 0 - (1,3,5) / (1)
     DE 1 - (2,4)   / (1)
     DE 2 - (1,3,5) / (2)
     DE 3 - (2,4)   / (2)
     DE 4 - (1,3,5) / (3,4,5)
     DE 5 - (2,4)   / (3,4,5)
</PRE>

<P>
Finally, a DistGrid object is destroyed by calling
 <PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050133200000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> DistGrid and DELayout</A>
</H3>

<P>
The examples of this section use the 2D DistGrid of the previous section 
   to show the interplay between DistGrid and DELayout. By default, i.e.
   without specifying the <TT>delayout</TT> argument, a DELayout will be created
   during DistGrid creation that provides as many DEs as the DistGrid
   object requires. The implicit call to <TT>ESMF_DELayoutCreate()</TT> is issued
   with a fixed number of DEs and default settings in all other aspects. The
   resulting DE to PET mapping depends on the number of PETs of the current VM
   context. Assuming 6 PETs in the VM
 <PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
will result in the following domain decomposition in terms of DEs
   <PRE>
     0  2  4
     1  3  5
</PRE>
   and their layout or distribution over the available PETs:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 1
     DE 2  -&gt; PET 2
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 4
     DE 5  -&gt; PET 5
</PRE>

<P>
Running the same example on a 4 PET VM will not change the domain 
   decomposition into 6 DEs as specified by
   <PRE>
     0  2  4
     1  3  5
</PRE>
   but the layout across PETs will now contain multiple DE-to-PET mapping with 
   default cyclic distribution:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 1
     DE 2  -&gt; PET 2
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 0
     DE 5  -&gt; PET 1
</PRE>

<P>
Sometimes it may be desirable for performance tuning to construct a DELayout
   with specific characteristics. For instance, if the 6 PETs of the above 
   example are running on 3 nodes of a dual-SMP node cluster and there is a 
   higher communication load along the first dimension of the model than along 
   the second dimension it would be sensible to place DEs according to this 
   knowledge. 

<P>
The following example first creates a DELayout 
   with 6 DEs where groups of 2 DEs are to be in fast connection. This DELayout 
   is then used to create a DistGrid.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=6, deGrouping=(/(i/2,i=0,5)/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), delayout=delayout, rc=rc)
</PRE>

<P>
This will ensure a distribution of DEs across the cluster resource 
   in the following way:
   <PRE>
     0   2   4
     1   3   5
    SMP SMP SMP
</PRE>

<P>
The interplay between DistGrid and DELayout may at first seem complicated.
   The simple but important rule to understand is that DistGrid describes a 
   domain decomposition and each domain is labeled with a DE number. The DELayout
   describes how these DEs are laid out over the compute resources of the VM, 
   i.e. PETs. The DEs are purely logical elements of decomposition and may be 
   relabeled to fit the algorithm or legacy code better. The following 
   example demonstrates this by describing the exact same distribution of the 
   domain data across the fictitious cluster of SMP-nodes with a different 
   choice of DE labeling:
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=6, deGrouping=(/(mod(i,3),i=0,5)/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), deLabelList=(/0,3,1,4,2,5/), delayout=delayout, rc=rc)
</PRE>

<P>
Here the <TT>deLabelList</TT> argument changes the default DE label sequence from
   column major to row major. The DELayout compensates for this change in DE
   labeling by changing the <TT>deGrouping</TT> argument to map the first dimension
   to SMP nodes as before. The decomposition and layout now looks as follows:
   <PRE>
     0   1   2
     3   4   5
    SMP SMP SMP
</PRE>

<P>
Finally, in order to achieve a completely user-defined distribution of the
   domain data across the PETs of the VM a DELayout may be created from a
   <TT>petMap</TT> before using it in the creation of a DistGrid. If for
   instance the desired distribution of a 2 x 3 decomposition puts the DEs of 
   the first row onto 3 separate PETs (PET 0, 1, 2) and groups the DEs of 
   the second row onto PET 3 a <TT>petMap</TT> must first be setup that
   takes the DE labeling of the DistGrid into account.The following lines of 
   code result in the desired distribution using column major DE labeling by 
   first create a DELayout and then using it in the DistGrid creation.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/0,3,1,3,2,3/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), delayout=delayout, rc=rc)
</PRE>

<P>
This decomposes the global domain into
   <PRE>
     0   2   4
     1   3   5
</PRE>
   and associates the DEs to the following PETs:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 3
     DE 2  -&gt; PET 1
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 2
     DE 5  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION050133300000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Single tile DistGrid with decomposition by DE blocks</A>
</H3>

<P>
In the previous examples the DistGrid objects were created with regular
   decompositions. In some cases a regular decomposition may not be the most
   natural choice to decompose and distribute the index space. The 
   DE block version of <TT>ESMF_DistGridCreate()</TT> offers more control
   over the precise decomposition. The following example shows how the 
   <TT>deBlockList</TT> argument is used to determine exactly what index space
   block ends up on each DE.

<P>
A single 5x5 tile is decomposed into 6 DEs. To this end a list is
   constructed that holds the min and max indices of all six DE
   blocks. The DE blocks must be constructed to cover the index space without
   overlapping each other. It is okay to leave holes in the index space, i.e.
   the DE blocks do not completely cover the index space tile.
<P>
<PRE>
  allocate(deBlockList(2, 2, 6))  ! (dimCount, 2, deCount)
  deBlockList(:,1,1) = (/1,1/)  ! minIndex  1st deBlock
  deBlockList(:,2,1) = (/3,2/)  ! maxIndex  1st deBlock
  deBlockList(:,1,2) = (/4,1/)  ! minIndex  2nd deBlock
  deBlockList(:,2,2) = (/5,2/)  ! maxIndex  2nd deBlock
  deBlockList(:,1,3) = (/1,3/)
  deBlockList(:,2,3) = (/2,4/)
  deBlockList(:,1,4) = (/3,3/)
  deBlockList(:,2,4) = (/5,4/)
  deBlockList(:,1,5) = (/1,5/)
  deBlockList(:,2,5) = (/3,5/)
  deBlockList(:,1,6) = (/4,5/)  ! minIndex  6th deBlock
  deBlockList(:,2,6) = (/5,5/)  ! maxInbex  6th deBlock
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    deBlockList=deBlockList, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050133400000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> 2D multi-tile DistGrid with regular decomposition</A>
</H3>

<P>
Creating a DistGrid from a list of LR tiles is a straightforward
   extension of the single tile case. The first four 
   arguments of <TT>ESMF_DistGridCreate()</TT> are promoted to rank 2 where the 
   second dimension is the tile index.

<P>
The following 2D multi-tile domain consisting of 3 LR tiles will 
   be used in the examples of this section:
   <PRE>
  
     ----------------------------------------&gt; 2nd dim
     |
     |                   (1,11)-----(1,20)
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   (10,11)---(10,20)
     |  (11,1)----(11,10)(11,11)---(11,20)
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  (20,1)----(20,10)(20,11)---(20,20)
     |
     |
     v
    1st dim
</PRE>

<P>
The first step in creating a multi-tile global domain is to construct the
   <TT>minIndex</TT> and <TT>maxIndex</TT> arrays.
<P>
<PRE>
  allocate(minIndexPTile(2,3))    ! (dimCount, tileCount)
  allocate(maxIndexPTile(2,3))    ! (dimCount, tileCount)
  minIndexPTile(:,1) = (/11,1/)
  maxIndexPTile(:,1) = (/20,10/)
  minIndexPTile(:,2) = (/11,11/)
  maxIndexPTile(:,2) = (/20,20/)
  minIndexPTile(:,3) = (/1,11/)
  maxIndexPTile(:,3) = (/10,20/)
</PRE>

<P>
Next the regular decomposition for each tile is set up in the
   <TT>regDecomp</TT> array. In this example each tile is associated with a
   single DE.
<P>
<PRE>
  allocate(regDecompPTile(2,3))    ! (dimCount, tileCount)
  regDecompPTile(:,1) = (/1,1/)    ! one DE
  regDecompPTile(:,2) = (/1,1/)    ! one DE
  regDecompPTile(:,3) = (/1,1/)    ! one DE
</PRE>

<P>
Finally the DistGrid can be created by calling
 <PRE>
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, regDecompPTile=regDecompPTile, rc=rc)
</PRE>

<P>
The default DE labeling sequence is identical to the tile labeling sequence
   and follows the sequence in which the tiles are defined during the create
   call. However, DE labels start at 0 whereas tile labels start at 1. In this 
   case the DE labels look as:
   <PRE>
           2
       0   1
</PRE>

<P>
Each tile can be decomposed differently into DEs. The default DE labeling 
   follows the column major order for each tile. This is demonstrated in the
   following case where the multi-tile global domain is decomposed into 9 DEs,
<P>
<PRE>
  regDecompPTile(:,1) = (/2,2/)    ! 4 DEs
  regDecompPTile(:,2) = (/1,3/)    ! 3 DEs
  regDecompPTile(:,3) = (/2,1/)    ! 2 DEs
  
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, regDecompPTile=regDecompPTile, rc=rc)
</PRE>

<P>
resulting in the following decomposition:
   <PRE>
             +-------+
             |   7   |
             |       |
             |   8   |
     +-------+-------+
     | 0   2 |       |
     |       | 4 5 6 |
     | 1   3 |       |
     +-------+-------+
</PRE>

<P>
<PRE>
     DE 0 - (11,1)  ~ (15,5)
     DE 1 - (16,1)  ~ (20,5)
     DE 2 - (11,6)  ~ (15,10)
     DE 3 - (16,6)  ~ (20,10)
     DE 4 - (11,11) ~ (20,14)
     DE 5 - (11,15) ~ (20,17)
     DE 6 - (11,18) ~ (20,20)
     DE 7 - (1,11)  ~ (5,20)
     DE 8 - (6,11)  ~ (10,20)
</PRE>

<P>
The <TT>decompflag</TT> and <TT>deLabelList</TT> arguments can be used much like
   in the single LR domain case to overwrite the default grid decomposition 
   (per tile) and to change the overall DE labeling sequence, respectively. 

<P>

<H3><A NAME="SECTION050133500000000000000"></A>
   <A NAME="DistGrid:ArbitrarySeqInd"></A>
<BR>
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Arbitrary DistGrids with user-supplied sequence indices
</H3>

<P>
The third, and most flexible way of creating an ESMF DistGrid object is
   by specifying the arbitrary sequence indices of all the index space elements
   associated with a particular DE. The concept of sequence index
   comes into the DistGrid class through the support it implements for the 
   communication methods of higher classes: Arrays and Fields. This support
   is based by associating a unique <EM>sequence index</EM> with each
   DistGrid index tuple. The sequence index can be used to address every Array
   or Field element. By default, the DistGrid does not actually generate and
   store the sequence index of each element. Instead a default sequence through
   the elements is implemented in the DistGrid code. This default sequence 
   is used internally when needed.

<P>
The DistGrid class provides two <TT>ESMF_DistGridCreate()</TT> calls that 
   allow the user to specify arbitrary sequence indices, overriding the use of
   the default sequence index scheme. The user sequence indices are passed to
   the DistGrid in form of 1d Fortran arrays, one array on each PET. The local
   size of this array on each PET determines the number of DistGrid elements on
   the PET. The supplied sequence indices must be unique across all PETs. 
  
<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet ! initialize unique 
                                                   ! seq. indices
  enddo
</PRE>

<P>
A default DELayout will be created automatically during 
   <TT>ESMF_DistGridCreate()</TT>, associating 1 DE per PET.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, rc=rc)
</PRE>

<P>
The user provided sequence index array can be deallocated once it has
   been used.
<P>
<PRE>
  deallocate(arbSeqIndexList)
</PRE>

<P>
The <TT>distgrid</TT> object can be used just like any other DistGrid object.
   The "arbitrary" nature of <TT>distgrid</TT> will only become visible during
   Array or Field communication methods, where source and destination objects
   map elements according to the sequence indices provided by the associated
   DistGrid objects.
<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
The second <TT>ESMF_DistGridCreate()</TT> call, that accepts the 
   <TT>arbSeqIndexList</TT> argument, allows the user to specify additional,
   regular DistGrid dimensions. These additional DistGrid dimensions are not
   decomposed across DEs, but instead are simply "added" or "multiplied" to the
   1D arbitrary dimension.

<P>
The same <TT>arbSeqIndexList</TT> array as before is used to define the 
   user supplied sequence indices.
<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet  ! initialize unique 
                                                    ! seq. indices
  enddo
</PRE>

<P>
The additional DistGrid dimensions are specified in the usual manner using
   <TT>minIndex</TT> and <TT>maxIndex</TT> arguments. The <TT>dimCount</TT> of the
   resulting DistGrid is the size of the <TT>minIndex</TT> and <TT>maxIndex</TT>
   arguments plus 1 for the arbitrary dimension. The <TT>arbDim</TT> argument is
   used to indicate which or the resulting DistGrid dimensions
   is associated with the arbitrary sequence indices provided by the user.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, &amp;
    arbDim=1, minIndexPTile=(/1,1/), maxIndexPTile=(/5,7/), rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arbSeqIndexList)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050133600000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> DistGrid Connections - Definition</A>
</H3>

<P>
By default all of the edges of the index space tiles making up a DistGrid
   are open. There is no sense of connectedness between the tiles. This situation
   is shown for a simple 2 tile DistGrid.
<P>
<PRE>
  allocate(minIndexPTile(2,2))    ! (dimCount, tileCount)
  allocate(maxIndexPTile(2,2))    ! (dimCount, tileCount)
  minIndexPTile(:,1) = (/1,1/)
  maxIndexPTile(:,1) = (/10,10/)
  minIndexPTile(:,2) = (/11,1/)
  maxIndexPTile(:,2) = (/20,10/)
  
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, rc=rc)
</PRE>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_2tiles_not_connected"></A><A NAME="70233"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 21:</STRONG>
Two 10x10 index space tiles next to each other without
       connections. Both tiles operate in the same global index space chosen 
       by <TT>ESMF_INDEX_GLOBAL</TT> when creating the DistGrid object.
       The index tuples held by the DistGrid are represented by the vertices of
       the shown grid structure. The index tuple (11,3), which is referenced in
       the text, is marked by a black circle.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="698" HEIGHT="342" ALIGN="BOTTOM" BORDER="0"
 SRC="img117.png"
 ALT="\includegraphics{dgconnect_2tiles_not_connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
Connections between index space tiles are specified during DistGrid
   creation through the <TT>connectionList</TT> argument. This argument takes
   a list of elements of <TT>type(ESMF_DistGridConnection)</TT>. Each element
   refers to one specific connection between any two tiles.

<P>
Each connection is defined by 4 parameters:
   
<UL>
<LI><TT>tileIndexA</TT> - The tile index of the "A" side of the connection.
</LI>
<LI><TT>tileIndexB</TT> - The tile index of the "B" side of the connection.
</LI>
<LI><TT>positionVector</TT> - A vector containing information about the
                                translation of the index space of tile "B" 
                                relative to tile "A". This vector has as many
                                components as there are index space dimensions.
</LI>
<LI><TT>orientationVector</TT> - A vector containing information about
                                   the rotation of the index space of tile "B"
                                   relative to tile "A". This vector has as many
                                   components as there are index space dimensions.
   
</LI>
</UL>

<P>
The underlying principle of the DistGrid connections is that all supported
   connections can be written as a forward transformation of the form
   <BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\vec a \rightarrow \vec b = \hat R \vec a + \vec P.
\end{equation}
 -->
<A NAME="eqn:dg_forward_connect_form"></A>
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eqn:dg_forward_connect_form"></A><IMG
 WIDTH="116" HEIGHT="57" BORDER="0"
 SRC="img118.png"
 ALT="\begin{displaymath}
\vec a \rightarrow \vec b = \hat R \vec a + \vec P.
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">4</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
This transform takes the index space tuple <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img119.png"
 ALT="$\vec a$"></SPAN> of a point in the 
   reference frame of tile "A" and expresses it as tuple <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img120.png"
 ALT="$\vec b$"></SPAN> in terms of
   the index space defined by tile "B". Here <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN>
   is a general rotation operator, and <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img122.png"
 ALT="$\vec P$"></SPAN> is a translation vector in index
   space. <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img122.png"
 ALT="$\vec P$"></SPAN> correspond to the <TT>orientationVector</TT> and
   <TT>positionVector</TT>, respectively.

<P>
As an example consider the index space point marked by the black circle in
   figure <A HREF="#fig:dgconnect_2tiles_not_connected">21</A>. In the reference frame of
   tile 1 the point has an index tuple of (11,3). Because of the global index
   space (<TT>ESMF_INDEX_GLOBAL</TT>), the point has the same index
   tuple of (11,3) in the reference frame of tile 2. Therefore, the connection
   that connects the right edge of tile 1 with the left edge of tile 2 has
   <!-- MATH
 $\hat R ={1\!\!1}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="48" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img123.png"
 ALT="$\hat R ={1\!\!1}$"></SPAN> (default orientation) and <!-- MATH
 $\vec P = (0,0)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="73" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img124.png"
 ALT="$\vec P = (0,0)$"></SPAN>. Therefore 
   the connection can be set by the following code. The resulting situation is
   shown in figure <A HREF="#fig:dgconnect_2tiles_connected">22</A>.
<P>
<PRE>
  allocate(connectionList(1))
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp;
    tileIndexA=1, tileIndexB=2, positionVector=(/0,0/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, connectionList=connectionList, &amp;
    rc=rc)  ! defaults to ESMF_INDEX_GLOBAL
</PRE>

<P>
The same topology can be defined for <TT>ESMF_INDEX_DELOCAL</TT> indexing.
   However, the <TT>positionVector</TT> must be adjusted for the fact that now
   the same point in index space has different index tuples depending on what
   tile's reference frame is used.

<P>
With local indexing both tiles start at (1,1) and end at (10,10).
<P>
<PRE>
  allocate(minIndexPTile(2,2))    ! (dimCount, tileCount)
  allocate(maxIndexPTile(2,2))    ! (dimCount, tileCount)
  minIndexPTile(:,1) = (/1,1/)
  maxIndexPTile(:,1) = (/10,10/)
  minIndexPTile(:,2) = (/1,1/)
  maxIndexPTile(:,2) = (/10,10/)
</PRE>

<P>
To see the impact that the index scheme has on the <TT>positionVector</TT>,
   again consider the same highlighted index space point. The index tuple
   for this point is still (11,3) in the reference frame of tile 1 (tile "A" of
   the connection). However, in the reference frame of of tile 2 
   (tile "B" of the connection)) it has changed to (1,3) due to local indexing.
   Therefore, using form (<A HREF="#eqn:dg_forward_connect_form">4</A>), we find that the
   position vector must be <!-- MATH
 $\vec P = \vec b - \vec a = (1,3) - (11,3) = (-10,0)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="269" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img125.png"
 ALT="$\vec P = \vec b - \vec a = (1,3) - (11,3) = (-10,0)$"></SPAN>.
<P>
<PRE>
  allocate(connectionList(1))
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp;
    tileIndexA=1, tileIndexB=2, positionVector=(/-10,0/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, connectionList=connectionList, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_2tiles_connected"></A><A NAME="69885"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 22:</STRONG>
Two 10x10 index space tiles next to each other with a single
       connection between the right edge of tile 1 and the left edge of tile 2.
       The index tuple (11,3), which is referenced in
       the text, is marked by a black circle.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="698" HEIGHT="342" ALIGN="BOTTOM" BORDER="0"
 SRC="img126.png"
 ALT="\includegraphics{dgconnect_2tiles_connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
Further note that every forward transformation has an associated inverse, or
   backward transformation from tile "B" into the reference frame of tile "A". 
   Inverting the forward transform yields the backward transform as
   <BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\vec b \rightarrow \vec a = \hat R^{-1} \vec b - \hat R^{-1} \vec P.
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="161" HEIGHT="26" BORDER="0"
 SRC="img127.png"
 ALT="\begin{displaymath}
\vec b \rightarrow \vec a = \hat R^{-1} \vec b - \hat R^{-1} \vec P.
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">5</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
The DistGrid implicitly considers the corresponding backward connection for 
   every forward connection that is specified explicitly. In other words,
   DistGrid connections are bidirectional.

<P>
Before going into the details of how the <TT>orientationVector</TT> and 
   <TT>positionVector</TT> arguments correspond to <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN> and <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img122.png"
 ALT="$\vec P$"></SPAN> for more
   complex cases, it is useful to explore what class of connections are covered
   by the above introduced form (<A HREF="#eqn:dg_forward_connect_form">4</A>) of
   <!-- MATH
 $\vec a \rightarrow \vec b$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="44" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img128.png"
 ALT="$\vec a \rightarrow \vec b$"></SPAN>.

<P>
First consider the case where tile "A" is rotated by <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN>
   relative to tile "B" around a general pivot point <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img129.png"
 ALT="$\vec p$"></SPAN> given in terms 
   of the index space of tile "A":

<P>
<BR>
<DIV ALIGN="CENTER"><A NAME="eqn:dg_forward_connect_pivot"></A>
<!-- MATH
 \begin{eqnarray}
\vec a \rightarrow \vec b & = & \hat R (\vec a - \vec p) + \vec p \nonumber \\
     & = & \hat R \vec a +  ({1\!\!1} - \hat R) \vec p
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG
 WIDTH="44" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img130.png"
 ALT="$\displaystyle \vec a \rightarrow \vec b$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="92" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img132.png"
 ALT="$\displaystyle \hat R (\vec a - \vec p) + \vec p$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="107" HEIGHT="39" ALIGN="MIDDLE" BORDER="0"
 SRC="img133.png"
 ALT="$\displaystyle \hat R \vec a + ({1\!\!1} - \hat R) \vec p$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">6</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
With substitution 
   <BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\vec P = ({1\!\!1} - \hat R) \vec p
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="98" HEIGHT="29" BORDER="0"
 SRC="img134.png"
 ALT="\begin{displaymath}
\vec P = ({1\!\!1} - \hat R) \vec p
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">7</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
form (<A HREF="#eqn:dg_forward_connect_form">4</A>) is recovered.

<P>
Next consider transform (<A HREF="#eqn:dg_forward_connect_pivot">6</A>) followed by
   a translation <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="23" ALIGN="BOTTOM" BORDER="0"
 SRC="img135.png"
 ALT="$\vec t$"></SPAN> of tile "B" relative to tile "A":

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\vec a \rightarrow \vec b =
     \hat R \vec a +  ({1\!\!1} - \hat R) \vec p + \vec t.
\end{equation}
 -->
<A NAME="eqn:dg_forward_connect_pivot_trans"></A>
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eqn:dg_forward_connect_pivot_trans"></A><IMG
 WIDTH="192" HEIGHT="61" BORDER="0"
 SRC="img136.png"
 ALT="\begin{displaymath}
\vec a \rightarrow \vec b =
\hat R \vec a + ({1\!\!1} - \hat R) \vec p + \vec t.
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">8</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
Again form (<A HREF="#eqn:dg_forward_connect_form">4</A>) is recovered with the 
   appropriate subsitution:
   <BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\vec P = ({1\!\!1} - \hat R) \vec p + \vec t.
\end{equation}
 -->
<A NAME="eqn:dg_forward_connect_pivot_trans_pv"></A>
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eqn:dg_forward_connect_pivot_trans_pv"></A><IMG
 WIDTH="124" HEIGHT="61" BORDER="0"
 SRC="img137.png"
 ALT="\begin{displaymath}
\vec P = ({1\!\!1} - \hat R) \vec p + \vec t.
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">9</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
Equation (<A HREF="#eqn:dg_forward_connect_pivot_trans_pv">9</A>) is the general
   definition of the <TT>positionVector</TT> argument for DistGrid connections.
   It allows two tiles to be connected according to the relationship expressed
   by (<A HREF="#eqn:dg_forward_connect_pivot_trans">8</A>). Note that this formualation of
   tile connections is more general than connecting an edge of a tile to the
   edge of another tile. Instead a DistGrid connection is specified as a general 
   relationship between the two index spaces, accounting for possible rotation 
   and translation. This formuation supports situations where some elements of
   the connected tiles overlap with each other in index space. The ESMF 
   DistGrid class leverages this feature when representing topologies that
   lead to redundancies of elements. Examples for this are the bipolar cut line
   in a tripole grid, or the edges of a cubed sphere.

<P>
By definition, DistGrid connections associate an index tuple of one tile
   with exactly one index tuple expressed in the reference frame of another tile.
   This restricts the supported rotations <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN> to multiples of <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img138.png"
 ALT="$90^{\circ}$"></SPAN>.
   Also allowing invesion of index space dimensions leads to 8 unique 
   operations in two dimension shown in table <A HREF="#tab:dg_ops">3</A>.

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
   <DIV ALIGN="CENTER">

</DIV>   
   <A NAME="tab:dg_ops"></A>   <A NAME="70234"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 3:</STRONG>
The 8 unique rotational operations in 2 dimensional index space. The
   associated <TT>orientationVector</TT> argument for each operation is also shown.</CAPTION>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER">&nbsp;</TD>
<TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN></TD>
<TD ALIGN="CENTER"><TT>orientationVector</TT></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img139.png"
 ALT="$0^{\circ}$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{rr}
      1 & 0 \\
      0 & 1 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img140.png"
 ALT="$\left( \begin{array}{rr}
1 &amp; 0 \\
0 &amp; 1 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{r}
      1 \\
      2 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="51" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img141.png"
 ALT="$\left( \begin{array}{r}
1 \\
2 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img138.png"
 ALT="$90^{\circ}$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{rr}
      0 & -1 \\
      1 & 0 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="88" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img142.png"
 ALT="$\left( \begin{array}{rr}
0 &amp; -1 \\
1 &amp; 0 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{r}
      -2 \\
      1 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img143.png"
 ALT="$\left( \begin{array}{r}
-2 \\
1 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img144.png"
 ALT="$180^{\circ}$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{rr}
      -1 & 0 \\
      0 & -1 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="100" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img145.png"
 ALT="$\left( \begin{array}{rr}
-1 &amp; 0 \\
0 &amp; -1 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{r}
      -1 \\
      -2 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img146.png"
 ALT="$\left( \begin{array}{r}
-1 \\
-2 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img147.png"
 ALT="$270^{\circ}$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{rr}
      0 & 1 \\
      -1 & 0 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="88" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img148.png"
 ALT="$\left( \begin{array}{rr}
0 &amp; 1 \\
-1 &amp; 0 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{r}
      2 \\
      -1 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img149.png"
 ALT="$\left( \begin{array}{r}
2 \\
-1 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img139.png"
 ALT="$0^{\circ}$"></SPAN> + inversion dim 1</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{rr}
      -1 & 0 \\
      0 & 1 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="88" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img150.png"
 ALT="$\left( \begin{array}{rr}
-1 &amp; 0 \\
0 &amp; 1 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{r}
      -1 \\
      2 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img151.png"
 ALT="$\left( \begin{array}{r}
-1 \\
2 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="19" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img139.png"
 ALT="$0^{\circ}$"></SPAN> + inversion dim 2</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{rr}
      1 & 0 \\
      0 & -1 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="88" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img152.png"
 ALT="$\left( \begin{array}{rr}
1 &amp; 0 \\
0 &amp; -1 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{r}
      1 \\
      -2 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img153.png"
 ALT="$\left( \begin{array}{r}
1 \\
-2 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img138.png"
 ALT="$90^{\circ}$"></SPAN> + inversion dim 1</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{rr}
      0 & 1 \\
      1 & 0 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="75" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img154.png"
 ALT="$\left( \begin{array}{rr}
0 &amp; 1 \\
1 &amp; 0 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{r}
      2 \\
      1 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="51" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img155.png"
 ALT="$\left( \begin{array}{r}
2 \\
1 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD><TD ALIGN="CENTER"><SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img138.png"
 ALT="$90^{\circ}$"></SPAN> + inversion dim 2</TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{rr}
      0 & -1 \\
      -1 & 0 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="100" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img156.png"
 ALT="$\left( \begin{array}{rr}
0 &amp; -1 \\
-1 &amp; 0 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="CENTER"><!-- MATH
 $\left( \begin{array}{r}
      -2 \\
      -1 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="64" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img157.png"
 ALT="$\left( \begin{array}{r}
-2 \\
-1 \end{array} \right)$"></SPAN></TD>
<TD ALIGN="LEFT">&nbsp;</TD></TR>
</TABLE>
</DIV>
<BR>

<P>
The <TT>orientationVector</TT> is simply a more compact format holding the same 
   information provided by the 8 rotational matrices. The first (or top) element
   of the orientation vector indicates which dimension of the tile "A" index
   tuple is used for the first dimension of the tile "B" tuple. The second 
   (or bottom) element of the orientation vector indicates which dimension of the
   tile "A" index tuple is used for the second dimenson of the tile "B" tuple.
   If an orientation vector entry is negative, the sign of the associated
   tuple element is inverted when going from tile "A" to tile "B" reference 
   frame. Table <A HREF="#tab:dg_ops">3</A> provides the corresponding 
   <TT>orientationVector</TT> argument for each of the 8 2D rotational operations. 

<P>

<H3><A NAME="SECTION050133700000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> DistGrid Connections - Single tile periodic and pole connections</A>
</H3>

<P>
The concept of DistGrid connections is not limited to cases with multiple
   tiles. Even a single tile DistGrid can have connections. In this instance
   <TT>tileA</TT> and <TT>tileB</TT> simply reference the same tile. A very common
   case is that of a single tile with periodic boundary conditions.

<P>
First consider a single tile DistGrid without connections.
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/50,20/), rc=rc)
</PRE>

<P>
In order to better visualize the topology, the first index space
   dimension is associated with the longitude (<!-- MATH
 $0^{\circ}..360^{\circ}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="59" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img158.png"
 ALT="$0^{\circ}..360^{\circ}$"></SPAN>), and
   the second dimension with latitude (<!-- MATH
 $-80^{\circ}..+80^{\circ}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="91" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img159.png"
 ALT="$-80^{\circ}..+80^{\circ}$"></SPAN>) of the unit
   sphere (using an ESMF_Grid object) as shown in figure 
   <A HREF="#fig:dgconnect_1tile_not_connected">23</A>.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_1tile_not_connected"></A><A NAME="69998"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 23:</STRONG>
A single 50x20 index space tile without connections. For better
       visualization the index space points are plotted on the unit circle.
       The gap between the right and left edge of the tile is visible. Further
       the top and the bottom edges of the tile are visibly without
       connection.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="455" HEIGHT="489" ALIGN="BOTTOM" BORDER="0"
 SRC="img160.png"
 ALT="\includegraphics{dgconnect_1tile_not_connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
A single DistGrid connection is needed to connect the right edge of the 
   index space tile with its left edge. Connecting a tile with itself in such
   manner leads to a periodic topology.

<P>
First the <TT>connectionList</TT> needs to be allocated for a single connection.
   Then the connection is defined with both <TT>tileIndexA</TT> and 
   <TT>tileIndexB</TT> set to 1, referring to the first, and only tile in this case.
<P>
<PRE>
  allocate(connectionList(1))
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp;
    tileIndexA=1, tileIndexB=1, positionVector=(/-50,0/), rc=rc)
</PRE>

<P>
The <TT>positionVector</TT> is determined by transformation 
   (<A HREF="#eqn:dg_forward_connect_form">4</A>), the fact that there is no rotation 
   involved, and that stepping over the right edge needs to connect back to
   the left edge. Therefore <!-- MATH
 $\vec P = \vec b - \vec a = (1,j) - (51,j) =
   (-50,0)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="268" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img161.png"
 ALT="$\vec P = \vec b - \vec a = (1,j) - (51,j) =
(-50,0)$"></SPAN>. Here <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> stands for an arbitrary value along the second index 
   space dimension.

<P>
Creating a DistGrid on the same index space tile, but with this connection,
   results in a periodic boundary condition along the first dimension.
   This is shown in figure <A HREF="#fig:dgconnect_1tile_periodic1_connected">24</A>. 
  
<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/50,20/), &amp;
    connectionList=connectionList, rc=rc)
</PRE>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_1tile_periodic1_connected"></A><A NAME="70013"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 24:</STRONG>
A single 50x20 index space tile with periodic connection along
       the first dimension.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="455" HEIGHT="489" ALIGN="BOTTOM" BORDER="0"
 SRC="img162.png"
 ALT="\includegraphics{dgconnect_1tile_periodic1_connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
In general it is more useful to express the position vector of a connection
   in terms of the tile minIndex and maxIndex components. For this we define the
   same index space tile in a set of variables.
<P>
<PRE>
  allocate(minIndex(2))    ! (dimCount)
  allocate(maxIndex(2))    ! (dimCount)
  minIndex(:) = (/1,1/)
  maxIndex(:) = (/50,20/)
</PRE>

<P>
Now we can code any connection on this tile in terms of <TT>minIndex</TT> and
   <TT>maxIndex</TT>. For purpose of demonstration we define periodic boundary
   conditions along both index space dimensions. The resulting torus topology
   is depicted in figure <A HREF="#fig:dgconnect_1tile_periodic2_connected">25</A>. 
<P>
<PRE>
  allocate(connectionList(2))
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp; ! 1st connection
    tileIndexA=1, tileIndexB=1, &amp;   ! periodic along i
    positionVector=(/ -(maxIndex(1)-minIndex(1)+1) , 0/), &amp;  
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridConnectionSet(connection=connectionList(2), &amp; ! 2nd connection
    tileIndexA=1, tileIndexB=1, &amp;   ! periodic along j
    positionVector=(/ 0 , -(maxIndex(2)-minIndex(2)+1) /), &amp;  
    rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=minIndex, maxIndex=maxIndex, &amp;
    connectionList=connectionList, rc=rc)
</PRE>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_1tile_periodic2_connected"></A><A NAME="70029"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 25:</STRONG>
A single 50x20 index space tile with periodic connections
      along both directions. The topology is that of a torus, however, because
      of the chosen spherical coordinates the connection through the middle 
      has the shape of a cylinder.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="496" HEIGHT="481" ALIGN="BOTTOM" BORDER="0"
 SRC="img163.png"
 ALT="\includegraphics{dgconnect_1tile_periodic2_connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
While the topology shown in figure 
   <A HREF="#fig:dgconnect_1tile_periodic2_connected">25</A> is that of a torus, the 
   coordinates chosen are actually those of a sphere. Next we replace
   the periodic connection along <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> (i.e. the second index space dimension) 
   with a more fitting pole connection at the top of the sphere 
   (i.e. at <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$j_{max}$"></SPAN>).

<P>
For the orientation vector associated with a regular pole connection at 
   <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$j_{max}$"></SPAN> we first look at how the two index space directions are affected. 
   Looking at a point with <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$i$"></SPAN> along the first dimension, and a second point
   <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img164.png"
 ALT="$i+1$"></SPAN> that is just to the right of the first point, we see that as the 
   pole is being crossed, the second point maps just right of the first point.
   Therefore, the orientation of the first index space dimension is unaffected
   by the pole connection. However, for the second dimension we find that
   increasing <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> on one side corresponds to a dereasing <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> across the pole.
   We thus have found the general fact that <TT>orientationVector=(1,-2)</TT> for
   a pole connection across the <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> direction.

<P>
In order to find the position vector of the polar connection we consider 
   starting at a general point (<SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$i$"></SPAN>,<SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$j_{max}$"></SPAN>) at the top edge of the tile. 
   Crossing the pole this takes us to a point that is again right on the 
   top edge with <SPAN CLASS="MATH"><IMG
 WIDTH="66" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img165.png"
 ALT="$j=j_{max}$"></SPAN>, and is <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img166.png"
 ALT="$180^\circ$"></SPAN> rotated along the first 
   dimension. This means <!-- MATH
 $i=mod(i+i_{size}/2, i_{size})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="180" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img167.png"
 ALT="$i=mod(i+i_{size}/2, i_{size})$"></SPAN>, with <!-- MATH
 $i_{size}=i_{max}
   -i_{min}+1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="163" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img168.png"
 ALT="$i_{size}=i_{max}
-i_{min}+1$"></SPAN>.
   In practice the modulo operation is automatically taken care of by the
   periodic connection along <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$i$"></SPAN>. We can therefore write:

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\vec a = \left( \begin{array}{l}
      i \\
      j_{max}+1 \end{array} \right)
   \rightarrow
   \vec b = \left( \begin{array}{l}
      i + i_{size}/2\\
      j_{max} \end{array} \right).
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="297" HEIGHT="45" BORDER="0"
 SRC="img169.png"
 ALT="\begin{displaymath}
\vec a = \left( \begin{array}{l}
i \\
j_{max}+1 \end{arr...
...in{array}{l}
i + i_{size}/2\\
j_{max} \end{array} \right).
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">10</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
Using this observation, together with table <A HREF="#tab:dg_ops">3</A> to 
   translate the polar <TT>orientationVector</TT> into a standard rotation 
   operation <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN>, we get the position vector from equation
   (<A HREF="#eqn:dg_forward_connect_form">4</A>):

<P>
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
\vec P & = & \vec b - \hat R \vec a \nonumber \\
          & = & \left( \begin{array}{l}
      i + i_{size}/2\\
      j_{max} \end{array} \right)
   - \left( \begin{array}{rr}
   1 & 0 \\
   0 & -1 \end{array} \right)
   \left( \begin{array}{l}
      i \\
      j_{max}+1 \end{array} \right) \nonumber \\
          & = & \left( \begin{array}{l}
      i_{size}/2\\
      2j_{max} +1 \end{array} \right).
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG
 WIDTH="17" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img170.png"
 ALT="$\displaystyle \vec P$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="51" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img171.png"
 ALT="$\displaystyle \vec b - \hat R \vec a$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="319" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img172.png"
 ALT="$\displaystyle \left( \begin{array}{l}
i + i_{size}/2\\
j_{max} \end{array} \ri...
...\end{array} \right)
\left( \begin{array}{l}
i \\
j_{max}+1 \end{array} \right)$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="119" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img173.png"
 ALT="$\displaystyle \left( \begin{array}{l}
i_{size}/2\\
2j_{max} +1 \end{array} \right).$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">11</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
<P>
<PRE>
  allocate(connectionList(2))
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp; ! 1st connection
    tileIndexA=1, tileIndexB=1, &amp;   ! periodic along i
    positionVector=(/-(maxIndex(1)-minIndex(1)+1),0/), &amp; 
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridConnectionSet(connection=connectionList(2), &amp; ! 2nd connection
    tileIndexA=1, tileIndexB=1, &amp;   ! pole at j_max
    orientationVector=(/1,-2/), &amp;
    positionVector=(/ (maxIndex(1)-minIndex(1)+1)/2 , 2*maxIndex(2)+1 /), &amp; 
    rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=minIndex, maxIndex=maxIndex, &amp;
    connectionList=connectionList, rc=rc)
</PRE>

<P>
The pole connection at <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$j_{max}$"></SPAN> can clearly be seen in figure 
   <A HREF="#fig:dgconnect_1tile_peripole_connected">26</A>. Note that the chosen perspective 
   hides the fact that the lower edge of the index space tile remains open.
   In other words there is still a hole at the bottom of the sphere that cannot
   be seen. Only three of the four sides have been connected so far: 
   The first connection
   connects the left and the right tile edges. The second connection connects
   the top edge to itself to form the pole. A third connection would be needed,
   e.g. to form a pole at the bottom edge much like the top edge.
   This would then complete a perfectly spherical topology with a single tile.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_1tile_peripole_connected"></A><A NAME="70236"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 26:</STRONG>
A single 50x20 index space tile with periodic connection
      along <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$i$"></SPAN>, and pole at <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$j_{max}$"></SPAN>. The hole at <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$j_{min}$"></SPAN> is hidden from
      sight.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="505" HEIGHT="485" ALIGN="BOTTOM" BORDER="0"
 SRC="img174.png"
 ALT="\includegraphics{dgconnect_1tile_peripole_connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
The final single tile topology discussed in this section is that of a tripole.
   A tripolar sphere has the typical spherical periodic boundary condition
   along one direction (e.g. connecting the left and the right tile edge), and a
   regular monopole at one of the other edges of the tile. However, instead
   of defining a second monopole at the opposite edge, a <EM>bipole</EM> connection
   is chosen.

<P>
Topologically a bipole connection can be thought of folding the respective
   edge at the middle point back onto itself. Assuming the bipole at the top 
   edge, i.e. at <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$j_{max}$"></SPAN>, we get mappings across the bipole of 
   <!-- MATH
 $(i_{min}, j_{max}+1) \rightarrow (i_{max}, j_{max})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="222" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img175.png"
 ALT="$(i_{min}, j_{max}+1) \rightarrow (i_{max}, j_{max})$"></SPAN>,
   <!-- MATH
 $(i_{min}+1, j_{max}+1) \rightarrow (i_{max}-1, j_{max})$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="277" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img176.png"
 ALT="$(i_{min}+1, j_{max}+1) \rightarrow (i_{max}-1, j_{max})$"></SPAN>, and so forth. 
   This means that 
   compared to the regular pole connection, the bipolar orientation vector
   reverses the <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$i$"></SPAN> direction in addition to the <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> direction: 
   <TT>orientationVector=(-1,-2)</TT>.

<P>
Using the bipolar mapping just mentioned for a point at <SPAN CLASS="MATH"><IMG
 WIDTH="34" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img177.png"
 ALT="$i_{min}$"></SPAN>, together
   with table <A HREF="#tab:dg_ops">3</A> to translate the polar <TT>orientationVector</TT>
   into a standard rotation  operation <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN>, we can solve for the position
   vector according to equation (<A HREF="#eqn:dg_forward_connect_form">4</A>):

<P>
<BR>
<DIV ALIGN="CENTER">

<!-- MATH
 \begin{eqnarray}
\vec P & = & \vec b - \hat R \vec a \nonumber \\
          & = & \left( \begin{array}{l}
      i_{max}\\
      j_{max} \end{array} \right)
   - \left( \begin{array}{rr}
   -1 & 0 \\
   0 & -1 \end{array} \right)
   \left( \begin{array}{l}
      i_{min} \\
      j_{max}+1 \end{array} \right) \nonumber \\
          & = & \left( \begin{array}{l}
      i_{max}+i_{min}\\
      2j_{max} +1 \end{array} \right).
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG
 WIDTH="17" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img170.png"
 ALT="$\displaystyle \vec P$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="51" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img171.png"
 ALT="$\displaystyle \vec b - \hat R \vec a$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="294" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img178.png"
 ALT="$\displaystyle \left( \begin{array}{l}
i_{max}\\
j_{max} \end{array} \right)
- ...
...rray} \right)
\left( \begin{array}{l}
i_{min} \\
j_{max}+1 \end{array} \right)$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img131.png"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="132" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img179.png"
 ALT="$\displaystyle \left( \begin{array}{l}
i_{max}+i_{min}\\
2j_{max} +1 \end{array} \right).$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">12</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>

<P>
Figure <A HREF="#fig:dgconnect_1tile_peribipole_connected">27</A> visualizes the
   bipolar topology at the top edge of the tile. Note, however, that the 
   coordinates are perfectly spherical. Consequently there is no "drawing
   shut" of the cut line as would be expected for a true bipolar geometry. 
   Still, the two poles are becoming visible at the two opposing
   ends of the top circle, where the distance between the connection lines is
   starting to go to zero.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_1tile_peribipole_connected"></A><A NAME="70237"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 27:</STRONG>
A single 50x20 index space tile with periodic connection
      along <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$i$"></SPAN>, and bi-pole at <SPAN CLASS="MATH"><IMG
 WIDTH="37" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$j_{max}$"></SPAN>. The regular pole connection
      at <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$j_{min}$"></SPAN> is hidden from sight.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="505" HEIGHT="486" ALIGN="BOTTOM" BORDER="0"
 SRC="img180.png"
 ALT="\includegraphics{dgconnect_1tile_peribipole_connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
<PRE>
  allocate(connectionList(3))
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp; ! 1st connection
    tileIndexA=1, tileIndexB=1, &amp;   ! periodic along i
    positionVector=(/-(maxIndex(1)-minIndex(1)+1),0/), &amp; 
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridConnectionSet(connection=connectionList(2), &amp; ! 2nd connection
    tileIndexA=1, tileIndexB=1, &amp;   ! pole at j_min
    orientationVector=(/1,-2/), &amp;
    positionVector=(/ (maxIndex(1)-minIndex(1)+1)/2 , 2*minIndex(2)+1 /), &amp; 
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridConnectionSet(connection=connectionList(3), &amp; ! 3rd connection
    tileIndexA=1, tileIndexB=1, &amp;   ! bi-pole at j_max
    orientationVector=(/-1,-2/), &amp;
    positionVector=(/ maxIndex(1)+minIndex(1) , 2*maxIndex(2)+1 /), &amp; 
    rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=minIndex, maxIndex=maxIndex, &amp;
    connectionList=connectionList, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050133800000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> DistGrid Connections - Multi tile connections</A>
</H3>

<P>
Starting point of the multi-tile connection examples will be the 
   six tile case shown in figure <A HREF="#fig:dgconnect_cusph_not_connected">28</A>. 
   All six tiles are identical squares of size 10x10.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_cusph_not_connected"></A><A NAME="70145"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 28:</STRONG>
Six 10x10 square index space tiles without connections. The tile
      number is indicated by color as indicated by the legend.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="555" HEIGHT="422" ALIGN="BOTTOM" BORDER="0"
 SRC="img181.png"
 ALT="\includegraphics{dgconnect_cusph_not_connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
One geometrical interpretation of the six tiles shown is that of an unfolded 
   cube. In fact, the way that the tiles are arranged in the 2D plane does 
   suggest the cubic interpretation. In order to turn the six tiles into a 
   cubic topology, each tile must be connected to its neighbors on all four 
   sides. In total there will be 12 connections that need to be made.

<P>
Choosing global indexing, the depicted six tile case can be created
   in the following way:
<P>
<PRE>
  allocate(minIndexPTile(2,6))    ! (dimCount, tileCount)
  allocate(maxIndexPTile(2,6))    ! (dimCount, tileCount)
  size = 10                       ! number of index space points along tile sides
  !- tile 1
  tile=1
  minIndexPTile(1,tile)=1
  minIndexPTile(2,tile)=1
  maxIndexPTile(1,tile)=minIndexPTile(1,tile)+size-1
  maxIndexPTile(2,tile)=minIndexPTile(2,tile)+size-1
  !- tile 2
  tile=2
  minIndexPTile(1,tile)=maxIndexPTile(1,tile-1)+1
  minIndexPTile(2,tile)=minIndexPTile(2,tile-1)
  maxIndexPTile(1,tile)=minIndexPTile(1,tile)+size-1
  maxIndexPTile(2,tile)=minIndexPTile(2,tile)+size-1
  !- tile 3
  tile=3
  minIndexPTile(1,tile)=minIndexPTile(1,tile-1)
  minIndexPTile(2,tile)=maxIndexPTile(2,tile-1)+1
  maxIndexPTile(1,tile)=minIndexPTile(1,tile)+size-1
  maxIndexPTile(2,tile)=minIndexPTile(2,tile)+size-1
  !- tile 4
  tile=4
  minIndexPTile(1,tile)=maxIndexPTile(1,tile-1)+1
  minIndexPTile(2,tile)=minIndexPTile(2,tile-1)
  maxIndexPTile(1,tile)=minIndexPTile(1,tile)+size-1
  maxIndexPTile(2,tile)=minIndexPTile(2,tile)+size-1
  !- tile 5
  tile=5
  minIndexPTile(1,tile)=minIndexPTile(1,tile-1)
  minIndexPTile(2,tile)=maxIndexPTile(2,tile-1)+1
  maxIndexPTile(1,tile)=minIndexPTile(1,tile)+size-1
  maxIndexPTile(2,tile)=minIndexPTile(2,tile)+size-1
  !- tile 6
  tile=6
  minIndexPTile(1,tile)=maxIndexPTile(1,tile-1)+1
  minIndexPTile(2,tile)=minIndexPTile(2,tile-1)
  maxIndexPTile(1,tile)=minIndexPTile(1,tile)+size-1
  maxIndexPTile(2,tile)=minIndexPTile(2,tile)+size-1
  
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, rc=rc)
</PRE>

<P>
The five connections between tiles 1&amp;2, 2&amp;3, 3&amp;4, 4&amp;5, 5&amp;6 are trivial.
   There are no rotations, which means that the <TT>orientationVector</TT> argument
   can be ommitted in these connections. Further, because of the global index 
   space, there are no translations either, which means that 
   <TT>positionVector</TT>=(0,0) for these five connections. The resulting
   topology is shown in figure <A HREF="#fig:dgconnect_cusph_5connected">29</A>.
<P>
<PRE>
  allocate(connectionList(5))
  !- connection 1
  conn=1
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=1, tileIndexB=2, positionVector=(/0, 0/), rc=rc)
  !- connection 2
  conn=2
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=2, tileIndexB=3, positionVector=(/0, 0/), rc=rc)
  !- connection 3
  conn=3
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=3, tileIndexB=4, positionVector=(/0, 0/), rc=rc)
  !- connection 4
  conn=4
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=4, tileIndexB=5, positionVector=(/0, 0/), rc=rc)
  !- connection 5
  conn=5
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=5, tileIndexB=6, positionVector=(/0, 0/), rc=rc)

  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, connectionList=connectionList, rc=rc)
</PRE>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_cusph_5connected"></A><A NAME="70157"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 29:</STRONG>
The six tiles of an unfolded cube with five connections defined.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="555" HEIGHT="422" ALIGN="BOTTOM" BORDER="0"
 SRC="img182.png"
 ALT="\includegraphics{dgconnect_cusph_5connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
The sixth connection that does not involve a rotation is that between tile
   1&amp;6. While there is no rotation involved, it does include a translation
   because the bottom edge of tile 1 must reach all the way to the top edge 
   of tile 6. This involves a translation along both the <SPAN CLASS="MATH"><IMG
 WIDTH="10" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$i$"></SPAN> and the <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> 
   dimension. 

<P>
Using the same procedure introduced in the previous section, we chose an
   arbitrary index space point close to the connection and write it in terms
   of both tiles that we want to connect. E.g. the first point of the top 
   edge of tile 6 is

<P>
<TT>( minIndexPTile(1,6) , maxIndexPTile(2,6) )</TT> 

<P>
in terms of tile 6. However,
   in terms of tile 1, going through the connection, it is

<P>
<TT>( minIndexPTile(1,1) , minIndexPTile(2,1)-1 )</TT>.

<P>
According to the general transformation relationship 
   (<A HREF="#eqn:dg_forward_connect_form">4</A>) the position vector <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img122.png"
 ALT="$\vec P$"></SPAN> for the 
   forward transform tile 1 <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img183.png"
 ALT="$\rightarrow$"></SPAN> tile 6 is then given as the 
   difference between these two representations. Figure 
   <A HREF="#fig:dgconnect_cusph_6connected">30</A> visualizes the situation.
<P>
<PRE>
  !- connection 6
  conn=6
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=1, tileIndexB=6, &amp;
    positionVector=(/minIndexPTile(1,6)-minIndexPTile(1,1),     &amp;
                     maxIndexPTile(2,6)-minIndexPTile(2,1)+1/), &amp;
    rc=rc)
  
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, connectionList=connectionList, rc=rc)
</PRE>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_cusph_6connected"></A><A NAME="70168"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 30:</STRONG>
The six tiles of an unfolded cube with all six connections that
      do not involve any rotation of tiles.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="556" HEIGHT="422" ALIGN="BOTTOM" BORDER="0"
 SRC="img184.png"
 ALT="\includegraphics{dgconnect_cusph_6connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
The six remaining connections all involve rotations. The procedure for finding
   the correct <TT>orientationVector</TT> and <TT>positionVector</TT> arguments
   still remains the same: First determine the direction of the connection
   to be formulated. This is important because for the forward connection the
   rotation applies to tile "A". Once the correct rotation operation <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img121.png"
 ALT="$\hat R$"></SPAN> is
   pinned down, an arbitrary point close to the connection is chosen. This point
   can either be on tile "A" or "B". It is written then written in terms of tile
   "A" index space <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img119.png"
 ALT="$\vec a$"></SPAN>, and in terms of tile "B" index space <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img120.png"
 ALT="$\vec b$"></SPAN>. 
   Obviously one of those formulations (either <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img119.png"
 ALT="$\vec a$"></SPAN> or <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img120.png"
 ALT="$\vec b$"></SPAN>) will take
   advantage of the connection, i.e. it will actually step outside the reference
   tile in order to reach the chosen point. Finally the position vector <SPAN CLASS="MATH"><IMG
 WIDTH="17" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img122.png"
 ALT="$\vec P$"></SPAN> 
   of the connection is determined by expression 
   (<A HREF="#eqn:dg_forward_connect_form">4</A>) as the difference:

<P>
<BR>
<DIV ALIGN="RIGHT" CLASS="mathdisplay">

<!-- MATH
 \begin{equation}
\vec P = \vec b - \hat R \vec a.
\end{equation}
 -->
<A NAME="eqn:dg_forward_pvec"></A>
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><A NAME="eqn:dg_forward_pvec"></A><IMG
 WIDTH="83" HEIGHT="57" BORDER="0"
 SRC="img185.png"
 ALT="\begin{displaymath}
\vec P = \vec b - \hat R \vec a.
\end{displaymath}"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">13</SPAN>)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>

<P>
Following the above outlined procedure for connection tile 1 <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img183.png"
 ALT="$\rightarrow$"></SPAN>
   tile 3, we find first that tile 1 needs to be rotated clockwise by <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img186.png"
 ALT="$90^\circ$"></SPAN>.
   This rotation lines up the top edge of tile 1 with the left edge of
   tile 3. A clockwise rotation of <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img186.png"
 ALT="$90^\circ$"></SPAN> corresponds to a counterclockwise
   rotation by <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img187.png"
 ALT="$270^\circ$"></SPAN> given in table <A HREF="#tab:dg_ops">3</A>. We therefore know
   that <TT>orientationVector</TT>=(2,-1) for this connection, and the associated
   operation is <!-- MATH
 $\hat R=\left(\begin{array}{rr}
      0 & 1 \\
      -1 & 0 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="121" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img188.png"
 ALT="$\hat R=\left(\begin{array}{rr}
0 &amp; 1 \\
-1 &amp; 0 \end{array} \right)$"></SPAN>.

<P>
Next we chose the first point on the top edge of tile 1 as a reference point.
   In terms of tile 1 this point has coordinates

<P>
<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img119.png"
 ALT="$\vec a$"></SPAN> = <TT>( minIndexPTile(1,1) , maxIndexPTile(2,1) )</TT>.

<P>
The same point in terms of tile 3 (going through the connection) has 
   coordinates

<P>
<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img120.png"
 ALT="$\vec b$"></SPAN> = <TT>( minIndexPTile(1,3)-1 , maxIndexPTile(2,3) )</TT>.

<P>
Using equation (<A HREF="#eqn:dg_forward_pvec">13</A>) we find the position vector and
   can write down the connection:
<P>
<PRE>
  allocate(connectionList(2))
  !- connection 1
  conn=1
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=1, tileIndexB=3, &amp;
    orientationVector=(/2,-1/), &amp; ! 270 degree rotation of tile A
    positionVector=(/minIndexPTile(1,3)-1-maxIndexPTile(2,1),   &amp;
                     maxIndexPTile(2,3)+minIndexPTile(1,1)/), &amp;
    rc=rc)
</PRE>

<P>
For greater clarity figure <A HREF="#fig:dgconnect_cusph_2rotconnected">31</A> only
   shows two connections. Besides the connection just defined between tile 1 
   and 3, the other connection shown is between tile 4 and 6. Defining the
   connection as forward going from tile 4 to tile 6 means that tile 4 needs
   to be rotated in such a way that its right edge meets up with the bottom
   edge of tile 6. This requires a counterclockwise rotation of tile 4 by
   <SPAN CLASS="MATH"><IMG
 WIDTH="27" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img186.png"
 ALT="$90^\circ$"></SPAN>. From table <A HREF="#tab:dg_ops">3</A> we then get 
   <TT>orientationVector</TT>=(-2,1), and <!-- MATH
 $\hat R=\left(\begin{array}{rr}
      0 & -1 \\
      1 & 0 \end{array} \right)$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="121" HEIGHT="54" ALIGN="MIDDLE" BORDER="0"
 SRC="img189.png"
 ALT="$\hat R=\left(\begin{array}{rr}
0 &amp; -1 \\
1 &amp; 0 \end{array} \right)$"></SPAN>.

<P>
Choosing the left most point on the bottom edge of tile 6 as the reference
   point, we find the coordinates in terms of tile 4 (through the connection)

<P>
<SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img119.png"
 ALT="$\vec a$"></SPAN> = <TT>( maxIndexPTile(1,4)+1 , maxIndexPTile(2,4) )</TT>,

<P>
and in terms of tile 6

<P>
<SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
 SRC="img120.png"
 ALT="$\vec b$"></SPAN> = <TT>( minIndexPTile(1,6) , minIndexPTile(2,6) )</TT>.

<P>
Again using equation (<A HREF="#eqn:dg_forward_pvec">13</A>) we find the position vector
   and can implement the second connection:
<P>
<PRE>
  !- connection 2
  conn=2
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=4, tileIndexB=6, &amp;
    orientationVector=(/-2,1/), &amp; ! 90 degree rotation of tile A
    positionVector=(/minIndexPTile(1,6)+maxIndexPTile(2,4),   &amp;
                     minIndexPTile(2,6)-maxIndexPTile(1,4)-1/), &amp;
    rc=rc)

  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, connectionList=connectionList, rc=rc)
</PRE>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_cusph_2rotconnected"></A><A NAME="70200"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 31:</STRONG>
The six tiles of an unfolded cube with two connections that
      involve rotation of tiles.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="555" HEIGHT="422" ALIGN="BOTTOM" BORDER="0"
 SRC="img190.png"
 ALT="\includegraphics{dgconnect_cusph_2rotconnected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>
The remaining four connections with rotations can be determined following the
   exact same recipe. The following code finally defines all 12 connections 
   needed to connect the six index space tiles into a cubic topology.
<P>
<PRE>
  allocate(connectionList(12))

  !- connection 1: tile 1 -&gt; tile 2
  conn=1
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=1, tileIndexB=2, positionVector=(/0, 0/), rc=rc)

  !- connection 2: tile 2 -&gt; tile 3
  conn=2
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=2, tileIndexB=3, positionVector=(/0, 0/), rc=rc)

  !- connection 3: tile 3 -&gt; tile 4
  conn=3
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=3, tileIndexB=4, positionVector=(/0, 0/), rc=rc)

  !- connection 4: tile 4 -&gt; tile 5
  conn=4
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=4, tileIndexB=5, positionVector=(/0, 0/), rc=rc)

  !- connection 5: tile 5 -&gt; tile 6
  conn=5
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=5, tileIndexB=6, positionVector=(/0, 0/), rc=rc)

  !- connection 6: tile 1 -&gt; tile 6
  conn=6
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=1, tileIndexB=6, &amp;
    positionVector=(/minIndexPTile(1,6)-minIndexPTile(1,1),     &amp;
                     maxIndexPTile(2,6)-minIndexPTile(2,1)+1/), &amp;
    rc=rc)

  !- connection 7: tile 1 -&gt; tile 3
  conn=7
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=1, tileIndexB=3, &amp;
    orientationVector=(/2,-1/), &amp; ! 270 degree rotation of tile A
    positionVector=(/minIndexPTile(1,3)-1-maxIndexPTile(2,1), &amp;
                     maxIndexPTile(2,3)+minIndexPTile(1,1)/), &amp;
    rc=rc)

  !- connection 8: tile 3 -&gt; tile 5
  conn=8
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=3, tileIndexB=5, &amp;
    orientationVector=(/2,-1/), &amp; ! 270 degree rotation of tile A
    positionVector=(/minIndexPTile(1,5)-1-maxIndexPTile(2,3), &amp;
                     maxIndexPTile(2,5)+minIndexPTile(1,3)/), &amp;
    rc=rc)

  !- connection 9: tile 5 -&gt; tile 1
  conn=9
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=5, tileIndexB=1, &amp;
    orientationVector=(/2,-1/), &amp; ! 270 degree rotation of tile A
    positionVector=(/minIndexPTile(1,1)-1-maxIndexPTile(2,5), &amp;
                     maxIndexPTile(2,1)+minIndexPTile(1,5)/), &amp;
    rc=rc)

  !- connection 10: tile 2 -&gt; tile 4
  conn=10
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=2, tileIndexB=4, &amp;
    orientationVector=(/-2,1/), &amp; ! 90 degree rotation of tile A
    positionVector=(/minIndexPTile(1,4)+maxIndexPTile(2,2),     &amp;
                     minIndexPTile(2,4)-maxIndexPTile(1,2)-1/), &amp;
    rc=rc)

  !- connection 11: tile 4 -&gt; tile 6
  conn=11
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=4, tileIndexB=6, &amp;
    orientationVector=(/-2,1/), &amp; ! 90 degree rotation of tile A
    positionVector=(/minIndexPTile(1,6)+maxIndexPTile(2,4),     &amp;
                     minIndexPTile(2,6)-maxIndexPTile(1,4)-1/), &amp;
    rc=rc)

  !- connection 12: tile 6 -&gt; tile 2
  conn=12
  call ESMF_DistGridConnectionSet(connection=connectionList(conn), &amp;
    tileIndexA=6, tileIndexB=2, &amp;
    orientationVector=(/-2,1/), &amp; ! 90 degree rotation of tile A
    positionVector=(/minIndexPTile(1,2)+maxIndexPTile(2,6),     &amp;
                     minIndexPTile(2,2)-maxIndexPTile(1,6)-1/), &amp;
    rc=rc)
  
  ! - create the DistGrid with 6 tiles and 12 connections
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndexPTile, &amp;
    maxIndexPTile=maxIndexPTile, connectionList=connectionList, rc=rc)
</PRE>

<P>
For better visualization the resulting cubic topology is plotted in 3D.
   Each index space point is associated with a longitude and latitude value
   of the unit sphere. Combined with the cubic topology formed by the six 
   index space tiles, this results in a cubed sphere representation shown in
   figure <A HREF="#fig:dgconnect_cusph_12connected">32</A>.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:dgconnect_cusph_12connected"></A><A NAME="70208"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 32:</STRONG>
Six index space tiles with all 12 connections to form a cubic
      topology. The coordinates at every index space point are chosen to 
      form a spherical geometry, resulting in a cubed sphere.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">

</DIV>     <IMG
 WIDTH="595" HEIGHT="494" ALIGN="BOTTOM" BORDER="0"
 SRC="img191.png"
 ALT="\includegraphics{dgconnect_cusph_12connected.eps}"></TD></TR>
</TABLE>
</DIV>

<P>


<H2><A NAME="SECTION050134000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>Multi-tile DistGrids from deBlockList are not yet supported.
</LI>
<LI>The fastAxis feature has not been implemented yet.
</LI>
</UL>

<H2><A NAME="SECTION050135000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
<EM>This section will be updated as the implementation of the DistGrid class
nears completion.</EM>

<H2><A NAME="SECTION050136000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050136100000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DistGridAssignment(=) - DistGrid assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     distgrid1 = distgrid2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid) :: distgrid1
     type(ESMF_DistGrid) :: distgrid2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign distgrid1 as an alias to the same ESMF DistGrid object in memory
     as distgrid2. If distgrid2 is invalid, then distgrid1 will be equally
     invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050136200000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_DistGridOperator(==) - DistGrid equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (distgrid1 == distgrid2) then ... endif
               OR
     result = (distgrid1 == distgrid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid), intent(in) :: distgrid1
     type(ESMF_DistGrid), intent(in) :: distgrid2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether distgrid1 and distgrid2 are valid aliases to the same ESMF
     DistGrid object in memory. For a more general comparison of two 
     ESMF DistGrids, going beyond the simple alias test, the 
     <TT>ESMF_DistGridMatch()</TT> function (not yet fully implemented) must 
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050136300000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_DistGridOperator(/=) - DistGrid not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (distgrid1 /= distgrid2) then ... endif
               OR
     result = (distgrid1 /= distgrid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid), intent(in) :: distgrid1
     type(ESMF_DistGrid), intent(in) :: distgrid2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether distgrid1 and distgrid2 are <I>not</I> valid aliases to the
     same ESMF DistGrid object in memory. For a more general comparison of two
     ESMF DistGrids, going beyond the simple alias test, the
     <TT>ESMF_DistGridMatch()</TT> function (not yet fully implemented) must 
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050136400000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_DistGridCreate - Create DistGrid object from DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDG(distgrid, &amp;
     firstExtra, lastExtra, indexflag, connectionList, balanceflag, &amp;
     delayout, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDG
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),           intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, target,               intent(in),  optional :: firstExtra(:)
     integer, target,               intent(in),  optional :: lastExtra(:)
     type(ESMF_Index_Flag),         intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection), intent(in),  optional :: connectionList(:)
     logical,                       intent(in),  optional :: balanceflag
     type(ESMF_DELayout),           intent(in),  optional :: delayout
     type(ESMF_VM),                 intent(in),  optional :: vm
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.3.0r</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
                 different VM than that of the current context.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>delayout</TT> to support changing the layout of
                DEs across PETs.
<BR>
Added argument <TT>balanceflag</TT> to support rebalancing of the
                incoming DistGrids decomposition.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new DistGrid from an existing DistGrid, keeping the decomposition
       unchanged, unless <TT>balanceflag=.true.</TT> (see below).
       The <TT>firstExtraPTile</TT> and <TT>lastExtraPTile</TT> arguments allow extra
       elements to be added at the first/last edge DE in each dimension. The 
       method also allows the <TT>indexflag</TT> to be set. Further, if the 
       <TT>connectionList</TT> argument provided in it will be used to set 
       connections in the newly created DistGrid, otherwise the connections of
       the incoming DistGrid will be used.

<P>
The <TT>balanceflag</TT> argument allows a change in the decomposition, and
       thus of the number of DEs. An attempt is made to decompose the index
       space into as many DEs as there are PETs in the VM for which the DistGrid
       is created. See the argument description for details.

<P>
Setting the <TT>balanceflag</TT> argument to <TT>.true.</TT> is currently
       incompatible with providing any of the other optional arguments.

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Incoming DistGrid object.
       
</DD>
<DT><STRONG>[firstExtra]</STRONG></DT>
<DD>Extra elements added to the first DE along each 
            dimension. This increases the size of the index space compared to 
            that of the incoming <TT>distgrid</TT>. The decomposition of the
            enlarged index space is constructed to align with the original index
            space provided by <TT>distgrid</TT>.
            The default is a zero vector.
       
</DD>
<DT><STRONG>[lastExtra]</STRONG></DT>
<DD>Extra elements added to the last DE along each 
            dimension. This increases the size of the index space compared to 
            that of the incoming <TT>distgrid</TT>. The decomposition of the
            enlarged index space is constructed to align with the original index
            space provided by <TT>distgrid</TT>.
            The default is a zero vector.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>If present, override the indexflag setting of the incoming
            <TT>distgrid</TT>. See section <A HREF="node9.html#const:indexflag">54.27</A> for a 
            complete list of options. By default use the indexflag setting of 
            <TT>distgrid</TT>. 
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>If present, override the connections of the incoming <TT>distgrid</TT>.
            See section <A HREF="#api:DistGridConnectionSet">36.7.2</A> for the associated Set()
            method. By default use the connections defined in <TT>distgrid</TT>.
       
</DD>
<DT><STRONG>[balanceflag]</STRONG></DT>
<DD>If set to <TT>.true</TT>, rebalance the incoming <TT>distgrid</TT>
            decompositon to exactly one DE per PET. The DEs along each dimension
            are chosen to provide the most balanced decomposition across all
            dimensions.
            The default is <TT>.false.</TT>, leaving the decomposition, and
            therefore the number of DEs unchanged. For this case, PETs might end
            up with no DE, one DE, or multiple DEs.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>If present, override the DELayout of the incoming <TT>distgrid</TT>.
            By default use the DELayout defined in <TT>distgrid</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the DistGrid object and the DELayout object
            are created on the specified <TT>ESMF_VM</TT> object. The 
            default is to use the VM of the current context. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050136500000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_DistGridCreate - Create DistGrid object from DistGrid (multi-tile version)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDGT(distgrid, firstExtraPTile, &amp;
     lastExtraPTile, indexflag, connectionList, balanceflag, &amp;
     delayout, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDGT
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),           intent(in)            :: distgrid
     integer, target,               intent(in)            :: firstExtraPTile(:,:)
     integer, target,               intent(in)            :: lastExtraPTile(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag),         intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection), intent(in),  optional :: connectionList(:)
     logical,                       intent(in),  optional :: balanceflag
     type(ESMF_DELayout),           intent(in),  optional :: delayout
     type(ESMF_VM),                 intent(in),  optional :: vm
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.3.0r</STRONG></DT>
<DD>Added argument <TT>vm</TT> to support object creation on a
                 different VM than that of the current context.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added argument <TT>delayout</TT> to support changing the layout of
                DEs across PETs.
<BR>
Added argument <TT>balanceflag</TT> to support rebalancing of the
                incoming DistGrids decomposition.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new DistGrid from an existing DistGrid, keeping the decomposition
       unchanged, unless <TT>balanceflag=.true.</TT> (see below).
       The <TT>firstExtraPTile</TT> and <TT>lastExtraPTile</TT> arguments allow extra
       elements to be added at the first/last edge DE in each dimension. The 
       method also allows the <TT>indexflag</TT> to be set. Further, if the 
       <TT>connectionList</TT> argument provided in it will be used to set 
       connections in the newly created DistGrid, otherwise the connections of
       the incoming DistGrid will be used.

<P>
The <TT>balanceflag</TT> argument allows a change in the decomposition, and
       thus of the number of DEs. An attempt is made to decompose the index
       space into as many DEs as there are PETs in the VM for which the DistGrid
       is created. See the argument description for details.

<P>
Setting the <TT>balanceflag</TT> argument to <TT>.true.</TT> is currently
       incompatible with providing any of the other optional arguments.

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Incoming DistGrid object.
       
</DD>
<DT><STRONG>firstExtraPTile</STRONG></DT>
<DD>Extra elements added to the first DE along each dimension for each 
            tile. This increases the size of the index space compared to 
            that of the incoming <TT>distgrid</TT>. The decomposition of the
            enlarged index space is constructed to align with the original index
            space provided by <TT>distgrid</TT>.
            The default is a zero vector.
       
</DD>
<DT><STRONG>lastExtraPTile</STRONG></DT>
<DD>Extra elements added to the last DE along each dimension for each
            tile. This increases the size of the index space compared to 
            that of the incoming <TT>distgrid</TT>. The decomposition of the
            enlarged index space is constructed to align with the original index
            space provided by <TT>distgrid</TT>.
            The default is a zero vector.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>If present, override the indexflag setting of the incoming
            <TT>distgrid</TT>. See section <A HREF="node9.html#const:indexflag">54.27</A> for a 
            complete list of options. By default use the indexflag setting of 
            <TT>distgrid</TT>. 
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>If present, override the connections of the incoming <TT>distgrid</TT>.
            See section <A HREF="#api:DistGridConnectionSet">36.7.2</A> for the associated Set()
            method. By default use the connections defined in <TT>distgrid</TT>.
       
</DD>
<DT><STRONG>[balanceflag]</STRONG></DT>
<DD>If set to <TT>.true</TT>, rebalance the incoming <TT>distgrid</TT>
            decompositon. An attempt is made to come out at exactly one DE per
            PET. However, if there are more tiles than PETs, the lower PETs will
            hold more than one DE. For cases where there are more PETs than
            tiles, each tile is decomposed into DEs as to provide the most
            balanced decomposition across all dimensions.
            The default is <TT>.false.</TT>, leaving the decomposition, and
            therefore the number of DEs unchanged. For this case, PETs might end
            up with no DE, one DE, or multiple DEs.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>If present, override the DELayout of the incoming <TT>distgrid</TT>.
            By default use the DELayout defined in <TT>distgrid</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the DistGrid object and the DELayout object
            are created on the specified <TT>ESMF_VM</TT> object. The 
            default is to use the VM of the current context. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050136600000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_DistGridCreate - Create DistGrid object with regular decomposition</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateRD(minIndex, maxIndex, regDecomp, &amp;
     decompflag, regDecompFirstExtra, regDecompLastExtra, deLabelList, &amp;
     indexflag, connectionList, delayout, vm, indexTK, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateRD
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                        intent(in)            :: minIndex(:)
     integer,                        intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                target, intent(in),  optional :: regDecomp(:)
     type(ESMF_Decomp_Flag), target, intent(in),  optional :: decompflag(:)
     integer,                target, intent(in),  optional :: regDecompFirstExtra(:)
     integer,                target, intent(in),  optional :: regDecompLastExtra(:)
     integer,                target, intent(in),  optional :: deLabelList(:)
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection),  intent(in),  optional :: connectionList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_VM),                  intent(in),  optional :: vm
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: indexTK
     integer,                        intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>indexTK</TT> to support explicit selection
                between 32-bit and 64-bit sequence indices.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from a single logically rectangular tile.
       The tile has a regular decomposition, where the tile is decomposed
       into a fixed number of DEs along each dimension. A regular decomposition
       of a single tile is expressed by a single <TT>regDecomp</TT> list of DE 
       counts in each dimension.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Index space tuple of the lower corner of the single tile.
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Index space tuple of the upper corner of the single tile.
       
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List of DE counts for each dimension. The total <TT>deCount</TT> is
            determined as the product of <TT>regDecomp</TT> elements.
            By default <TT>regDecomp</TT> = (/<TT>deCount</TT>,1,...,1/), 
            where <TT>deCount</TT>
            is the number of DEs in the <TT>delayout</TT>. If the default
            <TT>delayout</TT> is used, the <TT>deCount</TT> is equal to <TT>petCount</TT>.
            This leads to a simple 1 DE per PET distribution, where the
            decompsition is only along the first dimension.
       
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
            tile is to be divided between the DEs. The default setting
            is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. See section
            <A HREF="node9.html#const:decompflag">54.13</A> for a list of valid decomposition options.
       
</DD>
<DT><STRONG>[regDecompFirstExtra]</STRONG></DT>
<DD>Specify how many extra elements on the first DEs along each 
            dimension to consider when applying the regular decomposition 
            algorithm. This does <EM>not</EM> add extra elements to the 
            index space defined by <TT>minIndex</TT> and <TT>maxIndex</TT>. Instead
            <TT>regDecompFirstExtra</TT> is used to correctly interpret the 
            specified index space: The <TT>regDecomp</TT> is first applied to the
            index space <EM>without</EM> the extra elements. The extra elements are
            then added back in to arrive at the final decomposition. This is 
            useful when aligning the decomposition of index spaces that only
            differ in extra elements along the edges, e.g. when dealing with
            different stagger locations.
            The default is a zero vector, assuming no extra elements.
       
</DD>
<DT><STRONG>[regDecompLastExtra]</STRONG></DT>
<DD>Specify how many extra elements on the last DEs along each 
            dimension to consider when applying the regular decomposition 
            algorithm. This does <EM>not</EM> add extra elements to the 
            index space defined by <TT>minIndex</TT> and <TT>maxIndex</TT>. Instead
            <TT>regDecompLastExtra</TT> is used to correctly interpret the 
            specified index space: The <TT>regDecomp</TT> is first applied to the
            index space <EM>without</EM> the extra elements. The extra elements are
            then added back in to arrive at the final decomposition. This is 
            useful when aligning the decomposition of index spaces that only
            differ in extra elements along the edges, e.g. when dealing with
            different stagger locations.
            The default is a zero vector, assuming no extra elements.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecomp</TT>
            argument.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are forming a global
            index space or not. This does <EM>not</EM> affect the indices held
            by the DistGrid object, which are always identical to what was
            specified by <TT>minIndex</TT> and <TT>maxIndex</TT>, regardless of the
            <TT>indexflag</TT> setting. However, it does affect whether an
            <TT>ESMF_Array</TT> object created on the DistGrid can choose global
            indexing or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node9.html#const:indexflag">54.27</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="#api:DistGridConnectionSet">36.7.2</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> object to be used. If a DELayout object is
            specified its <TT>deCount</TT> must match the number indicated by 
            <TT>regDecomp</TT>. By default a new DELayout object will be created 
            with the correct number of DEs.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the DistGrid object (and the DELayout object if not 
            provided) are created on the specified <TT>ESMF_VM</TT> object. The 
            default is to use the VM of the current context. 
       
</DD>
<DT><STRONG>[indexTK]</STRONG></DT>
<DD>Typekind used for global sequence indexing. See section 
            <A HREF="node9.html#const:typekind">54.59</A> for a list of typekind options. Only integer
            types are supported. The default is to have ESMF automatically choose
            between <TT>ESMF_TYPEKIND_I4</TT> and <TT>ESMF_TYPEKIND_I8</TT>,
            depending on whether the global number of elements held by the
            DistGrid is below or above the 32-bit limit, respectively.
            Because of the use of signed integers for sequence indices, 
            element counts of <!-- MATH
 $> 2^{31}-1 = 2,147,483,647$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="192" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img192.png"
 ALT="$&gt; 2^{31}-1 = 2,147,483,647$"></SPAN> will switch to 64-bit 
            indexing.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050136700000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_DistGridCreate - Create DistGrid object with regular decomposition (multi-tile version)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateRDT(minIndexPTile, maxIndexPTile, &amp;
     regDecompPTile, decompflagPTile, regDecompFirstExtraPTile,&amp;
     regDecompLastExtraPTile, deLabelList, indexflag, connectionList, &amp;
     delayout, vm, indexTK, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateRDT
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                        intent(in)            :: minIndexPTile(:,:)
     integer,                        intent(in)            :: maxIndexPTile(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                        intent(in),  optional :: regDecompPTile(:,:)
     type(ESMF_Decomp_Flag), target, intent(in),  optional :: decompflagPTile(:,:)
     integer,                target, intent(in),  optional :: regDecompFirstExtraPTile(:,:)
     integer,                target, intent(in),  optional :: regDecompLastExtraPTile(:,:)
     integer,                        intent(in),  optional :: deLabelList(:)
     type(ESMF_Index_Flag),          intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection),  intent(in),  optional :: connectionList(:)
     type(ESMF_DELayout),            intent(in),  optional :: delayout
     type(ESMF_VM),                  intent(in),  optional :: vm
     type(ESMF_TypeKind_Flag),       intent(in),  optional :: indexTK
     integer,                        intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>indexTK</TT> to support explicit selection
                between 32-bit and 64-bit sequence indices.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from multiple logically rectangular tiles. 
       Each tile has a regular decomposition, where the tile is decomposed
       into a fixed number of DEs along each dimension. A regular decomposition
       of a multi-tile DistGrid is expressed by a list of DE count vectors, one
       vector for each tile. If a DELayout is specified, it must contain at least
       as many DEs as there are tiles.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndexPTile</STRONG></DT>
<DD>The first index provides the index space tuple of the lower 
            corner of a tile. The second index indicates the tile number.
       
</DD>
<DT><STRONG>maxIndexPTile</STRONG></DT>
<DD>The first index provides the index space tuple of the upper
            corner of a tile. The second index indicates the tile number.
       
</DD>
<DT><STRONG>[regDecompPTile]</STRONG></DT>
<DD>List of DE counts for each dimension. The second index steps through
            the tiles. The total <TT>deCount</TT> is determined as ths sum over
            the products of <TT>regDecomp</TT> elements for each tile.
            By default each tile is decomposed only along the first dimension.
            The default number of DEs per tile is at least 1, but may be greater
            for the leading tiles if the <TT>deCount</TT> is greater than the 
            <TT>tileCount</TT>. If no DELayout is specified, the <TT>deCount</TT> is 
            by default set equal to the number of PETs (<TT>petCount</TT>), or the 
            number of tiles (<TT>tileCount</TT>), which ever is greater. This means
            that as long as <TT>petCount</TT> &gt; <TT>tileCount</TT>, the resulting
            default distribution will be 1 DE per PET. Notice that some tiles
            may be decomposed into more DEs than other tiles.
       
</DD>
<DT><STRONG>[decompflagPTile]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of each
            tile is to be divided between the DEs. The default setting
            is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions for all tiles. 
            See section <A HREF="node9.html#const:decompflag">54.13</A> for a list of valid decomposition
            flag options. The second index indicates the tile number.
       
</DD>
<DT><STRONG>[regDecompFirstExtraPTile]</STRONG></DT>
<DD>Specify how many extra elements on the first DEs along each 
            dimension to consider when applying the regular decomposition 
            algorithm. This does <EM>not</EM> add extra elements to the 
            index space defined by <TT>minIndex</TT> and <TT>maxIndex</TT>. Instead
            <TT>regDecompFirstExtraPTile</TT> is used to correctly interpret the 
            specified index space: The <TT>regDecomp</TT> is first applied to the
            index space <EM>without</EM> the extra elements. The extra elements are
            then added back in to arrive at the final decomposition. This is 
            useful when aligning the decomposition of index spaces that only
            differ in extra elements along the edges, e.g. when dealing with
            different stagger locations.
            The default is a zero vector, assuming no extra elements.
       
</DD>
<DT><STRONG>[regDecompLastExtraPTile]</STRONG></DT>
<DD>Specify how many extra elements on the last DEs along each 
            dimension to consider when applying the regular decomposition 
            algorithm. This does <EM>not</EM> add extra elements to the 
            index space defined by <TT>minIndex</TT> and <TT>maxIndex</TT>. Instead
            <TT>regDecompLastExtraPTile</TT> is used to correctly interpret the 
            specified index space: The <TT>regDecomp</TT> is first applied to the
            index space <EM>without</EM> the extra elements. The extra elements are
            then added back in to arrive at the final decomposition. This is 
            useful when aligning the decomposition of index spaces that only
            differ in extra elements along the edges, e.g. when dealing with
            different stagger locations.
            The default is a zero vector, assuming no extra elements.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecompPTile</TT>
            elements in the sequence as they appear following the tile index.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndexPTile</TT> and
            <TT>maxIndexPTile</TT> arguments are forming a global index space or 
            not. This does <EM>not</EM> affect the indices held by the DistGrid 
            object, which are always identical to what was specified by 
            <TT>minIndexPTile</TT> and <TT>maxIndexPTile</TT>, regardless of the
            <TT>indexflag</TT> setting. However, it does affect whether an
            <TT>ESMF_Array</TT> object created on the DistGrid can choose global
            indexing or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node9.html#const:indexflag">54.27</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="#api:DistGridConnectionSet">36.7.2</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with as many DEs as there are PETs,
            or tiles, which ever is greater. If a DELayout object is specified,
            the number of DEs must match <TT>regDecompPTile</TT>, if present. In the
            case that <TT>regDecompPTile</TT> was not specified, the <TT>deCount</TT>
            must be at least that of the default DELayout. The 
            <TT>regDecompPTile</TT> will be constructed accordingly.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[indexTK]</STRONG></DT>
<DD>Typekind used for global sequence indexing. See section 
            <A HREF="node9.html#const:typekind">54.59</A> for a list of typekind options. Only integer
            types are supported. The default is to have ESMF automatically choose
            between <TT>ESMF_TYPEKIND_I4</TT> and <TT>ESMF_TYPEKIND_I8</TT>,
            depending on whether the global number of elements held by the
            DistGrid is below or above the 32-bit limit, respectively.
            Because of the use of signed integers for sequence indices, 
            element counts of <!-- MATH
 $> 2^{31}-1 = 2,147,483,647$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="192" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img192.png"
 ALT="$&gt; 2^{31}-1 = 2,147,483,647$"></SPAN> will switch to 64-bit 
            indexing.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050136800000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_DistGridCreate - Create DistGrid object with DE blocks</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDB(minIndex, maxIndex, deBlockList, &amp;
     deLabelList, indexflag, connectionList, delayout, vm, &amp;
     indexTK, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDB
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                       intent(in)            :: minIndex(:)
     integer,                       intent(in)            :: maxIndex(:)
     integer,                       intent(in)            :: deBlockList(:,:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                       intent(in),  optional :: deLabelList(:)
     type(ESMF_Index_Flag),         intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection), intent(in),  optional :: connectionList(:)
     type(ESMF_DELayout),           intent(in),  optional :: delayout
     type(ESMF_VM),                 intent(in),  optional :: vm
     type(ESMF_TypeKind_Flag),      intent(in),  optional :: indexTK
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.1.0r</STRONG></DT>
<DD>Added argument <TT>indexTK</TT> to support selecting between
                 32-bit and 64-bit sequence indices.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from a single logically rectangular 
       tile with decomposition specified by <TT>deBlockList</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Index space tuple of the lower corner of the single tile.
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Index space tuple of the upper corner of the single tile.
       
</DD>
<DT><STRONG>deBlockList</STRONG></DT>
<DD>List of DE-local blocks. The third index of <TT>deBlockList</TT>
            steps through the deBlock elements (i.e. deCount), which are defined
            by the first two indices. 
            The first index must be of size <TT>dimCount</TT> and the 
            second index must be of size 2. Each element of <TT>deBlockList</TT>
            defined by the first two indices hold the following information.
            <PRE>
                     +---------------------------------------&gt; 2nd index
                     |    1               2           
                     | 1  minIndex(1)    maxIndex(1)
                     | 2  minIndex(2)    maxIndex(2)
                     | .  minIndex(.)    maxIndex(.)
                     | .
                     v
                    1st index
</PRE>
            It is required that there be no overlap between the DE blocks.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the order of DEs in the <TT>deBlockList</TT> 
            argument.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are forming a global
            index space or not. This does <EM>not</EM> affect the indices held
            by the DistGrid object, which are always identical to what was
            specified by <TT>minIndex</TT> and <TT>maxIndex</TT>, regardless of the
            <TT>indexflag</TT> setting. However, it does affect whether an
            <TT>ESMF_Array</TT> object created on the DistGrid can choose global
            indexing or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node9.html#const:indexflag">54.27</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="#api:DistGridConnectionSet">36.7.2</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with the correct number of DEs. If
            a DELayout object is specified its number of DEs must match the 
            number indicated by <TT>regDecomp</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[indexTK]</STRONG></DT>
<DD>Typekind used for global sequence indexing. See section 
            <A HREF="node9.html#const:typekind">54.59</A> for a list of typekind options. Only integer
            types are supported. The default is to have ESMF automatically choose
            between <TT>ESMF_TYPEKIND_I4</TT> and <TT>ESMF_TYPEKIND_I8</TT>,
            depending on whether the global number of elements held by the
            DistGrid is below or above the 32-bit limit, respectively.
            Because of the use of signed integers for sequence indices, 
            element counts of <!-- MATH
 $> 2^{31}-1 = 2,147,483,647$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="192" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img192.png"
 ALT="$&gt; 2^{31}-1 = 2,147,483,647$"></SPAN> will switch to 64-bit 
            indexing.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050136900000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_DistGridCreate - Create DistGrid object with DE blocks (multi-tile version)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBT(minIndexPTile, maxIndexPTile, deBlockList, &amp;
     deToTileMap, deLabelList, indexflag, connectionList, &amp;
     delayout, vm, indexTK, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBT
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                       intent(in)            :: minIndexPTile(:,:)
     integer,                       intent(in)            :: maxIndexPTile(:,:)
     integer,                       intent(in)            :: deBlockList(:,:,:)
     integer,                       intent(in)            :: deToTileMap(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                       intent(in),  optional :: deLabelList(:)
     type(ESMF_Index_Flag),         intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection), intent(in),  optional :: connectionList(:)
     type(ESMF_DELayout),           intent(in),  optional :: delayout
     type(ESMF_VM),                 intent(in),  optional :: vm
     type(ESMF_TypeKind_Flag),      intent(in),  optional :: indexTK
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> on multiple logically 
       rectangular tiles with decomposition specified by <TT>deBlockList</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndexPTile</STRONG></DT>
<DD>The first index provides the index space tuple of the lower 
            corner of a tile. The second index indicates the tile number.
       
</DD>
<DT><STRONG>maxIndexPTile</STRONG></DT>
<DD>The first index provides the index space tuple of the upper
            corner of a tile. The second index indicates the tile number.
       
</DD>
<DT><STRONG>deBlockList</STRONG></DT>
<DD>List of DE-local blocks. The third index of <TT>deBlockList</TT>
            steps through the deBlock elements (i.e. deCount), which are defined
            by the first two indices. 
            The first index must be of size <TT>dimCount</TT> and the 
            second index must be of size 2. Each element of <TT>deBlockList</TT>
            defined by the first two indices hold the following information.
            <PRE>
                     +---------------------------------------&gt; 2nd index
                     |    1               2           
                     | 1  minIndex(1)    maxIndex(1)
                     | 2  minIndex(2)    maxIndex(2)
                     | .  minIndex(.)    maxIndex(.)
                     | .
                     v
                    1st index
</PRE>
            It is required that there be no overlap between the DE blocks.
       
</DD>
<DT><STRONG>deToTileMap</STRONG></DT>
<DD>List assigning each DE to a specific tile. The size of 
            <TT>deToTileMap</TT> must be equal to <TT>deCount</TT>.
            The order of DEs is the same as in <TT>deBlockList</TT>.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the order of DEs in the <TT>deBlockList</TT> 
            argument.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndexPTile</TT> and
            <TT>maxIndexPTile</TT> arguments are forming a global index space or 
            not. This does <EM>not</EM> affect the indices held by the DistGrid 
            object, which are always identical to what was specified by 
            <TT>minIndexPTile</TT> and <TT>maxIndexPTile</TT>, regardless of the
            <TT>indexflag</TT> setting. However, it does affect whether an
            <TT>ESMF_Array</TT> object created on the DistGrid can choose global
            indexing or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node9.html#const:indexflag">54.27</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="#api:DistGridConnectionSet">36.7.2</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with the correct number of DEs. If
            a DELayout object is specified its number of DEs must match the 
            number indicated by <TT>regDecomp</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[indexTK]</STRONG></DT>
<DD>Typekind used for global sequence indexing. See section 
            <A HREF="node9.html#const:typekind">54.59</A> for a list of typekind options. Only integer
            types are supported. The default is to have ESMF automatically choose
            between <TT>ESMF_TYPEKIND_I4</TT> and <TT>ESMF_TYPEKIND_I8</TT>,
            depending on whether the global number of elements held by the
            DistGrid is below or above the 32-bit limit, respectively.
            Because of the use of signed integers for sequence indices, 
            element counts of <!-- MATH
 $> 2^{31}-1 = 2,147,483,647$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="192" HEIGHT="33" ALIGN="MIDDLE" BORDER="0"
 SRC="img192.png"
 ALT="$&gt; 2^{31}-1 = 2,147,483,647$"></SPAN> will switch to 64-bit 
            indexing.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_DistGridCreate - Create 1D DistGrid object from user's arbitrary sequence index list 1 DE per PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBAI1D1DE(arbSeqIndexList, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBAI1D1DE
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(in)            :: arbSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> of <TT>dimCount</TT> 1 from a PET-local list
       of sequence indices. The PET-local size of the <TT>arbSeqIndexList</TT>
       argument determines the number of local elements in the created DistGrid.
       The sequence indices must be unique across all PETs. A default
       DELayout with 1 DE per PET across all PETs of the current VM is 
       automatically created.

<P>
This is a <EM>collective</EM> method across the current VM.

<P>
The arguments are:
       <DL>
<DT><STRONG>arbSeqIndexList</STRONG></DT>
<DD>List of arbitrary sequence indices that reside on the local PET.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361100000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_DistGridCreate - Create 1D DistGrid object from user's arbitrary 64-bit sequence index list 1 DE per PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBAI1D1DEI8(arbSeqIndexList, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBAI1D1DEI8
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer(ESMF_KIND_I8),  intent(in)            :: arbSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> of <TT>dimCount</TT> 1 from a PET-local list
       of sequence indices. The PET-local size of the <TT>arbSeqIndexList</TT>
       argument determines the number of local elements in the created DistGrid.
       The sequence indices must be unique across all PETs. A default
       DELayout with 1 DE per PET across all PETs of the current VM is 
       automatically created.

<P>
This is a <EM>collective</EM> method across the current VM.

<P>
The arguments are:
       <DL>
<DT><STRONG>arbSeqIndexList</STRONG></DT>
<DD>List of arbitrary sequence indices that reside on the local PET.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361200000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_DistGridCreate - Create 1D DistGrid object from user's arbitrary sequence index list multiple DE/PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBAI1D(arbSeqIndexList, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBAI1D
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_PtrInt1D), intent(in) :: arbSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> of <TT>dimCount</TT> 1 from a PET-local list
       of sequence index lists. The PET-local size of the <TT>arbSeqIndexList</TT>
       argument determines the number of local DEs in the created DistGrid.
       Each of the local DEs is associated with as many index space elements as
       there are arbitrary sequence indices in the associated list.
       The sequence indices must be unique across all DEs. A default
       DELayout with the correct number of DEs per PET is automatically created.

<P>
This is a <EM>collective</EM> method across the current VM.

<P>
The arguments are:
       <DL>
<DT><STRONG>arbSeqIndexList</STRONG></DT>
<DD>List of arbitrary sequence index lists that reside on the local PET.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361300000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_DistGridCreate - Create (1+n)D DistGrid object from user's arbitrary sequence index list and minIndexPTile/maxIndexPTile</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBAI(arbSeqIndexList, arbDim, &amp;
     minIndexPTile, maxIndexPTile, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBAI
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(in)            :: arbSeqIndexList(:)
     integer, intent(in)            :: arbDim
     integer, intent(in)            :: minIndexPTile(:)
     integer, intent(in)            :: maxIndexPTile(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> of <TT>dimCount</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img193.png"
 ALT="$1+n$"></SPAN>, where 
       <SPAN CLASS="MATH"><IMG
 WIDTH="30" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img194.png"
 ALT="$n=$"></SPAN> <TT>size(minIndexPTile)</TT> = <TT>size(maxIndexPTile)</TT>.

<P>
The resulting DistGrid will have a 1D distribution determined by the
       PET-local <TT>arbSeqIndexList</TT>. The PET-local size of the
       <TT>arbSeqIndexList</TT> argument determines the number of local elements 
       along the arbitrarily distributed dimension in the created DistGrid. The
       sequence indices must be unique across all PETs. The associated,
       automatically created DELayout will have 1 DE per PET across all PETs of
       the current VM.

<P>
In addition to the arbitrarily distributed dimension, regular DistGrid
       dimensions can be specified in <TT>minIndexPTile</TT> and <TT>maxIndexPTile</TT>. The
       <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img98.png"
 ALT="$n$"></SPAN> dimensional subspace spanned by the regular dimensions is "multiplied"
       with the arbitrary dimension on each DE, to form a <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img193.png"
 ALT="$1+n$"></SPAN> dimensional
       total index space described by the DistGrid object. The <TT>arbDim</TT>
       argument allows to specify which dimension in the resulting DistGrid
       corresponds to the arbitrarily distributed one.

<P>
This is a <EM>collective</EM> method across the current VM.

<P>
The arguments are:
       <DL>
<DT><STRONG>arbSeqIndexList</STRONG></DT>
<DD>List of arbitrary sequence indices that reside on the local PET.
       
</DD>
<DT><STRONG>arbDim</STRONG></DT>
<DD>Dimension of the arbitrary distribution.
       
</DD>
<DT><STRONG>minIndexPTile</STRONG></DT>
<DD>Index space tuple of the lower corner of the tile. The 
            arbitrary dimension is <EM>not</EM> included in this tile
       
</DD>
<DT><STRONG>maxIndexPTile</STRONG></DT>
<DD>Index space tuple of the upper corner of the tile. The
            arbitrary dimension is <EM>not</EM> included in this tile
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361400000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_DistGridDestroy - Release resources associated with a DistGrid </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridDestroy(distgrid, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid), intent(inout)          :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,             intent(in),   optional :: noGarbage
     integer,             intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_DistGrid</TT>, releasing the resources associated
     with the object.

<P>
By default a small remnant of the object is kept in memory in order to 
     prevent problems with dangling aliases. The default garbage collection
     mechanism can be overridden with the <TT>noGarbage</TT> argument.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this 
        condition ESMF cannot protect against accessing the destroyed object 
        through dangling aliases - a situation which may lead to hard to debug 
        application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
        set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use 
        temporary ESMF objects. For situations where the repeated creation and 
        destruction of temporary objects leads to memory issues, it is 
        recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
        removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361500000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_DistGridGet - Get object-wide DistGrid information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetDefault(distgrid, delayout, &amp;
     dimCount, tileCount, deCount, localDeCount, minIndexPTile, maxIndexPTile, &amp;
     elementCountPTile, elementCountPTileI8, minIndexPDe, maxIndexPDe, &amp;
     elementCountPDe, elementCountPDeI8, localDeToDeMap, deToTileMap, &amp;
     indexCountPDe, collocation, regDecompFlag, indexTK, indexflag, &amp;
     connectionCount, connectionList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),      intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DELayout),      intent(out), optional :: delayout
     integer,                  intent(out), optional :: dimCount
     integer,                  intent(out), optional :: tileCount
     integer,                  intent(out), optional :: deCount
     integer,                  intent(out), optional :: localDeCount
     integer,          target, intent(out), optional :: minIndexPTile(:,:)
     integer,          target, intent(out), optional :: maxIndexPTile(:,:)
     integer,          target, intent(out), optional :: elementCountPTile(:)
 integer(ESMF_KIND_I8),target, intent(out), optional :: elementCountPTileI8(:)
     integer,          target, intent(out), optional :: minIndexPDe(:,:)
     integer,          target, intent(out), optional :: maxIndexPDe(:,:)
     integer,          target, intent(out), optional :: elementCountPDe(:)
 integer(ESMF_KIND_I8),target, intent(out), optional :: elementCountPDeI8(:)
     integer,          target, intent(out), optional :: localDeToDeMap(:)
     integer,          target, intent(out), optional :: deToTileMap(:)
     integer,          target, intent(out), optional :: indexCountPDe(:,:)
     integer,          target, intent(out), optional :: collocation(:)
     logical,                  intent(out), optional :: regDecompFlag
     type(ESMF_TypeKind_Flag), intent(out), optional :: indexTK
     type(ESMF_Index_Flag),    intent(out), optional :: indexflag
     integer,                  intent(out), optional :: connectionCount
     type(ESMF_DistGridConnection), &amp;
                       target, intent(out), optional :: connectionList(:)
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>deCount</TT> to simplify access to this 
                variable. <BR>
Added arguments <TT>connectionCount</TT> and <TT>connectionList</TT>
                to provide user access to the explicitly defined connections in
                a DistGrid.
   
</DD>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added arguments <TT>localDeCount</TT> and <TT>localDeToDeMap</TT>
                to simplify access to these variables.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>indexTK</TT> to allow query of the sequence index
                typekind.
<BR>
Added arguments <TT>elementCountPTileI8</TT> and
                <TT>elementCountPDeI8</TT> to provide 64-bit access.
<BR>
Added argument <TT>indexflag</TT> to allow user to query this
                setting.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> object associated with <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of dimensions (rank) of <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[tileCount]</STRONG></DT>
<DD>Number of tiles in <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>Number of DEs in the DELayout in <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>Number of local DEs in the DELayout in <TT>distgrid</TT> on this PET.
     
</DD>
<DT><STRONG>[minIndexPTile]</STRONG></DT>
<DD>Lower index space corner per tile. Must enter
       allocated with <TT>shape(minIndexPTile) == (/dimCount, tileCount/)</TT>.
     
</DD>
<DT><STRONG>[maxIndexPTile]</STRONG></DT>
<DD>Upper index space corner per tile. Must enter
       allocated with <TT>shape(maxIndexPTile) == (/dimCount, tileCount/)</TT>.
     
</DD>
<DT><STRONG>[elementCountPTile]</STRONG></DT>
<DD>Number of elements in the exclusive region per tile. Must enter
       allocated with <TT>shape(elementCountPTile) == (/tileCount/)</TT>.
       An error will be returned if any of the counts goes above the 32-bit
       limit.
     
</DD>
<DT><STRONG>[elementCountPTileI8]</STRONG></DT>
<DD>Same as <TT>elementCountPTile</TT>, but of 64-bit integer kind.
     
</DD>
<DT><STRONG>[minIndexPDe]</STRONG></DT>
<DD>Lower index space corner per DE. Must enter
       allocated with <TT>shape(minIndexPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[maxIndexPDe]</STRONG></DT>
<DD>Upper index space corner per DE. Must enter
       allocated with <TT>shape(maxIndexPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[elementCountPDe]</STRONG></DT>
<DD>Number of elements in the exclusive region per DE. Must enter
       allocated with <TT>shape(elementCountPDe) == (/deCount/)</TT>.
       An error will be returned if any of the counts goes above the 32-bit
       limit.
     
</DD>
<DT><STRONG>[elementCountPDeI8]</STRONG></DT>
<DD>Same as <TT>elementCountPDe</TT>, but of 64-bit integer kind.
     
</DD>
<DT><STRONG>[localDeToDeMap]</STRONG></DT>
<DD>Global DE index for each local DE. Must enter allocated with
       <TT>shape(localDeToDeMap) == (/localDeCount/)</TT>. It is recommended to
       use a lower bound of 0 for <TT>localDeToDeMap</TT>, in order to support
       direct indexing into this map with a zero-based <TT>localDe</TT> variable.
     
</DD>
<DT><STRONG>[deToTileMap]</STRONG></DT>
<DD>Map each DE uniquely to a tile. Must enter allocated with
       <TT>shape(deToTileMap) == (/deCount/)</TT>. It is recommended to
       use a lower bound of 0 for <TT>deToTileMap</TT>, in order to support
       direct indexing into this map with a zero-based <TT>de</TT> variable.
     
</DD>
<DT><STRONG>[indexCountPDe]</STRONG></DT>
<DD>Number of indices for each dimension per DE. Must enter
       allocated with <TT>shape(indexCountPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[collocation]</STRONG></DT>
<DD>Collocation identifier for each dimension. Must enter
       allocated with <TT>shape(collocation) == (/dimCount/)</TT>.
     
</DD>
<DT><STRONG>[regDecompFlag]</STRONG></DT>
<DD>Decomposition scheme. A return value of <TT>.true.</TT> indicates
       a regular decomposition, i.e. the decomposition is based on a 
       logically rectangular scheme with specific number of DEs along
       each dimension. A return value of <TT>.false.</TT> indicates that the
       decomposition was <EM>not</EM> generated from a regular decomposition 
       description, e.g. a <TT>deBlockList</TT> was used instead.
     
</DD>
<DT><STRONG>[indexTK]</STRONG></DT>
<DD>Typekind used by the global sequence indexing. See section 
       <A HREF="node9.html#const:typekind">54.59</A> for a list of typekind options. Only the integer
       types are supported for sequence indices.
     
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Return the indexing option used by the <TT>distgrid</TT> object. See section
       <A HREF="node9.html#const:indexflag">54.27</A> for a complete list of options.
     
</DD>
<DT><STRONG>[connectionCount]</STRONG></DT>
<DD>Number of explicitly defined connections in <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of explicitly defined connections in <TT>distgrid</TT>. Must enter
       allocated with <TT>shape(connectionList) == (/connectionCount/)</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361600000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_DistGridGet - Get DE-local DistGrid information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetPLocalDe(distgrid, localDe, &amp;
     de, tile, collocation, arbSeqIndexFlag, seqIndexList, seqIndexListI8, &amp;
     elementCount, elementCountI8, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),      intent(in)            :: distgrid
     integer,                  intent(in)            :: localDe
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: de
     integer,                  intent(out), optional :: tile
     integer,                  intent(in),  optional :: collocation
     logical,                  intent(out), optional :: arbSeqIndexFlag
     integer,          target, intent(out), optional :: seqIndexList(:)
 integer(ESMF_KIND_I8),target, intent(out), optional :: seqIndexListI8(:)
     integer,                  intent(out), optional :: elementCount
     integer,                  intent(out), optional :: elementCountI8
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added arguments <TT>de</TT> and <TT>tile</TT> to simplify usage.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added arguments <TT>seqIndexListI8</TT> and <TT>elementCountI8</TT>
                to provide 64-bit access.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>
     
</DD>
<DT><STRONG>[de]</STRONG></DT>
<DD>The global DE associated with the <TT>localDe</TT>. DE indexing starts at 0.
     
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The tile on which the <TT>localDe</TT> is located. Tile indexing starts at 1.
     
</DD>
<DT><STRONG>[collocation]</STRONG></DT>
<DD>Collocation for which information is requested. Default to first
       collocation in <TT>collocation</TT> list.
     
</DD>
<DT><STRONG>[arbSeqIndexFlag]</STRONG></DT>
<DD>A returned value of <TT>.true.</TT> indicates that the <TT>collocation</TT>
       is associated with arbitrary sequence indices. For <TT>.false.</TT>,
       canoncial sequence indices are used.
     
</DD>
<DT><STRONG>[seqIndexList]</STRONG></DT>
<DD>The sequence indices associated with the <TT>localDe</TT>. This argument must
       enter allocated with a size equal to 
       <TT>elementCountPDe(localDeToDeMap(localDe))</TT>.
       An error will be returned if any of the sequence indices are above the
       32-bit limit.
     
</DD>
<DT><STRONG>[seqIndexListI8]</STRONG></DT>
<DD>Same as <TT>seqIndexList</TT>, but of 64-bit integer kind.
     
</DD>
<DT><STRONG>[elementCount]</STRONG></DT>
<DD>Number of elements in the localDe, i.e. identical to
       elementCountPDe(localDeToDeMap(localDe)).
       An error will be returned if the count is above the 32-bit limit.
     
</DD>
<DT><STRONG>[elementCountI8]</STRONG></DT>
<DD>Same as <TT>elementCount</TT>, but of 64-bit integer kind.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361700000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_DistGridGet - Get DE-local DistGrid information for a specific dimension</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetPLocalDePDim(distgrid, localDe, dim, &amp;
            indexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),    intent(in)            :: distgrid
     integer,                intent(in)            :: localDe
     integer,                intent(in)            :: dim
     integer,        target, intent(out)           :: indexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>
     
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension for which information is requested. <TT>[1,..,dimCount]</TT>
     
</DD>
<DT><STRONG>indexList</STRONG></DT>
<DD>Upon return this holds the list of DistGrid tile-local indices
       for <TT>localDe</TT> along dimension <TT>dim</TT>. The supplied variable 
       must be at least of size <TT>indexCountPDe(dim, localDeToDeMap(localDe))</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361800000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_DistGridIsCreated - Check whether a DistGrid object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_DistGridIsCreated(distgrid, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_DistGridIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid), intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>distgrid</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501361900000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_DistGridMatch - Check if two DistGrid objects match</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_DistGridMatch(distgrid1, distgrid2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGridMatch_Flag) :: ESMF_DistGridMatch
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)            :: distgrid1
     type(ESMF_DistGrid),  intent(in)            :: distgrid2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Determine to which level <TT>distgrid1</TT> and <TT>distgrid2</TT> match. 

<P>
Returns a range of values of type <TT>ESMF_DistGridMatch_Flag</TT>,
     indicating how closely the DistGrids match. For a description of the
     possible return values, see&nbsp;<A HREF="#const:distgridmatch">36.2.1</A>. 
     Note that this call only performs PET local matching. Different return values
     may be returned on different PETs for the same DistGrid pair.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501362000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_DistGridPrint - Print DistGrid information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridPrint(distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints internal information about the specified <TT>ESMF_DistGrid</TT> 
       object to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Specified <TT>ESMF_DistGrid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501362100000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_DistGridSet - Set arbitrary sequence for a specific local DE</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridSet()
   subroutine ESMF_DistGridSetPLocalDe(distgrid, localDe, collocation, &amp;
     seqIndexList, seqIndexListI8, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),      intent(inout)         :: distgrid
     integer,                  intent(in)            :: localDe
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(in),  optional :: collocation
     integer,          target, intent(in),  optional :: seqIndexList(:)
 integer(ESMF_KIND_I8),target, intent(in),  optional :: seqIndexListI8(:)
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set DistGrid information for a specific local DE.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is set. <TT>[0,..,localDeCount-1]</TT>
     
</DD>
<DT><STRONG>[collocation]</STRONG></DT>
<DD>Collocation for which information is set. Default to first
       collocation in <TT>collocation</TT> list.
     
</DD>
<DT><STRONG>[seqIndexList]</STRONG></DT>
<DD>Sequence indices for the elements on <TT>localDe</TT>. The <TT>seqIndexList</TT>
       must provide exactly <TT>elementCountPDe(localDeToDeMap(localDe)</TT> many
       entries. When this argument is present, the <TT>indexTK</TT> of
       <TT>distgrid</TT> will be set to <TT>ESMF_TYPEKIND_I4</TT>.
       This argument is mutually exclusive with <TT>seqIndexListI8</TT>. Only one
       or the other must be provided. An error will be returned otherwise.
     
</DD>
<DT><STRONG>[seqIndexListI8]</STRONG></DT>
<DD>Same as <TT>seqIndexList</TT>, but of 64-bit integer kind.
       When this argument is present, the <TT>indexTK</TT> of
       <TT>distgrid</TT> will be set to <TT>ESMF_TYPEKIND_I8</TT>.
       This argument is mutually exclusive with <TT>seqIndexList</TT>. Only one
       or the other must be provided. An error will be returned otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501362200000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_DistGridValidate - Validate DistGrid internals</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridValidate(distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>distgrid</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Specified <TT>ESMF_DistGrid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H2><A NAME="SECTION050137000000000000000"></A>
<A NAME="ref:distgridconnection"></A>
<BR>
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: DistGridConnection Methods
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050137100000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DistGridConnectionGet - Get DistGridConnection</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridConnectionGet(connection, &amp;
     tileIndexA, tileIndexB, dimCount, positionVector, orientationVector, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGridConnection), intent(in)            :: connection
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                       intent(out), optional :: tileIndexA
     integer,                       intent(out), optional :: tileIndexB
     integer,                       intent(out), optional :: dimCount
     integer,                       intent(out), optional :: positionVector(:)
     integer,                       intent(out), optional :: orientationVector(:)
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DistGridConnectionGet"></A>     Get connection parameters from an <TT>ESMF_DistGridConnection</TT> object.
     This interface provides access to all variables required to create a new
     connection using the <TT>ESMF_DistGridConnectionSet()</TT> method.

<P>
The arguments are:
     <DL>
<DT><STRONG>connection</STRONG></DT>
<DD>DistGridConnection object.
     
</DD>
<DT><STRONG>[tileIndexA]</STRONG></DT>
<DD>Index of one of the two connected tiles.
     
</DD>
<DT><STRONG>[tileIndexB]</STRONG></DT>
<DD>Index of the other connected tile.
     
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of dimensions of <TT>positionVector</TT>.
     
</DD>
<DT><STRONG>[positionVector]</STRONG></DT>
<DD>Position of tile B's minIndex with respect to tile A's minIndex.
       This array's size should be at least equal to <TT>dimCount</TT>.
     
</DD>
<DT><STRONG>[orientationVector]</STRONG></DT>
<DD>Lists which dimension of tile A is associated to which dimension of
       tile B. Negative index values may be used to indicate a reversal
       in index orientation. Should be at least of size <TT>dimCount</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050137200000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_DistGridConnectionSet - Set DistGridConnection</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridConnectionSet(connection, tileIndexA, tileIndexB, &amp;
     positionVector, orientationVector, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGridConnection),intent(out)         :: connection
     integer,                     intent(in)           :: tileIndexA
     integer,                     intent(in)           :: tileIndexB
     integer,                     intent(in)           :: positionVector(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                     intent(in), optional :: orientationVector(:)
     integer,                     intent(out), optional:: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DistGridConnectionSet"></A>     Set an <TT>ESMF_DistGridConnection</TT> object to represent a connection 
     according to the provided index space information.

<P>
The arguments are:
     <DL>
<DT><STRONG>connection</STRONG></DT>
<DD>DistGridConnection object.
     
</DD>
<DT><STRONG>tileIndexA</STRONG></DT>
<DD>Index of one of the two tiles that are to be connected.
     
</DD>
<DT><STRONG>tileIndexB</STRONG></DT>
<DD>Index of one of the two tiles that are to be connected.
     
</DD>
<DT><STRONG>positionVector</STRONG></DT>
<DD>Position of tile B's minIndex with respect to tile A's minIndex.
     
</DD>
<DT><STRONG>[orientationVector]</STRONG></DT>
<DD>Associates each dimension of tile A with a dimension in tile B's 
       index space. Negative index values may be used to indicate a 
       reversal in index orientation. It is erroneous to associate multiple
       dimensions of tile A with the same index in tile B. By default
       <TT>orientationVector = (/1,2,3,.../)</TT>, i.e. same orientation as tile A.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H2><A NAME="SECTION050138000000000000000"></A>
<A NAME="ref:distgridregdecomp"></A>
<BR>
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">8</SPAN> Class API: DistGridRegDecomp Methods
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050138100000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DistGridRegDecompSetCubic - Construct a DistGrid regDecomp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridRegDecompSetCubic(regDecomp, deCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,        target, intent(out)           :: regDecomp(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: deCount
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Construct a regular decomposition argument for DistGrid that is most cubic
     in <TT>dimCount</TT> dimensions, and multiplies out to <TT>deCount</TT> DEs. The
     factorization is stable monotonic decreasing, ensuring that earlier entries
     in <TT>regDecomp</TT> are larger or equal to the later entires.

<P>
The arguments are:
     <DL>
<DT><STRONG>regDecomp</STRONG></DT>
<DD>The regular decomposition description being constructed.
     
</DD>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>The number of DEs. Defaults to <TT>petCount</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION050140000000000000000">
<SPAN CLASS="arabic">37</SPAN> RouteHandle Class</A>
</H1>

<H2><A NAME="SECTION050141000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:RHandle"></A>
<P>
The ESMF RouteHandle class provides a unified interface for all route-based communication methods across the Field, FieldBundle, Array, and ArrayBundle classes. All route-based communication methods implement a pre-computation step, returning a RouteHandle, an execution step, and a release step. Typically the pre-computation, or Store() step will be a lot more expensive (both in memory and time) than the execution step. The idea is that once precomputed, a RouteHandle will be executed many times over during a model run, making the execution time a very performance critical piece of code. In ESMF, Regridding, Redisting, and Haloing are implemented as route-based communication methods. The following sections discuss the RouteHandle concepts that apply uniformly to all route-based communication methods, across all of the above mentioned classes.

<P>

<H2><A NAME="SECTION050142000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The user interacts with the RouteHandle class through the route-based communication methods of Field, FieldBundle, Array, and ArrayBundle. The usage of these methods are described in detail under their respective class documentation section. The following examples focus on the RouteHandle aspects common across classes and methods.

<P>

<P>

<P>

<H3><A NAME="SECTION050142100000000000000"></A>
   <A NAME="RH:bfb"></A>
<BR>
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Bit-for-bit reproducibility
</H3>

<P>
Bit-for-bit (bfb) reproducibility is at the core of the regression testing
   schemes of many scientific model codes. The bfb requirement makes it possible
   to easily compare the numerical results of simulation runs using standard
   binary diff tools.

<P>
While bfb reproducibility is desirable (and often required) for regression
   testing, it does limit the available performance optimization
   opportunities. Especially in highly parallelized code, best performance is 
   often achieved by allowing operations to occur in a flexible order. Under
   some conditions, however, a change in the order of numerical operations
   leads to small numerical differences in the results, breaking bfb
   reproducibility.

<P>
ESMF provides the following three levels of bfb reproducibility 
   support, with the associated performance optimization implications:

<P>

<UL>
<LI>Strict bit-for-bit reproducibility: Results are guaranteed to be 
   bit-for-bit identical even when executing across different numbers of PETs. 
   The optimization options are limited to memory layout and message aggregation.

<P>
</LI>
<LI>Relaxed bit-for-bit reproducibility: Results are only guaranteed to be
   bit-for-bit identical when running across an unchanged number of PETs. The 
   optimization options include partial sums, allowing computational load to 
   be balanced between source and destination PETs, and message sizes to be 
   reduced.

<P>
</LI>
<LI>No guarantee for bit-for-bit reproducibility: Results may differ by 
   numerical round-off. The optimization options include dynamic out-of-order
   summation of partial sums.

<P>
</LI>
</UL>

<P>
The following discussion uses very simple numerical examples to demonstrate
   how the order of terms in a sum can lead to results that are not
   bit-for-bit identical. The examples use single precision,
   <TT>ESMF_KIND_R4</TT> numbers, but the concepts apply the same
   to double precision, <TT>ESMF_KIND_R8</TT>; only that the decimals, for
   which bfb differences in the sums occur, are different ones.

<P>
With <TT>sumA</TT>, <TT>sumB</TT>, <TT>sumC</TT>, <TT>sumD</TT>, and <TT>sumE</TT> all of
   type <TT>real(ESMF_KIND_R4)</TT>, one finds the following bfb differences:
<P>
<PRE>
  sumA = (0.5 + 0.1) + 0.1        ! results in 0.700000048
  sumB = 0.5 + (0.1 + 0.1)        ! results in 0.699999988
  
  sumC = 0.5 +  0.2 + 0.1  + 0.1  ! results in 0.900000036
  sumD = 0.5 + (0.2 + 0.1) + 0.1  ! results in 0.900000036
  sumE = 0.5 + (0.2 + 0.1 + 0.1)  ! results in 0.899999976
</PRE>

<P>
These differences result from the fact that many decimals (even very simple
   ones like 0.1 or 0.2) lead to periodic binary floating point numbers.
   Periodic floating point numbers must be truncated when represented by a
   finite number of bits, leading to small rounding errors. Further truncation
   occurs when the radix point of two numbers must be aligned during
   floating point arithmetic, resulting in bit shifts for one of the
   numbers. The resulting truncation error depends on the precise numbers that
   need alignment. As a result, executing the "same" sum in a different order
   can lead to different truncation steps and consequently in results that are
   not bit-for-bit identical.

<P>
In order to help users with the implementation of their bfb requirement, 
   ESMF provides different levels of control over the term order in sparse 
   matrix multiplications, while at the same time offering performance 
   optimization options. In all there are <EM>three</EM> arguments that will be
   introduced in the following paragraphs: <TT>srcTermProcessing</TT>, 
   <TT>termorderflag</TT>, and <TT>pipelineDepth</TT>.

<P>
For the purpose of demonstration, a one-dimensional, arbitrarily distributed 
   source Array is constructed. There are three Array elements on each of the
   four PETs. Their local storage indices, sequence indices, and data values
   are as follows:

<P>
<PRE>
  
           +-----+-------+----------------+------------+
           | PET | index | sequence index | data value |
           +-----+-------+----------------+------------+
           |  0  |   1   |          1     |     0.5    |
           |  0  |   2   |          6     |     0.1    |
           |  0  |   3   |          9     |     0.1    |
           +-----+-------+----------------+------------+
           |  1  |   1   |          4     |     0.5    |
           |  1  |   2   |          3     |     0.1    |
           |  1  |   3   |         10     |     0.1    |
           +-----+-------+----------------+------------+
           |  2  |   1   |         11     |     0.5    |
           |  2  |   2   |          7     |     0.1    |
           |  2  |   3   |          5     |     0.1    |
           +-----+-------+----------------+------------+
           |  3  |   1   |          8     |     0.1    |
           |  3  |   2   |          2     |     0.2    |
           |  3  |   3   |         12     |     0.1    |
           +-----+-------+----------------+------------+
</PRE> 

<P>
The destination Array consists of only a single element, located on PET 0:

<P>
<PRE>
  
           +-----+-------+----------------+------------+
           | PET | index | sequence index | data value |
           +-----+-------+----------------+------------+
           |  0  |   1   |          1     |     n/a    |
           +-----+-------+----------------+------------+
</PRE> 

<P>
As a first example consider the following sparse matrix with three entries:
<P>
<PRE>
    factorIndexList(1,1) = 1  ! src seq index
    factorIndexList(2,1) = 1  ! dst seq index
    factorList(1) = 1.
    factorIndexList(1,2) = 6  ! src seq index
    factorIndexList(2,2) = 1  ! dst seq index
    factorList(2) = 1.
    factorIndexList(1,3) = 9  ! src seq index
    factorIndexList(2,3) = 1  ! dst seq index
    factorList(3) = 1.
</PRE>

<P>
In ESMF, the order in which the sparse matrix entries are specified in 
   <TT>factorIndexList</TT> and <TT>factorList</TT>, or on which PET they
   are provided, is completely irrelevant. The term order in the resulting
   sparse matrix sums is not affected by it.

<P>
There is one aspect of the sparse matrix format, however, that is relevant
   to the bfb considerations: When multiple entries for the same (src, dst)
   pair are present in a sparse matrix definition, the entries are summed
   into a single (src, dst) entry. Therefore, even if there are multiple
   sparse matrix entries for the same (src, dst) pair, there will only be a
   single term for it in the resulting expression.

<P>
Going back to the three term sparse matrix definition above, the 
   <EM>canonical</EM> term order is defined by the source sequence indices in 
   ascending order. With <TT>(src,dst)</TT> denoting the sparse matrix factors,
   and <TT>s(src)</TT> and <TT>d(dst)</TT> denoting source and destination Array
   elements, respectively, for <TT>src</TT> and <TT>dst</TT> sequence indices, the
   sum in canonical order is:

<P>
d(1) = (1,1)*s(1) + (6,1)*s(6) + (9,1)*s(9)

<P>
For simplicity, the factors in all of the examples are set to <TT>1.0</TT>, allowing us
   to drop them in the expressions. This helps focus on the critical issue - 
   term order:

<P>
d(1) = s(1) + s(6) + s(9)

<P>
There are two parameters that affect term order in the ESMF sparse matrix
   multiplication (SMM), and therefore must be considered in the context of bfb
   reproducibility. First there is the <TT>srcTermProcessing</TT> parameter which
   controls grouping of source terms located on the same PET. The value of the
   <TT>srcTermProcessing</TT> parameter indicates the maximum number of terms that
   may be grouped into partial sums on the source PET. Setting
   <TT>srcTermProcessing</TT> to 1 means that no partial sums are formed on the 
   source side, however, the source terms are multiplied with their
   respective sparse matrix factor before being sent to the destination PET. 
   Setting <TT>srcTermProcessing</TT> to 0 prevents these products from being carried
   out on the source side, and the source Array elements are sent unmodified.
   Depending on the distribution of the source Array, values greater than 1
   for <TT>srcTermProcessing</TT> can lead to partial sums and thus may have
   impact on the bfb reproducibility of the SMM.

<P>
The second parameter that may have bfb effects comes into play at 
   execution-time of a precomputed 
   RouteHandle. It is accessible via the <TT>termorderflag</TT> argument; a typed 
   flag with the following values:
   
<UL>
<LI><TT>ESMF_TERMORDER_SRCSEQ</TT> - Strictly enforces the canonical order
        of the source terms according to the source sequence index. However, 
        terms that are grouped together in the RouteHandle at store-time, as a 
        consequence of <TT>srcTermProcessing</TT>, are treated as
        single entities with a sequence index equal to the lowest original
        sequence index in the group. Use <TT>ESMF_TERMORDER_SRCSEQ</TT> together
        with <TT>srcTermProcessing=0</TT> or <TT>srcTermProcessing=1</TT> when strict
        bfb reproducibility is required independent of the source Array 
        distribution, e.g. for different number of PETs.
</LI>
<LI><TT>ESMF_TERMORDER_SRCPET</TT> - The source terms in the sum are 
        first arranged according to the relative position of the PET on which 
        they reside with respect to the destination PET. Second, all the terms
        coming from the same PET are sorted in canonical sequence index order
        and summed into partial sums. Again, terms that are grouped together
        in the RouteHandle at store-time are treated as
        single entities with a sequence index equal to the lowest original
        sequence index in the group. The final result for each destination
        element is determined by adding the partial sums in an order that is 
        fixed by the position of the partial sums' source PETs relative to
        the destination PET. This ensures bfb reproducibility of the result as
        long as the number of PETs remains unchanged.
</LI>
<LI><TT>ESMF_TERMORDER_FREE</TT> - For this option there are no
        restrictions on the term
        order. Terms can be summed in any order, and the order may change each
        time the RouteHandle is executed. This option grants greatest flexibility
        to the RouteHandle execution implementation. It is available for all the
        methods that take the <TT>termorderflag</TT> argument. Without a
        guaranteed source term order, the <TT>ESMF_TERMORDER_FREE</TT> option is
        not suitable for situations that require bfb reproducibility. 
   
</LI>
</UL> 

<P>
<B>ESMF_TERMORDER_SRCSEQ</B>

<P>
First using <TT>srcTermProcessing=0</TT> at store time and
   <TT>termorderflag=ESMF_TERMORDER_SRCSEQ</TT> at execution time,
   the canonical term order is expected:

<P>
d(1) = s(1) + s(6) + s(9) = 0.5 + 0.1 + 0.1 = sumA
  
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing = 0
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCSEQ, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCSEQ#1 = ", farrayPtr(1), " expect: ", sumA
    if (farrayPtr(1) /= sumA) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
The order of source terms across PETs is expected to have no effect on the
   bfb reproducibility of the result for <TT>ESMF_TERMORDER_SRCSEQ</TT>. To test
   this, a sparse matrix is used where the source terms originate from different
   PETs.
<P>
<PRE>
    factorIndexList(1,1) = 4  ! src seq index
    factorIndexList(2,1) = 1  ! dst seq index
    factorList(1) = 1.
    factorIndexList(1,2) = 5  ! src seq index
    factorIndexList(2,2) = 1  ! dst seq index
    factorList(2) = 1.
    factorIndexList(1,3) = 12 ! src seq index
    factorIndexList(2,3) = 1  ! dst seq index
    factorList(3) = 1.
</PRE>

<P>
Again the <TT>srcTermProcessing</TT> argument is kept at 0, ensuring that none
   of the source terms are grouped into partial sums.
  
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing = 0
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCSEQ, rc=rc)
</PRE>

<P>
Under <TT>ESMF_TERMORDER_SRCSEQ</TT> it does not matter on which PET a
   source term is located, the order of source terms is strictly defined by the
   order of source sequence indices:

<P>
d(1) = s(4) + s(5) + s(12) = 0.5 + 0.1 + 0.1 = sumA
  
<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCSEQ#2 = ", farrayPtr(1), " expect: ", sumA
    if (farrayPtr(1) /= sumA) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
The same sparse matrix leads to bfb differences in the result when executed
   with the <TT>ESMF_TERMORDER_SRCPET</TT> option. This is demonstrated further
   down in result <TT>SRCPET#4</TT>. 

<P>
<B>ESMF_TERMORDER_SRCPET</B>

<P>
<B>All source terms coming from the same PET</B>

<P>
In the following examples the <TT>srcTermProcessing</TT> argument at store-time
   is first set to 0, forcing all of the source terms to be sent to the
   destination PET unmodified. We start by going back to the initial sparse
   matrix where all of the source terms are located on the same PET.
<P>
<PRE>
    factorIndexList(1,1) = 1  ! src seq index
    factorIndexList(2,1) = 1  ! dst seq index
    factorList(1) = 1.
    factorIndexList(1,2) = 6  ! src seq index
    factorIndexList(2,2) = 1  ! dst seq index
    factorList(2) = 1.
    factorIndexList(1,3) = 9  ! src seq index
    factorIndexList(2,3) = 1  ! dst seq index
    factorList(3) = 1.
</PRE>

<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=0
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
Then, at execution time, the <TT>ESMF_TERMORDER_SRCPET</TT> option is used.
<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
Here all of the source elements originate from the same PET (PET 0). This
   fact, together with the <TT>ESMF_TERMORDER_SRCPET</TT> execution-time option,
   results in the following canonical term order:

<P>
d(1) = s(1) + s(6) + s(9) = 0.5 + 0.1 + 0.1 = sumA

<P>
This is exactly the same term order that was used above to produce the
   result stored in <TT>sumA</TT>.
<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#1 = ", farrayPtr(1), " expect: ", sumA
    if (farrayPtr(1) /= sumA) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
The sequence indices of the source terms are the only relevant aspect in 
   determining the source term order. Consider, for example, the following 
   sparse matrix, where again all source terms are located on the same PET 
   (PET 2):
<P>
<PRE>
    factorIndexList(1,1) = 11 ! src seq index
    factorIndexList(2,1) = 1  ! dst seq index
    factorList(1) = 1.
    factorIndexList(1,2) = 5  ! src seq index
    factorIndexList(2,2) = 1  ! dst seq index
    factorList(2) = 1.
    factorIndexList(1,3) = 7  ! src seq index
    factorIndexList(2,3) = 1  ! dst seq index
    factorList(3) = 1.
</PRE>

<P>
This time the source term order in memory is not the same
   as their sequence index order. Specifically, the sequence indices of the
   source terms, in the order they are stored in memory, is 11, 7, 5 (see the
   source Array diagram above for reference). 
   Further, as mentioned already, the order of entries in the sparse matrix
   also have not bearing on the term order in the SMM sums.
   Then, for the <TT>ESMF_TERMORDER_SRCPET</TT> option, and because all source
   terms are located on the same PET, the resulting source term order is the 
   canonical one determined by the source term sequence indices alone:

<P>
d(1) = s(5) + s(7) + s(11)

<P>
Filling in the source element data, we find

<P>
d(1) = 0.1 + 0.1 + 0.5,

<P>
which is expected to be bfb equivalent to the result stored in <TT>sumB</TT>
   from above.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=0
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#2 = ", farrayPtr(1), " expect: ", sumB
    if (farrayPtr(1) /= sumB) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
<B>Source terms coming from different PETs</B>

<P>
When the source terms are distributed across multiple PETs, the 
   <TT>ESMF_TERMORDER_SRCPET</TT> option first bundles the terms according to
   the PET on which they are stored. These source term "bundles" are then 
   arranged in an order that depends on the source PET position relative to the
   destination PET: starting with the bundle for which the source PET is the
   same as the destination PET, the source term bundles are placed in descending
   order with respect to their source PET, modulo petCount. The terms within
   each source term bundle are further sorted in the canonical order according
   to their sequence index.

<P>
The following sparse matrix demonstrates the effect of the
   <TT>ESMF_TERMORDER_SRCPET</TT> option.
<P>
<PRE>
    factorIndexList(1,1) = 1  ! src seq index
    factorIndexList(2,1) = 1  ! dst seq index
    factorList(1) = 1.
    factorIndexList(1,2) = 3  ! src seq index
    factorIndexList(2,2) = 1  ! dst seq index
    factorList(2) = 1.
    factorIndexList(1,3) = 7  ! src seq index
    factorIndexList(2,3) = 1  ! dst seq index
    factorList(3) = 1.
</PRE>

<P>
Here the source terms are located on PETs 0, 1, and 2. Using a [] notion to
   indicate the source PET of each term, the term order under 
   <TT>ESMF_TERMORDER_SRCPET</TT> is given by:

<P>
d(1) = s(1)[0] + s(7)[2] + s(3)[1] = 0.5 + 0.1 + 0.1

<P>
This is again the same order of terms that was used to produce the result 
   stored in <TT>sumA</TT> above.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=0
    
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#3 = ", farrayPtr(1), " expect: ", sumA
    if (farrayPtr(1) /= sumA) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
In the above example, the fact that the terms were ordered by source PET
   first, did not lead to numerical bfb differences compared to the canonical 
   source term order. However, this was purely coincidental in the way the
   numbers worked out for this example. The following case looks at a situation
   where the source PET order <EM>does</EM> lead to a result that shows bfb
   differences compared to the canonical term order.
<P>
<PRE>
    factorIndexList(1,1) = 4  ! src seq index
    factorIndexList(2,1) = 1  ! dst seq index
    factorList(1) = 1.
    factorIndexList(1,2) = 5  ! src seq index
    factorIndexList(2,2) = 1  ! dst seq index
    factorList(2) = 1.
    factorIndexList(1,3) = 12 ! src seq index
    factorIndexList(2,3) = 1  ! dst seq index
    factorList(3) = 1.
</PRE>

<P>
The canonical source term order of this SMM sum, determined by the source
   sequence indices alone, is:

<P>
d(1) = s(4) + s(5) + s(12) = 0.5 + 0.1 + 0.1,

<P>
which again would lead to a result that is bfb identical to <TT>sumA</TT>. 
   However, this is not the term order resulting from the
   <TT>ESMF_TERMORDER_SRCPET</TT> option. The actual order for this option is:

<P>
d(1) = s(12)[3] + s(5)[2] + s(4)[1] = 0.1 + 0.1 + 0.5,

<P>
resulting in a sum that is bfb identical to <TT>sumB</TT> instead.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=0
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#4 = ", farrayPtr(1), " expect: ", sumB
    if (farrayPtr(1) /= sumB) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
<B>Grouping of source terms coming from the same PET</B>

<P>
So far the <TT>srcTermProcessing</TT> argument was kept at 0, and therefore
   source term grouping had not to be considered. Source term grouping is only
   possible for terms that originate from the same PET. In preparation
   for a closer look at the bfb effects of source term grouping, consider a 
   sparse matrix where two of the source terms are located on the same PET.
<P>
<PRE>
    factorIndexList(1,1) = 1  ! src seq index
    factorIndexList(2,1) = 1  ! dst seq index
    factorList(1) = 1.
    factorIndexList(1,2) = 5  ! src seq index
    factorIndexList(2,2) = 1  ! dst seq index
    factorList(2) = 1.
    factorIndexList(1,3) = 7  ! src seq index
    factorIndexList(2,3) = 1  ! dst seq index
    factorList(3) = 1.
</PRE>

<P>
Here one of the source terms is located on PET 0 while the other two
   source terms are originating on PET 2. Keeping the <TT>srcTermProcessing</TT>
   argument at 0 first, the term order under <TT>ESMF_TERMORDER_SRCPET</TT> is 
   given by:

<P>
d(1) = s(1)[0] + s(5)[2] + s(7)[2] = 0.5 + 0.1 + 0.1

<P>
And again the result is expected to be bfb identical to the number stored 
   in <TT>sumA</TT>.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=0
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#5 = ", farrayPtr(1), " expect: ", sumA
    if (farrayPtr(1) /= sumA) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
The same result is also expected with <TT>srcTermProcessing</TT> set to 1. A
   value of 1 indicates that the multiplication of the source term with its
   sparse matrix factor is carried out on the source side before being sent to 
   the destination PET. The final sum is still carried out in the same order on
   the destination PET, essentially resulting in the exact same bfb identical
   sum as for <TT>srcTermProcessing</TT> set to 0.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=1
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#6 = ", farrayPtr(1), " expect: ", sumA
    if (farrayPtr(1) /= sumA) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
Increasing the <TT>srcTermProcessing</TT> argument to 2 (or higher) results in 
   source term grouping of the terms (up to the number specified in 
   <TT>srcTermProcessing</TT>) that are on the same source PET.

<P>
d(1) = s(1)[0] + ( s(5)[2] + s(7)[2] ) = 0.5 + (0.1 + 0.1)

<P>
This result is bfb identical to first adding 0.1 and 0.1 into a partial sum,
   and then adding this sum to 0.5. This is the exact grouping of
   terms that was used to obtain the result stored in <TT>sumB</TT> from above.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=2
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#7 = ", farrayPtr(1), " expect: ", sumB
    if (farrayPtr(1) /= sumB) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
In order to explore the effects of the <TT>srcTermProcessing</TT> argument
   further, more terms on the same source PET are needed in the SMM sum.
   The following sparse matrix has four entries, three of which originate from
   the same PET (PET 3).
<P>
<PRE>
    factorIndexList(1,1) = 1  ! src seq index
    factorIndexList(2,1) = 1  ! dst seq index
    factorList(1) = 1.
    factorIndexList(1,2) = 2  ! src seq index
    factorIndexList(2,2) = 1  ! dst seq index
    factorList(2) = 1.
    factorIndexList(1,3) = 8  ! src seq index
    factorIndexList(2,3) = 1  ! dst seq index
    factorList(3) = 1.
    factorIndexList(1,4) = 12 ! src seq index
    factorIndexList(2,4) = 1  ! dst seq index
    factorList(4) = 1.
</PRE>

<P>
Setting the <TT>srcTermProcessing</TT> argument back to 0 puts the terms in 
   PET order, and canonical order for each PET bundle.

<P>
d(1) = s(1)[0] + s(2)[3] + s(8)[3] + s(12)[3] = 0.5 + 0.2 + 0.1 + 0.1

<P>
The bfb identical result for this sum was calculated and stored in variable
   <TT>sumC</TT> above.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=0
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#8 = ", farrayPtr(1), " expect: ", sumC
    if (farrayPtr(1) /= sumC) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
Setting the <TT>srcTermProcessing</TT> argument to a value of 2 results in the 
   following source term grouping:

<P>
d(1) = s(1)[0] + ( s(2)[3] + s(8)[3] ) + s(12)[3]
            = 0.5 + ( 0.2 + 0.1 ) + 0.1,

<P>
where the (0.2 + 0.1) partial sum is carried out on source PET 3, and
   then sent to the destination PET (PET 0), together with the unmodified data 
   from source element 8 (0.1). The final sum is performed on PET 0. The
   result is identical to the precomputed value stored in <TT>sumD</TT>. The 
   numbers work out in a way where this result is bfb identical to the
   previous result, i.e. <TT>sumC</TT>. However, this bfb match is purely 
   coincidental.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=2
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#9 = ", farrayPtr(1), " expect: ", sumD
    if (farrayPtr(1) /= sumD) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
Increasing the <TT>srcTermProcessing</TT> argument up to 3 results in a three
   term partial sum on PET 3:

<P>
d(1) = s(1)[0] + ( s(2)[3] + s(8)[3] + s(12)[3] )
            = 0.5 + ( 0.2 + 0.1 + 0.1 ).

<P>
Again the final sum is performed on PET 0. The result is bfb identical to
   the number stored in <TT>sumE</TT>, which, for the chosen numbers, works out to
   have a bfb difference compared to <TT>sumC</TT> and <TT>sumD</TT>.
<P>
<PRE>
  ! forced srcTermProcessing
  srcTermProcessing=3
  
  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    print *, "result SRCPET#10 = ", farrayPtr(1), " expect: ", sumE
    if (farrayPtr(1) /= sumE) &amp;
      finalrc = ESMF_FAILURE
  endif
</PRE>

<P>
<B>Reproducibility and Performance</B>

<P>
The above examples show how bit-for-bit (bfb) reproducibility is a result of
   controlling the term order. ESMF offers several options to control the term
   order in the sparse matrix multiplication (SMM) implementation:

<UL>
<LI>To guarantee bfb reproducibility between consecutive executions of the
   same RouteHandle object, the <TT>ESMF_TERMORDER_SRCPET</TT> execution-time 
   option suffices.
</LI>
<LI>If bfb reproducibility is required between <EM>different</EM> RouteHandles, 
   e.g. a RouteHandle that is precomputed each time the application starts, 
   then it must be further ensured that the same value of <TT>srcTermProcessing</TT>
   is specified during the store call. Under these conditions the ESMF SMM 
   implementation guarantees bfb identical results between runs, as long as the
   number of PETs does not change.
</LI>
<LI>To guarantee bfb reproducibility between different runs, even when the
   number of PETs, and therefore the data distribution changes, the execution
   option <TT>ESMF_TERMORDER_SRCSEQ</TT> must be chosen together with
   <TT>srcTermProcessing</TT> equal to 0 or 1 (in order to prevent partial sums).
   
</LI>
</UL>

<P>
The term order in a SMM operation does not only affect the bfb
   reproducibility of the result, but also affects the SMM <EM>performance</EM>. 
   The precise performance implications of a specific term order are
   complicated and strongly depend on the exact problem structure, as well as
   on the details of the compute hardware. ESMF implements an auto-tuning 
   mechanism that can be used to conveniently determine a close to optimal set
   of SMM performance parameters.

<P>
There are two SMM performance parameters in ESMF that are encoded into a
   RouteHandle during store-time: <TT>srcTermProcessing</TT> and
   <TT>pipelineDepth</TT>. The first one affects the term order in the SMM sums and 
   has been discussed in detail above. The second parameter, <TT>pipelineDepth</TT>,
   determines how many in- and out-bound messages may be outstanding on each
   PET. It has no effect on the term order and does not lead to bfb differences
   in the SMM results. However, in order to achieve good performance
   reproducibility, the user has the option to pass in a fixed value of the
   <TT>pipelineDepth</TT> argument when precomputing RouteHandles.

<P>
Store calls that take the <TT>srcTermProcessing</TT> and/or <TT>pipelineDepth</TT>
   argument specify them as <TT>optional</TT> with <TT>intent(inout)</TT>. Omitting the
   argument when calling, or passing a variable that is set to a negative
   number, indicates that the respective parameter needs to be determined by
   the library. Further, if a variable with a negative value was passed in, then
   the variable is overwritten and replaced by the auto-tuned value on return. Through
   this mechanism a user can leverage the built-in auto-tuning feature of ESMF to
   obtain the best possible performance for a specific problem on a particular
   compute hardware, while still ensuring bfb and performance
   reproducibility between runs. The following example shows code that first
   checks if previously stored SMM performance parameters are available in a
   file on disk, and then either reads and uses them, or else uses auto-tuning
   to determine the parameters before writing them to file. For simplicity the
   same sparse matrix as in the previous example is used.
  
<P>
<PRE>
  ! precondition the arguments for auto-tuning and overwriting
  srcTermProcessing = -1  ! init negative value
  pipelineDepth     = -1  ! init negative value

  ! get a free Fortran i/o unit
  call ESMF_UtilIOUnitGet(unit=iounit, rc=rc)
</PRE>

<P>
<PRE>
  ! try to open the file that holds the SMM parameters
  open(unit=iounit, file="smmParameters.dat", status="old", action="read", &amp;
    form="unformatted", iostat=iostat)
  
  if (iostat == 0) then
    ! the file was present -&gt; read from it and close it again
    read(unit=iounit, iostat=iostat) srcTermProcessing, pipelineDepth, &amp;
      sumCompare
    close(unit=iounit)
  endif
  
  if ((localPet == 0) .and. (iostat == 0)) then
    print *, "SMM parameters successfully read from file"
    print *, " srcTermProcessing=", srcTermProcessing, " pipelineDepth=", &amp;
      pipelineDepth, " ==&gt;&gt; sumCompare=", sumCompare
  endif

  call ESMF_ArraySMMStore(srcArray, dstArray, &amp;
    factorIndexList=factorIndexList, factorList=factorList, &amp;
    routehandle=rh, srcTermProcessing=srcTermProcessing, &amp;
    pipelineDepth=pipelineDepth, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySMM(srcArray, dstArray, routehandle=rh, &amp;
    termorderflag=ESMF_TERMORDER_SRCPET, rc=rc)
</PRE>

<P>
<PRE>
  if ((localPet == 0) .and. (iostat /= 0)) then
    print *, "SMM parameters determined via auto-tuning -&gt; dump to file"
    open(unit=iounit, file="smmParameters.dat", status="unknown", &amp;
      action="write", form="unformatted")
    write(unit=iounit) srcTermProcessing, pipelineDepth, farrayPtr(1)
    close(unit=iounit)
  endif
  
  if (localPet == 0) then
    if (iostat /= 0) then
      ! cannot do bfb comparison of the result without reference
      print *, "result SRCPET#11 = ", farrayPtr(1)
    else
      ! do bfb comparison of the result against reference
      print *, "result SRCPET#11 = ", farrayPtr(1), " expect: ", sumCompare
      if (farrayPtr(1) /= sumCompare) then
        finalrc = ESMF_FAILURE
        write (msg, *) "Numerical difference detected: ", &amp;
          farrayPtr(1)-sumCompare
        call ESMF_LogWrite(msg, ESMF_LOGMSG_INFO)
      endif
    endif
  endif
</PRE>

<P>
Running this example for the first time exercises the auto-tuning branch. The
   auto-tuned <TT>srcTermProcessing</TT> and <TT>pipelineDepth</TT> parameters are
   then used in the SMM execution, as well as written to file. The SMM result
   variable is also written to the same file for test purposes.
   Any subsequent execution of the same example branches into the code that
   reads the previously determined SMM execution parameters from file, re-using
   them during store-time. This ensures bfb reproducibility of the SMM result, 
   which is tested in this example by comparing to the previously stored value.


<P>

<P>

<P>

<H3><A NAME="SECTION050142200000000000000"></A>
   <A NAME="RH:asyncVMEpoch"></A>
<BR>
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Asynchronous RouteHandle communication with VMEpoch
</H3>

<P>
The RouteHandle based communication calls of the Array and Field classes
   provide the <TT>routesyncflag</TT> argument. This argument allows the user to
   specify that the initiated call should not block. Additional calls are
   necessary to wait for a previously initiated communication call to finish.
   For a detailed discussion see section <A HREF="#Array:CommNB">28.2.20</A>.
   Building on these primitives, asynchronous communications patterns can be
   implemented in user code. However, a more elegant option to achive
   asynchronous behavior between sending and receiving PETs of RouteHandle based
   communications is provided by the VMEpoch feature discussed here.

<P>
The VMEpoch is a low level message aggregation and buffering approach.
   The VM level details are discussed under the ESMF_VM section in
   <A HREF="node6.html#VM:NBVMEpoch">51.3.11</A>.

<P>
There are several advantages of VMEpoch over the direct use of non-blocking
   RouteHandle based communication calls:

<P>

<UL>
<LI>Multiple different RouteHandles can be aggregated within the same epoch.
    This allows mixing of Redist(), Regrid(), and SMM() operations, and the
    aggregating of all messages.

<P>
</LI>
<LI>The <EM>same</EM> RouteHandle can be used several times within the same
    epoch. This is not possible under the direct non-blocking execution.

<P>
</LI>
<LI>ArrayBundle and FieldBundle communications are supported. This is not
    available for the direct non-blocking execution.

<P>
</LI>
</UL>

<P>
The <TT>ESMF_VMEpoch</TT> API consists of two interfaces:
   <TT>ESMF_VMEpochEnter()</TT> and <TT>ESMF_VMEpochExit()</TT>. Inside an epoch,
   communication calls are aggregated. Data transfers on the 
   <TT>src</TT> side are not issued until the epoch is exited. On the <TT>dst</TT>
   side, a single data transfer is received from any of the sending PETs, and
   then divided over the individual receive calls.

<P>
In the following code example, the <TT>srcArray</TT> has DEs on PET 0 and 1, 
   while <TT>dstArray</TT> has DEs on PET 2 and 3. Both Arrays are operating on
   the same global index space. A Redist() RouteHandle <TT>rh</TT> is created in
   the usual manner.
<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray, dstArray, routehandle=rh, rc=rc)
</PRE>

<P>
The precomputed <TT>rh</TT> can be used as usual. Here the use inside an active
   VMEpoch is demonstrated.

<P>
First enter the VMEpoch using <TT>ESMF_VMEpochEnter()</TT>, specifying the kind
   of epoch. Currently only a single VMEpoch kind is available:
   <TT>ESMF_VMEPOCH_BUFFER</TT>.
<P>
<PRE>
  call ESMF_VMEpochEnter(epoch=ESMF_VMEPOCH_BUFFER, rc=rc)
</PRE>

<P>
<B>SRC side (PET 0 &amp; 1):</B>
   The sending PETs do not block.

<P>
<B>DST side (PET 2 &amp; 3):</B>
   The receiving PETs do not block.

<P>
Notice that ESMF implements a throttle on the VMEpoch as to limit the number
   of queued message between PETs. This is necessary to protect the receiving
   side in the <TT>EAGER</TT> regime where MPI implementations send the
   data from the sending to the receiving side, assuming the receiving side
   will always be able to buffer. In cases where the sending side runs far
   ahead of the receiving side, this strategy can lead to
   increasing memory pressure on the receiving side, ultimatily resulting in
   out-of-memory conditions. The default throttle in VMEpoch is set to <SPAN CLASS="MATH"><IMG
 WIDTH="20" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$10$"></SPAN>
   outstanding message between any two PETs. It can be adjusted by specifying
   the <TT>throttle</TT> argument when calling <TT>ESMF_VMEpochEnter()</TT>.

<P>
Next the actual communication method, <TT>ESMF_ArrayRedist()</TT>, is called in
   the usual manner.
<P>
<PRE>
  call ESMF_ArrayRedist(srcArray, dstArray, routehandle=rh, rc=rc)
</PRE>

<P>
<B>SRC side (PET 0 &amp; 1):</B>
   The sending PETs block until the locally needed send buffers are available,
   and all local data manipulations and data movements into the send buffers have
   completed.

<P>
Waiting for the send buffers comes into play when a VMEpoch is entered and
   exited multiple times. The same send buffer is reused each time for the 
   same src-dst-PET pairs (and grown automatically if needed). Each send buffer
   becomes available once the MPI layer has indicated that the associated,
   previous <TT>MPI_Isend()</TT> has completed locally.

<P>
Once the send buffer for a specific PET pair is available, the local data
   movements defined by the <TT>rh</TT> and message aggregation must complete before
   returning. For <TT>Regrid()</TT> and <TT>SMM()</TT> operations the
   <TT>srcTermProcessing</TT> argument specified during <TT>Store()</TT> determines the
   amount of local data processing. Once returned, it is safe to modify the
   <TT>srcArray</TT> data on the local PET.

<P>
<B>DST side (PET 2 &amp; 3):</B>
   The receiving PETs block on the aggregated data from the src side for which
   the local PET has a dependency defined via the <TT>rh</TT>. Once received, the
   data is processed locally, and moved into the final location under the
   <TT>dstArray</TT>. On return, it is safe to access the data in <TT>dstArray</TT>
   on the local PET.

<P>
Notice that any number of RouteHandle based communication calls can be made
   inside the same active VMEpoch. In fact, aggregating messages from multiple
   exchanges is the typical use case of the VMEpoch approach. Additional
   communication calls cam either involve different RouteHandles, or even the
   same <TT>rh</TT> for different src/dst Array pairs.

<P>
When using communication calls that allow the specification of the
   <TT>termorderflag</TT>, e.g. <TT>ESMF_FieldRegrid()</TT>, <TT>ESMF_ArraySMM()</TT>,
   etc. inside a VMEpoch, it is important to set it to either 
   <TT>ESMF_TERMORDER_SRCPET</TT> or <TT>ESMF_TERMORDER_SRCSEQ</TT>. The default
   value of <TT>ESMF_TERMORDER_FREE</TT> is <EM>not</EM> compatible with VMEpoch.

<P>
Finally the active VMEpoch is exited by calling <TT>ESMF_VMEpochExit()</TT>.
<P>
<PRE>
  call ESMF_VMEpochExit(rc=rc)
</PRE>

<P>
<B>SRC side (PET 0 &amp; 1):</B>
   The sending PETs post their local <TT>MPI_Isend()</TT> calls. This is
   non-blocking.

<P>
<B>DST side (PET 2 &amp; 3):</B>
   The receiving PETs do not block.

<P>
As part of the final clean-up the <TT>rh</TT> is being released as usual.
<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=rh, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050142300000000000000"></A>
   <A NAME="RH:RHfromRH"></A>
<BR>
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Creating a RouteHandle from an existing RouteHandle - 
   Transfer to a different set of PETs
</H3>

<P>
Typically a RouteHandle object is created indirectly, i.e. without explicitly
   calling the <TT>ESMF_RouteHandleCreate()</TT> method. The RouteHandle
   object is a byproduct of calling communication Store() methods like 
   <TT>ESMF_FieldRegridStore()</TT>.

<P>
One exception to this rule is when creating a duplicate RouteHandle from an
   existing RouteHandle object. In this case the <TT>ESMF_RouteHandleCreate()</TT>
   method is used explicitly. While this method allows to create a duplicate 
   RouteHandle on the exact same set of PETs as the original RouteHandle, the 
   real purpose of duplication is the transfer of a precomputed RouteHandle to a
   different set of PETs. This is an efficient way to reduce the total time
   spent in Store() calls, for situations where the same communication pattern
   repeats for multiple components.

<P>
This example demonstrates the transfer of a RouteHandle from one set of PETs
   to another by first introducing three components. Component A is defined
   on the first half of available PETs.
<P>
<PRE>
  petCountA = petCount/2  ! component A gets half the PETs

  allocate(petListA(petCountA))
  do i=1, petCountA
    petListA(i) = i-1 ! PETs are base 0
  enddo
  
  compA = ESMF_GridCompCreate(petList=petListA, rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
    line=__LINE__, &amp;
    file=__FILE__)) &amp;
    call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
The other two components, B1 and B2, split the remaining PETs evenly.
<P>
<PRE>
  petCountR = petCount - petCountA
  petCountB1 = petCountR / 2
  
  allocate(petListB1(petCountB1))
  do i=1, petCountB1
    petListB1(i) = petCountA + i-1 ! PETs are base 0
  enddo

  allocate(petListB2(petCountR-petCountB1))
  do i=1, petCountR-petCountB1
    petListB2(i) = petCountA + petCountB1 + i-1 ! PETs are base 0
  enddo

  compB1 = ESMF_GridCompCreate(petList=petListB1, rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
    line=__LINE__, &amp;
    file=__FILE__)) &amp;
    call ESMF_Finalize(endflag=ESMF_END_ABORT)

  compB2 = ESMF_GridCompCreate(petList=petListB2, rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
    line=__LINE__, &amp;
    file=__FILE__)) &amp;
    call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Skipping all of the standard superstructure code, assume that <TT>fieldA</TT>
   has been created by component A, has been reconciled across all PETs via
   a StateReconcile() call, and accessed via a StateGet(). The same is true for
   <TT>fieldB1</TT> and <TT>fieldB2</TT> from components B1 and B2, respectively.

<P>
Now the RouteHandle <TT>rh1</TT> for a Redist operation is precomputed between 
   <TT>fieldA</TT> and <TT>fieldB1</TT>.
<P>
<PRE>
  call ESMF_FieldRedistStore(srcField=fieldA, dstField=fieldB1, &amp;
    routehandle=rh1, rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
    line=__LINE__, &amp;
    file=__FILE__)) &amp;
    call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
The communication pattern stored in <TT>rh1</TT> is between the PETs associated
   with component A and those associated with component B1. Now component B2 is
   simply a second instance of the same component code as B1, but on a different
   set of PETs. The <TT>ESMF_RouteHandleCreate()</TT> method can be used to 
   transfer <TT>rh1</TT> to the set of PETs that is consistent with fieldA to 
   fieldB2 communication.

<P>
In order to transfer a RouteHandle to a different set of PETs, the 
   <TT>originPetList</TT> and <TT>targetPetList</TT> must be constructed. The
   <TT>originPetList</TT> is the union of source and destination PETs (in that
   order) for which <TT>rh1</TT> was explicitly computed via the Store() call:
<P>
<PRE>
  allocate(originPetList(size(petListA)+size(petListB1)))
  originPetList(1:size(petListA)) = petListA(:)
  originPetList(size(petListA)+1:) = petListB1(:)
</PRE>

<P>
The <TT>targetPetList</TT> is the union of source and destination PETs (in that
   order) for which the target RouteHandle (i.e. <TT>rh2</TT>) will be defined:
<P>
<PRE>
  allocate(targetPetList(size(petListA)+size(petListB2)))
  targetPetList(1:size(petListA)) = petListA(:)
  targetPetList(size(petListA)+1:) = petListB2(:)
</PRE>

<P>
Now the new RouteHandle <TT>rh2</TT> can be created easily from the exising 
   RouteHandle <TT>rh1</TT>, suppling the origin and target petLists.
<P>
<PRE>
  rh2 = ESMF_RouteHandleCreate(rh1, originPetList=originPetList, &amp;
    targetPetList=targetPetList, rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
    line=__LINE__, &amp;
    file=__FILE__)) &amp;
    call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
The new RouteHandle <TT>rh2</TT> is completely independent of the original
   RouteHandle. In fact, it is perfectly fine to destroy (or release) <TT>rh1</TT> 
   while holding on to <TT>rh2</TT>.
<P>
<PRE>
  call ESMF_RouteHandleDestroy(rh1, noGarbage=.true., rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
    line=__LINE__, &amp;
    file=__FILE__)) &amp;
    call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Finally the <TT>rh2</TT> object can be used to redistribute data from 
   <TT>fieldA</TT> to <TT>fieldB2</TT>. 
<P>
<PRE>
  call ESMF_FieldRedist(srcField=fieldA, dstField=fieldB2, &amp;
    routehandle=rh2, rc=rc)
  if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &amp;
    line=__LINE__, &amp;
    file=__FILE__)) &amp;
    call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
The communication pattern held by <TT>rh2</TT>
   is idential to what whould have been created by an explicit 
   <TT>ESMF_FieldRedistStore()</TT> call. However, the 
   <TT>ESMF_RouteHandleCreate()</TT> call used to create <TT>rh2</TT> from <TT>rh1</TT>
   is much faster than the full RedistStore() operation.


<P>

<P>

<P>

<H3><A NAME="SECTION050142400000000000000"></A>
   <A NAME="RH:RHfromFile"></A>
<BR>
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Write a RouteHandle to file and creating a RouteHandle from file
</H3>

<P>
Communication Store() methods, like <TT>ESMF_FieldRegridStore()</TT>, are used
   to create RouteHandles. These methods can be expensive, both with respect to
   temporary memory requirements as well as the time they require to execute.
   Often the associated cost is acceptable because Store() calls are typically
   used during the initialization phase of the application. The cost of 
   RouteHandle generation is therefore armorized over the entire run phase
   of the application, where the RouteHandle is applied over and over to 
   transfer data according to the same communication pattern.

<P>
However, especially for short production runs, an expensive initialization
   time can become problematic. In such cases it is useful to write the
   RouteHandle to file. Subsequent application runs can then re-create the
   RouteHandle during initialization, simply from file at a fraction of the time
   of the original Store() call. 

<P>
First a RouteHandle must be created using one of the ESMF Store() methods.
<P>
<PRE>
  call ESMF_FieldRedistStore(srcField=fieldA, dstField=fieldB, &amp;
    routehandle=rh1, rc=rc)
</PRE>

<P>
Now the RouteHandle object <TT>rh1</TT> can be written to file using the
   <EM>collective</EM> <TT>ESMF_RouteHandleWrite()</TT> method.
<P>
<PRE>
  call ESMF_RouteHandleWrite(rh1, fileName="testWrite.RH", rc=rc)
</PRE>

<P>
This creates a single binary file with name <TT>testWrite.RH</TT>. The 
   information from across all PETs that define <TT>rh1</TT> is contained in this
   file.

<P>
At this point, the original RouteHandle is no longer needed and can be
   destroyed.
<P>
<PRE>
  call ESMF_RouteHandleDestroy(rh1, noGarbage=.true., rc=rc)
</PRE>

<P>
The RouteHandle just deleted can easily be re-created using the
   <TT>ESMF_RouteHandleCreate()</TT> method that accepts the file name as an 
   argument. This is a <EM>collective</EM> method that must be called on exactly
   the same number of PETs that was used for the original Store() and Write()
   calls that generated the file.
<P>
<PRE>
  rh2 = ESMF_RouteHandleCreate(fileName="testWrite.RH", rc=rc)
</PRE>

<P>
Finally the re-created RouteHandle, <TT>rh2</TT>, can be used to execute the
   communication pattern originally computed in <TT>rh1</TT>.
<P>
<PRE>
  call ESMF_FieldRedist(srcField=fieldA, dstField=fieldB, &amp;
    routehandle=rh2, rc=rc)
</PRE>

<P>
Once done with <TT>rh2</TT>, the RouteHandle can be destroyed as usual.
<P>
<PRE>
  call ESMF_RouteHandleDestroy(rh2, noGarbage=.true., rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050142500000000000000"></A>
   <A NAME="RH:Reusability"></A>
<BR>
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Reusablity of RouteHandles and interleaved distributed 
   and undistributed dimensions
</H3>

<P>
A RouteHandle object is typically created during a communication <TT>Store()</TT>
   call, e.g. an <TT>ESMF_FieldRegridStore()</TT>. Other communication methods
   with <TT>Store()</TT> are <TT>Halo</TT>, <TT>Redist</TT>, and <TT>SMM</TT>. The primary
   input objects of a <TT>Store()</TT> call are either Fields, Arrays,
   FieldBundles, or ArrayBundles. There will be an object for the source side,
   and another object for the destination side. Both objects must be of the
   same type.
<P>
<PRE>
  srcField = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>
<PRE>
  dstField = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_FieldRegridStore(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
The purpose of the explicit <TT>Store()</TT> call is to separate out the 
   expensive part of creating the RouteHandle object for a specific
   communication patter, from the less expensive part of applying it.
   Applying the RouteHandle results in data movement between 
   the source and destination objects. Once a RouteHandle is available, it is
   reusable. This means it can be applied over and over again to communicate
   data from the source to the destination object.
<P>
<PRE>
  do i=1, 10
    ! repeatedly applying the routehandle
    call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
      routehandle=routehandle, rc=rc)
  enddo
</PRE>

<P>
Reusability of a RouteHandle object extends beyond re-applying it to the same
   source/destination object pair that was used during <TT>Store()</TT>. The same
   RouteHandle can be applied to a different object pair, as long as these
   criterial are met:
   
<UL>
<LI>The new pair matches the original pair with respect to <EM>type</EM>, 
     and <EM>kind</EM>.
</LI>
<LI>The memory layout of the <EM>distributed</EM> (i.e. <EM>gridded</EM>) 
     dimensions of the new pair is congruent with the original pair. This means
     the <EM>DistGrid</EM>s must match, as well as any extra padding on the 
     distributed/gridded dimensions.
</LI>
<LI>Size, number, and position (i.e. index order) of potentially present
     <EM>undistributed</EM> (i.e. <EM>ungridded</EM>) dimensions does not affect the
     reusability of a RouteHandle.
   
</LI>
</UL>
   The following examples will discuss in detail what this means in practice.

<P>
First consider the case where a second pair of source and destination Fields
   is created identical to the first set. The precomputed RouteHandle is 
   immediatly reusable for this new Field pair to carry out the regrid operation.
<P>
<PRE>
  srcField2 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>
<PRE>
  dstField2 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>
<PRE>
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField2, dstField=dstField2, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
The same RouteHandle stays re-usable even for a Field pair where source and 
   destination have one or more additional undistributed dimensions. Here a
   single undistributed dimension is added. By default all undistributed 
   dimensions will be ordered <EM>after</EM> the distributed dimensions provided
   by the Grid object. 
<P>
<PRE>
  srcField3 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &amp;
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &amp;  ! undistributed dim last
    rc=rc)
</PRE>

<P>
<PRE>
  dstField3 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &amp;
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &amp; ! undistributed dim last
    rc=rc)
</PRE>

<P>
<PRE>
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField3, dstField=dstField3, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
The undistributed dimension can also be moved into the first position,
   and the same RouteHandle can still be re-used. Specifying the order
   of dimensions in a Field is accomplished by providing the
   <TT>gridToFieldMap</TT>. Here the Grid dimensions are mapped to 2nd and 3rd
   Field dimensions, moving the undistributed dimension into the leading
   position.
<P>
<PRE>
  srcField4 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &amp;
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &amp;
    gridToFieldMap=(/2,3/), rc=rc)  ! undistributed dim 1st
</PRE>

<P>
<PRE>
  dstField4 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &amp;
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &amp;
    gridToFieldMap=(/2,3/), rc=rc)  ! undistributed dim 1st
</PRE>

<P>
<PRE>
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField4, dstField=dstField4, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
It is not necessary that the undistributed dimension is in the same position
   on the source and destination Field. The only criteria that needs to be
   satisfied is that both source and destination have the <EM>same number</EM> of 
   undistributed elements. Here the RouteHandle is re-used for a 
   Field pair where the destination Field interleaves the undistributed dimension
   between the two distributed dimensions. At the same time the source Field
   keeps the undistributed dimension in leading position.
<P>
<PRE>
  srcField5 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &amp;
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &amp;
    gridToFieldMap=(/2,3/), rc=rc)  ! undistributed dim 1st
</PRE>

<P>
<PRE>
  dstField5 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &amp;
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &amp;
    gridToFieldMap=(/1,3/), rc=rc)  ! undistributed dim 2nd
</PRE>

<P>
<PRE>
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField5, dstField=dstField5, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
In the following example the undistributed elements on the source side are
   spread across two undistributed dimensions. Of course the product of the two
   dimension sizes must equal the number of undistributed elements on the 
   destination side, in order to fulfil the element count criteria. Here this 
   number is 10. At two undistributed dimension on the source side are placed
   in first and fourth position using the <TT>gridToFieldMap</TT>. The same
   RouteHandle is applied to this Field pair, resulting in the desired 
   regrid operation.
<P>
<PRE>
  srcField6 = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &amp;
    ungriddedLBound=(/1,1/), ungriddedUBound=(/2,5/), &amp;
    gridToFieldMap=(/2,3/), rc=rc)  ! undistributed dims 1st and 4th
</PRE>

<P>
<PRE>
  dstField6 = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &amp;
    ungriddedLBound=(/1/), ungriddedUBound=(/10/), &amp;
    gridToFieldMap=(/1,3/), rc=rc)  ! undistributed dim 2nd
</PRE>

<P>
<PRE>
  ! applying the same routehandle to a different pair of fields
  call ESMF_FieldRegrid(srcField=srcField6, dstField=dstField6, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
While the RouteHandle was precomputed using a specific source/destination
   Field pair, we have seen how it can be re-used as long as the memory layout 
   associated with the distributed (i.e. gridded) dimensions does not change.
   A natural extension of this feature is to allow the same RouteHandle to be 
   re-used when source and destination are FieldBundles instead of Fields. The
   only requirement here is that both sides contain the same number of elements,
   and that
   each pair constructed from the source and destination side is compatible with
   the original pair used as shown in the examples above. Here this criteria is
   simply met by constructing the source and destination FieldBundles from the
   exact Fields used in the previous examples.
<P>
<PRE>
  srcFieldBundle = ESMF_FieldBundleCreate(fieldList=(/srcField, &amp;
    srcField2, srcField3, srcField4, srcField5, srcField6/), rc=rc)
</PRE>

<P>
<PRE>
  dstFieldBundle = ESMF_FieldBundleCreate(fieldList=(/dstField, &amp;
    dstField2, dstField3, dstField4, dstField5, dstField6/), rc=rc)
</PRE>

<P>
<PRE>
  ! applying the same routehandle to a pair of FieldBundles
  call ESMF_FieldBundleRegrid(srcFieldBundle, dstFieldBundle, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
On a fundamental level, RouteHandles are re-usable across objects that
   have the same memory layout for their distributed dimensions. Since ESMF
   Fields are built on top of ESMF Arrays, it is 
   possible to re-use the same RouteHandle that was precomputed for a Field
   pair and apply it to a matching Array pair. 

<P>
For this example, the easiest way to create Arrays with the same memory 
   layout in the distributed dimensions is to query the source and destination
   Grid objects for their DistGrids. Then source and destination Arrays can be
   easily constructed.
<P>
<PRE>
  call ESMF_GridGet(srcGrid, distgrid=srcDistGrid, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridGet(dstGrid, distgrid=dstDistGrid, rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(srcDistGrid, ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(dstDistGrid, ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>
<PRE>
  ! applying the same routehandle to an Array pair
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
Finally the resources associated with the RouteHandle object are released.
   The recommended way to do this is by calling into the <TT>Release()</TT> method
   associated with the <TT>Store()</TT> method used to create the RouteHandle.
<P>
<PRE>
  call ESMF_FieldRegridRelease(routehandle, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION050142600000000000000"></A>
   <A NAME="RH:DynMask"></A>
<BR>
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Dynamic Masking
</H3>

<P>
When a RouteHandle object is created during an <TT>ESMF_FieldRegridStore()</TT>
   call, masking information can be provided by the user. This type of masking
   is said to be <EM>static</EM>, and is described in section <A HREF="#regrid:masking">24.2.10</A>.
   It is static, because the masks set the maximum limits of the regrid 
   operation, which cannot be changed later. All subsequent executions of the
   same RouteHandle can only use elements - source or destination - 
   that were not masked during the Store() call.

<P>
Once a RouteHandle object is available, whether it was created with or without 
   static masking, the associated regrid operation can further be masking 
   during RouteHandle execution . This is called <EM>dynamic</EM> masking, because
   it can dynamically change between subsequent RouteHandle executions. The 
   RouteHandle itself remains unchange during this process. The dynamic
   masking information is processed on the fly as the RouteHandle is applied.

<P>
The following example demonstrates dynamic masking for a regrid operation
   between two Field objects. Although it is supported, here
   the regrid operation between <TT>srcField</TT> and <TT>dstField</TT> is computed
   without static masking. 

<P>
Note that since the intention is to later use the generated RouteHandle for
   dynamic masking, it is important to provide the <TT>srcTermProcessing</TT> 
   argument, which must be set equal to 0. Doing this ensures that all
   of the multiplying with interpolation weights, and summing of terms, is
   carried out on the destination side. This is critical for dynamic masking.
<P>
<PRE>
  srcTermProcessing=0

  call ESMF_FieldRegridStore(srcField=srcField, dstField=dstField, &amp;
    srcTermProcessing=srcTermProcessing, routehandle=routehandle, rc=rc)
</PRE>

<P>
Now that <TT>routehandle</TT> is available, it can be used to execute the 
   regrid operation over and over during the course of the simualtion run.
<P>
<PRE>
  call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
Assume that during the course of the simulation the <TT>srcField</TT> becomes
   partially masked. This masking may be dynamically changing, as would be the
   case for the ice cover over the arctic ocean. Then the regrid operation 
   represented by <TT>routehandle</TT> should dynamically adjust to only use
   unmasked source elements.

<P>
The dynamic masking behavior can be achieved in ESMF by setting <TT>srcField</TT>
   elements to a special value.
<P>
<PRE>
  call ESMF_FieldGet(srcField, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  ! setting an arbitrary local source element to special value 'srcMaskValue'
  farrayPtr(lbound(farrayPtr,1)+3,lbound(farrayPtr,2)+3) = srcMaskValue
</PRE>

<P>
Then set up an <TT>ESMF_DynamicMask</TT> object that holds information about
   the special mask value. The dynamic mask object
   further holds a pointer to the routine that will be called in order to handle
   dynamically masked elements.
<P>
<PRE>
  call ESMF_DynamicMaskSetR8R8R8(dynamicMask, &amp;
    dynamicSrcMaskValue=srcMaskValue, &amp;
    dynamicMaskRoutine=simpleDynMaskProc, &amp;
    rc=rc)
</PRE>

<P>
The names of the specific <TT>DynamicMaskSet</TT> methods all carry a 
   typekind-triplet suffix. Here the suffix is <TT>R8R8R8</TT>. 
   This indicates that the <TT>dynamicMaskRoutine</TT> argument
   provided is expected to deal with <TT>real(ESMF_KIND_R8)</TT> destination data
   (first R8 typekind), <TT>real(ESMF_KIND_R8)</TT> factors (second R8 typekind),
   and <TT>real(ESMF_KIND_R8)</TT> source data (third R8 typekind).

<P>
Now when the <TT>routehandle</TT> is executed, and the <TT>dynamicMask</TT> object
   is passed into the <TT>ESMF_FieldRegrid()</TT> call,
<P>
<PRE>
  call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, dynamicMask=dynamicMask, rc=rc)
</PRE>

<P>
ESMF will scan the <TT>srcField</TT> for elements that have data equal to
   that set by <TT>dynamicSrcMaskValue</TT>. If any are found, they
   are passed into the routine provided via the <TT>dynamicMaskRoutine</TT>
   argument. 

<P>
The procedure passed through the <TT>dynamicMaskRoutine</TT> argument must 
   satisfy exactly the following predefined interface:

<P>
<PRE>
    interface
      subroutine ESMF_DynamicMaskRoutineR8R8R8(dynMaskList, &amp;
        dynamicSrcMaskValue, dynamicDstMaskValue, rc)
        use ESMF_UtilTypesMod
        implicit none
        type(ESMF_DynamicMaskElementR8R8R8), pointer        :: dynMaskList(:)
        real(ESMF_KIND_R8),            intent(in), optional :: dynamicSrcMaskValue
        real(ESMF_KIND_R8),            intent(in), optional :: dynamicDstMaskValue
        integer,                       intent(out)  :: rc
      end subroutine
    end interface
</PRE>

<P>
The first argument accepted according to this interface is an array of type
   <TT>ESMF_DynamicMaskElement</TT>. Each element of this array corresponds to a
   single element in the <TT>dstField</TT> that is affected by dynamic masking. 
   For each such <TT>dstElement</TT> the complete interpolation stencile is
   provided by the <TT>ESMF_DynamicMaskElement</TT> derived type:

<P>
<PRE>
    type ESMF_DynamicMaskElementR8R8R8
      real(ESMF_KIND_R8), pointer       :: dstElement
      real(ESMF_KIND_R8), allocatable   :: factor(:)
      real(ESMF_KIND_R8), allocatable   :: srcElement(:)
    end type
</PRE>

<P>
Here the <TT>dstElement</TT> is a pointer to the actual element in the 
   <TT>dstField</TT>. Thus, assigning <TT>dstElement</TT> to a value, immediately
   results in a value change of the element inside the <TT>dstField</TT> object.
   Further, the size of the <TT>factor(:)</TT> and <TT>srcElement(:)</TT> arrays is
   identical to each other and corresponds to the number of source elements in
   the interpolation stencile. Without dynamic masking, the <TT>dstElement</TT>
   would simply be calculated as the scalar product of <TT>factor(:)</TT> and 
   <TT>srcElement(:)</TT>.

<P>
By providing the <TT>dynamicMaskRoutine</TT>, the user has full control as to
   what exactly happens to destination elements that are affected by dynamic
   masking. For the current example, where some source elements may be marked by
   a special masking value, a simple scheme could be to only use non-masked
   source elements to calculate destination elements. The result then needs to
   be renormalized in order to account for the missing source elements. This
   could be implemented similar to the following subroutine:

<P>
<PRE>
    subroutine simpleDynMaskProc(dynamicMaskList, dynamicSrcMaskValue, &amp;
      dynamicDstMaskValue, rc)
      type(ESMF_DynamicMaskElementR8R8R8), pointer        :: dynamicMaskList(:)
      real(ESMF_KIND_R8),            intent(in), optional :: dynamicSrcMaskValue
      real(ESMF_KIND_R8),            intent(in), optional :: dynamicDstMaskValue
      integer,                       intent(out)          :: rc
      integer :: i, j
      real(ESMF_KIND_R8)  :: renorm
      if (associated(dynamicMaskList)) then
        do i=1, size(dynamicMaskList)
          dynamicMaskList(i)%dstElement = 0.d0 ! set to zero
          renorm = 0.d0 ! reset
          do j=1, size(dynamicMaskList(i)%factor)
            if (.not. &amp;
              match(dynamicSrcMaskValue,dynamicMaskList(i)%srcElement(j))) then
              dynamicMaskList(i)%dstElement = dynamicMaskList(i)%dstElement &amp;
                + dynamicMaskList(i)%factor(j) &amp;
                * dynamicMaskList(i)%srcElement(j)
              renorm = renorm + dynamicMaskList(i)%factor(j)
            endif
          enddo
          if (renorm &gt; 0.d0) then
            dynamicMaskList(i)%dstElement = dynamicMaskList(i)%dstElement / renorm
          else if (present(dynamicSrcMaskValue)) then
            dynamicMaskList(i)%dstElement = dynamicSrcMaskValue
          else
            rc = ESMF_RC_ARG_BAD  ! error detected
            return
          endif
        enddo
      endif
      ! return successfully
      rc = ESMF_SUCCESS
    end subroutine
</PRE>

<P>
So far in the example only the <TT>srcField</TT> had been dynamically masked.
   However, elements in the <TT>dstField</TT> can be masked as well, following 
   exactly the same manner.

<P>
First ensure that the <TT>dstField</TT> is in a well defined condition. This can
   be achived by reseting it, e.g. to zero, using the <TT>ESMF_FieldFill()</TT>
   method.
<P>
<PRE>
  call ESMF_FieldFill(dstField, dataFillScheme="const", const1=0.d0, rc=rc)
</PRE>

<P>
Now some of the destination elements are set to a defined masking value.
<P>
<PRE>
  call ESMF_FieldGet(dstField, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  ! setting an arbitrary local destination element to special value 'dstMaskValue'
  farrayPtr(lbound(farrayPtr,1)+1,lbound(farrayPtr,2)+1) = dstMaskValue
</PRE>

<P>
The <TT>dynamicMask</TT> is reset using the same <TT>DynamicMaskSet</TT> method as
   before, but in addition to the previous arguments, <TT>dynamicDstMaskValue</TT>
   is also specified.
<P>
<PRE>
  call ESMF_DynamicMaskSetR8R8R8(dynamicMask, &amp;
    dynamicSrcMaskValue=srcMaskValue, &amp;
    dynamicDstMaskValue=dstMaskValue, &amp;
    dynamicMaskRoutine=simpleDynMaskProc, &amp;
    rc=rc)
</PRE>

<P>
Passing the reset <TT>dynamicMask</TT> object into <TT>ESMF_FieldRegrid()</TT> 
   causes ESMF to not only look for source elements that match
   <TT>dynamicSrcMaskValue</TT>, but also destination elements that
   match <TT>dynamicDstMaskValue</TT>.
<P>
<PRE>
  call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, zeroregion=ESMF_REGION_EMPTY, &amp;
    dynamicMask=dynamicMask, rc=rc)
</PRE>

<P>
Again an adequate procedure is supplied through 
   <TT>dynamicMaskRoutine</TT>. For the current case, however, a suitable procedure
   would be inspecting the <TT>dstElement</TT> as well as all the <TT>dstElement</TT>s
   provided via the <TT>dynMaskList</TT> argument.

<P>
Notice the <TT>zeroregion = ESMF_REGION_EMPTY</TT> specification in the 
   <TT>ESMF_FieldRegrid()</TT> call. This setting ensures that values in the
   <TT>dstField</TT> remain unchanged until they are checked for
   <TT>dynamicDstMaskValue</TT>.  

<P>
The <TT>DynamicMaskSet</TT> methods provide an argument of <TT>logical</TT> type, 
   called <TT>handleAllElements</TT>. By default it is set to <TT>.false.</TT>, 
   which means that only elements affected by dynamic masking - as described
   above - are passed to the <TT>dynamicMaskRoutine</TT>. However, when
   <TT>handleAllElements</TT> is set to <TT>.true.</TT>, <EM>all</EM> local
   elements on each PET are made available to the <TT>dynamicMaskRoutine</TT>.
   This allows the user supplied procedure to implement fully customized
   handling of the interpolation from source to destination, using the 
   information supplied by ESMF.

<P>
To demonstrate this, a custom routine <TT>simpleHandleAllProc()</TT> is 
   passed in as <TT>dynamicMaskRoutine</TT>, and <TT>handleAllElements</TT> is
   set to <TT>.true.</TT>. All other aspects of the user interface remain unchanged.
<P>
<PRE>
  call ESMF_DynamicMaskSetR8R8R8(dynamicMask, &amp;
    dynamicSrcMaskValue=srcMaskValue, &amp;
    dynamicDstMaskValue=-2.d0, &amp;
    dynamicMaskRoutine=simpleHandleAllProc, &amp;
    handleAllElements=.true., &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, zeroregion=ESMF_REGION_EMPTY, &amp;
    dynamicMask=dynamicMask, rc=rc)
</PRE>

<P>
Dynamic masking is also available for source and destination fields that
   contain leading undistributed dimensions. When ESMF applies the regridding
   weights, it interprets the product space of leading undistributed dimensions
   of a Field or Array as the elements of a vector. In this approach the 
   interpolation becomes a vector operation.  When applying the concept
   of dynamic masking to such a vector operation, without making further 
   assumptions, it must be assumed that different vector elements may be 
   affected differently by the dynamic mask. ESMF therefore unrolls the vector
   dimension when constructing the information passed to the
   <TT>dynamicMaskRoutine</TT>. As a consequence of this, masking routines
   do not generally have to consider vectorization explicitly.

<P>
The concept is demonstrated by creating source and destination fields
   with one leading undistributed dimension.
<P>
<PRE>
  srcField = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R8, &amp;
    gridToFieldMap=(/2,3/), ungriddedLBound=(/1/), ungriddedUBound=(/20/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  dstField = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R8, &amp;
    gridToFieldMap=(/2,3/), ungriddedLBound=(/1/), ungriddedUBound=(/20/), &amp;
    rc=rc)
</PRE>

<P>
A regrid operation is computed in the usual manner. In order to make the
   resulting RouteHandle object suitable for dynamic masking, computations are
   pushed completely onto the destination PETs, as in previous examples, by
   setting the <TT>srcTermProcessing</TT> argument to zero.
<P>
<PRE>
  srcTermProcessing=0

  call ESMF_FieldRegridStore(srcField=srcField, dstField=dstField, &amp;
    srcTermProcessing=srcTermProcessing, routehandle=routehandle, rc=rc)
</PRE>

<P>
The same <TT>dynamicMaskRoutine</TT> as before can be used when setting up
   the <TT>ESMF_DynamicMask</TT> object. However, the source and destination
   Fields now contain 20 undistributed elements at each distributed location,
   and the dynamic mask routine will handle all elements that are affected
   by the dynamic mask conditions.
<P>
<PRE>
  call ESMF_DynamicMaskSetR8R8R8(dynamicMask, &amp;
    dynamicSrcMaskValue=srcMaskValue, &amp;
    dynamicDstMaskValue=dstMaskValue, &amp;
    dynamicMaskRoutine=simpleDynMaskProc, &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, zeroregion=ESMF_REGION_EMPTY, &amp;
    dynamicMask=dynamicMask, rc=rc)
</PRE>

<P>
Setting the <TT>handleAllElements</TT> to <TT>.true.</TT> will pass all elements
   to the <TT>dynamicMaskRoutine</TT>. There are 20 times as many elements
   on the source and destination side, and therefore the dynamic masking routine
   will handle exactly 20 times as many elements compared to the case without
   undistributed dimension.
<P>
<PRE>
  call ESMF_DynamicMaskSetR8R8R8(dynamicMask, &amp;
    dynamicSrcMaskValue=srcMaskValue, &amp;
    dynamicDstMaskValue=-2.d0, &amp;
    dynamicMaskRoutine=simpleHandleAllProc, &amp;
    handleAllElements=.true., &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, zeroregion=ESMF_REGION_EMPTY, &amp;
    dynamicMask=dynamicMask, rc=rc)
</PRE>

<P>
For the case with <TT>handleAllElements=.true.</TT>, where the entire
   vector of undistributed elements is passed to <TT>dynamicMaskRoutine</TT> at
   every distributed location, an alternative implementation option exists for
   the dynamic masking routine. In some cases this alternative may result in
   more efficient code because it allows to vectorize over the undistributed
   elements when summing up the interpolation terms. The alternative interface
   for <TT>dynamicMaskRoutine</TT> is:

<P>
<PRE>
    interface
      subroutine ESMF_DynamicMaskRoutineR8R8R8V(dynMaskList, &amp;
        dynamicSrcMaskValue, dynamicDstMaskValue, rc)
        use ESMF_UtilTypesMod
        implicit none
        type(ESMF_DynamicMaskElementR8R8R8V), pointer       :: dynMaskList(:)
        real(ESMF_KIND_R8),            intent(in), optional :: dynamicSrcMaskValue
        real(ESMF_KIND_R8),            intent(in), optional :: dynamicDstMaskValue
        integer,                       intent(out)  :: rc
      end subroutine
    end interface
</PRE>

<P>
The difference compared to the previously used interface is that the first
   argument now is of type <TT>ESMF_DynamicMaskElementR8R8R8V</TT>. This type is
   declared as follows:

<P>
<PRE>
    type ESMF_DynamicMaskElementR8R8R8V
      real(ESMF_KIND_R8), pointer       :: dstElement(:)
      real(ESMF_KIND_R8), allocatable   :: factor(:)
      type(ESMF_PtrR8D1), allocatable   :: srcElement(:)
    end type
</PRE>

<P>
Here <TT>size(dstElement)</TT> for every element in <TT>dynMaskList</TT> is
   identical to the vector size, i.e. the number of undistributed elements to 
   be handled. The same is true for <TT>size(srcElement(j)%ptr))</TT>, for every
   element <TT>j</TT> of the interpolation stencile.
<P>
<PRE>
  call ESMF_DynamicMaskSetR8R8R8V(dynamicMask, &amp;
    dynamicSrcMaskValue=srcMaskValue, &amp;
    dynamicDstMaskValue=-2.d0, &amp;
    dynamicMaskRoutine=simpleHandleAllProcV, &amp;
    handleAllElements=.true., &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, zeroregion=ESMF_REGION_EMPTY, &amp;
    dynamicMask=dynamicMask, rc=rc)
</PRE>

<P>
Applying dynamic masking to source and destination fields of other typekind
   than R8 only requires that the correct <TT>DynamicMaskSet</TT> method is chosen.
   Here we create <TT>real(ESMF_KIND_R4)</TT> source and destination fields.
<P>
<PRE>
  srcField = ESMF_FieldCreate(srcGrid, ESMF_TYPEKIND_R4, rc=rc)
</PRE>

<P>
<PRE>
  dstField = ESMF_FieldCreate(dstGrid, ESMF_TYPEKIND_R4, rc=rc)
</PRE>

<P>
Computing a suitable RouteHandle is unchanged.
<P>
<PRE>
  srcTermProcessing=0

  call ESMF_FieldRegridStore(srcField=srcField, dstField=dstField, &amp;
    srcTermProcessing=srcTermProcessing, routehandle=routehandle, rc=rc)
</PRE>

<P>
Now setting some source and destination elements to defined special values
   of the correct typekind.
<P>
<PRE>
  call ESMF_FieldGet(srcField, farrayPtr=farrayPtrR4, rc=rc)
</PRE>

<P>
<PRE>
  farrayPtrR4(lbound(farrayPtrR4,1)+3,lbound(farrayPtrR4,2)+3) = srcMaskValueR4
</PRE>

<P>
<PRE>
  call ESMF_FieldFill(dstField, dataFillScheme="const", const1=0.d0, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_FieldGet(dstField, farrayPtr=farrayPtrR4, rc=rc)
</PRE>

<P>
<PRE>
  farrayPtrR4(lbound(farrayPtrR4,1)+1,lbound(farrayPtrR4,2)+1) = dstMaskValueR4
</PRE>

<P>
Setting up the <TT>ESMF_DynamicMask</TT> object is practically the same as 
   before, just that the correct typekind-triplet suffix for the 
   <TT>DynamicMaskSet</TT> method must be selected, indicating that the 
   destination data is of typekind R4, the factors are still of typekind R8,
   and the source data is of typekind R4.
<P>
<PRE>
  call ESMF_DynamicMaskSetR4R8R4(dynamicMask, &amp;
    dynamicSrcMaskValue=srcMaskValueR4, &amp;
    dynamicDstMaskValue=dstMaskValueR4, &amp;
    dynamicMaskRoutine=simpleDynMaskProcR4R8R4, &amp;
    rc=rc)
</PRE>

<P>
Finally calling into <TT>ESMF_FieldRegrid()</TT> with the <TT>dynamicMask</TT>
   object is unchanged.
<P>
<PRE>
  call ESMF_FieldRegrid(srcField=srcField, dstField=dstField, &amp;
    routehandle=routehandle, zeroregion=ESMF_REGION_EMPTY, &amp;
    dynamicMask=dynamicMask, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION050143000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Non-blocking</B> communication via the <TT>routesyncflag</TT> option is implemented for Fields and Arrays. It is <EM>not</EM> available for FieldBundles and ArrayBundles. The user is advised to use the VMEpoch approach for all cases to achive asynchronicity.

<P>
</LI>
<LI>The <B>dynamic masking</B> feature currently has the following limitations:

<P>

<UL>
<LI>Only available for <TT>ESMF_TYPEKIND_R8</TT> and <TT>ESMF_TYPEKIND_R4</TT> Fields and Arrays.

<P>
</LI>
<LI>Only available through the <TT>ESMF_FieldRegrid()</TT> and <TT>ESMF_ArraySMM()</TT> methods.

<P>
</LI>
<LI>Destination objects that have undistributed dimensions <EM>after</EM> any distributed dimension are not supported.

<P>
</LI>
<LI>No check is implemented that ensure the user-provided RouteHandle object is suitable for dynamic masking.

<P>
</LI>
</UL>

<P>
</LI>
</UL>

<H2><A NAME="SECTION050144000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
Internally all route-based communication calls are implemented as sparse matrix multiplications. The precompute step for all of the supported communication methods can be broken up into three steps:

<OL>
<LI>Construction of the sparse matrix for the specific communication method.
</LI>
<LI>Generation of the communication pattern according to the sparse matrix.
</LI>
<LI>Encoding of the communication pattern for each participating PET in form of an XXE stream.
</LI>
</OL>

<H2><A NAME="SECTION050145000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050145100000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_RouteHandleCreate - Create a new RouteHandle from RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_RouteHandleCreate()
   function ESMF_RouteHandleCreateRH(routehandle, &amp;
     originPetList, targetPetList, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_RouteHandle) :: ESMF_RouteHandleCreateRH
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(in)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: originPetList(:)
     integer,                intent(in),  optional :: targetPetList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_RouteHandle</TT> object from and existing RouteHandle.
     The new RouteHandle can be created to function on a different petList than
     the incoming RouteHandle.

<P>
The arguments are:
     <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>The RouteHandle object to be duplicated.
     
</DD>
<DT><STRONG>[originPetList]</STRONG></DT>
<DD>The petList on which the incoming <TT>routehandle</TT> is defined to operate.
       If present, then <TT>targetPetList</TT> must also be present and of the same
       size. The petLists are used to map origin PETs to target PETs. By
       convention the petLists are constructed to first list the PETs of the
       source component, followed by the PETs of the destination component.
       Defaults, to the petList of the current component context, meaning that
       the PETs in the RouteHandle are not modified.

</DD>
<DT><STRONG>[targetPetList]</STRONG></DT>
<DD>The petList on which the newly created RouteHandle is defined to operate.
       If present, then <TT>originPetList</TT> must also be present and of the same
       size. The petLists are used to map origin PETs to target PETs. By
       convention the petLists are constructed to first list the PETs of the
       source component, followed by the PETs of the destination component.
       Defaults, to the petList of the current component context, meaning that
       the PETs in the RouteHandle are not modified.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050145200000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_RouteHandleCreate - Create a new RouteHandle from file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_RouteHandleCreate()
   function ESMF_RouteHandleCreateFile(fileName, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_RouteHandle) :: ESMF_RouteHandleCreateFile
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),           intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_RouteHandle</TT> object from a file. This method must
     be called from a VM context that holds exactly as many PETs as were used
     when generating the file.

<P>
The arguments are:
     <DL>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the RouteHandle file to be read in.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050145300000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_RouteHandleDestroy - Release resources associated with a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_RouteHandleDestroy(routehandle, &amp;
     noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional :: noGarbage
     integer,                intent(out),  optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_RouteHandle</TT>, releasing the resources associated
     with the object.

<P>
The arguments are:
     <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>The <TT>ESMF_RouteHandle</TT> to be destroyed.
     
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
       from the ESMF garbage collection system. Note however that under this
       condition ESMF cannot protect against accessing the destroyed object
       through dangling aliases - a situation which may lead to hard to debug
       application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
       set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF
       garbage collection system which will prevent problems with dangling
       aliases or incorrect sequences of destroy calls. However this level of
       support requires that a small remnant of the object is kept in memory
       past the destroy call. This can lead to an unexpected increase in memory
       consumption over the course of execution in applications that use
       temporary ESMF objects. For situations where the repeated creation and
       destruction of temporary objects leads to memory issues, it is
       recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully
       removing the entire temporary object from memory.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050145400000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_RouteHandleGet - Get values from a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_RouteHandleGet()
   subroutine ESMF_RouteHandleGetP(routehandle, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(in)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),       intent(out), optional :: name
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns information about an <TT>ESMF_RouteHandle</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD><TT>ESMF_RouteHandle</TT> to be queried.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the RouteHandle object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050145500000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_RouteHandleIsCreated - Check whether a RouteHandle object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_RouteHandleIsCreated(routehandle, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_RouteHandleIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(in)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>routehandle</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD><TT>ESMF_RouteHandle</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050145600000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_RouteHandlePrint - Print the contents of a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_RouteHandlePrint(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(in)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print information about an <TT>ESMF_RouteHandle</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD><TT>ESMF_RouteHandle</TT> to print contents of.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050145700000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_RouteHandleSet - Set values in a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_RouteHandleSet()
   subroutine ESMF_RouteHandleSetP(routehandle, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len = *),     intent(in),  optional :: name
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set an <TT>ESMF_RouteHandle</TT> attribute with the given value.

<P>
The arguments are:
     <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD><TT>ESMF_RouteHandle</TT> to be modified.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The RouteHandle name.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050145800000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_RouteHandleWrite - Write the RouteHandle to file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_RouteHandleWrite(routehandle, fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)         :: routehandle
     character(*),           intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write the RouteHandle to file. The generated file can then be used to
     re-create the same RouteHandle, on the same number of PETs, using the
     <TT>ESMF_RouteHandleCreate(fileName=...)</TT> method.

<P>
The arguments are:
     <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>The <TT>ESMF_RouteHandle</TT> to be written.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the output file to which the RouteHandle is written.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION050150000000000000000">
<SPAN CLASS="arabic">38</SPAN> I/O Capability</A>
</H1>

<H2><A NAME="SECTION050151000000000000000">
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF I/O provides an unified interface for input and output of
high level ESMF objects such as Fields.  ESMF I/O capability is integrated
with third-party software such as <A NAME="tex2html53"
  HREF="https://github.com/NCAR/ParallelIO">Parallel I/O (PIO)</A>
to read and write Fortran array data in MPI_IO binary or NetCDF format, and 
<A NAME="tex2html54"
  HREF="https://github.com/nlohmann/json">JSON for Modern C++</A>
Library to read Info attribute data in JSON format.  Other file I/O
functionalities, such as writing of error and log messages, input of
configuration parameters from an ASCII file, and lower-level I/O utilities are
covered in different sections of this document.  See the Log Class 
<A HREF="node6.html#sec:Log">49.1</A>, the Config Class <A HREF="node6.html#sec:Config">47.1</A>, and the Fortran 
I/O Utilities, <A HREF="node6.html#sec:IOUtil">53.1</A> respectively.

<P>

<H2><A NAME="SECTION050152000000000000000"></A>
<A NAME="io:dataio"></A>
<BR>
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">2</SPAN> Data I/O
</H2>

<P>
ESMF provides interfaces for high performance, parallel I/O using ESMF data
objects such as Arrays and Fields.  Currently ESMF supports I/O of binary and
NetCDF files.  The current ESMF implementation relies on the 
<A NAME="tex2html55"
  HREF="https://github.com/NCAR/ParallelIO">Parallel I/O (PIO)</A>
library developed as a collaboration between NCAR and DOE laboratories.  PIO
is built as part of the ESMF build when the environment variable ESMF_PIO is
set to "internal"; by default it is not set. When PIO is built with ESMF, the
ESMF methods internally call the PIO interfaces.  When PIO is not built with
ESMF, the ESMF methods are non-operable (no-op) stubs that simply return with
a return code of ESMF_RC_LIB_NOT_PRESENT.  Details about the environment
variables can be found in ESMF User Guide, "Building and Installing the ESMF",
"Third Party Libraries".

<P>
The following methods support parallel data I/O using PIO:

<P>
<DL>
<DT></DT>
<DD><TT>ESMF_FieldBundleRead()</TT>, section <A HREF="#api:FieldBundleRead">25.5.19</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_FieldBundleWrite()</TT>, section <A HREF="#api:FieldBundleWrite">25.5.39</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_FieldRead()</TT>, section <A HREF="#api:FieldRead">26.6.60</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_FieldWrite()</TT>, section <A HREF="#api:FieldWrite">26.6.82</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_ArrayBundleRead()</TT>, section <A HREF="#api:ArrayBundleRead">27.5.16</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_ArrayBundleWrite()</TT>, section <A HREF="#api:ArrayBundleWrite">27.5.27</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_ArrayRead()</TT>, section <A HREF="#api:ArrayRead">28.5.27</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_ArrayWrite()</TT>, section <A HREF="#api:ArrayWrite">28.5.47</A>.
</DD>
</DL>

<P>

<H2><A NAME="SECTION050153000000000000000">
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">3</SPAN> Data formats</A>
</H2>

<P>
Two formats are supported, namely, NetCDF and binary (through MPI_IO). 
The environment variables that are enabled when ESMF is built determine the 
format.  The environment variables ESMF_NETCDF or/and ESMF_PNETCDF should be 
set as appropriate to enable NetCDF I/O format.  If neither ESMF_NETCDF nor
ESMF_PNETCDF are set, and MPI_IO is enabled in MPI, the format will be 
binary.  Details about the environment variables can be found in ESMF User 
Guide, "Building and Installing the ESMF", "Third Party Libraries".

<P>
<DL>
<DT><STRONG><B>NetCDF</B></STRONG></DT>
<DD>Network Common Data Form (NetCDF) is an interface for 
array-oriented data access. The NetCDF library provides an
implementation of the interface. It also defines a 
machine-independent format for representing scientific data. Together,
the interface, library, and format support the creation, access, and
sharing of scientific data. The NetCDF software was developed at the
Unidata Program Center in Boulder, Colorado. See [<A
 HREF="node8.html#NetCDF3_UsersGuide_C">16</A>].
In geoscience, NetCDF can be naturally used to represent fields
defined on logically rectangular grids. NetCDF use in geosciences is 
specified by CF conventions mentioned above [<A
 HREF="node8.html#NetCDF_CF">15</A>].

<P>
To the extent that data on unstructured grids (or even observations) can be 
represented as one-dimensional arrays, NetCDF can also be used to store these 
data. However, it does not provide a high-level abstraction for this type of 
data. 

<P>
</DD>
<DT><STRONG><B>IEEE Binary Streams</B></STRONG></DT>
<DD>A natural way for a machine to represent data is to use a native
binary data representation. There are two choices of ordering of bytes
(so-called <I>Big Endian</I> and <I>Little Endian</I>), and a lot of
ambiguity in representing floating point data. The latter, however, is
specified, if IEEE Floating Point Standard 754 is satisfied.
([<A
 HREF="node8.html#IEEE-Floating-Point">23</A>], [<A
 HREF="node8.html#Kahan-IEEE-754">27</A>]). 
[<A
 HREF="node8.html#XML-W3C">21</A>].

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION050154000000000000000">
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>
Currently a small fraction of the anticipated data formats is implemented by 
ESMF.  The data I/O uses NetCDF and MPI_IO binary formats, and ESMF Attribute
I/O uses XML format.  Different libraries are employed for these
different formats.  In future development, a more centralized I/O technique
will likely be defined to provide efficient utilities with a set of standard
APIs that will allow manipulation of multiple standard formats.  Also, the 
ability to automatically detect file formats at runtime will be developed.

<P>

<H2><A NAME="SECTION050155000000000000000">
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
For data I/O, the ESMF I/O capability relies on the
<A NAME="tex2html56"
  HREF="https://github.com/NCAR/ParallelIO">PIO</A>,
<A NAME="tex2html57"
  HREF="http://www.unidata.ucar.edu/software/netcdf">NetCDF</A>, 
<A NAME="tex2html58"
  HREF="http://trac.mcs.anl.gov/projects/parallel-netcdf">PNetCDF</A>
and MPI_IO libraries.  For Info attribute I/O, the ESMF I/O capability uses
the <A NAME="tex2html59"
  HREF="https://github.com/nlohmann/json">JSON for Modern C++</A>
library to perform reading of JSON files.  PIO is included with the ESMF
distribution; the other libraries must be installed on the machine of interest.

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html2267"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2263"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2257"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2265"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2268"
  HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html2264"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html2258"
  HREF="node4.html">3 Superstructure</A>
 &nbsp; <B>  <A NAME="tex2html2266"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
