<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>3 API</TITLE>
<META NAME="description" CONTENT="3 API">
<META NAME="keywords" CONTENT="NUOPC_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="NUOPC_refdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="NUOPC_refdoc.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html441"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html437"
  HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html431"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html439"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html442"
  HREF="node5.html">4 Standardized Component Dependencies</A>
<B> Up:</B> <A NAME="tex2html438"
  HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A NAME="tex2html432"
  HREF="node3.html">2 Design and Implementation</A>
 &nbsp; <B>  <A NAME="tex2html440"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html443"
  HREF="node4.html#SECTION00041000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Generic Component: NUOPC_Driver</A>
<UL>
<LI><A NAME="tex2html444"
  HREF="node4.html#SECTION00041100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_DriverAddComp</A>
<LI><A NAME="tex2html445"
  HREF="node4.html#SECTION00041200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_DriverAddComp</A>
<LI><A NAME="tex2html446"
  HREF="node4.html#SECTION00041300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_DriverAddComp</A>
<LI><A NAME="tex2html447"
  HREF="node4.html#SECTION00041400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_DriverAddRunElement</A>
<LI><A NAME="tex2html448"
  HREF="node4.html#SECTION00041500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_DriverAddRunElement</A>
<LI><A NAME="tex2html449"
  HREF="node4.html#SECTION00041600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_DriverAddRunElement</A>
<LI><A NAME="tex2html450"
  HREF="node4.html#SECTION00041700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_DriverEgestRunSequence</A>
<LI><A NAME="tex2html451"
  HREF="node4.html#SECTION00041800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_DriverGet</A>
<LI><A NAME="tex2html452"
  HREF="node4.html#SECTION00041900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_DriverGetComp</A>
<LI><A NAME="tex2html453"
  HREF="node4.html#SECTION000411000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_DriverGetComp</A>
<LI><A NAME="tex2html454"
  HREF="node4.html#SECTION000411100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_DriverGetComp</A>
<LI><A NAME="tex2html455"
  HREF="node4.html#SECTION000411200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_DriverGetComp</A>
<LI><A NAME="tex2html456"
  HREF="node4.html#SECTION000411300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_DriverIngestRunSequence</A>
<LI><A NAME="tex2html457"
  HREF="node4.html#SECTION000411400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_DriverNewRunSequence</A>
<LI><A NAME="tex2html458"
  HREF="node4.html#SECTION000411500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_DriverPrint</A>
<LI><A NAME="tex2html459"
  HREF="node4.html#SECTION000411600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_DriverSetRunSequence</A>
</UL>
<BR>
<LI><A NAME="tex2html460"
  HREF="node4.html#SECTION00042000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Generic Component: NUOPC_ModelBase</A>
<LI><A NAME="tex2html461"
  HREF="node4.html#SECTION00043000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Generic Component: NUOPC_Model</A>
<UL>
<LI><A NAME="tex2html462"
  HREF="node4.html#SECTION00043100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_ModelGet</A>
</UL>
<BR>
<LI><A NAME="tex2html463"
  HREF="node4.html#SECTION00044000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Generic Component: NUOPC_Mediator</A>
<UL>
<LI><A NAME="tex2html464"
  HREF="node4.html#SECTION00044100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_MediatorGet</A>
</UL>
<BR>
<LI><A NAME="tex2html465"
  HREF="node4.html#SECTION00045000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Generic Component: NUOPC_Connector</A>
<UL>
<LI><A NAME="tex2html466"
  HREF="node4.html#SECTION00045100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_ConnectorGet</A>
<LI><A NAME="tex2html467"
  HREF="node4.html#SECTION00045200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_ConnectorSet</A>
</UL>
<BR>
<LI><A NAME="tex2html468"
  HREF="node4.html#SECTION00046000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> General Generic Component Methods</A>
<UL>
<LI><A NAME="tex2html469"
  HREF="node4.html#SECTION00046100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_CompAreServicesSet</A>
<LI><A NAME="tex2html470"
  HREF="node4.html#SECTION00046200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_CompAreServicesSet</A>
<LI><A NAME="tex2html471"
  HREF="node4.html#SECTION00046300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_CompAttributeAdd</A>
<LI><A NAME="tex2html472"
  HREF="node4.html#SECTION00046400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_CompAttributeAdd</A>
<LI><A NAME="tex2html473"
  HREF="node4.html#SECTION00046500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_CompAttributeEgest</A>
<LI><A NAME="tex2html474"
  HREF="node4.html#SECTION00046600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_CompAttributeEgest</A>
<LI><A NAME="tex2html475"
  HREF="node4.html#SECTION00046700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html476"
  HREF="node4.html#SECTION00046800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html477"
  HREF="node4.html#SECTION00046900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html478"
  HREF="node4.html#SECTION000461000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html479"
  HREF="node4.html#SECTION000461100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html480"
  HREF="node4.html#SECTION000461200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html481"
  HREF="node4.html#SECTION000461300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html482"
  HREF="node4.html#SECTION000461400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html483"
  HREF="node4.html#SECTION000461500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_CompAttributeIngest</A>
<LI><A NAME="tex2html484"
  HREF="node4.html#SECTION000461600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_CompAttributeIngest</A>
<LI><A NAME="tex2html485"
  HREF="node4.html#SECTION000461700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_CompAttributeReset</A>
<LI><A NAME="tex2html486"
  HREF="node4.html#SECTION000461800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> NUOPC_CompAttributeReset</A>
<LI><A NAME="tex2html487"
  HREF="node4.html#SECTION000461900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html488"
  HREF="node4.html#SECTION000462000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html489"
  HREF="node4.html#SECTION000462100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html490"
  HREF="node4.html#SECTION000462200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html491"
  HREF="node4.html#SECTION000462300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html492"
  HREF="node4.html#SECTION000462400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html493"
  HREF="node4.html#SECTION000462500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> NUOPC_CompCheckSetClock</A>
<LI><A NAME="tex2html494"
  HREF="node4.html#SECTION000462600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> NUOPC_CompDerive</A>
<LI><A NAME="tex2html495"
  HREF="node4.html#SECTION000462700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> NUOPC_CompDerive</A>
<LI><A NAME="tex2html496"
  HREF="node4.html#SECTION000462800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> NUOPC_CompFilterPhaseMap</A>
<LI><A NAME="tex2html497"
  HREF="node4.html#SECTION000462900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> NUOPC_CompFilterPhaseMap</A>
<LI><A NAME="tex2html498"
  HREF="node4.html#SECTION000463000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> NUOPC_CompGet</A>
<LI><A NAME="tex2html499"
  HREF="node4.html#SECTION000463100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> NUOPC_CompGet</A>
<LI><A NAME="tex2html500"
  HREF="node4.html#SECTION000463200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> NUOPC_CompSearchPhaseMap</A>
<LI><A NAME="tex2html501"
  HREF="node4.html#SECTION000463300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> NUOPC_CompSearchPhaseMap</A>
<LI><A NAME="tex2html502"
  HREF="node4.html#SECTION000463400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> NUOPC_CompSearchRevPhaseMap</A>
<LI><A NAME="tex2html503"
  HREF="node4.html#SECTION000463500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> NUOPC_CompSearchRevPhaseMap</A>
<LI><A NAME="tex2html504"
  HREF="node4.html#SECTION000463600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> NUOPC_CompSetClock</A>
<LI><A NAME="tex2html505"
  HREF="node4.html#SECTION000463700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> NUOPC_CompSetEntryPoint</A>
<LI><A NAME="tex2html506"
  HREF="node4.html#SECTION000463800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> NUOPC_CompSetEntryPoint</A>
<LI><A NAME="tex2html507"
  HREF="node4.html#SECTION000463900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> NUOPC_CompSetInternalEntryPoint</A>
<LI><A NAME="tex2html508"
  HREF="node4.html#SECTION000464000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> NUOPC_CompSetServices</A>
<LI><A NAME="tex2html509"
  HREF="node4.html#SECTION000464100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> NUOPC_CompSpecialize</A>
<LI><A NAME="tex2html510"
  HREF="node4.html#SECTION000464200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> NUOPC_CompSpecialize</A>
</UL>
<BR>
<LI><A NAME="tex2html511"
  HREF="node4.html#SECTION00047000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Field Dictionary Methods</A>
<UL>
<LI><A NAME="tex2html512"
  HREF="node4.html#SECTION00047100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_FieldDictionaryAddEntry</A>
<LI><A NAME="tex2html513"
  HREF="node4.html#SECTION00047200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_FieldDictionaryEgest</A>
<LI><A NAME="tex2html514"
  HREF="node4.html#SECTION00047300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_FieldDictionaryGetEntry</A>
<LI><A NAME="tex2html515"
  HREF="node4.html#SECTION00047400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_FieldDictionaryHasEntry</A>
<LI><A NAME="tex2html516"
  HREF="node4.html#SECTION00047500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_FieldDictionaryMatchSyno</A>
<LI><A NAME="tex2html517"
  HREF="node4.html#SECTION00047600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_FieldDictionarySetSyno</A>
<LI><A NAME="tex2html518"
  HREF="node4.html#SECTION00047700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_FieldDictionarySetup</A>
<LI><A NAME="tex2html519"
  HREF="node4.html#SECTION00047800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_FieldDictionarySetup</A>
</UL>
<BR>
<LI><A NAME="tex2html520"
  HREF="node4.html#SECTION00048000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Free Format Methods</A>
<UL>
<LI><A NAME="tex2html521"
  HREF="node4.html#SECTION00048100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_FreeFormatAdd</A>
<LI><A NAME="tex2html522"
  HREF="node4.html#SECTION00048200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_FreeFormatCreate</A>
<LI><A NAME="tex2html523"
  HREF="node4.html#SECTION00048300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_FreeFormatCreate</A>
<LI><A NAME="tex2html524"
  HREF="node4.html#SECTION00048400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_FreeFormatDestroy</A>
<LI><A NAME="tex2html525"
  HREF="node4.html#SECTION00048500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_FreeFormatGet</A>
<LI><A NAME="tex2html526"
  HREF="node4.html#SECTION00048600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_FreeFormatGetLine</A>
<LI><A NAME="tex2html527"
  HREF="node4.html#SECTION00048700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_FreeFormatLog</A>
<LI><A NAME="tex2html528"
  HREF="node4.html#SECTION00048800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_FreeFormatPrint</A>
</UL>
<BR>
<LI><A NAME="tex2html529"
  HREF="node4.html#SECTION00049000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Utility Routines</A>
<UL>
<LI><A NAME="tex2html530"
  HREF="node4.html#SECTION00049100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_AddNamespace</A>
<LI><A NAME="tex2html531"
  HREF="node4.html#SECTION00049200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_AddNestedState</A>
<LI><A NAME="tex2html532"
  HREF="node4.html#SECTION00049300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_Advertise</A>
<LI><A NAME="tex2html533"
  HREF="node4.html#SECTION00049400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_Advertise</A>
<LI><A NAME="tex2html534"
  HREF="node4.html#SECTION00049500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_AdjustClock</A>
<LI><A NAME="tex2html535"
  HREF="node4.html#SECTION00049600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_CheckSetClock</A>
<LI><A NAME="tex2html536"
  HREF="node4.html#SECTION00049700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_GetAttribute</A>
<LI><A NAME="tex2html537"
  HREF="node4.html#SECTION00049800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_GetAttribute</A>
<LI><A NAME="tex2html538"
  HREF="node4.html#SECTION00049900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_GetAttribute</A>
<LI><A NAME="tex2html539"
  HREF="node4.html#SECTION000491000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_GetStateMemberLists</A>
<LI><A NAME="tex2html540"
  HREF="node4.html#SECTION000491100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_GetStateMemberCount</A>
<LI><A NAME="tex2html541"
  HREF="node4.html#SECTION000491200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_GetTimestamp</A>
<LI><A NAME="tex2html542"
  HREF="node4.html#SECTION000491300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_IngestPetList</A>
<LI><A NAME="tex2html543"
  HREF="node4.html#SECTION000491400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_IsAtTime</A>
<LI><A NAME="tex2html544"
  HREF="node4.html#SECTION000491500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_IsAtTime</A>
<LI><A NAME="tex2html545"
  HREF="node4.html#SECTION000491600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_IsConnected</A>
<LI><A NAME="tex2html546"
  HREF="node4.html#SECTION000491700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_IsConnected</A>
<LI><A NAME="tex2html547"
  HREF="node4.html#SECTION000491800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">18</SPAN> NUOPC_IsUpdated</A>
<LI><A NAME="tex2html548"
  HREF="node4.html#SECTION000491900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">19</SPAN> NUOPC_IsUpdated</A>
<LI><A NAME="tex2html549"
  HREF="node4.html#SECTION000492000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">20</SPAN> NUOPC_NoOp</A>
<LI><A NAME="tex2html550"
  HREF="node4.html#SECTION000492100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">21</SPAN> NUOPC_Realize</A>
<LI><A NAME="tex2html551"
  HREF="node4.html#SECTION000492200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">22</SPAN> NUOPC_Realize</A>
<LI><A NAME="tex2html552"
  HREF="node4.html#SECTION000492300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">23</SPAN> NUOPC_Realize</A>
<LI><A NAME="tex2html553"
  HREF="node4.html#SECTION000492400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">24</SPAN> NUOPC_Realize</A>
<LI><A NAME="tex2html554"
  HREF="node4.html#SECTION000492500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">25</SPAN> NUOPC_Realize</A>
<LI><A NAME="tex2html555"
  HREF="node4.html#SECTION000492600000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">26</SPAN> NUOPC_SetAttribute</A>
<LI><A NAME="tex2html556"
  HREF="node4.html#SECTION000492700000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">27</SPAN> NUOPC_SetAttribute</A>
<LI><A NAME="tex2html557"
  HREF="node4.html#SECTION000492800000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">28</SPAN> NUOPC_SetTimestamp</A>
<LI><A NAME="tex2html558"
  HREF="node4.html#SECTION000492900000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">29</SPAN> NUOPC_SetTimestamp</A>
<LI><A NAME="tex2html559"
  HREF="node4.html#SECTION000493000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">30</SPAN> NUOPC_SetTimestamp</A>
<LI><A NAME="tex2html560"
  HREF="node4.html#SECTION000493100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">31</SPAN> NUOPC_SetTimestamp</A>
<LI><A NAME="tex2html561"
  HREF="node4.html#SECTION000493200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">32</SPAN> NUOPC_SetTimestamp</A>
</UL>
<BR>
<LI><A NAME="tex2html562"
  HREF="node4.html#SECTION000410000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Auxiliary Routines</A>
<UL>
<LI><A NAME="tex2html563"
  HREF="node4.html#SECTION000410100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_Write</A>
<LI><A NAME="tex2html564"
  HREF="node4.html#SECTION000410200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_Write</A>
<LI><A NAME="tex2html565"
  HREF="node4.html#SECTION000410300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_Write</A>
<LI><A NAME="tex2html566"
  HREF="node4.html#SECTION000410400000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_Write</A>
<LI><A NAME="tex2html567"
  HREF="node4.html#SECTION000410500000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_Write</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00040000000000000000">
<SPAN CLASS="arabic">3</SPAN> API</A>
</H1>

<H2><A NAME="SECTION00041000000000000000"></A>
<A NAME="NUOPC_Driver"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Generic Component: NUOPC_Driver
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<I CLASS="sans">MODULE:</I>
<PRE>  module NUOPC_Driver
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Component that drives and coordinates initialization of its child components: Model, Mediator, and Connector components. For every Driver time step the same run sequence, i.e. sequence of Model, Mediator, and Connector <TT>Run</TT> methods is called. The run sequence is fully customizable. The default run sequence implements explicit time stepping.

<P>

<P><P>
<BR>
<I CLASS="sans">SUPER:</I>
<PRE>  ESMF_GridComp
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SETSERVICES:</I>
<PRE>  subroutine SetServices(driver, rc)
    type(ESMF_GridComp)   :: driver
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SEMANTIC SPECIALIZATION LABELS:</I>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_SetModelServices</B>
    
<UL>
<LI>Optional. By default driver has no child components.
</LI>
<LI>Use <TT>NUOPC_DriverAddComp()</TT> repeatedly to add child components to the driver.
</LI>
<LI>Use <TT>NUOPC_CompAttributeSet()</TT> or <TT>NUOPC_CompAttributeIngest()</TT> to set attributes on child components.
</LI>
<LI>Create and set driver clock with startTime, stopTime, and timeStep, if not done by the driver's parent.
    
</LI>
</UL>
</LI>
<LI><B>label_SetRunSequence</B>
    
<UL>
<LI>Optional. By default drive child components in the sequence they were added.
</LI>
<LI>Define and set a RunSequence either by calling <TT>NUOPC_DriverIngestRunSequence()</TT>, or by using the <TT>NUOPC_DriverNewRunSequence()</TT> and <TT>NUOPC_DriverAddRunElement()</TT> API.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyInitializePhaseMap</B>
    
<UL>
<LI>Optional. By default InitializePhaseMap attributes are not modified.
</LI>
<LI>Modify the InitializePhaseMap attribute on the child components as desired. This is very rarely needed.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyCplLists</B>
    
<UL>
<LI>Optional. By default CplList attributes are  not modified.
</LI>
<LI>Modify the CplList attribute on the child components as desired. This can be useful to set custom Connection Options for specific Field pairs.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_SetRunClock</B>
      
<UL>
<LI>Optional. By default driver clock is not modified each time its Run is entered.
</LI>
<LI>Modify the driver clock before executing RunSequence. This is very rarely needed.
      
</LI>
</UL>
</LI>
<LI><B>label_ExecuteRunSequence</B>
    
<UL>
<LI>Optional. By default use NUOPC generic RunSequence execution.
</LI>
<LI>Implement a custom RunSequence execution. This is very rarely needed.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00041100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_DriverAddComp - Add a GridComp child to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddGridComp(driver, compLabel, &amp;
     compSetServicesRoutine, compSetVMRoutine, petList, info, config, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     interface
       recursive subroutine compSetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     interface
       recursive subroutine compSetVMRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     optional                                   :: compSetVMRoutine
     integer,             intent(in),  optional :: petList(:)
     type(ESMF_Info),     intent(in),  optional :: info
     type(ESMF_Config),   intent(in),  optional :: config
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create and add a GridComp (i.e. Model, Mediator, or Driver) as a child 
   component to a Driver. The component is created on the provided <TT>petList</TT>,
   or by default across all of the Driver PETs.

<P>
The specified <TT>compSetServicesRoutine()</TT> is called back immediately after
   the new child component has been created internally. Very little around the
   component is set up at that time (e.g. NUOPC component attributes will not be
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component - typically by deriving 
   from a generic component followed by the appropriate specilizations.

<P>
If provided, the <TT>compSetVMRoutine()</TT> is called back before the 
   <TT>compSetServicesRoutine()</TT>. This allows the child component to set
   aspects of its own VM, such as threading or the PE distribution among PETs.

<P>
The <TT>info</TT> argument can be used to pass custom attributes to the child
   component. These attributes are available on the component when
   <TT>compSetVMRoutine()</TT> and <TT>compSetServicesRoutine()</TT> are called.
   The attributes provided in <TT>info</TT> are <EM>copied</EM> onto the child
   component. This allows the same <TT>info</TT> object to be used for multiple
   child components without conflict.

<P>
The <TT>compLabel</TT> must uniquely identify the child component within the
   context of the Driver component.

<P>
If the <TT>comp</TT> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A NAME="SECTION00041200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_DriverAddComp - Add a GridComp child from shared object to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddGridCompSO(driver, compLabel, &amp;
     sharedObj, petList, info, config, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(in),  optional :: petList(:)
     type(ESMF_Info),     intent(in),  optional :: info
     type(ESMF_Config),   intent(in),  optional :: config
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create and add a GridComp (i.e. Model, Mediator, or Driver) as a child 
   component to a Driver. The component is created on the provided <TT>petList</TT>,
   or by default across all of the Driver PETs. 

<P>
The <TT>SetServices()</TT> routine in the <TT>sharedObj</TT> is called back
   immediately after the
   new child component has been created internally. Very little around the
   component is set up at that time (e.g. NUOPC component attributes will not be
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component - typically by deriving 
   from a generic component followed by the appropriate specilizations.

<P>
The <TT>info</TT> argument can be used to pass custom attributes to the child
   component. These attributes are available on the component when
   <TT>compSetVMRoutine()</TT> and <TT>compSetServicesRoutine()</TT> are called.
   The attributes provided in <TT>info</TT> are <EM>copied</EM> onto the child
   component. This allows the same <TT>info</TT> object to be used for multiple
   child components without conflict.

<P>
The <TT>compLabel</TT> must uniquely identify the child component within the
   context of the Driver component.

<P>
If the <TT>comp</TT> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A NAME="SECTION00041300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_DriverAddComp - Add a CplComp child to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   recursive subroutine NUOPC_DriverAddCplComp(driver, srcCompLabel, &amp;
     dstCompLabel, compSetServicesRoutine, compSetVMRoutine, petList, info, &amp;
     config, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
     interface
       recursive subroutine compSetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     interface
       recursive subroutine compSetVMRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     optional                                   :: compSetVMRoutine
     integer, target,     intent(in),  optional :: petList(:)
     type(ESMF_Info),     intent(in),  optional :: info
     type(ESMF_Config),   intent(in),  optional :: config
     type(ESMF_CplComp),  intent(out), optional :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create and add a CplComp (i.e. Connector) as a child component to a Driver.
   The component is created on the provided <TT>petList</TT>, or by default across 
   the union of PETs of the components indicated by <TT>srcCompLabel</TT>
   and <TT>dstCompLabel</TT>.

<P>
The specified <TT>SetServices()</TT> routine is called back immediately after the
   new child component has been created internally. Very little around the
   component is set up at that time (e.g. NUOPC component attributes will not be
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component - typically by deriving 
   from a generic component followed by the appropriate specilizations.

<P>
The <TT>info</TT> argument can be used to pass custom attributes to the child
   component. These attributes are available on the component when
   <TT>compSetVMRoutine()</TT> and <TT>compSetServicesRoutine()</TT> are called.
   The attributes provided in <TT>info</TT> are <EM>copied</EM> onto the child
   component. This allows the same <TT>info</TT> object to be used for multiple
   child components without conflict.

<P>
The <TT>compLabel</TT> must uniquely identify the child component within the 
   context of the Driver component.

<P>
If the <TT>comp</TT> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A NAME="SECTION00041400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_DriverAddRunElement - Add RunElement for Model, Mediator, or Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementMPL(driver, slot, compLabel, &amp;
     phaseLabel, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     character(len=*),    intent(in)            :: compLabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: phaseLabel
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add an element associated with a Model, Mediator, or Driver component to the
   run sequence of the Driver. The component must have been added to the Driver,
   and associated with <TT>compLabel</TT> prior to this call.

<P>
If <TT>phaseLabel</TT> was not specified, the first entry in the
   <TT>RunPhaseMap</TT> attribute of the referenced component will be used to 
   determine the run phase of the added element.

<P>
By default an error is returned if no component is associated with the 
   specified <TT>compLabel</TT>. This error can be suppressed by setting
   <TT>relaxedflag=.true.</TT>, and no entry will be added to the run sequence.

<P>
The <TT>slot</TT> number identifies the run sequence time slot in case multiple
   sequences are available. Slots start counting from 1. 

<P>

<P>

<H3><A NAME="SECTION00041500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_DriverAddRunElement - Add RunElement for Connector</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementCPL(driver, slot, srcCompLabel,&amp;
     dstCompLabel, phaseLabel, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: phaseLabel
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add an element associated with a Connector component to the
   run sequence of the Driver. The component must have been added to the Driver,
   and associated with <TT>srcCompLabel</TT> and <TT>dstCompLabel</TT> prior to this
   call.

<P>
If <TT>phaseLabel</TT> was not specified, the first entry in the
   <TT>RunPhaseMap</TT> attribute of the referenced component will be used to 
   determine the run phase of the added element.

<P>
By default an error is returned if no component is associated with the 
   specified <TT>compLabel</TT>. This error can be suppressed by setting
   <TT>relaxedflag=.true.</TT>, and no entry will be added to the run sequence.

<P>
The <TT>slot</TT> number identifies the run sequence time slot in case multiple
   sequences are available. Slots start counting from 1. 

<P>

<P>

<H3><A NAME="SECTION00041600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_DriverAddRunElement - Add RunElement that links to another slot</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   recursive subroutine NUOPC_DriverAddRunElementL(driver, slot, linkSlot, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     integer,             intent(in)            :: linkSlot
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add an element to the run sequence of the Driver that links to the time slot
   indicated by <TT>linkSlot</TT>. 

<P>

<P>

<H3><A NAME="SECTION00041700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_DriverEgestRunSequence - Egest the run sequence as FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine NUOPC_DriverEgestRunSequence(driver, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: driver
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Egest the run sequence stored in the driver as a FreeFormat object. It is the
   caller's responsibility to destroy the created freeFormat object. 

<P>

<P>

<H3><A NAME="SECTION00041800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_DriverGet - Get info from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGet()
   recursive subroutine NUOPC_DriverGet(driver, slotCount, parentClock, &amp;
     importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(out), optional :: slotCount
     type(ESMF_Clock),    intent(out), optional :: parentClock
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access Driver information. 

<P>

<P>

<H3><A NAME="SECTION00041900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_DriverGetComp - Get a GridComp child from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetGridComp(driver, compLabel, comp, petList, &amp;
     importState, exportState, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             pointer,     optional :: petList(:)
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query the Driver for a GridComp (i.e. Model, Mediator, or Driver) child 
   component that was added under <TT>compLabel</TT>.

<P>
If provided, the <TT>petList</TT> argument will be associated with the petList
   that was used to create the referenced component. This pointer must not be
   deallocated by the user!

<P>
By default an error is returned if no component is associated with the 
   specified <TT>compLabel</TT>. This error can be suppressed by setting
   <TT>relaxedflag=.true.</TT>, and unassociated arguments will be returned. 

<P>

<P>

<H3><A NAME="SECTION000411000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_DriverGetComp - Get a CplComp child from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetCplComp(driver, srcCompLabel, &amp;
     dstCompLabel, comp, petList, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
     type(ESMF_CplComp),  intent(out), optional :: comp
     integer,             pointer    , optional :: petList(:)
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query the Driver for a CplComp (i.e. Connector) child 
   component that was added under <TT>compLabel</TT>.

<P>
If provided, the <TT>petList</TT> argument will be associated with the petList
   that was used to create the referenced component. This pointer must not be
   deallocated by the user!

<P>
By default an error is returned if no component is associated with the 
   specified <TT>compLabel</TT>. This error can be suppressed by setting
   <TT>relaxedflag=.true.</TT>, and unassociated arguments will be returned. 

<P>

<P>

<H3><A NAME="SECTION000411100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_DriverGetComp - Get all the GridComp child components from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetAllGridComp(driver, compList, petLists, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     type(ESMF_GridComp), pointer, optional     :: compList(:)
     type(ESMF_PtrInt1D), pointer, optional     :: petLists(:)
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get all the GridComp (i.e. Model, Mediator, or Driver) child components from a
   Driver. The incoming <TT>compList</TT> and <TT>petLists</TT> arguments must be 
   unassociated. This means that the user code must explicitly call
   <TT>nullify()</TT> or use the <TT>=&gt; null()</TT> syntax on the variables passed in
   as the actual arguments. On return it becomes the responsibility of the caller
   to deallocate any associated <TT>compList</TT> and <TT>petLists</TT> arguments. 

<P>

<P>

<H3><A NAME="SECTION000411200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_DriverGetComp - Get all the CplComp child components from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   recursive subroutine NUOPC_DriverGetAllCplComp(driver, compList, petLists, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     type(ESMF_CplComp),  pointer               :: compList(:)
     type(ESMF_PtrInt1D), pointer, optional     :: petLists(:)
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get all the CplComp (i.e. Connector) child components from a
   Driver. The incoming <TT>compList</TT> and <TT>petLists</TT> arguments must be 
   unassociated. This means that the user code must explicitly call
   <TT>nullify()</TT> or use the <TT>=&gt; null()</TT> syntax on the variables passed in
   as the actual arguments. On return it becomes the responsibility of the caller
   to deallocate any associated <TT>compList</TT> and <TT>petLists</TT> arguments. 

<P>

<P>

<H3><A NAME="SECTION000411300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_DriverIngestRunSequence - Ingest the run sequence from FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine NUOPC_DriverIngestRunSequence(driver, freeFormat, &amp;
     autoAddConnectors, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: driver
     type(NUOPC_FreeFormat), intent(in),  target   :: freeFormat
     logical,                intent(in),  optional :: autoAddConnectors
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Ingest the run sequence from a FreeFormat object and replace the
   run sequence currently held by the driver. Every line in
   <TT>freeFormat</TT> corresponds to either a component run sequence element, or
   is part of a time loop or alarm block defintion.

<P>
<B>Component run sequence elements</B> define the run method of a single
   component. The lines are interpreted sequentially, however, components
   will execute concurrently as long as this is not prevented by
   data-dependencies or overlapping petLists.

<P>
Each line specifies the precise run method phase for a single component
   instance. For model, mediator, and driver components the format is this:

<P>
<PRE>
     compLabel [phaseLabel]
</PRE>
   Here <TT>compLabel</TT> is the label by which the component instance is known to
   the driver. It is optionally followed a <TT>phaseLabel</TT> identifying a
   specific run phase. An example of calling the run phase of the ATM instance
   that contains the "fast" processes, and is labeled <TT>fast</TT>:

<P>
<PRE>
     ATM fast
</PRE>
   By default, i.e. without <TT>phaseLabel</TT>, the first
   registered run method of the component is used.

<P>
The format for connector components is different. It looks like this:

<P>
<PRE>
     srcCompLabel -&gt; dstCompLabel [connectionOptions]
</PRE>
   A connector instance is uniquely known by the two components it connects,
   i.e. by <TT>srcCompLabel</TT> and <TT>dstCompLabel</TT>. The syntax requires that
   the token <TT>-&gt;</TT> be specified between source and destination. Optionally
   <TT>connectionOptions</TT> can be supplied using the format discussed
   under section <A HREF="node3.html#connection_options">2.4.4</A>. The connection options are set
   as attribute <TT>ConnectionOptions</TT> on the respective connector component.

<P>
An example of executing the connector
   instance that transfers fields from the ATM component to the OCN component,
   using redistribution for remapping:

<P>
<PRE>
     ATM -&gt; OCN :remapMethod=redist
</PRE>

<P>
By default <TT>autoAddConnectors</TT> is <TT>.false.</TT>, which means that all
   components referenced in the <TT>freeFormat</TT> run sequence, including 
   connectors, must already be available as child components of the <TT>driver</TT>
   component. An error will be returned if this is not the case.
   However, when <TT>autoAddConnectors</TT> is set to <TT>.true.</TT>, connector
   components encountered in the run sequence that are no already present in
   the <TT>driver</TT> will be added automatically. The default
   <TT>NUOPC_Connector</TT> implementation is used for all automatically added
   connector instances.

<P>
Lines that contain a <B>time loop</B> definition have the general format:

<P>
<PRE>
     @{timeStep|*}[:runDuration]
       ...
       ...
     @
</PRE>
   Both <TT>timeStep</TT> and <TT>runDuration</TT> are numbers in units of seconds.
   Time loops can be nested and concatenated.

<P>
A wildcard "*" character can be specified in place of an actual <TT>timeStep</TT>
   number. In this case the <TT>timeStep</TT> of the associated run clock object
   is set to be equal to the <TT>timeStep</TT> of the time loop one level up in the
   loop nesting hierarchy.
   If a wildcard time step is used for a single outer time loop in the run
   sequence, then the associated run clock is identical to the driver clock and
   must be set explicitly by the driver code, or its parent component.

<P>
The <TT>runDuration</TT> specification is optional. If omitted, the duration of
   the associated run clock is set to the <TT>timeStep</TT> of the time loop one
   level up in the loop nesting hierarchy. This ensures that for a single
   nested time loop, the loop returns to the parent loop level at the appropriate
   time.

<P>
A simple example of a single time loop with one hour timestep:

<P>
<PRE>
     @3600
       ...
       ...
     @
</PRE>
   Each time loop has its own associated clock object. NUOPC manages these clock
   objects, i.e. their creation and destruction, as well as <TT>startTime</TT>,
   <TT>endTime</TT>, <TT>timeStep</TT> adjustments during the execution. The outer
   most time loop of the run sequence is a special case. It uses the driver
   clock itself. If a single outer most loop is defined in the run sequence
   provided by <TT>freeFormat</TT>, this loop becomes the driver loop level
   directly. Therefore, setting the <TT>timeStep</TT> or <TT>runDuration</TT> for
   the outer most time loop results modifiying the driver clock itself.
   However, for cases with concatenated loops on the upper level of
   the run sequence in <TT>freeFormat</TT>, a single outer loop is added
   automatically during ingestion, and the driver clock is used for this loop
   instead.

<P>
A more complex run sequence example, that shows component run
   sequence elements outside of time loops, a nested time loop, time step
   wildcards, explicit duration specifications, and concatenated time loops:

<P>
<PRE>
     @100:800
       ATM -&gt; OCN
       OCN -&gt; ATM
       ATM
       OCN
       @*
         OCN -&gt; EXTOCN
         EXTOCN
       @
     @
     ATM -&gt; EXTATM
     EXTATM
     @100:1000
       ATM -&gt; OCN
       OCN -&gt; ATM
       ATM
       OCN
     @
</PRE>
   Here the <TT>timeStep</TT> of the first time loop is explicitly chosen at
   <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$100s$"></SPAN>. The <TT>runDuration</TT> is explicitly set to <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$800s$"></SPAN>. The first time
   loop steps the current time forward for <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$800s$"></SPAN>, for each iteration executing
   ATM-OCN coupling, followed by the nested loop that calls the
   <TT>OCN -&gt; EXTOCN</TT> and <TT>EXTOCN</TT> components. The nested loop uses a
    wildcard <TT>timeStep</TT> and therefore is
   identical to the parent loop level <TT>timeStep</TT> of <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$100s$"></SPAN>. The nested
   <TT>runDuration</TT> is not specified and therefore also defaults to the parent
   time step of <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$100s$"></SPAN>. In other words, the nested loop is executed exactly once
   for every parent loop iteration.

<P>
After <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$800s$"></SPAN> the first time loop is exited, and followed by explicit calls to
   <TT>ATM -&gt; EXTAMT</TT> and <TT>EXTATM</TT> components. Finally the second time loop
   is entered for another <SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="$1000s$"></SPAN> <TT>runDuration</TT>. The <TT>timeStep</TT> is again
   explicitly set to <SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="$100s$"></SPAN>. The second time loop only implements ATM-OCN
   coupling, and no coupling to EXTOCN is implemented. Finally, after <SPAN CLASS="MATH"><IMG
 WIDTH="43" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="$1800s$"></SPAN>
   the sequence returns to the driver level loop.

<P>
Lines that contain an <B>alarm block</B> definition have the general format:

<P>
<PRE>
     @@{alarmTime|*}
       ...
       ...
     @@
</PRE>
   The <TT>alarmTime</TT> is a number in units of seconds, and indicates at which
   interval the alarm will ring. The first ring time of an alarm is the current
   time of the parent clock.

<P>
Specification of the wildcard character <TT>*</TT> sets the alarmTime equal to
   the timeStep of the parentClock.

<P>
When an alarm rings, the entire alarm block is executed once.

<P>
Nesting of time loops and alarm blocks is supported.

<P>

<P>

<H3><A NAME="SECTION000411400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_DriverNewRunSequence - Replace the run sequence in a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine NUOPC_DriverNewRunSequence(driver, slotCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slotCount
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Replace the current run sequence of the Driver with a new one that has 
   <TT>slotCount</TT> slots. Each slot uses its own clock for time keeping. 

<P>

<P>

<H3><A NAME="SECTION000411500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_DriverPrint - Print internal Driver information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine NUOPC_DriverPrint(driver, orderflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     logical,             intent(in),  optional :: orderflag
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print internal Driver information. If <TT>orderflag</TT> is provided and set
   to <TT>.true.</TT>, the output is ordered from lowest to highest PET. Setting 
   this flag makes the method collective. 

<P>

<P>

<H3><A NAME="SECTION000411600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_DriverSetRunSequence - Set internals of RunSequence slot</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverSetRunSequence()
   recursive subroutine NUOPC_DriverSetRunSequence(driver, slot, clock, alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     type(ESMF_Clock),    intent(in)            :: clock
     type(ESMF_Alarm),    intent(in),  optional :: alarm
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the <TT>clock</TT> in the run sequence under <TT>slot</TT> of the Driver.


<H2><A NAME="SECTION00042000000000000000"></A>
<A NAME="NUOPC_ModelBase"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Generic Component: NUOPC_ModelBase
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<I CLASS="sans">MODULE:</I>
<PRE>  module NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Partial specialization of a component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called the component steps one timeStep forward on the passed in parent
clock. The component flags incompatibility during <TT>Run</TT> if the current time of the incoming
clock does not match the current time of the internal clock.

<P>

<P><P>
<BR>
<I CLASS="sans">SUPER:</I>
<PRE>  ESMF_GridComp
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SETSERVICES:</I>
<PRE>  subroutine SetServices(modelBase, rc)
    type(ESMF_GridComp)   :: modelBase
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SEMANTIC SPECIALIZATION LABELS:</I>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_Advertise</B>
    
<UL>
<LI>Required in order to advertise fields.
</LI>
<LI>Use <TT>NUOPC_Advertise()</TT> to advertise specific fields in the Import- and ExportState of the component.
</LI>
<LI>Alternatively set the FieldTransferPolicy attribute on the Import- and ExportState of the component to request field mirroring.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyAdvertised</B>
    
<UL>
<LI>Optional. By default do not modify the advertised fields.
</LI>
<LI>Mostly used when field mirroring was requested during Advertise.
</LI>
<LI>Remove undesired advertised fields in the Import- and ExportState of the component.
</LI>
<LI>Adjust attributes e.g. for TransferOffer on advertised fields.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeProvided</B>
    
<UL>
<LI>Required in order to realize fields.
</LI>
<LI>Use <TT>NUOPC_Realize()</TT> to realize fields previously advertised, and for which this component is responsible for providing the Field allocation and/or the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_AcceptTransfer</B>
    
<UL>
<LI>Optional. By default accept the Distribution of the transferred GeomObjects.
</LI>
<LI>Change the distribution of any of the transferred GeomObjects.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeAccepted</B>
    
<UL>
<LI>Optional. Needed for any fields for which component is accepting the GeomObject.
</LI>
<LI>Use <TT>NUOPC_Realize()</TT> to realize fields previously advertised, and for which this component is accepting the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_SetClock</B>
    
<UL>
<LI>Optional. By default create clock according to time information provided by driver.
</LI>
<LI>Adjust and set the component clock.
    
</LI>
</UL>
</LI>
<LI><B>label_DataInitialize</B>
    
<UL>
<LI>Optional. Needed to initialize data, and to participate in resolution of data dependencies between components during initialize.
</LI>
<LI>Initialize data in fields.
</LI>
<LI>Set NUOPC attributes used for data dependency resolution.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_Advance</B>
    
<UL>
<LI>Called every timeStep on the component internal clock.
</LI>
<LI>Implement the forward integration of the model.
</LI>
<LI>Ensure data in the export fields is updated before returning.
    
</LI>
</UL>
</LI>
<LI><B>label_AdvanceClock</B>
    
<UL>
<LI>Optional. By default the component internal clock is advanced by one internal timeStep at the end of the Advance step.
    
</LI>
</UL>
</LI>
<LI><B>label_CheckImport</B>
    
<UL>
<LI>Optional. By default check the timestamp of all import fields against the current time of the internal clock.
    
</LI>
</UL>
</LI>
<LI><B>label_SetRunClock</B>
    
<UL>
<LI>Optional. By default do not adjust the internal clock when entering Run.
    
</LI>
</UL>
</LI>
<LI><B>label_TimestampExport</B>
    
<UL>
<LI>Optinal. By default timestamp all export fields according to the current time of the component internal clock before returning.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<H2><A NAME="SECTION00043000000000000000"></A>
<A NAME="NUOPC_Model"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Generic Component: NUOPC_Model
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<I CLASS="sans">MODULE:</I>
<PRE>  module NUOPC_Model
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Model component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called the model integrates one timeStep forward on the passed in parent clock. The internal clock is advanced at the end of each <TT>Run</TT> call. The component flags incompatibility during <TT>Run</TT> if the current time of the incoming clock does not match the current time of the internal clock.

<P>

<P><P>
<BR>
<I CLASS="sans">SUPER:</I>
<PRE>  NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SETSERVICES:</I>
<PRE>  subroutine SetServices(model, rc)
    type(ESMF_GridComp)   :: model
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SEMANTIC SPECIALIZATION LABELS:</I>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_Advertise</B>
    
<UL>
<LI>Required in order to advertise fields.
</LI>
<LI>Use <TT>NUOPC_Advertise()</TT> to advertise specific fields in the Import- and ExportState of the component.
</LI>
<LI>Alternatively set the FieldTransferPolicy attribute on the Import- and ExportState of the component to request field mirroring.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyAdvertised</B>
    
<UL>
<LI>Optional. By default do not modify the advertised fields.
</LI>
<LI>Mostly used when field mirroring was requested during Advertise.
</LI>
<LI>Remove undesired advertised fields in the Import- and ExportState of the component.
</LI>
<LI>Adjust attributes e.g. for TransferOffer on advertised fields.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeProvided</B>
    
<UL>
<LI>Required in order to realize fields.
</LI>
<LI>Use <TT>NUOPC_Realize()</TT> to realize fields previously advertised, and for which this component is responsible for providing the Field allocation and/or the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_AcceptTransfer</B>
    
<UL>
<LI>Optional. By default accept the Distribution of the transferred GeomObjects.
</LI>
<LI>Change the distribution of any of the transferred GeomObjects.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeAccepted</B>
    
<UL>
<LI>Optional. Needed for any fields for which component is accepting the GeomObject.
</LI>
<LI>Use <TT>NUOPC_Realize()</TT> to realize fields previously advertised, and for which this component is accepting the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_SetClock</B>
    
<UL>
<LI>Optional. By default create clock according to time information provided by driver.
</LI>
<LI>Adjust and set the component clock.
    
</LI>
</UL>
</LI>
<LI><B>label_DataInitialize</B>
    
<UL>
<LI>Optional. Needed to initialize data, and to participate in resolution of data dependencies between components during initialize.
</LI>
<LI>Initialize data in fields.
</LI>
<LI>Set NUOPC attributes used for data dependency resolution.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_Advance</B>
    
<UL>
<LI>Called every timeStep on the component internal clock.
</LI>
<LI>Implement the forward integration of the model.
</LI>
<LI>Ensure data in the export fields is updated before returning.
    
</LI>
</UL>
</LI>
<LI><B>label_AdvanceClock</B>
    
<UL>
<LI>Optional. By default the component internal clock is advanced by one internal timeStep at the end of the Advance step.
    
</LI>
</UL>
</LI>
<LI><B>label_CheckImport</B>
    
<UL>
<LI>Optional. By default check the timestamp of all import fields against the current time of the internal clock.
    
</LI>
</UL>
</LI>
<LI><B>label_SetRunClock</B>
    
<UL>
<LI>Optional. By default do not adjust the internal clock when entering Run.
    
</LI>
</UL>
</LI>
<LI><B>label_TimestampExport</B>
    
<UL>
<LI>Optinal. By default timestamp all export fields according to the current time of the component internal clock before returning.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00043100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_ModelGet - Get info from a Model</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_ModelGet(model, driverClock, modelClock, &amp;
     importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: model
     type(ESMF_Clock),    intent(out), optional :: driverClock
     type(ESMF_Clock),    intent(out), optional :: modelClock
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access Model information.


<H2><A NAME="SECTION00044000000000000000"></A>
<A NAME="NUOPC_Mediator"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Generic Component: NUOPC_Mediator
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<I CLASS="sans">MODULE:</I>
<PRE>  module NUOPC_Mediator
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Mediator component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called, the time stamp on the imported Fields must match the current time (on both the incoming and internal clock). Before returning, the Mediator time stamps the exported Fields with the same current time, before advancing the internal clock one timeStep forward.

<P>

<P><P>
<BR>
<I CLASS="sans">SUPER:</I>
<PRE>  NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SETSERVICES:</I>
<PRE>  subroutine SetServices(mediator, rc)
    type(ESMF_GridComp)   :: mediator
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SEMANTIC SPECIALIZATION LABELS:</I>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_Advertise</B>
    
<UL>
<LI>Required in order to advertise fields.
</LI>
<LI>Use <TT>NUOPC_Advertise()</TT> to advertise specific fields in the Import- and ExportState of the component.
</LI>
<LI>Alternatively set the FieldTransferPolicy attribute on the Import- and ExportState of the component to request field mirroring.
    
</LI>
</UL>
</LI>
<LI><B>label_ModifyAdvertised</B>
    
<UL>
<LI>Optional. By default do not modify the advertised fields.
</LI>
<LI>Mostly used when field mirroring was requested during Advertise.
</LI>
<LI>Remove undesired advertised fields in the Import- and ExportState of the component.
</LI>
<LI>Adjust attributes e.g. for TransferOffer on advertised fields.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeProvided</B>
    
<UL>
<LI>Required in order to realize fields.
</LI>
<LI>Use <TT>NUOPC_Realize()</TT> to realize fields previously advertised, and for which this component is responsible for providing the Field allocation and/or the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_AcceptTransfer</B>
    
<UL>
<LI>Optional. By default accept the Distribution of the transferred GeomObjects.
</LI>
<LI>Change the distribution of any of the transferred GeomObjects.
    
</LI>
</UL>
</LI>
<LI><B>label_RealizeAccepted</B>
    
<UL>
<LI>Optional. Needed for any fields for which component is accepting the GeomObject.
</LI>
<LI>Use <TT>NUOPC_Realize()</TT> to realize fields previously advertised, and for which this component is accepting the GeomObject.
    
</LI>
</UL>
</LI>
<LI><B>label_SetClock</B>
    
<UL>
<LI>Optional. By default create clock according to time information provided by driver.
</LI>
<LI>Adjust and set the component clock.
    
</LI>
</UL>
</LI>
<LI><B>label_DataInitialize</B>
    
<UL>
<LI>Optional. Needed to initialize data, and to participate in resolution of data dependencies between components during initialize.
</LI>
<LI>Initialize data in fields.
</LI>
<LI>Set NUOPC attributes used for data dependency resolution.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_Advance</B>
    
<UL>
<LI>Called every timeStep on the component internal clock.
</LI>
<LI>Implement the forward integration of the model.
</LI>
<LI>Ensure data in the export fields is updated before returning.
    
</LI>
</UL>
</LI>
<LI><B>label_AdvanceClock</B>
    
<UL>
<LI>Optional. By default the component internal clock is advanced by one internal timeStep at the end of the Advance step.
    
</LI>
</UL>
</LI>
<LI><B>label_CheckImport</B>
    
<UL>
<LI>Optional. By default check the timestamp of all import fields against the current time of the internal clock.
    
</LI>
</UL>
</LI>
<LI><B>label_SetRunClock</B>
    
<UL>
<LI>Optional. By default do not adjust the internal clock when entering Run.
    
</LI>
</UL>
</LI>
<LI><B>label_TimestampExport</B>
    
<UL>
<LI>Optinal. By default timestamp all export fields according to the current time of the component internal clock before returning.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00044100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_MediatorGet - Get info from a Mediator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_MediatorGet(mediator, driverClock, mediatorClock, &amp;
     importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: mediator
     type(ESMF_Clock),    intent(out), optional :: driverClock
     type(ESMF_Clock),    intent(out), optional :: mediatorClock
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access Mediator information.


<H2><A NAME="SECTION00045000000000000000"></A>
<A NAME="NUOPC_Connector"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Generic Component: NUOPC_Connector
</H2>

<P>

<P>

<P>

<P><P>
<BR>
<I CLASS="sans">MODULE:</I>
<PRE>  module NUOPC_Connector
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Component that makes a unidirectional connection between model, mediator, and or driver components. During initialization field pairing is performed between the import and export side according to section <A HREF="node3.html#FieldPairing">2.4.2</A>, and paired fields are connected. By default the bilinear regrid method is used during <TT>Run</TT> to transfer data from the connected import Fields to the connected export Fields.

<P>

<P><P>
<BR>
<I CLASS="sans">SUPER:</I>
<PRE>  ESMF_CplComp
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SETSERVICES:</I>
<PRE>  subroutine SetServices(connector, rc)
    type(ESMF_CplComp)    :: connector
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I CLASS="sans">SEMANTIC SPECIALIZATION LABELS:</I>

<UL>
<LI>Initialize:
  
<UL>
<LI><B>label_ComputeRouteHandle</B>
    
<UL>
<LI>Optional. By default compute routehandles according to CplList attribute.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Run:
  
<UL>
<LI><B>label_ExecuteRouteHandle</B>
    
<UL>
<LI>Optional. By default execute routehandles stored in the Connector.
    
</LI>
</UL>
</LI>
</UL>
</LI>
<LI>Finalize:
  
<UL>
<LI><B>label_ReleaseRouteHandle</B>
    
<UL>
<LI>Optional. By default release routehandles stored in the Connector.
    
</LI>
</UL>
</LI>
<LI><B>label_Finalize</B>
    
<UL>
<LI>Optional. By default do nothing.
</LI>
<LI>Destroy any objects created during Initalize.
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00045100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_ConnectorGet - Get parameters from a Connector</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_ConnectorGet(connector, srcFields, dstFields, rh, state, &amp;
     CplSet, cplSetList, srcVM, dstVM, driverClock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: connector
     type(ESMF_FieldBundle), intent(out), optional :: srcFields
     type(ESMF_FieldBundle), intent(out), optional :: dstFields
     type(ESMF_RouteHandle), intent(out), optional :: rh
     type(ESMF_State),       intent(out), optional :: state
     character(*),           intent(in),  optional :: CplSet
     character(ESMF_MAXSTR), pointer,     optional :: cplSetList(:)
     type(ESMF_VM),          intent(out), optional :: srcVM
     type(ESMF_VM),          intent(out), optional :: dstVM
     type(ESMF_Clock),       intent(out), optional :: driverClock
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get parameters from the <TT>connector</TT> internal state.

<P>
The Connector keeps information about the connection that it implements 
     in its internal state. When customizing a Connector, it is often necessary
     to access and sometimes modify these data objects.

<P>
The arguments are:
     <DL>
<DT><STRONG>connector</STRONG></DT>
<DD>The Connector component.
     
</DD>
<DT><STRONG>[srcFields]</STRONG></DT>
<DD>The FieldBundle under which the Connector keeps track of all connected
       source side fields. The order in which the fields are stored
       in <TT>srcFields</TT> is significant, as it corresponds to the order of
       fields in <TT>dstFields</TT>. Consequently, when accessing and modifying
       the fields inside of <TT>srcFields</TT>, it is important to use the
       <TT>itemorderflag=ESMF_ITEMORDER_ADDORDER</TT> option to
       <TT>ESMF_FieldBundleGet()</TT>.
     
</DD>
<DT><STRONG>[dstFields]</STRONG></DT>
<DD>The FieldBundle under which the Connector keeps track of all connected
       destination side fields. The order in which the fields are stored
       in <TT>dstFields</TT> is significant, as it corresponds to the order of
       fields in <TT>srcFields</TT>. Consequently, when accessing and modifying
       the fields inside of <TT>dstFields</TT>, it is important to use the
       <TT>itemorderflag=ESMF_ITEMORDER_ADDORDER</TT> option to
       <TT>ESMF_FieldBundleGet()</TT>.
     
</DD>
<DT><STRONG>[rh]</STRONG></DT>
<DD>The RouteHandle that the Connector uses to move data from <TT>srcFields</TT>
       to <TT>dstFields</TT>.
     
</DD>
<DT><STRONG>[state]</STRONG></DT>
<DD>A State object that the Connector keeps to make customization of the 
       Connector more convenient. The generic Connector code handles creation
       and destruction of <TT>state</TT>, but does <EM>not</EM> access it directly 
       for information.
     
</DD>
<DT><STRONG>[CplSet]</STRONG></DT>
<DD>If present, all of the returned information is specific to the specified
       coupling set.
     
</DD>
<DT><STRONG>[cplSetList]</STRONG></DT>
<DD>The list of coupling sets currently known to the Connector. This argument
       must enter the call <EM>unassociated</EM> or an error is returned. This means
       that the user code must explicitly call <TT>nullify()</TT> or use the
       <TT>=&gt; null()</TT> syntax on the variable passed in as <TT>cplSetList</TT>
       argument. On return, the <TT>cplSetList</TT> argument will be associated, 
       potentially of size zero. The responsibility for deallocation transfers
       to the caller.
     
</DD>
<DT><STRONG>[srcVM]</STRONG></DT>
<DD>The VM of the source side component.
     
</DD>
<DT><STRONG>[dstVM]</STRONG></DT>
<DD>The VM of the destination side component.
     
</DD>
<DT><STRONG>[driverClock]</STRONG></DT>
<DD>The Clock object used by the current RunSequence level to drive this
       component.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00045200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_ConnectorSet - Set parameters in a Connector</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_ConnectorSet(connector, srcFields, dstFields, rh, state, &amp;
     CplSet, srcVM, dstVM, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: connector
     type(ESMF_FieldBundle), intent(in),  optional :: srcFields
     type(ESMF_FieldBundle), intent(in),  optional :: dstFields
     type(ESMF_RouteHandle), intent(in),  optional :: rh
     type(ESMF_State),       intent(in),  optional :: state
     character(*),           intent(in),  optional :: CplSet
     type(ESMF_VM),          intent(in),  optional :: srcVM
     type(ESMF_VM),          intent(in),  optional :: dstVM
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set parameters in the <TT>connector</TT> internal state.

<P>
The Connector keeps information about the connection that it implements 
     in its internal state. When customizing a Connector, it is often necessary
     to access and sometimes modify these data objects.

<P>
The arguments are:
     <DL>
<DT><STRONG>connector</STRONG></DT>
<DD>The Connector component.
     
</DD>
<DT><STRONG>[srcFields]</STRONG></DT>
<DD>The FieldBundle under which the Connector keeps track of all connected
       source side fields. The order in which the fields are stored
       in <TT>srcFields</TT> is significant, as it corresponds to the order of
       fields in <TT>dstFields</TT>. Consequently, when setting <TT>srcFields</TT>, it
       is important to add them in the same order as for <TT>dstFields</TT>.
     
</DD>
<DT><STRONG>[dstFields]</STRONG></DT>
<DD>The FieldBundle under which the Connector keeps track of all connected
       destination side fields. The order in which the fields are stored
       in <TT>dstFields</TT> is significant, as it corresponds to the order of
       fields in <TT>srcFields</TT>. Consequently, when setting <TT>dstFields</TT>, it
       is important to add them in the same order as for <TT>srcFields</TT>.
     
</DD>
<DT><STRONG>[rh]</STRONG></DT>
<DD>The RouteHandle that the Connector uses to move data from <TT>srcFields</TT>
       to <TT>dstFields</TT>.
     
</DD>
<DT><STRONG>[state]</STRONG></DT>
<DD>A State object that the Connector keeps to make customization of the 
       Connector more convenient. Only in very rare cases would the user want
       to replace the <TT>state</TT> that is managed by the generic Connector
       implementation. If <TT>state</TT> is set by this call, the user essentially
       claims ownership of the previous <TT>state</TT> object, and becomes 
       responsible for its destruction. Ownership of the new <TT>state</TT> is 
       transferred to the Connector and must not be explicitly destroyed by the
       user code.
     
</DD>
<DT><STRONG>[CplSet]</STRONG></DT>
<DD>If present, all of the passed in information is set under the specified
       coupling set.
     
</DD>
<DT><STRONG>[srcVM]</STRONG></DT>
<DD>The VM of the source side component.
     
</DD>
<DT><STRONG>[dstVM]</STRONG></DT>
<DD>The VM of the destination side component.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H2><A NAME="SECTION00046000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> General Generic Component Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION00046100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_CompAreServicesSet - Check if SetServices was called</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAreServicesSet() 
   function NUOPC_GridCompAreServicesSet(comp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_GridCompAreServicesSet
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if SetServices has been called for <TT>comp</TT>. 
     Otherwise return <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION00046200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_CompAreServicesSet - Check if SetServices was called</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAreServicesSet() 
   function NUOPC_CplCompAreServicesSet(comp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_CplCompAreServicesSet
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: comp
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if SetServices has been called for <TT>comp</TT>.
     Otherwise return <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION00046300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_CompAttributeAdd - Add NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeAdd() 
   subroutine NUOPC_GridCompAttributeAdd(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add Attributes to the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A NAME="SECTION00046400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_CompAttributeAdd - Add NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeAdd() 
   subroutine NUOPC_CplCompAttributeAdd(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add Attributes to the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A NAME="SECTION00046500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_CompAttributeEgest - Egest NUOPC GridComp Attributes in FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeEgest() 
   subroutine NUOPC_GridCompAttributeEge(comp, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Egest the Attributes of the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance") as a FreeFormat object.
     It is the caller's responsibility to destroy the created <TT>freeFormat</TT>
     object. 

<P>

<P>

<H3><A NAME="SECTION00046600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_CompAttributeEgest - Egest NUOPC CplComp Attributes in FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeEgest() 
   subroutine NUOPC_CplCompAttributeEge(comp, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Egest the Attributes of the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance") as a FreeFormat object.
     It is the caller's responsibility to destroy the created <TT>freeFormat</TT>
     object. 

<P>

<P>

<H3><A NAME="SECTION00046700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGet(comp, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively. Attribute must be
     of type character string. See <A HREF="#NUOPC_GridCompAttributeIng">3.6.15</A> if attribute
     was added using NUOPC_CompAttributeIngest.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00046800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGet(comp, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively. Attribute must be
     of type character string. See <A HREF="#NUOPC_CplCompAttributeIng">3.6.16</A> if attribute
     was added using NUOPC_CompAttributeIngest.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00046900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetI(comp, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     integer,             intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively. Attribute must be
     of type integer. See <A HREF="#NUOPC_GridCompAttributeIng">3.6.15</A> if attribute was added
     using NUOPC_CompAttributeIngest.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000461000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetI(comp, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     character(*),        intent(in)            :: name
     integer,             intent(out)           :: value
     logical,             intent(out), optional :: isPresent
     logical,             intent(out), optional :: isSet
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively. Attribute must be
     of type integer. See <A HREF="#NUOPC_CplCompAttributeIng">3.6.16</A> if attribute was added
     using NUOPC_CompAttributeIngest.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000461100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetSL(comp, name, valueList, isPresent, &amp;
     isSet, itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),       intent(in)            :: comp
     character(*),              intent(in)            :: name
     character(*),              intent(out), optional :: valueList(:)
     logical,                   intent(out), optional :: isPresent
     logical,                   intent(out), optional :: isSet
     integer,                   intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag),  intent(out), optional :: typekind
     integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively. Attribute must be
     of type character string. See <A HREF="#NUOPC_GridCompAttributeIng">3.6.15</A> if attribute
     was added using NUOPC_CompAttributeIngest.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>[valueList]</STRONG></DT>
<DD>The list of values of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000461200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetSL(comp, name, valueList, isPresent, &amp;
     isSet, itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),       intent(in)            :: comp
     character(*),             intent(in)            :: name
     character(*),             intent(out), optional :: valueList(:)
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively. Attribute must be
     of type character string. See <A HREF="#NUOPC_CplCompAttributeIng">3.6.16</A> if attribute
     was added using NUOPC_CompAttributeIngest.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>[valueList]</STRONG></DT>
<DD>The list of values of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000461300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetIL(comp, name, valueList, isPresent, &amp;
     isSet, itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),       intent(in)            :: comp
     character(*),              intent(in)            :: name
     integer,                   intent(out)           :: valueList(:)
     logical,                   intent(out), optional :: isPresent
     logical,                   intent(out), optional :: isSet
     integer,                   intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag),  intent(out), optional :: typekind
     integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively. Attribute must be
     of type integer. See <A HREF="#NUOPC_GridCompAttributeIng">3.6.15</A> if attribute was added
     using NUOPC_CompAttributeIngest.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>valueList</STRONG></DT>
<DD>The list of values of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000461400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetIL(comp, name, valueList, isPresent, &amp;
     isSet, itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),       intent(in)            :: comp
     character(*),             intent(in)            :: name
     integer,                  intent(out)           :: valueList(:)
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively. Attribute must be
     of type integer. See <A HREF="#NUOPC_CplCompAttributeIng">3.6.16</A> if attribute was added
     using NUOPC_CompAttributeIngest.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>valueList</STRONG></DT>
<DD>The list of values of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000461500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_CompAttributeIngest - Ingest free format NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_GridCompAttributeIng(comp, freeFormat, addFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     logical,                intent(in),  optional :: addFlag
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_GridCompAttributeIng"></A>     Ingest the Attributes from a FreeFormat object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance"). All Attributes are added as type character string.

<P>
If <TT>addFlag</TT> is <TT>.false.</TT> (default), an error will be returned if 
     an attribute is to be ingested that was not previously added to the 
     <TT>comp</TT> object. If <TT>addFlag</TT> is <TT>.true.</TT>, all missing attributes
     will be added by this method automatically as needed.

<P>
Each line in <TT>freeFormat</TT> is of this format:

<P>
<PRE>
       attributeName = attributeValue
</PRE>

<P>
For example:
     <PRE>
       Verbosity  = 0
       Profiling  = 0
       Diagnostic = 0
</PRE>
     could directly be ingested as Attributes for any instance of the four 
     standard NUOPC component kinds. This is because <TT>Verbosity</TT>,
     <TT>Profiling</TT>, and <TT>Diagnostic</TT> are pre-defined Attributes of the 
     NUOPC component kinds according to sections <A HREF="node3.html#DriverCompMeta">2.3.1</A>, 
     <A HREF="node3.html#ModelCompMeta">2.3.2</A>, <A HREF="node3.html#MediatorCompMeta">2.3.3</A>, and <A HREF="node3.html#ConnectorCompMeta">2.3.4</A>.

<P>
When Attributes are specified in <TT>freeFormat</TT> that are not pre-defined
     for a specific component kind, they can still be ingested by a component
     instance using the <TT>addFlag=.true.</TT> option. For instance:
     <PRE>
       ModelOutputChoice = 2
</PRE>
     specifies a user-level Attribute, which is not part of the pre-defined 
     Attributes of any of the standard NUOPC component kinds.

<P>

<P>

<H3><A NAME="SECTION000461600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_CompAttributeIngest - Ingest free format NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_CplCompAttributeIng(comp, freeFormat, addFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     logical,                intent(in),  optional :: addFlag
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_CplCompAttributeIng"></A>     Ingest the Attributes from a FreeFormat object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance"). All Attributes are added as type character string.

<P>
If <TT>addFlag</TT> is <TT>.false.</TT> (default), an error will be returned if 
     an attribute is to be ingested that was not previously added to the 
     <TT>comp</TT> object. If <TT>addFlag</TT> is <TT>.true.</TT>, all missing attributes
     will be added by this method automatically as needed.

<P>
Each line in <TT>freeFormat</TT> is of this format:

<P>
<PRE>
       attributeName = attributeValue
</PRE>

<P>
For example:
     <PRE>
       Verbosity  = 0
       Profiling  = 0
       Diagnostic = 0
</PRE>
     could directly be ingested as Attributes for any instance of the four 
     standard NUOPC component kinds. This is because <TT>Verbosity</TT>,
     <TT>Profiling</TT>, and <TT>Diagnostic</TT> are pre-defined Attributes of the 
     NUOPC component kinds according to sections <A HREF="node3.html#DriverCompMeta">2.3.1</A>, 
     <A HREF="node3.html#ModelCompMeta">2.3.2</A>, <A HREF="node3.html#MediatorCompMeta">2.3.3</A>, and <A HREF="node3.html#ConnectorCompMeta">2.3.4</A>.

<P>
When Attributes are specified in <TT>freeFormat</TT> that are not pre-defined
     for a specific component kind, they can still be ingested by a component
     instance using the <TT>addFlag=.true.</TT> option. For instance:
     <PRE>
       ModelOutputChoice = 2
</PRE>
     specifies a user-level Attribute, which is not part of the pre-defined 
     Attributes of any of the standard NUOPC component kinds.

<P>

<P>

<H3><A NAME="SECTION000461700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_CompAttributeReset - Reset NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeReset() 
   subroutine NUOPC_GridCompAttributeReset(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Reset Attributes on the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A NAME="SECTION000461800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> NUOPC_CompAttributeReset - Reset NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeReset() 
   subroutine NUOPC_CplCompAttributeReset(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Reset Attributes on the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A NAME="SECTION000461900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> NUOPC_CompAttributeSet - Set a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetS(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> NUOPC_CompAttributeSet - Set a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetS(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> NUOPC_CompAttributeSet - Set a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetI(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     integer,      intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> NUOPC_CompAttributeSet - Set a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetI(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     integer,      intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> NUOPC_CompAttributeSet - Set a NUOPC GridComp List Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetSL(comp, name, valueList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: valueList(:)
     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> NUOPC_CompAttributeSet - Set a NUOPC CplComp List Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetSL(comp, name, valueList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: valueList(:)
     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> NUOPC_CompCheckSetClock - Check Clock compatibility and set stopTime</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompCheckSetClock() 
   subroutine NUOPC_GridCompCheckSetClock(comp, externalClock, checkTimeStep, &amp;
     forceTimeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     logical,                 intent(in),  optional :: checkTimeStep
     logical,                 intent(in),  optional :: forceTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Compare <TT>externalClock</TT> to the internal clock of <TT>comp</TT> to make sure
     they match in their current time. Also ensure that the time step of the
     external clock is a multiple of the time step of the internal clock. If
     both conditions are satisfied then set the stop time of the internal clock
     so it is reached in one time step of the external clock. Otherwise leave the
     internal clock unchanged and return with error. The direction of
     the involved clocks is taking into account.
     Setting the <TT>forceTimeStep</TT> argument to <TT>.true.</TT> forces the
     <TT>timeStep</TT> of the <TT>externalClock</TT> to be used to reset the
     <TT>timeStep</TT> of the internal clock. 

<P>

<P>

<H3><A NAME="SECTION000462600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> NUOPC_CompDerive - Derive a GridComp from a generic component</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompDerive() 
   recursive subroutine NUOPC_GridCompDerive(comp, genericSetServicesRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     interface
       subroutine genericSetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Derive a GridComp (i.e. Model, Mediator, or Driver) from a generic 
     component by calling into the specified <TT>SetServices()</TT> routine of the
     generic component. This is typically the first call in the
     <TT>SetServices()</TT> routine of the specializing component, and is followed
     by <TT>NUOPC_CompSpecialize()</TT> calls. 

<P>

<P>

<H3><A NAME="SECTION000462700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> NUOPC_CompDerive - Derive a CplComp from a generic component</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompDerive() 
   recursive subroutine NUOPC_CplCompDerive(comp, genericSetServicesRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     interface
       subroutine genericSetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Derive a CplComp (i.e. Connector) from a generic
     component by calling into the specified <TT>SetServices()</TT> routine of the
     generic component. This is typically the first call in the
     <TT>SetServices()</TT> routine of the specializing component, and is followed
     by <TT>NUOPC_CompSpecialize()</TT> calls. 

<P>

<P>

<H3><A NAME="SECTION000462800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> NUOPC_CompFilterPhaseMap - Filter the Phase Map of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompFilterPhaseMap()
   subroutine NUOPC_GridCompFilterPhaseMap(comp, methodflag, acceptStringList, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in)            :: acceptStringList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Filter all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   that do <EM>not</EM> match any entry in the <TT>acceptStringList</TT>. 

<P>

<P>

<H3><A NAME="SECTION000462900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> NUOPC_CompFilterPhaseMap - Filter the Phase Map of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompFilterPhaseMap()
   subroutine NUOPC_CplCompFilterPhaseMap(comp, methodflag, acceptStringList, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in)            :: acceptStringList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Filter all PhaseMap entries in a CplComp (i.e. Connector)
   that do <EM>not</EM> match any entry in the <TT>acceptStringList</TT>. 

<P>

<P>

<H3><A NAME="SECTION000463000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> NUOPC_CompGet - Access info from GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompGet()
   subroutine NUOPC_GridCompGet(comp, name, verbosity, profiling, diagnostic, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(out), optional :: name
     integer,            intent(out), optional :: verbosity
     integer,            intent(out), optional :: profiling
     integer,            intent(out), optional :: diagnostic
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access information from a GridComp. 

<P>

<P>

<H3><A NAME="SECTION000463100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> NUOPC_CompGet - Access info from CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompGet()
   subroutine NUOPC_CplCompGet(comp, name, verbosity, profiling, diagnostic, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(out), optional :: name
     integer,            intent(out), optional :: verbosity
     integer,            intent(out), optional :: profiling
     integer,            intent(out), optional :: diagnostic
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access information from a CplComp. 

<P>

<P>

<H3><A NAME="SECTION000463200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> NUOPC_CompSearchPhaseMap - Search the Phase Map of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSearchPhaseMap()
   subroutine NUOPC_GridCompSearchPhaseMap(comp, methodflag, internalflag, &amp;
     phaseLabel, phaseIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     logical,                intent(in),  optional :: internalflag
     character(len=*),       intent(in),  optional :: phaseLabel
     integer,                intent(out)           :: phaseIndex
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Search all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   to see if <TT>phaseLabel</TT> is found. Return the associated ESMF
   <TT>phaseIndex</TT>, or <TT>-1</TT> if not found. If <TT>phaseLabel</TT> is not
   specified, set <TT>phaseIndex</TT> to the first entry in the PhaseMap, or 
   <TT>-1</TT> if there are no entries. The <TT>internalflag</TT> argument 
   allows to search the internal phase maps of driver components. The default
   is <TT>internalflag=.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION000463300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> NUOPC_CompSearchPhaseMap - Search the Phase Map of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSearchPhaseMap()
   subroutine NUOPC_CplCompSearchPhaseMap(comp, methodflag, phaseLabel, &amp;
     phaseIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in),  optional :: phaseLabel
     integer,                intent(out)           :: phaseIndex
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Search all PhaseMap entries in a CplComp (i.e. Connector)
   to see if <TT>phaseLabel</TT> is found. Return the associated ESMF
   <TT>phaseIndex</TT>, or <TT>-1</TT> if not found. If <TT>phaseLabel</TT> is not
   specified, set <TT>phaseIndex</TT> to the first entry in the PhaseMap, or 
   <TT>-1</TT> if there are no entries. 

<P>

<P>

<H3><A NAME="SECTION000463400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> NUOPC_CompSearchRevPhaseMap - Reverse Search the Phase Map of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSearchRevPhaseMap()
   subroutine NUOPC_GridCompSearchRevPhaseMap(comp, methodflag, internalflag, &amp;
     phaseIndex, phaseLabel, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     logical,                intent(in),  optional :: internalflag
     integer,                intent(in),  optional :: phaseIndex
     character(len=*),       intent(out)           :: phaseLabel
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Search all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   to see if the ESMF <TT>phaseIndex</TT> is found. Return the associated
   <TT>phaseLabel</TT>, or an empty string if not found. If <TT>phaseIndex</TT> is not
   specified, set <TT>phaseLabel</TT> to the first entry in the PhaseMap, or 
   an empty string if there are no entries. The <TT>internalflag</TT> argument 
   allows to search the internal phase maps of driver components. The default
   is <TT>internalflag=.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION000463500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> NUOPC_CompSearchRevPhaseMap - Reverse Search the Phase Map of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSearchRevPhaseMap()
   subroutine NUOPC_CplCompSearchRevPhaseMap(comp, methodflag, phaseIndex, &amp;
     phaseLabel, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     integer,                intent(in),  optional :: phaseIndex
     character(len=*),       intent(out)           :: phaseLabel
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Search all PhaseMap entries in a CplComp (i.e. Connector)
   to see if the ESMF <TT>phaseIndex</TT> is found. Return the associated
   <TT>phaseLabel</TT>, or an empty string if not found. If <TT>phaseIndex</TT> is not
   specified, set <TT>phaseLabel</TT> to the first entry in the PhaseMap, or 
   an empty string if there are no entries. 

<P>

<P>

<H3><A NAME="SECTION000463600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> NUOPC_CompSetClock - Initialize and set the internal Clock of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetClock()
   subroutine NUOPC_GridCompSetClock(comp, externalClock, stabilityTimeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     type(ESMF_TimeInterval), intent(in),  optional :: stabilityTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_GridCompSetClock"></A>
<P>
Set the component internal clock as a copy of <TT>externalClock</TT>, but
     with a timeStep that is less than or equal to the stabilityTimeStep.
     At the same time ensure that the timeStep of the external clock is
     a multiple of the timeStep of the internal clock. If the stabilityTimeStep
     argument is not provided then the internal clock will simply be set
     as a copy of the external clock. 

<P>

<P>

<H3><A NAME="SECTION000463700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> NUOPC_CompSetEntryPoint - Set entry point for a GridComp (DEPRECATED!)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetEntryPoint()
   subroutine NUOPC_GridCompSetEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set an entry point for a GridComp (i.e. Model, Mediator, or Driver). Publish
   the new entry point in the correct <TT>PhaseMap</TT> component attribute.

<P>
Starting with version 8.1.0, the use of this method is deprecated. Components
   should instead specialize exclusively using the <TT>NUOPC_CompSpecialize()</TT>
   method. 

<P>

<P>

<H3><A NAME="SECTION000463800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> NUOPC_CompSetEntryPoint - Set entry point for a CplComp (DEPRECATED!)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetEntryPoint()
   subroutine NUOPC_CplCompSetEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(cplcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set an entry point for a CplComp (i.e. Connector). Publish
   the new entry point in the correct <TT>PhaseMap</TT> component attribute.

<P>
Starting with version 8.1.0, the use of this method is deprecated. Components
   should instead specialize exclusively using the <TT>NUOPC_CompSpecialize()</TT>
   method. 

<P>

<P>

<H3><A NAME="SECTION000463900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> NUOPC_CompSetInternalEntryPoint - Set internal entry point for a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetInternalEntryPoint()
   subroutine NUOPC_GridCompSetIntEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set an <EM>internal</EM> entry point for a GridComp (i.e. Driver). Only Drivers 
   currently utilize internal entry points. Internal entry points allow user
   specialization on the driver level during initialization and run sequencing. 

<P>

<P>

<H3><A NAME="SECTION000464000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> NUOPC_CompSetServices - Try to find and call SetServices in a shared object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetServices()
   recursive subroutine NUOPC_GridCompSetServices(comp, sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     character(len=*),        intent(in),  optional :: sharedObj
     integer,                 intent(out), optional :: userRc
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Try to find a routine called "<TT>SetServices</TT>" in the <TT>sharedObj</TT> file
     and execute the routine. An attempt is made to find a routine that
     is close in name to "<TT>SetServices</TT>", allowing for compiler name
     mangling, i.e. upper and lower case, as well as trailing underscores. 

<P>

<P>

<H3><A NAME="SECTION000464100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> NUOPC_CompSpecialize - Specialize a derived GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSpecialize()
   subroutine NUOPC_GridCompSpecialize(comp, specLabel, specPhaseLabel, &amp;
     specRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     character(len=*), intent(in)            :: specLabel
     character(len=*), intent(in),  optional :: specPhaseLabel
     interface
       subroutine specRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Specialize a derived GridComp (i.e. Model, Mediator, or Driver). If
   <TT>specPhaseLabel</TT> is specified, the specialization only applies to
   the associated phase. Otherwise the specialization applies to all phases. 

<P>

<P>

<H3><A NAME="SECTION000464200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> NUOPC_CompSpecialize - Specialize a derived CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSpecialize()
   subroutine NUOPC_CplCompSpecialize(comp, specLabel, specPhaseLabel, &amp;
     specRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: comp
     character(len=*), intent(in)            :: specLabel
     character(len=*), intent(in),  optional :: specPhaseLabel
     interface
       subroutine specRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Specialize a derived CplComp (i.e. Connector). If
   <TT>specPhaseLabel</TT> is specified, the specialization only applies to
   the associated phase. Otherwise the specialization applies to all phases.


<H2><A NAME="SECTION00047000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Field Dictionary Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION00047100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_FieldDictionaryAddEntry - Add an entry to the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionaryAddEntry(standardName, canonicalUnits, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     character(*),                 intent(in)            :: canonicalUnits
     integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add an entry to the NUOPC Field dictionary. If necessary the dictionary is
     first set up. 

<P>

<P>

<H3><A NAME="SECTION00047200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_FieldDictionaryEgest - Egest NUOPC Field dictionary into FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionaryEgest(freeFormat, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     type(ESMF_IOFmt_Flag),  intent(in),  optional :: iofmt
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Egest the contents of the NUOPC Field dictionary into a FreeFormat object.
     If I/O format option <TT>iofmt</TT> is provided and equal to <TT>ESMF_IOFMT_YAML</TT>,
     the FreeFormat object will contain the NUOPC Field dictionary expressed in YAML
     format. Other values for <TT>iofmt</TT> are ignored and this method behaves as if
     the optional <TT>iofmt</TT> argument were missing. In such a case, <TT>freeFormat</TT>
     will contain NUOPC Field dictionary entries in the traditional format.
     It is the caller's responsibility to destroy the created <TT>freeFormat</TT>
     object. 

<P>

<P>

<H3><A NAME="SECTION00047300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_FieldDictionaryGetEntry - Get information about a NUOPC Field dictionary entry</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionaryGetEntry(standardName, canonicalUnits, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     character(*),                 intent(out), optional :: canonicalUnits
     integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the canonical units that the NUOPC Field dictionary associates with
     the <TT>standardName</TT>. 

<P>

<P>

<H3><A NAME="SECTION00047400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_FieldDictionaryHasEntry - Check whether the NUOPC Field dictionary has a specific entry</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function NUOPC_FieldDictionaryHasEntry(standardName, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_FieldDictionaryHasEntry
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the NUOPC Field dictionary has an entry with the
     specified <TT>standardName</TT>, <TT>.false.</TT> otherwise. 

<P>

<P>

<H3><A NAME="SECTION00047500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_FieldDictionaryMatchSyno - Check whether the NUOPC Field dictionary considers the standard names synonyms</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function NUOPC_FieldDictionaryMatchSyno(standardName1, standardName2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_FieldDictionaryMatchSyno
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName1
     character(*),                 intent(in)            :: standardName2
     integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the NUOPC Field dictionary considers
     <TT>standardName1</TT> and <TT>standardName2</TT> synonyms, <TT>.false.</TT> 
     otherwise. Also, if <TT>standardName1</TT> and/or <TT>standardName2</TT> do not 
     correspond to an existing dictionary entry, .false. will be returned. 

<P>

<P>

<H3><A NAME="SECTION00047600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_FieldDictionarySetSyno - Set synonyms in the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionarySetSyno(standardNames, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardNames(:)
     integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set all of the elements of the <TT>standardNames</TT> argument to be considered
     synonyms by the field dictionary. Every element in <TT>standardNames</TT> must
     correspond to the standard name of already existing entries in the field 
     dictionary, or else an error will be returned. 

<P>

<P>

<H3><A NAME="SECTION00047700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_FieldDictionarySetup - Setup the default NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_FieldDictionarySetup()
   subroutine NUOPC_FieldDictionarySetupDefault(rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Setup the default NUOPC Field dictionary. 

<P>

<P>

<H3><A NAME="SECTION00047800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_FieldDictionarySetup - Setup the NUOPC Field dictionary from file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_FieldDictionarySetup()
   subroutine NUOPC_FieldDictionarySetupFile(fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),      intent(in)              :: fileName
     integer,               intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Setup the NUOPC Field dictionary by reading its content from YAML file.
     If the NUOPC Field dictionary already exists, remove it and create a new one.
     This feature requires ESMF built with YAML support. Please see the
     ESMF User's Guide for details.


<H2><A NAME="SECTION00048000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Free Format Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION00048100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_FreeFormatAdd - Add lines to a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatAdd(freeFormat, stringList, line, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(inout) :: freeFormat
     character(len=*),                 intent(in)    :: stringList(:)
     integer,                optional, intent(in)    :: line
     integer,                optional, intent(out)   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add lines to a FreeFormat object. The capacity of <TT>freeFormat</TT> may 
     increase during this operation. The new lines provided in <TT>stringList</TT>
     are added starting at position <TT>line</TT>. If <TT>line</TT> is greater than the
     current <TT>lineCount</TT> of <TT>freeFormat</TT>, blank lines are inserted to
     fill the gap. By default, i.e. without specifying the <TT>line</TT> argument,
     the elements in <TT>stringList</TT> are added to the <EM>end</EM> of the
     <TT>freeFormat</TT> object. 

<P>

<P>

<H3><A NAME="SECTION00048200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_FreeFormatCreate - Create a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_FreeFormatCreate()
   function NUOPC_FreeFormatCreateDefault(freeFormat, stringList, capacity, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(NUOPC_FreeFormat) :: NUOPC_FreeFormatCreateDefault
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat), optional, intent(in)  :: freeFormat
     character(len=*),       optional, intent(in)  :: stringList(:)
     integer,                optional, intent(in)  :: capacity
     integer,                optional, intent(out) :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new FreeFormat object, which by default is empty. 
     If <TT>freeFormat</TT> is provided, then the newly created object starts as
     a copy of <TT>freeFormat</TT>. If <TT>stringList</TT> is provided, then it is
     added to the end of the newly created object. If <TT>capacity</TT> is provided,
     it is used for the <EM>initial</EM> creation of the newly created FreeFormat 
     object. However, if the <TT>freeFormat</TT> or <TT>stringList</TT> arguments are
     present, the final capacity may be larger than specified by <TT>capacity</TT>. 

<P>

<P>

<H3><A NAME="SECTION00048300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_FreeFormatCreate - Create a FreeFormat object from Config</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_FreeFormatCreate()
   function NUOPC_FreeFormatCreateRead(config, label, relaxedflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(NUOPC_FreeFormat) :: NUOPC_FreeFormatCreateRead
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config)                            :: config
     character(len=*),      intent(in)            :: label
     logical,               intent(in),  optional :: relaxedflag
     integer,               intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new FreeFormat object from ESMF_Config object. The <TT>config</TT>
     object must exist, and <TT>label</TT> must reference either a single line
     or a table attribute within <TT>config</TT>. The content of the attribute is
     read and returned in the newly created FreeFormat object.

<P>
By default an error is returned if <TT>label</TT> is not found in <TT>config</TT>.
   This error can be suppressed by setting <TT>relaxedflag=.true.</TT>, in which
   case an empty FreeFormat object is returned.

<P>

<P>

<H3><A NAME="SECTION00048400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_FreeFormatDestroy - Destroy a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatDestroy(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(inout) :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy a FreeFormat object. All internal memory is deallocated. 

<P>

<P>

<H3><A NAME="SECTION00048500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_FreeFormatGet - Get information from a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatGet(freeFormat, lineCount, capacity, stringList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),                       intent(in)  :: freeFormat
     integer,                            optional, intent(out) :: lineCount
     integer,                            optional, intent(out) :: capacity
     character(len=NUOPC_FreeFormatLen), optional, pointer     :: stringList(:)
     integer,                            optional, intent(out) :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get information from a FreeFormat object. 

<P>

<P>

<H3><A NAME="SECTION00048600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_FreeFormatGetLine - Get line info from a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatGetLine(freeFormat, line, lineString, tokenCount, &amp;
     tokenList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),                       intent(in)  :: freeFormat
     integer,                                      intent(in)  :: line
     character(len=NUOPC_FreeFormatLen), optional, intent(out) :: lineString
     integer,                            optional, intent(out) :: tokenCount
     character(len=NUOPC_FreeFormatLen), optional, intent(out) :: tokenList(:)
     integer,                            optional, intent(out) :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get information about a specific line in a FreeFormat object. 

<P>

<P>

<H3><A NAME="SECTION00048700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_FreeFormatLog - Write a FreeFormat object to the default Log</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatLog(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(in)    :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write a FreeFormat object to the default Log. 

<P>

<P>

<H3><A NAME="SECTION00048800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_FreeFormatPrint - Print a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatPrint(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(in)    :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print a FreeFormat object.


<H2><A NAME="SECTION00049000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Utility Routines</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION00049100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_AddNamespace - Add a nested state with Namespace to a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_AddNamespace(state, Namespace, nestedStateName, &amp;
     nestedState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(len=*), intent(in)            :: Namespace
     character(len=*), intent(in),  optional :: nestedStateName
     type(ESMF_State), intent(out), optional :: nestedState
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add a Namespace to <TT>state</TT>. Namespaces are implemented via nested 
     states. This creates a nested state inside of <TT>state</TT>. The nested state
     is returned as <TT>nestedState</TT>. If provided, <TT>nestedStateName</TT> will 
     be used to name the newly created nested state. The default name of the 
     nested state is equal to <TT>Namespace</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to which the Namespace is added.
     
</DD>
<DT><STRONG>Namespace</STRONG></DT>
<DD>The Namespace string.
     
</DD>
<DT><STRONG>[nestedStateName]</STRONG></DT>
<DD>Name of the nested state. Defaults to <TT>Namespace</TT>.
     
</DD>
<DT><STRONG>[nestedState]</STRONG></DT>
<DD>Optional return of the newly created nested state.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_AddNestedState - Add a nested state to a state with NUOPC attributes</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_AddNestedState(state, Namespace, CplSet, nestedStateName, &amp;
     vm, nestedState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(len=*), intent(in),  optional :: Namespace
     character(len=*), intent(in),  optional :: CplSet
     character(len=*), intent(in),  optional :: nestedStateName
     type(ESMF_VM),    intent(in),  optional :: vm
     type(ESMF_State), intent(out), optional :: nestedState
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a nested state inside of <TT>state</TT>. The arguments <TT>Namespace</TT>
     and tt CplSet are used to set NUOPC attributes on the newly created
     state. The nested state is returned as <TT>nestedState</TT>. If provided,
     <TT>nestedStateName</TT> will be used to name the newly created nested state.
     The default name of the nested state is equal to
     <TT>Namespace</TT>_<TT>CplSet</TT>, <TT>Namespace</TT>, or <TT>CplSet</TT> if the
     arguments are provided.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to which the namespace is added.
     
</DD>
<DT><STRONG>[Namespace]</STRONG></DT>
<DD>Optional The Namespace string. Defaults to "__UNSPECIFIED__".
     
</DD>
<DT><STRONG>[CplSet]</STRONG></DT>
<DD>Optional The CplSet string. Defaults to "__UNSPECIFIED__".
     
</DD>
<DT><STRONG>[nestedStateName]</STRONG></DT>
<DD>Name of the nested state. Defaults to <TT>Namespace</TT>_<TT>CplSet</TT>,
       <TT>Namespace</TT>, or <TT>CplSet</TT> if arguments are provided.
     
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the nested state object is created on the specified
       <TT>ESMF_VM</TT> object. The default is to create the nested state object
       on the VM of the current component context.
     
</DD>
<DT><STRONG>[nestedState]</STRONG></DT>
<DD>Optional return of the newly created nested state.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_Advertise - Advertise a single Field in a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Advertise() 
   subroutine NUOPC_AdvertiseField(state, StandardName, Units, &amp;
     LongName, ShortName, name, TransferOfferGeomObject, SharePolicyField, &amp;
     SharePolicyGeomObject, vm, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardName
     character(*),     intent(in),  optional :: Units
     character(*),     intent(in),  optional :: LongName
     character(*),     intent(in),  optional :: ShortName
     character(*),     intent(in),  optional :: name
     character(*),     intent(in),  optional :: TransferOfferGeomObject
     character(*),     intent(in),  optional :: SharePolicyField
     character(*),     intent(in),  optional :: SharePolicyGeomObject
     type(ESMF_VM),    intent(in),  optional :: vm
     type(ESMF_Field), intent(out), optional :: field
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_AdvertiseField"></A>     Advertise a field in a state. This creates an empty field and adds it to
     <TT>state</TT>. The "StandardName", "Units", "LongName", "ShortName", and 
     "TransferOfferGeomObject" attributes of the field are set according to the
     provided input..

<P>
The call checks the provided information against the NUOPC Field Dictionary
     to ensure correctness. Defaults are set according to the NUOPC Field 
     Dictionary.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object through which the field is advertised.
     
</DD>
<DT><STRONG>StandardName</STRONG></DT>
<DD>The "StandardName" attribute of the advertised field. Must be a 
       StandardName found in the NUOPC Field Dictionary.
<BR>
NOTE that if by below default rules, <TT>StandardName</TT> is also used as
       the input for <TT>name</TT>, then it must not contain the slash ("/")
       character.
     
</DD>
<DT><STRONG>[Units]</STRONG></DT>
<DD>The "Units" attribute of the advertised field. Must be convertible to the
       canonical units specified in the NUOPC Field Dictionary for the specified
       StandardName. (Currently this is restricted to be identical to the 
       canonical untis specified in the NUOPC Field Dictionary.)
       If omitted, the default is to use the canonical units associated with
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[LongName]</STRONG></DT>
<DD>The "LongName" attribute of the advertised field. NUOPC does not restrict
       the value of this attribute.
       If omitted, the default is to use the StandardName.
     
</DD>
<DT><STRONG>[ShortName]</STRONG></DT>
<DD>The "ShortName" attribute of the advertised field. NUOPC does not restrict
       the value of this attribute.
       If omitted, the default is to use the StandardName.
<BR>
NOTE that if by below default rules, <TT>ShortName</TT> is also used as
       the input for <TT>name</TT>, then it must not contain the slash ("/")
       character.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The actual name of the advertised field by which it is accessed in the
       state object. The string provided for <TT>name</TT> must not contain the
       slash ("/") character.
       If omitted, the default is to use the value of the ShortName.
     
</DD>
<DT><STRONG>[TransferOfferGeomObject]</STRONG></DT>
<DD>If the state intent of <TT>state</TT> is <TT>ESMF_STATEINTENT_EXPORT</TT>,
       the "ProducerTransferOffer" attribute of the advertised field is set.
       If the state intent of <TT>state</TT> is <TT>ESMF_STATEINTENT_IMPORT</TT>,
       the "ConsumerTransferOffer" attribute of the advertised field is set.
       NUOPC controls the vocabulary of this attribute. Valid options are 
       "will provide", "can provide", "cannot provide".
       If omitted, the default is "will provide".
     
</DD>
<DT><STRONG>[SharePolicyField]</STRONG></DT>
<DD>The "SharePolicyField" attribute of the advertised field. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is "not share".
     
</DD>
<DT><STRONG>[SharePolicyGeomObject]</STRONG></DT>
<DD>The "SharePolicyGeomObject" attribute of the advertised field. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is equal to <TT>SharePolicyField</TT>.
     
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the Field object used during advertising is created on the
       specified <TT>ESMF_VM</TT> object. The default is to create the Field object
       on the VM of the current component context.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the empty field object that was used to advertise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_Advertise - Advertise a list of Fields in a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Advertise() 
   subroutine NUOPC_AdvertiseFields(state, StandardNames, &amp;
     TransferOfferGeomObject, SharePolicyField, SharePolicyGeomObject, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardNames(:)
     character(*),     intent(in),  optional :: TransferOfferGeomObject
     character(*),     intent(in),  optional :: SharePolicyField
     character(*),     intent(in),  optional :: SharePolicyGeomObject
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_AdvertiseFields"></A>     Advertise a list of fields in a state. This creates a list of empty fields
     and adds it to the <TT>state</TT>. The "StandardName", "TransferOfferGeomObject",
     "SharePolicyField", and "SharePolicyGeomObject" attributes of all the 
     fields are set according to the provided input. The "Units", "LongName",
     and "ShortName" attributes for each field are set according to the defaults
     documented under method <A HREF="#NUOPC_AdvertiseField">3.9.3</A>

<P>
The call checks the provided information against the NUOPC Field Dictionary
     to ensure correctness.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object through which the fields are advertised.
     
</DD>
<DT><STRONG>StandardNames</STRONG></DT>
<DD>A list of "StandardName" attributes of the advertised fields. Must be 
       StandardNames found in the  NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[TransferOfferGeomObject]</STRONG></DT>
<DD>The "TransferOfferGeomObject" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "will provide", "can provide", "cannot provide".
       If omitted, the default is "will provide".
     
</DD>
<DT><STRONG>[SharePolicyField]</STRONG></DT>
<DD>The "SharePolicyField" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is "not share".
     
</DD>
<DT><STRONG>[SharePolicyGeomObject]</STRONG></DT>
<DD>The "SharePolicyGeomObject" attribute of the advertised fields. This 
       setting applies to all the fields advertised in this call. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "share", and "not share".
       If omitted, the default is equal to <TT>SharePolicyField</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_AdjustClock - Adjust the timestep in a clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_AdjustClock(clock, maxTimestep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock)                               :: clock
     type(ESMF_TimeInterval), intent(in),  optional :: maxTimestep
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Adjust the <TT>clock</TT> to have a potentially smaller timestep. The timestep
     on the incoming <TT>clock</TT> object is compared to the <TT>maxTimestep</TT>, and
     reset to the smaller of the two.

<P>
The arguments are:
     <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The clock to be adjusted.
     
</DD>
<DT><STRONG>[maxTimestep]</STRONG></DT>
<DD>Upper bound of the timestep allowed in <TT>clock</TT>. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">6</SPAN> NUOPC_CheckSetClock - Check a Clock for compatibility and set its values</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_CheckSetClock(setClock, checkClock, setStartTimeToCurrent, &amp;
     currTime, forceCurrTime, checkTimeStep, forceTimeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock),        intent(inout)         :: setClock
     type(ESMF_Clock),        intent(in)            :: checkClock
     logical,                 intent(in),  optional :: setStartTimeToCurrent
     type(ESMF_Time),         intent(in),  optional :: currTime
     logical,                 intent(in),  optional :: forceCurrTime
     logical,                 intent(in),  optional :: checkTimeStep
     logical,                 intent(in),  optional :: forceTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
By default compare <TT>setClock</TT> to <TT>checkClock</TT> to ensure they match
     in their current time. Further ensure that the timeStep of <TT>checkClock</TT>
     is a multiple of the timeStep of <TT>setClock</TT>. If both conditions are 
     satisfied then the stopTime of the <TT>setClock</TT> is set one 
     <TT>checkClock</TT> timeStep, or <TT>setClock</TT> runDuration, ahead of the
     current time, which ever is shorter. The direction of <TT>checkClock</TT>
     is considered when setting the stopTime.

<P>
By default the startTime of the <TT>setClock</TT> is not modified. However, if
     <TT>setStartTimeToCurrent == .true.</TT> the startTime of <TT>setClock</TT> is set
     to the currentTime of <TT>checkClock</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>setClock</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object to be checked and set.
     
</DD>
<DT><STRONG>checkClock</STRONG></DT>
<DD>The reference clock object.
     
</DD>
<DT><STRONG>[setStartTimeToCurrent]</STRONG></DT>
<DD>If <TT>.true.</TT> then also set the startTime in <TT>setClock</TT> according to
       the startTime in <TT>checkClock</TT>. The default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[currTime]</STRONG></DT>
<DD>If provided, use <TT>currTime</TT> instead of <TT>checkClock</TT> when checking
       or setting the current time of <TT>setClock</TT>.
     
</DD>
<DT><STRONG>[forceCurrTime]</STRONG></DT>
<DD>If <TT>.true.</TT> then do <EM>not</EM> check the current time of the
       <TT>setClock</TT>, but instead force it to align with the <TT>checkClock</TT>,
       or <TT>currTime</TT>, if it was provided. The default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[checkTimeStep]</STRONG></DT>
<DD>If <TT>.true.</TT> then check that <TT>timeStep</TT> of the 
       <TT>setClock</TT> can reach the next increment on the <TT>checkClock</TT>
       by an integer number of steps. For <TT>.false.</TT> do not check this
       condition. The default is <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[forceTimeStep]</STRONG></DT>
<DD>If <TT>.true.</TT> then do <EM>not</EM> use the <TT>timeStep</TT> of the 
       <TT>setClock</TT> to check if the next increment on the <TT>checkClock</TT>
       can be reached in an integer number of steps. Instead set the
       <TT>timeStep</TT> of the <TT>setClock</TT> to the <TT>timeStep</TT> of the
       <TT>checkClock</TT>. The default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">7</SPAN> NUOPC_GetAttribute - Get the value of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeFieldVal(field, name, value, isPresent, isSet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     character(*),     intent(in)            :: name
     character(*),     intent(out)           :: value
     logical,          intent(out), optional :: isPresent
     logical,          intent(out), optional :: isSet
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>field</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">8</SPAN> NUOPC_GetAttribute - Get the typekind of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeFieldTK(field, name, isPresent, isSet, &amp;
     itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(in)            :: field
     character(*),             intent(in)            :: name
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query the <TT>typekind</TT> of the attribute <TT>name</TT> inside of <TT>field</TT>
     using the convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">9</SPAN> NUOPC_GetAttribute - Get the value of a NUOPC State Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_GetAttribute()
   subroutine NUOPC_GetAttributeState(state, name, value, isPresent, isSet, &amp;
     itemCount, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),         intent(in)            :: state
     character(*),             intent(in)            :: name
     character(*),             intent(out), optional :: value
     logical,                  intent(out), optional :: isPresent
     logical,                  intent(out), optional :: isSet
     integer,                  intent(out), optional :: itemCount
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>state</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>. Returns with error if
     the attribute is not present or not set.

<P>
Unless <TT>isPresent</TT> and <TT>isSet</TT> are provided, return with error if 
     the Attribute is not present or not set, respectively.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>[value]</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is present, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[isSet]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the queried attribute is set, <TT>.false.</TT>
       otherwise.
     
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Number of items in the attribute. Return 0 if not present or not set.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">10</SPAN> NUOPC_GetStateMemberLists - Build lists of information of State members</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_GetStateMemberLists(state, StandardNameList, &amp;
     ConnectedList, NamespaceList, CplSetList, itemNameList, fieldList, &amp;
     stateList, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),       intent(in)            :: state
     character(ESMF_MAXSTR), pointer, optional     :: StandardNameList(:)
     character(ESMF_MAXSTR), pointer, optional     :: ConnectedList(:)
     character(ESMF_MAXSTR), pointer, optional     :: NamespaceList(:)
     character(ESMF_MAXSTR), pointer, optional     :: CplSetList(:)
     character(ESMF_MAXSTR), pointer, optional     :: itemNameList(:)
     type(ESMF_Field),       pointer, optional     :: fieldList(:)
     type(ESMF_State),       pointer, optional     :: stateList(:)
     logical,                intent(in), optional  :: nestedFlag
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Construct lists containing the StandardNames, field names, and connected 
     status of the fields in <TT>state</TT>. Return this information in the
     list arguments. Recursively parse through nested States.

<P>
All pointer arguments present must enter this method unassociated. This
     means that the user code must explicitly call <TT>nullify()</TT> or use the
     <TT>=&gt; null()</TT> syntax on the variables passed in as any of the pointer
     arguments. On return, the pointer arguments may either be unassociated or
     associated. Consequently the user code must first check the status of any
     of the returned pointer arguments via the <TT>associated()</TT> intrinsic
     before accessing the argument. The responsibility for deallocation of
     associated pointer arguments transfers to the caller.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be queried.
     
</DD>
<DT><STRONG>[StandardNameList]</STRONG></DT>
<DD>If present, return a list of the "StandardName" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[ConnectedList]</STRONG></DT>
<DD>If present, return a list of the "Connected" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[NamespaceList]</STRONG></DT>
<DD>If present, return a list of the "Namespace" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[CplSetList]</STRONG></DT>
<DD>If present, return a list of the "CplSet" attribute of each member.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[itemNameList]</STRONG></DT>
<DD>If present, return a list of each member name.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>If present, return a list of the member fields.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[stateList]</STRONG></DT>
<DD>If present, return a list of the states corresonding to the owner of the
       fields returned under <TT>fieldList</TT>.
       See the note about pointer arguments in the description section above for
       correct usage.
     
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD>When set to .true., returns information from nested States (default).
       When set to .false., returns information at the current State level only.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">11</SPAN> NUOPC_GetStateMemberCount - Determing number of State members</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_GetStateMemberCount(state, fieldCount, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),       intent(in)            :: state
     integer,                intent(out), optional :: fieldCount
     logical,                intent(in),  optional :: nestedFlag
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Determine the number of fields in <TT>state</TT>. By default recursively parse
     through nested States.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be queried.
     
</DD>
<DT><STRONG>[fieldCount]</STRONG></DT>
<DD>Number of fields.
     
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD>When set to .true., returns information from nested States (default).
       When set to .false., returns information at the current State level only.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">12</SPAN> NUOPC_GetTimestamp - Get the timestamp of a Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_GetTimestamp(field, isValid, time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     logical,          intent(out), optional :: isValid
     type(ESMF_Time),  intent(out), optional :: time
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access the timestamp on <TT>field</TT> in form of an <TT>ESMF_Time</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be checked.
     
</DD>
<DT><STRONG>[isValid]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the timestamp is valid, <TT>.false.</TT> otherwise.
     
</DD>
<DT><STRONG>[time]</STRONG></DT>
<DD>The timestamp as <TT>ESMF_Time</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">13</SPAN> NUOPC_IngestPetList - Ingest a petList from FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_IngestPetList(petList, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, allocatable,   intent(out)           :: petList(:)
     type(NUOPC_FreeFormat), intent(in),  target   :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Construct a petList from a <TT>FreeFormat</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>petList</STRONG></DT>
<DD>The constructed petList. The size and content is set by this method.
     
</DD>
<DT><STRONG>freeFormat</STRONG></DT>
<DD>The incoming petList information in free format. The format supports
       two types of elements:
       
<UL>
<LI>Single PET elements consist of a single number referring to the PET.
</LI>
<LI>Block elements consist of two PET numbers, separated by a "-" 
             character. No white spaces are accepted between the dash and the
             PET numbers. A block element includes all of the PETs between the
             lower bound (left PET number), and the upper bound (right PET
             number), bounds inclusive. The upper bound must <EM>not</EM> be
             less than the lower bound. 
       
</LI>
</UL>
       Any number of elements may be listed in the free format. The idividual
       elements are separated by white spaces.

<P>
For an example, the free format petList definition
       <PRE>
       "2-5 12 0 15-23"
</PRE>
       would translate into a <TT>petList</TT> output of
       <PRE>
       (/2, 3, 4, 5, 12, 0, 15, 16, 17, 18, 19, 20, 21, 22, 23/)
</PRE>
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">14</SPAN> NUOPC_IsAtTime - Check if a Field is at the given Time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_IsAtTime()
   function NUOPC_IsAtTimeField(field, time, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsAtTimeField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if <TT>field</TT> has a timestamp
     that matches <TT>time</TT>. Otherwise returns <TT>.false.</TT>. On PETs 
     with only a proxy instance of the field, <TT>.true.</TT> is returned
     regardless of the actual timestamp.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be checked.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The time to compare against.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">15</SPAN> NUOPC_IsAtTime - Check if Field(s) in a State are at the given Time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_IsAtTime()
   function NUOPC_IsAtTimeState(state, time, fieldName, count, fieldList, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsAtTimeState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),              intent(in)            :: state
     type(ESMF_Time),               intent(in)            :: time
     character(*),                  intent(in),  optional :: fieldName
     integer,                       intent(out), optional :: count
     type(ESMF_Field), allocatable, intent(out), optional :: fieldList(:)
     integer,                       intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the field(s) in <TT>state</TT> have a timestamp 
     that matches <TT>time</TT>. Otherwise return <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be checked.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The time to compare against.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be checked. If provided, and 
       the state does not contain a field with <TT>fieldName</TT>, return an 
       error in <TT>rc</TT>. If not provided, check <EM>all</EM> the fields contained
       in <TT>state</TT> and return <TT>.true.</TT> if all the fields are at the 
       correct time.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are at <TT>time</TT> are returned. If 
       <TT>fieldName</TT> is present then <TT>count</TT> cannot be greater than 1.
     
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>If provided, the fields that are <EM>not</EM> at <TT>time</TT> are returned. If 
       <TT>fieldName</TT> is present then <TT>fieldList</TT> can contain a maximum of
       1 field.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">16</SPAN> NUOPC_IsConnected - Check if a Field is connected</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_IsConnected()
   function NUOPC_IsConnectedField(field, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsConnectedField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>field</TT> is connected.
     Otherwise return <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be checked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">17</SPAN> NUOPC_IsConnected - Check if Field(s) in a State are connected</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_IsConnected()
   function NUOPC_IsConnectedState(state, fieldName, count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsConnectedState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the field(s) in <TT>state</TT> are connected. Otherwise
     return <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be checked.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be checked. If provided, and 
       the state does not contain a field with <TT>fieldName</TT>, return an 
       error in <TT>rc</TT>. If not provided, check <EM>all</EM> the fields contained
       in <TT>state</TT> and return <TT>.true.</TT> if all the fields are connected.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are connected are returned. If 
       <TT>fieldName</TT> is present then <TT>count</TT> cannot be greater than 1.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">18</SPAN> NUOPC_IsUpdated - Check if a Field is marked as updated</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_IsUpdated()
   function NUOPC_IsUpdatedField(field, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsUpdatedField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the field has its "Updated"
     attribute set to "true". Otherwise return <TT>.false.</TT>. 

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be checked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">19</SPAN> NUOPC_IsUpdated - Check if Field(s) in a State are marked as updated</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_IsUpdated()
   function NUOPC_IsUpdatedState(state, fieldName, count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsUpdatedState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the field(s) in <TT>state</TT> have the "Updated"
     attribute set to "true". Otherwise return <TT>.false.</TT>. 

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be checked.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be checked. If provided, and 
       the state does not contain a field with <TT>fieldName</TT>, return an 
       error in <TT>rc</TT>. If not provided, check <EM>all</EM> the fields contained
       in <TT>state</TT> and return <TT>.true.</TT> if all the fields are updated.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are updated are returned. If 
       <TT>fieldName</TT> is present then <TT>count</TT> cannot be greater than 1.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">20</SPAN> NUOPC_NoOp - No-Operation attachable method for GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine NUOPC_NoOp(gcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)   :: gcomp
     integer, intent(out)  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
No-Op method with an interface that matches the
     requirements for a attachable method for ESMF_GridComp objects.

<P>
The arguments are:
     <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object to which this method is attached.
     
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">21</SPAN> NUOPC_Realize - Realize previously advertised Fields inside a State on a single Grid with internal allocation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteG(state, grid, fieldName, typekind, &amp;
     staggerloc, selection, dataFillScheme, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     type(ESMF_Grid),          intent(in)            :: grid
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     type(ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme    
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_RealizeCompleteG"></A>
<P>
Realize or remove fields inside of <TT>state</TT> according to <TT>selection</TT>.
     All of the fields that are realized are created internally on the same 
     <TT>grid</TT> object, allocating memory for as many field dimensions as there 
     are grid dimensions.

<P>
The type and kind of the created fields is according to argument 
     <TT>typekind</TT>.

<P>
Realized fields are filled with data according to the <TT>dataFillScheme</TT>
     argument.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object in which the fields are realized.
     
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on which to realize the fields.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be realized, or removed, according
       to <TT>selection</TT>. If provided, and the state does not contain a field
       with name <TT>fieldName</TT>, return an error in <TT>rc</TT>. If not provided,
       realize <EM>all</EM> the fields contained in <TT>state</TT> according to 
       <TT>selection</TT>.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the internally created field(s). The valid options are
       <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
       <TT>ESMF_TYPEKIND_R4</TT>, and <TT>ESMF_TYPEKIND_R8</TT>.
       By default use the <TT>typekind</TT> of the partially created field used
       during advertise, or <TT>ESMF_TYPEKIND_R8</TT>, if the advertised field 
       did not have a <TT>typekind</TT> defined.
     
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. By default use the same
       stagger location as the advertising field, or 
       <TT>ESMF_STAGGERLOC_CENTER</TT> if the advertising field was created empty.
     
</DD>
<DT><STRONG>[selection]</STRONG></DT>
<DD>Selection of mode of operation:
       
<UL>
<LI><TT>"realize_all"</TT> (default)
</LI>
<LI><TT>"realize_connected_remove_others"</TT>
</LI>
<LI><TT>"realize_connected+provide_remove_others"</TT>
       
</LI>
</UL>
     
</DD>
<DT><STRONG>[dataFillScheme]</STRONG></DT>
<DD>Realized fields will be filled according to the selected fill
       scheme. See <TT>ESMF_FieldFill()</TT> for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the completed field that was realized by this method. This option
       is only supported if also argument <TT>fieldName</TT> was specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">22</SPAN> NUOPC_Realize - Realize previously advertised Fields inside a State on a single LocStream with internal allocation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteLS(state, locstream, fieldName, typekind, selection,&amp;
     dataFillScheme, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     type(ESMF_LocStream),     intent(in)            :: locstream
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme    
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_RealizeCompleteLS"></A>
<P>
Realize or remove fields inside of <TT>state</TT> according to <TT>selection</TT>.
     All of the fields that are realized are created internally on the same 
     <TT>locstream</TT> object, allocating memory accordingly.

<P>
The type and kind of the created fields is according to argument 
     <TT>typekind</TT>.

<P>
Realized fields are filled with data according to the <TT>dataFillScheme</TT>
     argument.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object in which the fields are realized.
     
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on which to realize the fields.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be realized, or removed, according
       to <TT>selection</TT>. If provided, and the state does not contain a field
       with name <TT>fieldName</TT>, return an error in <TT>rc</TT>. If not provided,
       realize <EM>all</EM> the fields contained in <TT>state</TT> according to 
       <TT>selection</TT>.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the internally created field(s). The valid options are
       <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
       <TT>ESMF_TYPEKIND_R4</TT>, and <TT>ESMF_TYPEKIND_R8</TT>.
       By default use the <TT>typekind</TT> of the partially created field used
       during advertise, or <TT>ESMF_TYPEKIND_R8</TT>, if the advertised field 
       did not have a <TT>typekind</TT> defined.
     
</DD>
<DT><STRONG>[selection]</STRONG></DT>
<DD>Selection of mode of operation:
       
<UL>
<LI><TT>"realize_all"</TT> (default)
</LI>
<LI><TT>"realize_connected_remove_others"</TT>
       
</LI>
</UL>
     
</DD>
<DT><STRONG>[dataFillScheme]</STRONG></DT>
<DD>Realized fields will be filled according to the selected fill
       scheme. See <TT>ESMF_FieldFill()</TT> for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the completed field that was realized by this method. This option
       is only supported if also argument <TT>fieldName</TT> was specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">23</SPAN> NUOPC_Realize - Realize previously advertised Fields inside a State on a single Mesh with internal allocation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeCompleteM(state, mesh, fieldName, typekind, &amp;
     meshloc, selection, dataFillScheme, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     type(ESMF_Mesh),          intent(in)            :: mesh
     character(*),             intent(in),  optional :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     type(ESMF_MeshLoc),       intent(in),  optional :: meshloc
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_RealizeCompleteM"></A>
<P>
Realize or remove fields inside of <TT>state</TT> according to <TT>selection</TT>.
     All of the fields that are realized are created internally on the same 
     <TT>mesh</TT> object, allocating memory accordingly.

<P>
The type and kind of the created fields is according to argument 
     <TT>typekind</TT>.

<P>
Realized fields are filled with data according to the <TT>dataFillScheme</TT>
     argument.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object in which the fields are realized.
     
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on which to realize the fields.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be realized, or removed, according
       to <TT>selection</TT>. If provided, and the state does not contain a field
       with name <TT>fieldName</TT>, return an error in <TT>rc</TT>. If not provided,
       realize <EM>all</EM> the fields contained in <TT>state</TT> according to 
       <TT>selection</TT>.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the internally created field(s). The valid options are
       <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
       <TT>ESMF_TYPEKIND_R4</TT>, and <TT>ESMF_TYPEKIND_R8</TT>.
       By default use the <TT>typekind</TT> of the partially created field used
       during advertise, or <TT>ESMF_TYPEKIND_R8</TT>, if the advertised field 
       did not have a <TT>typekind</TT> defined.
     
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Location of data in the mesh cell. By default use the same
       mesh location as the advertising field, or 
       <TT>ESMF_STAGGERLOC_NODE</TT> if the advertising field was created empty.
     
</DD>
<DT><STRONG>[selection]</STRONG></DT>
<DD>Selection of mode of operation:
       
<UL>
<LI><TT>"realize_all"</TT> (default)
</LI>
<LI><TT>"realize_connected_remove_others"</TT>
       
</LI>
</UL>
     
</DD>
<DT><STRONG>[dataFillScheme]</STRONG></DT>
<DD>Realized fields will be filled according to the selected fill
       scheme. See <TT>ESMF_FieldFill()</TT> for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the completed field that was realized by this method. This option
       is only supported if also argument <TT>fieldName</TT> was specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">24</SPAN> NUOPC_Realize - Realize a previously advertised Field in a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeField(state, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_RealizeField"></A>
<P>
Realize a previously advertised field in <TT>state</TT> by replacing the
     advertised field with <TT>field</TT> of the same name.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object in which the fields are realized.
     
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>The new field to put in place of the previously advertised (empty) field.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">25</SPAN> NUOPC_Realize - Realize a previously advertised Field in a State after Transfer of GeomObject</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Realize()
   subroutine NUOPC_RealizeTransfer(state, fieldName, typekind, gridToFieldMap, &amp;
     ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, &amp;
     realizeOnlyConnected, removeNotConnected, realizeOnlyNotShared, &amp;
     realizeOnlyNotComplete, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     character(*),             intent(in)            :: fieldName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     integer, target,          intent(in),  optional :: gridToFieldMap(:)
     integer, target,          intent(in),  optional :: ungriddedLBound(:)
     integer, target,          intent(in),  optional :: ungriddedUBound(:)
     integer,                  intent(in),  optional :: totalLWidth(:)
     integer,                  intent(in),  optional :: totalUWidth(:)
     logical,                  intent(in),  optional :: realizeOnlyConnected
     logical,                  intent(in),  optional :: removeNotConnected
     logical,                  intent(in),  optional :: realizeOnlyNotShared
     logical,                  intent(in),  optional :: realizeOnlyNotComplete
     type(ESMF_Field),         intent(out), optional :: field
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_RealizeTransfer"></A>
<P>
Realize a field where GeomObject has been set by the NUOPC GeomObject
     transfer protocol.

<P>
The data of the realized field is left uninitialized by this method.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object in which the field is realized.
     
</DD>
<DT><STRONG>fieldName</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be realized. If <TT>state</TT> does
       not contain a field with name <TT>fieldName</TT>, return an error in 
       <TT>rc</TT>.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the internally created field(s). The valid options are
       <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
       <TT>ESMF_TYPEKIND_R4</TT>, and <TT>ESMF_TYPEKIND_R8</TT>.
       By default use the <TT>typekind</TT> of the connected provider field.
     
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>The mapping of grid/mesh dimensions against field dimensions. The argument
       is of rank 1 and with a size of dimCount. The elements correspond to the
       grid/mesh elements in order, and associates it with the indicated 
       field dimension. Only entries between 1 and the field rank are allowed.
       There must be no duplicate entries in <TT>gridToFieldMap</TT>.
       By default use the <TT>gridToFieldMap</TT> of the connected provider field.
     
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of
       elements defines the number of ungridded dimensions of the field and 
       must be consistent with <TT>ungriddedUBound</TT>.
       By default use the <TT>ungriddedLBound</TT> of the connected provider field.
     
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of
       elements defines the number of ungridded dimensions of the field and 
       must be consistent with <TT>ungriddedLBound</TT>.
       By default use the <TT>ungriddedLBound</TT> of the connected provider field.
     
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD><EM>This argument is only supported for fields defined on
       <TT>ESMF_Grid</TT>.</EM>
       The number elements outside the lower bound of the exclusive region.
       The argument is of rank 1 and with a size of dimCount, the number of
       gridded dimensions of the field. The ordering of the dimensions is that
       of the field (considering <TT>gridToFieldMap</TT>).
       By default a zero vector is used, resulting in no elements outside the
       exclusive region.
     
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD><EM>This argument is only supported for fields defined on
       <TT>ESMF_Grid</TT>.</EM>
       The number elements outside the upper bound of the exclusive region.
       The argument is of rank 1 and with a size of dimCount, the number of
       gridded dimensions of the field. The ordering of the dimensions is that
       of the field (considering <TT>gridToFieldMap</TT>).
       By default a zero vector is used, resulting in no elements outside the
       exclusive region.
     
</DD>
<DT><STRONG>[realizeOnlyConnected]</STRONG></DT>
<DD>If set to <TT>.false.</TT>, realize the specified field irregardless of the
       connected status. If set to <TT>.true.</TT>, only a connected field will be
       realized. The default is <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[removeNotConnected]</STRONG></DT>
<DD>If set to <TT>.false.</TT>, do not remove a field from the state due to its
       connected status. If set to <TT>.true.</TT>, remove the field if it is not
       connected. This requires <TT>realizeOnlyConnected</TT> to be <TT>.true.</TT>,
       and a runtime error will be returned otherwise.
       The default is <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[realizeOnlyNotShared]</STRONG></DT>
<DD>If set to <TT>.false.</TT>, realize the specified field irregardless of its
       shared status. If set to <TT>.true.</TT>, only a field that has 
       "ShareStatusField" set to "not shared" will be realized.
       The default is <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[realizeOnlyNotComplete]</STRONG></DT>
<DD>If set to <TT>.false.</TT>, realize the specified field irregardless of its
       complete status. If set to <TT>.true.</TT>, only a field that has not yet
       been completed will be realized.
       The default is <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Returns the completed field that was realized by this method. An invalid
       field object will be returned if the conditions were such that the field
       was  not realized.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492600000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">26</SPAN> NUOPC_SetAttribute - Set the value of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_SetAttribute()
   subroutine NUOPC_SetAttributeField(field, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field)                      :: field
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the attribute <TT>name</TT> inside of <TT>field</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on which to set the attribute.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the set attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the set attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492700000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">27</SPAN> NUOPC_SetAttribute - Set the value of a NUOPC State Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_SetAttribute()
   subroutine NUOPC_SetAttributeState(state, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                      :: state
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the attribute <TT>name</TT> inside of <TT>state</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on which to set the attribute.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the set attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the set attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492800000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">28</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on a Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampField(field, time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout)         :: field
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the TimeStamp according to <TT>time</TT> on <TT>field</TT>.

<P>
This call should rarely be needed in user written code.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be time stampped.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> object defining the TimeStamp.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492900000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">29</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on Fields in a list</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampFieldList(fieldList, time, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout)         :: fieldList(:)
     type(ESMF_Time),  intent(in)            :: time
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the TimeStamp according to <TT>time</TT> on <TT>field</TT>.

<P>
This call should rarely be needed in user written code.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldList</STRONG></DT>
<DD>The list of <TT>ESMF_Field</TT> objects to be time stampped.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> object defining the TimeStamp.
     
</DD>
<DT><STRONG>[selective]</STRONG></DT>
<DD>If <TT>.true.</TT>, then only set the TimeStamp on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       TimeStamp on all the fields. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000493000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">30</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on Fields in a list from Clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampFieldListClk(fieldList, clock, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout)         :: fieldList(:)
     type(ESMF_Clock), intent(in)            :: clock
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the TimeStamp according to <TT>time</TT> on <TT>field</TT>.

<P>
This call should rarely be needed in user written code.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldList</STRONG></DT>
<DD>The list of <TT>ESMF_Field</TT> objects to be time stampped.
     
</DD>
<DT><STRONG>clock</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object defining the TimeStamp by its current time.
     
</DD>
<DT><STRONG>[selective]</STRONG></DT>
<DD>If <TT>.true.</TT>, then only set the TimeStamp on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       TimeStamp on all the fields. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000493100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">31</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on all the Fields in a State</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampState(state, time, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Time),  intent(in)            :: time
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the TimeStamp according to <TT>clock</TT> on all the fields in
     <TT>state</TT>. Depending on <TT>selective</TT>, all or only some fields may be
     updated.

<P>
This call should rarely be needed in user written code. It is used 
     by the generic Connector.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object holding the fields to be time stampped.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> object defining the TimeStamp.
     
</DD>
<DT><STRONG>[selective]</STRONG></DT>
<DD>If <TT>.true.</TT>, then only set the TimeStamp on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       TimeStamp on all the fields. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000493200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">32</SPAN> NUOPC_SetTimestamp - Set the TimeStamp on all the Fields in a State from Clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_SetTimestamp()
   subroutine NUOPC_SetTimestampStateClk(state, clock, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Clock), intent(in)            :: clock
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the TimeStamp according to <TT>clock</TT> on all the fields in
     <TT>state</TT>. Depending on <TT>selective</TT>, all or only some fields may be
     updated.

<P>
This call should rarely be needed in user written code. It is used 
     by the generic Connector.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object holding the fields to be time stampped.
     
</DD>
<DT><STRONG>clock</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object defining the TimeStamp by its current time.
     
</DD>
<DT><STRONG>[selective]</STRONG></DT>
<DD>If <TT>.true.</TT>, then only set the TimeStamp on those fields
       for which the "Updated" attribute is equal to "true". Otherwise set the
       TimeStamp on all the fields. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H2><A NAME="SECTION000410000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Auxiliary Routines</A>
</H2>
Auxiliary routines are provided with the NUOPC Layer as a convenience to the
user. Typically more work is needed on these methods before considering them
NUOPC core functionality.

<P>

<P>

<P>

<H3><A NAME="SECTION000410100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> NUOPC_Write - Write a distributed interpolation matrix to file in SCRIP format</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_SCRIPWrite(factorList, factorIndexList, fileName, &amp;
     relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(in), target    :: factorList(:)
     integer,            intent(in), target    :: factorIndexList(:,:) 
     character(*),       intent(in)            :: fileName
     logical,            intent(in),  optional :: relaxedflag
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="api_NUOPC_SCRIPWrite"></A>     Write the destributed interpolaton matrix provided by <TT>factorList</TT> 
     and <TT>factorIndexList</TT> to a SCRIP formatted NetCDF file. Each PET calls
     with its local list of factors and indices. The call then writes the 
     distributed factors into a single file. If the file already exists, the
     contents is replaced by this call.

<P>
The arguments are:
     <DL>
<DT><STRONG>factorList</STRONG></DT>
<DD>The distributed factor list.
     
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>The distributed list of source and destination indices.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file to be written to.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <TT>.true.</TT>, then no error is returned even if the call cannot write
       the file due to library limitations. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000410200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> NUOPC_Write - Write a distributed factorList to file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_FactorsWrite(factorList, fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), pointer               :: factorList(:)
     character(*),       intent(in)            :: fileName
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
THIS METHOD IS DEPRECATED. Use <A HREF="#api_NUOPC_SCRIPWrite">3.10.1</A> instead.

<P>
Write the destributed <TT>factorList</TT> to file. Each PET calls with its 
     local list of factors. The call then writes the distributed factors into
     a single file. The order of the factors in the file is first by PET, and 
     within each PET the PET-local order is preserved. Changing the number of 
     PETs for the same regrid operation will likely change the order of factors
     across PETs, and therefore files written will differ.

<P>
The arguments are:
     <DL>
<DT><STRONG>factorList</STRONG></DT>
<DD>The distributed factor list.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file to be written to.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000410300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> NUOPC_Write - Write Field data to file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_FieldWrite(field, fileName, overwrite, status, timeslice, &amp;
     iofmt, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),           intent(in)            :: field
     character(*),               intent(in)            :: fileName
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     logical,                    intent(in),  optional :: relaxedflag
     integer,                    intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write the data in <TT>field</TT> to <TT>file</TT> under the field's "StandardName" 
     attribute if supported by the <TT>iofmt</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object whose data is to be written.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file to write to.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Field data may
        <EM>not</EM> be overwritten. If .true., the
        data corresponding to each field's name will be
        be overwritten. If the <TT>timeslice</TT> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
     
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Valid options are <TT>ESMF_FILESTATUS_NEW</TT>, 
        <TT>ESMF_FILESTATUS_OLD</TT>, <TT>ESMF_FILESTATUS_REPLACE</TT>, and
        <TT>ESMF_FILESTATUS_UNKNOWN</TT> (default).
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Time slice counter. Must be positive. The behavior of this
       option may depend on the setting of the <TT>overwrite</TT> flag:
       <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
       less than the maximum time already in the file, the write will fail.
       
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
       
</DD>
</DL>
       By default, i.e. by omitting the <TT>timeslice</TT> argument, no
       provisions for time slicing are made in the output file,
       however, if the file already contains a time axis for the variable,
       a timeslice one greater than the maximum will be written.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Supported options are <TT>ESMF_IOFMT_NETCDF</TT>,
       <TT>ESMF_IOFMT_NETCDF4P</TT>, and <TT>ESMF_IOFMT_NETCDF4C</TT>. If not
       present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <TT>.true.</TT>, then no error is returned even if the call cannot write
       the file due to library limitations, or because <TT>field</TT> does not 
       contain any data. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000410400000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> NUOPC_Write - Write the Fields within a State to NetCDF files</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_StateWrite(state, fieldNameList, fileNamePrefix, overwrite, &amp;
     status, timeslice, iofmt, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),           intent(in)            :: state
     character(len=*),           intent(in),  optional :: fieldNameList(:)
     character(len=*),           intent(in),  optional :: fileNamePrefix
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     logical,                    intent(in),  optional :: relaxedflag
     integer,                    intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write the data of the fields within a <TT>state</TT> to NetCDF files. Each 
     field is written to an individual file using the "StandardName" attribute
     as NetCDF attribute.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object containing the fields.
     
</DD>
<DT><STRONG>[fieldNameList]</STRONG></DT>
<DD>List of names of the fields to be written. By default write all the fields
       in <TT>state</TT>.
     
</DD>
<DT><STRONG>[fileNamePrefix]</STRONG></DT>
<DD>File name prefix, common to all the files written.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Field data may
        <EM>not</EM> be overwritten. If .true., the
        data corresponding to each field's name will be
        be overwritten. If the <TT>timeslice</TT> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
     
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Valid options are <TT>ESMF_FILESTATUS_NEW</TT>, 
        <TT>ESMF_FILESTATUS_OLD</TT>, <TT>ESMF_FILESTATUS_REPLACE</TT>, and
        <TT>ESMF_FILESTATUS_UNKNOWN</TT> (default).
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Time slice counter. Must be positive. The behavior of this
       option may depend on the setting of the <TT>overwrite</TT> flag:
       <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
       less than the maximum time already in the file, the write will fail.
       
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
       
</DD>
</DL>
       By default, i.e. by omitting the <TT>timeslice</TT> argument, no
       provisions for time slicing are made in the output file,
       however, if the file already contains a time axis for the variable,
       a timeslice one greater than the maximum will be written.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Supported options are <TT>ESMF_IOFMT_NETCDF</TT>,
       <TT>ESMF_IOFMT_NETCDF4P</TT>, and <TT>ESMF_IOFMT_NETCDF4C</TT>. If not
       present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <TT>.true.</TT>, then no error is returned even if the call cannot write
       the file due to library limitations. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000410500000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> NUOPC_Write - Write the Fields within a FieldBundle to NetCDF files</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_Write()
   subroutine NUOPC_FieldBundleWrite(fieldbundle, fieldNameList, fileNamePrefix, overwrite, &amp;
     status, timeslice, iofmt, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),     intent(in)            :: fieldbundle
     character(len=*),           intent(in),  optional :: fieldNameList(:)
     character(len=*),           intent(in),  optional :: fileNamePrefix
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     logical,                    intent(in),  optional :: relaxedflag
     integer,                    intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write the data of the fields within a <TT>fieldbundle</TT> to NetCDF files.
     Each field is written to an individual file using the "StandardName"
     attribute as NetCDF attribute.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object containing the fields.
     
</DD>
<DT><STRONG>[fieldNameList]</STRONG></DT>
<DD>List of names of the fields to be written. By default write all the fields
       in <TT>fieldbundle</TT>.
     
</DD>
<DT><STRONG>[fileNamePrefix]</STRONG></DT>
<DD>File name prefix, common to all the files written.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Field data may
        <EM>not</EM> be overwritten. If .true., the
        data corresponding to each field's name will be
        be overwritten. If the <TT>timeslice</TT> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
     
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Valid options are <TT>ESMF_FILESTATUS_NEW</TT>, 
        <TT>ESMF_FILESTATUS_OLD</TT>, <TT>ESMF_FILESTATUS_REPLACE</TT>, and
        <TT>ESMF_FILESTATUS_UNKNOWN</TT> (default).
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Time slice counter. Must be positive. The behavior of this
       option may depend on the setting of the <TT>overwrite</TT> flag:
       <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
       less than the maximum time already in the file, the write will fail.
       
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
       
</DD>
</DL>
       By default, i.e. by omitting the <TT>timeslice</TT> argument, no
       provisions for time slicing are made in the output file,
       however, if the file already contains a time axis for the variable,
       a timeslice one greater than the maximum will be written.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The I/O format.  Supported options are <TT>ESMF_IOFMT_NETCDF</TT>,
       <TT>ESMF_IOFMT_NETCDF4P</TT>, and <TT>ESMF_IOFMT_NETCDF4C</TT>. If not
       present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <TT>.true.</TT>, then no error is returned even if the call cannot write
       the file due to library limitations. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html441"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html437"
  HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html431"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html439"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html442"
  HREF="node5.html">4 Standardized Component Dependencies</A>
<B> Up:</B> <A NAME="tex2html438"
  HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A NAME="tex2html432"
  HREF="node3.html">2 Design and Implementation</A>
 &nbsp; <B>  <A NAME="tex2html440"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
