<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2025 (Released January 1, 2025) -->
<HTML lang="en">
<HEAD>
<TITLE>4 Infrastructure: Fields and Grids</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2025">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node6.html">
<LINK REL="previous" HREF="node4.html">
<LINK REL="next" HREF="node6.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1006"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A
 HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A
 HREF="node4.html">3 Superstructure</A>
 &nbsp; <B>  <A ID="tex2html1007"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><A ID="tex2html1008"
  HREF="node5.html#SECTION05010000000000000000"><SPAN CLASS="arabic">24</SPAN> Overview of Data Classes</A>
<UL>
<LI><A ID="tex2html1009"
  HREF="node5.html#SECTION05011000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">1</SPAN> Bit-for-Bit Considerations</A>
<LI><A ID="tex2html1010"
  HREF="node5.html#SECTION05012000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN> Regrid</A>
<UL>
<LI><A ID="tex2html1011"
  HREF="node5.html#SECTION05012100000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Interpolation methods: bilinear</A>
<LI><A ID="tex2html1012"
  HREF="node5.html#SECTION05012200000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Interpolation methods: higher-order patch</A>
<LI><A ID="tex2html1013"
  HREF="node5.html#SECTION05012300000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Interpolation methods: nearest source to destination</A>
<LI><A ID="tex2html1014"
  HREF="node5.html#SECTION05012400000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Interpolation methods: nearest destination to source</A>
<LI><A ID="tex2html1015"
  HREF="node5.html#SECTION05012500000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Interpolation methods: first-order conservative</A>
<LI><A ID="tex2html1016"
  HREF="node5.html#SECTION05012600000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Interpolation methods: second-order conservative</A>
<LI><A ID="tex2html1017"
  HREF="node5.html#SECTION05012700000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Conservation</A>
<LI><A ID="tex2html1018"
  HREF="node5.html#SECTION05012800000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> The effect of normalization options on integrals and values produced by conservative methods</A>
<LI><A ID="tex2html1019"
  HREF="node5.html#SECTION05012900000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">9</SPAN> Great circle cells</A>
<LI><A ID="tex2html1020"
  HREF="node5.html#SECTION050121000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">10</SPAN> Masking</A>
<LI><A ID="tex2html1021"
  HREF="node5.html#SECTION050121100000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">11</SPAN> Extrapolation methods: overview</A>
<LI><A ID="tex2html1022"
  HREF="node5.html#SECTION050121200000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">12</SPAN> Extrapolation methods: nearest source to destination</A>
<LI><A ID="tex2html1023"
  HREF="node5.html#SECTION050121300000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">13</SPAN> Extrapolation methods: inverse distance weighted average</A>
<LI><A ID="tex2html1024"
  HREF="node5.html#SECTION050121400000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">14</SPAN> Extrapolation methods: creep fill</A>
<LI><A ID="tex2html1025"
  HREF="node5.html#SECTION050121500000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">15</SPAN> Unmapped destination points</A>
<LI><A ID="tex2html1026"
  HREF="node5.html#SECTION050121600000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN> Spherical grids and poles</A>
<LI><A ID="tex2html1027"
  HREF="node5.html#SECTION050121700000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">17</SPAN> Vector regridding</A>
<LI><A ID="tex2html1028"
  HREF="node5.html#SECTION050121800000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">18</SPAN> Troubleshooting guide</A>
<LI><A ID="tex2html1029"
  HREF="node5.html#SECTION050121900000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">19</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1030"
  HREF="node5.html#SECTION050122000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">20</SPAN> Design and implementation notes</A>
</UL>
<LI><A ID="tex2html1031"
  HREF="node5.html#SECTION05013000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN> File-based Regrid API</A>
<LI><A ID="tex2html1032"
  HREF="node5.html#SECTION05014000000000000000"><SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</UL>
<LI><A ID="tex2html1033"
  HREF="node5.html#SECTION05020000000000000000"><SPAN CLASS="arabic">25</SPAN> FieldBundle Class</A>
<UL>
<LI><A ID="tex2html1034"
  HREF="node5.html#SECTION05021000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1035"
  HREF="node5.html#SECTION05022000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1036"
  HREF="node5.html#SECTION05023000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1037"
  HREF="node5.html#SECTION05024000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1038"
  HREF="node5.html#SECTION05025000000000000000"><SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API: Basic FieldBundle Methods</A>
</UL>
<LI><A ID="tex2html1039"
  HREF="node5.html#SECTION05030000000000000000"><SPAN CLASS="arabic">26</SPAN> Field Class</A>
<UL>
<LI><A ID="tex2html1040"
  HREF="node5.html#SECTION05031000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A ID="tex2html1041"
  HREF="node5.html#SECTION05031100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Operations</A>
</UL>
<LI><A ID="tex2html1042"
  HREF="node5.html#SECTION05032000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1043"
  HREF="node5.html#SECTION05032100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_FIELDSTATUS</A>
</UL>
<LI><A ID="tex2html1044"
  HREF="node5.html#SECTION05033000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A ID="tex2html1045"
  HREF="node5.html#SECTION05033100000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field create and destroy</A>
</UL>
<LI><A ID="tex2html1046"
  HREF="node5.html#SECTION05034000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1047"
  HREF="node5.html#SECTION05035000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1048"
  HREF="node5.html#SECTION05036000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<LI><A ID="tex2html1049"
  HREF="node5.html#SECTION05037000000000000000"><SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: Field Utilities</A>
</UL>
<LI><A ID="tex2html1050"
  HREF="node5.html#SECTION05040000000000000000"><SPAN CLASS="arabic">27</SPAN> ArrayBundle Class</A>
<UL>
<LI><A ID="tex2html1051"
  HREF="node5.html#SECTION05041000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1052"
  HREF="node5.html#SECTION05042000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1053"
  HREF="node5.html#SECTION05043000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1054"
  HREF="node5.html#SECTION05044000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1055"
  HREF="node5.html#SECTION05045000000000000000"><SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1056"
  HREF="node5.html#SECTION05050000000000000000"><SPAN CLASS="arabic">28</SPAN> Array Class</A>
<UL>
<LI><A ID="tex2html1057"
  HREF="node5.html#SECTION05051000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1058"
  HREF="node5.html#SECTION05052000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1059"
  HREF="node5.html#SECTION05053000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1060"
  HREF="node5.html#SECTION05054000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1061"
  HREF="node5.html#SECTION05055000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
<LI><A ID="tex2html1062"
  HREF="node5.html#SECTION05056000000000000000"><SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API: DynamicMask Methods</A>
</UL>
<LI><A ID="tex2html1063"
  HREF="node5.html#SECTION05060000000000000000"><SPAN CLASS="arabic">29</SPAN> LocalArray Class</A>
<UL>
<LI><A ID="tex2html1064"
  HREF="node5.html#SECTION05061000000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1065"
  HREF="node5.html#SECTION05062000000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">2</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1066"
  HREF="node5.html#SECTION05063000000000000000"><SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1067"
  HREF="node5.html#SECTION05070000000000000000"><SPAN CLASS="arabic">30</SPAN> ArraySpec Class</A>
<UL>
<LI><A ID="tex2html1068"
  HREF="node5.html#SECTION05071000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1069"
  HREF="node5.html#SECTION05072000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1070"
  HREF="node5.html#SECTION05073000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1071"
  HREF="node5.html#SECTION05074000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1072"
  HREF="node5.html#SECTION05075000000000000000"><SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1073"
  HREF="node5.html#SECTION05080000000000000000"><SPAN CLASS="arabic">31</SPAN> Grid Class</A>
<UL>
<LI><A ID="tex2html1074"
  HREF="node5.html#SECTION05081000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A ID="tex2html1075"
  HREF="node5.html#SECTION05081100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Representation in ESMF</A>
<LI><A ID="tex2html1076"
  HREF="node5.html#SECTION05081200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Grids</A>
<LI><A ID="tex2html1077"
  HREF="node5.html#SECTION05081300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Grid Topologies and Periodicity</A>
<LI><A ID="tex2html1078"
  HREF="node5.html#SECTION05081400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Grid Distribution</A>
<LI><A ID="tex2html1079"
  HREF="node5.html#SECTION05081500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Coordinates</A>
<LI><A ID="tex2html1080"
  HREF="node5.html#SECTION05081600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Coordinate Specification and Generation</A>
<LI><A ID="tex2html1081"
  HREF="node5.html#SECTION05081700000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> Staggering</A>
<LI><A ID="tex2html1082"
  HREF="node5.html#SECTION05081800000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> Masking</A>
</UL>
<LI><A ID="tex2html1083"
  HREF="node5.html#SECTION05082000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1084"
  HREF="node5.html#SECTION05082100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GRIDCONN</A>
<LI><A ID="tex2html1085"
  HREF="node5.html#SECTION05082200000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GRIDITEM</A>
<LI><A ID="tex2html1086"
  HREF="node5.html#SECTION05082300000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GRIDMATCH</A>
<LI><A ID="tex2html1087"
  HREF="node5.html#SECTION05082400000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GRIDSTATUS</A>
<LI><A ID="tex2html1088"
  HREF="node5.html#SECTION05082500000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_POLEKIND</A>
<LI><A ID="tex2html1089"
  HREF="node5.html#SECTION05082600000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_STAGGERLOC</A>
</UL>
<LI><A ID="tex2html1090"
  HREF="node5.html#SECTION05083000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1091"
  HREF="node5.html#SECTION05084000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1092"
  HREF="node5.html#SECTION05085000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<UL>
<LI><A ID="tex2html1093"
  HREF="node5.html#SECTION05085100000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Topology</A>
</UL>
<LI><A ID="tex2html1094"
  HREF="node5.html#SECTION05086000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API: General Grid Methods</A>
<LI><A ID="tex2html1095"
  HREF="node5.html#SECTION05087000000000000000"><SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: StaggerLoc Methods</A>
</UL>
<LI><A ID="tex2html1096"
  HREF="node5.html#SECTION05090000000000000000"><SPAN CLASS="arabic">32</SPAN> LocStream Class</A>
<UL>
<LI><A ID="tex2html1097"
  HREF="node5.html#SECTION05091000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1098"
  HREF="node5.html#SECTION05092000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1099"
  HREF="node5.html#SECTION05092100000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Coordinate keyNames</A>
<LI><A ID="tex2html1100"
  HREF="node5.html#SECTION05092200000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Masking keyName</A>
</UL>
<LI><A ID="tex2html1101"
  HREF="node5.html#SECTION05093000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1102"
  HREF="node5.html#SECTION05094000000000000000"><SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1103"
  HREF="node5.html#SECTION050100000000000000000"><SPAN CLASS="arabic">33</SPAN> Mesh Class</A>
<UL>
<LI><A ID="tex2html1104"
  HREF="node5.html#SECTION050101000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A ID="tex2html1105"
  HREF="node5.html#SECTION050101100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh representation in ESMF</A>
<LI><A ID="tex2html1106"
  HREF="node5.html#SECTION050101200000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Meshes</A>
</UL>
<LI><A ID="tex2html1107"
  HREF="node5.html#SECTION050102000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1108"
  HREF="node5.html#SECTION050102100000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_MESHELEMTYPE</A>
</UL>
<LI><A ID="tex2html1109"
  HREF="node5.html#SECTION050103000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1110"
  HREF="node5.html#SECTION050104000000000000000"><SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1111"
  HREF="node5.html#SECTION050110000000000000000"><SPAN CLASS="arabic">34</SPAN> XGrid Class</A>
<UL>
<LI><A ID="tex2html1112"
  HREF="node5.html#SECTION050111000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1113"
  HREF="node5.html#SECTION050112000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1114"
  HREF="node5.html#SECTION050112100000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_XGRIDSIDE</A>
</UL>
<LI><A ID="tex2html1115"
  HREF="node5.html#SECTION050113000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1116"
  HREF="node5.html#SECTION050114000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<UL>
<LI><A ID="tex2html1117"
  HREF="node5.html#SECTION050114100000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Restrictions and Future Work</A>
</UL>
<LI><A ID="tex2html1118"
  HREF="node5.html#SECTION050115000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1119"
  HREF="node5.html#SECTION050116000000000000000"><SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1120"
  HREF="node5.html#SECTION050120000000000000000"><SPAN CLASS="arabic">35</SPAN> Geom Class</A>
<UL>
<LI><A ID="tex2html1121"
  HREF="node5.html#SECTION050121000000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1122"
  HREF="node5.html#SECTION050122000000000000000"><SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API: Geom Methods</A>
</UL>
<LI><A ID="tex2html1123"
  HREF="node5.html#SECTION050130000000000000000"><SPAN CLASS="arabic">36</SPAN> DistGrid Class</A>
<UL>
<LI><A ID="tex2html1124"
  HREF="node5.html#SECTION050131000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1125"
  HREF="node5.html#SECTION050132000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1126"
  HREF="node5.html#SECTION050132100000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DISTGRIDMATCH</A>
</UL>
<LI><A ID="tex2html1127"
  HREF="node5.html#SECTION050133000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1128"
  HREF="node5.html#SECTION050134000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1129"
  HREF="node5.html#SECTION050135000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1130"
  HREF="node5.html#SECTION050136000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<LI><A ID="tex2html1131"
  HREF="node5.html#SECTION050137000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: DistGridConnection Methods</A>
<LI><A ID="tex2html1132"
  HREF="node5.html#SECTION050138000000000000000"><SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">8</SPAN> Class API: DistGridRegDecomp Methods</A>
</UL>
<LI><A ID="tex2html1133"
  HREF="node5.html#SECTION050140000000000000000"><SPAN CLASS="arabic">37</SPAN> RouteHandle Class</A>
<UL>
<LI><A ID="tex2html1134"
  HREF="node5.html#SECTION050141000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1135"
  HREF="node5.html#SECTION050142000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1136"
  HREF="node5.html#SECTION050143000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1137"
  HREF="node5.html#SECTION050144000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1138"
  HREF="node5.html#SECTION050145000000000000000"><SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1139"
  HREF="node5.html#SECTION050150000000000000000"><SPAN CLASS="arabic">38</SPAN> I/O Capability</A>
<UL>
<LI><A ID="tex2html1140"
  HREF="node5.html#SECTION050151000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1141"
  HREF="node5.html#SECTION050152000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">2</SPAN> Data I/O</A>
<LI><A ID="tex2html1142"
  HREF="node5.html#SECTION050153000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">3</SPAN> Data formats</A>
<LI><A ID="tex2html1143"
  HREF="node5.html#SECTION050154000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1144"
  HREF="node5.html#SECTION050155000000000000000"><SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION05000000000000000000">
<SPAN CLASS="arabic">4</SPAN> Infrastructure: Fields and Grids</A>
</H1>
<P>

<H1><A ID="SECTION05010000000000000000">
<SPAN CLASS="arabic">24</SPAN> Overview of Data Classes</A>
</H1>

<P>
The ESMF infrastructure data classes are part of the framework's 
hierarchy of structures for handling Earth system model data and 
metadata on parallel platforms.  The hierarchy is in complexity; the 
simplest data class in the infrastructure represents a distributed data
array and the most complex data class represents a bundle of physical 
fields that are discretized on the same grid.  Data class methods 
are called both from user-written code and from other classes 
internal to the framework. 

<P>
Data classes are distributed over <B>DE</B>s, or <B>Decomposition Elements</B>.  
A DE represents a piece of a decomposition.  A DELayout is a collection
of DEs with some associated connectivity that describes a specific 
distribution.  For example, the distribution of a grid divided 
into four segments in the x-dimension would be expressed in ESMF as
a DELayout with four DEs lying along an x-axis. This abstract concept 
enables a data decomposition to be defined in 
terms of threads, MPI processes, virtual decomposition elements, or
combinations of these without changes to user code.  This is a
primary strategy for ensuring optimal performance and portability
for codes using ESMF for communications.

<P>
ESMF data classes provide a standard,
convenient way for developers to collect together information 
related to model or observational data.  The information assembled 
in a data class includes a data pointer, a set of attributes 
(e.g. units, although attributes can also be user-defined), and a 
description of an associated grid.  The same set of information within 
an ESMF data object can be used by the framework to arrange 
intercomponent data transfers, to perform I/O, for communications
such as gathers and scatters, for simplification of interfaces 
within user code, for debugging, and for other functions.  
This unifies and organizes codes overall so that the user need not
define different representations of metadata for the same field 
for I/O and for component coupling.  

<P>
Since it is critical that users be able to introduce ESMF into their
codes easily and incrementally, ESMF data classes can be created based 
on native Fortran pointers.  Likewise, there are methods for retrieving 
native Fortran pointers from within ESMF data objects.  This allows
the user to perform allocations using ESMF, and to retrieve Fortran
arrays later for optimized model calculations.  The ESMF data classes 
do not have associated differential operators or other mathematical 
methods.

<P>
For flexibility, it is not necessary to build an ESMF data object 
all at once.  For example, it's possible to create a 
field but to defer allocation of the associated field data until 
a later time.

<P>
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=553>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Hierarchy of data structures designed specifically for the Earth 
system domain and high performance, parallel computing.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Multi-use ESMF structures simplify user code overall.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Data objects support incremental construction and deferred allocation.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Native Fortran arrays can be associated with or retrieved from ESMF data
objects, for ease of adoption, convenience, and performance.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>A variety of operations are provided for manipulating data in data objects 
such as regridding, redistribution, halo communication, and sparse matrix multiply.</TD>
</TR>
</TABLE>
</DIV>

<P>
The main classes that are used for model and observational data manipulation
are as follows:

<P>

<UL>
<LI><B>Array</B>  An ESMF Array contains a data pointer, 
information about its associated datatype, precision, and 
dimension.  

<P>
Data elements in Arrays are partitioned into categories 
defined by the role the data element plays in distributed halo 
operations.  Haloing - sometimes called ghosting - is the 
practice of copying portions of array data to multiple memory 
locations to ensure that data dependencies can be satisfied 
quickly when performing a calculation.  ESMF Arrays contain 
an <B>exclusive</B> domain, which contains data elements
updated exclusively and definitively by a given DE; a 
<B>computational</B> domain, which contains all data elements
with values that are updated by the DE in computations; and 
a <B>total</B> domain, which includes both the computational 
domain and data elements from other DEs which may be read 
but are not updated in computations.

<P>
</LI>
<LI><B>ArrayBundle</B> ArrayBundles are collections of
Arrays that are stored in a single object.  Unlike FieldBundles,
they don't need to be distributed the same way across PETs.  The
motivation for ArrayBundles is both convenience and performance.

<P>
</LI>
<LI><B>Field</B>  A Field holds model and/or observational 
data together with its underlying grid or set of spatial 
locations.  It provides methods for configuration, 
initialization, setting and retrieving data values, 
data I/O, data regridding, and manipulation of attributes.

<P>
</LI>
<LI><B>FieldBundle</B> Groups of Fields on the same underlying 
physical grid can be collected into a single object called a FieldBundle.  
A FieldBundle provides two major functions: it allows groups of 
Fields to be manipulated using a single identifier, for example 
during export or import of data between Components; and 
it allows data from multiple Fields to be packed together 
in memory for higher locality of reference and ease in 
subsetting operations.  Packing a set of Fields into a single
FieldBundle before performing a data communication allows the set 
to be transferred at once rather than as a Field at a time.
This can improve performance on high-latency platforms.

<P>
FieldBundle objects contain methods for setting and retrieving constituent 
fields, regridding, data I/O, and reordering of data in memory.

<P>
</LI>
</UL>

<P>

<H2><A ID="SECTION05011000000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">1</SPAN> Bit-for-Bit Considerations</A>
</H2>

<P>
Bit-for-bit reproducibility is at the core of the regression testing
schemes of many scientific model codes. The bit-for-bit requirement makes it
easy to compare the numerical results of simulation runs using standard
binary diff tools.

<P>
For the most part, ESMF methods do not modify user data numerically, and
thus have no effect on the bit-for-bit characteristics of the model code.
The exceptions are the regrid weight generation and the sparse matrix
multiplication.

<P>
In the case of the regrid weight generation, user data is used to produce
interpolation weights following specific numerical schemes. The bit-for-bit
reproducibility of the generated weights depends on the implementation
details. Section <A HREF="#sec:regrid">24.2</A> provides more details about the bit-for-bit
considerations with respect to the regrid weights generated by ESMF.

<P>
In the case of the sparse matrix multiplication, which is the typical method
that is used to apply the regrid weights, user data is directly manipulated 
by ESMF. In order to help users with the implementation of their bit-for-bit
requirements, while also considering the associated performance impact,
the ESMF sparse matrix implementation provides three levels of bit-for-bit
support. The strictest level ensures that the numerical results are
bit-for-bit identical, even when executing across different numbers of
PETs. In the relaxed level, bit-for-bit reproducibility is guaranteed when
running across an unchanged number of PETs. The lowest level makes no
guarantees about bit-for-bit reproducibility, however, it provides the
greatest performance potential for those cases where numerical round-off
differences are acceptable. An in-depth discussion of bit-for-bit
reproducibility, and the performance aspects of route-based communication
methods, such the sparse matrix multiplication, is given in section
<A HREF="#RH:bfb"><IMG  ALT="[*]" SRC="crossref.png"></A>.

<P>

<H2><A ID="SECTION05012000000000000000"></A><A ID="sec:regrid"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN> Regrid
</H2>

<P>
This section describes the regridding methods provided by ESMF. Regridding, also called remapping or interpolation, is 
 the process of changing the grid that underlies data values while preserving qualities of the original data. Different 
 kinds of transformations are appropriate for different problems. Regridding may be needed when communicating data between
 Earth system model components such as land and atmosphere, or between different data sets to support operations such as visualization.

<P>
Regridding can be broken into two stages. The first stage is generation of an interpolation weight matrix that describes how points in 
 the source grid contribute to points in the destination grid. The second stage is the multiplication of values on the source grid by the
 interpolation weight matrix to produce values on the destination grid. This is implemented as a parallel sparse matrix multiplication.

<P>
There are two options for accessing ESMF regridding functionality: <B>offline</B> and <B>integrated</B>. Offline regridding is a process whereby interpolation 
 weights are generated by a separate ESMF command line tool, not within the user code. The ESMF offline regridding tool also only generates the interpolation 
 matrix, the user is responsible for reading in this matrix and doing the actual interpolation (multiplication by the sparse matrix) in their code.
 Please see Section&nbsp;<A HREF="node3.html#sec:ESMF_RegridWeightGen">12</A> for a description of the offline regridding command line tool and the options it supports. For user convenience, there
 is also a method interface to the offline regrid tool functionality which is described in Section&nbsp;<A HREF="#api:esmf_regridweightgenfile"><IMG  ALT="[*]" SRC="crossref.png"></A>.
 In contrast to offline regridding, integrated regridding is a process whereby interpolation weights are generated via subroutine calls during the
 execution of the user's code. In addition to generating the weights, integrated regridding can also produce a <B>RouteHandle</B> (described in Section&nbsp;<A HREF="#sec:RHandle">37.1</A>) which allows the user to perform the parallel sparse 
 matrix multiplication using ESMF methods. In other words, ESMF integrated regridding allows a user to perform the whole process of interpolation within their code. 

<P>
To see what types of grids and other options are supported in the two types of regridding and their testing status, please see the <A ID="tex2html28"
  HREF="http://earthsystemmodeling.org/regrid/">ESMF Regridding Status</A>
webpage for this version of ESMF.
 Figure&nbsp;<A HREF="#Regrid_Interfaces">24.2</A> shows a comparison of different regrid interfaces and where they can be found in the documentation. 

<P>
The rest of this section further describes the various options available in ESMF regridding. 

<P>
<BR><P></P>
<DIV class="CENTER"><A ID="Regrid_Interfaces"></A><A ID="1433"></A>
<TABLE>
<CAPTION><STRONG>Table 1:</STRONG>
Regrid Interfaces</CAPTION>
<TR><TD>
<DIV class="CENTER">
<BR>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Name</TD>
<TD CLASS="LEFT">Access via</TD>
<TD CLASS="LEFT">Inputs</TD>
<TD CLASS="CENTER" COLSPAN=2><SPAN>Outputs</SPAN></TD>
<TD CLASS="LEFT">Description</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">Weights</TD>
<TD CLASS="LEFT">RouteHandle</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_FieldRegridStore()</TD>
<TD CLASS="LEFT">Subroutine call</TD>
<TD CLASS="LEFT">Field object</TD>
<TD CLASS="LEFT">yes</TD>
<TD CLASS="LEFT">yes</TD>
<TD CLASS="LEFT">Sec.&nbsp;<A HREF="#api:esmf_fieldregridstorenx"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_FieldBundleRegridStore()</TD>
<TD CLASS="LEFT">Subroutine call</TD>
<TD CLASS="LEFT">Fieldbundle obj.</TD>
<TD CLASS="LEFT">no</TD>
<TD CLASS="LEFT">yes</TD>
<TD CLASS="LEFT">Sec.&nbsp;<A HREF="#api:esmf_fieldbundleregridstore"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_RegridWeightGen()</TD>
<TD CLASS="LEFT">Subroutine call</TD>
<TD CLASS="LEFT">Grid files</TD>
<TD CLASS="LEFT">yes</TD>
<TD CLASS="LEFT">no</TD>
<TD CLASS="LEFT">Sec.&nbsp;<A HREF="#api:esmf_regridweightgenfile"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_RegridWeightGen</TD>
<TD CLASS="LEFT">Command Line Tool</TD>
<TD CLASS="LEFT">Grid files</TD>
<TD CLASS="LEFT">yes</TD>
<TD CLASS="LEFT">no</TD>
<TD CLASS="LEFT">Sec.&nbsp;<A HREF="node3.html#sec:ESMF_RegridWeightGen">12</A></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>

</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>

<H3><A ID="SECTION05012100000000000000"></A><A ID="sec:interpolation:bilinear"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Interpolation methods: bilinear
</H3>
 Bilinear interpolation calculates the value for the 
 destination point as a combination of multiple linear interpolations, one for each dimension of the Grid. Note that for ease of 
 use, the term bilinear interpolation is used for 3D interpolation in ESMF as well, although it should more properly be referred 
 to as trilinear interpolation.

<P>

<P></P>

<P>
In 2D, ESMF supports bilinear regridding between any combination of the following:
 
<UL>
<LI>Structured grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of polygons with any number of sides
</LI>
<LI>A set of disconnected points (<SPAN style="font-family:monospace">ESMF_LocStream</SPAN>) may be the destination of the regridding
</LI>
<LI>An exchange grid (<SPAN style="font-family:monospace">ESMF_XGrid</SPAN>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports bilinear regridding between any combination of the following:
 
<UL>
<LI>Structured grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of a single logically rectangular tile
</LI>
<LI>Unstructured meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of hexahedrons 
</LI>
<LI>A set of disconnected points (<SPAN style="font-family:monospace">ESMF_LocStream</SPAN>) may be the destination of the regridding
 
</LI>
</UL>

<P>

<P></P>

<P>
<B>Restrictions:</B>
 
<UL>
<LI>Cells which contain enough identical corners to collapse to a line or point are currently ignored
</LI>
<LI>Self-intersecting cells (e.g. a cell twisted into a bow tie) are not supported 
</LI>
<LI>On a spherical grid, cells which contain an edge which extends more than half way around the sphere are not supported 
</LI>
<LI>Source Fields built on a Grid which contains a DE of width less than 2 elements are not supported
 
</LI>
</UL>

<P>
To use the bilinear method the user may create their Fields on any stagger location (e.g. <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN>) for a Grid, or
 any Mesh location (e.g. <SPAN style="font-family:monospace">ESMF_MESHLOC_NODE</SPAN>) for a Mesh. For either a Grid or a Mesh, the location upon which the Field is built 
 must contain coordinates. This method will also work with a destination Field built on a LocStream that contains coordinates, 
 or with a source or destination Field built on an XGrid.

<P>

<H3><A ID="SECTION05012200000000000000"></A><A ID="sec:interpolation:patch"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Interpolation methods: higher-order patch
</H3>

<P>
Patch (or higher-order) interpolation is the ESMF version of a technique called &ldquo;patch recovery&rdquo; commonly
 used in finite element modeling&nbsp;[<A
 HREF="node8.html#PatchInterp1">16</A>]&nbsp;[<A
 HREF="node8.html#PatchInterp2">14</A>]. It typically results in better approximations to 
 values and derivatives when compared to bilinear interpolation.
 Patch interpolation works by constructing multiple polynomial patches to represent
 the data in a source cell. For 2D grids, these polynomials
 are currently 2nd degree 2D polynomials. One patch is constructed for each corner of the source cell, and the patch is constructed 
 by doing a least squares fit through the data in the cells surrounding the corner. The interpolated value at the destination point is 
 then a weighted average of the values of the patches at that point. 

<P>
The patch method has a larger stencil than the bilinear, for this reason the patch weight matrix can be correspondingly larger
 than the bilinear matrix (e.g. for a quadrilateral grid the patch matrix is around 4x the size of
 the bilinear matrix). This can be an issue when performing a regrid operation close to the memory
 limit on a machine. 

<P>
The patch method does not guarantee that after regridding the range of values in the destination field is within the range of 
 values in the source field. For example, if the mininum value in the source field is 0.0, then it's possible that after regridding with the 
 patch method, the destination field will contain values less than 0.0.

<P>

<P></P>

<P>
In 2D, ESMF supports patch regridding between any combination of the following:
 
<UL>
<LI>Structured Grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of a single logically rectangular tile
</LI>
<LI>Unstructured meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of polygons with any number of sides
</LI>
<LI>A set of disconnected points (<SPAN style="font-family:monospace">ESMF_LocStream</SPAN>) may be the destination of the regridding
</LI>
<LI>An exchange grid (<SPAN style="font-family:monospace">ESMF_XGrid</SPAN>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports patch regridding between any combination of the following:
 
<UL>
<LI>NONE
 
</LI>
</UL>

<P>

<P></P>

<P>
<B>Restrictions:</B>
 
<UL>
<LI>Cells which contain enough identical corners to collapse to a line or point are currently ignored
</LI>
<LI>Self-intersecting cells (e.g. a cell twisted into a bow tie) are not supported
</LI>
<LI>On a spherical grid, cells which contain an edge which extends more than half way around the sphere are not supported 
</LI>
<LI>Source Fields built on a Grid which contains a DE of width less than 2 elements are not supported
 
</LI>
</UL>

<P>
To use the patch method the user may create their Fields on any stagger location (e.g. <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN>) for a Grid, or
 any Mesh location (e.g. <SPAN style="font-family:monospace">ESMF_MESHLOC_NODE</SPAN>) for a Mesh. For either a Grid or a Mesh, the location upon which the Field is built 
 must contain coordinates. This method will also work with a destination Field built on a LocStream that contains coordinates, 
 or with a source or destination Field built on an XGrid.

<P>

<H3><A ID="SECTION05012300000000000000"></A><A ID="sec:interpolation:neareststod"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Interpolation methods: nearest source to destination
</H3>
In nearest source to destination interpolation (<SPAN style="font-family:monospace">ESMF_REGRIDMETHOD_NEAREST_STOD</SPAN>) each destination point is mapped to the closest source point. A given source point may map to multiple destination points, but no destination point will receive input from more than one source point. If two points are equally close, then the point with the smallest sequence index is arbitrarily used (i.e. the point which would have the smallest index in the weight matrix). 

<P>

<P></P>

<P>
In 2D, ESMF supports nearest source to destination regridding between any combination of the following:
 
<UL>
<LI>Structured Grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of polygons with any number of sides
</LI>
<LI>A set of disconnected points (<SPAN style="font-family:monospace">ESMF_LocStream</SPAN>) 
</LI>
<LI>An exchange grid (<SPAN style="font-family:monospace">ESMF_XGrid</SPAN>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports nearest source to destination regridding between any combination of the following:
 
<UL>
<LI>Structured Grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured Meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of hexahedrons (e.g. cubes) and tetrahedrons
</LI>
<LI>A set of disconnected points (<SPAN style="font-family:monospace">ESMF_LocStream</SPAN>) 
 
</LI>
</UL>

<P>

<P></P>

<P>
<SPAN  CLASS="textbf">Restrictions:</SPAN>
<BR>
<SPAN  CLASS="textit">NONE</SPAN>

<P>

<P></P>

<P>
To use the nearest source to destination method the user may create their Fields on any stagger location (e.g. <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN>) for a Grid, or
 any Mesh location (e.g. <SPAN style="font-family:monospace">ESMF_MESHLOC_NODE</SPAN>) for a Mesh. For either a Grid or a Mesh, the location upon which the Field is built 
 must contain coordinates. This method will also work with a source or destination Field built on a LocStream that contains coordinates, or when the source 
or destination Field is built on an XGrid.

<P>

<H3><A ID="SECTION05012400000000000000"></A><A ID="sec:interpolation:nearestdtos"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Interpolation methods: nearest destination to source
</H3>
In nearest destination to source interpolation (<SPAN style="font-family:monospace">ESMF_REGRIDMETHOD_NEAREST_DTOS</SPAN>) each source point is mapped to the closest destination point. A given destination point may receive input from multiple source points, but no source point will map to more than one destination point. If two points are equally close, then the point with the smallest sequence index is arbitrarily used (i.e. the point which would have the smallest index in the weight matrix). Note that with this method the unmapped destination point detection currently doesn't work, so no error will be returned even if there are destination points that don't map to any source point. 

<P>

<P></P>

<P>
In 2D, ESMF supports nearest destination to source regridding between any combination of the following:
 
<UL>
<LI>Structured Grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of polygons with any number of sides
</LI>
<LI>A set of disconnected points (<SPAN style="font-family:monospace">ESMF_LocStream</SPAN>) 
</LI>
<LI>An exchange grid (<SPAN style="font-family:monospace">ESMF_XGrid</SPAN>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports nearest destination to source regridding between any combination of the following:
 
<UL>
<LI>Structured Grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured Meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of hexahedrons (e.g. cubes) and tetrahedrons
</LI>
<LI>A set of disconnected points (<SPAN style="font-family:monospace">ESMF_LocStream</SPAN>) 
 
</LI>
</UL>

<P>

<P></P>

<P>
<SPAN  CLASS="textbf">Restrictions:</SPAN>
<BR>

<UL>
<LI>The unmapped destination point detection doesn't currently work for this method. Even if there are unmapped points, no error will be returned. 
</LI>
</UL>

<P>

<P></P>

<P>
To use the nearest destination to source method the user may create their Fields on any stagger location (e.g. <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN>) for a Grid, or
 any Mesh location (e.g. <SPAN style="font-family:monospace">ESMF_MESHLOC_NODE</SPAN>) for a Mesh. For either a Grid or a Mesh, the location upon which the Field is built 
 must contain coordinates. This method will also work with a source or destination Field built on a LocStream that contains coordinates, or when the source 
or destination Field is built on an XGrid.

<P>

<H3><A ID="SECTION05012500000000000000"></A><A ID="sec:interpolation:conserve"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Interpolation methods: first-order conservative
</H3>
 The goal of this method is to preserve the integral of the field across the interpolation from source to destination.  
 (For a more in-depth description of what this preservation of the integral (i.e. conservation) means please see section&nbsp;<A HREF="#sec:interpolation:conservation">24.2.7</A>.)  In this method the value across each source cell is treated as a constant, so it will typically have a larger 
 interpolation error than the bilinear or patch methods.  The first-order method used here is similar to that described in the following paper&nbsp;[<A
 HREF="node8.html#ConservativeOrder1">18</A>].

<P>
In the first-order method, the values for a particular destination cell are a calculated as a combination of the values of the intersecting 
 source cells. The weight of a given source cell's contribution 
 to the total being the amount that that source cell overlaps with the destination cell. 
 In particular, the weight is the ratio of the area of intersection of the source and destination cells to the area of the whole destination cell. 

<P>
To see a description of how the different normalization options affect the values and integrals produced by the conservative methods see section&nbsp;<A HREF="#sec:interpolation:conservative_norm_opts">24.2.8</A>. For Grids, Meshes, or XGrids on a sphere this method uses great circle cells, for a description of potential problems with these see&nbsp;<A HREF="#sec:interpolation:great_circle_cells">24.2.9</A>.

<P>

<P></P>

<P>
In 2D, ESMF supports conservative regridding between any combination of the following:
 
<UL>
<LI>Structured Grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of polygons with any number of sides
</LI>
<LI>An exchange grid (<SPAN style="font-family:monospace">ESMF_XGrid</SPAN>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports conservative regridding between any combination of the following:
 
<UL>
<LI>Structured Grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of a single logically rectangular tile
</LI>
<LI>Unstructured Meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of hexahedrons (e.g. cubes) and tetrahedrons
 
</LI>
</UL>

<P>

<P></P>

<P>
<B>Restrictions:</B>
 
<UL>
<LI>Cells which contain enough identical corners to collapse to a line or point are optionally (via a flag) either ignored or return an error
</LI>
<LI>Self-intersecting cells (e.g. a cell twisted into a bow tie) are not supported
</LI>
<LI>On a spherical grid, cells which contain an edge which extends more than half way around the sphere are not supported 
</LI>
<LI>Source or destination Fields built on a Grid which contains a DE of width less than 2 elements are not supported
 
</LI>
</UL>

<P>

<P></P>

<P>
To use the conservative method the user should create their Fields on the center 
 stagger location (<SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN> in 2D or <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER_VCENTER</SPAN> in 3D) for Grids  or the element location (<SPAN style="font-family:monospace">ESMF_MESHLOC_ELEMENT</SPAN>) for Meshes.
 For Grids, the corner stagger location (<SPAN style="font-family:monospace">ESMF_STAGGERLOC_CORNER</SPAN> in 2D or <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CORNER_VFACE</SPAN> in 3D) must contain coordinates describing the outer perimeter of the Grid cells. This method will also work when the source or destination Field is built on an XGrid.

<P>

<H3><A ID="SECTION05012600000000000000"></A><A ID="sec:interpolation:conserve_2ndorder"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Interpolation methods: second-order conservative
</H3>
 Like the first-order conservative method, this method's goal is to preserve the integral of the field across the interpolation from source to destination.  
 (For a more in-depth description of what this preservation of the integral (i.e. conservation) means please see section&nbsp;<A HREF="#sec:interpolation:conservation">24.2.7</A>.)  The difference between the first and second-order conservative methods is that the second-order takes the source gradient into account, so
 it yields a smoother destination field that typically better matches the source field. This difference between the first and second-order methods 
 is particularly apparent when going from a coarse source grid to a finer destination grid. Another difference is that the second-order method
  does not guarantee that after regridding the range of values in the destination field is within the range of 
 values in the source field. For example, if the mininum value in the source field is 0.0, then it's possible that after regridding with the 
 second-order method, the destination field will contain values less than 0.0.  The implementation of this method is based on the one 
  described in this paper&nbsp;[<A
 HREF="node8.html#ConservativeOrder2">12</A>]. 

<P>
Like the first-order method, the values for a particular destination cell with the second-order method
 are a combination of the values of the intersecting source cells with the weight of a given source cell's contribution to the total 
 being the amount that that source cell overlaps with the destination cell. 
 However, with the second-order conservative interpolation there are additional terms that take into account the gradient of the field 
 across the source cell. In particular, the value <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.76ex; vertical-align: -0.11ex; " SRC="img24.svg"
 ALT="$d$"></SPAN> for a given destination cell is calculated as:

<P>
<!-- MATH
 $d=\sum^{intersecting-source-cells}_{i}(s_{i}+\nabla s_{i} \cdot (c_{si}-c_{d}))$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.08ex; vertical-align: -0.78ex; " SRC="img25.svg"
 ALT="$d=\sum^{intersecting-source-cells}_{i}(s_{i}+\nabla s_{i} \cdot (c_{si}-c_{d}))$"></SPAN>

<P>

<P></P>

<P>
Where:
<BR>
<DL>
<DD></DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.51ex; vertical-align: -0.44ex; " SRC="img26.svg"
 ALT="$s_{i}$"></SPAN></STRONG></DT>
<DD>is the intersecting source cell value. 
  
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG
 STYLE="height: 2.07ex; vertical-align: -0.44ex; " SRC="img27.svg"
 ALT="$\nabla s_{i}$"></SPAN></STRONG></DT>
<DD>is the intersecting source cell gradient. 
  
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.51ex; vertical-align: -0.44ex; " SRC="img28.svg"
 ALT="$c_{si}$"></SPAN></STRONG></DT>
<DD>is the intersecting source cell centroid. 
  
</DD>
<DT><STRONG><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.51ex; vertical-align: -0.44ex; " SRC="img29.svg"
 ALT="$c_{d}$"></SPAN></STRONG></DT>
<DD>is the destination cell centroid. 
</DD>
</DL>

<P>

<P></P>

<P>
To see a description of how the different normalization options affect the values and integrals produced by the conservative methods see section&nbsp;<A HREF="#sec:interpolation:conservative_norm_opts">24.2.8</A>. For Grids, Meshes, or XGrids on a sphere this method uses great circle cells, for a description of potential problems with these see&nbsp;<A HREF="#sec:interpolation:great_circle_cells">24.2.9</A>.

<P>

<P></P>

<P>
In 2D, ESMF supports second-order conservative regridding between any combination of the following:
 
<UL>
<LI>Structured Grids (<SPAN style="font-family:monospace">ESMF_Grid</SPAN>) composed of any number of logically rectangular tiles
</LI>
<LI>Unstructured meshes (<SPAN style="font-family:monospace">ESMF_Mesh</SPAN>) composed of polygons with any number of sides
</LI>
<LI>An exchange grid (<SPAN style="font-family:monospace">ESMF_XGrid</SPAN>)
 
</LI>
</UL>

<P>

<P></P>

<P>
In 3D, ESMF supports second-order conservative regridding between any combination of the following:
 
<UL>
<LI>NONE
 
</LI>
</UL>

<P>

<P></P>

<P>
<B>Restrictions:</B>
 
<UL>
<LI>Cells which contain enough identical corners to collapse to a line or point are optionally (via a flag) either ignored or return an error
</LI>
<LI>Self-intersecting cells (e.g. a cell twisted into a bow tie) are not supported
</LI>
<LI>On a spherical grid, cells which contain an edge which extends more than half way around the sphere are not supported 
</LI>
<LI>Source or destination Fields built on a Grid which contains a DE of width less than 2 elements are not supported
 
</LI>
</UL>

<P>

<P></P>

<P>
To use the second-order conservative method the user should create their Fields on the center 
 stagger location (<SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN> for Grids  or the element location (<SPAN style="font-family:monospace">ESMF_MESHLOC_ELEMENT</SPAN>) for Meshes.
 For Grids, the corner stagger location (<SPAN style="font-family:monospace">ESMF_STAGGERLOC_CORNER</SPAN> in 2D must contain coordinates describing the outer perimeter of the Grid cells. 
 This method will also work when the source or destination Field is built on an XGrid.

<P>

<H3><A ID="SECTION05012700000000000000"></A><A ID="sec:interpolation:conservation"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Conservation
</H3>
 Conservation means that the following equation will hold:  <!-- MATH
 $\sum^{all-source-cells}(V_{si}*A_{si}) = \sum^{all-destination-cells}(V_{dj}*A_{dj})$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.04ex; vertical-align: -0.75ex; " SRC="img30.svg"
 ALT="$\sum^{all-source-cells}(V_{si}*A_{si}) = \sum^{all-destination-cells}(V_{dj}*A_{dj})$"></SPAN>, where
 V is the variable being regridded and A is the area of a cell.  The subscripts s and d refer to source and destination values, and the i and j are the source  and destination grid cell indices (flattening the arrays to 1 dimension). 

<P>
If the user doesn't specify a cell areas in the involved Grids or Meshes, then the areas (A) in the above equation are calculated by ESMF. 
 For Cartesian grids, the area of a grid cell calculated by ESMF is the typical Cartesian area. 
 For grids on a sphere, cell areas are calculated by connecting the corner coordinates of each grid cell with great circles. If the user 
 does specify the areas in the Grid or Mesh, then the conservation will be adjusted to work for the areas 
 provided by the user. This means that the above equation will hold, but with the areas (A) being the ones specified by the user.

<P>
The user should be aware that because of the conservation relationship between the source and destination fields, the more the total source area
 differs from the total destination area the more the values of the source field will differ from the corresponding values of the destination field, 
 likely giving a higher interpolation error. It is best to have the total source and destination areas the same 
 (this will automatically be true if no user areas are specified). For source and destination grids 
 that only partially overlap, the overlapping regions of the source and destination should be the same.

<P>

<H3><A ID="SECTION05012800000000000000"></A><A ID="sec:interpolation:conservative_norm_opts"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> The effect of normalization options on integrals and values produced by conservative methods
</H3>
 It is important to note that by default (i.e. using destination area normalization) 
conservative regridding doesn't normalize the interpolation weights by the destination fraction. 
This means that for a destination grid which only partially overlaps the source grid
the destination field that is output from the regrid operation 
should be divided by the corresponding destination fraction to yield the 
true interpolated values for cells which are only partially covered by the source grid. 
The fraction also needs to be included when computing the total source and destination integrals. 
(To include the fraction in the conservative weights, the user can specify 
the fraction area normalization type. This can be done by specifying <SPAN style="font-family:monospace">normType=ESMF_NORMTYPE_FRACAREA</SPAN> when
invoking <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN>.)

<P>
For weights generated using destination area normalization (either by not specifying any normalization type or by specifying <SPAN style="font-family:monospace">normType=ESMF_NORMTYPE_DSTAREA</SPAN>), if a destination field extends 
outside the unmasked source field, then the values of the cells which 
extend partway outside the unmasked source field are decreased by the fraction they extend outside. 
To correct these values, the destination field (<SPAN style="font-family:monospace">dst_field</SPAN>) resulting
from the <SPAN style="font-family:monospace">ESMF_FieldRegrid()</SPAN> call can be divided by the destination fraction <SPAN style="font-family:monospace">dst_frac</SPAN> 
from the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call. The following pseudocode demonstrates  how to do this:

<P>
<PRE>

 for each destination element i
    if (dst_frac(i) not equal to 0.0) then
       dst_field(i)=dst_field(i)/dst_frac(i)
    end if
 end for
</PRE>

<P>
For weights generated using destination area normalization (either by not specifying any normalization type or by specifying <SPAN style="font-family:monospace">normType=ESMF_NORMTYPE_DSTAREA</SPAN>), 
the following pseudo-code shows how to compute the total destination integral (<SPAN style="font-family:monospace">dst_total</SPAN>) given the
destination field values (<SPAN style="font-family:monospace">dst_field</SPAN>) resulting
from the <SPAN style="font-family:monospace">ESMF_FieldRegrid()</SPAN> call, the destination area (<SPAN style="font-family:monospace">dst_area</SPAN>) from the <SPAN style="font-family:monospace">ESMF_FieldRegridGetArea()</SPAN> call,  and the destination fraction (<SPAN style="font-family:monospace">dst_frac</SPAN>) from the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call. As shown in the previous paragraph, it also 
shows how to adjust the destination field (<SPAN style="font-family:monospace">dst_field</SPAN>) resulting from the <SPAN style="font-family:monospace">ESMF_FieldRegrid()</SPAN> call by the
fraction (<SPAN style="font-family:monospace">dst_frac</SPAN>) from the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call: 

<P>
<PRE>

 dst_total=0.0
 for each destination element i
    if (dst_frac(i) not equal to 0.0) then
       dst_total=dst_total+dst_field(i)*dst_area(i) 
       dst_field(i)=dst_field(i)/dst_frac(i)
       ! If mass computed here after dst_field adjust, would need to be:
       ! dst_total=dst_total+dst_field(i)*dst_area(i)*dst_frac(i) 
    end if
 end for
</PRE>

<P>
For weights generated using fraction area normalization (by specifying <SPAN style="font-family:monospace">normType=ESMF_NORMTYPE_FRACAREA</SPAN>),
no adjustment of the destination field is necessary. The following pseudo-code shows how to compute 
the total destination integral (<SPAN style="font-family:monospace">dst_total</SPAN>) given the
destination field values (<SPAN style="font-family:monospace">dst_field</SPAN>) resulting
from the <SPAN style="font-family:monospace">ESMF_FieldRegrid()</SPAN> call, the destination area (<SPAN style="font-family:monospace">dst_area</SPAN>) from the <SPAN style="font-family:monospace">ESMF_FieldRegridGetArea()</SPAN>
call,  and the destination fraction (<SPAN style="font-family:monospace">dst_frac</SPAN>) from the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call:

<P>
<PRE>
 dst_total=0.0
 for each destination element i
      dst_total=dst_total+dst_field(i)*dst_area(i)*dst_frac(i) 
 end for
</PRE>

<P>
For both normalization types, the following pseudo-code shows how to compute the total source integral (<SPAN style="font-family:monospace">src_total</SPAN>) given the source field values
 (<SPAN style="font-family:monospace">src_field</SPAN>), the source area (<SPAN style="font-family:monospace">src_area</SPAN>) from the <SPAN style="font-family:monospace">ESMF_FieldRegridGetArea()</SPAN> call, and
 the source fraction (<SPAN style="font-family:monospace">src_frac</SPAN>) from the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call:

<P>
<PRE>
 src_total=0.0
 for each source element i
    src_total=src_total+src_field(i)*src_area(i)*src_frac(i)
 end for
</PRE>

<P>

<H3><A ID="SECTION05012900000000000000"></A><A ID="sec:interpolation:great_circle_cells"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">9</SPAN> Great circle cells
</H3>
 For Grids, Meshes, or XGrids on a sphere some combinations of interpolation options 
 (e.g. first and second-order conservative methods) use cells whose edges are great circles. This section describes some behavior 
 that the user may not expect from these cells and some potential solutions. 

<P>
A great circle edge isn't necessarily the same as a straight line in latitude longitude space. 
 For small edges, this difference will be small, but for long edges it
 could be significant. This means if the user expects cell edges as straight lines in latitude longitude 
 space, they should avoid using one large cell with 
 long edges to compute an average over a region (e.g. over an ocean basin).

<P>
Also, the  user should also avoid using cells that contain one edge that runs half way or more around the earth, because the 
 regrid weight calculation assumes the edge follows the shorter great circle path. 
 There isn't a unique great circle edge defined between points on the 
 exact opposite side of the earth from one another (antipodal points). 
 However, the user can work around both of these problem by breaking the long edge into two smaller edges by inserting 
 an extra node, or by breaking the large target grid cells 
 into two or more smaller grid cells. This allows the application to resolve the ambiguity in edge direction. 

<P>

<H3><A ID="SECTION050121000000000000000"></A>
<A ID="regrid:masking"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">10</SPAN> Masking
</H3>
Masking is the process whereby parts of a Grid, Mesh, or LocStream 
can be marked to be ignored during an operation, such as when they 
are used in regridding.  Masking can be used on a Field created from 
a regridding source to indicate that certain portions should not be 
used to generate regridded data.  This is useful, for example, if a 
portion of the source contains unusable values.  Masking can also be 
used on a Field created from a regridding destination to indicate 
that a certain portion should not receive regridded data.  This is 
useful, for example, when part of the destination isn't being used 
(e.g. the land portion of an ocean grid).

<P>
The user may mask out points in the source
Field or destination Field or both. To do masking the user sets
mask information in the Grid (see <A HREF="#sec:usage:items"><IMG  ALT="[*]" SRC="crossref.png"></A>), Mesh
(see <A HREF="#sec:mesh:mask"><IMG  ALT="[*]" SRC="crossref.png"></A>), or LocStream (see <A HREF="#const:maskkeyname">32.2.2</A>)
upon which the Fields passed into the
<SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call are built. The <SPAN style="font-family:monospace">srcMaskValues</SPAN>
and <SPAN style="font-family:monospace">dstMaskValues</SPAN> arguments to that
call can then be used to specify which values in that mask
information indicate that a location should be masked out. For
example, if <SPAN style="font-family:monospace">dstMaskValues</SPAN> is set to (/1,2/), then any location that
has a value of 1 or 2 in the mask information of the Grid, Mesh or LocStream
upon which the destination Field is built will be masked out.

<P>
Masking behavior differs slightly between regridding methods. For
non-conservative regridding methods (e.g. bilinear or high-order
patch), masking is done on points. For these methods, masking a
destination point means that that point won't participate in
regridding (e.g. won't be interpolated to). For these methods,
masking a source point means that the entire source cell using
that point is masked out. In other words, if any corner point
making up a source cell is masked then the cell is masked. For
conservative regridding methods (e.g. first-order conservative)
masking is done on cells. Masking a destination cell means that
the cell won't participate in regridding (e.g. won't be
interpolated to). Similarly, masking a source cell means that the
cell won't participate in regridding (e.g. won't be interpolated
from).  For any type of interpolation method (conservative or
non-conservative) the masking is set on the location upon
which the Fields passed into the regridding call are built.
For example, if Fields built on  <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN> are
passed into the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call then the masking
should also be set on <SPAN style="font-family:monospace">ESMF_STAGGERLOC_CENTER</SPAN>.

<P>

<H3><A ID="SECTION050121100000000000000"></A><A ID="sec:extrapolation:overview"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">11</SPAN> Extrapolation methods: overview
</H3>

<P>
Extrapolation in the ESMF regridding system is a way to automatically fill some or all of the 
destination points left unmapped by a regridding method. Weights generated by
the extrapolation method are merged into the regridding weights to yield one set of weights or 
routehandle. Currently extrapolation is not supported with conservative regridding methods, because 
doing so would result in non-conservative weights. 

<P>

<H3><A ID="SECTION050121200000000000000"></A><A ID="sec:extrapolation:neareststod"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">12</SPAN> Extrapolation methods: nearest source to destination
</H3>
In nearest source to destination extrapolation (<SPAN style="font-family:monospace">ESMF_EXTRAPMETHOD_NEAREST_STOD</SPAN>) each unmapped 
destination point is mapped to the closest source point. A given source point may map to 
multiple destination points, but no destination point will receive input from more than one source point. 
If two points are equally close, then the point with the smallest sequence index is arbitrarily used 
(i.e. the point which would have the smallest index in the weight matrix). 

<P>
If there is at least one unmasked source point, then this method is expected to fill all unmapped points. 

<P>

<H3><A ID="SECTION050121300000000000000"></A><A ID="sec:extrapolation:nearestidavg"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">13</SPAN> Extrapolation methods: inverse distance weighted average
</H3>
In inverse distance weighted average extrapolation (<SPAN style="font-family:monospace">ESMF_EXTRAPMETHOD_NEAREST_IDAVG</SPAN>) each unmapped 
destination point is the weighted average of the closest N source points. The weight is 
the reciprocal of the distance of the source point from the destination point raised to a power P.
All the weights contributing to one destination point are normalized so that they sum to 1.0. 
The user can choose N and P when using this method, but defaults are also provided. For example, when 
calling <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> N is specified via the argument <SPAN style="font-family:monospace">extrapNumSrcPnts</SPAN> and 
P is specified via the argument <SPAN style="font-family:monospace">extrapDistExponent</SPAN>.  

<P>
If there is at least one unmasked source point, then this method is expected to fill all unmapped points. 

<P>

<H3><A ID="SECTION050121400000000000000"></A><A ID="sec:extrapolation:creep"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">14</SPAN> Extrapolation methods: creep fill
</H3>
In creep fill extrapolation (<SPAN style="font-family:monospace">ESMF_EXTRAPMETHOD_CREEP</SPAN>) unmapped destination points are filled by 
repeatedly moving data from mapped locations to neighboring unmapped locations for a user specified 
number of levels. More precisely, for each creeped point, its value is the average of the values of the 
point's immediate neighbors in the previous level. For the first level, the values are the average of the 
point's immediate neighbors in the destination points mapped by the regridding method. The number of creep levels
is specified by the user. For example, in ESMF_FieldRegridStore() this number of levels is specified 
via the <SPAN style="font-family:monospace">extrapNumLevels</SPAN> argument. 

<P>
Unlike some extrapolation methods, creep fill does not necessarily 
fill all unmapped destination points. Unfilled destination points are still unmapped with the usual 
consequences (e.g. they won't be in the resulting regridding matrix, and won't be set by the application 
of the regridding weights).

<P>
Because it depends on the connections in the destination grid, creep fill extrapolation is not supported when the 
destination Field is built on a Location Stream (ESMF_LocStream). Also, creep fill is currently only supported for 
2D Grids, Meshes, or XGrids

<P>

<H3><A ID="SECTION050121500000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">15</SPAN> Unmapped destination points</A>
</H3>
 If a destination point can't be mapped to a location in the source grid by the combination of regrid method and 
 optional follow on extrapolation method, then the user has two choices. The user may ignore those destination points
 that can't be mapped by setting the <SPAN style="font-family:monospace">unmappedaction</SPAN> argument to <SPAN style="font-family:monospace">ESMF_UNMAPPEDACTION_IGNORE</SPAN> (Ignored points won't be included in
 the sparse matrix or routeHandle). If the user needs the unmapped points, the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> method has the capability to return
 a list of them using the <SPAN style="font-family:monospace">unmappedDstList</SPAN> argument.  In addition to ignoring them, the user also has the option to return
 an error if unmapped destination points exist. This is the default behavior, so the user can either not set the <SPAN style="font-family:monospace">unmappedaction</SPAN> argument
 or the user can set it to <SPAN style="font-family:monospace">ESMF_UNMAPPEDACTION_ERROR</SPAN>. Currently, the unmapped destination error detection doesn't 
 work with the nearest destination to source regrid method (<SPAN style="font-family:monospace">ESMF_REGRIDMETHOD_NEAREST_DTOS</SPAN>), so with this method the regridding 
 behaves as if <SPAN style="font-family:monospace">ESMF_UNMAPPEDACTION_IGNORE</SPAN> is always on. 

<P>

<H3><A ID="SECTION050121600000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">16</SPAN> Spherical grids and poles</A>
</H3>
In the case that the Grid is on a sphere (<SPAN style="font-family:monospace">coordSys=ESMF_COORDSYS_SPH_DEG or ESMF_COORDSYS_SPH_RAD</SPAN>)
then the coordinates given in the Grid are interpreted as latitude and longitude values. The coordinates can either be in degrees or radians as indicated by the 
<SPAN style="font-family:monospace">coordSys</SPAN> flag set during Grid creation. As is true with many global models, this application currently assumes the latitude and longitude refer to positions on a 
perfect sphere, as opposed to a more complex and accurate representation of the Earth's true shape such as would be used in a GIS system. (ESMF's current user base doesn't 
require this level of detail in representing the Earth's shape, but it could be added in the future if necessary.)

<P>
For Grids on a sphere, the regridding occurs in 3D Cartesian to avoid
problems with periodicity and with the pole singularity. This library
 supports four options for handling the pole region (i.e. the empty area above the top row of the source grid or below
 the bottom row of the source grid).  Note that all of these pole options currently only work for the Fields build on the Grid class.

<P>
The first option is to leave the pole region empty (<SPAN style="font-family:monospace">polemethod=ESMF_POLEMETHOD_NONE</SPAN>), in this 
 case if a destination point lies above or below the 
 top row of the source grid, it will fail to map, yielding an error (unless <SPAN style="font-family:monospace">unmappedaction=ESMF_UNMAPPEDACTION_IGNORE</SPAN> is specified).  

<P>
With the next two options (<SPAN style="font-family:monospace">ESMF_POLEMETHOD_ALLAVG</SPAN> and <SPAN style="font-family:monospace">ESMF_POLEMETHOD_NPNTAVG</SPAN>), the pole region is handled by constructing 
 an artificial pole in the center of the top and bottom row of grid points and then filling
 in the region from this pole to the edges of the source grid with triangles. 
 The pole is located at the average of the position of the points surrounding
 it, but moved outward to be at the same radius as the rest of the points
 in the grid. The difference between the two artificial pole options is what value is used at the pole. 
 The option (<SPAN style="font-family:monospace">polemethod=ESMF_POLEMETHOD_ALLAVG</SPAN>) sets the value at the pole to be the average of the values
 of all of the grid points surrounding the pole. The option (<SPAN style="font-family:monospace">polemethod=ESMF_POLEMETHOD_NPNTAVG</SPAN>) allows the user to choose
 a number N from 1 to the number of source grid points around the pole. The value N is set via the argument <SPAN style="font-family:monospace">regridPoleNPnts</SPAN>. For
 each destination point, the value at the pole is then the average of the N source points
 surrounding that destination point. 

<P>
The last option (<SPAN style="font-family:monospace">polemethod=ESMF_POLEMETHOD_TEETH</SPAN>) does not construct an artificial pole, instead the
 pole region is covered by connecting points across the top and bottom row of the source Grid into triangles. As 
 this makes the top and bottom of the source sphere flat, for a big enough difference between the size of
 the source and destination pole regions, this can still result in unmapped destination points.  
 Only pole option <SPAN style="font-family:monospace">ESMF_POLEMETHOD_NONE</SPAN> is currently supported with the conservative interpolation methods 
 (e.g. <SPAN style="font-family:monospace">regridmethod=ESMF_REGRIDMETHOD_CONSERVE</SPAN>) and with the nearest neighbor interpolation options (e.g. <SPAN style="font-family:monospace">regridmethod=ESMF_REGRIDMETHOD_NEAREST_STOD</SPAN>).

<P>
<BR><P></P>
<DIV class="CENTER"><A ID="line_type_support"></A><A ID="1674"></A>
<TABLE>
<CAPTION><STRONG>Table 2:</STRONG>
Line Type Support by Regrid Method (* indicates the default)</CAPTION>
<TR><TD>
<DIV class="CENTER">
<BR>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Regrid Method</TD>
<TD CLASS="CENTER" COLSPAN=2><SPAN>Line Type</SPAN></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">ESMF_LINETYPE_CART</TD>
<TD CLASS="LEFT">ESMF_LINETYPE_GREAT_CIRCLE</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_REGRIDMETHOD_BILINEAR</TD>
<TD CLASS="LEFT">Y*</TD>
<TD CLASS="LEFT">Y</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_REGRIDMETHOD_PATCH</TD>
<TD CLASS="LEFT">Y*</TD>
<TD CLASS="LEFT">Y</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_REGRIDMETHOD_NEAREST_STOD</TD>
<TD CLASS="LEFT">Y*</TD>
<TD CLASS="LEFT">N</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_REGRIDMETHOD_NEAREST_DTOS</TD>
<TD CLASS="LEFT">Y*</TD>
<TD CLASS="LEFT">N</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_REGRIDMETHOD_CONSERVE</TD>
<TD CLASS="LEFT">N/A</TD>
<TD CLASS="LEFT">Y*</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_REGRIDMETHOD_CONSERVE_2ND</TD>
<TD CLASS="LEFT">N/A</TD>
<TD CLASS="LEFT">Y*</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="CENTER">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
</TR>
</TABLE>

</DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
Another variation in the regridding supported with spherical grids is <B>line type</B>. This is controlled in the
<SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> method by the <SPAN style="font-family:monospace">lineType</SPAN> argument. This argument allows the user to select the path of the line which connects
two points on a sphere surface. This in turn controls the path along which distances are calculated and the shape of 
the edges that make up a cell. Both of these quantities can influence how interpolation weights are calculated, for example in
bilinear interpolation the distances are used to calculate the weights and the cell edges are used to determine to which source 
cell a destination point should be mapped. 

<P>
ESMF currently supports two line types: ESMF_LINETYPE_CART and ESMF_LINETYPE_GREAT_CIRCLE. The ESMF_LINETYPE_CART option 
specifies that the line between two points follows a straight path through the 3D Cartesian space in which the sphere is embedded.
Distances are measured along 
this 3D Cartesian line. Under this option cells are approximated by planes in 3D space, and their boundaries are 3D Cartesian lines
between their corner points.  The ESMF_LINETYPE_GREAT_CIRCLE option specifies that the line between two points follows
a great circle path along the sphere surface. (A great circle is the shortest path between two points on a sphere.) 
Distances are measured along the great circle path. Under this option cells are on the sphere surface, and their boundaries 
are great circle paths between their corner points. 

<P>
Figure&nbsp;<A HREF="#line_type_support">24.2.16</A> shows which line types are supported for each regrid method as well as the defaults (indicated by *).

<P>

<H3><A ID="SECTION050121700000000000000"></A><A ID="sec::vectorRegrid"></A>
<BR>
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">17</SPAN> Vector regridding
</H3>

<P>
ESMF's initial vector regridding capability is intended to give cleaner results for 2D spherical vectors expressed in
terms of local directions (e.g. east and north) than regridding each vector component separately. To do this, it
converts the vectors to 3D Cartesian space and then does the regridding there. This allows all the vectors participating in
the regridding to have a consistent representation. After regridding, the resulting 3D vectors are then converted
back to the local direction form. This entire process is expressed in the usual weight matrix and/or routeHandle form and so
the typical <SPAN style="font-family:monospace">ESMF_FieldRegridStore()/ESMF_FieldRegrid()/ESMF_FieldRegridRelease()</SPAN> regridding paradigm can be used.
However, the weight matrix will be in the format that allows it to contain tensor dimension indices (i.e. the leading
dimension of the <SPAN style="font-family:monospace">factorIndexList</SPAN> will be of size 4). 

<P>
In this initial version, the meaning of the different entries in the vector dimension are fixed. They will be interpreted as:
<BR>
<DL>
<DD></DD>
<DT><STRONG>1st entry</STRONG></DT>
<DD>the east component of the vector
  
</DD>
<DT><STRONG>2nd entry</STRONG></DT>
<DD>the north component of the vector
</DD>
</DL>

<P>
Note that because the different components are mixed, using vector regridding with a conservative regrid method will not necessarily produce vectors whose components are conservative. 

<P>

<H3><A ID="SECTION050121800000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">18</SPAN> Troubleshooting guide</A>
</H3>

<P>
The below is a list of problems users commonly encounter with regridding and potential solutions. 
 This is by no means an exhaustive list, so if none of these problems fit your case, or if the solutions
 don't fix your problem, please feel free to email esmf support (esmf_support@ucar.edu).

<P>

<P><P>
<BR>

<P>
<B>Problem:</B> Regridding is too slow.

<P>

<P>
<BR>

<P>
<B>Possible Cause:</B> The <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> method is called more than is necessary. <BR>
The <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> operation is a complex one and can be 
 relatively slow for some cases (large Grids, 3D grids, etc.) 

<P>

<P></P>

<P>
<B>Solution:</B> Reduce the number of <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> calls to the minimum necessary. The
 routeHandle generated by the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call depends on only four factors: the 
 stagger locations that the input Fields are created on, the coordinates in the Grids the input Fields
 are built on at those stagger locations, the padding of the input Fields 
 (specified by the <SPAN style="font-family:monospace">totalWidth</SPAN> arguments in <SPAN style="font-family:monospace">FieldCreate</SPAN>) and the size of the tensor
 dimensions in the input Fields (specified by the <SPAN style="font-family:monospace">ungridded</SPAN> arguments in <SPAN style="font-family:monospace">FieldCreate</SPAN>). 
 For any pair of Fields which share these attributes with the Fields used in the
 <SPAN style="font-family:monospace">ESMF_FieldRegridStore</SPAN> call  the same routeHandle can be used. Note that the data in the 
 Fields does NOT matter, the same routeHandle can be used no matter how the data in the Fields changes.

<P>

<P></P>

<P>
In particular:
 
<UL>
<LI>If Grid coordinates do not change during a run, then the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call can be
 done once between a pair of Fields at the beginning and the resulting routeHandle used for each 
 timestep during the run. 

<P>
</LI>
<LI>If a pair of Fields was created with exactly the same arguments to <SPAN style="font-family:monospace">ESMF_FieldCreate()</SPAN> as the 
 pair of Fields used during an <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call, then the resulting routeHandle can 
 also be used between that pair of Fields. 
 
</LI>
</UL>

<P>

<P><P>
<BR>

<P>
<B>Problem:</B> Distortions in destination Field at periodic boundary.

<P>

<P>
<BR>

<P>
<B>Possible Cause:</B> The Grid overlaps itself. With a periodic Grid, the regrid system expects
  the first point to not be a repeat of the last point. In other words,
  regrid constructs its own connection and overlap between the first and last points of the
  periodic dimension and so the Grid doesn't need to contain these. If the Grid does, then this
  can cause problems. 

<P>

<P></P>

<P>
<B>Solution:</B> Define the Grid so that it doesn't contain the overlap point. This typically means simply making
 the Grid one point smaller in the periodic dimension.  If a Field 
 constructed on the Grid needs to contain these overlap points then the user can use the
 <SPAN style="font-family:monospace">totalWidth</SPAN> arguments to include this extra padding in the Field. Note, however, 
 that the regrid won't update these extra points, so the user will have to do a copy to fill the points
 in the overlap region in the Field.  

<P>

<H3><A ID="SECTION050121900000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">19</SPAN> Restrictions and Future Work</A>
</H3>
This section contains restrictions that apply to the entire regridding system. For restrictions that apply to just one interpolation method, see the section corresponding to that method above.

<P>

<UL>
<LI><B>Regridding doesn't work on a Field created on a Grid with an arbitrary distribution:</B> Using a Field built on a Grid with an arbitrary distribution will cause the regridding to stop with an error.  

<P>
</LI>
</UL>

<P>

<H3><A ID="SECTION050122000000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">20</SPAN> Design and implementation notes</A>
</H3>

<P>
The ESMF regrid weight calculation functionality has been designed to enable it to support a wide range
of grid and interpolation types without needing to support each individual combination of source grid type,
destination grid type, and interpolation method. To avoid the quadratic growth of the number of pairs
of grid types, all grids are converted to a common internal format and the regrid weight calculation
is performed on that format. This vastly reduces the variety of grids that need to be supported in 
the weight calculations for each interpolation method. It also has the added benefit of making it
straightforward to add new grid types and to allow them to work with all the existing grid types.
To hook into the existing weight calculation code, the new type just needs to be converted to the
internal format. 

<P>
The internal grid format used by the ESMF regrid weight calculation is a finite element
unstructured mesh. This was chosen because it was the most general format and all the others could be 
converted to it. The ESMF finite element unstructured mesh (ESMF FEM) is similar in some respects to the SIERRA&nbsp;[<A
 HREF="node8.html#Sierra">13</A>] package 
developed at Sandia National Laboratory. The ESMF code relies on some of the same underlying toolkits (e.g. Zoltan&nbsp;[<A
 HREF="node8.html#Zoltan">11</A>] library 
for calculating mesh partitions) and adds a layer on top that allows the calculation of regrid weights and some mesh operations 
(e.g. mesh redistribution) that ESMF needs. The ESMF FEM has similar notions to SIERRA about the basic structure of the
mesh entities, fields, iteration and a similar notion of parallel distribution. 

<P>
Currently we use the ESMF FEM internal mesh to hold the structure of our Mesh class and 
in our regrid weight calculation. The parts of the internal FEM code that are used/tested by ESMF are the following:

<UL>
<LI>The creation of a mesh composed of triangles and quadrilaterals or hexahedrons and tetrahedrons.
</LI>
<LI>The object relations data base to store the connections between objects (e.g. which element contains which nodes).
</LI>
<LI>The fields to hold data (e.g. coordinates). We currently only build fields on nodes and elements (2D and 3D).
</LI>
<LI>Iteration to move through mesh entities.
</LI>
<LI>The parallel code to maintain information about the distribution of the mesh across processors and to communicate data between parts of the mesh on different processors (i.e. halos).
</LI>
</UL>

<P>

<H2><A ID="SECTION05013000000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">3</SPAN> File-based Regrid API</A>
</H2>&nbsp;<A ID="sec:filebasedregrid"></A>
<P>

<H2><A ID="SECTION05014000000000000000">
<SPAN CLASS="arabic">24</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<OL>
<LI><B>32-bit index limitation:</B> Currently all index space dimensions in an ESMF object are represented by signed 32-bit integers. This limits the number of elements in one-dimensional objects to the 32-bit limit. This limit can be crossed by higher dimensional objects, where the product space is only limited by the 64-bit sequence index representation.
</LI>
</OL>

<H1><A ID="SECTION05020000000000000000">
<SPAN CLASS="arabic">25</SPAN> FieldBundle Class</A>
</H1>

<H2><A ID="SECTION05021000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
A FieldBundle functions mainly as a convenient container for storing
similar Fields.  It represents &ldquo;bundles&rdquo; of Fields that are 
discretized on the same Grid, Mesh, LocStream, or XGrid and distributed in the same manner.
The FieldBundle is an important data structure because it can be added to a State, 
which is used for sending and receiving data between Components.

<P>
In the common case where FieldBundle is built on top of a Grid,
Fields within a FieldBundle may be located at different locations relative 
to the vertices of their common Grid.  The Fields in a FieldBundle may
be of different dimensions, as long as the Grid dimensions that 
are distributed are the same.  For example, a surface Field on 
a distributed lat/lon Grid and a 3D Field with an added vertical 
dimension on the same distributed lat/lon Grid can be included
in the same FieldBundle.

<P>
FieldBundles can be created and destroyed, can have Attributes 
added or retrieved, and can have Fields added, removed, replaced, or retrieved.
Methods include queries that return information about the FieldBundle
itself and about the Fields that it contains.  The Fortran 
data pointer of a Field within a FieldBundle can be obtained 
by first retrieving the Field with a call to <SPAN style="font-family:monospace">ESMF_FieldBundleGet()</SPAN>,
and then using <SPAN style="font-family:monospace">ESMF_FieldGet()</SPAN> to get the data.

<P>
In the future FieldBundles will serve as a mechanism for performance
optimization.  ESMF will take advantage of the similarities of the
Fields within a FieldBundle to optimize collective communication,
I/O, and regridding.  See Section <A HREF="#sec:bundlerest">25.3</A> for a
description of features that are scheduled for future work.

<H2><A ID="SECTION05022000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
Examples of creating, accessing and destroying FieldBundles and their
constituent Fields are provided in this section, along with some
notes on FieldBundle methods.

<H2><A ID="SECTION05023000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>
<A ID="sec:bundlerest"></A>
<P>

<OL>
<LI><B>No enforcement of the <EM>same</EM> Grid, Mesh, LocStream, or XGrid 
restriction.</B>
While the documentation indicates in several places (including the Design and
Implementation Notes) that a FieldBundle can only contain Fields that are built
on the same Grid, Mesh, LocStream, or XGrid, and all Fields must have the same
distribution, the actual FieldBundle implementation is more general and
supports bundling of any Fields. The documentation, however, is
in line with the long term plan of making the restrictive FieldBundle definition
the default behavior. The more general bundling option would then be retained
as a special case that requires explicit specification by the user.
There is currently no functional difference in the FieldBundle implementation
that profits from the documented restrictive approach. In addition, the general
bundling option has been supported for a long time. Note however that the
documented restrictive behavior is the anticipated long term default for
FieldBundles.

<P>
</LI>
<LI><B>No mathematical operators.</B>
The FieldBundle class does not support differential or other
mathematical operators.  We do not anticipate providing this 
functionality in the near future.

<P>
</LI>
<LI><B>Limited validation and print options.</B>
We are planning to increase the number of validity checks available
for FieldBundles as soon as possible.  We also will
be working on print options.

<P>
</LI>
<LI><B>Packed data has limited supported.</B>
One of the options that we are currently working on for FieldBundles is
packing.  Packing means that the data from all the
Fields that comprise the FieldBundle are manipulated collectively.
This operation can be done without 
destroying the original Field data.  Packing is being designed to 
facilitate optimized regridding, data communication, and I/O operations.
This will reduce the latency overhead of the communication.  

<P>
<B>CAUTION:</B> For communication methods, the undistributed dimension representing
the number of fields must have identical size between source and destination packed
data. Communication methods do not permute the order of fields in the source
and destination packed FieldBundle.

<P>
</LI>
<LI><B>Interleaving Fields within a FieldBundle.</B>
Data locality is important for performance on some computing
platforms.  An interleave option will be added to allow the user to create
a packed FieldBundle in which Fields are either concatenated in memory
or in which Field elements are interleaved.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION05024000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI><B>Fields in a FieldBundle reference the same Grid, Mesh, LocStream, or XGrid.</B>
In order to reduce memory requirements and ensure consistency, the 
Fields within a FieldBundle all reference the same Grid, Mesh, 
LocStream, or XGrid object. This restriction may be relaxed in the future.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION05025000000000000000">
<SPAN CLASS="arabic">25</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API: Basic FieldBundle Methods</A>
</H2>

<H1><A ID="SECTION05030000000000000000">
<SPAN CLASS="arabic">26</SPAN> Field Class</A>
</H1>

<H2><A ID="SECTION05031000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
An ESMF Field represents a physical field, such as temperature.
The motivation for including Fields in ESMF is that bundles of 
Fields are the entities that are normally exchanged when coupling
Components.  

<P>
The ESMF Field class contains distributed and discretized field data, a reference 
to its associated grid, and metadata.  The Field class stores the grid <I>staggering</I>
for that physical field.
This is the relationship of how the data array of a field maps onto a grid 
(e.g. one item per
cell located at the cell center, one item per cell located at the NW
corner,  one item per cell vertex, etc.).  This means that different Fields
which are on the same underlying ESMF Grid but have different
staggerings can share the same Grid object without needing to replicate
it multiple times. 

<P>
Fields can be added to States for use in inter-Component
data communications.  Fields can also be added to FieldBundles,
which are groups of Fields on the same underlying Grid.  
One motivation for packing Fields into FieldBundles is convenience; 
another is the ability to perform optimized collective data transfers.  

<P>
Field communication capabilities include: data redistribution, regridding, scatter,
gather, sparse-matrix multiplication, and halo update.  These are discussed
in more detail in the documentation for the specific method calls.  
ESMF does not currently support vector fields, so the components of 
a vector field must be stored as separate Field objects.  

<P>

<H3><A ID="SECTION05031100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Operations</A>
</H3>

<P>
The Field class allows the user to easily perform a number of operations on 
the data stored in a Field. This section gives a brief summary of the different types of operations
and the range of their capabilities. The operations covered here are: redistribution (<SPAN style="font-family:monospace">ESMF_FieldRedistStore()</SPAN>), sparse matrix multiply (<SPAN style="font-family:monospace">ESMF_FieldSMMStore()</SPAN>), and regridding (<SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN>).

<P>
The redistribution operation (<SPAN style="font-family:monospace">ESMF_FieldRedistStore()</SPAN>) allows the user to move data between two Fields with the same size, but different 
distribution. This operation is useful, for example, to move data between two components with different distributions. 
Please see Section&nbsp;<A HREF="#sec:field:usage:redist_1dptr"><IMG  ALT="[*]" SRC="crossref.png"></A> for an example of the redistribution capability.

<P>
The sparse matrix multiplication operation (<SPAN style="font-family:monospace">ESMF_FieldSMMStore()</SPAN>) allows the user to multiply the data in a Field by a sparse matrix. This operation is useful, for example, if the user has an interpolation matrix and wants to apply it to the data in a Field. Please see Section&nbsp;<A HREF="#sec:field:usage:smm_1dptr"><IMG  ALT="[*]" SRC="crossref.png"></A>
for an example of the sparse matrix multiply capability.

<P>
The regridding operation (<SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN>) allows the user to move data from one grid to another while maintaining certain properties
of the data. Regridding is also called interpolation or remapping. In the Field regridding operation the grids the data is being moved between
are the grids associated with the Fields storing the data. The regridding operation works on Fields built on Meshes, Grids, or Location Streams.  
There are six regridding methods available: bilinear, higher-order patch, two types of nearest neighbor, first-order conservative, and second-order conservative.
Please see section&nbsp;<A HREF="#sec:regrid">24.2</A> for a more indepth description of regridding including in which situations each method is supported. 
Please see section&nbsp;<A HREF="#sec:fieldregrid"><IMG  ALT="[*]" SRC="crossref.png"></A> for a description of the regridding capability as it applies to Fields. Several sections following section&nbsp;<A HREF="#sec:fieldregrid"><IMG  ALT="[*]" SRC="crossref.png"></A> 
contain examples of using regridding. 

<P>

<H2><A ID="SECTION05032000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION05032100000000000000"></A>
<A ID="const:fieldstatus"></A>
<BR>
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_FIELDSTATUS
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>  

An ESMF_Field can be in different status after initialization. Field status can be queried using <SPAN style="font-family:monospace">ESMF_FieldGet()</SPAN> method.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_FieldStatus_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_FIELDSTATUS_EMPTY</STRONG></DT>
<DD>Field is empty without geombase or data storage. Such a Field can be added to a <SPAN style="font-family:monospace">ESMF_State</SPAN> and participate <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN>. 
</DD>
<DT><STRONG>ESMF_FIELDSTATUS_GRIDSET</STRONG></DT>
<DD>Field is partially created. It has a geombase object internally created and the geombase object associates with either a <SPAN style="font-family:monospace">ESMF_Grid</SPAN>, or a <SPAN style="font-family:monospace">ESMF_Mesh</SPAN>, or an <SPAN style="font-family:monospace">ESMF_XGrid</SPAN>, or a <SPAN style="font-family:monospace">ESMF_LocStream</SPAN>. It's an error to set another geombase object in such a Field. It can also be added to a <SPAN style="font-family:monospace">ESMF_State</SPAN> and participate <SPAN style="font-family:monospace">ESMF_StateReconcile()</SPAN>.
</DD>
<DT><STRONG>ESMF_FIELDSTATUS_COMPLETE</STRONG></DT>
<DD>Field is completely created with geombase and data storage internally allocated. 
</DD>
</DL>
<H2><A ID="SECTION05033000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
A Field serves as an annotator of data, since it carries 
a description of the grid it is associated with and metadata 
such as name and units.  Fields can be used in this capacity
alone, as convenient, descriptive containers into which arrays 
can be placed and retrieved.  However, for most codes the primary 
use of Fields is in the context of import and export States,
which are the objects that carry coupling information between 
Components.  Fields enable data to be self-describing, and a
State holding ESMF Fields contains data in a standard format
that can be queried and manipulated.  

<P>
The sections below go into more detail about Field usage.

<P>

<H3><A ID="SECTION05033100000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field create and destroy</A>
</H3>

<P>
Fields can be created and destroyed at any time during 
application execution.  However, these Field methods require 
some time to complete.  We do not recommend that the user
create or destroy Fields inside performance-critical 
computational loops.

<P>
All versions of the <SPAN style="font-family:monospace">ESMF_FieldCreate()</SPAN> 
routines require a Grid object as input, or require a Grid
be added before most operations involving Fields can be performed.
The Grid contains the information needed to know which 
Decomposition Elements (DEs) are participating in 
the processing of this Field, and which subsets of the data
are local to a particular DE.

<P>
The details of how the create process happens depend
on which of the variants of the <SPAN style="font-family:monospace">ESMF_FieldCreate()</SPAN> 
call is used.  Some of the variants are discussed below.

<P>
There are versions of the <SPAN style="font-family:monospace">ESMF_FieldCreate()</SPAN> interface
which create the Field based on the input Grid.  The ESMF
can allocate the proper amount of 
space but not assign initial values.  The user code
can then get the pointer to the uninitialized buffer and 
set the initial data values.

<P>
Other versions of the <SPAN style="font-family:monospace">ESMF_FieldCreate()</SPAN> interface
allow user code to attach arrays that have already been
allocated by the user.  Empty Fields can also be created in
which case the data can be added at some later time.

<P>
For versions of Create which do not specify data values,
user code can create an ArraySpec object, which
contains information about the typekind and rank of the
data values in the array.  Then at Field create time, the
appropriate amount of memory is allocated to contain the
data which is local to each DE.

<P>
When finished with a <SPAN style="font-family:monospace">ESMF_Field</SPAN>, the <SPAN style="font-family:monospace">ESMF_FieldDestroy</SPAN> method
removes it.  However, the objects inside the <SPAN style="font-family:monospace">ESMF_Field</SPAN>
created externally should be destroyed separately, 
since objects can be added to
more than one <SPAN style="font-family:monospace">ESMF_Field</SPAN>.  For example, the same <SPAN style="font-family:monospace">ESMF_Grid</SPAN>
can be referenced by multiple <SPAN style="font-family:monospace">ESMF_Field</SPAN>s.  In this case the
internal Grid is not deleted by the <SPAN style="font-family:monospace">ESMF_FieldDestroy</SPAN> call.

<H2><A ID="SECTION05034000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<A ID="Field:rest"></A>

<LI><B>CAUTION:</B> It depends on the specific entry point of <SPAN style="font-family:monospace">ESMF_FieldCreate()</SPAN> used during Field creation, which Fortran operations are supported on the Fortran array pointer <SPAN style="font-family:monospace">farrayPtr</SPAN>, returned by <SPAN style="font-family:monospace">ESMF_FieldGet()</SPAN>. Only if the <SPAN style="font-family:monospace">ESMF_FieldCreate()</SPAN> <EM>from pointer</EM> variant was used, will the returned <SPAN style="font-family:monospace">farrayPtr</SPAN> variable contain the original bounds information, and be suitable for the Fortran <SPAN style="font-family:monospace">deallocate()</SPAN> call. This limitation is a direct consequence of the Fortran 95 standard relating to the passing of array arguments.

<P>
</LI>
<LI><B>No mathematical operators.</B>  The Fields class does not 
currently support advanced
operations on fields, such as differential or other
mathematical operators.

<P>
</LI>
</OL>
<H2><A ID="SECTION05035000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>Some methods which have a Field interface are actually 
implemented at the underlying Grid or Array level; they
are inherited by the Field class.  This allows the user
API (Application Programming Interface) to present functions at
the level which is most consistent to the application without
restricting where inside the ESMF the actual implementation
is done.

<P>
</LI>
<LI>The Field class is implemented in Fortran, and as such is
defined inside the framework by a Field derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The Field class itself is very thin; it is a container class which
groups a Grid and an Array object together.

<P>
</LI>
<LI>Fields follow the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same Fields at the same point in their execution.  Since an early
user request was that global object creation not impose the overhead of
a barrier or synchronization point, Field creation does no inter-PET
communication.  For this to work, each PET must query the total number
of PETs in this VM, and which local PET number it is.  It can then
compute which DE(s) are part of the local decomposition, and any
global information can be computed in unison by all PETs independently
of the others.  In this way the overhead of communication is avoided,
at the cost of more difficulty in diagnosing program bugs which result
from not all PETs executing the same create calls.

<P>
</LI>
<LI>Related to the item above, the user request to not impose
inter-PET communication at object creation time means that requirement
FLD 1.5.1, that all Fields will have unique names, and if not specified, 
the framework will generate a unique name for it, is difficult or
impossible to support.  A part of this requirement has been implemented;
a unique object counter is maintained in the Base object class, and if
a name is not given at create time a name such as "Field003" is generated
which is guaranteed to not be repeated by the framework.   However, it
is impossible to error check that the user has not replicated a name,
and it is possible under certain conditions that if not all PETs have
created the same number of objects, that the counters on different PETs
may not stay synchronized.   This remains an open issue.

<P>
</LI>
</OL>
<H2><A ID="SECTION05036000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<H2><A ID="SECTION05037000000000000000">
<SPAN CLASS="arabic">26</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: Field Utilities</A>
</H2>

<H1><A ID="SECTION05040000000000000000">
<SPAN CLASS="arabic">27</SPAN> ArrayBundle Class</A>
</H1>

<H2><A ID="SECTION05041000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The <SPAN style="font-family:monospace">ESMF_ArrayBundle</SPAN> class allows a set of Arrays to be bundled into a
single object. The Arrays in an ArrayBundle may be of different type, kind,
rank and distribution. Besides ease of use resulting from bundling, the
ArrayBundle class offers the opportunity for performance optimization when
operating on a bundle of Arrays as a single entity.  Communication methods are 
especially good candidates for performance optimization. Best optimization
results are expected for ArrayBundles that contain Arrays that share a common
distribution, i.e. DistGrid, and are of same type, kind and rank.

<P>
ArrayBundles are one of the data objects that can be added to States,
which are used for providing to or receiving data from other Components.

<H2><A ID="SECTION05042000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
Examples of creating, destroying and accessing ArrayBundles and their
constituent Arrays are provided in this section, along with some
notes on ArrayBundle methods.

<H2><A ID="SECTION05043000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Non-blocking</B> ArrayBundle communications option is not yet implemented. In the future this functionality will be provided via the
<SPAN style="font-family:monospace">routesyncflag</SPAN> option.

<P>
</LI>
</UL>
<H2><A ID="SECTION05044000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The following is a list of implementation specific details about the current ESMF ArrayBundle.

<P>

<UL>
<LI>Implementation language is C++.
</LI>
<LI>All precomputed communication methods are based on sparse matrix
multiplication.
</LI>
</UL>
<H2><A ID="SECTION05045000000000000000">
<SPAN CLASS="arabic">27</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05050000000000000000">
<SPAN CLASS="arabic">28</SPAN> Array Class</A>
</H1>

<H2><A ID="SECTION05051000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The Array class is an alternative to the Field class for representing
distributed, structured data.  Unlike Fields, which are built to carry
grid coordinate information, Arrays only carry information about the
<I>indices</I> associated with grid cells.  Since they do not have coordinate
information, Arrays cannot be used to calculate interpolation weights.
However, if the user supplies interpolation weights, the Array sparse
matrix multiply (SMM) operation can be used to apply the weights and transfer
data to the new grid.  Arrays carry enough information to perform
redistribution, scatter, and gather communication operations.

<P>
Like Fields, Arrays can be added to a State and used in inter-Component
data communications.  Arrays can also be grouped together into ArrayBundles,
allowing operations to be performed collectively on the whole group.  One
motivation for this is convenience; another is the ability to schedule
optimized, collective data transfers.

<P>
From a technical standpoint, the ESMF Array class is an index space based,
distributed data storage class. Its purpose is to hold distributed user data.
Each decompositon element (DE) is associated with its own memory allocation. The
index space relationship between DEs is described by the ESMF DistGrid class.
DEs, and their associated memory allocation, are pinned either to a specific
perisistent execution thread (PET), virtual address space (VAS), or a single
system image (SSI). This aspect is managed by the ESMF DELayout class. Pinning
to PET is the most common mode and is the default.

<P>
The Array class offers common communication patterns within the index space
formalism. All RouteHandle based communication methods of the Field,
FieldBundle, and ArrayBundle layers are implemented via the Array SMM operation.

<H2><A ID="SECTION05052000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
An <SPAN style="font-family:monospace">ESMF_Array</SPAN> is a distributed object that must exist on all PETs of the current context. Each PET-local instance of an Array object contains memory allocations for all PET-local DEs. There may be 0, 1, or more DEs per PET and the number of DEs per PET can differ between PETs for the same Array object. Memory allocations may be provided for each PET by the user during Array creation or can be allocated as part of the Array create call. Many of the concepts of the <SPAN style="font-family:monospace">ESMF_Array</SPAN> class are illustrated by the following examples.

<H2><A ID="SECTION05053000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<A ID="Array:rest"></A>

<LI><B>CAUTION:</B> Depending on the specific <SPAN style="font-family:monospace">ESMF_ArrayCreate()</SPAN> entry point used during Array creation, certain Fortran operations are not supported on the Fortran array pointer <SPAN style="font-family:monospace">farrayPtr</SPAN>, returned by <SPAN style="font-family:monospace">ESMF_ArrayGet()</SPAN>. Only if the <SPAN style="font-family:monospace">ESMF_ArrayCreate()</SPAN> <EM>from pointer</EM> variant was used, will the returned <SPAN style="font-family:monospace">farrayPtr</SPAN> variable contain the original bounds information, and be suitable for the Fortran <SPAN style="font-family:monospace">deallocate()</SPAN> call. This limitation is a direct consequence of the Fortran 95 standard relating to the passing of array arguments. Fortran array pointers returned from an Array that was created through the <EM>assumed shape array</EM> variant of <SPAN style="font-family:monospace">ESMF_ArrayCreate()</SPAN> will have bounds that are consistent with the other arguments specified during Array creation. These pointers are not suitable for deallocation in accordance to the Fortran 95 standard.

<P>
</LI>
<LI><B>1D limit:</B> ArrayHalo(), ArrayRedist() and ArraySMM() operations on Arrays created on DistGrids with arbitrary sequence indices are currently limited to 1D arbitrary DistGrids. There is no restriction on the number, size
and mapping of undistributed Array dimensions in the presence of such a 1D
arbitrary DistGrid.

<P>
</LI>
</UL>
<H2><A ID="SECTION05054000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The Array class is part of the ESMF index space layer and is built on top of the DistGrid and DELayout classes. The DELayout class introduces the notion of 
<EM>decomposition elements</EM> (DEs) and their layout across the available PETs. The DistGrid describes how index space is decomposed by assigning <EM>logically rectangular index space pieces</EM> or <EM>DE-local tiles</EM> to the DEs. The Array finally associates a <EM>local memory allocation</EM> with each local DE.

<P>
The following is a list of implementation specific details about the current ESMF Array.

<P>

<UL>
<LI>Implementation language is C++.
</LI>
<LI>Local memory allocations are internally held in <SPAN style="font-family:monospace">ESMF_LocalArray</SPAN>
objects.
</LI>
<LI>All precomputed communication methods are based on sparse matrix
multiplication.
</LI>
</UL>
<H2><A ID="SECTION05055000000000000000">
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<H2><A ID="SECTION05056000000000000000"></A>
<A ID="ref:dynamicmask"></A>
<BR>
<SPAN CLASS="arabic">28</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API: DynamicMask Methods
</H2>

<H1><A ID="SECTION05060000000000000000">
<SPAN CLASS="arabic">29</SPAN> LocalArray Class</A>
</H1>

<H2><A ID="SECTION05061000000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The <SPAN style="font-family:monospace">ESMF_LocalArray</SPAN> class provides a language independent 
representation of data in array format. One of the major functions 
of the LocalArray class is to bridge the Fortran/C/C++ language 
difference that exists with respect to array representation. All 
ESMF Field and Array data is internally stored in ESMF LocalArray 
objects allowing transparent access from Fortran and C/C++.

<P>
In the ESMF Fortran API the LocalArray becomes visible in those cases 
where a local PET may be associated with multiple pieces of an Array, 
e.g. if there are multiple DEs associated with a single PET. The Fortran 
language standard does not provide an array of arrays construct, however 
arrays of derived types holding arrays are possible. ESMF calls use 
arguments that are of type <SPAN style="font-family:monospace">ESMF_LocalArray</SPAN> with <SPAN style="font-family:monospace">dimension</SPAN> 
attributes where necessary.

<P>

<H2><A ID="SECTION05062000000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">2</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>The TKR (type/kind/rank) overloaded LocalArray interfaces declare the dummy Fortran array arguments with the pointer attribute. The advantage of doing this is that it allows ESMF to inquire information about the provided Fortran array. The disadvantage of this choice is that actual Fortran arrays passed into these interfaces <EM>must</EM> also be defined with pointer attribute in the user code.
</LI>
</UL>
<H2><A ID="SECTION05063000000000000000">
<SPAN CLASS="arabic">29</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05070000000000000000">
<SPAN CLASS="arabic">30</SPAN> ArraySpec Class</A>
</H1>

<H2><A ID="SECTION05071000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
An ArraySpec is a very simple class that contains type, kind, and
rank information about an Array.  This information is stored in two
parameters.  <B>TypeKind</B> describes the data type of the elements
in the Array and their precision.  <B>Rank</B> is the number of dimensions
in the Array.

<P>
The only methods that are associated with the ArraySpec class are those 
that allow you to set and retrieve this information.

<P>

<H2><A ID="SECTION05072000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The ArraySpec is passed in as an argument at Field and 
FieldBundle creation in order to describe an Array that will 
be allocated or attached at a later time.  There are any
number of situations in which this approach is useful.  
One common example is a case in which the user wants to create
a very flexible export State with many diagnostic variables 
predefined, but only a subset desired and consequently 
allocated for a particular run.  

<P>

<H2><A ID="SECTION05073000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limit on rank.</B>  The values for type, kind and rank passed 
into the ArraySpec
class are subject to the same limitations as Arrays.  The maximum
array rank is 7, which is the highest rank supported by Fortran.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION05074000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The information contained in an <SPAN style="font-family:monospace">ESMF_ArraySpec</SPAN> is used to create 
<SPAN style="font-family:monospace">ESMF_Array</SPAN> objects. 

<P>
<SPAN style="font-family:monospace">ESMF_ArraySpec</SPAN> is a shallow class, and only set and get methods
are needed.  They do not need to be created or destroyed.

<P>

<H2><A ID="SECTION05075000000000000000">
<SPAN CLASS="arabic">30</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION05080000000000000000">
<SPAN CLASS="arabic">31</SPAN> Grid Class</A>
</H1>

<H2><A ID="SECTION05081000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF Grid class is used to describe the geometry and discretization
of logically rectangular physical grids.  It also contains the
description of the grid's underlying topology and the decomposition
of the physical grid across the available computational resources.
The most frequent use of the Grid class is to describe physical grids
in user code so that sufficient information is available to perform ESMF
methods such as regridding.  

<P>
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=553>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Representation of grids formed by logically rectangular regions,
including uniform and rectilinear grids (e.g. lat-lon grids),
curvilinear grids (e.g. displaced pole grids), and grids formed
by connected logically rectangular regions (e.g. cubed sphere grids).</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Support for 1D, 2D, 3D, and higher dimension grids.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Distribution of grids across computational resources for parallel
operations - users set which grid dimensions are distributed.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Grids can be created already distributed, so that no single
resource needs global information during the creation process.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Options to define periodicity and other edge connectivities either 
explicitly or implicitly via shape shortcuts.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Options for users to define grid coordinates themselves or to call
prefabricated coordinate generation routines for standard grids.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Options for incremental construction of grids.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Options for using a set of pre-defined stagger locations or for setting
custom stagger locations.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A ID="SECTION05081100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Representation in ESMF</A>
</H3>

<P>
ESMF Grids are based on the concepts described in <I>A Standard
Description of Grids Used in Earth System Models</I> [Balaji 2006].  In this document
Balaji introduces the mosaic concept as a means of describing
a wide variety of Earth system model grids.  A <B>mosaic</B> is
composed of grid tiles connected at their edges.  Mosaic grids
includes simple, single tile grids as a special case.  

<P>
The ESMF Grid class is a representation of a mosaic grid.  Each ESMF
Grid is constructed of one or more logically rectangular <B>Tiles</B>.
A Tile will usually have some physical significance (e.g. the region
of the world covered by one face of a cubed sphere grid).

<P>
The piece of a Tile that resides on one DE (for simple cases, a DE
can be thought of as a processor - see section on the DELayout)
is called a <B>LocalTile</B>.  For example, the six faces of a cubed
sphere grid are each Tiles, and each Tile can be divided into many
LocalTiles.  

<P>
Every ESMF Grid contains a DistGrid object, which defines the Grid's
index space, topology, distribution, and connectivities.  It enables
the user to define the complex edge relationships of tripole and other
grids.  The DistGrid can be created explicitly and passed into a Grid
creation routine, or it can be created implicitly if the user takes
a Grid creation shortcut. The DistGrid used
in Grid creation describes the properties of the Grid cells. In addition
to this one, the Grid internally creates DistGrids for each stagger location. 
These stagger DistGrids are related to the original DistGrid, but may 
contain extra padding to represent the extent of the index space of
the stagger. These DistGrids are what are used when a Field is created 
on a Grid. 

<P>

<H3><A ID="SECTION05081200000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Grids</A>
</H3>

<P>
The range of supported grids in ESMF can be defined by:

<UL>
<LI>Types of topologies and shapes supported.  ESMF supports one or
more logically rectangular grid Tiles with connectivities specified
between cells.  For more details see section <A HREF="#sec:ShapeShortcut">31.1.3</A>.
</LI>
<LI>Types of distributions supported.  ESMF supports  regular,
irregular, or arbitrary distributions of data.  
For more details see section <A HREF="#sec:desc:dist">31.1.4</A>.
</LI>
<LI>Types of coordinates supported.  ESMF supports uniform, rectilinear,
and curvilinear coordinates.  For more details see section <A HREF="#sec:coordspec">31.1.5</A>.
</LI>
</UL>

<P>

<H3><A ID="SECTION05081300000000000000"></A>
<A ID="sec:ShapeShortcut"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Grid Topologies and Periodicity
</H3>

ESMF has shortcuts for the creation of standard Grid topologies 
or <B>shapes</B> up to 3D.  In many cases, these enable the user to
bypass the step of creating a DistGrid before creating the Grid. 
There are two sets of methods which allow the user to do this. These two sets of methods cover the same set of topologies, but
allow the user to specify them in different ways.

<P>
The first set of these are a group of overloaded
calls broken up by the number of periodic dimensions they specify. With these the user can pick 
the method which creates a Grid with the number of periodic dimensions they need, and then specify other connectivity 
options via arguments to the method. The following is a description of these methods:

<P>

<P>
<BR>

<P>
<DL>
<DT><STRONG>ESMF_GridCreateNoPeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with no edge connections, for example, a regional Grid with closed boundaries.

<P>
</DD>
<DT><STRONG>ESMF_GridCreate1PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 1 periodic dimension and supports a range of options for what to do at the pole (see&nbsp;Section&nbsp;<A HREF="#const:polekind">31.2.5</A>). Some examples of Grids which can be created here are tripole spheres, bipole spheres, cylinders with open poles. 

<P>
</DD>
<DT><STRONG>ESMF_GridCreate2PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 2 periodic dimensions, for example a torus, or a regional Grid with
doubly periodic boundaries. 
</DD>
</DL>

<P>
More detailed information can be found in the API description of each.

<P>

<P>
<BR>

<P>
The second set of shortcut methods is a set of methods overloaded under the name <SPAN style="font-family:monospace">ESMF_GridCreate()</SPAN>. These methods
allow the user to specify the connectivites at the end of each dimension, by using the ESMF_GridConn_Flag flag. The table below shows the ESMF_GridConn_Flag settings used to create 
standard shapes in 2D using the ESMF_GridCreate() call.  Two values
are specified for each dimension, one for the low end and one for 
the high end of the dimension's index values.

<P>

<P>
<BR>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">2D Shape</TD>
<TD CLASS="CENTER"><B>connflagDim1(1)</B></TD>
<TD CLASS="CENTER"><B>connflagDim1(2)</B></TD>
<TD CLASS="CENTER"><B>connflagDim2(1)</B></TD>
<TD CLASS="CENTER"><B>connflagDim2(2)</B></TD>
</TR>
<TR><TD CLASS="LEFT"><B>Rectangle</B></TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">NONE</TD>
</TR>
<TR><TD CLASS="LEFT"><B>Bipole Sphere</B></TD>
<TD CLASS="CENTER">POLE</TD>
<TD CLASS="CENTER">POLE</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
</TR>
<TR><TD CLASS="LEFT"><B>Tripole Sphere</B></TD>
<TD CLASS="CENTER">POLE</TD>
<TD CLASS="CENTER">BIPOLE</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
</TR>
<TR><TD CLASS="LEFT"><B>Cylinder</B></TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
</TR>
<TR><TD CLASS="LEFT"><B>Torus</B></TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
<TD CLASS="CENTER">PERIODIC</TD>
</TR>
</TABLE>

<P>
<BR>

<P>
If the user's grid shape is too complex for an ESMF shortcut routine,
or involves more than three dimensions, a DistGrid can be created
to specify the shape in detail.  This DistGrid is then passed
into a Grid create call.

<P>

<H3><A ID="SECTION05081400000000000000"></A>
<A ID="sec:desc:dist"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Grid Distribution
</H3>

<P>
ESMF Grids have several options for data distribution (also referred to
as decomposition).  As ESMF Grids are cell based, these 
options are all specified  in terms of how the cells in the Grid
are broken up between DEs. 

<P>
The main distribution options are regular, irregular, and arbitrary.
A <B>regular</B> distribution is one in which the same number of
contiguous grid cells are assigned to each DE in the
distributed dimension.  An <B>irregular</B> distribution is one in which
unequal numbers of contiguous grid cells are assigned to each
DE in the distributed dimension.  An <B>arbitrary</B> distribution is
one in which any grid cell can be assigned to any DE.  Any of these
distribution options can be applied to any of the grid shapes (i.e.,
rectangle) or types (i.e., rectilinear).  Support for arbitrary distribution 
is limited in the current version of ESMF, see Section <A HREF="#example:ArbGridWithUndistDim"><IMG  ALT="[*]" SRC="crossref.png"></A> for
an example of creating a Grid with an arbitrary distribution.

<P>
Figure <A HREF="#fig:GridDecomps">12</A> illustrates options for distribution.

<DIV class="CENTER"><A ID="fig:GridDecomps"></A><A ID="3716"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 12:</STRONG>
Examples of regular and irregular decomposition of
a grid <B>a</B> that is 6x6, and an arbitrary decomposition of
a grid <B>b</B> that is 6x3.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{GridDecomps}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img31.svg"
 ALT="\scalebox{0.9}{\includegraphics{GridDecomps}}"></TD></TR>
</TABLE>
</DIV>

<P>
A distribution can also be specified using the DistGrid, by passing
object into a Grid create call.

<P>

<H3><A ID="SECTION05081500000000000000"></A>
<A ID="sec:coordspec"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Coordinates
</H3>
Grid Tiles can have uniform, rectilinear, or curvilinear
coordinates.  The coordinates of <B>uniform</B> grids are equally spaced along
their axes, and can be fully specified by the coordinates of the two opposing points
that define the grid's physical span.  The coordinates of <B>rectilinear</B> grids
are unequally spaced along their axes, and can be fully specified by giving
the spacing of grid points along each axis.  The coordinates of <B>curvilinear 
grids</B> must be specified by giving the explicit set of coordinates for each
grid point.  Curvilinear grids are often uniform or rectilinear grids that 
have been warped; for example, to place a pole over a land mass so that it
does not affect the computations performed on an ocean model grid.  Figure
<A HREF="#fig:LogRectGrids">13</A> shows examples of each type of grid.

<P>

<DIV class="CENTER"><A ID="fig:LogRectGrids"></A><A ID="1965"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 13:</STRONG>
Types of logically rectangular grid tiles.  Red circles show the
values needed to specify grid coordinates for each type.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{LogRectGrids}}$
 -->
<IMG
 STYLE="height: 14.62ex; vertical-align: -0.11ex; " SRC="img32.svg"
 ALT="\scalebox{0.9}{\includegraphics{LogRectGrids}}"></TD></TR>
</TABLE>
</DIV>

<P>
Each of these coordinate types can be set for each of the standard grid shapes
described in section <A HREF="#sec:ShapeShortcut">31.1.3</A>.  

<P>
The table below shows how examples of common single Tile grids fall 
into this shape and coordinate taxonomy.  Note that any
of the grids in the table can have a regular or arbitrary distribution.

<P>

<P>
<BR>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=74>&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=147><B>Uniform</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=147><B>Rectilinear</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=147><B>Curvilinear</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=74><B>Sphere</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Global uniform lat-lon grid</TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Gaussian grid</TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Displaced pole grid</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=74><B>Rectangle</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Regional uniform lat-lon grid</TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Gaussian grid section</TD>
<TD CLASS="LEFT TOP"  WIDTH=147>Polar stereographic grid section</TD>
</TR>
</TABLE>

<P>

<H3><A ID="SECTION05081600000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Coordinate Specification and Generation</A>
</H3>

<P>
There are two ways of specifying coordinates in ESMF.  The
first way is for the user to <B>set</B> the coordinates.  The second 
way is to take a shortcut and have the framework <B>generate</B>
the coordinates.  

<P>
See Section&nbsp;<A HREF="#sec:usage:staggerloc"><IMG  ALT="[*]" SRC="crossref.png"></A> for more description and examples of
setting coordinates.

<P>

<H3><A ID="SECTION05081700000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> Staggering</A>
</H3>

<P>
<B>Staggering</B> is a finite difference technique in which the values 
of different physical quantities are placed at different locations
within a grid cell. 

<P>
The ESMF Grid class supports a variety of stagger locations, including
cell centers, corners, and edge centers. The default stagger location in 
ESMF is the cell center, and cell counts in Grid are based on this assumption.
Combinations of the 2D ESMF stagger locations are sufficient to specify any of the
Arakawa staggers.  ESMF also supports staggering in 3D and higher dimensions.
There are shortcuts for standard staggers, and interfaces through which users 
can create custom staggers.  

<P>
As a default the ESMF Grid class provides symmetric staggering, so
that cell centers are enclosed by cell perimeter (e.g. corner) 
stagger locations. This means the coordinate arrays for stagger
locations other than the center will have an additional element of 
padding in order to enclose the cell center locations.
However, to achieve other types of staggering, the user may alter 
or eliminate this padding by using the appropriate options when adding
coordinates to a Grid. 

<P>
In the current release, only the cell center stagger location is supported for an
arbitrarily distributed grid. For examples and a full description of the stagger interface 
see Section&nbsp;<A HREF="#sec:usage:staggerloc"><IMG  ALT="[*]" SRC="crossref.png"></A>. 

<P>

<H3><A ID="SECTION05081800000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> Masking</A>
</H3>

<P>
Masking is the process whereby parts of a Grid can be marked to be
ignored during an operation.  For a description of how to set mask information in
the Grid, see here <A HREF="#sec:usage:items"><IMG  ALT="[*]" SRC="crossref.png"></A>. For a description of how masking works
in regridding, see here <A HREF="#regrid:masking">24.2.10</A>.

<H2><A ID="SECTION05082000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION05082100000000000000"></A>
<A ID="const:gridconn"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_GRIDCONN
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

The <SPAN style="font-family:monospace">ESMF_GridCreateShapeTile</SPAN> command has three specific arguments
<SPAN style="font-family:monospace">connflagDim1</SPAN>, <SPAN style="font-family:monospace">connflagDim2</SPAN>, and <SPAN style="font-family:monospace">connflagDim3</SPAN>. These can be used
to setup different types of connections at the ends of each dimension
of a Tile.  Each of these parameters is a two element array. The first
element is the connection type at the minimum end of the dimension
and the second is the connection type at the maximum end. The default
value for all the connections is ESMF_GRIDCONN_NONE, specifying no
connection.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_GridConn_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDCONN_NONE</STRONG></DT>
<DD>No connection.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_PERIODIC</STRONG></DT>
<DD>Periodic connection.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_POLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element ((i+n/2) mod n).

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i+1.
</DD>
</DL>

<P>

<H3><A ID="SECTION05082200000000000000"></A>
<A ID="const:griditem"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_GRIDITEM
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
The ESMF Grid can contain other kinds of data besides coordinates. 
This data is referred to as Grid &ldquo;items&rdquo;. Some items may be used
by ESMF for calculations involving the Grid. The following
are the valid values of ESMF_GridItem_Flag.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_GridItem_Flag)</SPAN>

<P>
The valid values are:
<BR><TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Item Label</TD>
<TD CLASS="CENTER"><B>Type Restriction</B></TD>
<TD CLASS="CENTER"><B>Type Default</B></TD>
<TD CLASS="CENTER"><B>ESMF Uses</B></TD>
<TD CLASS="CENTER"><B>Controls</B></TD>
</TR>
<TR><TD CLASS="LEFT"><B>ESMF_GRIDITEM_MASK</B></TD>
<TD CLASS="CENTER">ESMF_TYPEKIND_I4</TD>
<TD CLASS="CENTER">ESMF_TYPEKIND_I4</TD>
<TD CLASS="CENTER">YES</TD>
<TD CLASS="CENTER">Masking in Regrid</TD>
</TR>
<TR><TD CLASS="LEFT"><B>ESMF_GRIDITEM_AREA</B></TD>
<TD CLASS="CENTER">NONE</TD>
<TD CLASS="CENTER">ESMF_TYPEKIND_R8</TD>
<TD CLASS="CENTER">YES</TD>
<TD CLASS="CENTER">Conservation in Regrid</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<B>NOTE:</B> One important thing to consider when setting areas in the Grid using <SPAN style="font-family:monospace">ESMF_GRIDITEM_AREA</SPAN>,
  ESMF doesn't currently do unit conversion on areas. If these areas are going to be used
 in a process that also involves the areas of another Grid or Mesh (e.g. conservative regridding), then
 it is the user's responsibility to make sure that the area units are consistent between the two sides.
 If ESMF calculates an area on the surface of a sphere, then it is in units of square radians. If 
 it calculates the area for a Cartesian grid, then it is in the same units as the coordinates, but squared. 

<P>

<H3><A ID="SECTION05082300000000000000"></A>
<A ID="const:gridmatch"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_GRIDMATCH
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
 This type is used to indicate the level to which two grids match.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_GridMatch_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDMATCH_INVALID:</STRONG></DT>
<DD>Indicates a non-valid matching level. Returned
      if an error occurs in the matching function. If a higher matching level
      is returned then no error occurred.
</DD>
<DT><STRONG>ESMF_GRIDMATCH_NONE:</STRONG></DT>
<DD>The lowest level of grid matching. 
      This indicates that the Grid's don't match at any of the higher levels. 
</DD>
<DT><STRONG>ESMF_GRIDMATCH_EXACT:</STRONG></DT>
<DD>All the pieces of the Grid (e.g. distgrids, 
      coordinates, etc.) except the name, match between the two Grids. 
</DD>
<DT><STRONG>ESMF_GRIDMATCH_ALIAS:</STRONG></DT>
<DD>Both Grid variables are aliases to the exact
      same Grid object in memory. 
</DD>
</DL>

<P>

<H3><A ID="SECTION05082400000000000000"></A>
<A ID="const:gridstatus"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_GRIDSTATUS
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
The ESMF Grid class can exist in two states. These states are
present so that the library code can detect if a Grid has been
appropriately setup for the task at hand. The following
are the valid values of ESMF_GRIDSTATUS.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_GridStatus_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDSTATUS_EMPTY:</STRONG></DT>
<DD>Status after a Grid has been created with 
      <SPAN style="font-family:monospace">ESMF_GridEmptyCreate</SPAN>.  A Grid object container is allocated but
      space for internal objects is not.  Topology information and coordinate
      information is incomplete.  This object can be used in <SPAN style="font-family:monospace">ESMF_GridEmptyComplete()</SPAN>
      methods in which additional information is added to the Grid.
</DD>
<DT><STRONG>ESMF_GRIDSTATUS_COMPLETE:</STRONG></DT>
<DD>The Grid has a specific topology and
      distribution, but incomplete coordinate arrays.  The Grid can be used
      as the basis for allocating a Field, and coordinates can be added
      via <SPAN style="font-family:monospace">ESMF_GridCoordAdd()</SPAN> to allow other functionality. 
</DD>
</DL>

<P>

<H3><A ID="SECTION05082500000000000000"></A>
<A ID="const:polekind"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_POLEKIND
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
This type describes the type of connection that occurs at the pole when a Grid is 
created with <SPAN style="font-family:monospace">ESMF_GridCreate1PeriodicDim()</SPAN>.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_PoleKind_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_POLEKIND_NONE</STRONG></DT>
<DD>No connection at pole.

<P>
</DD>
<DT><STRONG>ESMF_POLEKIND_MONOPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element i+n/2.

<P>
</DD>
<DT><STRONG>ESMF_POLEKIND_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i+1.
</DD>
</DL>

<P>

<H3><A ID="SECTION05082600000000000000"></A>
<A ID="const:staggerloc"></A>
<BR>
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_STAGGERLOC
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
 In the ESMF Grid class, data can be located at different positions in a
 Grid cell.  When setting or retrieving coordinate data the stagger location is
 specified to tell the Grid method  from where in the cell to get the data. 
 Although the user may define their own custom stagger locations, 
 ESMF provides a set of predefined locations for ease of use. The
following are the valid predefined stagger locations. 

<P>

<P>
<BR>

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:gridstaggerloc2d"></A><A ID="2047"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 14:</STRONG>
2D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}$
 -->
<IMG
 STYLE="height: 12.22ex; vertical-align: -0.11ex; " SRC="img33.svg"
 ALT="\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
The 2D predefined stagger locations (illustrated in figure&nbsp;<A HREF="#fig:gridstaggerloc2d">14</A>) are:
<BR><DL>
<DT><STRONG>ESMF_STAGGERLOC_CENTER:</STRONG></DT>
<DD>The center of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER:</STRONG></DT>
<DD>The corners of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1:</STRONG></DT>
<DD>The edges offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2:</STRONG></DT>
<DD>The edges offset from the center in the 2nd dimension.
</DD>
</DL>

<P>

<P>
<BR>

<P>
<DIV class="CENTER">
</DIV>
<DIV class="CENTER"><A ID="fig:gridstaggerloc3d"></A><A ID="2058"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 15:</STRONG>
3D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}$
 -->
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img34.svg"
 ALT="\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}"></TD></TR>
</TABLE>
</DIV>
<DIV class="CENTER">
</DIV>

<P>
The 3D predefined stagger locations (illustrated in figure&nbsp;<A HREF="#fig:gridstaggerloc3d">15</A>) are:
<BR><DL>
<DT><STRONG>ESMF_STAGGERLOC_CENTER_VCENTER:</STRONG></DT>
<DD>The center of the 3D cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER_VCENTER:</STRONG></DT>
<DD>Half way up the vertical edges of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 1 and the vertical dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 2 and the vertical dimension. 
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER_VFACE:</STRONG></DT>
<DD>The corners of the 3D cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 2nd dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CENTER_VFACE:</STRONG></DT>
<DD>The center of the top and bottom face. The face bounded by the 1st and 2nd dimensions. 
</DD>
</DL>

<P>

<H2><A ID="SECTION05083000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
This section describes the use of the ESMF Grid class. It first discusses
the more user friendly shape specific interface to the Grid. 
During this discussion it covers creation and options, 
adding stagger locations, coordinate data access, and other grid 
functionality. After this initial phase the document discusses 
the more advanced options which the user can employ should they
need more customized interaction with the Grid class.

<P>

<H2><A ID="SECTION05084000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Grids with factorized coordinates can only be redisted when they are 2D.</B>
Using the ESMF_GridCreate() interface that allows the user to create a copy of an existing Grid with a new distribution will give incorrect results when used on a Grid with 3 or more dimensions and whose coordinate arrays are less than the full dimension of the Grid (i.e. it contains factorized coordinates).

<P>
</LI>
<LI><B>7D limit.</B>  Only grids up to 7D will be supported.

<P>
</LI>
<LI><B>Future adaptation.</B>  Currently Grids
are created and then remain unchanged. In the future, it would
be useful to provide support for the various forms of grid
adaptation. This would allow the grids to dynamically change
their resolution to more closely match what is needed at a particular
time and position during a computation for front tracking or adaptive meshes.

<P>
</LI>
<LI><B>Future Grid generation.</B> This class for now only contains
the basic functionality for operating on the grid. In the future
methods will be added to enable the automatic generation of various types of
grids. 

<P>
</LI>
</UL>

<P>

<H2><A ID="SECTION05085000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<H3><A ID="SECTION05085100000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Topology</A>
</H3> 

<P>
The <SPAN style="font-family:monospace">ESMF_Grid</SPAN> class depends upon the <SPAN style="font-family:monospace">ESMF_DistGrid</SPAN> class
for the specification of its topology. That is, when 
creating a Grid, first an <SPAN style="font-family:monospace">ESMF_DistGrid</SPAN> is created to describe the 
appropriate index space topology. This decision was
made because it seemed redundant to have a system for doing this
in both classes. It also seems most appropriate for
the machinary for topology creation to be located at the lowest
level possible so that it can be used by other
classes (e.g. the <SPAN style="font-family:monospace">ESMF_Array</SPAN> class). Because of this, however,
the authors recommend that as a natural part of the 
implementation of subroutines to generate standard grid shapes
(e.g. <SPAN style="font-family:monospace">ESMF_GridGenSphere</SPAN>) a set of standard
topology generation subroutines be implemented (e.g. <SPAN style="font-family:monospace">ESMF_DistGridGenSphere</SPAN>) for users who want to create a standard topology, but a custom geometry.

<P>

<H2><A ID="SECTION05086000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API: General Grid Methods</A>
</H2>

<H2><A ID="SECTION05087000000000000000">
<SPAN CLASS="arabic">31</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: StaggerLoc Methods</A>
</H2>&nbsp;<A ID="ref:stagsub"></A>
<H1><A ID="SECTION05090000000000000000">
<SPAN CLASS="arabic">32</SPAN> LocStream Class</A>
</H1>

<H2><A ID="SECTION05091000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
A location stream (LocStream) can be used to represent the locations of
a set of data points.  For example, in the data assimilation world, 
LocStreams can be used to represent a set of observations.  The values 
of the data points are stored within a Field or FieldBundle created 
using the LocStream.

<P>
The locations are generally described using Cartesian (x, y, z), or 
(lat, lon, radius) coordinates.  The coordinates are stored using 
constructs called <I>keys</I>.  A Key is essentially a list of point 
descriptors, one for each data point.  They may hold other information 
besides the coordinates - a mask, for example.  They may also hold a 
second set of coordinates.    Keys are referenced by name - see 
<A HREF="#const:coordkeyname">32.2.1</A> and <A HREF="#const:maskkeyname">32.2.2</A> for specific 
keynames required in regridding.  Each key must contain the same 
number of elements as there are data points in the LocStream.  While 
there is no assumption in the ordering of the points, the order 
chosen must be maintained in each of the keys.

<P>
LocStreams can be very large. Data assimilation systems might use
LocStreams with up to <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img35.svg"
 ALT="$10^{8}$"></SPAN> observations, so efficiency is critical.
LocStreams can be created from file, see <A HREF="#locstream:createfromfile"><IMG  ALT="[*]" SRC="crossref.png"></A>.

<P>
Common operations involving LocStreams are similar to those involving Grids.
For example, LocStreams allow users to:

<P>

<OL>
<LI>Create a Field or FieldBundle on a LocStream
</LI>
<LI>Regrid data in Fields defined on LocStreams
</LI>
<LI>Redistribute data between Fields defined on LocStreams
</LI>
<LI>Gather or scatter a FieldBundle defined on a LocStream from/to a root DE
</LI>
<LI>Extract Fortran array from Field which was defined on a LocStream
</LI>
</OL>

<P>
A LocStream differs from a Grid in that no topological structure is
maintained between the points
(e.g. the class contains no information about which point is the neighbor
of which other point).

<P>
A LocStream is similar to a Mesh in that both are collections of irregularly positioned 
points.  However, the two structures differ because a Mesh also has connectivity: 
each data point represents either a center or corner of a cell. There is no requirement that the
points in a LocStream have connectivity, in fact there is no requirement that any two points 
have any particular spatial relationship at all.

<H2><A ID="SECTION05092000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION05092100000000000000"></A>
<A ID="const:coordkeyname"></A>
<BR>
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Coordinate keyNames
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
For ESMF to be able to use coordinates specified in a LocStream key (e.g. in regridding) 
they need to be named with the appropriate identifiers. The particular identifiers depend 
on the coordinate system (i.e. coordSys argument) used to create the LocStream containing 
the keys.  ESMF regridding expects these keys to be of type ESMF_TYPEKIND_R8. 

<P>
The valid values are:
<BR><TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Coordinate System</TD>
<TD CLASS="CENTER"><B>dimension 1</B></TD>
<TD CLASS="CENTER"><B>dimension 2</B></TD>
<TD CLASS="CENTER"><B>dimension 3 (if used)</B></TD>
</TR>
<TR><TD CLASS="LEFT"><B>ESMF_COORDSYS_SPH_DEG</B></TD>
<TD CLASS="CENTER">ESMF:Lon</TD>
<TD CLASS="CENTER">ESMF:Lat</TD>
<TD CLASS="CENTER">ESMF:Radius</TD>
</TR>
<TR><TD CLASS="LEFT"><B>ESMF_COORDSYS_SPH_RAD</B></TD>
<TD CLASS="CENTER">ESMF:Lon</TD>
<TD CLASS="CENTER">ESMF:Lat</TD>
<TD CLASS="CENTER">ESMF:Radius</TD>
</TR>
<TR><TD CLASS="LEFT"><B>ESMF_COORDSYS_CART</B></TD>
<TD CLASS="CENTER">ESMF:X</TD>
<TD CLASS="CENTER">ESMF:Y</TD>
<TD CLASS="CENTER">ESMF:Z</TD>
</TR>
</TABLE>

<P>

<H3><A ID="SECTION05092200000000000000"></A>
<A ID="const:maskkeyname"></A>
<BR>
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Masking keyName
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Points within a LocStream can be marked and then potentially ignored during certain 
operations, like regridding.  This masking information must be contained in a key 
named with the appropriate identifier.  ESMF regridding expects this key to be 
of type ESMF_TYPEKIND_I4.

<P>
The valid value is:
<DL>
<DT><STRONG>ESMF:Mask</STRONG></DT>
<DD>
</DD>
</DL>
<H2><A ID="SECTION05093000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<H2><A ID="SECTION05094000000000000000">
<SPAN CLASS="arabic">32</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION050100000000000000000">
<SPAN CLASS="arabic">33</SPAN> Mesh Class</A>
</H1>

<H2><A ID="SECTION050101000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
Unstructured grids are commonly used in the computational solution of partial differential 
equations.  These are especially useful for problems that involve complex geometry, where 
using the less flexible structured grids can result in grid representation of regions 
where no computation is needed.  Finite element and finite volume methods map naturally 
to unstructured grids and are used commonly in hydrology, ocean modeling, and many other 
applications.

<P>
In order to provide support for application codes using unstructured grids, the ESMF library 
provides a class for representing unstructured grids called the <B>Mesh</B>. Fields can be 
created on a Mesh to hold data. Fields created on a Mesh can also be used as either the 
source or destination or both of an interpolation (i.e. an <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> call) 
which allows data to be moved between unstructured grids. This section describes the Mesh 
and how to create and use them in ESMF. 

<P>

<H3><A ID="SECTION050101100000000000000"></A><A ID="sec:meshrep"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh representation in ESMF
</H3>

<P>
A Mesh in ESMF is constructed of <B>nodes</B> and <B>elements</B>.

<P>
A <B>node</B>, also known as a vertex or corner, is a part of a Mesh which represents a single point. Coordinate information is
set in a node.

<P>
An <B>element</B>, also known as a cell, is a part of a mesh which represents a small 
region of space. Elements are described in terms of a connected set of nodes which represent locations along their boundaries.

<P>
Field data may be located on either the nodes or elements of a Mesh. 

<P>

<P>
<BR>

<P>
The dimension of a Mesh in ESMF is specified with two parameters: the <B>parametric dimension</B> and the <B>spatial dimension</B>.

<P>
The <B>parametric dimension</B> of a Mesh is the dimension of the topology of the Mesh. This can be thought of as the dimension of 
the elements which make up the Mesh. For example, a Mesh composed of triangles would have a parametric dimension of 2, whereas
a Mesh composed of tetrahedra would have a parametric dimension of 3. 

<P>
The <B>spatial dimension</B> of a Mesh is the dimension of the space the Mesh is embedded in. In other words, it is the number of coordinate dimensions needed to describe the location of the nodes making up the Mesh. 

<P>
For example, a Mesh constructed of squares on a plane would have a parametric dimension of 2 and a spatial dimension of 2. 
If that same Mesh were used to represent the 2D surface of a sphere, then the Mesh would still have a parametric dimension 
of 2, but now its spatial dimension would be 3. 

<P>

<H3><A ID="SECTION050101200000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Meshes</A>
</H3>

<P>
The range of Meshes supported by ESMF are defined by several factors: dimension, element 
types, and distribution.

<P>
ESMF currently only supports Meshes whose number of coordinate dimensions (spatial dimension) 
is 2 or 3. The dimension of the elements in a Mesh (parametric dimension) must be less than 
or equal to the spatial dimension, but also must be either 2 or 3. This means that a Mesh may 
be either 2D elements in 2D space, 3D elements in 3D space, or a manifold constructed of 2D 
elements embedded in 3D space. 

<P>
ESMF supports a range of elements for each Mesh parametric dimension. For a 
parametric dimension of 2, the native supported element types are triangles and quadrilaterals.
In addition to these, ESMF supports 2D polygons with any number of sides. Internally these
are represented as sets of triangles, but to the user should behave like any other element. 
For a parametric dimension of 3, the supported element types are tetrahedrons
and hexahedrons. See Section&nbsp;<A HREF="#const:meshelemtype">33.2.1</A> for diagrams of these. The Mesh 
supports any combination of element types within a particular dimension, but types from 
different dimensions may not be mixed.  For example, a Mesh cannot be constructed of both 
quadrilaterals and tetrahedra.

<P>
ESMF currently only supports distributions where every node on a PET must be a part of an 
element on that PET. In other words, there must not be nodes without a corresponding element 
on any PET.

<H2><A ID="SECTION050102000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION050102100000000000000"></A>
<A ID="const:meshelemtype"></A>
<BR>
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_MESHELEMTYPE
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
 An ESMF Mesh can be constructed from a combination of different elements. The type of elements that can
be used in a Mesh depends on the Mesh's parameteric dimension, which is set during Mesh creation. The
following are the valid Mesh element types for each valid Mesh parametric dimension (2D or 3D) .

<P>

<P>
<BR>

<P>
<PRE>
                     3                          4 ---------- 3
                    / \                         |            |  
                   /   \                        |            |
                  /     \                       |            |
                 /       \                      |            |
                /         \                     |            |
               1 --------- 2                    1 ---------- 2

           ESMF_MESHELEMTYPE_TRI            ESMF_MESHELEMTYPE_QUAD

     2D element types (numbers are the order for elementConn during Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 2 ESMF supports two native element types (illustrated above),
but also supports polygons with more sides. Internally these polygons are represented as a set of 
triangles, but to the user should behave like other elements. 
To specify the non-native polygons in the <SPAN style="font-family:monospace">elementType</SPAN> argument use the number of corners 
of the polygon (e.g. for a pentagon use 5). The connectivity for a polygon should be specified in counterclockwise order.
The following table summarizes this information:

<P>

<P></P>

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Element Type</TD>
<TD CLASS="CENTER">Number of Nodes</TD>
<TD CLASS="LEFT">Description</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_MESHELEMTYPE_TRI</TD>
<TD CLASS="CENTER">3</TD>
<TD CLASS="LEFT">A triangle</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_MESHELEMTYPE_QUAD</TD>
<TD CLASS="CENTER">4</TD>
<TD CLASS="LEFT">A quadrilateral (e.g. a rectangle)</TD>
</TR>
<TR><TD CLASS="LEFT">N</TD>
<TD CLASS="CENTER">N</TD>
<TD CLASS="LEFT">An N-gon  (e.g. if N=5 a pentagon)</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<BR>

<P>
<PRE>
                                            
                 3                               8---------------7
                /|\                             /|              /|
               / | \                           / |             / |
              /  |  \                         /  |            /  |
             /   |   \                       /   |           /   |
            /    |    \                     5---------------6    |
           4-----|-----2                    |    |          |    |
            \    |    /                     |    4----------|----3
             \   |   /                      |   /           |   /
              \  |  /                       |  /            |  /
               \ | /                        | /             | /
                \|/                         |/              |/
                 1                          1---------------2

       ESMF_MESHELEMTYPE_TETRA             ESMF_MESHELEMTYPE_HEX  

  3D element types (numbers are the order for elementConn during Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 3 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT">Element Type</TD>
<TD CLASS="CENTER">Number of Nodes</TD>
<TD CLASS="LEFT">Description</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_MESHELEMTYPE_TETRA</TD>
<TD CLASS="CENTER">4</TD>
<TD CLASS="LEFT">A tetrahedron (NOT VALID IN BILINEAR OR PATCH REGRID)</TD>
</TR>
<TR><TD CLASS="LEFT">ESMF_MESHELEMTYPE_HEX</TD>
<TD CLASS="CENTER">8</TD>
<TD CLASS="LEFT">A hexahedron (e.g. a cube)</TD>
</TR>
</TABLE>

<P>

<H2><A ID="SECTION050103000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<H2><A ID="SECTION050104000000000000000">
<SPAN CLASS="arabic">33</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION050110000000000000000">
<SPAN CLASS="arabic">34</SPAN> XGrid Class</A>
</H1>

<H2><A ID="SECTION050111000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:xgrid:desc"></A>An exchange grid represents the 2D boundary layer usually between the
atmosphere on one side and ocean and land on the other in an Earth
system model. There are dynamical and thermodynamical processes on
either side of the boundary layer and on the boundary layer itself.
The boundary layer exchanges fluxes from either side and adjusts
boundary conditions for the model components involved. For climate modeling,
it is critical that the fluxes transferred by the boundary layer are
conservative.

<P>
The ESMF exchange grid is implemented as the <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> class. 
Internally it's represented by a collection of the intersected cells
between atmosphere and ocean/land[<A
 HREF="node8.html#BalajiXGrid">10</A>] grids. 
These polygonal cells can have irregular shapes
and can be broken down into triangles facilitating a finite element
approach. 

<P>
There are two ways to create an <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> object from
user supplied information. The first way to create an <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> takes
two lists of <SPAN style="font-family:monospace">ESMF_Grid</SPAN> or <SPAN style="font-family:monospace">ESMF_Mesh</SPAN> that represent the model component grids on
either side of the exchange grid. From the two lists of <SPAN style="font-family:monospace">ESMF_Grid</SPAN> or <SPAN style="font-family:monospace">ESMF_Mesh</SPAN>,
information required for flux exchange calculation between any pair of the 
model components from either side of the exchange grid is computed. In addition, the
internal representation of the <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> is computed and can be optionally stored
as an <SPAN style="font-family:monospace">ESMF_Mesh</SPAN>. This internal representation is the collection of the intersected
polygonal cells as a result of merged <SPAN style="font-family:monospace">ESMF_Mesh</SPAN>es from both sides of the exchange grid.
<SPAN style="font-family:monospace">ESMF_Field</SPAN> can be created on the <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> and used for weight generation
and regridding as the internal representation in the <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> has
a complete geometrical description of the exchange grid.

<P>
The second way 
to create an <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> requires users to supply all necessary information
to compute communication routehandle. A later
call to <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> with the xgrid and source and destination
<SPAN style="font-family:monospace">ESMF_Field</SPAN>s computes the <SPAN style="font-family:monospace">ESMF_Routehandle</SPAN> object for matrix
multiply operation used in model remapping. 

<P>
<SPAN style="font-family:monospace">ESMF_XGrid</SPAN> deals with 2 distinctive kinds of fraction for each Grid or Mesh cell
involved in its creation. The following description applies to both <SPAN style="font-family:monospace">ESMF_Grid</SPAN> 
and <SPAN style="font-family:monospace">ESMF_Mesh</SPAN> involved in the <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> creation process.
The first fraction quantity <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.54ex; " SRC="img36.svg"
 ALT="$f_1$"></SPAN> is the same as defined in direct
Field regrid between a source and destination <SPAN style="font-family:monospace">ESMF_Field</SPAN> pair, namely the fraction
of a total Grid cell area <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.74ex; vertical-align: -0.11ex; " SRC="img37.svg"
 ALT="$A$"></SPAN> that is used in weight generation. The second fraction quantity <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.54ex; " SRC="img38.svg"
 ALT="$f_2$"></SPAN>
is a result of the Grid merging process when multiple <SPAN style="font-family:monospace">ESMF_Grid</SPAN>s or model components
exist on one side of the exchange grid. To compute XGrid, the multiple <SPAN style="font-family:monospace">ESMF_Grid</SPAN>s
are first merged together to form a super mesh. During the merging process, Grids that are
of a higher priority clips into lower priority Grids, creating fractional cells in the lower
priority Grids. Priority is a mechanism to resolve the claim of a surface region by multiple
Grids. To conserve flux, any surface area can only be claimed by a unique Grid. This is
a typical practice in earth system modelling, e.g. to handle land and ocean boundary.

<P>
In addition to the matrix multiply communication routehandle, 
<SPAN style="font-family:monospace">ESMF_XGrid</SPAN> exports both <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.54ex; " SRC="img36.svg"
 ALT="$f_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.54ex; " SRC="img38.svg"
 ALT="$f_2$"></SPAN> to the user through the <SPAN style="font-family:monospace">ESMF_FieldRegridStore()</SPAN> method
because each remapping pair has different <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.54ex; " SRC="img36.svg"
 ALT="$f_1$"></SPAN> and <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.54ex; " SRC="img38.svg"
 ALT="$f_2$"></SPAN> associated with it. <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.54ex; " SRC="img38.svg"
 ALT="$f_2$"></SPAN> from source Grid is 
folded directly in the calculated weight matrices since its used to calculate destination point flux
density <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.74ex; vertical-align: -0.11ex; " SRC="img39.svg"
 ALT="$F$"></SPAN>. The global source flux is defined as <!-- MATH
 $\sum_{g=1}^{g=n\_srcgrid}\sum_{s=1}^{s=n\_srccell}{ f_{1s} f_{2s} A_s F_s }$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.38ex; vertical-align: -1.08ex; " SRC="img40.svg"
 ALT="$\sum_{g=1}^{g=n\_srcgrid}\sum_{s=1}^{s=n\_srccell}{ f_{1s} f_{2s} A_s F_s }$"></SPAN>.
The global destination flux is defined as: 
<!-- MATH
 $\sum_{g=1}^{g=n\_dstgrid}\sum_{d=1}^{d=n\_dstcell}{ \sum_{s=1}^{s=n\_intersect}(w_{sd} F_s) f_{2d} A_d}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 3.38ex; vertical-align: -1.08ex; " SRC="img41.svg"
 ALT="$\sum_{g=1}^{g=n\_dstgrid}\sum_{d=1}^{d=n\_dstcell}{ \sum_{s=1}^{s=n\_intersect}(w_{sd} F_s) f_{2d} A_d}$"></SPAN>, <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.51ex; vertical-align: -0.44ex; " SRC="img42.svg"
 ALT="$w_{sd}$"></SPAN> is the
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.19ex; vertical-align: -0.54ex; " SRC="img38.svg"
 ALT="$f_2$"></SPAN> modified weight intersecting s-th source Grid cell with d-th destination Grid cell.
It can be proved that this formulation of the fractions and 
weight calculation ensures first order global conservation of
flux <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.74ex; vertical-align: -0.11ex; " SRC="img43.svg"
 ALT="$\mathcal{F}$"></SPAN> transferred from source grids to exchange grid, and from exchange grid to destination grids.

<P>

<H2><A ID="SECTION050112000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION050112100000000000000"></A>
<A ID="const:xgridside"></A>
<BR>
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_XGRIDSIDE
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>  
Specify which side of the <SPAN style="font-family:monospace">ESMF_XGrid</SPAN> the current operation is taking place.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_XGridSide_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_XGRIDSIDE_A</STRONG></DT>
<DD>A side of the eXchange Grid, corresponding to the A side of the Grids used to create an XGrid.
</DD>
<DT><STRONG>ESMF_XGRIDSIDE_B</STRONG></DT>
<DD>B side of the eXchange Grid, corresponding to the B side of the Grids used to create an XGrid.
</DD>
<DT><STRONG>ESMF_XGRIDSIDE_BALANCED</STRONG></DT>
<DD>The internally generated balanced side of the eXchange Grid in the middle.
</DD>
</DL>
<H2><A ID="SECTION050113000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<H2><A ID="SECTION050114000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<H3><A ID="SECTION050114100000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Restrictions and Future Work</A>
</H3>

<P>

<OL>
<A ID="XGrid:rest"></A>
<LI><B>CAUTION:</B> Any Grid or Mesh pair picked from the A side and B side of the XGrid 
cannot point to the same Grid or Mesh in memory on a local PET. This prevents Regrid from
selecting the right source and destination grid automatically to calculate the regridding routehandle.
It's okay for the Grid and Mesh to have identical topological and geographical properties as long
as they are stored in different memory.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION050115000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>The XGrid class is implemented in Fortran, and as such is
defined inside the framework by a XGrid derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The XGrid class contains information needed to create Grid, Field, and
communication routehandle.

<P>
</LI>
<LI>XGrid follows the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same XGrids at the same point in their execution. 
In addition to the unison rule, XGrid creation also performs inter-PET
communication within the current executing VM. 
</LI>
</OL>
<H2><A ID="SECTION050116000000000000000">
<SPAN CLASS="arabic">34</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION050120000000000000000">
<SPAN CLASS="arabic">35</SPAN> Geom Class</A>
</H1>

<H2><A ID="SECTION050121000000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF Geom class is used as a container for other ESMF geometry objects (e.g. an ESMF Grid). This allows a generic
representation of a geometry to be passed around (e.g. through a coupled system) without it's specific type being known.
Some operations are supported on a Geom object and more will be added over time as needed. However, if
an unsupported operation is needed, then the specific geometry object can always be pulled out and operated on that way.

<P>
In addition to the geometry object, a Geom can also contain information describing a location on a geometry. For example, in the case of
a Grid, a geometry object will also contain a stagger location. Having this location information allows the creation of Fields and
other capabilities to be performed in the most generic way on a Geom object. For geometries where it is appropriate, the user can
optionally specify this location information during the creation of a Geom object. However, if no location is specified, then default values for
this information are provided which match those which would be used when creating a Field with the specific geometry
(e.g. stagger location ESMF_STAGGERLOC_CENTER for a Grid).

<H2><A ID="SECTION050122000000000000000">
<SPAN CLASS="arabic">35</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API: Geom Methods</A>
</H2>

<H1><A ID="SECTION050130000000000000000">
<SPAN CLASS="arabic">36</SPAN> DistGrid Class</A>
</H1>

<H2><A ID="SECTION050131000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:DistGrid"></A>The ESMF DistGrid class sits on top of the DELayout class and holds domain
information in index space. A DistGrid object captures the index space topology
and describes its decomposition in terms of DEs. Combined with DELayout and VM
the DistGrid defines the data distribution of a domain decomposition across the
computational resources of an ESMF Component.

<P>
The global domain is defined as the union of logically
rectangular (LR) sub-domains or <EM>tiles</EM>. The DistGrid create methods allow
the specification of such a multi-tile global domain and its decomposition into
exclusive, DE-local LR regions according to various degrees of user specified
constraints. Complex index space topologies can be constructed by specifying
connection relationships between tiles during creation.

<P>
The DistGrid class holds domain information for all DEs. Each DE is associated
with a local LR region. No overlap of the regions is allowed. The DistGrid
offers query methods that allow DE-local topology information to be extracted,
e.g. for the construction of halos by higher classes.

<P>
A DistGrid object only contains decomposable dimensions. The minimum rank for a
DistGrid object is 1. A maximum rank does not exist for DistGrid objects, 
however, ranks greater than 7 may lead to difficulties with respect to the
Fortran API of higher classes based on DistGrid. The rank of a DELayout object
contained within a DistGrid object must be equal to the DistGrid rank. Higher
class objects that use the DistGrid, such as an Array object, may be of
different rank than the associated DistGrid object. The higher class object
will hold the mapping information between its dimensions and the DistGrid
dimensions.

<H2><A ID="SECTION050132000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION050132100000000000000"></A>
<A ID="const:distgridmatch"></A>
<BR>
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DISTGRIDMATCH
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Indicates the level to which two DistGrid variables match.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_DistGridMatch_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DISTGRIDMATCH_INVALID:</STRONG></DT>
<DD>Indicates a non-valid matching level. One
  or both DistGrid objects are invalid.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_NONE:</STRONG></DT>
<DD>The lowest valid level of DistGrid matching. 
  This indicates that the DistGrid objects don't match at any of the higher
  levels.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_INDEXSPACE:</STRONG></DT>
<DD>The index space covered by the two
  DistGrid objects is identical. However, differences between the two objects
  prevents a higher matching level.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_TOPOLOGY:</STRONG></DT>
<DD>The topology (i.e. index space and 
  connections) defined by the two DistGrid objects is identical. However, 
  differences between the two objects prevents a higher matching level.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_DECOMP:</STRONG></DT>
<DD>The index space decomposition defined by
   the two DistGrid objects is identical. However, differences between the two
   objects prevents a higher matching level.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_EXACT:</STRONG></DT>
<DD>The two DistGrid objects match in all 
  aspects, including sequence indices. The only aspect that may differ between
  the two objects is their name.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_ALIAS:</STRONG></DT>
<DD>Both DistGrid variables are aliases to the
  exact same DistGrid object in memory.
</DD>
</DL>

<P>

<H2><A ID="SECTION050133000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to create, use and destroy DistGrid objects. In order to produce complete and valid DistGrid objects all of the <SPAN style="font-family:monospace">ESMF_DistGridCreate()</SPAN> calls require to be called in unison i.e. on <EM>all</EM> PETs of a component with a complete set of valid arguments.

<H2><A ID="SECTION050134000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>Multi-tile DistGrids from deBlockList are not yet supported.
</LI>
<LI>The fastAxis feature has not been implemented yet.
</LI>
</UL>
<H2><A ID="SECTION050135000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
<EM>This section will be updated as the implementation of the DistGrid class
nears completion.</EM>

<H2><A ID="SECTION050136000000000000000">
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<H2><A ID="SECTION050137000000000000000"></A>
<A ID="ref:distgridconnection"></A>
<BR>
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API: DistGridConnection Methods
</H2>

<H2><A ID="SECTION050138000000000000000"></A>
<A ID="ref:distgridregdecomp"></A>
<BR>
<SPAN CLASS="arabic">36</SPAN>.<SPAN CLASS="arabic">8</SPAN> Class API: DistGridRegDecomp Methods
</H2>

<H1><A ID="SECTION050140000000000000000">
<SPAN CLASS="arabic">37</SPAN> RouteHandle Class</A>
</H1>

<H2><A ID="SECTION050141000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:RHandle"></A>
<P>
The ESMF RouteHandle class provides a unified interface for all route-based communication methods across the Field, FieldBundle, Array, and ArrayBundle classes. All route-based communication methods implement a pre-computation step, returning a RouteHandle, an execution step, and a release step. Typically the pre-computation, or Store() step will be a lot more expensive (both in memory and time) than the execution step. The idea is that once precomputed, a RouteHandle will be executed many times over during a model run, making the execution time a very performance critical piece of code. In ESMF, Regridding, Redisting, and Haloing are implemented as route-based communication methods. The following sections discuss the RouteHandle concepts that apply uniformly to all route-based communication methods, across all of the above mentioned classes.

<P>

<H2><A ID="SECTION050142000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The user interacts with the RouteHandle class through the route-based communication methods of Field, FieldBundle, Array, and ArrayBundle. The usage of these methods are described in detail under their respective class documentation section. The following examples focus on the RouteHandle aspects common across classes and methods.

<H2><A ID="SECTION050143000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Non-blocking</B> communication via the <SPAN style="font-family:monospace">routesyncflag</SPAN> option is implemented for Fields and Arrays. It is <EM>not</EM> available for FieldBundles and ArrayBundles. The user is advised to use the VMEpoch approach for all cases to achive asynchronicity.

<P>
</LI>
<LI>The <B>dynamic masking</B> feature currently has the following limitations:

<P>

<UL>
<LI>Only available for <SPAN style="font-family:monospace">ESMF_TYPEKIND_R8</SPAN> and <SPAN style="font-family:monospace">ESMF_TYPEKIND_R4</SPAN> Fields and Arrays.

<P>
</LI>
<LI>Only available through the <SPAN style="font-family:monospace">ESMF_FieldRegrid()</SPAN> and <SPAN style="font-family:monospace">ESMF_ArraySMM()</SPAN> methods.

<P>
</LI>
<LI>Destination objects that have undistributed dimensions <EM>after</EM> any distributed dimension are not supported.

<P>
</LI>
<LI>No check is implemented that ensure the user-provided RouteHandle object is suitable for dynamic masking.

<P>
</LI>
</UL>

<P>
</LI>
</UL>
<H2><A ID="SECTION050144000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
Internally all route-based communication calls are implemented as sparse matrix multiplications. The precompute step for all of the supported communication methods can be broken up into three steps:

<OL>
<LI>Construction of the sparse matrix for the specific communication method.
</LI>
<LI>Generation of the communication pattern according to the sparse matrix.
</LI>
<LI>Encoding of the communication pattern for each participating PET in form of an XXE stream.
</LI>
</OL>
<H2><A ID="SECTION050145000000000000000">
<SPAN CLASS="arabic">37</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION050150000000000000000">
<SPAN CLASS="arabic">38</SPAN> I/O Capability</A>
</H1>

<H2><A ID="SECTION050151000000000000000">
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF I/O provides a unified interface for input and output of
high level ESMF objects such as Fields.  ESMF I/O capability is integrated
with third-party software such as <A ID="tex2html34"
  HREF="https://github.com/NCAR/ParallelIO">Parallel I/O (PIO)</A>
to read and write Fortran array data in NetCDF format, and 
<A ID="tex2html35"
  HREF="https://github.com/nlohmann/json">JSON for Modern C++</A>
Library to read Info attribute data in JSON format.  Other file I/O
functionalities, such as writing of error and log messages, input of
configuration parameters from an ASCII file, and lower-level I/O utilities are
covered in different sections of this document.  See the Log Class 
<A HREF="node6.html#sec:Log">49.1</A>, the Config Class <A HREF="node6.html#sec:Config">47.1</A>, and the Fortran 
I/O Utilities, <A HREF="node6.html#sec:IOUtil">53.1</A> respectively.

<P>

<H2><A ID="SECTION050152000000000000000"></A>
<A ID="io:dataio"></A>
<BR>
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">2</SPAN> Data I/O
</H2>

<P>
ESMF provides interfaces for high performance, parallel I/O using ESMF data
objects such as Arrays and Fields.  Currently ESMF only supports I/O of
NetCDF files.  The current ESMF implementation relies on the 
<A ID="tex2html36"
  HREF="https://github.com/NCAR/ParallelIO">Parallel I/O (PIO)</A>
library developed as a collaboration between NCAR and DOE laboratories.  PIO
is built as part of the ESMF build when the environment variable ESMF_PIO is
set to "internal", or is linked against when ESMF_PIO is set to "external"; by
default ESMF_PIO is not set (which results in using the internal PIO if other
aspects of the ESMF build configuration allow it).  When PIO is built with ESMF,
the ESMF methods internally call the PIO interfaces.  When ESMF is not built with
PIO, the ESMF methods are non-operable (no-op) stubs that simply return with
a return code of ESMF_RC_LIB_NOT_PRESENT.  Details about the environment
variables can be found in ESMF User Guide, "Building and Installing the ESMF",
"Third Party Libraries".

<P>
The following methods support parallel data I/O using PIO:

<P>
<DL>
<DT></DT>
<DD><SPAN style="font-family:monospace">ESMF_FieldBundleRead()</SPAN>, section <A HREF="#api:FieldBundleRead"><IMG  ALT="[*]" SRC="crossref.png"></A>.
</DD>
<DT></DT>
<DD><SPAN style="font-family:monospace">ESMF_FieldBundleWrite()</SPAN>, section <A HREF="#api:FieldBundleWrite"><IMG  ALT="[*]" SRC="crossref.png"></A>.
</DD>
<DT></DT>
<DD><SPAN style="font-family:monospace">ESMF_FieldRead()</SPAN>, section <A HREF="#api:FieldRead"><IMG  ALT="[*]" SRC="crossref.png"></A>.
</DD>
<DT></DT>
<DD><SPAN style="font-family:monospace">ESMF_FieldWrite()</SPAN>, section <A HREF="#api:FieldWrite"><IMG  ALT="[*]" SRC="crossref.png"></A>.
</DD>
<DT></DT>
<DD><SPAN style="font-family:monospace">ESMF_ArrayBundleRead()</SPAN>, section <A HREF="#api:ArrayBundleRead"><IMG  ALT="[*]" SRC="crossref.png"></A>.
</DD>
<DT></DT>
<DD><SPAN style="font-family:monospace">ESMF_ArrayBundleWrite()</SPAN>, section <A HREF="#api:ArrayBundleWrite"><IMG  ALT="[*]" SRC="crossref.png"></A>.
</DD>
<DT></DT>
<DD><SPAN style="font-family:monospace">ESMF_ArrayRead()</SPAN>, section <A HREF="#api:ArrayRead"><IMG  ALT="[*]" SRC="crossref.png"></A>.
</DD>
<DT></DT>
<DD><SPAN style="font-family:monospace">ESMF_ArrayWrite()</SPAN>, section <A HREF="#api:ArrayWrite"><IMG  ALT="[*]" SRC="crossref.png"></A>.
</DD>
</DL>

<P>

<H2><A ID="SECTION050153000000000000000">
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">3</SPAN> Data formats</A>
</H2>

<P>
The only format currently supported is NetCDF. The environment variables
ESMF_NETCDF and/or ESMF_PNETCDF must be set to enable this NetCDF-based I/O.
Details about the environment variables can be found in ESMF User Guide,
"Building and Installing the ESMF", "Third Party Libraries".

<P>
<DL>
<DT><STRONG><B>NetCDF</B></STRONG></DT>
<DD>Network Common Data Form (NetCDF) is an interface for 
array-oriented data access. The NetCDF library provides an
implementation of the interface. It also defines a 
machine-independent format for representing scientific data. Together,
the interface, library, and format support the creation, access, and
sharing of scientific data. The NetCDF software was developed at the
Unidata Program Center in Boulder, Colorado. See [<A
 HREF="node8.html#NetCDF3_UsersGuide_C">9</A>].
In geoscience, NetCDF can be naturally used to represent fields
defined on logically rectangular grids. NetCDF use in geosciences is 
specified by CF conventions mentioned above [<A
 HREF="node8.html#NetCDF_CF">8</A>].

<P>
To the extent that data on unstructured grids (or even observations) can be 
represented as one-dimensional arrays, NetCDF can also be used to store these 
data. However, it does not provide a high-level abstraction for this type of 
data. 

<P>
</DD>
</DL>

<P>

<H2><A ID="SECTION050154000000000000000">
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limited data formats supported.</B>
Currently a small fraction of the anticipated data formats is implemented by 
ESMF.  The data I/O uses NetCDF format, and ESMF Info
I/O uses JSON format.  Different libraries are employed for these
different formats.  In future development, a more centralized I/O technique
will likely be defined to provide efficient utilities with a set of standard
APIs that will allow manipulation of multiple standard formats.  Also, the 
ability to automatically detect file formats at runtime will be developed.

<P>
</LI>
<LI><B>Some limitations with multi-tile I/O.</B>
There are a few limitations when doing I/O on multi-tile Arrays and
Fields (e.g., a cubed sphere grid represented as a six-tile grid): This
I/O requires at least as many PETs as there are tiles, and for I/O of
ArrayBundles and FieldBundles, all Arrays / Fields in the bundle must
contain the same number of tiles.

<P>
</LI>
<LI><B>Replicated dimensions.</B>
I/O of Arrays / Fields with replicated dimensions (section
<A HREF="#sec:array:usage:replicated_dims"><IMG  ALT="[*]" SRC="crossref.png"></A>) is only partially working. In
most situations, replicated dimensions appear as dimensions in the
output file; ideally, these replicated dimensions would be removed in
the output file, and we plan to make that change in the future.
Furthermore, slices of the replicated dimensions other than the first
can have garbage values in the output file. In addition, there is an
inconsistency when outputting Arrays / Fields that have a decomposition
with more than one DE per PET: in this case, replicated dimensions are
removed in the output file. Finally, I/O cannot be performed on
multi-tile Arrays / Fields with replicated dimensions.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION050155000000000000000">
<SPAN CLASS="arabic">38</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
For data I/O, the ESMF I/O capability relies on the
<A ID="tex2html37"
  HREF="https://github.com/NCAR/ParallelIO">PIO</A>
and
<A ID="tex2html38"
  HREF="http://www.unidata.ucar.edu/software/netcdf">NetCDF</A>
libraries, and optionally the
<A ID="tex2html39"
  HREF="http://trac.mcs.anl.gov/projects/parallel-netcdf">PNetCDF</A>
library.  For Info attribute I/O, the ESMF I/O capability uses the
<A ID="tex2html40"
  HREF="https://github.com/nlohmann/json">JSON for Modern C++</A>
library to perform reading of JSON files. PIO and JSON for Modern C++
are included with the ESMF distribution; the other libraries must be
installed on the machine of interest.

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1006"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A
 HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A
 HREF="node4.html">3 Superstructure</A>
 &nbsp; <B>  <A ID="tex2html1007"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
