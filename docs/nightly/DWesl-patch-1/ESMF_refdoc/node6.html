<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2025 (Released January 1, 2025) -->
<HTML lang="en">
<HEAD>
<TITLE>5 Infrastructure: Utilities</TITLE>

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2025">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node7.html">
<LINK REL="previous" HREF="node5.html">
<LINK REL="next" HREF="node7.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1145"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node7.html">6 References</A>
<B> Up:</B> <A
 HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A
 HREF="node5.html">4 Infrastructure: Fields and Grids</A>
 &nbsp; <B>  <A ID="tex2html1146"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><A ID="tex2html1147"
  HREF="node6.html#SECTION06010000000000000000"><SPAN CLASS="arabic">39</SPAN> Overview of Infrastructure Utility Classes</A>
<LI><A ID="tex2html1148"
  HREF="node6.html#SECTION06020000000000000000"><SPAN CLASS="arabic">40</SPAN> Info Class (Object Attributes)</A>
<UL>
<LI><A ID="tex2html1149"
  HREF="node6.html#SECTION06021000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN> Migrating from Attribute</A>
<UL>
<LI><A ID="tex2html1150"
  HREF="node6.html#SECTION06021100000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Setting an Attribute</A>
<LI><A ID="tex2html1151"
  HREF="node6.html#SECTION06021200000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Getting an Attribute</A>
</UL>
<LI><A ID="tex2html1152"
  HREF="node6.html#SECTION06022000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">2</SPAN> Key Format Overview</A>
<LI><A ID="tex2html1153"
  HREF="node6.html#SECTION06023000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">3</SPAN> Usage and Examples</A>
<LI><A ID="tex2html1154"
  HREF="node6.html#SECTION06024000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1155"
  HREF="node6.html#SECTION06030000000000000000"><SPAN CLASS="arabic">41</SPAN> Time Manager Utility</A>
<UL>
<LI><A ID="tex2html1156"
  HREF="node6.html#SECTION06031000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">1</SPAN> Time Manager Classes</A>
<LI><A ID="tex2html1157"
  HREF="node6.html#SECTION06032000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">2</SPAN> Calendar</A>
<LI><A ID="tex2html1158"
  HREF="node6.html#SECTION06033000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">3</SPAN> Time Instants and TimeIntervals</A>
<LI><A ID="tex2html1159"
  HREF="node6.html#SECTION06034000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">4</SPAN> Clocks and Alarms</A>
<LI><A ID="tex2html1160"
  HREF="node6.html#SECTION06035000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1161"
  HREF="node6.html#SECTION06036000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
</UL>
<LI><A ID="tex2html1162"
  HREF="node6.html#SECTION06040000000000000000"><SPAN CLASS="arabic">42</SPAN> Calendar Class</A>
<UL>
<LI><A ID="tex2html1163"
  HREF="node6.html#SECTION06041000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1164"
  HREF="node6.html#SECTION06042000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1165"
  HREF="node6.html#SECTION06042100000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_CALKIND</A>
</UL>
<LI><A ID="tex2html1166"
  HREF="node6.html#SECTION06043000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1167"
  HREF="node6.html#SECTION06044000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1168"
  HREF="node6.html#SECTION06045000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1169"
  HREF="node6.html#SECTION06050000000000000000"><SPAN CLASS="arabic">43</SPAN> Time Class</A>
<UL>
<LI><A ID="tex2html1170"
  HREF="node6.html#SECTION06051000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1171"
  HREF="node6.html#SECTION06052000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1172"
  HREF="node6.html#SECTION06053000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1173"
  HREF="node6.html#SECTION06054000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1174"
  HREF="node6.html#SECTION06060000000000000000"><SPAN CLASS="arabic">44</SPAN> TimeInterval Class</A>
<UL>
<LI><A ID="tex2html1175"
  HREF="node6.html#SECTION06061000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1176"
  HREF="node6.html#SECTION06062000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1177"
  HREF="node6.html#SECTION06063000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1178"
  HREF="node6.html#SECTION06064000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1179"
  HREF="node6.html#SECTION06070000000000000000"><SPAN CLASS="arabic">45</SPAN> Clock Class</A>
<UL>
<LI><A ID="tex2html1180"
  HREF="node6.html#SECTION06071000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1181"
  HREF="node6.html#SECTION06072000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1182"
  HREF="node6.html#SECTION06072100000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DIRECTION</A>
</UL>
<LI><A ID="tex2html1183"
  HREF="node6.html#SECTION06073000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1184"
  HREF="node6.html#SECTION06074000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1185"
  HREF="node6.html#SECTION06075000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1186"
  HREF="node6.html#SECTION06080000000000000000"><SPAN CLASS="arabic">46</SPAN> Alarm Class</A>
<UL>
<LI><A ID="tex2html1187"
  HREF="node6.html#SECTION06081000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1188"
  HREF="node6.html#SECTION06082000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1189"
  HREF="node6.html#SECTION06082100000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ALARMLIST</A>
</UL>
<LI><A ID="tex2html1190"
  HREF="node6.html#SECTION06083000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1191"
  HREF="node6.html#SECTION06084000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1192"
  HREF="node6.html#SECTION06085000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1193"
  HREF="node6.html#SECTION06086000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1194"
  HREF="node6.html#SECTION06090000000000000000"><SPAN CLASS="arabic">47</SPAN> Config Class</A>
<UL>
<LI><A ID="tex2html1195"
  HREF="node6.html#SECTION06091000000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A ID="tex2html1196"
  HREF="node6.html#SECTION06091100000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Package history</A>
<LI><A ID="tex2html1197"
  HREF="node6.html#SECTION06091200000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Resource files</A>
</UL>
<LI><A ID="tex2html1198"
  HREF="node6.html#SECTION06092000000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A ID="tex2html1199"
  HREF="node6.html#SECTION06093000000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1200"
  HREF="node6.html#SECTION060100000000000000000"><SPAN CLASS="arabic">48</SPAN> HConfig Class</A>
<UL>
<LI><A ID="tex2html1201"
  HREF="node6.html#SECTION060101000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1202"
  HREF="node6.html#SECTION060102000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1203"
  HREF="node6.html#SECTION060102100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_HCONFIGMATCH</A>
</UL>
<LI><A ID="tex2html1204"
  HREF="node6.html#SECTION060103000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1205"
  HREF="node6.html#SECTION060104000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1206"
  HREF="node6.html#SECTION060105000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1207"
  HREF="node6.html#SECTION060106000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1208"
  HREF="node6.html#SECTION060110000000000000000"><SPAN CLASS="arabic">49</SPAN> Log Class</A>
<UL>
<LI><A ID="tex2html1209"
  HREF="node6.html#SECTION060111000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1210"
  HREF="node6.html#SECTION060112000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1211"
  HREF="node6.html#SECTION060112100000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LOGERR</A>
<LI><A ID="tex2html1212"
  HREF="node6.html#SECTION060112200000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LOGKIND</A>
<LI><A ID="tex2html1213"
  HREF="node6.html#SECTION060112300000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LOGMSG</A>
</UL>
<LI><A ID="tex2html1214"
  HREF="node6.html#SECTION060113000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1215"
  HREF="node6.html#SECTION060114000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1216"
  HREF="node6.html#SECTION060115000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1217"
  HREF="node6.html#SECTION060116000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
<LI><A ID="tex2html1218"
  HREF="node6.html#SECTION060117000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1219"
  HREF="node6.html#SECTION060120000000000000000"><SPAN CLASS="arabic">50</SPAN> DELayout Class</A>
<UL>
<LI><A ID="tex2html1220"
  HREF="node6.html#SECTION060121000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1221"
  HREF="node6.html#SECTION060122000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1222"
  HREF="node6.html#SECTION060122100000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_PIN</A>
<LI><A ID="tex2html1223"
  HREF="node6.html#SECTION060122200000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_SERVICEREPLY</A>
</UL>
<LI><A ID="tex2html1224"
  HREF="node6.html#SECTION060123000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1225"
  HREF="node6.html#SECTION060124000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1226"
  HREF="node6.html#SECTION060125000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1227"
  HREF="node6.html#SECTION060126000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1228"
  HREF="node6.html#SECTION060130000000000000000"><SPAN CLASS="arabic">51</SPAN> VM Class</A>
<UL>
<LI><A ID="tex2html1229"
  HREF="node6.html#SECTION060131000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1230"
  HREF="node6.html#SECTION060132000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A ID="tex2html1231"
  HREF="node6.html#SECTION060132100000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_VMEPOCH</A>
</UL>
<LI><A ID="tex2html1232"
  HREF="node6.html#SECTION060133000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<LI><A ID="tex2html1233"
  HREF="node6.html#SECTION060134000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1234"
  HREF="node6.html#SECTION060135000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A ID="tex2html1235"
  HREF="node6.html#SECTION060136000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1236"
  HREF="node6.html#SECTION060140000000000000000"><SPAN CLASS="arabic">52</SPAN> Profiling and Tracing</A>
<UL>
<LI><A ID="tex2html1237"
  HREF="node6.html#SECTION060141000000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A ID="tex2html1238"
  HREF="node6.html#SECTION060141100000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Profiling</A>
<LI><A ID="tex2html1239"
  HREF="node6.html#SECTION060141200000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Tracing</A>
</UL>
<LI><A ID="tex2html1240"
  HREF="node6.html#SECTION060142000000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A ID="tex2html1241"
  HREF="node6.html#SECTION060142100000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Output a Timing Profile to Text</A>
<LI><A ID="tex2html1242"
  HREF="node6.html#SECTION060142200000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Summarize Timings across Multiple PETs</A>
<LI><A ID="tex2html1243"
  HREF="node6.html#SECTION060142300000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Limit the Set of Profiled PETs</A>
<LI><A ID="tex2html1244"
  HREF="node6.html#SECTION060142400000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Include MPI Communication in the Profile</A>
<LI><A ID="tex2html1245"
  HREF="node6.html#SECTION060142500000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Output a Detailed Trace for Analysis</A>
<LI><A ID="tex2html1246"
  HREF="node6.html#SECTION060142600000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Set the Clock used for Profiling/Tracing</A>
</UL>
<LI><A ID="tex2html1247"
  HREF="node6.html#SECTION060143000000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A ID="tex2html1248"
  HREF="node6.html#SECTION060144000000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</UL>
<LI><A ID="tex2html1249"
  HREF="node6.html#SECTION060150000000000000000"><SPAN CLASS="arabic">53</SPAN> Fortran I/O and System Utilities</A>
<UL>
<LI><A ID="tex2html1250"
  HREF="node6.html#SECTION060151000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A ID="tex2html1251"
  HREF="node6.html#SECTION060152000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A ID="tex2html1252"
  HREF="node6.html#SECTION060152100000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Fortran unit number management</A>
<LI><A ID="tex2html1253"
  HREF="node6.html#SECTION060152200000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Flushing output</A>
</UL>
<LI><A ID="tex2html1254"
  HREF="node6.html#SECTION060153000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN> Design and Implementation Notes</A>
<UL>
<LI><A ID="tex2html1255"
  HREF="node6.html#SECTION060153100000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Fortran unit number management</A>
<LI><A ID="tex2html1256"
  HREF="node6.html#SECTION060153200000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Flushing output</A>
<LI><A ID="tex2html1257"
  HREF="node6.html#SECTION060153300000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sorting algorithms</A>
</UL>
<LI><A ID="tex2html1258"
  HREF="node6.html#SECTION060154000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN> Utility API</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION06000000000000000000">
<SPAN CLASS="arabic">5</SPAN> Infrastructure: Utilities</A>
</H1>
<P>

<H1><A ID="SECTION06010000000000000000">
<SPAN CLASS="arabic">39</SPAN> Overview of Infrastructure Utility Classes</A>
</H1>

<P>
The ESMF utilities are a set of tools for quickly assembling modeling applications.

<P>
The ESMF Info class enables models to be self-describing via metadata, which are instances of JSON-compatible key-value pairs.

<P>
The Time Management Library provides utilities for time and time interval representation and calculation, and higher-level utilities that control model time stepping, via clocks, as well as alarming.

<P>
The ESMF Config class provides configuration management based on NASA DAO's Inpak package, a collection of methods for accessing files containing input parameters stored in an ASCII format.

<P>
The ESMF LogErr class consists of a variety of methods for writing error, warning, and informational messages to log files. A default Log is created during ESMF initialization. Other Logs can be created later in the code by the user.

<P>
The DELayout class provides a layer of abstraction on top of the Virtual Machine (VM) layer. DELayout does this by introducing DEs (Decomposition Elements) as logical resource units. The DELayout object keeps track of the relationship between its DEs and the resources of the associated VM object. A DELayout can be shaped by the user at creation time to best match the computational problem or other design criteria.

<P>
The ESMF VM (Virtual Machine) class is a generic representation of hardware and system software resources. There is exactly one VM object per ESMF Component, providing the execution environment for the Component code. The VM class handles all resource management tasks for the Component class and provides a description of the underlying configuration of the compute resources used by a Component.  In addition to resource description and management, the VM class offers the lowest level of ESMF communication methods.

<P>
The ESMF Fortran I/O utilities provide portable methods to access capabilities which are often implemented in different ways amongst different environments. Currently, two utility methods are implemented: one to find an unopened unit number, and one to flush an I/O buffer.

<H1><A ID="SECTION06020000000000000000"></A>
<A ID="esmf_info_class"></A>
<BR>
<SPAN CLASS="arabic">40</SPAN> Info Class (Object Attributes)
</H1>

<P>
All ESMF base objects (i.e. Array, ArrayBundle, Field, FieldBundle, Grid, Mesh, DistGrid) contain a key-value attribute storage object called <SPAN  CLASS="texttt">ESMF_Info</SPAN>. <SPAN  CLASS="texttt">ESMF_Info</SPAN> objects may also be created independent of a base object. <SPAN  CLASS="texttt">ESMF_Info</SPAN> supports setting and getting key-value pairs where the <SPAN  CLASS="textit">key</SPAN> is a string and the <SPAN  CLASS="textit">value</SPAN> is a scalar or a list of common data types. An <SPAN  CLASS="texttt">ESMF_Info</SPAN> object may have a flat or nested data structure. The purpose of <SPAN  CLASS="texttt">ESMF_Info</SPAN> is to support I/O-compatible metadata structures (i.e. netCDF), internal record-keeping for model execution (NUOPC), and provide a mechanism for custom user metadata attributes.

<P>
<SPAN  CLASS="texttt">ESMF_Info</SPAN> is designed for interoperability. To achieve this goal, <SPAN  CLASS="texttt">ESMF_Info</SPAN> adopted the JSON (Javascript Object Notation) specification. Internally, <SPAN  CLASS="texttt">ESMF_Info</SPAN> uses <SPAN  CLASS="textit">JSON for Modern C++</SPAN> [<A
 HREF="node8.html#json_for_modern_cpp">1</A>] to manage its storage map. There are numerous resources for JSON on the web [<A
 HREF="node8.html#json">6</A>]. Quoting from the <SPAN  CLASS="textit">json.org</SPAN> site [<A
 HREF="node8.html#json">6</A>] when it introduces the format:
<BLOCKQUOTE>
<SPAN  CLASS="textit">JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.</SPAN>
    <SPAN  CLASS="textit">JSON is built on two structures:</SPAN>
    </BLOCKQUOTE>
<UL>
<LI><SPAN  CLASS="textit">A collection of name/value pairs. In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.</SPAN>
</LI>
<LI><SPAN  CLASS="textit">An ordered list of values. In most languages, this is realized as an array, vector, list, or sequence.</SPAN>
    
</LI>
</UL><BLOCKQUOTE>
    <SPAN  CLASS="textit">These are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages also be based on these structures.</SPAN>

</BLOCKQUOTE>

<P>
By adopting JSON compliance for <SPAN  CLASS="texttt">ESMF_Info</SPAN>, ESMF made its core metadata capabilities explicitly interoperable with a widely used data structure. If data may be represented with JSON, then it is compatible with <SPAN  CLASS="texttt">ESMF_Info</SPAN>.

<P>
<SPAN  CLASS="textbf"><SPAN  CLASS="textit">There are some aspects of the <SPAN  CLASS="texttt">ESMF_Info</SPAN> implementation related to JSON and <SPAN  CLASS="textit">JSON for Modern C++</SPAN> that should be noted:</SPAN></SPAN>

<OL>
<LI>JSON supports 64-bit data types for integers and reals ([<A
 HREF="node8.html#json_for_modern_cpp_64bit_int">3</A>], [<A
 HREF="node8.html#json_for_modern_cpp_64bit_float">2</A>]). I4/R4 is converted to I8/R8 and vice versa. <SPAN  CLASS="texttt">ESMF_Info</SPAN> internally tracks 32-bit sets to ensure the data type may be appropriately queried.
</LI>
<LI>The memory overhead per JSON object (e.g. a key-value pair) requires an additional allocator pointer for type generalization [<A
 HREF="node8.html#json_for_modern_cpp_memory_overhead">5</A>]. Hence, the JSON map is not suited for big data storage, offering flexibility in exchange.
</LI>
<LI>Keys are stored in an unordered map sorted in lexicographical order.
</LI>
</OL>

<P>

<H2><A ID="SECTION06021000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN> Migrating from Attribute</A>
</H2>
The <SPAN  CLASS="texttt">ESMF_Info</SPAN> class is a replacement for the <SPAN  CLASS="texttt">ESMF_Attribute</SPAN> class and is the preferred way of managing metadata attributes in ESMF moving forward. It is recommended that users migrate existing <SPAN  CLASS="texttt">ESMF_Attribute</SPAN> calls to the new <SPAN  CLASS="texttt">ESMF_Info</SPAN> API. The <SPAN  CLASS="texttt">ESMF_Info</SPAN> class provides the backend for <SPAN  CLASS="texttt">ESMF_Attribute</SPAN> since ESMF version 8.1. The <SPAN  CLASS="texttt">ESMF_Attribute</SPAN> docs are located in appendix <A HREF="node9.html#appendix_attribute_legacy_api">57</A>. In practice, users should experience no friction when migrating client code. Please email ESMF support in the case of a migration issue. Some structural changes to <SPAN  CLASS="texttt">ESMF_Attribute</SPAN> did occur:

<UL>
<LI>Changed behavior when getting fixed-size lists. List size in storage must match the size of the outgoing list.
</LI>
<LI>Removed ability to use a default value with list gets.
</LI>
<LI>Removed <SPAN  CLASS="texttt">attPackInstanceName</SPAN> from all interfaces.
</LI>
<LI>Removed <SPAN  CLASS="texttt">attcopyFlag</SPAN> from all interfaces.
</LI>
<LI>Removed <SPAN  CLASS="texttt">ESMF_Attribute</SPAN>-managed object linking.
</LI>
<LI>Modified <SPAN  CLASS="texttt">ESMF_AttributeAdd</SPAN> to set the target key to a null JSON value.
</LI>
<LI>Modified <SPAN  CLASS="texttt">ESMF_AttributeSet</SPAN> to not require an attribute added to an <SPAN  CLASS="texttt">ESMF_AttPack</SPAN> be added through <SPAN  CLASS="texttt">ESMF_AttributeAdd</SPAN> before setting.
</LI>
<LI>Removed support for attribute XML I/O.
</LI>
<LI>Removed ability to add multiple nested Attribute packages.
</LI>
<LI>Removed retrieval of "internal" ESMF object Attributes.
</LI>
</UL>

<P>
Below are examples for setting and getting an attribute using <SPAN  CLASS="texttt">ESMF_Info</SPAN> and the legacy <SPAN  CLASS="texttt">ESMF_Attribute</SPAN>. The <SPAN  CLASS="texttt">ESMF_Info</SPAN> interfaces are not overloaded for ESMF object types but rather work off a handle retrieved via a get call.

<P>

<H3><A ID="SECTION06021100000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Setting an Attribute</A>
</H3>
With <SPAN  CLASS="texttt">ESMF_Attribute</SPAN>:
<PRE>
call ESMF_AttributeSet(array, "aKey", 15, rc=rc)
</PRE>
With <SPAN  CLASS="texttt">ESMF_Info</SPAN>:
<PRE>
call ESMF_InfoGetFromHost(array, info, rc=rc)
call ESMF_InfoSet(info, "aKey", 15, rc=rc)
</PRE>

<P>
Notice that the legacy <SPAN style="font-family:monospace">ESMF_Attribute</SPAN> API expects the usage of what was called an "Attribute Package". This essentially corresponds to a namespace similar to what <SPAN style="font-family:monospace">ESMF_Info</SPAN> provides for keys via the JSON Pointer syntax (see <A HREF="#info_key_format">40.2</A>). In the above <SPAN style="font-family:monospace">ESMF_AttributeSet()</SPAN> call, without specification of <SPAN style="font-family:monospace">convention</SPAN> and <SPAN style="font-family:monospace">purpose</SPAN> arguments, the resulting JSON pointer of the key is "/ESMF/General/aKey". This is important to account for when mixing deprecated <SPAN style="font-family:monospace">ESMF_Attribute</SPAN> calls with the <SPAN style="font-family:monospace">ESMF_Info</SPAN> API.

<P>

<H3><A ID="SECTION06021200000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Getting an Attribute</A>
</H3>
With <SPAN  CLASS="texttt">ESMF_Attribute</SPAN>:
<PRE>
call ESMF_AttributeGet(array, "aKey", aKeyValue, rc=rc)
</PRE>
With <SPAN  CLASS="texttt">ESMF_Info</SPAN>:
<PRE>
call ESMF_InfoGetFromHost(array, info, rc=rc)
call ESMF_InfoGet(info, "aKey", aKeyValue, rc=rc)
</PRE>

<P>
Notice again that the <SPAN style="font-family:monospace">ESMF_Attribute</SPAN> API automatically prepends "/ESMF/General/" to the JSON pointer used for key in the absence of <SPAN style="font-family:monospace">convention</SPAN> and <SPAN style="font-family:monospace">purpose</SPAN> arguments.

<P>

<H2><A ID="SECTION06022000000000000000"></A>
<A ID="info_key_format"></A>
<BR>
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">2</SPAN> Key Format Overview
</H2>
A key in the <SPAN  CLASS="texttt">ESMF_Info</SPAN> interface provides the location of a value to retrieve from the key-value storage. Keys in the <SPAN  CLASS="texttt">ESMF_Info</SPAN> class use the JSON Pointer syntax [<A
 HREF="node8.html#json_for_modern_cpp_json_pointer">4</A>]. A forward slash is prepended to string keys if it does not exist. Hence, <SPAN  CLASS="texttt">"aKey"</SPAN> and <SPAN  CLASS="texttt">"/aKey"</SPAN> are equivalent. Note the indexing aspect of the JSON Pointer syntax is not supported.

<P>
Some examples for valid "key" arguments:

<UL>
<LI><SPAN  CLASS="texttt">altitude</SPAN> :: A simple key argument with no nesting.
</LI>
<LI><SPAN  CLASS="texttt">/altitude</SPAN> :: A simple key argument with no nesting with the prepended pointer forward slash.
</LI>
<LI><SPAN  CLASS="texttt">/altitude/height_above_mean_sea_level</SPAN> :: A key for an attribute "height_above_mean_sea_level" nested in a map identified with key "altitude".
</LI>
</UL>
<H2><A ID="SECTION06023000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">3</SPAN> Usage and Examples</A>
</H2>

<H2><A ID="SECTION06024000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION06030000000000000000">
<SPAN CLASS="arabic">41</SPAN> Time Manager Utility</A>
</H1>

<P>
The ESMF Time Manager utility includes software for time and date 
representation and calculations, model time advancement, and the 
identification of unique and periodic events.  Since multi-component 
geophysical applications often require synchronization across
the time management schemes of the individual components, the 
Time Manager's standard calendars and consistent time representation 
promote component interoperability.
<DIV class="CENTER">
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=553>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Drift-free timekeeping through an integer-based internal time 
representation.  Both integers and reals can be specified at the interface.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>The ability to represent time as a rational fraction, to support 
exact timekeeping in applications that involve grid refinement.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Support for many calendar kinds, including user-customized calendars.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Support for both concurrent and sequential modes of component execution.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=553>Support for varying and negative time steps.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION06031000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">1</SPAN> Time Manager Classes</A>
</H2>
There are five ESMF classes that represent time concepts:

<UL>
<LI><B>Calendar</B>  A Calendar can be used to keep track of the 
date as an ESMF Gridded Component advances in time. Standard calendars 
(such as Gregorian and 360-day) and user-specified calendars are 
supported.  Calendars can be queried for quantities such as seconds 
per day, days per month, and days per year.  
</LI>
<LI><B>Time</B> A Time represents a time instant in a particular
calendar, such as November 28, 1964, at 7:31pm EST in the Gregorian 
calendar.  The Time class can be used 
to represent the start and stop time of a time integration.
</LI>
<LI><B>TimeInterval</B> TimeIntervals represent a period 
of time, such as 300 milliseconds.  Time steps can be represented 
using TimeIntervals.  
</LI>
<LI><B>Clock</B> Clocks collect the parameters and 
methods used for model time advancement into a convenient 
package.  A Clock can be queried for quantities such
as start time, stop time, current time, and time step.  Clock
methods include incrementing the current time, and determining
if it is time to stop.  
</LI>
<LI><B>Alarm</B> Alarms identify unique or periodic events
by &ldquo;ringing&rdquo; - returning a true value - at specified times.  
For example, an Alarm might be set to ring on the day of the 
year when leaves start falling from the trees in a climate model.
</LI>
</UL>

<P>
<DIV class="CENTER">
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img44.svg"
 ALT="\includegraphics{TimeMgr_desc}">

</DIV>

<P>
In the remainder of this section, we briefly summarize the 
functionality that the Time Manager classes provide.  Detailed 
descriptions and usage examples precede the API listing for each 
class.

<P>

<H2><A ID="SECTION06032000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">2</SPAN> Calendar</A>
</H2>
An ESMF Calendar can be queried for seconds per day, days per month 
and days per year.  The flexible definition of Calendars allows them
to be defined for planetary bodies other than Earth.  The set of supported 
calendars includes:
<DL>
<DT><STRONG>Gregorian</STRONG></DT>
<DD>The standard Gregorian calendar.
</DD>
<DT><STRONG>no-leap</STRONG></DT>
<DD>The Gregorian calendar with no leap years.
</DD>
<DT><STRONG>Julian</STRONG></DT>
<DD>The standard Julian date calendar.
</DD>
<DT><STRONG>Julian Day</STRONG></DT>
<DD>The standard Julian days calendar.
</DD>
<DT><STRONG>Modified Julian Day</STRONG></DT>
<DD>The Modified Julian days calendar.
</DD>
<DT><STRONG>360-day</STRONG></DT>
<DD>A 30-day-per-month, 12-month-per-year calendar.
</DD>
<DT><STRONG>no calendar</STRONG></DT>
<DD>Tracks only elapsed model time in hours, minutes, seconds.
</DD>
</DL>
See Section&nbsp;<A HREF="#sec:Calendar">42.1</A> for more details on supported standard 
calendars, and how to create a customized ESMF Calendar.

<P>

<H2><A ID="SECTION06033000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">3</SPAN> Time Instants and TimeIntervals</A>
</H2>

<P>
<A ID="subsec:Time_Instants_and_TimeIntervals"></A>TimeIntervals and Time instants (simply called Times) are the computational 
building blocks of the Time Manager utility.  TimeIntervals support operations
such as add, subtract, compare size, reset value, copy value, and subdivide
by a scalar.  Times, which are moments in time associated with specific
Calendars, can be incremented or decremented by TimeIntervals, compared to
determine which of two Times is later, differenced to obtain the TimeInterval
between two Times, copied, reset, and manipulated in other useful ways.
Times support a host of different queries, both for values of individual Time 
components such as year, month, day, and second, and for derived values such 
as day of year, middle of current month and Julian day.  It is also possible 
to retrieve the value of the hardware realtime clock in the form of a 
Time.  See Sections&nbsp;<A HREF="#sec:Time">43.1</A> and&nbsp;<A HREF="#sec:TimeInterval">44.1</A>, respectively,
for use and examples of Times and TimeIntervals.

<P>
Since climate modeling, numerical weather prediction and other 
Earth and space applications have widely varying time scales and require 
different sorts of calendars, Times and TimeIntervals must support 
a wide range of time specifiers, spanning nanoseconds to years.  The
interfaces to these time classes are defined so that the user can specify a time
using a combination of units selected from the list shown in 
Table&nbsp;<A HREF="#table:timeOpts">41.4</A>.  

<P>

<H2><A ID="SECTION06034000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">4</SPAN> Clocks and Alarms</A>
</H2>
Although it is possible to repeatedly step a Time forward by a 
TimeInterval using arithmetic on these basic types, it is useful to 
identify a higher-level concept to represent this function.  We refer to 
this capability as a Clock, and include in its required features the 
ability to store the start and stop times of 
a model run, to check when time advancement should cease, 
and to query the value of quantities such as the current time and the
time at the previous time step.  The Time Manager includes a class 
with methods that return a true value when a periodic or unique event 
has taken place; we refer to these as Alarms.  Applications may contain 
temporary or multiple Clocks and Alarms.  Sections&nbsp;<A HREF="#sec:Clock">45.1</A> and
<A HREF="#sec:Alarm">46.1</A> describe the use of Clocks and Alarms in detail.

<P>
<A ID="table:timeOpts"></A>
<DIV class="CENTER">
</DIV>
<BR><P></P>
<DIV class="CENTER">

<A ID="2460"></A>
<TABLE class="PAD  BORDER" style="">
<CAPTION><STRONG>Table 3:</STRONG>
Specifiers for Times and TimeIntervals</CAPTION>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>Unit</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Meaning</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;yy|yy_i8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Year.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>mm</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Month of the year.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>dd</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Day of the month.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;d|d_i8|d_r8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Julian or Modified Julian day.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;h|h_r8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Hour.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;m|m_r8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Minute.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;s|s_i8|s_r8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Second.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;ms|ms_r8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Millisecond.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;us|us_r8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Microsecond.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;ns|ns_r8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Nanosecond.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>O</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Time zone offset in integer number of hours and minutes.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;sN|sN_i8&gt;</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Numerator for times of the form s <B><!-- MATH
 $+
\frac{{\rm sN}}{{\rm sD}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.92ex; vertical-align: -0.88ex; " SRC="img45.svg"
 ALT="$+
\frac{{\rm sN}}{{\rm sD}}$"></SPAN></B>, where s is seconds and s, sN, and
sD are integers.  This format provides a mechanism for supporting
exact behavior.</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92><B>&lt;sD|sD_i8</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Denominator for times of the form s <B><!-- MATH
 $+
\frac{{\rm sN}}{{\rm sD}}$
 -->
<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.92ex; vertical-align: -0.88ex; " SRC="img45.svg"
 ALT="$+
\frac{{\rm sN}}{{\rm sD}}$"></SPAN></B>, where s is seconds and s, sN, and
sD are integers.</TD>
</TR>
</TABLE>
</DIV>
<BR>
<DIV class="CENTER">
</DIV>

<P>

<H2><A ID="SECTION06035000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<OL>
<LI><B>Base TimeIntervals and Times on the same integer representation.</B> 
It is useful to allow both TimeIntervals and Times to 
inherit from a single class, BaseTime.  In C++, this can be
implemented by using inheritance.  In Fortran, it can be implemented
by having the derived types TimeIntervals and Times
contain a derived type BaseTime.  In both cases, the 
BaseTime class can be made private and invisible to the user.

<P>
The result of this strategy is that Time Intervals and 
Times gain a consistent core representation of time as well a set
of basic methods.

<P>
The BaseTime class can be designed with a minimum number of elements
to represent any required time.  The design is based on the idea used
in the real-time POSIX 1003.1b-1993 standard.  That is, to represent
time simply as a pair of integers: one for seconds (whole) and one for
nanoseconds (fractional).  These can then be converted at the interface
level to any desired format.

<P>
For ESMF, this idea can be modified and extended, in order to handle the
requirements for a large time range (&gt; 200,000 years) and to exactly
represent any rational fraction, not just nanoseconds.  To handle the
large time range, a 64-bit or greater integer is used for whole seconds.
Any rational fractional second is expressed using two additional integers:
a numerator and a denominator.  Both the whole seconds and fractional
numerator are signed to handle negative time intervals and instants.
For arithmetic consistency both must carry the same sign (both positive
or both negative), except, of course, for zero values.  The fractional
seconds element (numerator) is bounded with respect to whole seconds. 
If the absolute value of the
numerator becomes greater than or equal to the denominator, whole
seconds are incremented or decremented accordingly and the numerator is
reset to the remainder.  Conversions are performed upon demand by
interface methods within the TimeInterval and
Time classes.  This is done because different applications require different
representations of time intervals and time instances.  Floating point values as well as integers can be specified for the various time units in the interfaces, see Table&nbsp;<A HREF="#table:timeOpts">41.4</A>.  Floating point values are represented internally as integer-based rational fractions.

<P>
The BaseTime class defines increment and decrement methods for basic
TimeInterval calculations between Time instants.  It is done here rather
than in the Calendar class because it can be done with simple 
second-based arithmetic that is calendar independent.  

<P>
Comparison methods can also be defined in the BaseTime class.  These
perform equality/inequality, less than, and greater than comparisons
between any two TimeIntervals or Times.  These methods capture
the common comparison logic between TimeIntervals and Times and
hence are defined here for sharing.

<P>
</LI>
<LI><B>The Time class depends on a calendar.</B> The Time class contains 
an internal Calendar class.  
Upon demand by a user, the results of an increment or decrement operation are 
converted to user units, which may be calendar-dependent, via methods 
obtained from their internal Calendar.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION06036000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
Time Manager utility.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV class="CENTER">
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img46.svg"
 ALT="\includegraphics{TimeMgr_obj}">   

</DIV>

<H1><A ID="SECTION06040000000000000000">
<SPAN CLASS="arabic">42</SPAN> Calendar Class</A>
</H1>

<H2><A ID="SECTION06041000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:Calendar"></A>The Calendar class represents the standard calendars used in 
geophysical modeling:  Gregorian, Julian, Julian Day, Modified Julian Day, 
no-leap, 360-day, and no-calendar.  It also supports a user-customized 
calendar.  Brief descriptions are provided for each calendar below.  For more 
information on standard calendars, see&nbsp;[<A
 HREF="node8.html#Seidelman">20</A>] and&nbsp;[<A
 HREF="node8.html#Meyer1">17</A>].

<H2><A ID="SECTION06042000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>
<A ID="subsec:Calendar_options"></A>
<P>

<H3><A ID="SECTION06042100000000000000"></A>
<A ID="const:calkindflag"></A>
<BR>
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_CALKIND
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Supported calendar kinds.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_CalKind_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_CALKIND_360DAY</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
In the 360-day calendar, there are 12 months, each of which has 30 days.  
Like the no-leap calendar, this is a simple approximation to the Gregorian
calendar sometimes used by modelers.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_CUSTOM</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
The user can set calendar parameters in the generic calendar.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_GREGORIAN</STRONG></DT>
<DD><I>Valid range: 3/1/4801 BC to 10/29/292,277,019,914 </I>
<BR>
The Gregorian calendar is the calendar currently in use 
throughout Western countries.  Named after Pope Gregory XIII, it is a minor 
correction to the older Julian calendar. In the Gregorian calendar every
fourth year is a leap year in which February has 29 and not 28 days;
however, years divisible by 100 are not leap years unless they are also 
divisible  by 400.  As in the Julian calendar, days begin at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_JULIAN</STRONG></DT>
<DD><I>Valid range: 3/1/4713 BC to 4/24/292,271,018,333 </I> 
<BR>
The Julian calendar was introduced by Julius Caesar in 46 B.C., and 
reached its final form in 4 A.D.  The Julian calendar differs from the 
Gregorian only in the determination of leap years, lacking the correction 
for years divisible by 100 and 400 in the Gregorian calendar.  In the Julian 
calendar, any year is a leap year if divisible by 4.  Days are considered to 
begin at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_JULIANDAY</STRONG></DT>
<DD><I>Valid range:  +/- 1x10<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img47.svg"
 ALT="$^{14}$"></SPAN></I> 
<BR>
Julian days simply enumerate the days and fraction of a day which 
have elapsed since the start of the Julian era, defined as beginning at noon 
on Monday, 1st January of year 4713 B.C. in the Julian calendar.  Julian days, 
unlike the dates in the Julian and Gregorian calendars, begin at noon.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_MODJULIANDAY</STRONG></DT>
<DD><I>Valid range:  +/- 1x10<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img47.svg"
 ALT="$^{14}$"></SPAN></I>
<BR>
The Modified Julian Day (MJD) was introduced by space scientists in
 the late 1950's.  It is defined as an offset from the Julian Day (JD):

<P>
MJD = JD - 2400000.5

<P>
The half day is subtracted so that the day starts at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_NOCALENDAR</STRONG></DT>
<DD><I>Valid range: machine limits</I>
<BR>
The no-calendar option simply tracks the elapsed model time in seconds.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_NOLEAP</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
The no-leap calendar is the Gregorian calendar with no leap years - 
February is always assumed to have 28 days.  Modelers sometimes use this 
calendar as a simple, close approximation to the Gregorian calendar.

<P>
</DD>
</DL>
<H2><A ID="SECTION06043000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
In most multi-component Earth system applications, the timekeeping in 
each component 
must refer to the same standard calendar in order for the components 
to properly synchronize.  It therefore makes sense to create as few 
ESMF Calendars as possible, preferably one per application.
A typical strategy would be to create a single Calendar at the start
of an application, and use that Calendar in all subsequent calls that
accept a Calendar, such as <SPAN style="font-family:monospace">ESMF_TimeSet</SPAN>.

<P>
The following example shows how to set up an ESMF Calendar.  

<H2><A ID="SECTION06044000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>
<A ID="subsec:Calendar_rest"></A>
<P>

<OL>
<LI><B>Months per year set to 12.</B> Due to the requirement of only Earth modeling, the number of months per year is hard-coded at 12.  However, for easy modification, this is implemented via a C preprocessor #define MONTHS_PER_YEAR in ESMCI_Calendar.h.

<P>
</LI>
<LI><B>Calendar date conversions.</B> Date conversions are currently defined between the Gregorian, Julian, Julian Day, and Modified Julian Day calendars. Further research and work would need to be done to determine conversion algorithms with and between the other calendars:  No Leap, 360 Day, and Custom.

<P>
</LI>
<LI><B>ESMF_CALKIND_CUSTOM.</B> Currently, there is no provision for a custom calendar to define a leap year rule, so <SPAN style="font-family:monospace">ESMF_CalendarIsLeapYear()</SPAN> will always return <SPAN style="font-family:monospace">.false.</SPAN> in this case.  However, the arguments <SPAN style="font-family:monospace">daysPerYear</SPAN>, <SPAN style="font-family:monospace">daysPerYearDn</SPAN>, and <SPAN style="font-family:monospace">daysPerYearDd</SPAN> in <SPAN style="font-family:monospace">ESMF_CalendarCreate()</SPAN> and <SPAN style="font-family:monospace">ESMF_CalendarSet()</SPAN> can be used to set a fractional number of days per year, for example, 365.25 = 365 25/100.  Also, if further timekeeping precision is required, fractional and/or floating point <SPAN style="font-family:monospace">secondsPerDay</SPAN> and <SPAN style="font-family:monospace">secondsPerYear</SPAN> could be added to the interfaces <SPAN style="font-family:monospace">ESMF_CalendarCreate()</SPAN>, <SPAN style="font-family:monospace">ESMF_CalendarSet()</SPAN>, and <SPAN style="font-family:monospace">ESMF_CalendarGet()</SPAN> and implemented.

<P>
</LI>
</OL>
<H2><A ID="SECTION06045000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION06050000000000000000">
<SPAN CLASS="arabic">43</SPAN> Time Class</A>
</H1>

<H2><A ID="SECTION06051000000000000000"></A>
<A ID="sec:Time"></A>
<BR>
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description
</H2>

<P>
A Time represents a specific point in time.  In order to accommodate
the range of time scales in Earth system applications, Times in
the ESMF can be specified in many different ways, from years to
nanoseconds.  The Time interface is designed so that you select one or 
more options from a list of time units in order to specify a 
Time. The options for specifying a Time are shown in 
Table&nbsp;<A HREF="#table:timeOpts">41.4</A>.  

<P>
There are Time methods defined for setting and getting a
Time, incrementing and decrementing a Time by a TimeInterval,
taking the difference between two Times, and comparing Times.
Special quantities such as the middle of the month and the 
day of the year associated with a particular Time can be retrieved. 
There is a method for returning the Time value as a string in 
the ISO 8601 format YYYY-MM-DDThh:mm:ss [<A
 HREF="node8.html#ISO">15</A>].

<P>
A Time that is specified in hours, minutes, seconds, or subsecond intervals 
does not need to be associated with a standard calendar; a Time whose
specification includes time units of a day and greater must be.  The 
ESMF representation
of a calendar, the Calendar class, is described in Section&nbsp;<A HREF="#sec:Calendar">42.1</A>.
The <SPAN style="font-family:monospace">ESMF_TimeSet</SPAN> method is used to initialize a Time as well as
associate it with a Calendar.  If a Time method is invoked in which a Calendar
is necessary and one has not been set, the ESMF method will return an error
condition.

<P>
In the ESMF the TimeInterval class is used to represent time periods.
This class is frequently used in combination with the Time class.
The Clock class, for example, advances model time by incrementing a
Time with a TimeInterval. 

<P>

<H2><A ID="SECTION06052000000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
Times are most frequently used to represent start, stop, and current 
model times.  The following examples show how to create, initialize, and
manipulate <SPAN style="font-family:monospace">Time</SPAN>.

<P>

<H2><A ID="SECTION06053000000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limits on size and resolution of Time.</B>  The limits on the size and 
resolution of the time representation are based on the
64-bit integer types used.  For seconds, a signed 64-bit integer
will have a range of +/- <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img48.svg"
 ALT="$2^{63}$"></SPAN>-1, or +/- 9,223,372,036,854,775,807.  This
corresponds to a maximum size of +/- (<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img48.svg"
 ALT="$2^{63}$"></SPAN>-1)/(86400 * 365.25) or
+/- 292,271,023,045 years.

<P>
For fractional seconds, a signed 64-bit integer will handle a resolution of
+/- <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img49.svg"
 ALT="$2^{31}$"></SPAN>-1, or +/- 9,223,372,036,854,775,807 parts of a second.

<P>
</LI>
</OL>
<H2><A ID="SECTION06054000000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION06060000000000000000">
<SPAN CLASS="arabic">44</SPAN> TimeInterval Class</A>
</H1>

<H2><A ID="SECTION06061000000000000000"></A>
<A ID="sec:TimeInterval"></A>
<BR>
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description
</H2>
A TimeInterval represents a period between time instants.  
It can be either positive or negative.  Like the Time interface, 
the TimeInterval interface is designed so that you can choose 
one or more options from a list of time units in order 
to specify a TimeInterval.
See Section&nbsp;<A HREF="#subsec:Time_Instants_and_TimeIntervals">41.3</A>, 
Table&nbsp;<A HREF="#table:timeOpts">41.4</A> for the available options.

<P>
There are TimeInterval methods defined for setting and getting 
a TimeInterval, for incrementing and decrementing a TimeInterval 
by another TimeInterval, and for multiplying and dividing 
TimeIntervals by integers, reals, fractions and other TimeIntervals.  
Methods are also defined to take the absolute value and negative 
absolute value of a TimeInterval, and for comparing the length of two
TimeIntervals.

<P>
The class used to represent time instants in ESMF is Time,
and this class is frequently used in operations along with 
TimeIntervals.  For example, the difference between two
Times is a TimeInterval.  

<P>
When a TimeInterval is used in calculations that involve an absolute 
reference time, such as incrementing a Time with a TimeInterval, calendar 
dependencies may be introduced.  The length of the time period that the 
TimeInterval represents will depend on the reference Time and the 
standard calendar that is associated with it.  The calendar dependency becomes 
apparent when, for example, adding a TimeInterval of 1 day to the Time 
of February 28, 1996, at 4:00pm EST.  In a 360 day calendar, the 
resulting date would be February 29, 1996, at 4:00pm EST.  In a no-leap 
calendar, the result would be March 1, 1996, at 4:00pm EST.

<P>
TimeIntervals are used by other parts of the ESMF timekeeping
system, such as Clocks (Section&nbsp;<A HREF="#sec:Clock">45.1</A>) and Alarms 
(Section&nbsp;<A HREF="#sec:Alarm">46.1</A>).

<P>

<H2><A ID="SECTION06062000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A typical use for a TimeInterval in a geophysical model 
is representation of the time step by which the model is 
advanced.  Some models change the size of their time step as 
the model run progresses; this could
be done by incrementing or decrementing the original time 
step by another TimeInterval, or by dividing or multiplying
the time step by an integer value.  An example of advancing 
model time using a TimeInterval representation of a time
step is shown in Section&nbsp;<A HREF="#sec:Clock">45.1</A>.

<P>
The following brief example shows how to create, initialize 
and manipulate <SPAN style="font-family:monospace">TimeInterval</SPAN>.

<P>

<H2><A ID="SECTION06063000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limits on time span.</B> The limits on the time span that can be
represented are based on the 64-bit integer types used.  For
seconds, a signed 64-bit integer will have a range of +/- <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img48.svg"
 ALT="$2^{63}$"></SPAN>-1, or
+/- 9,223,372,036,854,775,807.  This corresponds to a range of
+/- (<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img48.svg"
 ALT="$2^{63}$"></SPAN>-1)/(86400 * 365.25) or +/- 292,271,023,045 years.

<P>
For fractional seconds, a signed 64-bit integer will handle a resolution of
+/- <SPAN CLASS="MATH"><IMG
 STYLE="height: 2.02ex; vertical-align: -0.11ex; " SRC="img49.svg"
 ALT="$2^{31}$"></SPAN>-1, or +/- 9,223,372,036,854,775,807 parts of a second.

<P>
</LI>
</OL>
<H2><A ID="SECTION06064000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION06070000000000000000">
<SPAN CLASS="arabic">45</SPAN> Clock Class</A>
</H1>

<H2><A ID="SECTION06071000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:Clock"></A>
<P>
The Clock class advances model time and tracks its associated
date on a specified Calendar.  It stores start time, stop time,
current time, previous time, and a time step.  It can also store
a reference time, typically the time instant at which a simulation 
originally began.  For a restart run, the reference time can be 
different than the start time, when the application execution resumes.

<P>
A user can call the <SPAN style="font-family:monospace">ESMF_ClockSet</SPAN> method and reset the time 
step as desired.  

<P>
A Clock also stores a list of Alarms, which can be set to flag 
events that occur at a specified time instant or at 
a specified time interval.  See Section&nbsp;<A HREF="#sec:Alarm">46.1</A> for 
details on how to use Alarms.

<P>
There are methods for setting and getting the Times and 
Alarms associated with a Clock.  Methods are defined for 
advancing the Clock's current time, checking if the 
stop time has been reached, reversing direction, and 
synchronizing with a real clock. 

<P>

<H2><A ID="SECTION06072000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION06072100000000000000"></A>
<A ID="const:direction"></A>
<BR>
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DIRECTION
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

Specifies the time-stepping direction of a clock.  Use with "direction"
argument to methods <SPAN style="font-family:monospace">ESMF_ClockSet()</SPAN> and <SPAN style="font-family:monospace">ESMF_ClockGet()</SPAN>.
Cannot be used with method <SPAN style="font-family:monospace">ESMF_ClockCreate()</SPAN>, since it only
initializes a clock in the default forward mode; a clock must be advanced
(timestepped) at least once before reversing direction via
<SPAN style="font-family:monospace">ESMF_ClockSet()</SPAN>.  This also holds true for negative timestep clocks
which are initialized (created) with stopTime &lt; startTime, since "forward"
means timestepping from startTime towards stopTime
(see <SPAN style="font-family:monospace">ESMF_DIRECTION_FORWARD</SPAN> below).

<P>
"Forward" and "reverse" directions are distinct from positive and negative
timesteps.  "Forward" means timestepping in the direction established at
<SPAN style="font-family:monospace">ESMF_ClockCreate()</SPAN>, from startTime towards stopTime, regardless
of the timestep sign.  "Reverse" means timestepping in the opposite direction,
back towards the clock's startTime, regardless of the timestep sign.

<P>
Clocks and alarms run in reverse in such a way that the state of a clock and
its alarms after each time step is precisely replicated as it was in forward
time-stepping mode.  All methods which query clock and alarm state will
return the same result for a given timeStep, regardless of the direction of
arrival.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_Direction_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DIRECTION_FORWARD</STRONG></DT>
<DD>Upon calling <SPAN style="font-family:monospace">ESMF_ClockAdvance()</SPAN>, the clock will timestep from
its startTime toward its stopTime.  This is the default direction.  A user
can use either <SPAN style="font-family:monospace">ESMF_ClockIsStopTime()</SPAN> or <SPAN style="font-family:monospace">ESMF_ClockIsDone()</SPAN>
methods to determine when stopTime is reached.  This forward behavior also
holds for negative timestep clocks which are initialized (created) with
stopTime &lt; startTime.

<P>
</DD>
<DT><STRONG>ESMF_DIRECTION_REVERSE</STRONG></DT>
<DD>Upon calling <SPAN style="font-family:monospace">ESMF_ClockAdvance()</SPAN>, the clock will timestep backwards
toward its startTime.  Use method <SPAN style="font-family:monospace">ESMF_ClockIsDone()</SPAN> to determine when
startTime is reached.  This reverse behavior also holds for negative timestep
clocks which are initialized (created) with stopTime &lt; startTime.

<P>
</DD>
</DL>

<P>

<H2><A ID="SECTION06073000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The following is a typical sequence for using a Clock in a 
geophysical model.

<P>
<B>At initialize:</B>

<UL>
<LI>Set a Calendar.
</LI>
<LI>Set start time, stop time and time step as Times and 
Time Intervals.
</LI>
<LI>Create and Initialize a Clock using the start time, stop time and time
step.
</LI>
<LI>Define Times and Time Intervals associated with special
events, and use these to set Alarms.
</LI>
</UL>

<P>
<B>At run:</B>

<UL>
<LI>Advance the Clock, checking for ringing alarms as needed.
</LI>
<LI>Check if it is time to stop.
</LI>
</UL>

<P>
<B>At finalize:</B>

<UL>
<LI>Since Clocks and Alarms are deep classes, they need to be explicitly
destroyed at finalization.  Times and TimeIntervals are lightweight classes,
so they don't need explicit destruction.
</LI>
</UL>

<P>
The following code example illustrates Clock usage.

<P>

<H2><A ID="SECTION06074000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Alarm list allocation factor</B>  The alarm list within a clock is
dynamically allocated automatically, 200 alarm references at a time.
This constant is defined in both Fortran and C++ with a #define for ease
of modification.

<P>
</LI>
<LI><B>Clock variable timesteps in reverse</B> 

In order for a clock with
variable timesteps to be run in <SPAN style="font-family:monospace">ESMF_DIRECTION_REVERSE</SPAN>, the user must
supply those timesteps to <SPAN style="font-family:monospace">ESMF_ClockAdvance()</SPAN>.  Essentially, the user
must save the timesteps while in forward mode.  In a future release, the
Time Manager will assume this responsibility by saving the clock state
(including the timeStep) at every timestep while in forward mode.

<P>
</LI>
</OL>
<H2><A ID="SECTION06075000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION06080000000000000000">
<SPAN CLASS="arabic">46</SPAN> Alarm Class</A>
</H1>

<H2><A ID="SECTION06081000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:Alarm"></A>The Alarm class identifies events that occur at specific Times
or specific TimeIntervals by returning a true value at those times
or subsequent times, and a false value otherwise.  

<P>

<H2><A ID="SECTION06082000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION06082100000000000000"></A>
<A ID="const:alarmlist"></A>
<BR>
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ALARMLIST
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Specifies the characteristics of Alarms that populate
a retrieved Alarm list.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_AlarmList_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ALARMLIST_ALL</STRONG></DT>
<DD>All alarms.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_NEXTRINGING</STRONG></DT>
<DD>Alarms that will ring before or at the next timestep.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_PREVRINGING</STRONG></DT>
<DD>Alarms that rang at or since the last timestep.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_RINGING</STRONG></DT>
<DD>Only ringing alarms.

<P>
</DD>
</DL>

<P>

<H2><A ID="SECTION06083000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
Alarms are used in conjunction with Clocks (see Section&nbsp;<A HREF="#sec:Clock">45.1</A>).
Multiple Alarms can be associated with a Clock.  During the
<SPAN style="font-family:monospace">ESMF_ClockAdvance()</SPAN> method, a Clock iterates over its internal Alarms
to determine if any are ringing.  Alarms ring when a specified Alarm 
time is reached or exceeded, taking into account whether the time step is
positive or negative.  In <SPAN style="font-family:monospace">ESMF_DIRECTION_REVERSE</SPAN>
(see Section&nbsp;<A HREF="#sec:Clock">45.1</A>), alarms ring in reverse, i.e., they begin
ringing when they originally ended, and end ringing when they originally
began.  On completion of the time advance call, the Clock optionally returns
a list of ringing alarms.

<P>
Each ringing Alarm can then be processed using Alarm methods for identifying,
turning off, disabling or resetting the Alarm.

<P>
Alarm methods are defined for obtaining the ringing state, turning the
ringer on/off, enabling/disabling the Alarm, and getting/setting 
associated times.

<P>
The following example shows how to set and process Alarms.

<H2><A ID="SECTION06084000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Alarm list allocation factor</B>  The alarm list within a clock is
dynamically allocated automatically, 200 alarm references at a time.
This constant is defined in both Fortran and C++ with a #define for ease
of modification.

<P>
</LI>
<LI><B>Sticky alarm end times in reverse</B>  For sticky alarms, there is
an implicit limitation that in order to properly reverse timestep through a
ring end time, that time must have already been traversed in the forward
direction.  This is due to the fact that the Time Manager cannot predict
when user code will call <SPAN style="font-family:monospace">ESMF_AlarmRingerOff()</SPAN>.  An error message
will be logged when this limitation is not satisfied.

<P>
</LI>
<LI><B>Sticky alarm ring interval in reverse</B>  

For repeating sticky alarms,
it is currently assumed that the ringInterval is constant, so that only the
time of the last call to <SPAN style="font-family:monospace">ESMF_AlarmRingerOff()</SPAN> is saved.  In
<SPAN style="font-family:monospace">ESMF_DIRECTION_REVERSE</SPAN>, this information is used to turn sticky alarms
back on.  In a future release, ringIntervals will be allowed to be variable,
by saving alarm state at every timestep.

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION06085000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The Alarm class is designed as a deep, dynamically allocatable class,
based on a pointer type.  This allows for both indirect and direct
manipulation of alarms.  Indirect alarm manipulation is where ESMF_Alarm API
methods, such as ESMF_AlarmRingerOff(), are invoked on alarm references
(pointers) returned from ESMF_Clock queries such as "return ringing alarms."
Since the method is performed on an alarm reference, the actual alarm held
by the clock is affected, not just a user's local copy.  Direct alarm
manipulation is the more common case where alarm API methods are invoked on
the original alarm objects created by the user.

<P>
For consistency, the ESMF_Clock class is also designed as a deep, dynamically
allocatable class. 

<P>
An additional benefit from this approach is that Clocks and Alarms can be
created and used from anywhere in a user's code without regard to the scope
in which they were created.  In contrast, statically created Alarms and
Clocks would disappear if created within a user's routine that returns,
whereas dynamically allocated Alarms and Clocks will persist until explicitly
destroyed by the user.

<H2><A ID="SECTION06086000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION06090000000000000000">
<SPAN CLASS="arabic">47</SPAN> Config Class</A>
</H1>

<H2><A ID="SECTION06091000000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:Config"></A>
<P>
ESMF Configuration Management is based on NASA DAO's 
Inpak 90 package, a Fortran 90 collection of routines/functions
for accessing <EM>Resource Files</EM> in ASCII format.The package 
is optimized for minimizing formatted I/O, performing all of its 
string operations in memory using Fortran intrinsic functions.
<BR>
<P>

<H3><A ID="SECTION06091100000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Package history</A>
</H3>

<P>
The ESMF Configuration Management Package was evolved by
Leonid Zaslavsky and Arlindo da Silva from Ipack90 package
created by Arlindo da Silva at NASA DAO.

<P>
Back in the 70's Eli Isaacson wrote IOPACK in Fortran
66.  In June of 1987 Arlindo da Silva wrote Inpak77 using
Fortran 77 string functions; Inpak 77 is a vastly
simplified IOPACK, but has its own goodies not found in
IOPACK.  Inpak 90 removes some obsolete functionality in
Inpak77, and parses the whole resource file in memory for
performance.

<P>

<H3><A ID="SECTION06091200000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Resource files</A>
</H3>

<P>
A <EM>Resource File (RF)</EM> is a text file consisting of list of 
   <EM>label</EM>-<EM>value</EM> pairs. There is a buffer limit of 256,000 
   characters for the entire Resource File. Each <EM>label</EM> is limited 
   to 1,000 characters. Each label should be followed by some data, the 
   <EM>value</EM>. An example Resource File follows. It is the file used 
   in the example below. 

<P>
<PRE>
 # This is an example Resource File.  
 # It contains a list of &lt;label,value&gt; pairs.
 # The colon after the label is required. 

 # The values after the label can be an list.
 # Multiple types are authorized.
  
  my_file_names:         jan87.dat jan88.dat jan89.dat  # all strings
  constants:             3.1415   25                    # float and integer
  my_favorite_colors:    green blue 022               


 # Or, the data can be a list of single value pairs. 
 # It is simplier to retrieve data in this format:

  radius_of_the_earth:   6.37E6         
  parameter_1:           89
  parameter_2:           78.2
  input_file_name:       dummy_input.nc


 # Or, the data can be located in a table using the following
 # syntax:

  my_table_name::
   1000     3000     263.0
    925     3000     263.0
    850     3000     263.0
    700     3000     269.0
    500     3000     287.0
    400     3000     295.8
    300     3000     295.8
  ::
</PRE>

<P>
Note that the colon after the label is required and that the double colon is required
 to declare tabular data. 

<P>
Resource files are intended for random access (except between ::'s in a 
 table definition). This means that order in which a particular 
 <EM>label-value</EM> pair is retrieved is not dependent upon the original order 
 of the pairs. The only exception to this, however, is when the same <EM>label</EM> appears 
 multiple times within the Resource File.

<P>

<H2><A ID="SECTION06092000000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<H2><A ID="SECTION06093000000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION060100000000000000000">
<SPAN CLASS="arabic">48</SPAN> HConfig Class</A>
</H1>

<H2><A ID="SECTION060101000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:HConfig"></A>
<P>
The ESMF HConfig class implements a hierarchical configuration facility that is
compatible with YAML Ain't Markup Language (YAML<SUP><SMALL>TM</SMALL></SUP>). ESMF HConfig
can be understood as a Fortran interface to YAML. However, no claim is made that
<EM>all</EM> YAML language features are supported in their entirety.

<P>
The purpose of the HConfig class under ESMF is to provide a migration path
toward more standard configuration management for ESMF applications. To this end
ESMF_HConfig integrates with the traditional ESMF_Config class. Through this
integration the traditional Config class API offers basic access to YAML
configuration files, in addition to providing backward compatible support of the
traditional config file format. This is discussed in more detail in the Config
class section. For more complete YAML support, applications are encouraged to
migrate to the HConfig API discussed in this section.

<P>

<H2><A ID="SECTION060102000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION060102100000000000000"></A>
<A ID="const:hconfigmatch"></A>
<BR>
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_HCONFIGMATCH
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Indicates the level to which two HConfig variables match.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_HConfigMatch_Flag)</SPAN>

<P>
The valid values in ascending order are:
<DL>
<DT><STRONG>ESMF_HCONFIGMATCH_INVALID:</STRONG></DT>
<DD>Indicates a non-valid matching level. One
  or both HConfig objects are invalid.
</DD>
<DT><STRONG>ESMF_HCONFIGMATCH_NONE:</STRONG></DT>
<DD>The lowest valid level of HConfig matching.
  This indicates that the HConfig objects are valid, but their YAML
  representation does not match.
</DD>
<DT><STRONG>ESMF_HCONFIGMATCH_EXACT:</STRONG></DT>
<DD>There is an exact match between the YAML
  representation of both HConfig objects. They may or may not be aliases to
  the same object in memory.
</DD>
<DT><STRONG>ESMF_HCONFIGMATCH_ALIAS:</STRONG></DT>
<DD>Both HConfig variables are aliases to the
  exact same HConfig object in memory.
</DD>
</DL>
<H2><A ID="SECTION060103000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how a user typically interacts with the
HConfig API. The HConfig class introduces two derived types:

<UL>
<LI><SPAN style="font-family:monospace">ESMF_HConfig</SPAN>
</LI>
<LI><SPAN style="font-family:monospace">ESMF_HConfigIter</SPAN>
</LI>
</UL>

<P>
<SPAN style="font-family:monospace">ESMF_HConfig</SPAN> objects can be created explicitly by the user, or they
can be accessed from an existing <SPAN style="font-family:monospace">ESMF_Config</SPAN> object, e.g. queried from
a Component. They can play a number of roles when interacting with
a HConfig hierarchy:

<P>

<OL>
<LI>The root node of the entire hierarchy. In YAML terminology, this
refers to a <EM>document</EM>.
</LI>
<LI><EM>Any</EM> node within the hierarchy.
</LI>
<LI>Collection of hierarchies, i.e. a set of YAML <EM>documents</EM>.
</LI>
</OL>

<P>
<SPAN style="font-family:monospace">ESMF_HConfigIter</SPAN> objects are iterators, <EM>referencing</EM> a specific
node within the hierarchy. They are created from <SPAN style="font-family:monospace">ESMF_HConfig</SPAN> objects.
The iterator approach allows convenient sequential traversal of a particular
location in the HConfig hierarchy. There are <EM>two</EM> flavors of iterators in
HConfig: <EM>sequence</EM> and <EM>map</EM> iterators.
Both are represented by the same <SPAN style="font-family:monospace">ESMF_HConfigIter</SPAN> derived type, and the
distinction is made at run-time.

<P>
Notice that there are redundancies built into the HConfig API, where different
ways are available to achieve the same goal. This is mostly done for
convenience, allowing the user to pick the approach most suitable to their
needs.

<P>
For instance, while it can be convenient to use iterators in some cases, in
others, it might be more appropriate to access elements directly by <EM>index</EM>
(for sequences) or <EM>key</EM> (for maps). Both options are available.

<P>

<H2><A ID="SECTION060104000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>The YAML Core schema, which is an extension of the JSON schema, is
  implemented and used to resolve non-specific tags under HConfig.
  There is currently no mechanism implemented to switch to a different schema
  for tag resolution.
</LI>
<LI>Currently the only available removal method for HConfig <EM>map</EM>
  objects requires that <EM>keys</EM> be simple scalar strings.
</LI>
<LI>There is currently no method implemented that allows setting of tags from
  from the API.
</LI>
</UL>
<H2><A ID="SECTION060105000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The ESMF HConfig class is implemented on top of YAML-CPP (https://github.com/jbeder/yaml-cpp).
A copy of YAML-CPP is included in the ESMF source tree under ./src/prologue/yaml-cpp. It is
used by a number of ESMF/NUOPC functions, including HConfig.

<H2><A ID="SECTION060106000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION060110000000000000000"></A>
<A ID="log_class"></A>
<BR>
<SPAN CLASS="arabic">49</SPAN> Log Class
</H1>

<H2><A ID="SECTION060111000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:Log"></A>
<P>
The Log class consists of a variety of methods for writing error, warning, and
informational messages to files.  A default Log is created at ESMF
initialization.  Other Logs can be created later in the code by the user.  Most
Log methods take a Log as an optional argument and apply to the default Log
when another Log is not specified.  A set of standard return codes and
associated messages are provided for error handling.  

<P>
Log provides capabilities to store message entries in a buffer, which is 
flushed to a file, either when the buffer is full, or when the user calls an 
<SPAN style="font-family:monospace">ESMF_LogFlush()</SPAN> method.  Currently, the default is for the Log to flush
after every ten entries.  This can easily be changed by using the 
<SPAN style="font-family:monospace">ESMF_LogSet()</SPAN> method and setting the <SPAN style="font-family:monospace">maxElements</SPAN> property to 
another value.  The <SPAN style="font-family:monospace">ESMF_LogFlush()</SPAN> method is automatically called when 
the program exits by any means (program completion, halt on error, or when the
Log is closed).

<P>
The user has the capability to abort the program on conditions such as
an error or on a warning by using the <SPAN style="font-family:monospace">ESMF_LogSet()</SPAN> method with
the <SPAN style="font-family:monospace">logmsgAbort</SPAN> argument.  For example if the  <SPAN style="font-family:monospace">logmsgAbort</SPAN> array
is set to <SPAN style="font-family:monospace">(ESMF_LOGMSG_ERROR,ESMF_LOGMSG_WARNING)</SPAN>, the program will 
stop on any and all warning or errors.  When the <SPAN style="font-family:monospace">logmsgAbort</SPAN> argument
is set to  <SPAN style="font-family:monospace">ESMF_LOGMSG_ERROR</SPAN>, the program will only abort on
errors.  Lastly, the user can choose to never abort by using
<SPAN style="font-family:monospace">ESMF_LOGMSG_NONE</SPAN>; this is the default.

<P>
Log will automatically put the PET number into the Log.  Also, the user can 
either specify <SPAN style="font-family:monospace">ESMF_LOGKIND_SINGLE</SPAN> which writes all the entries to a single 
Log or <SPAN style="font-family:monospace">ESMF_LOGKIND_MULTI</SPAN> which writes entries to multiple Logs according to 
the PET number.  To distinguish Logs from each other when using 
<SPAN style="font-family:monospace">ESMF_LOGKIND_MULTI</SPAN>, the PET number (in the format <SPAN style="font-family:monospace">PETx.</SPAN>) will be 
prepended to the file name where x is the PET number.

<P>
Opening multiple log files and writing log messages from all the processors
may affect the application performance while running on a large number of
processors.  For that reason, <SPAN style="font-family:monospace">ESMF_LOGKIND_NONE</SPAN> is provided to
switch off the Log capability.  All the Log methods have no effect
in the <SPAN style="font-family:monospace">ESMF_LOGKIND_NONE</SPAN> mode.

<P>
A tracing capability may be enabled by setting the <SPAN style="font-family:monospace">trace</SPAN> flag by
using the <SPAN style="font-family:monospace">ESMF_LogSet()</SPAN> method.  When tracing is enabled, calls to
methods such as <SPAN style="font-family:monospace">ESMF_LogFoundError</SPAN>, <SPAN style="font-family:monospace">ESMF_LogFoundAllocError</SPAN>,
and <SPAN style="font-family:monospace">ESMF_LogFoundDeallocError</SPAN> are logged in the default log file.
This can result in voluminous output.  It is typically used only around areas
of code which are being debugged.

<P>
Other options that are planned for Log are to adjust the verbosity of output, and to optionally write to <SPAN style="font-family:monospace">stdout</SPAN> instead of file(s).

<P>

<H2><A ID="SECTION060112000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION060112100000000000000"></A>
<A ID="const:logerr"></A>
<BR>
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LOGERR
</H3>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGERR_PASSTHRU</STRONG></DT>
<DD>A named character constant, with a predefined generic error message, 
		that can be used for the <SPAN style="font-family:monospace">msg</SPAN> argument in any <SPAN style="font-family:monospace">ESMF_Log</SPAN> 
		routine.  The message indicated 
		by this named constant is &ldquo;<I>Passing error in return code</I>."
</DD>
</DL>

<P>

<H3><A ID="SECTION060112200000000000000"></A>
<A ID="const:logkindflag"></A>
<BR>
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LOGKIND
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Specifies a single log file, multiple log files (one per PET), or no log files.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_LogKind_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGKIND_SINGLE</STRONG></DT>
<DD>Use a single log file, combining messages from all of the PETs.  Not supported on some platforms.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_MULTI</STRONG></DT>
<DD>Use multiple log files &mdash; one per PET.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_MULTI_ON_ERROR</STRONG></DT>
<DD>Use multiple log files &mdash; one per PET.  A log file is only opened when a message
         of type <SPAN style="font-family:monospace">ESMF_LOGMSG_ERROR</SPAN> is encountered.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_NONE</STRONG></DT>
<DD>Do not issue messages to a log file.
</DD>
</DL>

<P>

<H3><A ID="SECTION060112300000000000000"></A>
<A ID="const:logmsgflag"></A>
<BR>
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LOGMSG
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>

Specifies a message level

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_LogMsg_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGMSG_INFO</STRONG></DT>
<DD>Informational messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_WARNING</STRONG></DT>
<DD>Warning messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_ERROR</STRONG></DT>
<DD>Error messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_TRACE</STRONG></DT>
<DD>Trace messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_DEBUG</STRONG></DT>
<DD>DEBUG messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_JSON</STRONG></DT>
<DD>JSON format messages
</DD>
</DL>

<P>
Valid predefined named array constant values are:

<P>
<DL>
<DT><STRONG>ESMF_LOGMSG_ALL</STRONG></DT>
<DD>All messages
	
</DD>
<DT><STRONG>ESMF_LOGMSG_NONE</STRONG></DT>
<DD>No messages
	
</DD>
<DT><STRONG>ESMF_LOGMSG_NOTRACE</STRONG></DT>
<DD>All messages EXCEPT trace messages
</DD>
</DL>

<P>

<H2><A ID="SECTION060113000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
By default <SPAN style="font-family:monospace">ESMF_Initialize()</SPAN> opens a default Log in 
<SPAN style="font-family:monospace">ESMF_LOGKIND_MULTI</SPAN> mode. ESMF handles the initialization and finalization
of the default Log so the user can immediately start using it. If additional Log
objects are desired, they must be explicitly created or opened using
<SPAN style="font-family:monospace">ESMF_LogOpen()</SPAN>.

<P>
<SPAN style="font-family:monospace">ESMF_LogOpen()</SPAN> requires a Log object and filename argument. Additionally,
the user can specify single or multi Logs by setting the <SPAN style="font-family:monospace">logkindflag</SPAN> property
to <SPAN style="font-family:monospace">ESMF_LOGKIND_SINGLE</SPAN> or <SPAN style="font-family:monospace">ESMF_LOGKIND_MULTI</SPAN>.
This is useful as the PET numbers are automatically added to the Log entries.
A single Log will put all entries, regardless of PET number, into a single
log while a multi Log will create multiple Logs with the PET number prepended
to the filename and all entries will be written to their corresponding Log 
by their PET number.

<P>
By default, the Log file is not truncated at the start of a new run; it just
gets appended each time.  Future functionality may include an option to
either truncate or append to the Log file. 

<P>
In all cases where a Log is opened, a Fortran unit number is assigned to a specific
Log.  A Log is assigned an unused unit number using the algorithm described in
the <SPAN style="font-family:monospace">ESMF_IOUnitGet()</SPAN> method.

<P>
The user can then set or get options on how the Log should be used 
with the <SPAN style="font-family:monospace">ESMF_LogSet()</SPAN> and <SPAN style="font-family:monospace">ESMF_LogGet()</SPAN> methods.  These are 
partially implemented at this time. 

<P>
Depending on how the options are set, <SPAN style="font-family:monospace">ESMF_LogWrite()</SPAN> either writes user
messages directly to a Log file or writes to a buffer that can be flushed when 
full or by using the <SPAN style="font-family:monospace">ESMF_LogFlush()</SPAN> method.  The default is to flush 
after every ten entries because <SPAN style="font-family:monospace">maxElements</SPAN> is initialized to ten 
(which means the buffer reaches its full state after every ten writes and then
flushes).

<P>
A message filtering option may be set with <SPAN style="font-family:monospace">ESMF_LogSet()</SPAN> so
that only selected message types are actually written to the log.  One key
use of this feature is to allow placing informational log write requests
into the code for debugging or tracing.  Then, when the informational entries
are not needed, the messages at that level may be turned off &mdash; leaving only
warning and error messages in the logs. 

<P>
For every <SPAN style="font-family:monospace">ESMF_LogWrite()</SPAN>, a time and date stamp is prepended to the
Log entry.  The time is given in microsecond precision.  The user can call 
other methods to write to the Log.  In every case, all methods eventually make 
a call implicitly to <SPAN style="font-family:monospace">ESMF_LogWrite()</SPAN> even though the user may never 
explicitly call it.

<P>
When calling <SPAN style="font-family:monospace">ESMF_LogWrite()</SPAN>, the user can supply an optional line,
file and method.  These arguments can be passed in explicitly or with the help
of cpp macros.  In the latter case, a define for an <SPAN style="font-family:monospace">ESMF_FILENAME</SPAN> must 
be placed at the beginning of a file and a define for <SPAN style="font-family:monospace">ESMF_METHOD</SPAN> must
be placed at the beginning of each method.  The user can then use the
<SPAN style="font-family:monospace">ESMF_CONTEXT</SPAN> cpp macro in place of line, file and method to insert the 
parameters into the method.  The user does not have to specify line number as
it is a value supplied by cpp.

<P>
An example of Log output is given below running with <SPAN style="font-family:monospace">logkindflag</SPAN> 
property set to <SPAN style="font-family:monospace">ESMF_LOGKIND_MULTI</SPAN> (default) using the default Log:

<P>
(Log file <SPAN style="font-family:monospace">PET0.ESMF_LogFile</SPAN>)
<PRE>
20041105 163418.472210 INFO      PET0     Running with ESMF Version 2.2.1
</PRE>

<P>
(Log file <SPAN style="font-family:monospace">PET1.ESMF_LogFile</SPAN>)
<PRE>
20041105 163419.186153 ERROR     PET1     ESMF_Field.F90             812  
ESMF_FieldGet No Grid or Bad Grid attached to Field
</PRE>

<P>
The first entry shows date and time stamp.  The time is given in microsecond 
precision.  The next item shown is the type of message (INFO in this case).  
Next, the PET number is added.  Lastly, the content is written.

<P>
The second entry shows something slightly different.  In this case, we have
an ERROR.  The method name (ESMF_Field.F90) is automatically provided from 
the cpp macros as well as the line number (812).  Then the content of the 
message is written.

<P>
When done writing messages, the default Log is closed by calling 
<SPAN style="font-family:monospace">ESMF_LogFinalize()</SPAN>  or <SPAN style="font-family:monospace">ESMF_LogClose()</SPAN> for user created Logs.  
Both methods will release the assigned unit number.

<H2><A ID="SECTION060114000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Line, file and method are only available when using the C 
preprocessor</B>
Message writing methods are expanded using the ESMF macro ESMF_CONTEXT 
that adds the predefined symbolic constants __LINE__ and __FILE__ (or 
the ESMF constant ESMF_FILENAME if defined) and the ESMF constant ESMF_METHOD 
to the argument list.  Using these constants, we can associate a file name, 
line number and method name with the message.  If the CPP preprocessor is not 
used, this expansion will not be done and hence the ESMF macro ESMF_CONTEXT 
can not be used, leaving the file name, line number and method out of the Log 
text.

<P>
</LI>
<LI><B>Get and set methods are partially implemented.</B>
Currently, the <SPAN style="font-family:monospace">ESMF_LogGet()</SPAN> and <SPAN style="font-family:monospace">ESMF_LogSet()</SPAN> methods are 
partially implemented.   

<P>
</LI>
<LI><B>Log only appends entries.</B>
All writing to the Log is appended rather than overwriting the Log.  Future 
enhancements include the option to either append to an existing Log or 
overwrite the existing Log.

<P>
</LI>
<LI><B>Avoiding conflicts with the default Log.</B>

The private methods <SPAN style="font-family:monospace">ESMF_LogInitialize()</SPAN> and <SPAN style="font-family:monospace">ESMF_LogFinalize()</SPAN> 
are called during <SPAN style="font-family:monospace">ESMF_Initialize()</SPAN> and <SPAN style="font-family:monospace">ESMF_Finalize()</SPAN> 
respectively, so they do not need to be called if the default Log is used. 
If a new Log is required, <SPAN style="font-family:monospace">ESMF_LogOpen()</SPAN> is used with a new Log object 
passed in so that there are no conflicts with the default Log.

<P>
</LI>
<LI><B>ESMF_LOGKIND_SINGLE does not work properly.</B>
When the <SPAN style="font-family:monospace">ESMF_LogKind_Flag</SPAN> is set to <SPAN style="font-family:monospace">ESMF_LOGKIND_SINGLE</SPAN>, different system may behave
differently.  The log messages from some processors may be lost or overwritten
by other processors.  Users are advised not to use this mode.  The MPI-based
I/O will be implemented to fix the problem in the future release. 

<P>
</LI>
</OL>
<H2><A ID="SECTION060115000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<OL>
<LI>The Log class was implemented in Fortran and uses the Fortran I/O 
libraries when the class methods are called from Fortran. The C/C++ Log
methods use the Fortran I/O library by calling utility functions that are
written in Fortran. These utility functions call the standard Fortran write, 
open and close functions.  At initialization an <SPAN style="font-family:monospace">ESMF_LOG</SPAN> is created. 
The <SPAN style="font-family:monospace">ESMF_LOG</SPAN> stores information for a specific Log file.   When working 
with more than one Log file, multiple <SPAN style="font-family:monospace">ESMF_LOG</SPAN>'s are required (one 
<SPAN style="font-family:monospace">ESMF_LOG</SPAN> for each Log file).  For each Log, a handle is returned 
through the <SPAN style="font-family:monospace">ESMF_LogInitialize</SPAN> method for the default log or <SPAN style="font-family:monospace">ESMF_LogOpen</SPAN> for a user created log.  The user can specify single or multi logs by 
setting the <SPAN style="font-family:monospace">logkindflag</SPAN> property in the <SPAN style="font-family:monospace">ESMF_LogInitialize</SPAN> or 
<SPAN style="font-family:monospace">ESMF_Open</SPAN> method to <SPAN style="font-family:monospace">ESMF_LOGKIND_SINGLE</SPAN> or <SPAN style="font-family:monospace">ESMF_LOGKIND_MULTI</SPAN>.
Similarly, the user can set the <SPAN style="font-family:monospace">logkindflag</SPAN> property for the default
Log with the <SPAN style="font-family:monospace">ESMF_Initialize</SPAN> method call.
The <SPAN style="font-family:monospace">logkindflag</SPAN> is useful as the PET numbers are automatically added to the 
log entries.  A single log will put all entries, regardless of PET number, 
into a single log while a multi log will create multiple logs with the PET 
number prepended to the filename and all entries will be written to their 
corresponding log by their PET number.

<P>
The properties for a Log are set with the <SPAN style="font-family:monospace">ESMF_LogSet()</SPAN> method and 
retrieved with the <SPAN style="font-family:monospace">ESMF_LogGet()</SPAN> method.

<P>
Additionally, buffering is enabled.  Buffering allows <SPAN style="font-family:monospace">ESMF</SPAN> to manage 
output data streams in a desired way.  Writing to the buffer is transparent 
to the user because all the Log entries are handled automatically by the 
<SPAN style="font-family:monospace">ESMF_LogWrite()</SPAN> method.  All the user has to do is specify the buffer
size (the default is ten) by setting the <SPAN style="font-family:monospace">maxElements</SPAN> property.  Every 
time the <SPAN style="font-family:monospace">ESMF_LogWrite()</SPAN> method is called, a LogEntry element is 
populated with the <SPAN style="font-family:monospace">ESMF_LogWrite()</SPAN> information.  When the buffer is 
full (i.e., when all the LogEntry elements are populated), the buffer will be 
flushed and all the contents will be written to file.  If buffering is not 
needed, that is <SPAN style="font-family:monospace">maxElements=1</SPAN> or <SPAN style="font-family:monospace">flushImmediately=ESMF_TRUE</SPAN>, 
the <SPAN style="font-family:monospace">ESMF_LogWrite()</SPAN> method will immediately write to the Log file(s).
</LI>
</OL>
<H2><A ID="SECTION060116000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
Log class.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV class="CENTER">
<IMG
 STYLE="height: 16.22ex; vertical-align: -0.11ex; " SRC="img50.svg"
 ALT="\includegraphics{Log_obj}">   

</DIV>

<P>

<H2><A ID="SECTION060117000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION060120000000000000000">
<SPAN CLASS="arabic">50</SPAN> DELayout Class</A>
</H1>

<H2><A ID="SECTION060121000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The DELayout class provides an additional layer of abstraction on top of the Virtual Machine (VM) layer. DELayout does this by introducing DEs (Decomposition Elements) as logical resource units. The DELayout object keeps track of the relationship between its DEs and the resources of the associated VM object. 

<P>
The relationship between DEs and VM resources (PETs (Persistent Execution Threads) and VASs (Virtual Address Spaces)) contained in a DELayout object is defined during its creation and cannot be changed thereafter. There are, however, a number of hint and specification arguments that can be used to shape the DELayout during its creation.

<P>
Contrary to the number of PETs and VASs contained in a VM object, which are fixed by the available resources, the number of DEs contained in a DELayout can be chosen freely to best match the computational problem or other design criteria. Creating a DELayout with less DEs than there are PETs in the associated VM object can be used to share resources between decomposed objects within an ESMF component. Creating a DELayout with more DEs than there are PETs in the associated VM object can be used to evenly partition the computation over the available resources.

<P>
The simplest case, however, is where the DELayout contains the same number of DEs as there are PETs in the associated VM context. In this case the DELayout may be used to re-label the hardware and operating system resources held by the VM. For instance, it is possible to order the resources so that specific DEs have best available communication paths. The DELayout will map the DEs to the PETs of the VM according to the resource details provided by the VM instance. 

<P>
Furthermore, general DE to PET mapping can be used to offer computational resources with finer granularity than the VM does. The DELayout can be queried for computational and communication capacities of DEs and DE pairs, respectively. This information can be used to best utilize the DE resources when partitioning the computational problem. In combination with other ESMF classes, general DE to PET mapping can be used to realize cache blocking, communication hiding and dynamic load balancing.

<P>
Finally, the DELayout layer offers primitives that allow a work queue style dynamic load balancing between DEs.

<P>

<H2><A ID="SECTION060122000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION060122100000000000000"></A>
<A ID="const:pin_flag"></A>
<BR>
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_PIN
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Specifies which VM resource DEs are pinned to (PETs, VASs, SSIs).

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_Pin_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_PIN_DE_TO_PET</STRONG></DT>
<DD>Pin DEs to PETs. Only the owning PET has access to a DE.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_VAS</STRONG></DT>
<DD>Pin DEs to virtual address spaces (VAS). DEs are accessible from all PETs
    within the same VAS.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_SSI</STRONG></DT>
<DD>Pin DEs to single system images (SSI) - typically shared memory nodes.
    DEs are accessible from all PETs within the same SSI. The memory allocation
    between different DEs is allowed to be non-contiguous.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_SSI_CONTIG</STRONG></DT>
<DD>Same as <SPAN style="font-family:monospace">ESMF_PIN_DE_TO_SSI</SPAN>, but the shared memory allocation
    across DEs located on the same SSI must be contigous throughout.
</DD>
</DL>

<P>

<H3><A ID="SECTION060122200000000000000"></A>
<A ID="const:servicereply_flag"></A>
<BR>
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_SERVICEREPLY
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Reply when a PET offers to service a DE.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_ServiceReply_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_SERVICEREPLY_ACCEPT</STRONG></DT>
<DD>The service offer has been accepted. The PET is expected to service the DE.
  
</DD>
<DT><STRONG>ESMF_SERVICEREPLY_DENY</STRONG></DT>
<DD>The service offer has been denied. The PET is expected to not service the
    DE.
</DD>
</DL>

<P>

<H2><A ID="SECTION060123000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to create, use and destroy DELayout objects.

<H2><A ID="SECTION060124000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<H2><A ID="SECTION060125000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The DELayout class is a light weight object. It stores the DE to PET and VAS mapping for all DEs within all PET instances and a list of local DEs for each PET instance. The DELayout does not store the computational and communication weights optionally provided as arguments to the create method. These hints are only used during create while they are available in user owned arrays.

<H2><A ID="SECTION060126000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION060130000000000000000">
<SPAN CLASS="arabic">51</SPAN> VM Class</A>
</H1>

<H2><A ID="SECTION060131000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF VM (Virtual Machine) class is a generic representation of hardware and system software resources. There is exactly one VM object per ESMF Component, providing the execution environment for the Component code. The VM class handles all resource management tasks for the Component class and provides a description of the underlying configuration of the compute resources used by a Component.

<P>
In addition to resource description and management, the VM class offers the lowest level of ESMF communication methods. The VM communication calls are very similar to MPI. Data references in VM communication calls must be provided as raw, language-specific, one-dimensional, contiguous data arrays. The similarity between VM and MPI communication calls is striking and there are many equivalent point-to-point and collective communication calls. However, unlike MPI, the VM communication calls support communication between threaded PETs in a completely transparent fashion.

<P>
Many ESMF applications do not interact with the VM class directly very much. The  resource management aspect is wrapped completely transparent into the ESMF Component concept. Often the only reason that user code queries a Component
object for the associated VM object is to inquire about resource information, such as the <SPAN style="font-family:monospace">localPet</SPAN> or the <SPAN style="font-family:monospace">petCount</SPAN>. Further, for most applications the use of higher level communication APIs, such as provided by Array and Field, are much more convenient than using the low level VM communication calls.

<P>
The basic elements of a VM are called PETs, which stands for Persistent Execution Threads. These are equivalent to OS threads with a lifetime of at least that of the associated component. All VM functionality is expressed in terms of PETs. In the simplest, and most common case, a PET is equivalent to an MPI process. However, ESMF also supports multi-threading, where multiple PETs run as Pthreads inside the same virtual address space (VAS).

<P>
The resource management functions of the VM class become visible when a component, or the driver code, creates sub-components. Section <A HREF="node4.html#sec:AppDriverSetVM">16.4.3</A> discusses this aspect from the Superstructure 
perspective and provides links to the relevant Component examples in the documentation.

<P>
There are two parts to resource management, the parent and the child. When the parent component creates a child component, the parent VM object provides the resources on which the child is created with <SPAN style="font-family:monospace">ESMF_GridCompCreate()</SPAN> or <SPAN style="font-family:monospace">ESMF_CplCompCreate()</SPAN>. The optional <SPAN style="font-family:monospace">petList</SPAN> argument to these calls limits the resources that the parent gives to a specific child. The child component, may specify - during its optional 
<SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetVM()</SPAN> method - how it wants to arrange the inherited resources in its own VM. After this, all standard ESMF methods of the Component, including <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN>, will execute in the child VM. Notice that the <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetVM()</SPAN> routine, although part of the child Component, must execute <EM>before</EM> the child VM has been started up. It runs in the parent VM context. The child VM is created and started up just before the user-written set services routine, specified as an argument to <SPAN style="font-family:monospace">ESMF_&lt;Grid/Cpl&gt;CompSetServices()</SPAN>, is entered.

<H2><A ID="SECTION060132000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A ID="SECTION060132100000000000000"></A>
<A ID="const:vmepoch_flag"></A>
<BR>
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_VMEPOCH
</H3>

<P>
<SPAN style="font-family:sans-serif">DESCRIPTION:
<BR></SPAN>
Specifies the kind of VM Epoch being entered.

<P>
The type of this flag is:

<P>
<SPAN style="font-family:monospace">type(ESMF_VMEpoch_Flag)</SPAN>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_VMEPOCH_NONE</STRONG></DT>
<DD>An epoch wihout special behavior.
  
</DD>
<DT><STRONG>ESMF_VMEPOCH_BUFFER</STRONG></DT>
<DD>This option must only be used for parts of the code with distinct sending
    and receiving PETs, i.e. where no PETs are both sender and receiver.
    All non-blocking messages are being buffered. A single message is sent
    between unique pairs of src-dst PETs. This can significantly improve
    performance for cases with a large imbalance in the number of sending
    versus receiving PETs. The extra buffering also improves the overall
    asynchronous behavior between the sending and receiving side.
</DD>
</DL>
<H2><A ID="SECTION060133000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The concept of the ESMF Virtual Machine (VM) is so fundamental to the framework that every ESMF application uses it. However, for many user applications the VM class is transparently hidden behind the ESMF Component concept and higher data classes (e.g. Array, Field). The interaction between user code and VM is often only indirect. The following examples provide an overview of where the VM class can come into play in user code.

<H2><A ID="SECTION060134000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Only array section syntax that leads to contiguous sub sections is supported</B>. The source and destination arguments in VM communication calls must reference contiguous data arrays. Fortran array sections are not guaranteed to be contiguous in all cases.

<P>
</LI>
<LI><B>Non-blocking <SPAN style="font-family:monospace">Reduce()</SPAN> operations <EM>not</EM> implemented.</B> None of the reduce communication calls have an implementation for the non-blocking feature. This affects:

<UL>
<LI><SPAN style="font-family:monospace">ESMF_VMAllFullReduce()</SPAN>,
</LI>
<LI><SPAN style="font-family:monospace">ESMF_VMAllReduce()</SPAN>,
</LI>
<LI><SPAN style="font-family:monospace">ESMF_VMReduce()</SPAN>.
</LI>
</UL>

<P>
</LI>
<LI><B>Limitations when using <SPAN style="font-family:monospace">mpiuni</SPAN> mode.</B> In <SPAN style="font-family:monospace">mpiuni</SPAN> mode non-blocking communications are limited to one outstanding message per source-destination PET pair. Furthermore, in <SPAN style="font-family:monospace">mpiuni</SPAN> mode the message length must be smaller than the internal ESMF buffer size.

<P>
</LI>
<LI><B>Alternative communication paths not accessible.</B> All user accessible VM communication calls are currently implemented using MPI-1.2. VM's implementation of alternative communication techniques, such as shared memory between threaded PETs and POSIX IPC between PETs located on the same single system image, are currently inaccessible to the user. (One exception to this is the <SPAN style="font-family:monospace">mpiuni</SPAN> case for which the VM automatically utilizes a shared memory path.)

<P>
</LI>
<LI><B>Data arrays in VM comm calls are <EM>assumed shape</EM> with rank=1.</B> Currently all dummy arrays in VM comm calls are defined as <EM>assumed shape</EM> arrays of rank=1. The motivation for this choice is that the use of assumed shape dummy arrays guards against the Fortran copy in/out problem. However it may not be as flexible as desired from the user perspective. Alternatively all dummy arrays could be defined as <EM>assumed size</EM> arrays, as it is done in most MPI implementations, allowing arrays of various rank to be passed into the comm methods. Arrays of higher rank can be passed into the current interfaces using Fortran array syntax. This approach is explained in section <A HREF="#vm_higherrank"><IMG  ALT="[*]" SRC="crossref.png"></A>.

<P>
</LI>
<LI><B>Limitations when using VMEpoch.</B> Using a blocking collective call (e.g. <SPAN style="font-family:monospace">ESMF_VMBroadcast()</SPAN>, the <SPAN style="font-family:monospace">MPI_Bcast()</SPAN> used by <SPAN style="font-family:monospace">ESMF_InfoBroadcast()</SPAN>, etc.) within the region enclosed by <SPAN style="font-family:monospace">ESMF_VMEpochEnter()</SPAN> and <SPAN style="font-family:monospace">ESMF_VMEpochExit()</SPAN> will result in a deadlock. 

<P>
</LI>
</OL>

<P>

<H2><A ID="SECTION060135000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The VM class provides an additional layer of abstraction on top of the POSIX machine model, making it suitable for HPC applications. There are four key aspects the VM class deals with.

<P>

<OL>
<LI>Encapsulation of hardware and operating system details within the concept of Persistent Execution Threads (PETs).

<P>
</LI>
<LI>Resource management in terms of PETs with a guard against over-subscription.

<P>
</LI>
<LI>Topological description of the underlying configuration of the compute resources in terms of PETs.

<P>
</LI>
<LI>Transparent communication API for point-to-point and collective PET-based primitives, hiding the many different communication channels and offering best possible performance.

<P>
</LI>
</OL>

<P>
<DIV class="CENTER">
<!-- MATH
 $\scalebox{0.6}{\includegraphics{VM_design}}$
 -->
<IMG
 STYLE="height: 9.82ex; vertical-align: -0.11ex; " SRC="img51.svg"
 ALT="\scalebox{0.6}{\includegraphics{VM_design}}">
</DIV>

<P>
<B>Definition of terms used in the diagram</B>

<P>

<UL>
<LI>PE: A processing element (PE) is an alias for the smallest physical processing unit available on a particular hardware platform. In the language of today's microprocessor architecture technology a PE is identical to a core, however, if future microprocessor designs change the smallest physical processing unit the mapping of the PE to actual hardware will change accordingly. Thus the PE layer separates the hardware specific part of the VM from the hardware-independent part. Each PE is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>Core: A Core is the smallest physical processing unit which typically comprises a register set, an integer arithmetic unit, a floating-point unit and various control units. Each Core is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>CPU: The central processing unit (CPU) houses single or multiple cores, providing them with the interface to system memory, interconnects and I/O. Typically the CPU provides some level of caching for the instruction and data streams in and out of the Cores. Cores in a multi-core CPU typically share some caches. Each CPU is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>SSI: A single system image (SSI) spans all the CPUs controlled by a single running instance of the operating system. SMP and NUMA are typical multi-CPU SSI architectures. Each SSI is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>TOE: A thread of execution (TOE) executes an instruction sequence. TOE's come in two flavors: PET and TET.

<P>
</LI>
<LI>PET: A persistent execution thread (PET) executes an instruction sequence on an associated set of data. The PET has a lifetime at least as long as the associated data set. In ESMF the PET is the central concept of abstraction provided by the VM class. The PETs of an VM object are labeled from 0 to N-1 where N is the total number of PETs in the VM object.

<P>
</LI>
<LI>TET: A transient execution thread (TET) executes an instruction sequence on an associated set of data. A TET's lifetime might be shorter than that of the associated data set.

<P>
</LI>
<LI>OS-Instance: The OS-Instance of a TOE describes how a particular TOE is instantiated on the OS level. Using POSIX terminology a TOE will run as a single thread within a single- or multi-threaded process.

<P>
</LI>
<LI>Pthreads: Communication via the POSIX Thread interface.

<P>
</LI>
<LI>MPI-1, MPI-2: Communication via MPI standards 1 and 2.

<P>
</LI>
<LI>armci: Communication via the aggregate remote memory copy interface.

<P>
</LI>
<LI>SHMEM: Communication via the SHMEM interface.

<P>
</LI>
<LI>OS-IPC: Communication via the operating system's inter process communication interface. Either POSIX IPC or System V IPC.

<P>
</LI>
<LI>InterCon-lib: Communication via the interconnect's library native interface. An example is the Elan library for Quadrics.

<P>
</LI>
</UL>

<P>
The POSIX machine abstraction, while a very powerful concept, needs augmentation when applied to HPC applications. Key elements of the POSIX abstraction are processes, which provide virtually unlimited resources (memory, I/O, sockets, ...) to possibly multiple threads of execution. Similarly POSIX threads create the illusion that there is virtually unlimited processing power available to each POSIX process. While the POSIX abstraction is very suitable for many multi-user/multi-tasking applications that need to share limited physical resources, it does not directly fit the HPC workload where over-subscription of resources is one of the most expensive modes of operation.

<P>
ESMF's virtual machine abstraction is based on the POSIX machine model but holds additional information about the available physical processing units in terms of Processing Elements (PEs). A PE is the smallest physical processing unit and encapsulates the hardware details (Cores, CPUs and SSIs).

<P>
There is exactly one physical machine layout for each application, and all VM instances have access to this information. The PE is the smallest processing unit which, in today's microprocessor technology, corresponds to a single Core. Cores are arranged in CPUs which in turn are arranged in SSIs. The setup of the physical machine layout is part of the ESMF initialization process.

<P>
On top of the PE concept the key abstraction provided by the VM is the PET. All user code is executed by PETs while OS and hardware details are hidden. The VM class contains a number of methods which allow the user to prescribe how the PETs of a desired virtual machine should be instantiated on the OS level and how they should map onto the hardware. This prescription is kept in a private virtual machine plan object which is created at the same time the associated component is being created. Each time component code is entered through one of the component's registered top&ndash;level methods (Initialize/Run/Finalize), the virtual machine plan along with a pointer to the respective user function is used to instantiate the user code on the PETs of the associated VM in form of single- or multi-threaded POSIX processes.

<P>
The process of starting, entering, exiting and shutting down a VM is very transparent, all spawning and joining of threads is handled by VM methods "behind the scenes". Furthermore, fundamental synchronization and communication primitives are provided on the PET level through a uniform API, hiding details related to the actual instantiation of the participating PETs.

<P>
Within a VM object each PE of the physical machine maps to 0 or 1 PETs. Allowing unassigned PEs provides a means to prevent over-subscription between multiple concurrently running virtual machines. Similarly a maximum of one PET per PE prevents over-subscription within a single VM instance. However, over-subscription is possible by subscribing PETs from different virtual machines to the same PE. This type of over-subscription can be desirable for PETs associated with I/O workloads expected to be used infrequently and to block often on I/O requests.

<P>
On the OS level each PET of a VM object is represented by a POSIX thread (Pthread) either belonging to a single&ndash; or multi&ndash;threaded process and maps to at least 1 PE of the physical machine, ensuring its execution. Mapping a single PET to multiple PEs provides resources for user&ndash;level multi&ndash;threading, in which case the user code inquires how many PEs are associated with its PET and if there are multiple PEs available the user code can spawn an equal number of threads (e.g. OpenMP) without risking over-subscription. Typically these user spawned threads are short-lived and used for fine-grained parallelization in form of TETs. All PEs mapped against a single PET must be part of a unique SSI in order to allow user&ndash;level multi&ndash;threading!

<P>
In addition to discovering the physical machine the ESMF initialization process sets up the default global virtual machine. This VM object, which is the ultimate parent of all VMs created during the course of execution, contains as many PETs as there are PEs in the physical machine. All of its PETs are instantiated in form of single-threaded MPI processes and a 1:1 mapping of PETs to PEs is used for the default global VM.

<P>
The VM design and implementation is based on the POSIX process and thread model as well as the MPI-1.2 standard. As a consequence of the latter standard the number of processes is static during the course of execution and is determined at start-up. The VM implementation further requires that the user starts up the ESMF application with as many MPI processes as there are PEs in the available physical machine using the platform dependent mechanism to ensure proper process placement. 

<P>
All MPI processes participating in a VM are grouped together by means of an MPI_Group object and their context is defined via an MPI_Comm object (MPI intra-communicator). The PET local process id within each virtual machine is equal to the MPI_Comm_rank in the local MPI_Comm context whereas the PET process id is equal to the MPI_Comm_rank in MPI_COMM_WORLD. The PET process id is used within the VM methods to determine the virtual memory space a PET is operating in. 

<P>
In order to provide a migration path for legacy MPI-applications the VM offers accessor functions to its MPI_Comm object. Once obtained this object may be used in explicit user-code MPI calls within the same context.

<P>

<H2><A ID="SECTION060136000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION060140000000000000000">
<SPAN CLASS="arabic">52</SPAN> Profiling and Tracing</A>
</H1>

<H2><A ID="SECTION060141000000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>

<H3><A ID="SECTION060141100000000000000"></A>
<A ID="sec:Profiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Profiling
</H3>

<P>
ESMF's built in <EM>profiling</EM> capability collects runtime statistics
of an executing ESMF application through both automatic and manual code
instrumentation. Timing information for all phases of all ESMF components
executing in an application can be automatically collected using the
<SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE</SPAN> environment variable (see below for settings).
Additionally, arbitrary user-defined code regions can be timed by
manually instrumenting code with special API calls.  Timing profiles
of component phases and user-defined regions can be output in several
different formats:

<UL>
<LI>in text at the end of ESMF Log files
</LI>
<LI>in separate text file, one per PET (if the ESMF Logs are turned off)
</LI>
<LI>in a single summary text file that aggregates timings over multiple PETs
</LI>
<LI>in a binary format for import into the <A ID="tex2html42"
  HREF="https://github.com/esmf-org/esmf-profiler">esmf-profiler</A>
for profile visualization
</LI>
</UL>

<P>
The following table lists important environment variables that control
aspects of ESMF profiling.

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=218><B>Environment Variable</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=290><B>Description</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><B>Example Values</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><B>Default</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=290>Enable/disables all profiling functions</TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ON</SPAN> or <SPAN style="font-family:monospace">OFF</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">OFF</SPAN></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE_PETLIST</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=290>Limits profiling to an explicit list of PETs</TD>
<TD CLASS="LEFT TOP"  WIDTH=218>&ldquo;<SPAN style="font-family:monospace">0-9 50 99</SPAN>&rdquo;</TD>
<TD CLASS="LEFT TOP"  WIDTH=218><EM>profile all PETs</EM></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE_OUTPUT</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=290>Controls output format of profiles;  multiple can be specified in a space separated list</TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">TEXT</SPAN>, <SPAN style="font-family:monospace">SUMMARY</SPAN>, <SPAN style="font-family:monospace">BINARY</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">TEXT</SPAN></TD>
</TR>
</TABLE>

<P>

<H3><A ID="SECTION060141200000000000000"></A>
<A ID="sec:Tracing"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Tracing
</H3>

<P>
Whereas profiling collects summary information from an application,
<EM>tracing</EM> records a more detailed set of events for later analysis. Trace
analysis can be used to understand what happened during a program's
execution and is often used for diagnosing problems, debugging, and
performance analysis.

<P>
ESMF has a built-in tracing capability that records events into special
binary log files.  Unlike log files written by the <SPAN style="font-family:monospace">ESMF_Log</SPAN> class,
which are primarily for human consumption (see Section <A HREF="#sec:Log">49.1</A>),
the trace output files are
recorded in a compact binary representation and are processed by tools
to produce various analyses. ESMF event streams are recorded in the
<A ID="tex2html43"
  HREF="http://diamon.org/ctf/">Common Trace Format</A>
(CTF).
CTF traces include one or more event streams,
as well as a metadata file describing the events in the streams.

<P>
Several tools are available for reading in the CTF traces output by ESMF.
Of the tools listed below, the first one is designed specifically for
analyzing ESMF applications and the second two are general purpose tools
for working with all CTF traces.

<UL>
<LI><A ID="tex2html44"
  HREF="https://github.com/esmf-org/esmf-profiler">esmf-profiler</A>
is a tool that ingests traces from an ESMF application and generates
  performance profile plots.
</LI>
<LI><A ID="tex2html45"
  HREF="http://tracecompass.org/">TraceCompass</A>
is a general purpose tool for reading, analyzing, and visualizing traces.
</LI>
<LI><A ID="tex2html46"
  HREF="http://www.efficios.com/babeltrace">Babeltrace</A>
is a command-line tool and library for trace conversion
  that can read and write CTF traces. Python bindings are available
  to open CTF traces are iterate through events.  
</LI>
</UL>

<P>
Events that can be captured by the ESMF tracer include the following. Events
are recorded with a high-precision timestamp to allow timing analyses.
<DL>
<DT><STRONG>phase_enter</STRONG></DT>
<DD>indicates entry into an initialize, run, or finalize ESMF component routine
</DD>
<DT><STRONG>phase_exit</STRONG></DT>
<DD>indicates exit from an initialize, run, or finalize ESMF component routine
</DD>
<DT><STRONG>region_enter</STRONG></DT>
<DD>indicates entry into a user-defined code region
</DD>
<DT><STRONG>region_exit</STRONG></DT>
<DD>indicates exit from a user-defined code region
</DD>
</DL>

<P>
The following table lists important environment variables that control
aspects of ESMF tracing.

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT TOP"  WIDTH=218><B>Environment Variable</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=290><B>Description</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><B>Example Values</B></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><B>Default</B></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=290>Enable/disables all tracing functions</TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ON</SPAN> or <SPAN style="font-family:monospace">OFF</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">OFF</SPAN></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_CLOCK</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=290>Sets the type of clock for timestamping events (see Section <A HREF="#sec:TracingClocks">52.2.6</A>).</TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">REALTIME</SPAN> or <SPAN style="font-family:monospace">MONOTONIC</SPAN> or <SPAN style="font-family:monospace">MONOTONIC_SYNC</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">REALTIME</SPAN></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_PETLIST</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=290>Limits tracing to an explicit list of PETs</TD>
<TD CLASS="LEFT TOP"  WIDTH=218>&ldquo;<SPAN style="font-family:monospace">0-9 50 99</SPAN>&rdquo;</TD>
<TD CLASS="LEFT TOP"  WIDTH=218><EM>trace all PETs</EM></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_COMPONENT</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=290>Enables/disable tracing of Component phase_enter and phase_exit events</TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ON</SPAN> or <SPAN style="font-family:monospace">OFF</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ON</SPAN></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_FLUSH</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=290>Controls frequency of event stream flushing to file</TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">DEFAULT</SPAN> or <SPAN style="font-family:monospace">EAGER</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=218><SPAN style="font-family:monospace">DEFAULT</SPAN></TD>
</TR>
</TABLE>

<P>

<H2><A ID="SECTION060142000000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>

<H3><A ID="SECTION060142100000000000000"></A>
<A ID="sec:BasicProfiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Output a Timing Profile to Text
</H3>

<P>
ESMF profiling is disabled by default. To profile an application,
set the <SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE</SPAN> variable to <SPAN style="font-family:monospace">ON</SPAN> prior
to executing the application.  You do not need to recompile
your code to enable profiling.

<P>
<PRE>
# csh shell
$ setenv ESMF_RUNTIME_PROFILE ON

# bash shell
$ export ESMF_RUNTIME_PROFILE=ON

# (from now on, only the csh shell version will be shown)
</PRE>

<P>
Then execute the application in the usual way. At the end of
the run the profile information will be available at the end
of each PET log (if ESMF Logs are turned on) or in a set of
separate files, one per PET, with names <EM>ESMF_Profile.XXX</EM>
where XXX is the PET number.  Below is an example timing
profile.  Some regions are left out for brevity.

<P>
<PRE>
Region                           Count  Total (s)   Self (s)    Mean (s)    Min (s)     Max (s)
  [esm] Init 1                   1      4.0878      0.0341      4.0878      4.0878      4.0878
    [OCN-TO-ATM] IPDv05p6b       1      2.6007      2.6007      2.6007      2.6007      2.6007
    [ATM-TO-OCN] IPDv05p6b       1      1.4333      1.4333      1.4333      1.4333      1.4333
    [ATM] IPDv00p2               1      0.0055      0.0055      0.0055      0.0055      0.0055
    [OCN] IPDv00p2               1      0.0023      0.0023      0.0023      0.0023      0.0023
    [ATM] IPDv00p1               1      0.0011      0.0011      0.0011      0.0011      0.0011
    [OCN] IPDv00p1               1      0.0009      0.0009      0.0009      0.0009      0.0009
    [ATM-TO-OCN] IPDv05p3        1      0.0008      0.0008      0.0008      0.0008      0.0008
    [ATM-TO-OCN] IPDv05p1        1      0.0008      0.0008      0.0008      0.0008      0.0008
    [ATM-TO-OCN] IPDv05p2b       1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p4        1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p2a       1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p5        1      0.0007      0.0007      0.0007      0.0007      0.0007
    [OCN-TO-ATM] IPDv05p3        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p4        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p2b       1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p2a       1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p5        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p1        1      0.0005      0.0005      0.0005      0.0005      0.0005
  [esm] RunPhase1                1      2.7423      0.9432      2.7423      2.7423      2.7423
    [OCN-TO-ATM] RunPhase1       864    0.6094      0.6094      0.0007      0.0006      0.0179
    [ATM] RunPhase1              864    0.5296      0.2274      0.0006      0.0005      0.0011
      ATM:ModelAdvance           864    0.3022      0.3022      0.0003      0.0003      0.0005
    [ATM-TO-OCN] RunPhase1       864    0.3345      0.3345      0.0004      0.0002      0.0299
    [OCN] RunPhase1              864    0.3256      0.3256      0.0004      0.0003      0.0010
  [esm] FinalizePhase1           1      0.0029      0.0020      0.0029      0.0029      0.0029
    [OCN-TO-ATM] FinalizePhase1  1      0.0006      0.0006      0.0006      0.0006      0.0006
    [ATM-TO-OCN] FinalizePhase1  1      0.0002      0.0002      0.0002      0.0002      0.0002
    [OCN] FinalizePhase1         1      0.0001      0.0001      0.0001      0.0001      0.0001
    [ATM] FinalizePhase1         1      0.0000      0.0000      0.0000      0.0000      0.0000
</PRE>

<P>
A timed region is either an ESMF component phase (e.g., initialize,
run, or finalize) or a user-defined region of code surrounded by calls to
<SPAN style="font-family:monospace">ESMF_TraceRegionEnter()</SPAN> and <SPAN style="font-family:monospace">ESMF_TraceRegionExit()</SPAN>. (See
section <A HREF="#ex:TraceUserEx"><IMG  ALT="[*]" SRC="crossref.png"></A> for more information on instrumenting
user-defined regions.)
Regions are organized hierarchically with sub-regions nested.
For example, in the profile above,
the <SPAN style="font-family:monospace">[OCN] RunPhase1</SPAN> is a sub-region of <SPAN style="font-family:monospace">[esm] RunPhase1</SPAN> and is
entirely contained inside that region. Regions with the same name may appear
at multiple places in the hierarchy, and so would appear in multiple rows
in the table.  The statistics in that row apply to that region at that
location in the hierarchy. Component names appear in square brackets,
e.g., <SPAN style="font-family:monospace">[ATM]</SPAN>,  <SPAN style="font-family:monospace">[OCN]</SPAN>, and <SPAN style="font-family:monospace">[ATM-TO-OCN]</SPAN>.
By default, timings are based on elapsed wall clock time and are collected
on a per-PET basis. Therefore, regions timings may differ across PETs. Regions
are sorted with the most expensive regions appearing at the top. The following
describes the meaning of the statistics in each column:

<P>
<table width="90%"><tr><td align="right" valign="top"><SPAN style="font-family:monospace">Count</SPAN></td><td valign="top">&nbsp;the number of times the region is executed</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Total</SPAN></td><td valign="top">&nbsp;the aggregate time spent in the region, inclusive of all sub-regions</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Self</SPAN></td><td valign="top">&nbsp;the aggregate time spend in the region, exclusive of all sub-regions</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Mean</SPAN></td><td valign="top">&nbsp;the average amount of time for one execution of the region</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Min</SPAN></td><td valign="top">&nbsp;time of the fastest execution of the region</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Max</SPAN></td><td valign="top">&nbsp;time of the slowest execution of the region
</td></tr></table>

<P>

<H3><A ID="SECTION060142200000000000000"></A>
<A ID="sec:SummaryProfiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Summarize Timings across Multiple PETs
</H3>

<P>
By default, separate timing profiles are generated for each PET
in the application.  The per-PET profiles can be aggregated together
and output to a single file, <EM>ESMF_Profile.summary</EM>, by setting the
<SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE_OUTPUT</SPAN> environment variable as follows:

<P>
<PRE>
$ setenv ESMF_RUNTIME_PROFILE ON              # turn on profiling
$ setenv ESMF_RUNTIME_PROFILE_OUTPUT SUMMARY  # specify summary output
</PRE>

<P>
Note the <SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE</SPAN> environment variable must
also be set to <SPAN style="font-family:monospace">ON</SPAN> since this controls all profiling capabilities.
The <EM>ESMF_Profile.summary</EM> file will contain a tree of
timed regions, but aggregated across all PETs. For example:

<P>
<PRE>
Region                           PETs   PEs    Count    Mean (s)    Min (s)     Min PET Max (s)     Max PET
  [esm] Init 1                   4      4      1        4.0880      4.0878      2       4.0883      1
    [OCN-TO-ATM] IPDv05p6b       4      4      1        2.6007      2.6007      2       2.6007      3
    [ATM-TO-OCN] IPDv05p6b       4      4      1        1.4335      1.4333      0       1.4337      3
    [ATM-TO-OCN] IPDv05p4        4      4      1        0.0037      0.0007      0       0.0060      1
    [ATM] IPDv00p2               4      4      1        0.0034      0.0020      1       0.0055      0
    [ATM-TO-OCN] IPDv05p1        4      4      1        0.0020      0.0007      2       0.0033      3
    [OCN] IPDv00p2               4      4      1        0.0019      0.0015      3       0.0024      2
    [ATM-TO-OCN] IPDv05p3        4      4      1        0.0010      0.0008      0       0.0013      1
    [ATM-TO-OCN] IPDv05p2a       4      4      1        0.0009      0.0007      0       0.0012      3
    [ATM] IPDv00p1               4      4      1        0.0009      0.0007      3       0.0011      0
    [ATM-TO-OCN] IPDv05p2b       4      4      1        0.0008      0.0007      0       0.0010      3
    [ATM-TO-OCN] IPDv05p5        4      4      1        0.0008      0.0007      0       0.0010      3
    [ATM-TO-OCN] IPDv05p6a       4      4      1        0.0008      0.0005      2       0.0012      3
    [OCN-TO-ATM] IPDv05p3        4      4      1        0.0008      0.0006      2       0.0010      3
    [OCN-TO-ATM] IPDv05p4        4      4      1        0.0008      0.0006      0       0.0009      3
    [OCN-TO-ATM] IPDv05p2b       4      4      1        0.0007      0.0006      2       0.0009      3
    [OCN] IPDv00p1               4      4      1        0.0007      0.0005      1       0.0009      2
    [OCN-TO-ATM] IPDv05p2a       4      4      1        0.0007      0.0006      2       0.0009      1
    [OCN-TO-ATM] IPDv05p5        4      4      1        0.0007      0.0006      0       0.0009      3
    [OCN-TO-ATM] IPDv05p1        4      4      1        0.0006      0.0005      0       0.0008      1
    [OCN-TO-ATM] IPDv05p6a       4      4      1        0.0006      0.0004      2       0.0007      1
  [esm] RunPhase1                4      4      1        2.7444      2.7423      0       2.7454      1
    [OCN-TO-ATM] RunPhase1       4      4      864      0.6123      0.6004      2       0.6244      1
    [ATM] RunPhase1              4      4      864      0.5386      0.5296      0       0.5530      1
      ATM:ModelAdvance           4      4      864      0.3038      0.3022      0       0.3065      1
    [OCN] RunPhase1              4      4      864      0.3471      0.3256      0       0.3824      1
    [ATM-TO-OCN] RunPhase1       4      4      864      0.2843      0.1956      1       0.3345      0
  [esm] FinalizePhase1           4      4      1        0.0029      0.0029      1       0.0030      2
    [OCN-TO-ATM] FinalizePhase1  4      4      1        0.0007      0.0006      0       0.0008      3
    [ATM-TO-OCN] FinalizePhase1  4      4      1        0.0002      0.0001      3       0.0002      1
    [OCN] FinalizePhase1         4      4      1        0.0001      0.0001      3       0.0001      0
    [ATM] FinalizePhase1         4      4      1        0.0001      0.0000      0       0.0001      2
</PRE>

<P>
The meaning of the statistics in each column in as follows:
<table width="90%"><tr><td align="right" valign="top"><SPAN style="font-family:monospace">PETs</SPAN></td><td valign="top">&nbsp;the number of reporting PETs that executed the region</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">PEs</SPAN></td><td valign="top">&nbsp;the number of PEs associated with the reporting PETs that executed the region</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Count</SPAN></td><td valign="top">&nbsp;the number of times each reporting PET executed the region
      or &ldquo;MULTIPLE&rdquo; if not all PETs executed the region the same number of times</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Mean</SPAN></td><td valign="top">&nbsp;the mean across all reporting PETs of the total time spent in the region</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Min</SPAN></td><td valign="top">&nbsp;the minimum across all reporting PETs of the total time spent in the region</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Min PET</SPAN></td><td valign="top">&nbsp;the PET that reported the minimum time</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Max</SPAN></td><td valign="top">&nbsp;the maximum across all reporting PETs of the total time spent in the region</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">Max PET</SPAN></td><td valign="top">&nbsp;the PET that reported the maximum time
</td></tr></table>

<P>
Note that setting the <SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE_PETLIST</SPAN> environment variable
(described below) may reduce the number of reporting PETs. Only reporting PETs are
included in the summary profile. To output both the per-PET and summary timing profiles,
set the <SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE_OUTPUT</SPAN> environment variable as follows:

<P>
<PRE>
$ setenv ESMF_RUNTIME_PROFILE_OUTPUT "TEXT SUMMARY"
</PRE>

<P>

<H3><A ID="SECTION060142300000000000000"></A>
<A ID="sec:LimitProfiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Limit the Set of Profiled PETs
</H3>

<P>
By default, all PETs in an application are profiled. It may be desirable
to only profile a subset of PETs to reduce the amount of output.
An explicit list of PETs can be specified by setting the
<SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE_PETLIST</SPAN> environment variable.
The syntax of this environment variable is to list
PET numbers separated by spaces. PET ranges are also supported using
the &ldquo;X-Y&rdquo; syntax where X &lt; Y.
For example:

<P>
<PRE>
# only profile PETs 0, 20, and 35 through 39
$ setenv ESMF_RUNTIME_PROFILE_PETLIST "0 20 35-39"
</PRE>

<P>
When used in conjunction with the <SPAN style="font-family:monospace">SUMMARY</SPAN> option above, the summarized
profile will only aggregate over the specified set of PETs. The one exception is that
PET 0 is always profiled if <SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE=ON</SPAN>, regardless of the
<SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_PETLIST</SPAN> setting.

<P>

<H3><A ID="SECTION060142400000000000000"></A>
<A ID="sec:MPIProfiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Include MPI Communication in the Profile
</H3>

<P>
MPI functions can be included in the timing profile to indicate how much time
is spent inside communication calls.  This can also help to determine load imbalance
in the system, since large times spent inside MPI may indicate that communication
between PETs is not tightly synchronized.  This option includes <EM>all</EM> MPI calls in
the application, whether or not they originate from the ESMF library.  Here is a partial
example summary profile that contains MPI times:

<P>
<PRE>
Region                           PETs   Count    Mean (s)    Min (s)     Min PET Max (s)     Max PET
  [esm] RunPhase1                8      1        4.9307      4.6867      0       4.9656      1
    [OCN] RunPhase1              8      1824     0.8344      0.8164      0       0.8652      1
    [MED] RunPhase1              8      1824     0.8203      0.7900      5       0.8584      1
    [ATM] RunPhase1              8      1824     0.6387      0.6212      5       0.6610      1
    [ATM-TO-MED] RunPhase1       8      1824     0.5975      0.5317      0       0.6583      5
      MPI_Bcast                  8      1824     0.0443      0.0025      4       0.1231      5
      MPI_Wait                   8      MULTIPLE 0.0421      0.0032      0       0.0998      2
    [MED-TO-OCN] RunPhase1       8      1824     0.4879      0.4497      0       0.5362      4
      MPI_Wait                   8      MULTIPLE 0.0234      0.0030      0       0.0821      4
      MPI_Bcast                  8      1824     0.0111      0.0024      4       0.0273      5
    [OCN-TO-MED] RunPhase1       8      1824     0.4541      0.4075      0       0.4918      4
      MPI_Wait                   8      MULTIPLE 0.0339      0.0017      0       0.0824      4
      MPI_Bcast                  8      1824     0.0194      0.0026      4       0.0452      6
    [MED-TO-ATM] RunPhase1       8      1824     0.4487      0.4005      0       0.4911      5
      MPI_Bcast                  8      1824     0.0338      0.0026      4       0.0942      5
      MPI_Wait                   8      MULTIPLE 0.0241      0.0022      1       0.0817      2
  [esm] Init 1                   8      1        0.6287      0.6287      1       0.6287      4
    [ATM-TO-MED] IPDv05p6b       8      1        0.1501      0.1500      1       0.1501      2
      MPI_Barrier                8      242      0.0082      0.0006      3       0.0157      7
      MPI_Wait                   8      MULTIPLE 0.0034      0.0010      0       0.0053      7
      MPI_Allreduce              8      62       0.0030      0.0003      3       0.0063      7
      MPI_Alltoall               8      6        0.0015      0.0000      1       0.0022      5
      MPI_Allgather              8      21       0.0010      0.0002      1       0.0017      7
      MPI_Waitall                8      MULTIPLE 0.0006      0.0001      3       0.0015      7
      MPI_Send                   8      MULTIPLE 0.0004      0.0001      7       0.0008      6
      MPI_Allgatherv             8      6        0.0001      0.0001      4       0.0001      0
      MPI_Scatter                8      5        0.0000      0.0000      0       0.0000      7
      MPI_Reduce                 8      5        0.0000      0.0000      1       0.0000      0
      MPI_Recv                   8      MULTIPLE 0.0000      0.0000      0       0.0000      3
      MPI_Bcast                  8      1        0.0000      0.0000      0       0.0000      7
</PRE>

<P>
The procedure for including MPI
functions in the timing profile depends on whether the application is
dynamically or statically linked. Most applications are dynamically linked,
however on some systems (such as Cray), static linking may be used.
Note that for either option, ESMF must be built with <SPAN style="font-family:monospace">ESMF_TRACE_LIB_BUILD=ON</SPAN>,
which is the default.

<P>
In <EM>dynamically linked applications</EM>, the <SPAN style="font-family:monospace">LD_PRELOAD</SPAN> (Linux) or
<SPAN style="font-family:monospace">DYLD_INSERT_LIBRARIES</SPAN> (Darwin) environment variable must be used when
executing the MPI application.  This instructs the dynamic loader to interpose
certain MPI symbols so they can be captured by the ESMF profiler.  To simplify
this process, a script is provided at <SPAN style="font-family:monospace">$(ESMF_INSTALL_LIBDIR)/preload.sh</SPAN>
that sets the appropriate variable.

<P>
For example, if you typically execute your application as as follows:

<P>
<PRE>
$ mpirun -np 8 ./myApp
</PRE>

<P>
then you should add the <EM>preload.sh</EM> script in front of the
executable when starting the application as follows:

<P>
<PRE>
# replace $(ESMF_INSTALL_LIBDIR) with absolute path
# ... to the ESMF installation lib directory
$ mpirun -np 8 $(ESMF_INSTALL_LIBDIR)/preload.sh ./myApp
</PRE>

<P>
An advantage of this approach is that your application does <EM>not</EM> need to
be recompiled. The MPI timing information will be included in the per-PET profiles and/or the summary
profile, depending on the setting of environment variable
<SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE_OUTPUT</SPAN>.

<P>
Notice that an additional step is required for dynamically linked applications
on <EM>Darwin</EM> systems with System Integrity Protection (SIP) enabled! In
addition to using the <SPAN style="font-family:monospace">$(ESMF_INSTALL_LIBDIR)/preload.sh</SPAN> script during
launching of the executable as shown above, the executable must <EM>also be
linked</EM> against the dynamic ESMF trace preload library. This must happen during
the link step of the executable. It is most easily accomplished by using
variable <SPAN style="font-family:monospace">$(ESMF_F90ESMFPRELOADLINKLIBS)</SPAN> instead of the typical
<SPAN style="font-family:monospace">$(ESMF_F90ESMFLINKLIBS)</SPAN> variable for the final link command. Both
variables are defined in the <EM>esmf.mk</EM> file that should be imported by
the application Makefile. For example:

<P>
<PRE>
# import esmf.mk
include $(ESMFMKFILE)

# other makefile targets here...

# example final link command, with $(ESMF_F90ESMFPRELOADLINKLIBS)
myApp: myApp.o driver.o model.o
        $(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) \
        $(ESMF_F90LINKRPATHS) -o $@ $^ $(ESMF_F90ESMFPRELOADLINKLIBS)
</PRE>

<P>
In <EM>statically linked applications</EM>, the application must be re-linked
with specific options provided to the linker.  These options instruct the linker
to wrap the MPI symbols with the ESMF profiling functions. The linking flags that
must be provided are included in the <EM>esmf.mk</EM> Makefile fragment that
is part of the ESMF installation. These link flags should be imported into
your application Makefile, and included in the final link command. To do this,
first import the <EM>esmf.mk</EM> file into your application Makefile. The path
to this file is typically stored in the <SPAN style="font-family:monospace">ESMFMKFILE</SPAN> environment variable.
Then, pass the variables <SPAN style="font-family:monospace">$(ESMF_TRACE_STATICLINKOPTS)</SPAN> and
<SPAN style="font-family:monospace">$(ESMF_TRACE_STATICLINKLIBS)</SPAN> to the final linking command.  For example:

<P>
<PRE>
# import esmf.mk
include $(ESMFMKFILE)

# other makefile targets here...

# example final link command, with $(ESMF_TRACE_STATICLINKOPTS)
# ... and $(ESMF_TRACE_STATICLINKLIBS) added
myApp: myApp.o driver.o model.o
        $(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) \
        $(ESMF_F90LINKRPATHS) -o $@ $^ $(ESMF_F90ESMFLINKLIBS) \
        $(ESMF_TRACE_STATICLINKOPTS) $(ESMF_TRACE_STATICLINKLIBS)
</PRE>

<P>
This option will statically wrap all of the MPI functions and include them
in the profile output.  Execute the application in the normal way
with the environment variable <SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE</SPAN> set to <SPAN style="font-family:monospace">ON</SPAN>.
You will see the MPI functions included in the timing profile.

<P>

<H3><A ID="SECTION060142500000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Output a Detailed Trace for Analysis</A>
</H3>

<P>
ESMF tracing is disabled by default. To enable tracing, set the
<SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE</SPAN> environment variable to <SPAN style="font-family:monospace">ON</SPAN>. You
do not need to recompile your code to enable tracing.

<P>
<PRE>
# csh shell
$ setenv ESMF_RUNTIME_TRACE ON

# bash shell
$ export ESMF_RUNTIME_TRACE=ON
</PRE>

<P>
When enabled, the default behavior is to trace all PETs of the
ESMF application. Although the ESMF tracer is designed to write
events in a compact form, tracing can produce an extremely
large number of events depending on the total number of PETs and
the length of the run. To reduce output, it is possible to restrict
the PETs that produce trace output by setting the <SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_PETLIST</SPAN>
environment variable. For example, this setting:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_PETLIST "0 101 192-196"
</PRE>

<P>
will instruct the tracer to only trace PETs 0, 101, and 192 through 196
(inclusive). The syntax of this environment variable is to list
PET numbers separated by spaces. PET ranges are also supported using
the &ldquo;X-Y&rdquo; syntax where X &lt; Y. For PET counts greater than 100, it is
recommended to set this environment variable. The one exception is that
PET 0 is always traced, regardless of the <SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_PETLIST</SPAN>
setting.

<P>
ESMF's profiling and tracing options can be used together.  A typical
use would be to set <SPAN style="font-family:monospace">ESMF_RUNTIME_PROFILE=ON</SPAN> for all PETs to
capture summary timings, and set <SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE=ON</SPAN> and
<SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_PETLIST</SPAN> to a subset of of PETs,
such as the root PET of each ESMF component. This helps to keep trace
sizes small while still providing timing summaries over all PETs.

<P>
When tracing is enabled, <SPAN style="font-family:monospace">phase_enter</SPAN> and <SPAN style="font-family:monospace">phase_exit</SPAN> events will
automatically be recorded for all initialize, run, and finalize phases of all
Components in the application. To trace <EM>only</EM> user-instrumented regions (via
the <SPAN style="font-family:monospace">ESMF_TraceRegionEnter()</SPAN> and <SPAN style="font-family:monospace">ESMF_TraceRegionExit()</SPAN> calls),
Component-level tracing can be turned off by setting:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_COMPONENT OFF
</PRE>

<P>
After running an ESMF application with tracing enabled, a directory
called <EM>traceout</EM> will be created in the run directory and it will
contain a <EM>metadata</EM> file and an event stream file <EM>esmf_stream_XXXX</EM>
for each PET with tracing enabled. Together these files form a valid
CTF trace which may be analyzed with any of the tools listed above.

<P>
Trace events are flushed to file at a regular interval. If the application
crashes, some of the most recent events may not be flushed to file. To
maximize the number of events appearing in the trace, an option is available
to flush events to file more frequently. Because this option may have
negative performance implications due to increased file I/O, it is not
recommended unless needed. To turn on eager flushing use:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_FLUSH EAGER
</PRE>

<P>

<H3><A ID="SECTION060142600000000000000"></A>
<A ID="sec:TracingClocks"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Set the Clock used for Profiling/Tracing
</H3>

<P>
There are three options for the kind of clock to use to timestamp
events when profiling/tracing an application.
These options are controlled by setting the environment variable
<SPAN style="font-family:monospace">ESMF_RUNTIME_TRACE_CLOCK</SPAN>.
<table width="90%"><tr><td align="right" valign="top"><SPAN style="font-family:monospace">REALTIME</SPAN></td><td valign="top">&nbsp;The <SPAN style="font-family:monospace">REALTIME</SPAN> clock timestamps events with the current time on
      the system.  This is the default clock if the above environment
      variable is not set.  This setting can be useful when tracing PETs that
      span multiple physical computing nodes assuming that the system clocks
      on each node are adequately synchronized.  On most HPC systems, system
      clocks are periodically updated to stay in sync.  A disadvantage of this
      clock is that periodic adjustments mean the clock is not monotonically
      increasing so some timings may be inaccurate if the system clock jumps
      forward or backward significantly. Testing has shown that this is not
      typically an issue on most systems.</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">MONOTONIC</SPAN></td><td valign="top">&nbsp;The <SPAN style="font-family:monospace">MONOTONIC</SPAN> clock is guaranteed to be monotonically increasing
      and does not suffer from periodic adjustments.  The timestamps represent
      an amount of time since some arbitrary point in the past.  There is no
      guarantee that these timestamps will be synchronized across physical
      computing nodes, so this option should only be used for tracing a set of PETs
      running on a single physical machine.</td></tr>
<tr><td align="right" valign="top"><SPAN style="font-family:monospace">MONOTONIC_SYNC</SPAN></td><td valign="top">&nbsp;The <SPAN style="font-family:monospace">MONOTONIC_SYNC</SPAN> clock is similar to the <SPAN style="font-family:monospace">MONOTONIC</SPAN> clock
      in that it is guaranteed to be monotonically increasing. In addition, at
      application startup, all PET clocks are synchronized to a common time
      by determining a PET-local offset to be applied to timestamps. Therefore this option
      can be used to compare trace streams across physical nodes.
</td></tr></table>

<H2><A ID="SECTION060143000000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limited types of trace events.</B>
  Currently only a few trace event types are available. The tracer may
  be extended in the future to record additional types of events.
</LI>
<LI><B>MPI call profing not available for statically linked executables on Darwin.</B>
  Currently the linker on Darwin systems does not support the wrapping of
  symbols during static linking. In order to access MPI call profiling on Darwin,
  executables should be linked dynamically in combination with the procedure
  described in section <A HREF="#sec:MPIProfiling">52.2.4</A>.
</LI>
</OL>

<P>

<H2><A ID="SECTION060144000000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<H1><A ID="SECTION060150000000000000000">
<SPAN CLASS="arabic">53</SPAN> Fortran I/O and System Utilities</A>
</H1>

<H2><A ID="SECTION060151000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A ID="sec:IOUtil"></A>
<P>
The ESMF Fortran I/O and System utilities provide portable methods to
access capabilities which are often implemented in different
ways amongst different environments.  These utility methods are
divided into three groups: command line access, Fortran I/O, and
sorting.

<P>
Command line arguments may be accessed using three methods:
<SPAN style="font-family:monospace">ESMF_UtilGetArg()</SPAN> returns a given command line argument,
<SPAN style="font-family:monospace">ESMF_UtilGetArgC()</SPAN> returns a count of the number of command line
arguments available.  Finally, the <SPAN style="font-family:monospace">ESMF_UtilGetArgIndex()</SPAN> method
returns the index of a desired argument value, given its keyword name.

<P>
Two I/O methods are implemented: <SPAN style="font-family:monospace">ESMF_IOUnitGet()</SPAN>,
to obtain an unopened Fortran unit number within the range of unit numbers that
ESMF is allowed to use, and <SPAN style="font-family:monospace">ESMF_IOUnitFlush()</SPAN> to flush the
I/O buffer associated with a specific Fortran unit.

<P>
Finally, the <SPAN style="font-family:monospace">ESMF_UtilSort()</SPAN> method sorts integer, floating point,
and character string data types in either ascending or descending order.

<H2><A ID="SECTION060152000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>

<H3><A ID="SECTION060152100000000000000"></A> <A ID="fio:unitnumbers"></A>
<BR>
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Fortran unit number management
</H3>
The <SPAN style="font-family:monospace">ESMF_UtilIOUnitGet()</SPAN> method is provided so that applications
using ESMF can remain free of unit number conflicts &mdash; both when combined
with other third party code, or with ESMF itself.  This call is typically
used just prior to an <SPAN style="font-family:monospace">OPEN</SPAN> statement:

<P>
<PRE>
  call ESMF_UtilIOUnitGet (unit=grid_unit, rc=rc)
  open (unit=grid_unit, file='grid_data.dat', status='old', action='read')
</PRE>

<P>
By default, unit numbers between 50 and 99 are scanned to find an unopened
unit number.

<P>
Internally, ESMF also uses <SPAN style="font-family:monospace">ESMF_UtilIOUnitGet()</SPAN> when it needs to open
Fortran unit numbers for file I/O.  By using the same API for both user and
ESMF code, unit number collisions can be avoided.

<P>
When integrating ESMF into an application where there are conflicts with
other uses of the same unit number range, such as when hard-coded unit number
values are used, an alternative unit number range can be specified.
The <SPAN style="font-family:monospace">ESMF_Initialize()</SPAN> optional arguments <SPAN style="font-family:monospace">IOUnitLower</SPAN> and <SPAN style="font-family:monospace">IOUnitUpper</SPAN>
may be set as needed.  Note that <SPAN style="font-family:monospace">IOUnitUpper</SPAN> must be set to a value higher than
<SPAN style="font-family:monospace">IOUnitLower</SPAN>, and that both must be non-negative.  Otherwise <SPAN style="font-family:monospace">ESMF_Initialize</SPAN>
will return a return code of <SPAN style="font-family:monospace">ESMF_FAILURE</SPAN>.  ESMF itself does not typically need more
than about five units for internal use.

<P>
<PRE>
  call ESMF_Initialize (..., IOUnitLower=120, IOUnitUpper=140)
</PRE>

<P>
All current Fortran environments have preconnected unit numbers, such as
units 5 and 6 for standard input and output, in the single digit range.
So it is recommended that the unit number range is chosen to begin at unit 10
or higher to avoid these preconnected units.

<P>

<H3><A ID="SECTION060152200000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Flushing output</A>
</H3>

<P>
Fortran run-time libraries generally use buffering techniques to improve I/O
performance.  However output buffering can be problematic when output is needed,
but is &ldquo;trapped&rdquo; in the buffer because it is not full.
This is a common occurrance when debugging a program, and inserting <SPAN style="font-family:monospace">WRITE</SPAN> statements
to track down the bad area of code.  If the program crashes before the output
buffer has been flushed, the desired debugging output may never be seen &mdash; giving
a misleading indication of where the problem occurred.  It would be desirable
to ensure that the output buffer is flushed at predictable
points in the program in order to get the needed results.
Likewise, in parallel code, predictable flushing of output buffers is a common
requirement, often in conjunction with <SPAN style="font-family:monospace">ESMF_VMBarrier()</SPAN> calls.  

<P>
The <SPAN style="font-family:monospace">ESMF_UtilIOUnitFlush()</SPAN> API is provided to flush a unit as desired.  Here is
an example of code which prints debug values, and serializes the output to a
terminal in PET order:

<P>
<PRE>
  type(ESMF_VM) :: vm

  integer :: tty_unit
  integer :: me, npets

  call ESMF_Initialize (vm=vm, rc=rc)
  call ESMF_VMGet (vm, localPet=me, petCount=npes)

  call ESMF_UtilIOUnitGet (unit=tty_unit)
  open (unit=tty_unit, file='/dev/tty', status='old', action='write')
  ...
  call ESMF_VMBarrier (vm=vm)
  do, i=0, npets-1
    if (i == me) then
      write (tty_unit, *) 'PET: ', i, ', values are: ', a, b, c
      call ESMF_UtilIOUnitFlush (unit=tty_unit)
    end if
    call ESMF_VMBarrier (vm=vm)
  end do
</PRE>
<H2><A ID="SECTION060153000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<H3><A ID="SECTION060153100000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Fortran unit number management</A>
</H3>

<P>
When ESMF needs to open a Fortran I/O unit, it calls <SPAN style="font-family:monospace">ESMF_IOUnitGet()</SPAN> to find
an unopened unit number.  As delivered, the range of unit numbers that are
searched are between <SPAN style="font-family:monospace">ESMF_LOG_FORTRAN_UNIT_NUMBER</SPAN> (normally set to
50), and <SPAN style="font-family:monospace">ESMF_LOG_UPPER</SPAN> (normally set to 99.)
Unopened unit numbers are found by using the Fortran <SPAN style="font-family:monospace">INQUIRE</SPAN> statement.

<P>
When integrating ESMF into an application where there are conflicts with
other uses of the same unit number range, an alternative range can be specified
in the <SPAN style="font-family:monospace">ESMF_Initialize()</SPAN> call by setting the <SPAN style="font-family:monospace">IOUnitLower</SPAN> and <SPAN style="font-family:monospace">IOUnitUpper</SPAN>
arguments as needed.  <SPAN style="font-family:monospace">ESMF_IOUnitGet()</SPAN> will then search the alternate range
of unit numbers.  Note that <SPAN style="font-family:monospace">IOUnitUpper</SPAN> must be set to a value higher than
<SPAN style="font-family:monospace">IOUnitLower</SPAN>, and that both must be non-negative.  Otherwise <SPAN style="font-family:monospace">ESMF_Initialize</SPAN>
will return a return code of <SPAN style="font-family:monospace">ESMF_FAILURE</SPAN>.

<P>
Fortran unit numbers are not standardized in the Fortran 90 Standard.  The standard
only requires that they be non-negative integers.  But other than that, it is
up to the compiler writers and application developers to provide and
use units which work with the particular implementation.  For example,
units 5 and 6 are a defacto standard for &ldquo;standard input&rdquo; and
&ldquo;standard output&rdquo; &mdash; even though this is not specified in the actual Fortran
standard.  The Fortran standard also does not specify which unit numbers can
be used, nor does it specify how many can be open simultaneously.

<P>
Since all current compilers have preconnected unit numbers, and these are
typically found on units lower than 10, it is recommended that applications
use unit numbers 10 and higher.

<P>

<H3><A ID="SECTION060153200000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Flushing output</A>
</H3>

<P>
When ESMF needs to flush a Fortran unit, the <SPAN style="font-family:monospace">ESMF_IOUnitFlush()</SPAN> API is used
to centralize the file flushing capability, because Fortran has not historically
had a standard mechanism for flushing output buffers.  Most compilers run-time libraries
support various library extensions to provide this functionality &mdash; though,
being non-standard, the spelling and number of arguments vary between implementations.
Fortran 2003 also provides for a <SPAN style="font-family:monospace">FLUSH</SPAN> statement which is built into the
language.  When possible, <SPAN style="font-family:monospace">ESMF_IOUnitFlush()</SPAN> uses the F2003 <SPAN style="font-family:monospace">FLUSH</SPAN> statement.
With older compilers, the appropriate library call is made.

<P>

<H3><A ID="SECTION060153300000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sorting algorithms</A>
</H3>

<P>
The <SPAN style="font-family:monospace">ESMF_UtilSort()</SPAN> algorithms are the same as those in the <SPAN style="font-family:monospace">LAPACK</SPAN>
sorting procedures <SPAN style="font-family:monospace">SLASRT()</SPAN> and <SPAN style="font-family:monospace">DLASRT()</SPAN>.  Two algorithms are used.
For small sorts, arrays with 20 or fewer elements, a simple Insertion sort is
used.  For larger sorts, a Quicksort algorithm is used.

<P>
Compared to the original <SPAN style="font-family:monospace">LAPACK</SPAN> code, a full Fortran 90 style
interface is supported for ease of use and enhanced compile time checking.
Additional support is also provided for integer and character string data
types.

<H2><A ID="SECTION060154000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN> Utility API</A>
</H2>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html1145"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node7.html">6 References</A>
<B> Up:</B> <A
 HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A
 HREF="node5.html">4 Infrastructure: Fields and Grids</A>
 &nbsp; <B>  <A ID="tex2html1146"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
