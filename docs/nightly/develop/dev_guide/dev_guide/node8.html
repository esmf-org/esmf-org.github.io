<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>7 Conventions</TITLE>
<META NAME="description" CONTENT="7 Conventions">
<META NAME="keywords" CONTENT="dev_guide">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="dev_guide.css">

<LINK REL="next" HREF="node9.html">
<LINK REL="previous" HREF="node7.html">
<LINK REL="up" HREF="dev_guide.html">
<LINK REL="next" HREF="node9.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html569"
  HREF="node9.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html565"
  HREF="dev_guide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html559"
  HREF="node7.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html567"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html570"
  HREF="node9.html">8 Tracking and Metrics</A>
<B> Up:</B> <A NAME="tex2html566"
  HREF="dev_guide.html">dev_guide</A>
<B> Previous:</B> <A NAME="tex2html560"
  HREF="node7.html">6 Test Harness</A>
 &nbsp; <B>  <A NAME="tex2html568"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A NAME="tex2html571"
  HREF="node8.html#SECTION00081000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Docs: Code and Documentation Templates and Associated Scripts</A>
<UL>
<LI><A NAME="tex2html572"
  HREF="node8.html#SECTION00081100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Documentation Generation Script</A>
<LI><A NAME="tex2html573"
  HREF="node8.html#SECTION00081200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Code Generation Scripts</A>
</UL>
<BR>
<LI><A NAME="tex2html574"
  HREF="node8.html#SECTION00082000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> Docs: Documentation Guidelines and Conventions</A>
<UL>
<LI><A NAME="tex2html575"
  HREF="node8.html#SECTION00082100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Accessibility</A>
<LI><A NAME="tex2html576"
  HREF="node8.html#SECTION00082200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> File format</A>
<LI><A NAME="tex2html577"
  HREF="node8.html#SECTION00082300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Typeface and Diagram Conventions</A>
<LI><A NAME="tex2html578"
  HREF="node8.html#SECTION00082400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Style Rules for <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN></A>
</UL>
<BR>
<LI><A NAME="tex2html579"
  HREF="node8.html#SECTION00083000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> Docs: Performance Report Conventions</A>
<LI><A NAME="tex2html580"
  HREF="node8.html#SECTION00084000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> Docs: Reference Manual Conventions</A>
<UL>
<LI><A NAME="tex2html581"
  HREF="node8.html#SECTION00084100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description, Use and Examples, and Other Introductory Sections</A>
<LI><A NAME="tex2html582"
  HREF="node8.html#SECTION00084200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples Sections</A>
<LI><A NAME="tex2html583"
  HREF="node8.html#SECTION00084300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> Flags and Options Sections</A>
<LI><A NAME="tex2html584"
  HREF="node8.html#SECTION00084400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API Sections</A>
</UL>
<BR>
<LI><A NAME="tex2html585"
  HREF="node8.html#SECTION00085000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> Code: Method Conventions</A>
<UL>
<LI><A NAME="tex2html586"
  HREF="node8.html#SECTION00085100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Standard Method Names</A>
<LI><A NAME="tex2html587"
  HREF="node8.html#SECTION00085200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use of *Set and *Get</A>
<LI><A NAME="tex2html588"
  HREF="node8.html#SECTION00085300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use of Is* and Has*</A>
<LI><A NAME="tex2html589"
  HREF="node8.html#SECTION00085400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> Functions vs. Subroutines</A>
<LI><A NAME="tex2html590"
  HREF="node8.html#SECTION00085500000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> Source and Destination Ordering</A>
</UL>
<BR>
<LI><A NAME="tex2html591"
  HREF="node8.html#SECTION00086000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> Code: Argument Conventions</A>
<UL>
<LI><A NAME="tex2html592"
  HREF="node8.html#SECTION00086100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Standard Variable Names</A>
<LI><A NAME="tex2html593"
  HREF="node8.html#SECTION00086200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use of Is* and Has*</A>
<LI><A NAME="tex2html594"
  HREF="node8.html#SECTION00086300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> Variable Capitalization</A>
<LI><A NAME="tex2html595"
  HREF="node8.html#SECTION00086400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> Variables Associated with Options</A>
<LI><A NAME="tex2html596"
  HREF="node8.html#SECTION00086500000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> Variables Having Logical Data Type</A>
<LI><A NAME="tex2html597"
  HREF="node8.html#SECTION00086600000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> Arguments which are Arrays</A>
<LI><A NAME="tex2html598"
  HREF="node8.html#SECTION00086700000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> Arguments which are Pointers</A>
</UL>
<BR>
<LI><A NAME="tex2html599"
  HREF="node8.html#SECTION00087000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> Code: File Rules</A>
<UL>
<LI><A NAME="tex2html600"
  HREF="node8.html#SECTION00087100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Version Identification</A>
<LI><A NAME="tex2html601"
  HREF="node8.html#SECTION00087200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> License and Copyright Information</A>
<LI><A NAME="tex2html602"
  HREF="node8.html#SECTION00087300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> TODO: Reminder</A>
<LI><A NAME="tex2html603"
  HREF="node8.html#SECTION00087400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> FILENAME Macros</A>
</UL>
<BR>
<LI><A NAME="tex2html604"
  HREF="node8.html#SECTION00088000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> Code: Style Rules for Source Code</A>
<LI><A NAME="tex2html605"
  HREF="node8.html#SECTION00089000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN> Code: Error Handling Conventions</A>
<UL>
<LI><A NAME="tex2html606"
  HREF="node8.html#SECTION00089100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">1</SPAN> Objectives</A>
<LI><A NAME="tex2html607"
  HREF="node8.html#SECTION00089200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">2</SPAN> Approach</A>
<LI><A NAME="tex2html608"
  HREF="node8.html#SECTION00089300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">3</SPAN> Error Masking</A>
<LI><A NAME="tex2html609"
  HREF="node8.html#SECTION00089400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">4</SPAN> Example (pre-review method)</A>
<LI><A NAME="tex2html610"
  HREF="node8.html#SECTION00089500000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">5</SPAN> Example (post-review method)</A>
<LI><A NAME="tex2html611"
  HREF="node8.html#SECTION00089600000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">6</SPAN> Memory Allocation Checking</A>
</UL>
<BR>
<LI><A NAME="tex2html612"
  HREF="node8.html#SECTION000810000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN> Initialization Standardization Instructions</A>
<UL>
<LI><A NAME="tex2html613"
  HREF="node8.html#SECTION000810100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Overview</A>
<LI><A NAME="tex2html614"
  HREF="node8.html#SECTION000810200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> Instructions</A>
<LI><A NAME="tex2html615"
  HREF="node8.html#SECTION000810300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> Module</A>
<LI><A NAME="tex2html616"
  HREF="node8.html#SECTION000810400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> Shallow Class</A>
<LI><A NAME="tex2html617"
  HREF="node8.html#SECTION000810500000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> Deep Class</A>
<LI><A NAME="tex2html618"
  HREF="node8.html#SECTION000810600000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">6</SPAN> Parameter Class</A>
<LI><A NAME="tex2html619"
  HREF="node8.html#SECTION000810700000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">7</SPAN> Subroutine</A>
<LI><A NAME="tex2html620"
  HREF="node8.html#SECTION000810800000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF Class Types</A>
</UL>
<BR>
<LI><A NAME="tex2html621"
  HREF="node8.html#SECTION000811000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN> Code: Data Type Consistency Guidelines</A>
<UL>
<LI><A NAME="tex2html622"
  HREF="node8.html#SECTION000811100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN> Use ESMF names for data types in C and ESMF data kinds in Fortran</A>
<LI><A NAME="tex2html623"
  HREF="node8.html#SECTION000811200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">2</SPAN> Fortran</A>
<LI><A NAME="tex2html624"
  HREF="node8.html#SECTION000811300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">3</SPAN> C and C++</A>
<LI><A NAME="tex2html625"
  HREF="node8.html#SECTION000811400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_TypeKind_Flag &ldquo;labels&rdquo;: When knowing the data type/kind is necessary</A>
<LI><A NAME="tex2html626"
  HREF="node8.html#SECTION000811500000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">5</SPAN> Guidelines for Fortran-C Interfaces</A>
</UL>
<BR>
<LI><A NAME="tex2html627"
  HREF="node8.html#SECTION000812000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN> Code: Optional Argument Conventions for the C/C++ API</A>
<UL>
<LI><A NAME="tex2html628"
  HREF="node8.html#SECTION000812100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN> Overview</A>
<LI><A NAME="tex2html629"
  HREF="node8.html#SECTION000812200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">2</SPAN> Approach</A>
<LI><A NAME="tex2html630"
  HREF="node8.html#SECTION000812300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">3</SPAN> Internal Macros for Processing the Optional Argument List</A>
<LI><A NAME="tex2html631"
  HREF="node8.html#SECTION000812400000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">4</SPAN> Parsing the Optional Argument List</A>
</UL>
<BR>
<LI><A NAME="tex2html632"
  HREF="node8.html#SECTION000813000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN> Code: Makefile Conventions</A>
<UL>
<LI><A NAME="tex2html633"
  HREF="node8.html#SECTION000813100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">1</SPAN> Code Building Rules</A>
<LI><A NAME="tex2html634"
  HREF="node8.html#SECTION000813200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">2</SPAN> Document Building Rules</A>
<LI><A NAME="tex2html635"
  HREF="node8.html#SECTION000813300000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">3</SPAN> Include Files</A>
</UL>
<BR>
<LI><A NAME="tex2html636"
  HREF="node8.html#SECTION000814000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN> Preprocessor Usage</A>
<UL>
<LI><A NAME="tex2html637"
  HREF="node8.html#SECTION000814100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN>.<SPAN CLASS="arabic">1</SPAN> Using the Preprocessor For Generic Fortran Code</A>
<LI><A NAME="tex2html638"
  HREF="node8.html#SECTION000814200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN>.<SPAN CLASS="arabic">2</SPAN> System Dependent Strategy Using Preprocessor</A>
</UL>
<BR>
<LI><A NAME="tex2html639"
  HREF="node8.html#SECTION000815000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF Data Type Autopromotion Support Policy and Guide</A>
<UL>
<LI><A NAME="tex2html640"
  HREF="node8.html#SECTION000815100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> How We Arrived at This Autopromotion Support Policy</A>
</UL>
<BR>
<LI><A NAME="tex2html641"
  HREF="node8.html#SECTION000816000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">16</SPAN> Scripts: Script Coding Standard</A>
<UL>
<LI><A NAME="tex2html642"
  HREF="node8.html#SECTION000816100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Content Rules</A>
</UL>
<BR>
<LI><A NAME="tex2html643"
  HREF="node8.html#SECTION000817000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">17</SPAN> Lang: Interlanguage Coding Conventions</A>
<UL>
<LI><A NAME="tex2html644"
  HREF="node8.html#SECTION000817100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Optional Arguments Across Language Interfaces</A>
</UL>
<BR>
<LI><A NAME="tex2html645"
  HREF="node8.html#SECTION000818000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">18</SPAN> Lang: Fortran Coding Standard</A>
<UL>
<LI><A NAME="tex2html646"
  HREF="node8.html#SECTION000818100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Content Rules</A>
<LI><A NAME="tex2html647"
  HREF="node8.html#SECTION000818200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Style Rules</A>
</UL>
<BR>
<LI><A NAME="tex2html648"
  HREF="node8.html#SECTION000819000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">19</SPAN> Lang: C/C++ Coding Standard</A>
<LI><A NAME="tex2html649"
  HREF="node8.html#SECTION000820000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">20</SPAN> Repo: Source Code Naming and Tagging Conventions</A>
<UL>
<LI><A NAME="tex2html650"
  HREF="node8.html#SECTION000820100000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Public Releases</A>
<LI><A NAME="tex2html651"
  HREF="node8.html#SECTION000820200000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Internal Releases</A>
</UL>
<BR>
<LI><A NAME="tex2html652"
  HREF="node8.html#SECTION000821000000000000000"><SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">21</SPAN> Data Management Conventions</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00080000000000000000"></A>
<A NAME="sec:code_conv"></A>
<BR>
<SPAN CLASS="arabic">7</SPAN> Conventions
</H1>

<P>
Code and documentation developed for the ESMF will follow conventions 
for both style and content.  The goal is to create software with a consistent 
look and feel so that it is easier to read and maintain.  

<P>
Because much ESMF documentation is generated directly from source 
code, code and documentation conventions are closely intertwined.

<P>

<H2><A NAME="SECTION00081000000000000000"></A>
<A NAME="sec:code_templates"></A>
<BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Docs: Code and Documentation Templates and Associated Scripts
</H2>

<P>
ESMF maintains a set of templates for developing Fortran and 
C++ codes and their documentation.  The documentation templates
include requirements, design, and reference documents.
These templates are bundled with the source distribution, in 
the following directory:
<BR>
<PRE>
$(ESMF_DIR)/scripts/doc_templates
</PRE> 

<P>

<H3><A NAME="SECTION00081100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Documentation Generation Script</A>
</H3>

<P>
The <TT>do_newdoc</TT> script in the document templates package creates
a new document directory and populates it with the appropriate files.
The READMEs in the package describe the procedure for running the 
script.

<P>

<H3><A NAME="SECTION00081200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Code Generation Scripts</A>
</H3>
A set of scripts is available that creates a set of new directories for either 
a C++ or Fortran class and populates them with the appropriate code and 
document files.  The READMEs in the <TT>doc_templates</TT> 
package describe the procedures for doing this.  

<P>
The following scripts are included in the <TT>doc_templates</TT> package:
<DL>
<DT><STRONG>do_newcomp</STRONG></DT>
<DD>This script creates a new component. It makes a new component directory
tree if one does not already exist. In addition, it adds the required template files
in the component directory tree with the proper root file names.
</DD>
<DT><STRONG>do_newclass</STRONG></DT>
<DD>This script creates a new class template in the current directory. 
It may be used for both C++ and Fortran 90 classes. For C++, it adds an include
file (ESMC_class.h) in the component include directory, if one does not exist.
</DD>
</DL>

<P>

<H2><A NAME="SECTION00082000000000000000"></A>
<A NAME="sec:docguidelines"></A>
<BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> Docs: Documentation Guidelines and Conventions
</H2>

<P>

<H3><A NAME="SECTION00082100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Accessibility</A>
</H3>

<P>
Software documentation for the last public release is at:
<PRE>
  http://www.earthsystemmodeling.org -&gt; Users -&gt; Documentation
</PRE> 

<P>
Software documentation for all releases is at:
<PRE>
  http://www.earthsystemmodeling.org -&gt; Download -&gt; View All Releases
</PRE>

<P>
Documents are available to developers for editing through the
ESMF repository on the SourceForge site.

<P>

<H3><A NAME="SECTION00082200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> File format</A>
</H3>

<P>
Documents will be available in both web-browsable (e.g. html) and
printer-friendly formats.  They will be written in <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> and based on a
set of templates. <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> was chosen because:

<P>

<UL>
<LI>it is a format that many people are already familiar with; 
</LI>
<LI>it can produce both print and web documentation by using text-to-html
tools such as <A NAME="tex2html21"
  HREF="http://laborant.dfki.uni-sb.de:8000/doc/latex2html-manual-html-99_1/">latex2html</A>;
</LI>
<LI>it is the format generated by the F90/C++ compatible 
auto-documentation tool <A NAME="tex2html22"
  HREF="http://polar.gsfc.nasa.gov/software/protex/protex.php">ProTeX</A>[<A
 HREF="node12.html#protex">3</A>], 
which we shall use.
</LI>
</UL>

<P>

<H3><A NAME="SECTION00082300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Typeface and Diagram Conventions</A>
</H3>

<P>

<P>
The following conventions for fonts and capitalization are used
in this and other ESMF documents. <BR>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Style</B></TD>
<TD ALIGN="LEFT"><B>Meaning</B></TD>
<TD ALIGN="LEFT"><B>Example</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>italics</I></TD>
<TD ALIGN="LEFT">documents</TD>
<TD ALIGN="LEFT"><I>ESMF Reference Manual</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>courier</TT></TD>
<TD ALIGN="LEFT">code fragments</TD>
<TD ALIGN="LEFT"><TT>ESMF_TRUE</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>courier()</TT></TD>
<TD ALIGN="LEFT">ESMF method name</TD>
<TD ALIGN="LEFT"><TT>ESMF_FieldGet()</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>boldface</B></TD>
<TD ALIGN="LEFT">first definitions</TD>
<TD ALIGN="LEFT">An <B>address space</B> is ...</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>boldface</B></TD>
<TD ALIGN="LEFT">web links and tabs</TD>
<TD ALIGN="LEFT"><B>Developers</B> tab on the website</TD>
</TR>
<TR><TD ALIGN="LEFT">Capitals</TD>
<TD ALIGN="LEFT">ESMF class name</TD>
<TD ALIGN="LEFT">DataMap</TD>
</TR>
</TABLE> 

<P>
ESMF class names frequently coincide with words commonly
used within the Earth system domain (field, grid, component, array, 
etc.)  The convention we adopt in this manual is that if a word is 
used in the context of an ESMF class name it is capitalized, and 
if the word is used in a more general context it remains in lower 
case.  We would write, for example, that an ESMF Field class 
represents a physical field.  

<P>
Diagrams are drawn using the Unified Modeling Language (UML).  UML 
is a visual tool that can illustrate the structure of 
classes, define relationships between classes, and describe sequences
of actions.  A reader interested in more detail can refer to a 
text such as <I>The Unified Modeling Language Reference Manual.</I>
 []

<P>

<H3><A NAME="SECTION00082400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Style Rules for <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN></A>
</H3>

<P>
General style recommendations for <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> documentation include the
following:

<P>

<OL>
<LI>Limiting the source file text width to 80 characters;
</LI>
<LI>The use of proper indentation in sections and environments;
</LI>
<LI>The liberal use of blank lines to delimit blocks;
</LI>
<LI>Leaving as much of the typesetting as possible to <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> itself
  (user-specified lengths, pagebreaks, etc. are discouraged);
</LI>
<LI>The use of the <TT>html</TT> package for convenient production
  of HTML and print formats;
</LI>
<LI>The use of the <TT>fontenc</TT> packages
  to permit use of <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> special tokens in source;
</LI>
<LI>The use of a Type-I font (e.g the <TT>times</TT> or
  <TT>palatcm</TT> packages) to provide scaling PDF documents.
</LI>
</OL>

<P>

<H2><A NAME="SECTION00083000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> Docs: Performance Report Conventions</A>
</H2>
Measurements and analysis of ESMF performance are documented in
performance reports.  These reports are used to communicate 
information about framework performance, and are used to
define and assess the success of optimization efforts.
They are posted on the ESMF website under the <B>Performance</B>
link.  Reports typically contain the following sections:  Objective,
Description of the Benchmark,  Results, Optimizations 
and Conclusions.

<P>
Performance reports should contain the following specific 
information:

<OL>
<LI>The tag or version of the framework used (<I>not</I> a moving tag,
like HEAD or LAST_STABLE)
</LI>
<LI>Where to get the source code
</LI>
<LI>Machine location and type
</LI>
<LI>OS and compiler version
</LI>
<LI>Processor counts
</LI>
<LI>Complete description of grids and distributions or where
to get that info
</LI>
<LI>How many iterations were performed for each data point
</LI>
<LI>How the timings were obtained from the iterations 
</LI>
</OL>

<P>

<H2><A NAME="SECTION00084000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> Docs: Reference Manual Conventions</A>
</H2>

<P>

<H3><A NAME="SECTION00084100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description, Use and Examples, and Other Introductory Sections</A>
</H3>

<P>

<OL>
<LI>These sections shall contain thorough coverage of class
behavior and usage.  Any mention of private classes or implementation 
strategies shall be reserved for the sections called <I>Design and 
Implementation Notes</I>.  Restrictions shall be listed in the 
<I>Restrictions and Future Work</I> sections.

<P>
</LI>
<LI>If a method name is referred to in the text it shall be in this
fashion <TT>ESMF_&lt;Class&gt;&lt;MethodName&gt;()</TT>.  If a code fragment or flag is
included in the text, we shall use the form <TT>ESMF_&lt;FLAG_NAME&gt;</TT> 
or surround the fragment with the <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> <TT>verbatim</TT> command.  The 
goal is to get all code fragments in an identifiable font.

<P>
</LI>
<LI>Class names shall be capitalized in these sections, and
in the normal text font, e.g. Field.  The reason is that 
Field is not an ESMF derived type or code fragment and writing 
the full type, e.g. <TT>ESMF_Field</TT>, everywhere makes long 
explanations less readable.

<P>
</LI>
<LI>Verbs like halo and regrid shall not be capitalized since they 
are not public classes. The exception is when such a verb is also a
private class, and it is written about in that context.  For example, 
when writing about Regrid as a private class in a <I>Design and 
Implementation Notes</I> section it is appropriate to capitalize it.

<P>
</LI>
<LI>Full class names shall be used everywhere (e.g., Layout will
not be used as a shorthand for DELayout).

<P>
</LI>
</OL>

<P>

<H3><A NAME="SECTION00084200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples Sections</A>
</H3>

<P>
A standard template for examples has not yet been created.

<P>

<H3><A NAME="SECTION00084300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> Flags and Options Sections</A>
</H3>

<P>

<OL>
<LI>All flags and options (hereafter referred to as options) 
shall be broken out into separate sections called <I>&lt;Class&gt; Options</I>.  
Options shall each have their own derived type, 
e.g. <TT>ESMF_Sync_Flag</TT>, and valid values will be all capitals
with underscore separators, e.g. <TT>ESMF_SYNC_NONBLOCKING</TT>.

<P>
</LI>
<LI>When possible, call options &lt;Class&gt;Type or &lt;Something&gt;Flag and
name the argument in the argument list the same thing.  For example,
the option <TT>ESMF_Sync_Flag</TT> has associated arguments 
called <TT>syncflag</TT>.

<P>
</LI>
<LI>The purpose of options shall be fully described along with all 
valid values in the options sections of the document.  See the
standard format in <I>Calendar Options</I> or <I>Grid Options</I>.

<P>
</LI>
<LI>In the sections describing the usage and values for options, 
only use the full class name, e.g. <TT>ESMF_Field</TT>, method names such
as <TT>ESMF_FieldWrite</TT>, or particular argument names, such as <TT>syncflag</TT>. Do not use the more informal form of the short class
name in a regular font, e.g. Field.  The rationale is that here we 
are carefully specifying interface behavior and are referring only 
to particular ESMF types, values, and methods.  It is a pain in 
the neck to be that rigorous in the longer text sections 
(like <I>Description</I>), but it is helpful to be precise for the 
API specification.
</LI>
</OL>

<P>

<H3><A NAME="SECTION00084400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API Sections</A>
</H3>

<P>

<OL>
<LI>Public class methods shall be capitalized by name within a file.
Generally private methods are listed at the end of the file.  Especially 
for classes with many methods, this makes locating a particular method 
somewhat easier.

<P>
</LI>
<LI>All public methods shall be fully documented in the <I>Reference
Manual</I>.  Private methods without interfaces shall not appear at all.
Private methods that are overloaded with public interface shall follow
a standard format that clearly indicates that the methods are overloaded;
see <TT>ESMF_FieldCreate()</TT> for an example.

<P>
</LI>
<LI>The <I>Reference Manual</I> shall include for each class a thorough
specification of behavior, including any default values or behaviors.
Description of options can reference <I>&lt;Class&gt; Options</I> sections.
All descriptions should contain complete sentences with periods,
e.g. "This method sets invalid values for an <TT>ESMF_FieldBundle</TT> object."

<P>
</LI>
<LI>The brief one-line description that follows the method name shall
begin with a capital and have no period at the end.

<P>
</LI>
<LI>All methods shall conform to method naming conventions.

<P>
</LI>
<LI>Functions shall have their data type and return variable name declared
on a separate line after the <TT>function</TT> statement, and prior to the
argument list declarations.  The data type shall not appear in the
<TT>function</TT> statement.  The optional <TT>result</TT> clause should also
not be used.

<P>
</LI>
<LI>All arguments shall conform to variable naming conventions
for capitalization and standard use of terms such as count, dim, etc.
The conventions shall be used even if names become fairly long.
All class names will be used in full, e.g. DELayout will not be
used instead of DELayout.  Cryptic abbreviations like <TT>btype</TT> 
shall not be used - use <TT>bundleType</TT> instead.

<P>
</LI>
<LI>As with descriptions of flags and options:  in the sections describing
methods, only use the full class name, e.g. <TT>ESMF_Field</TT>, method names such
as <TT>ESMF_FieldWrite</TT>, or particular argument names, such as <TT>syncflag</TT>. Do not use the more informal short form in regular 
font, e.g. Field.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION00085000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> Code: Method Conventions</A>
</H2>

<P>

<H3><A NAME="SECTION00085100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Standard Method Names</A>
</H3>

<P>
ESMF defines a set of standard methods and interface rules that
hold across the entire API.  These are: 

<P>

<UL>
<LI><TT>ESMF/C_&lt;Class&gt;Create()</TT> and <TT>ESMF_&lt;Class&gt;Destroy()</TT>, for creating and 
destroying classes.  The <TT>ESMF_&lt;Class&gt;Create()</TT> method allocates 
memory for the class structure itself and for internal variables, and
initializes variables as appropriate.  It is always written as a 
Fortran function that returns a derived type instance of the class.

<P>
</LI>
<LI><TT>ESMF/C_&lt;Class&gt;Set()</TT> and <TT>ESMF_&lt;Class&gt;Get()</TT>, for setting 
and retrieving a particular item or flag.  In general, these methods are
overloaded for all cases where the item can be manipulated as a
name/value pair.  If identifying the item requires more than a 
name, or if the class is of sufficient complexity that overloading
in this way would result in an overwhelming number of options, we 
define specific <TT>ESMF_&lt;Class&gt;Set&lt;Something&gt;</TT> and 
<TT>ESMF_&lt;Class&gt;Get&lt;Something&gt;</TT> interfaces.

<P>
</LI>
<LI><TT>ESMF/C_&lt;Class&gt;Add()</TT>, <TT>ESMF_&lt;Class&gt;Get()</TT>, and 
<TT>ESMF_&lt;Class&gt;Remove()</TT> for manipulating 
items that can be appended or inserted into a list of like
items within a class.  For example, the <TT>ESMF_StateAdd()</TT>
method adds another Field to the list of Fields contained
in the State class.

<P>
</LI>
<LI><TT>ESMF/C_&lt;Class&gt;Print()</TT>, for printing the contents of a class to 
standard out.  This method is mainly intended for debugging.

<P>
</LI>
<LI><TT>ESMF/C_&lt;Class&gt;ReadRestart()</TT> and <TT>ESMF_&lt;Class&gt;WriteRestart</TT>, 
for saving the contents of a class and restoring it exactly.  Read
and write restart methods have not yet been implemented for most
ESMF classes, so where necessary the user needs to write restart 
values themselves.

<P>
</LI>
<LI><TT>ESMF/C_&lt;Class&gt;Validate()</TT>, for determining whether a class is 
internally consistent.  For example, <TT>ESMF_FieldValidate</TT> checks 
whether the Array and Grid associated with a Field are consistent.

<P>
</LI>
<LI><TT>ESM[F/C]_&lt;Class&gt;Construct()</TT> and <TT>ESM[F/C]_&lt;Class&gt;Destruct()</TT>,
for initializing a previously allocated object with valid data.  This 
function is called by the create function.  Depending on the type of 
object this function may or may not allocate resources that need to be freed.  
Only for ESMF internal usage; not visible to users.

<P>
</LI>
</UL>

<P>

<H3><A NAME="SECTION00085200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use of *Set and *Get</A>
</H3> In general, Set and Get calls with optional arguments
for each possible attribute to be processed shall be used instead of individual
Set and Get calls.  The goals are a smaller, clearer interface and easier extensibility.
An exception is when the Set or Get does not translate to a simple name/value pair,
for instance when one element of an array of internal attributes must be retrieved.

<P>

<H3><A NAME="SECTION00085300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use of Is* and Has*</A>
</H3> Methods names that indicate the 
presence of some attribute or quality shall use the Has* form.  Methods 
that indicate a condition shall use the Is* form; for example, 
<TT>ESMF_DELayoutIsLocal</TT>.  In Fortran, these should return <TT>logical</TT>
data type results.  The goals are consistency and clarity.

<P>

<H3><A NAME="SECTION00085400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> Functions vs. Subroutines</A>
</H3>
Most Fortran calls in the ESMF are subroutines, with 
any returned values passed through the interface.  For the sake of 
convenience, some ESMF calls are written as functions.

<P>

<H3><A NAME="SECTION00085500000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> Source and Destination Ordering</A>
</H3>
In ESMF we shall follow a source first, then destination convention when ordering
arguments.

<P>

<H2><A NAME="SECTION00086000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> Code: Argument Conventions</A>
</H2>

<P>
The naming conventions listed here apply to arguments that appear in 
ESMF public interfaces.  It is nice if internal arguments also adhere
to these conventions, but not enforced as it is as the interface.

<P>

<H3><A NAME="SECTION00086100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Standard Variable Names</A>
</H3>

<P>
The following table lists a set of standard terms that we use in ESMF.

<P>
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><TT>Cell</TT></TD>
<TD ALIGN="LEFT">grid cell</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Coord</TT></TD>
<TD ALIGN="LEFT">coordinate</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Count</TT></TD>
<TD ALIGN="LEFT">count</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Dim</TT></TD>
<TD ALIGN="LEFT">dimension, used for grids</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Dst</TT></TD>
<TD ALIGN="LEFT">destination</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>List</TT></TD>
<TD ALIGN="LEFT">indicates that the quantity is an array</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Local</TT></TD>
<TD ALIGN="LEFT">indicates that the quantity is associated with a PET or DE</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Per</TT></TD>
<TD ALIGN="LEFT">per item</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Rank</TT></TD>
<TD ALIGN="LEFT">data array dimension</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Send</TT></TD>
<TD ALIGN="LEFT">send</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Src</TT></TD>
<TD ALIGN="LEFT">source</TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>Recv</TT></TD>
<TD ALIGN="LEFT">receive</TD>
</TR>
</TABLE>

<P>
These are used in combination to create argument and variable names.  
For example, <TT>localCellCountPerDimList</TT> is an array of counts, per 
dimension, of the number of local grid cells.

<P>

<H3><A NAME="SECTION00086200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use of Is* and Has*</A>
</H3> Variable names that indicate the 
presence of some attribute or quality shall use the Has* form; e.g., a 
variable such as <TT>hasGrid</TT>.  Variables that indicate a condition shall 
use the Is* form.  In Fortran, these should return <TT>logical</TT>
data type results.  The goals are consistency and clarity.

<P>

<H3><A NAME="SECTION00086300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> Variable Capitalization</A>
</H3> 
For method arguments that are multi-word, the first word is lower
case and subsequent words begin with upper case.  ESMF class 
names (including typed flags) are an exception.  When multi-word 
class names appear in argument lists, all letters after the first 
are lower case.  The first letter is lower case if the class is the
first word in the argument and upper case otherwise.  For 
example, in an argument list the DELayout class name may appear 
as <TT>delayout</TT> or <TT>srcDelayout</TT>.

<P>

<H3><A NAME="SECTION00086400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> Variables Associated with Options</A>
</H3>
Variables associated with flags or option shall have the same name as
the option (as long as it is not too awkward); for example, an option 
<TT>ESMF_Sync_Flag</TT> has an associated argument <TT>syncflag</TT>.

<P>

<H3><A NAME="SECTION00086500000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> Variables Having Logical Data Type</A>
</H3>
Variables associated with flags or other boolean values shall use
the Fortran <TT>logical</TT> data type in the public ESMF API.  The <TT>ESMF_Logical</TT>
derived type shall only be used in Fortran code internally, for example when passing
logical values between Fortran and C++ code.

<P>

<H3><A NAME="SECTION00086600000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> Arguments which are Arrays</A>
</H3>
Arguments which are arrays shall use the Fortran assumed-shape passing style.
This allows the procedure to use intrinsic functions such as <TT>size</TT>,
<TT>lbound</TT>, and <TT>ubound</TT> within the method to determine array
dimension sizes.  Also, ESMF convention is to place the array specification
following the variable name, rather than by using the <TT>dimension</TT>
attribute or a separate <TT>dimension</TT> statement.  For example:
<PRE>
    type(ESMF_Field), intent(in) :: fieldList(:)
</PRE>

<P>

<H3><A NAME="SECTION00086700000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> Arguments which are Pointers</A>
</H3>
Arguments which are pointers may point to either scalar or array targets.
Pointers are typically used when an object must be allocated within the method
and returned to the caller.  A second use is when the original array bounds
must be maintained.  No <TT>intent</TT> attributes are currently used with
pointers because they are not part of Fortran-90 or Fortran-95.

<P>

<H2><A NAME="SECTION00087000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> Code: File Rules</A>
</H2> 

<P>

<H3><A NAME="SECTION00087100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Version Identification</A>
</H3> 
The first line of every file in ESMF
  must be its CVS version identification. For example, each <SPAN CLASS="logo,LaTeX">L<SUP><SMALL>A</SMALL></SUP>T<SMALL>E</SMALL>X</SPAN> 
  file must begin:
<PRE>
% $Id$ 
</PRE>

<P>
In addition, for source code, the CVS identifier must have the 
ability to be written to a variable for output to a configuration log.  
Therefore each F90 module must contain a declaration:
<PRE>
character(len=80), private :: version = '$Id$'
</PRE>

<P>

<H3><A NAME="SECTION00087200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> License and Copyright Information</A>
</H3>

<P>
Source and documentation files must contain the ESMF license and 
copyright header:

<P>
<PRE>
! Earth System Modeling Framework
! Copyright 2002-2020, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
</PRE>

<P>

<H3><A NAME="SECTION00087300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> TODO: Reminder</A>
</H3> 
To identify code sections that need
additional work or other pending activity that must be done before a release,
the code will be marked with a <TT>TODO</TT> identifier. 
<PRE>
example:
! TODO: add support for other data types (CMD 4/01).
</PRE>
This will allow developers to 'grep' source files before software releases. 

<P>

<H3><A NAME="SECTION00087400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> FILENAME Macros</A>
</H3>
Source code files should define the /tt ESMF_FILENAME or /tt ESMC_FILENAME
macros to ensure that the filename is correctly displayed from the ESMF logging.
This can be done using the following code:

<P>
<PRE>
#define ESMC_FILENAME "./src/Infrastructure/Attribute/src/ESMCI_Attribute.C"
</PRE>

<P>
with the appropriate filename.  Note that the path is relative to the ESMF
root directory.

<P>

<H2><A NAME="SECTION00088000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> Code: Style Rules for Source Code</A>
</H2>

<P>
General style recommendations for source code include the following:

<P>

<OL>
<LI>Limiting the text width to 80 characters;
</LI>
<LI>Each class implementation will be in a single file;
</LI>
<LI>The use of proper indentation of loops and blocks;
</LI>
<LI>The liberal use of blank lines to delimit code blocks;
</LI>
<LI>The use of comment lines of dashes or dots to delimit
  procedures;
</LI>
<LI>The use of useful descriptive names for physically meaningful
  variables; short conventional names for iterators (e.g
  <TT>(i,j,k)</TT> for spatial grid indices);
</LI>
<LI>The use of short comments on the same line to identify variables
  (i.e using <TT>!</TT> or <TT>//</TT>); longer comments in
  well-delineated blocks to describe what a portion of code is doing;
</LI>
<LI>Compact code units: long procedures should be split up if
  possible. 200 lines is a rule-of-thumb procedure length limit.
</LI>
<LI>Use of global variables or public class variables should be
kept to a minimum to increase encapsulation and ensure modular code.
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION00089000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN> Code: Error Handling Conventions</A>
</H2>

<P>

<H3><A NAME="SECTION00089100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">1</SPAN> Objectives</A>
</H3>

<P>
The objectives of these conventions are:

<P>

<OL>
<LI>to produce appropriate error messages when users try to call a method or branch in the ESMF software that is incomplete;
</LI>
<LI>to produce appropriate error messages for methods that have been implemented and reviewed, and to identify these methods clearly in the ESMF source code;
</LI>
<LI>to create defaults that enable developers to generate appropriate error messages throughout the development process, with a minimum of effort;
</LI>
<LI>to flexibly move between a mode where incomplete code is treated as an error (the user perspective) to a mode where it is not (the developer perspective, when using stubs for code construction).
</LI>
</OL>

<P>

<H3><A NAME="SECTION00089200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">2</SPAN> Approach</A>
</H3>

<P>
ESMF methods are classified into two categories: pre-review, and post-review. As of the version 3.0.1 release, *all* methods are pre-review.

<P>
Reviews are expected to begin once conventions for framework behavior are sufficiently well-defined. To pass review, methods must have their basic functionality fully implemented. If any unimplemented options are present, they must be documented and must generate appropriate errors in order for the method to pass review.

<P>
A pre-review method has its return code (<TT>rc</TT>) initialized to the value <TT>ESMF_RC_NOT_IMPL</TT> (not implemented). Possible sources of specific errors within the method, such as subroutine calls, generate local return codes (<TT>localrc</TT>).

<P>
The <TT>localrc</TT> values are evaluated using the function <TT>ESMF_LogMsgFoundError()</TT>, which takes both the <TT>localrc</TT> and the <TT>rc</TT> as input arguments. If the <TT>localrc</TT> does not indicate an error, <TT>rc</TT> is output from <TT>ESMF_LogMsgFoundError()</TT> with the value it had going into the call, and the value of the function is <TT>.false.</TT>. If <TT>localrc</TT> does indicate an error, <TT>rc</TT> is set to the <TT>localrc</TT> value before being output from <TT>ESMF_LogMsgFoundError()</TT>, and the value of the function is <TT>.true.</TT>.

<P>
The convention is to place <TT>ESMF_LogMsgFoundError()</TT> into a conditional statement that causes a return from the method, with the correctly set <TT>rc</TT>, when an error is found in <TT>localrc</TT>, e.g.:
<PRE>
if (ESMF_LogFoundError(localrc, &lt;other args ...&gt;, rc)) return
</PRE>
Use of the <TT>ESMF_LogMsgFoundError()</TT> function is further described in the ESMF Reference Manual.

<P>
Note that if no error is found, <TT>rc</TT> retains its <TT>ESMF_RC_NOT_IMPL</TT> status throughout the method. The developer must explicitly set the <TT>rc</TT> to <TT>ESMF_SUCCESS</TT> just before returning from any branch that is believed to be successful.

<P>
The default <TT>rc</TT> value thus becomes <TT>ESMF_RC_NOT_IMPL</TT> for any code that is not explicitly marked as reaching success by the developer. Stub methods and incomplete branches can be handled very naturally this way - the developer simply does not set <TT>rc=ESMF_SUCCESS</TT> before returning. There are two differences in the treatment of pre-review and post-review methods:

<OL>
<LI>Post-review methods have their <TT>rc</TT> initialized to the <TT>ESMF_RC_NOT_SET</TT> value. The rationale is that methods that are supposed to be implemented should not default to an error code that says that they are unimplemented. The difference in initialization also indicates a particular method's review status to someone browsing the source code.

<P>
</LI>
<LI>Any unimplemented or incomplete branch must have its <TT>rc</TT> value explicitly set by the developer to <TT>ESMF_RC_NOT_IMPL</TT> before returning. This is to ensure that the behavior of the method is communicated as accurately as possible to the user via its return codes.

<P>
</LI>
</OL>

<P>
These conventions achieve the first three objectives above, namely producing appropriate error messages throughout a method's life cycle, with minimal developer effort.

<P>

<H3><A NAME="SECTION00089300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">3</SPAN> Error Masking</A>
</H3>

<P>
Under normal use - what a user will encounter by default - <TT>ESMF_RC_NOT_IMPL</TT> is treated as an error. However, through a special LogErr setting a developer who wishes to use stub methods and prototyping during code construction can equate <TT>ESMF_RC_NOT_IMPL</TT> with <TT>ESMF_SUCCESS</TT>. This achieves the fourth objective above, allowing for different user and developer modes of handling incomplete code. This is done by setting the errorMask argument in the <TT>ESMF_LogSet()</TT> call to <TT>ESMF_RC_NOT_IMPL</TT>, e.g.:

<P>
<PRE>
call ESMF_LogSet(errorMask = /ESMF_RC_NOT_IMPL/)
</PRE>

<P>

<H3><A NAME="SECTION00089400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">4</SPAN> Example (pre-review method)</A>
</H3>

<P>
The following is an example of a pre-review method, <TT>sub()</TT>, that calls two subroutines internally, <TT>subsub1()</TT> and <TT>subsub2()</TT>. The subroutine <TT>sub()</TT> takes as input an integer argument that it can branch on and outputs a return code. Here <TT>branch==1</TT> is fully implemented, <TT>branch==2</TT> is incomplete, and other values of branch are not yet addressed. Several possible error scenarios are described following the code listing.

<P>
<PRE>
subroutine sub(branch, rc)
integer :: branch
integer, optional :: rc
integer :: localrc   ! local return code

if (present(rc)) rc=ESMF_RC_NOT_IMPL
! ...code...
if (branch==1) then
call subsub1(localrc)
if (ESMF_LogFoundError(localrc, &amp;
  ESMF_ERR_PASSTHRU, &amp;
  ESMF_CONTEXT, rc=rc)) then
  !   ... any necessary garbage collection ...
  return ! Return point 1
endif !   ...fully implemented code...
if (present(rc)) rc=ESMF_SUCCESS
elseif (branch==2) then call subsub2(localrc)
if (ESMF_LogFoundError(localrc, &amp;
  ESMF_ERR_PASSTHRU, &amp;
  ESMF_CONTEXT, rc=rc)) then
  !   ... any necessary garbage collection ...
  return ! Return point 2
endif
!   ...incomplete code...
end if

end subroutine
</PRE>

<P>
Note: This example is quite artificial, since simple branching like this would be better handled with a switch case statement that had a well-defined default. However, the control sequence shown better illustrates the sorts of errors that can occur in a real code with complex conditionals.

<P>
<B>Possible scenarios:</B>

<OL>
<LI><TT>branch==1</TT> and there is no error in <TT>subsub1()</TT>. In this case, <TT>rc</TT> retains the value of <TT>ESMF_RC_NOT_IMPL</TT> up to the point at which it is set to <TT>ESMF_SUCCESS</TT>, after which <TT>sub()</TT> ends.

<P>
</LI>
<LI><TT>branch==1</TT> and there is an error in <TT>subsub1()</TT>. The <TT>localrc</TT> returned by <TT>subsub1()</TT> will have the value of a specific error code, say <TT>ESMF_RC_DIV_ZERO</TT>. This will get passed into the evaluation <TT>ESMF_LogMsgFoundErr()</TT>, which will set <TT>rc</TT> to the <TT>localrc</TT> error value. Since the value of the evaluation expression is true, the method will return at Return point 1. It is important to perform any necessary garbage collection before returning to avoid memory leaks.

<P>
</LI>
<LI><TT>branch==2</TT> and there is no error in <TT>subsub2()</TT>. Here the value of <TT>rc</TT> is still <TT>ESMF_RC_NOT_IMPL</TT> when it is input into the <TT>ESMF_LogMsgFoundErr()</TT> call following <TT>subsub2()</TT>. Since the code in this branch is not complete and <TT>rc</TT> is never set to <TT>ESMF_SUCCESS</TT>, the <TT>rc</TT> value is still <TT>ESMF_RC_NOT_IMPL</TT> at the end of <TT>sub()</TT>. Note that to allow the default to work properly, <TT>rc</TT> should not be set to <TT>ESMF_SUCCESS</TT> right before the end of the method!

<P>
</LI>
<LI><TT>branch==2</TT> and there is an error in <TT>subsub2()</TT>. Much like scenario 2, the <TT>localrc</TT> returned by <TT>subsub2()</TT> will have the value of a specific error code. The <TT>localrc</TT> will get passed into <TT>ESMF_LogMsgFoundErr()</TT>, which will set <TT>rc</TT> to the <TT>localrc</TT> error value, and then cause a return at Return point 2.

<P>
</LI>
<LI>any value where branch <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img93.png"
 ALT="$/=1$"></SPAN> and branch <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img94.png"
 ALT="$/= 2$"></SPAN> (e.g. <TT>branch==0</TT>). Here there is a &ldquo;hole&rdquo; in the code, since the behavior of <TT>branch==0</TT> is not yet addressed. However, with this approach the <TT>rc</TT> value remains <TT>ESMF_RC_NOT_IMPL</TT> when <TT>sub()</TT> ends, producing an appropriate error message for the user.

<P>
</LI>
</OL>
<H3><A NAME="SECTION00089500000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">5</SPAN> Example (post-review method)</A>
</H3>

<P>
This example is modeled on the pre-review example, but illustrates error handling for a post-review method. Here <TT>branch==1</TT> is fully implemented, <TT>branch==2</TT> is known to be incomplete, and other values of branch are cases that the developer and reviewers have missed. This is not what one would wish to see in reviewed code - ideally all cases should be implemented - but we cannot count on this. This example shows how deficiencies can most effectively be handled.

<P>
The return code <TT>rc</TT> is now initialized to <TT>ESMF_RC_NOT_SET</TT>. The developer has recognized that the <TT>branch==2</TT> code is incomplete and <TT>rc</TT> is set explicitly to <TT>ESMF_RC_NOT_IMPL</TT> before returning.

<P>
<PRE>
subroutine sub(branch, rc)
integer :: branch
integer, optional :: rc
integer :: localrc   ! local return code

if (present(rc)) rc=ESMF_RC_NOT_SET
! ...code...
if (branch==1) then
call subsub1(localrc)
if (ESMF_LogFoundError(localrc, &amp;
  ESMF_ERR_PASSTHRU, &amp;
  ESMF_CONTEXT, rc=rc)) then
  !   ... any necessary garbage collection ...      return ! Return point 1
endif
!   ...fully implemented code...
if (present(rc)) rc=ESMF_SUCCESS
elseif (branch==2) then call subsub2(localrc)
if (ESMF_LogFoundError(localrc, &amp;
  ESMF_ERR_PASSTHRU, &amp;
  ESMF_CONTEXT, rc=rc)) then
  !   ... any necessary garbage collection ...
  return ! Return point 2
endif
!   ...incomplete code...
if (present(rc)) rc=ESMF_RC_NOT_IMPL       end if
end subroutine
{
</PRE>

<P>
<B>Possible scenarios:</B>

<P>
<TT>branch==1</TT>. Here the behavior is essentially the same as in scenarios 1 and 2. When there is an error in <TT>subsub1()</TT>, the returned <TT>rc</TT> from <TT>sub()</TT> has the error code <TT>subsub1()</TT> generated. When there is not an error in <TT>subsub1()</TT>, the returned <TT>rc</TT> from <TT>sub()</TT> is <TT>ESMF_SUCCESS</TT>.

<P>
<TT>branch==2</TT> and there is an error in <TT>subsub2()</TT>. The behavior here is analogous to scenario 3. The returned <TT>rc</TT> from <TT>sub()</TT> has the error code <TT>subsub2()</TT> generated.

<P>
<TT>branch==2</TT> and there is no error in <TT>subsub2()</TT>. The value of <TT>rc</TT> remains <TT>ESMF_RC_NOT_SET</TT> up to the point at which it is explicitly set to <TT>ESMF_RC_NOT_IMPL</TT>, and <TT>sub()</TT> ends. Method documentation is expected to explain the gap in functionality.

<P>
any value where branch <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img93.png"
 ALT="$/=1$"></SPAN> and branch <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img94.png"
 ALT="$/= 2$"></SPAN> (e.g. <TT>branch==0</TT>). Here <TT>rc</TT> is not explicitly set to a value before the branch returns, and so <TT>sub()</TT> returns with the default <TT>rc</TT> value of <TT>ESMF_RC_NOT_SET</TT>. The user can tell from this error code that the developer did not consider this either unimplemented code or successful code, and that there is an unexpected &ldquo;hole&rdquo; in the method's functionality. 

<P>

<P>

<H3><A NAME="SECTION00089600000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">6</SPAN> Memory Allocation Checking</A>
</H3>

<P>
In Fortran code, the <TT>allocate</TT> and <TT>deallocate</TT> statements should
always have their success or failure checked by using <TT>stat=</TT> and checking
the value it returns.  Since this value is defined by the Fortran
standard, and is not an ESMF return code, the alternative checking calls are
<TT>ESMF_LogFoundAllocError()</TT> and <TT>ESMF_LogFoundDeAllocError()</TT>.
To further distinguish the difference between a Fortran status return
and a ESMF return code, the local error variable should be named &ldquo;memstat&rdquo;
rather than &ldquo;localrc&rdquo;.

<P>
<PRE>
  real, allocatable :: big_array(:,:)
  integer :: memstat
  ! ...
  allocate (big_array(m,n), stat=memstat)
  if (ESMF_LogFoundAllocError(memstat, &amp;
    ESMF_ERR_PASSTHRU, &amp;
    ESMF_CONTEXT, rc=rc)) then
    ! ... any necessary clean up
    return
  end if
  ! ... use big_array for a while
  deallocate (big_array, stat=memstat)
  if (ESMF_LogFoundDeAllocError(memstat, &amp;
    ESMF_ERR_PASSTHRU, &amp;
    ESMF_CONTEXT, rc=rc)) then
    ! ... any necessary clean up
    return
  end if
</PRE>

<P>
In C++ code, where the <TT>new</TT> operator is used, allocation errors can
be caught by wrapping the allocation code inside a <TT>try</TT> block to catch
any exceptions.  Multiple allocations may be wrapped inside a single block
in order to reduce the amount of checking code.

<P>
<PRE>
#include "ESMCI.h"
//...
void alloc_func (int m, int n, int *rc) {
#undef  ESMC_METHOD
#define ESMC_METHOD alloc_func
  double *array1, *array2;
  try {
    array1 = new double[m];
    array2 = new double[n];
  }
  catch (std::bad_alloc) {
    // ... any necessary clean up
    ESMC_LogDefault.MsgAllocError("allocating array1 and array2",
        ESMC_CONTEXT, rc);
    return;
  }
  // ... use array1 and array2 for a while
  delete array2;
  delete array1;
}
</PRE>

<P>
In code which uses <TT>malloc()</TT> and <TT>free()</TT>,
the return value from <TT>malloc()</TT> may be tested against
<TT>NULL</TT> to determine if an error occurred.  No checking is
possible with <TT>free()</TT>.  In new code, the C++ <TT>new</TT>
operator and associated checking should be used.

<P>

<P>

<H2><A NAME="SECTION000810000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN> Initialization Standardization Instructions</A>
</H2>

<P>

<H3><A NAME="SECTION000810100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Overview</A>
</H3>

<P>
Currently not all Fortran compilers support the
automatic initialization of class components. However,
in the ESMF system this initialization is used for two
tasks. The first is the initialization of shallow class
components which need to be set before they're used
(e.g. flags). The second is the detection of invalid
(e.g. not yet created) deep class variables. In order
to handle these tasks in the absence of compiler
initialization a software based solution has been
developed.

<P>
The software solution is based on the improbability of
an uninitialized variable containing a specific value. For
example, given a 64 bit integer variable x, the
probability of x containing the value 10 are approximately
1 in <SPAN CLASS="MATH"><IMG
 WIDTH="33" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img95.png"
 ALT="$10^{19}$"></SPAN>. This of course assumes that the value in
an uninitialized variable is a uniformly distributed random
variable, which is not necessarily true. However, the small probability
of a given value occurring is not an unreasonable assumption
given that the value is not pathological
(e.g. 0 or binary 111111..). The probability can
also be made as small as is necessary
by using larger precision types.

<P>
Given the improbability of a specific value occurring in an
uninitialized variable, the task of initializing a shallow
class is implemented as follows. First, a non-pathological
value, ESMF_INIT_DEFINED, is chosen. Next, an integer
component, isInit, is added to the shallow class.
Finally, for every routine taking the shallow
class as an input variable, the component isInit is checked
against ESMF_INIT_DEFINED. If they don't match, then the variable
containing isInit is initialized, including setting isInit to
ESMF_INIT_DEFINED. If they do match, then with extremely high probability
the variable has already been initialized and nothing
need be done. This algorithm helps to ensure that the shallow
class is initialized before being used in the system.

<P>
The task of detecting an invalid deep class is
implemented as follows. As before, we chose a value
ESMF_INIT_CREATED, and add the isInit component to the class
definition. Next, inside the constructors for
the class isInit is set to ESMF_INIT_CREATED, and
inside the destructors for the class isInit
is set to something other than ESMF_INIT_CREATED.
Finally, for every routine taking the deep class
as an input variable, the component isInit is
checked against ESMF_INIT_CREATED. If they match, then
nothing happens because with extremely high
probability the variable has been though the
constructor and thus is valid. If they don't match,
then the variable is invalid and an error occurs.
This allows invalid deep class variables to be detected
before being used in the system.

<P>
In order to make the process of adding these non-compiler
based initialization tasks easier, a set of macros has been defined.
The following is a description of the procedures to use them.

<P>

<H3><A NAME="SECTION000810200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">2</SPAN> Instructions</A>
</H3>

<P>
These changes should be added to all new F90 code in both the source
(/src) and interface (/interface) subdirectories of the classes.

<P>
When adding code as a part of this task remember to use
the standard ESMF coding conventions. In particular, when adding 
new routines remember to use the standard 
ESMF protex style (BOP/EOP) subroutine description, like those that
appear in every other ESMF subroutine. For Validate use 
the BOP/EOP tags for ESMF_TYPEGetInit and ESMF_TYPEInit 
use the internal BOPI/EOPI tags. 

<P>
Some F90 source files are autogenerated. In this case, modify
the macro file which is used to create the autogenerated file. 
The macro file is usually named something like ESMF_TypeMacos.h.
When modifying a macro file remember to end each line
with: @ To recognize when an F90 file is autogenerated
they usually have the line: &lt;Created by maco - do not edit directly&gt;
close to the beginning. There will also usually be a .cpp
file with the same name as the .F90 file.

<P>
For the purposes of initialization standardization the 
classes in the system have been divided into three types: shallow, deep,
and parameter. Shallow classes have little if any allocation and
can often be used right after declaration. An example of a shallow
class is ESMF_ArraySpec.  Deep classes on the other hand  have a lot of
allocated data and need to be constructed before being used. An example of
a deep class is ESMF_State. Parameter classes are 
those which are used to add type checking to a set of parameter values.
This type of class is typically just a single integer wrapped in a Fortran type.
An example of a parameter class is ESMF_GridType. Both shallow and
deep classes are effected by the standardization, but parameter classes
are left unchanged. See section&nbsp;<A HREF="#is:typelist">7.10.8</A> for a list of
ESMF classes and their classification. 

<P>
The instructions for the standardization have been broken 
up by what to do for each module, what to do for each type of class, 
and what to do for routines.

<P>

<H3><A NAME="SECTION000810300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">3</SPAN> Module</A>
</H3>

<P>
When adding a new F90 module do the following:

<P>

<OL>
<LI>If the following line is not present in the use statement list, then add 
it (except in ESMF_LogErr.F90 and ESMF_UtilTypes.F90):
<PRE>
    use ESMF_InitMacrosMod
</PRE>

<P>
</LI>
<LI>If the following line is not present in the include statement list, then add it (except in ESMF_LogErr.F90):
<PRE>
    #include "ESMF.h"
</PRE>
</LI>
</OL>

<P>

<H3><A NAME="SECTION000810400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">4</SPAN> Shallow Class</A>
</H3>

<P>
When adding a new shallow class definition perform the following steps:

<P>

<OL>
<LI>If the line:
<PRE>
    use ESMF_UtilTypesMod
</PRE>
  isn't in the list of used modules, then add it.  

<P>
</LI>
<LI>Add the line ESMF_INIT_DECLARE to the type definition.
</LI>
<LI>Be sure the #ifndef ESMF_NO_INITIALIZERS construct is
    used around any initialization of type components. 
    The declarations inside the #else to #endif half of the construct
    should be identical to the #ifndef half except without initialization.
</LI>
<LI>Create an initialization subroutine for the class.
    Given that the name of the class is ESMF_STYPE,
    the name of the subroutine should be ESMF_STYPEInit().
    This subroutine should take a single parameter of class
    ESMF_STYPE and set all the variables that are
    initialized in the #ifndef ESMF_NO_INITIALIZERS branch
    of 3. Note, for pointers that are set using ptr-&gt;Null()
    in the type initialization, use nullify(t%ptr) in the 
    ESMF_STYPEInit subroutine instead. 
</LI>
<LI>Add the line ESMF_INIT_SET_DEFINED(S1) to the body of
    the new subroutine ESMF_STYPEInit() described in 4.
     S1 is the variable being initialized in ESMF_STYPEInit().
</LI>
<LI>Create an access subroutine for the new init component.
    The name of the subroutine should be ESMF_STYPEGetInit.
    It should have the following form:

<P>
<PRE>
    function ESMF_STYPEGetInit(s)
       type(ESMF_STYPE), intent(in), optional :: s
       ESMF_INIT_TYPE :: ESMF_STYPEGetInit

      if (present(s)) then
          ESMF_STYPEGetInit=ESMF_INIT_GET(s)
      else
          ESMF_STYPEGetInit=ESMF_INIT_DEFINED
      endif

    end function ESMF_STYPEGetInit
</PRE>

<P>
</LI>
<LI>Create an ESMF_STYPEValidate subroutine with the following form:

<P>
<PRE>
    ! Comments describing validate (see ESMF_StateValidate for an example)
    subroutine ESMF_STYPEValidate(s,rc)
       type(ESMF_STYPE), intent(inout) :: s
       integer, intent(out),optional :: rc

       ! check initialization status
       ESMF_INIT_CHECK_SET_SHALLOW(ESMF_STYPEGetInit,ESMF_STYPEInit,s)
       
       ! return success
       if (present(rc)) then
          rc=ESMF_SUCCESS
       endif

    end subroutine ESMF_STYPEValidate
</PRE>

<P>
</LI>
<LI>If the shallow class in question is public, then
    add the lines:
<PRE>
       public ESMF_STYPEInit
       public ESMF_STYPEGetInit
       public ESMF_STYPEValidate
</PRE>
    to the PUBLIC MEMBER FUNCTION section. 

<P>
</LI>
<LI>Add the new class to the list in section&nbsp;<A HREF="#is:typelist">7.10.8</A>.

<P>
</LI>
</OL>

<P>
Here is an example illustrating the whole procedure: 
<BR>
<P>
Starting with this shallow class definition:

<P>
<PRE>
   module ESMF_ExampleMod

       type ESMF_Shallow
           private
            ... other components ...
#ifndef ESMF_NO_INITIALIZERS
            integer :: num=0
            integer, pointer :: list(:) =&gt; Null()
#else
            integer :: num
            integer, pointer :: list(:)
#endif
       end type

! !PUBLIC TYPES:
      public ESMF_Shallow 
     
! !PUBLIC MEMBER FUNCTIONS:

       contains

       ... other routines ...

   end module ESMF_ExampleMod
</PRE>

<P>
The standardization procedure yields this:
<BR>(modified lines marked with *)

<P>
<PRE>
   module ESMF_ExampleMod
*       use ESMF_UtilTypesMod 
*       use ESMF_InitMacrosMod 

       type ESMF_Shallow
            private
            ... other components ...
#ifndef ESMF_NO_INITIALIZERS
            integer :: num=0
            integer, pointer :: list(:) =&gt; Null()
#else
            integer :: num
            integer, pointer :: list(:)
#endif
*            ESMF_INIT_DECLARE
       end type

! !PUBLIC TYPES:
      public ESMF_Shallow 

! !PUBLIC MEMBER FUNCTIONS:
*      public ESMF_ShallowInit
*      public ESMF_ShallowValidate
*      public ESMF_ShallowGetInit

       contains

*    function ESMF_ShallowGetInit(s)
*       type(ESMF_Shallow), intent(in), optional :: s
*       ESMF_INIT_TYPE :: ESMF_ShallowGetInit
*
*      if (present(s)) then
*          ESMF_ShallowGetInit=ESMF_INIT_GET(s)
*      else
*          ESMF_ShallowGetInit=ESMF_INIT_DEFINED
*      endif
*
*    end function ESMF_ShallowGetInit
*
*    subroutine ESMF_ShallowInit(s)
*       type(ESMF_Shallow) :: s
*    
*        s%num=0 
*        nullify(s%list)
*
*        ESMF_INIT_SET_DEFINED(s) 
*    end subroutine ESMF_ShallowInit
*
*    subroutine ESMF_ShallowValidate(s,rc)
*       type(ESMF_Shallow), intent(inout) :: s
*       integer, intent(out),optional :: rc
*
*       ! check initialization status
*       ESMF_INIT_CHECK_SET_SHALLOW(ESMF_ShallowGetInit,ESMF_ShallowInit,s)
*       
*       ! return success
*       if (present(rc)) then
*          rc=ESMF_SUCCESS
*       endif
*
*    end subroutine ESMF_ShallowValidate

       ... other routines ...

   end module ESMF_Shallow
</PRE>

<P>

<H3><A NAME="SECTION000810500000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">5</SPAN> Deep Class</A>
</H3>

<P>
When adding a new deep class definition perform the following steps:

<P>

<OL>
<LI>If the line:
<PRE>
      use ESMF_UtilTypesMod
</PRE> 
    isn't in the list of used modules, then add it.  
</LI>
<LI>Add the line ESMF_INIT_DECLARE to the type definition.
</LI>
<LI>Add the line ESMF_INIT_SET_CREATED(D1) to the
      TypeCreate() function. D1 is the deep class variable
      being created.
</LI>
<LI>Add the line ESMF_INIT_SET_DELETED(D1) to the
      TypeDestroy() subroutine. D1 is the deep class
      variable being destroyed.
</LI>
<LI>Create an access subroutine for the new init component.
    The name of the subroutine should be ESMF_DTYPEGetInit.
    It should have the following form:
<PRE>
    function ESMF_DTYPEGetInit(d)
       type(ESMF_DTYPE), intent(in),optional :: d
       ESMF_INIT_TYPE :: ESMF_DTYPEGetInit

      if (present(d)) then
          ESMF_DTYPEGetInit=ESMF_INIT_GET(d)
      else
          ESMF_DTYPEGetInit=ESMF_INIT_CREATED
      endif

    end function ESMF_DTYPEGetInit
</PRE>

<P>
</LI>
<LI>Given that the deep class is ESMF_DTYPE create a validate subroutine
 with the following form:
<PRE>
    ! Comments describing validate (see ESMF_StateValidate for an example)
    subroutine ESMF_DTYPEValidate(d1,rc)
       type(ESMF_DTYPE), intent(in) :: d1
       integer, intent(out),optional :: rc

       ! Check Init Status
       ESMF_INIT_CHECK_DEEP(ESMF_DTYPEGetInit,d1,rc)

       ! Add other checks here

       ! If all checks passed return success
       if (present(rc)) then
           rc=ESMF_SUCCESS
       endif

    end subroutine ESMF_DTYPEValidate
</PRE>

<P>
</LI>
<LI>If the deep class in question is public, then
    add the lines:
<PRE>
       public ESMF_DTYPEGetInit
       public ESMF_DTYPEValidate
</PRE>
    to the PUBLIC MEMBER FUNCTION section.

<P>
</LI>
<LI>Some deep classes are private and occasionally it
will become necessary to access their internal components
to set the initialization flag or get the this pointer
in code which doesn't have access. The standard way
to do this in ESMF is to write a public subroutine in the 
class module where the subroutine can have access to 
the classes' internal components.

<P>
The following are the standard names for the subroutines
which set a class as created, set a class as deleted, and set the this 
pointer, and get the this pointer:
<PRE>
ESMF_DTYPESetInitCreated
ESMF_DTYPESetInitDeleted
ESMF_DTYPESetThis
ESMF_DTYPEGetThis
</PRE>

<P>
</LI>
<LI>Add the new class to the list in section&nbsp;<A HREF="#is:typelist">7.10.8</A>.

<P>
</LI>
</OL>

<P>
Here is an example illustrating the whole procedure: 
<BR>
<P>
Starting with this deep type definition:

<P>
<PRE>
   module ESMF_ExampleMod

       type ESMF_Deep
            private
            ... other components ...
       end type

! !PUBLIC TYPES:
      public ESMF_Deep

! !PUBLIC MEMBER FUNCTIONS:

       contains

        function ESMF_DeepCreate()
              type(ESMF_Deep) :: ESMF_DeepCreate

              ... other create code ...

        end function ESMF_DeepCreate

        subroutine ESMF_DeepDestroy(d)
              type(ESMF_Deep) :: d

              ... other create code ...

        end subroutine ESMF_DeepDestroy

        ... other routines ...

   end module ESMF_ExampleMod
</PRE>

<P>
The standardization procedure yields this:
<BR>(modified lines marked with *)

<P>
<PRE>
   module ESMF_ExampleMod
*       use ESMF_UtilTypesMod 
*       use ESMF_InitMacrosMod       

       type ESMF_Deep
           private
           ... other components ...
*           ESMF_INIT_DECLARE
       end type

! !PUBLIC TYPES:
      public ESMF_Deep

! !PUBLIC MEMBER FUNCTIONS:
*      public ESMF_DeepValidate     
*      public ESMF_DeepGetInit     

       contains

*    function ESMF_DeepGetInit(d)
*       type(ESMF_Deep), intent(in),optional :: d
*       ESMF_INIT_TYPE :: ESMF_DeepGetInit
*
*       if (present(d)) then
*          ESMF_DeepGetInit=ESMF_INIT_GET(d)
*      else
*          ESMF_DeepGetInit=ESMF_INIT_CREATED
*      endif
*
*    end function ESMF_DeepGetInit
*
*       subroutine ESMF_DeepValidate(d,rc)
*          type(ESMF_Deep), intent(in) :: d
*          integer, intent(out),optional :: rc
*
*          ! Check Init Status
*          ESMF_INIT_CHECK_DEEP(ESMF_DeepGetInit,d,rc)
*
*         ! Add other checks here
*
*         ! If all checks passed return success
*         if (present(rc)) then
*            rc=ESMF_SUCCESS
*         endif
*
*        end subroutine ESMF_DeepValidate

        function ESMF_DeepCreate()
              type(ESMF_Deep) :: ESMF_DeepCreate

              ... other create code ...

*              ESMF_INIT_SET_CREATED(ESMF_DeepCreate)

        end function ESMF_DeepCreate

        subroutine ESMF_DeepDestroy(d)
              type(ESMF_Deep) :: d

              ... other create code ...

*              ESMF_INIT_SET_DELETED(d)

        end subroutine ESMF_DeepDestroy

        ... other routines ...

   end module ESMF_ExampleMod
</PRE>

<P>

<H3><A NAME="SECTION000810600000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">6</SPAN> Parameter Class</A>
</H3>

<P>
When adding a new parameter class definition, don't add any initialization
standardization code. However, do add the new class to the class list in
section&nbsp;<A HREF="#is:typelist">7.10.8</A>.

<P>

<H3><A NAME="SECTION000810700000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">7</SPAN> Subroutine</A>
</H3>

<P>
When adding a new subroutine or function (both referred 
to as 'routine' henceforth) perform the following steps:

<P>

<OL>
<LI>At the beginning of the routine, for each shallow
      class parameter S1 of type ESMF_STYPE. Add the line
      ESMF_INIT_CHECK_SHALLOW(ESMF_STYPEGetInit, ESMF_STYPEInit, S1).
      In addition, if the intent of S1 is intent(in), switch it to 
      intent(inout) to allow it to be modified.  

<P>
</LI>
<LI>At the beginning of each routine, for each deep
     class *input* parameter D1 of type ESMF_DTYPE, add the line
     ESMF_INIT_CHECK_DEEP(ESMF_DTYPEGetInit, D1, rc). 
     Here rc is the return code variable
     for the routine.
</LI>
</OL>

<P>
The initialization macros in 1. and 2. should be
added before any code which uses the types being checked. 

<P>
When adding the check macros to code there are a couple of issues
to keep in mind for compatibility with all compilers. First, 
don't break up the macro across lines (e.g. using &amp;). 
Second, some compilers have a maximum line length. Occasionally, 
the Deep class check macro will expand to larger than this
length, if you find that this is occurring with a particular
line use the ESMF_INIT_CHECK_DEEP_SHORT macro instead. 
It takes exactly the same parameter list as the normal deep class
check macro, but expands to a much shorter line. 

<P>
Here is an example illustrating this procedure: 
<BR>
<P>
Starting with this routine:

<P>
<PRE>
   subroutine ESMF_EXAMPLE(s1,d1,s2,d2,d3,rc)
         type(ESMF_Shallow1), intent(in) :: s1
         type(ESMF_Shallow2), intent(out) :: s2
         type(ESMF_Deep1),intent(in) :: d1
         type(ESMF_Deep2),intent(inout) :: d2
         type(ESMF_Deep3),intent(out) :: d3
         integer :: rc
         .... local variable declarations ...

         ! initialize return code
         rc=ESMF_FAILURE

          ...... rest of subroutine code....

  end subroutine ESMF_Example
</PRE>

<P>
The standardization yields this:
<BR>(modified lines marked with *)

<P>
<PRE>
   subroutine ESMF_EXAMPLE(s1,d1,s2,d2,d3,rc)
*         type(ESMF_Shallow1), intent(inout) :: s1
         type(ESMF_Shallow2) :: s2
         type(ESMF_Deep1) :: d1
         type(ESMF_Deep2),intent(inout) :: d2
         type(ESMF_Deep3),intent(out) :: d3
         integer :: rc
         .... other local variable declarations ...

         ! initialize return code
         rc=ESMF_FAILURE

*         ! check variables
*         ESMF_INIT_CHECK_DEEP(ESMF_Deep1GetInit,d1,rc)
*         ESMF_INIT_CHECK_DEEP(ESMF_Deep2GetInit,d2,rc)
*
*         ESMF_INIT_CHECK_SET_SHALLOW(ESMF_Shallow1GetInit,ESMF_Shallow1Init,s1)
*         ESMF_INIT_CHECK_SET_SHALLOW(ESMF_Shallow2GetInit,ESMF_Shallow2Init,s2)

          ...... rest of subroutine code....

  end subroutine ESMF_Example
</PRE>

<P>

<H3><A NAME="SECTION000810800000000000000"></A><A NAME="is:typelist"></A>
<BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF Class Types
</H3>

<P>
CAUTION: The following lists are very much outdated!!!

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Class</B></TD>
<TD ALIGN="LEFT"><B>Type</B></TD>
<TD ALIGN="LEFT"><B>Fortran</B></TD>
<TD ALIGN="LEFT"><B>ESMF</B></TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Alarm</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">public</TD>
<TD ALIGN="LEFT">public</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_AlarmList_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">public</TD>
<TD ALIGN="LEFT">public</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Array</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_ArrayBundle</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_ArraySpec</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Attribute</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Base</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_BaseTime</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_CWrap</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Calendar</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_CalKind_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Clock</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_CommHandle</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_CommTable</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_CompClass</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_CompType_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Config</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_ConfigAttrUsed</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Context_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_CoordOrder</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_CplComp</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_DELayout</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_DataHolder</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_DataValue</TD>
<TD ALIGN="LEFT">Ignore</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Decomp_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Direction_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_DistGrid</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Field</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_FieldBundle</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_FieldBundleDataMap</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_FieldBundleType</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_FieldDataMap</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_FieldType</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Fraction</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Grid</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_GridComp</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_GridStatus_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Index_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_InterfaceInt</TD>
<TD ALIGN="LEFT">Ignore</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
</TABLE>
</DIV>
<BR>

<P>
<BR><P></P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Class</B></TD>
<TD ALIGN="LEFT"><B>Type</B></TD>
<TD ALIGN="LEFT"><B>Fortran</B></TD>
<TD ALIGN="LEFT"><B>ESMF</B></TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_LOGENTRY</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_LocalArray</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Log</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_LogKind_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Logical</TD>
<TD ALIGN="LEFT">Ignore</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Mask</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_LogMsg_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_NeededFlag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_ObjectID</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Pin_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_PhysGrid</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Pointer</TD>
<TD ALIGN="LEFT">Ignore</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_ReadyFlag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Reduce_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Region_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_RegridMethod_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_RelLoc</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_ReqForRestartFlag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Route</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_RouteHandle</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_StaggerLoc</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_State</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_StateClass</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_StateItem</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_StateItem_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_StateIntent_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Status</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Sync_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_End_Flag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_Time</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_TimeInterval</TD>
<TD ALIGN="LEFT">Shallow</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_VM</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_VMId</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_VMPlan</TD>
<TD ALIGN="LEFT">Deep</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_ValidFlag</TD>
<TD ALIGN="LEFT">Parameter</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
</TR>
</TABLE>
</DIV>
<BR>

<P>

<P>

<P>

<H2><A NAME="SECTION000811000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN> Code: Data Type Consistency Guidelines</A>
</H2>

<P>
The following tools and guidelines are in place in order to maintain the ESMF framework's portability and robustness, in light of the fact that neither the Fortran nor C++ standards require a fixed size for any given data type and/or kind. Please note that these guidelines pertain to the internal ESMF code, not to the user code that interfaces to it.

<P>

<H3><A NAME="SECTION000811100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN> Use ESMF names for data types in C and ESMF data kinds in Fortran</A>
</H3>

<P>

<H3><A NAME="SECTION000811200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">2</SPAN> Fortran</A>
</H3>

<P>
Any occurrence of Fortran data kind parameters within ESMF code must be specified with ESMF parameters only. e.g.
<PRE>
       ESMF_KIND_I4
       ESMF_KIND_I8
       ESMF_KIND_R4
       ESMF_KIND_R8
</PRE>
These are internally defined such that the size of the data they describe is the number at the end of the parameter. e.g. in

<P>
<PRE>
       integer(ESMF_KIND_I8) :: someInteger
</PRE>
someInteger is an 8 byte integer in any platform.

<P>
Kind of literal constants:

<P>
Only the ESMF kind parameters listed above are allowed when specifying the kind of literal Fortran constants. e.g.

<P>
<PRE>
     real(ESMF_KIND_R8) :: a,b
     a=b*0.1_ESMF_KIND_R8
</PRE>

<P>
In the example above <TT>0.1_ESMF_KIND_R8</TT> is a literal constant of kind <TT>ESMF_KIND_R8</TT> and value 0.1.

<P>
This means that any other syntax, such as:
<PRE>
           a=b*0.1d0
           a=b*0.1_8
</PRE>
is NOT to be used.

<P>
<TT>ESMF_KIND_I</TT>, <TT>ESMF_KIND_R</TT>: Note that the <TT>ESMF_TypeKind_Flag</TT> parameters: <TT>ESMF_KIND_I</TT> and <TT>ESMF_KIND_R</TT> are defined for use in user code only. They are handles offered to the user for ESMF internal default kinds and not to be used internally in the ESMF framework.

<P>
<B>Real Data:</B>

<OL>
<LI>All real data in Fortran should be declared with an explicit ESMF defined kind parameter in the form:
<PRE>
              real(ESMF_KIND_R&lt;n&gt;) :: RealVariable
</PRE>

<P>
where <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img96.png"
 ALT="$&lt;n&gt;$"></SPAN> is the size in bytes of the memory occupied by each real datum. Allowed values of n are those that correspond to supported type/kind data, e.g.
<PRE>
              real (ESMF_KIND_R8) :: a,b
</PRE>
      declares a and b to be 8 byte reals

<P>
</LI>
<LI>Routines should be overloaded for all supported kinds(sizes) of real user data (e.g. in Array class routines).

<P>
</LI>
<LI>Real parameter arguments, such as the arguments to grid or regrid routines need not be cause for overloading. They should be declared with the kind required for appropriate accuracy and uniform behavior across platforms. Documentation should identify when specific data types and kinds are required in calling such routines.
</LI>
</OL>

<P>
<B>Integer Data:</B>

<P>
The standards for integer data differ between integers that store user data and integers that do not.

<P>
Routines with user integer data arguments (e.g. integer arrays), must be overloaded for all integer data kinds supported. These will be declared as
<PRE>
                         integer(ESMF_KIND_I&lt;n&gt;)
</PRE>
where <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img96.png"
 ALT="$&lt;n&gt;$"></SPAN> denotes data size in byte units.

<P>
Integers that do not represent user data must generally be declared without a specific kind (see the section below on Default Type Representation). Possible exceptions to this rule follow on items (3) and (4) below.

<P>
Care should be exercised to insure that integer arguments to intrinsic Fortran functions are of the correct kind (usually default). Likewise, argument parameters to VM routines should be of default kind.

<P>
In the case where a specific kind is required for integer ESMF routine arguments, such as occurs in TimeMgr routines, the requirement must be clearly documented (as noted above, ESMF kind parameters are to be used to specify the kind).

<P>
Default Type Representation:

<P>
Default Integer Data Internal to the ESMF:

<P>
Internally in the ESMF framework, all integer data intended to be of default kind must be declared without specifying their kind, e.g.
<PRE>
               subroutine ESMF_SomeRoutine(foo)
               integer :: foo
</PRE>
This is for clarity purposes, as well as to minimize the overall size of the framework.

<P>
<TT>ESMF_KIND_I</TT> must not be used to declare data internally within ESMF.

<P>
To provide some background, the handle <TT>ESMF_KIND_I</TT> is provided to aid users who want to insure that their integer user code matches the kind of ESMF internal default integer data. It is particularly useful when user code is compiled with integer autopromotion. User code that calls ESMF routines with internal default integer arguments could declare those integers to be of <TT>kind=ESMF_KIND_I</TT>, e.g.
<PRE>
                 program myUserCode
                 integer(ESMF_KIND_I) :: my_foo
                 call ESMF_SomeRoutine(my_foo)
</PRE>

<P>
<B>Logical Data:</B>

<P>
The standards for logical data differ between logicals which are used as dummy arguments in user-callable entry points, and those which need to be passed
to ESMF C++ routines.

<P>
Routines with user logical data arguments use default kind arguments:
<PRE>
                 logical :: isActive
</PRE>

<P>
Local logicals within Fortran code also generally use the default Fortran logical data type.

<P>
ESMF defines a <TT>ESMF_Logical</TT> derived type for use when passing logical values between Fortran and C++ code.  The constants <TT>ESMF_TRUE</TT> and
<TT>ESMF_FALSE</TT> are available, and must be used to ensure compatibility with the C++ code.

<P>
For convenience, defined assignment operators are available which convert between Fortran logical and the <TT>ESMF_Logical</TT> derived type. 
Finally, there are .eq. and .ne. operators defined to compare <TT>ESMF_Logical</TT> values.

<P>
<PRE>
               subroutine ESMF_SomeRoutine(myFlag)
                 use ESMF
                 implicit none
		 
                 logical, intent(inout) :: myFlag
	       
                 type(ESMF_Logical) :: myFlag_local

                 myFlag_local = myFlag                  ! Defined assignment
                 if (myFlag_local .eq. ESMF_TRUE) then  ! Use of .eq. operator
                   call c_ESMC_SomeCRoutine (myFlag_local)  ! Pass to C++
                 else
                   call c_ESMC_OtherCRtoutine (myFlag_local)
                 end if
                 myFlag = myFlag_local                  ! Defined assignment
               end subroutine
</PRE>

<P>

<H3><A NAME="SECTION000811300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">3</SPAN> C and C++</A>
</H3>

<P>
ESMF C datatypes are also declared with the property that their size remains constant across platforms. This convention is set in order to make ESMF more robust in terms of portability, as well as for the correct matching of Fortran-C routine interfaces. They have a direct size correspondence to their Fortran counterparts. Their names are:

<P>
<PRE>   
          ESMC_I4 (=) integer type of size 4 bytes
          ESMC_I8 (=) integer type of size 8 bytes
          ESMC_R4 (=) floating point type of size 4 bytes
          ESMC_R8 (=) floating point type of size 8 bytes
</PRE>

<P>
e.g.
<PRE>
          ESMC_R4 someFloat;
</PRE>
here <TT>someFloat</TT> is a 4 byte floating point in any platform.

<P>
<B>Real Data:</B>

<OL>
<LI>All real data in C should be declared with an explicit ESMF type in the form:
<PRE>
              ESMC_R&lt;n&gt;  RealVariable;
</PRE>
      where <SPAN CLASS="MATH"><IMG
 WIDTH="47" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img96.png"
 ALT="$&lt;n&gt;$"></SPAN> is the size in bytes of the memory occupied by each real datum. (Allowed values of n are those that correspond to supported type/kind data). e.g.
<PRE>
              ESMC_R8  a,b;
</PRE>
      which declares a and b to be 8 byte reals.

<P>
</LI>
<LI>Methods containing user data - such as arrays - as arguments must handle all supported real user data types and sizes.
</LI>
</OL>

<P>
<B>Integer Data:</B>

<OL>
<LI>All integers that do not represent user data must be declared using the C datatype <TT>int</TT>.

<P>
</LI>
<LI>Methods containing user data - such as arrays - as arguments must handle all supported integer user data types and sizes.
</LI>
</OL>

<P>
<B>Boolean Data:</B>

<OL>
<LI>Boolean values used internally within the C++ routines may use the <TT>bool</TT> data type.

<P>
</LI>
<LI>Methods which are Fortran-callable, and pass boolean values through the dummy argument list, must use the
<TT>ESMC_Logical</TT> enumerated type.  The constants <TT>ESMF_TRUE</TT> and <TT>ESMF_FALSE</TT> are available
for comparison purposes.  These constants must be used to ensure compatibility with the Fortran code.
</LI>
</OL>

<P>
<PRE>
               void fortran_caller(bool &amp;myFlag) {	       
                 ESMF_Logical myFlag_local;

                 myFlag_local = myFlag;
                 if (myFlag_local == ESMF_TRUE)
                   ESMF_SomeFortranRoutine (&amp;myFlag_local);  // Pass to Fortran
                 else
                   ESMF_OtherFortranRtoutine (&amp;myFlag_local);

                 myFlag = myFlag_local;
               }
</PRE>

<P>

<H3><A NAME="SECTION000811400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_TypeKind_Flag &ldquo;labels&rdquo;: When knowing the data type/kind is necessary</A>
</H3>

<P>
An enumerated parameter in C++ and a corresponding sequence parameter in Fortran are provided in order to identify the type-and-kind of data being processed in various ESMF routines. There is a one to one correspondence between the Fortran sequence and the C++ enumerated type. They are mostly used as a tool to customize code for a specific data type and kind, and to insure the correct handling of user data across Fortran-C interfaces.

<P>
In Fortran this sequenced type's name is <TT>ESMF_TypeKind_Flag</TT>.

<P>
The <TT>ESMF_TypeKind_Flag</TT> parameter names declared are:

<P>
<PRE>
               ESMF_TYPEKIND_I4   (4 byte integer)
               ESMF_TYPEKIND_I8   (8 byte integer)
               ESMF_TYPEKIND_R4   (4 byte floating point)
               ESMF_TYPEKIND_R8   (8 byte floating point)
</PRE>

<P>
The following are supported for user interface use only (they are not to be used internally in the ESMF framework):
<PRE>
               ESMF_TYPEKIND_I    (labels integer_not_autopromoted data)
               ESMF_TYPEKIND_R    (labels real_not_autopromoted data)
</PRE>

<P>
Fortran <TT>ESMF_TypeKind_Flag</TT> parameters mostly appear in calls to C routines that create or manipulate arrays, fields, or bundles. e.g.
<PRE>
         ....
         ESMF_TypeKind_Flag :: tk
         ...
          !-set tk
         ...
         call FTN_X(c_ESMC_VMAllFullReduce( ..., tk, ...  )
         ...
         ...
</PRE>
Likewise in C the enumerated type's name is <TT>ESMC_TypeKind_Flag</TT>.

<P>
The <TT>ESMC_TypeKind_Flag</TT> parameter names declared are:
<PRE>
               ESMC_TYPEKIND_I4   (4 byte integer)
               ESMC_TYPEKIND_I8   (8 byte integer)
               ESMC_TYPEKIND_R4   (4 byte floating point)
               ESMC_TYPEKIND_R8   (8 byte floating point)
</PRE>

<P>
In C, <TT>ESMC_TypeKind_Flag</TT> parameters are used to tailor computation to the type and kind of user data arguments being processed. e.g
<PRE>
  void FTN_X(c_esmc_vmallfullreduce)(.., ESMC_TypeKind_Flag *dtk, ..,int *rc){
    .....      
    switch (*dtk){
    case ESMC_TYPEKIND_I4:
      ....
      break;
    case ESMC_TYPEKIND_R4:
      ....
      break;
    case ESMC_TYPEKIND_R8:
      ...         
      break;
    default:
      ....
    }
    ...
</PRE>

<P>

<H3><A NAME="SECTION000811500000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">5</SPAN> Guidelines for Fortran-C Interfaces</A>
</H3>

<P>
There must be a one to one correspondence of Fortran and C arguments as illustrated in the table below. So for example, if a Fortran routine calls a C method that expects an argument of type <TT>ESMC_I4</TT>, the argument in the Fortran call should be declared to be an integer of <TT>kind=ESMF_KIND_I4</TT>.
<PRE>
     integer(ESMF_KIND_I4)  &lt;--&gt;  ESMC_I4  [4 bytes]
     integer(ESMF_KIND_I8)  &lt;--&gt;  ESMC_I8  [8 bytes]
     real(ESMF_KIND_R4)     &lt;--&gt;  ESMC_R4  [4 bytes]
     real(ESMF_KIND_R8)     &lt;--&gt;  ESMC_R8  [8 bytes]
     integer                &lt;--&gt;  int
     type(ESMF_Logical)     &lt;--&gt;  ESMC_Logical
     etc.
</PRE>
Also, <TT>ESMF_TypeKind_Flag</TT> and <TT>ESMC_TypeKind_Flag</TT> values are set to have matching values. That is:
<PRE>
             ESMF_TYPEKIND_I&lt;n&gt; = ESMC_TYPEKIND_I&lt;n&gt;
             ESMF_TYPEKIND_R&lt;n&gt; = ESMC_TYPEKIND_R&lt;n&gt;
</PRE>

<P>
<B>Character strings:</B>

<P>
When passing character strings to subprograms, most Fortran compilers pass
'hidden' string length arguments by value after all of the user-supplied arguments.
Each hidden argument corresponds to each character string that is passed.
Because of varying compiler support of 32-bit vs 64-bit string lengths,
the <TT>ESMCI_FortranStrLenArg</TT> macro is used in C++ code to specify the
data type of the hidden arguments.

<P>
For input arguments is usually convenient to copy the Fortran string into a
C++ string.  The <TT>ESMC_F90lentrim</TT> procedure provides a common way
to obtain the length of the Fortran string - while ignoring trailing blanks.
It is analogous to the Fortran <TT>len_trim</TT> intrinsic function.

<P>
<PRE>
  void FTN_X(c_esmc_somecode) (
      const char *name1,   // in - some name in a character string
      const char *name2,   // in - some other name
      int *rc,             // out - return code
      ESMCI_FortranStrLenArg name1_l,   // in - hidden length of name1
      ESMCI_FortranStrLenArg name2_l) { // in - hidden length of name2

      string name1_local = string (name1, ESMC_F90lentrim (name1, name1_l));
      string name2_local = string (name2, ESMC_F90lentrim (name2, name2_l));
      ...
  }
</PRE>

<P>
Likewise, when C++ code needs to pass a character string to Fortran code,
passing the string itself is performed by it address.  The hidden length
argument uses the standard string <TT>length</TT> method:

<P>
<PRE>
      FTN_X(f_esmf_somef90code) (
          name1_local.c_str(),
          name2_local.c_str(),
          &amp;localrc,
          (ESMCI_FortranStrLenArg) name1_local.length(),
          (ESMCI_FortranStrLenArg) name2_local.length())
</PRE>

<P>
Note that when an array of characters is passed, the hidden string size is
that of an individual array element.  The size of each dimension of the array
should be explicitly passed through separate arguments.  Thus, in the following
declaration, the hidden argument would have a value of 32.  The dimensions, 20
and 30, would need to be separately passed:

<P>
<PRE>
    character(32) :: char_array(20,30)
    :
    call c_esmc_something (  &amp;
        char_array, size (char_array,1), size (char_array, 2), &amp;
        localrc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION000812000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN> Code: Optional Argument Conventions for the C/C++ API</A>
</H2>

<P>

<H3><A NAME="SECTION000812100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN> Overview</A>
</H3>

<P>
Optional arguments in the public ESMC interface are implemented using the
variable-length argument list functionality provided by <TT>&lt;stdarg.h&gt;</TT>.
The <TT>&lt;stdarg.h&gt;</TT> header contains a set of macros which allows portable
functions that accept variable-length argument lists (also known as variadic
functions) to be written. Variadic functions are declared with an ellipsis in
place of the last parameter and must have at least one named (fixed) parameter.
A typical example of such a function is printf which is declared as

<P>
<PRE>
        int printf(char *fmt, ...).
</PRE>

<P>
The following type and macros are provided by <TT>&lt;stdarg.h&gt;</TT> for processing
variable-length argument lists.

<UL>
<LI><TT>va_list</TT>
<BR>
Type suitable for use in accessing the variable-length argument list of a function
with the stdarg macros;
</LI>
<LI><TT>void va_start(va_list ap, last_arg)</TT>
<BR>
Initializes the variable argument list pointer <SPAN  CLASS="textit">ap</SPAN> to the beginning of the
variable argument list, before any calls to <TT>va_arg</TT>. <SPAN  CLASS="textit">last_arg</SPAN> is
the last fixed argument being passed to the function (the argument before the
ellipsis).
</LI>
<LI><SPAN  CLASS="textit">type</SPAN> <TT>va_arg(va_list ap, </TT><SPAN  CLASS="textit">type</SPAN><TT>)</TT>
<BR>
Returns the next argument in the variable-length argument list pointed to by
<TT>ap</TT>. Each invocation of <TT>va_arg</TT> modifies <TT>ap</TT> such that
the values of successive arguments are returned in turn. The <SPAN  CLASS="textit">type</SPAN>
parameter is the type the argument is expected to be. The parameter <SPAN  CLASS="textit">type</SPAN>
is a type name specified so that the type of a pointer to an object that has the
specified type can be obtained simply by adding a <TT>*</TT> to <SPAN  CLASS="textit">type</SPAN>.
Different types can be mixed, but it is up to the function to know what type of
argument is expected. Note that <TT>ap</TT> must be initialized with
<TT>va_start</TT>. If there is no next argument, then the result is undefined.
</LI>
<LI><TT>void va_end(va_list ap)</TT>
<BR>
Destroys the variable argument list pointer <TT>ap</TT>, rendering it invalid
unless <TT>va_start</TT> is called again. Each invocation of <TT>va_start</TT>
must be matched by a corresponding invocation of <TT>va_end</TT> in the same
function. After the call <TT>va_end(ap)</TT> the variable <TT>ap</TT> is
undefined. Multiple traversals of the list, each bracketed by <TT>va_start</TT>
and <TT>va_end</TT> are possible.
</LI>
</UL>

Arguments corresponding to the variable-length argument list specified by
<TT>",..."</TT> in a function prototype always undergo the following argument
conversions: <TT>bool</TT> or <TT>char</TT> or <TT>short</TT> are converted to
<TT>int</TT>, and <TT>float</TT> is converted to <TT>double</TT>.
<BR>

<P>
In order to correctly retrieve arguments from the variable argument list it is
necessary to know the type of each argument. In order to correctly terminate
parsing the variable argument list it is also necessary to know the number of
arguments in the list. Since the number of arguments and their types
are not known at compile time the best one can do is establish a convention
such that the caller will provide type and length information about the variable
argument list. The convention, however, is not a guarantee that the caller does
not mistakenly specify the types or number of arguments.
The <TT>scanf</TT> and <TT>printf</TT> functions do this by having
the last fixed argument be a character (format) string in which the caller
specifies the types (for example, <TT>"%f%d%s"</TT> for each argument in the
variable argument list. Although, the format string specifies the number of
expected arguments there is no actual "termination-flag" inserted at the end of
the variable argument list. If the caller incorrectly specifies the in the format
string more arguments than are actually provided then the function will likely
access invalid sections of memory while parsing the variable argument list.
Unless this error is trapped by the system the function will unwittingly process
erroneous data.

<P>

<H3><A NAME="SECTION000812200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">2</SPAN> Approach</A>
</H3>

<P>
The following conventions are established for the public ESMC optional argument
API. The "class" associated with this API is called <TT>ESMC_Arg</TT> and its
header files are located in <TT>Infrastructure/Util/include</TT>. The public
optional argument API for a class is provided by the public header for that class
together with <TT>ESMC_Arg.h</TT>. Macros for internal processing of optional
arguments are provided by the <TT>ESMCI_Arg.h</TT> header.
Each ESMC class has a set of named optional arguments associated with its
methods. Associated with each optional argument of a class is a unique (within
the class) optional argument identifier (<SPAN  CLASS="textit">id</SPAN>) of type
<TT>ESMCI_ArgID</TT>. The optional argument list provided by
the caller must consist of a sequence of argument identifier and argument
(<SPAN  CLASS="textit">id</SPAN>, <SPAN  CLASS="textit">arg</SPAN>) pairs. The optional argument list must be terminated
by the global identifier <TT>ESMCI_ArgLastID</TT>.
The <TT>ESMC_ArgLast</TT> macro is provided by <TT>ESMC_Arg.h</TT> for the
user to indicate the end of an optional argument list.
<BR>

<P>
The global identifier <TT>ESMCI_ArgBaseID</TT> is the starting identifier for
local (class) optional argument identifiers. <TT>ESMCI_ArgBaseID</TT>
establishes a set of global optional argument identifiers, such that, the global
set does not intersect with any class identifier set.
The optional argument identifier list for a class will be declared in the public
header for that class. The naming convention for optional argument identifiers
is
<PRE>
                ESMCI_&lt;ClassName&gt;Arg&lt;ArgName&gt;ID
</PRE>
where <TT>ClassName</TT> is the
name of the class and <TT>ArgName</TT> is the name of the optional argument with
the first letter capitalized. The optional argument identifier list is declared
as enumeration constants with the first identifier set equal to
<TT>ESMCI_ArgBaseID</TT>. Here is an example for a class called "Xclass".
<PRE>
   // Optional argument identifier list for the ESMC_Xclass API.
   enum {
     ESMCI_XclassArgAoptID = ESMCI_ArgBaseID,  // ESMC_I1
     ESMCI_XclassArgBoptID,                    // ESMC_I4
     ESMCI_XclassArgCoptID,                    // ESMC_R4
     ESMCI_XclassArgDoptID,                    // ESMC_R8
     ESMCI_XclassArgEoptID,                    // ESMC_Fred
   };
</PRE>

It is helpful for the class developer to list the data type of
each optional argument (as a comment) with its associated <SPAN  CLASS="textit">id</SPAN>.
<BR>

<P>
The <TT>ESMCI_Arg(ID,AR)</TT> internal macro (declared in <TT>ESMC_Arg.h</TT>)
is provided for casting an optional argument and its associated <SPAN  CLASS="textit">id</SPAN> into
the required sequence for passing to functions.
<PRE>
   #define ESMCI_Arg(ID,ARG)  ((ESMCI_ArgID)ID),(ARG)
</PRE>

Each class will use this internal macro in its public header to declare
user macros for the class specific optional arguments. 
The naming convention for class specific optional argument expansion macros 
is
<PRE>
                ESMC_&lt;ClassName&gt;Arg&lt;ArgName&gt;(ARG)
</PRE>
where <TT>ClassName</TT> is the
name of the class and <TT>ArgName</TT> is the name of the optional argument with
the first letter capitalized. The argument of the macro is the actual caller
provided optional argument.  Here is an example of how the macros are used for
the class "Xclass".
<PRE>
   // Argument expansion macros for the ESMC_Xclass API.
   #define ESMC_XclassArgAopt(ARG)  ESMCI_Arg(ESMCI_XclassArgAoptID,ARG)
   #define ESMC_XclassArgBopt(ARG)  ESMCI_Arg(ESMCI_XclassArgBoptID,ARG)
   #define ESMC_XclassArgCopt(ARG)  ESMCI_Arg(ESMCI_XclassArgCoptID,ARG)
   #define ESMC_XclassArgDopt(ARG)  ESMCI_Arg(ESMCI_XclassArgDoptID,ARG)
   #define ESMC_XclassArgEopt(ARG)  ESMCI_Arg(ESMCI_XclassArgEoptID,ARG)
</PRE>

Here is an example call, with properly specified optional arguments, to a class
function. The function has three named (fixed) arguments.
<PRE>
   rc = ESMC_XclassFunc(fixedArg1,fixedArg2,fixedArg3,
                        ESMC_XclassArgAopt(aOptArg),
                        ESMC_XclassArgCopt(cOptArg),
                        ESMC_XclassArgDopt(dOptArg),
                        ESMC_ArgLast)
</PRE>

<P>

<H3><A NAME="SECTION000812300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">3</SPAN> Internal Macros for Processing the Optional Argument List</A>
</H3>

<P>
Internal macros for processing the optional argument list are declared in
<TT>ESMCI_Arg.h</TT>. These macros provide a consistent internal interface to
the macros defined in <TT>stdarg.h</TT>. What follows is a description of each
macro available to a class developer.

<P>

<UL>
<LI><TT>ESMCI_ArgList</TT>
<BR>
Optional argument list data type (<TT>va_list</TT>). The variable used for
accessing the optional argument list must be declared as this type.
</LI>
<LI><TT>ESMCI_ArgStart(AP,LAST)</TT>
<BR>
Internal macro to initialize optional argument list processing. <TT>AP</TT> is
the optional argument list pointer. <TT>LAST</TT> is the last fixed argument
(before the optional argument list).
</LI>
<LI><TT>ESMCI_ArgEnd(AP)</TT>
<BR>
Internal macro to finalize optional argument list processing. <TT>AP</TT> is
the optional argument list pointer.
</LI>
<LI><TT>ESMCI_ArgGetID(AP)</TT>
<BR>
Internal macro to return an optional argument identifier. <TT>AP</TT> is
the optional argument list pointer.
</LI>
</UL>

<P>
The following type specific <TT>ESMCI_ArgGet</TT> macros are provided for
returning optional argument values. These macros correctly account for the
forced type conversions described above. In each macro, <TT>AP</TT> is the
optional argument list pointer.
<BR>
<BR>
Internal macros for returning standard C (non-pointer) types.
<PRE>
   #define ESMCI_ArgGetChar(AP)           (char)va_arg(AP,int)
   #define ESMCI_ArgGetShort(AP)         (short)va_arg(AP,int)
   #define ESMCI_ArgGetInt(AP)             (int)va_arg(AP,int)
   #define ESMCI_ArgGetLong(AP)           (long)va_arg(AP,long)
   #define ESMCI_ArgGetLongLong(AP)  (long long)va_arg(AP,long long)
   #define ESMCI_ArgGetFloat(AP)         (float)va_arg(AP,double)
   #define ESMCI_ArgGetDouble(AP)       (double)va_arg(AP,double)
</PRE>

Internal macros for returning defined ESMC types.
<PRE>
   #define ESMCI_ArgGetI1(AP)          (ESMC_I1)va_arg(AP,int)
   #define ESMCI_ArgGetI2(AP)          (ESMC_I2)va_arg(AP,int)
   #define ESMCI_ArgGetI4(AP)          (ESMC_I4)va_arg(AP,int)
   #define ESMCI_ArgGetI8(AP)          (ESMC_I8)va_arg(AP,ESMC_I8)
   #define ESMCI_ArgGetR8(AP)          (ESMC_R8)va_arg(AP,double)
   #define ESMCI_ArgGetR4(AP)          (ESMC_R4)va_arg(AP,double)
</PRE>

Special internal macro for returning strings.
<PRE>
   #define ESMCI_ArgGetString(AP)               va_arg(AP,char*)
</PRE>

General internal macro for returning all non-converted types.
<PRE>
   #define ESMCI_ArgGet(AP,TYPE)                va_arg(AP,TYPE)
</PRE>

<TT>TYPE</TT> is the expected type of returned argument.

<P>

<H3><A NAME="SECTION000812400000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">4</SPAN> Parsing the Optional Argument List</A>
</H3>

<P>
Each class function with optional arguments will declare an optional argument
list pointer and optional argument list <SPAN  CLASS="textit">id</SPAN>.
<PRE>
  ESMCI_ArgList argPtr;       // optional argument list pointer
  ESMCI_ArgID argID;          // optional argument list id
</PRE>

<P>
Parsing the optional argument list consists of three distinct phases: initializing
the argument list pointer, retrieving each argument in succession based on its
<SPAN  CLASS="textit">id</SPAN>, and finalizing the argument list pointer. The block for retrieving
arguments must first retrieve an argument <SPAN  CLASS="textit">id</SPAN>. If that <SPAN  CLASS="textit">id</SPAN> is
not <TT>ESMCI_ArgLastID</TT> and is in the set of valid ids for that function,
then the argument is retrieved using a type-appropriate <TT>ESMCI_ArgGet</TT>
macro. The following example code should be considered as "template" code for
parsing an optional argument list.
<PRE>
  // parse the optional argument list:
  ESMCI_ArgStart(argPtr,ifix);
  while ( (argID = ESMCI_ArgGetID(argPtr)) != ESMCI_ArgLastID ) {
    switch ( argID ) {
      case ESMCI_XclassArgAoptID:
        aOpt = ESMCI_ArgGetI1(argPtr);
        break;
      case ESMCI_XclassArgBoptID:
        bOpt = ESMCI_ArgGetI4(argPtr);
        break;
      case ESMCI_XclassArgCoptID:
        cOpt = ESMCI_ArgGetR4(argPtr);
        break;
      case ESMCI_XclassArgDoptID:
        dOpt = ESMCI_ArgGetR8(argPtr);
        break;
      case ESMCI_XclassArgEoptID:
        eOpt = ESMCI_ArgGet(argPtr,ESMC_Fred);
        break;
      default:
        ESMC_LogDefault.MsgFoundError(ESMC_RC_OPTARG_BAD, "", &amp;rc);
        return rc;
    } // end switch (argID)
  } // end while (argID)
  ESMCI_ArgEnd(argPtr);
</PRE>

<P>
Prior to actually parsing the optional argument list a function must check the
list for proper specification. This is done by using a code block similar to the
parsing block shown above. The difference is that in this case the
<TT>ESMCI_ArgGet</TT> macros are only used to increment the argument list pointer.
<PRE>
  // check the optional argument list:
  ESMCI_ArgStart(argPtr,lastFixed);
  while ( (argID = ESMCI_ArgGetID(argPtr)) != ESMCI_ArgLastID ) {
    switch ( argID ) {
      case ESMCI_XclassArgAoptID: ESMCI_ArgGetI1(argPtr); break;
      case ESMCI_XclassArgBoptID: ESMCI_ArgGetI4(argPtr); break;
      case ESMCI_XclassArgCoptID: ESMCI_ArgGetR4(argPtr); break;
      case ESMCI_XclassArgDoptID: ESMCI_ArgGetR8(argPtr); break;
      case ESMCI_XclassArgEoptID: ESMCI_ArgGet(argPtr,ESMC_Fred); break;
      default:
        ESMC_LogDefault.MsgFoundError(ESMC_RC_OPTARG_BAD, "", &amp;rc);
        return rc;
    } // end switch (argID)
  } // end while (argID)
  ESMCI_ArgEnd(argPtr);
</PRE>

<P>
The following example shows how an optional argument list check block can be
structured to handle an optional argument whose type is call dependent. In this
case the type of the <TT>dValue</TT> optional argument depends on the value of the
<TT>ESMC_TypeKind_Flag</TT> argument <TT>tk</TT> (which is the last fixed argument).
<PRE>
  // check the optional argument list:
  ESMCI_ArgStart(argPtr,tk);
  while ( (argID = ESMCI_ArgGetID(argPtr)) != ESMCI_ArgLastID ) {
    switch ( argID ) {
      case ESMCI_ConfigArgCountID: ESMCI_ArgGetInt(argPtr); break;
      case ESMCI_ConfigArgLabelID: ESMCI_ArgGetString(argPtr); break;
      case ESMCI_ConfigArgDvalueID:
        switch ( tk ) {
          case ESMC_TYPEKIND_I4: ESMCI_ArgGetI4(argPtr); break;
          case ESMC_TYPEKIND_I8: ESMCI_ArgGetI8(argPtr); break;
          case ESMC_TYPEKIND_R4: ESMCI_ArgGetR4(argPtr); break;
          case ESMC_TYPEKIND_R8: ESMCI_ArgGetR8(argPtr); break;
          case ESMC_TYPEKIND_LOGICAL: ESMCI_ArgGetInt(argPtr); break;
          case ESMC_TYPEKIND_CHARACTER: ESMCI_ArgGetString(argPtr); break;
        } // end switch (tk)
        break;
      default:
        ESMC_LogDefault.MsgFoundError(ESMC_RC_OPTARG_BAD, "", &amp;rc);
        return rc;
    } // end switch (argID)
  } // end while (argID)
  ESMCI_ArgEnd(argPtr);
</PRE>

<P>

<P>

<P>

<H2><A NAME="SECTION000813000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN> Code: Makefile Conventions</A>
</H2> 	 

<P>
The makefiles use GNU standard target names when possible.
The default rule is to remake the ESMF library.  Targets exist
to build the unit and system tests, the examples, the demos,
and to run them together or individually.  Targets also exist
to build the documentation and create pdf and html versions.
For more details on targets, refer to the README file in the top
level ESMF directory, and also the <I>ESMF User's Guide</I>.

<P>

<H3><A NAME="SECTION000813100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">1</SPAN> Code Building Rules</A>
</H3> 
During software development it is advantageous to recompile a portion of
ESMF and not build the entire framework when testing localized software
modifications.  The makefiles are configured to compile only files in the
current directory and rebuild the shared libraries only when necessary.
Therefore when "gmake" is entered in any directory, only files in that
directory are compiled.  However, the entire ESMF framework may be built
from any directory by entering "gmake lib".

<P>
The unit tests, the system tests, the examples, and the demos all share
a common set of targets.  The following target list illustrates the
options for the examples.  The names <TT>unit_tests</TT>, <TT>system_tests</TT>,
<TT>demos</TT>, and <TT>all_tests</TT> can be substituted wherever <TT>examples</TT>
occurs.
<DL>
<DT><STRONG>examples</STRONG></DT>
<DD>build and run all examples
</DD>
<DT><STRONG>examples_uni</STRONG></DT>
<DD>build and run all examples single process
</DD>
<DT><STRONG>build_examples</STRONG></DT>
<DD>build the examples
</DD>
<DT><STRONG>run_examples</STRONG></DT>
<DD>run the examples and report the success/fail status
</DD>
<DT><STRONG>run_examples_uni</STRONG></DT>
<DD>run the examples single process
</DD>
<DT><STRONG>check_examples</STRONG></DT>
<DD>report the success/fail status without reexecution
</DD>
<DT><STRONG>clean_examples</STRONG></DT>
<DD>remove the example executables
</DD>
</DL> 

<P>

<H3><A NAME="SECTION000813200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">2</SPAN> Document Building Rules</A>
</H3> 
The makefile rules for building documents are now located in:
<PRE> build/common.mk
</PRE> 
The rules exist
as pattern rules and are controlled by the variables set in a doc
directory's makefile.  The pattern rules will build .tex  from source code
and .pdf, .dvi and html files from .ctex files.

<P>
Variables that can be set in the individual doc/makefiles are called
"makefile variables".  These are: 
<DL>
<DT><STRONG>DVIFILES</STRONG></DT>
<DD>
</DD>
<DT><STRONG>PDFFILES</STRONG></DT>
<DD>
</DD>
<DT><STRONG>HTMLFILES</STRONG></DT>
<DD>
</DD>
<DT><STRONG>TEXTFILES_TO_MAKE</STRONG></DT>
<DD>
</DD>
</DL>

<P>
Document file dependencies are set with: 
<DL>
<DT><STRONG>REFDOC_DEP_FILES</STRONG></DT>
<DD>
</DD>
</DL>

<P>
The makefiles targets work from both local directory and from ESMF_DIR:
<DL>
<DT><STRONG>gmake alldoc</STRONG></DT>
<DD>
</DD>
<DT><STRONG>gmake pdf</STRONG></DT>
<DD>
</DD>
<DT><STRONG>gmake dvi</STRONG></DT>
<DD>
</DD>
<DT><STRONG>gmake html</STRONG></DT>
<DD>
</DD>
</DL>

<P>

<H3><A NAME="SECTION000813300000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">3</SPAN> Include Files</A>
</H3> 
At the highest directory level, the "include"
directory will contain public include files intended to be used in
user-written code.  They will be broken up into separate files, with a
single "ESMF.h" include file which includes all the others.

<P>
At the 'src' level, parallel to Infrastructure, Superstructure, and doc,
is another include directory.  This is for private include files which are
ESMF-wide.  These might include system-wide architecture dependent
#defines constants, etc.

<P>
Below the Superstructure &amp; Infrastructure level are the individual
component levels (TimeMgr, Field, Component, etc).  Under each of these
directories is an include directory for the component specific include
files.

<P>

<P>

<H2><A NAME="SECTION000814000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN> Preprocessor Usage</A>
</H2>

<P>

<H3><A NAME="SECTION000814100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN>.<SPAN CLASS="arabic">1</SPAN> Using the Preprocessor For Generic Fortran Code</A>
</H3>

<P>
Fortran allows the creation of generic subprogram names via the
<TT>INTERFACE</TT> facility.  This lets the caller use a simplified
single name for a call.  Then, based on the callers actual argument list,
the compiler will choose an appropriate specific routine to perform
the task.

<P>
When several specific variants of a generic call exist, and only
differ in minor ways, for example by ESMF object type, it can be
desirable to have the variants generated from a single definition.
This allows improvements in the reliability and maintainability of
the code.  Feature code can be added in a single place, and all
of the specific routines will automatically incorporate the new code.

<P>
By convention, generic ESMF Fortran code uses the GNU C preprocessor
macro facility to generate specific routines.  These routines generally
differ only in the type, kind, and rank of the dummy arguments.  The
internal code is otherwise identical.

<P>
When writing a cpp macro, the definition must be 'one line' long.
Since coding an entire subprogram requires many lines to implement,
a backslash character is used at the end of each line to concatenate
multiple lines from the input file into a single, very long, preprocessor
line.  After macro expansion, each preprocessor line needs to be
converted into a sequence of Fortran statements.  So again by
convention, at-sign characters, @, are used as the second-to-last
character in each line.  After cpp has been run, the long lines from
the result are split at the @ characters by converting them to newline
characters.  The <TT>tr</TT> command is used for this translation.

<P>
ESMF Fortran files which need to be preprocessed in this manner use
the file name suffix <TT>.cppF90</TT>.  This triggers the makefile system
to use the following sequence when processing the file:

<P>

<UL>
<LI>The gcc version of cpp is run.  This causes a first pass of
preprocessing to occur.  All macro expansion for generic routines
should be performed in this pass.

<P>
</LI>
<LI>The <TT>tr</TT> command is run to perform several transformations:

<P>

<OL>
<LI>Convert @ characters to newline characters.  As described above, this
converts the one very long line of any cpp macro expansion into multiple
source lines for the compiler.

<P>
</LI>
<LI>Convert caret, ^&nbsp; characters to # characters
in order to allow selected preprocessing directives to pass through to the
second level of preprocessing performed by the actual compiler.

<P>
</LI>
<LI>Convert vertical bar, |, characters to apostrophe (single
quote) characters.  Vertical bars should be used where apostrophe characters
need to appear.  This is needed because some versions of cpp look for matching
apostrophes in order to properly issue code.  Note that only lines within a
macro definition, i.e., those ending in @&nbsp; need to use this transformation.

<P>
</LI>
</OL>

<P>
</LI>
<LI>The Fortran compiler is run.  The built-in preprocessor is used for
the second preprocessing pass.  This pass is used for other preprocessing
tasks - such as including header files needed for compilation, or for
conditional compilation of system-dependent code.

<P>
</LI>
</UL>

<P>
A simple example of generic code written in this style is:

<P>
<PRE>
  module ESMF_Example_mod
    use ESMF
    implicit none

! The following header needs to be preprocessed by the compiler,
! not the first cpp pass.  So use a caret as the first character,
! rather than a pound-sign.

^include "my_header.inc"

! Define a generic name with three specific routines

    interface ESMF_generic_name
      module procedure ESMF_ArraySpecifc
      module procedure ESMF_FieldSpecfic
      module procedure ESMF_MeshSpecific
    end interface

  contains

! Define a macro for expansion.  Each line is terminated with a
! @\ sequence.  Also note the use of ## for concatenation
! and # for stringization.

#define MySpecificMacro(mclass, mthis)  \
  subroutine mclass##Specific (mthis, rc) @\
    type(mclass), intent(inout) :: mthis @\
    integer, optional :: rc @\
 @\
    print *, |class = |, #mclass @\
 @\
    if (present (rc)) rc = ESMF_SUCCESSFUL @\
 @\
  end subroutine mclass##Specfic @\

! Expand macro for a few classes

MySpecificMacro(ESMF_Array, array)
MySpefificMacro(ESMF_Field, field)
MySpecificMacro(ESMF_Mesh, mesh)

end module ESMF_Example_mod
</PRE>

<P>
Character string concatenation via the Fortran concatenation operator <TT>//</TT>
can be problematic due to the first pass preprocessing treating it as a C++ inline
comment.  An alternative is to use the <TT>ESMF_StringConcat</TT> function.

<P>

<H3><A NAME="SECTION000814200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN>.<SPAN CLASS="arabic">2</SPAN> System Dependent Strategy Using Preprocessor</A>
</H3> Since the code
must compile across different platforms, a strategy must be adopted to
handle the system differences. Examples of system differences are: the
subroutines (bcopy vs memcopy) or include filenames (strings.h vs str.h,
etc).

<P>
Rather than putting architecture names in all the source files, there will
be an ESMF-wide file which contains sections like this: 
<PRE>
 #ifdef sgi 
 #define HAS_VFORK 0 
 #define BCOPY_FASTER 1 
 #define FOPEN_3RD_ARG 1 
 #endif

 #ifdef sun 
 #define HAS_VFORK 1 
 #define BCOPY_FASTER 0 
 #define FOPEN_3RD_ARG 1 
 #endif
</PRE> This allows system-dependent code to be bracketed with
meaningful names: 

<P>
<PRE> 

 #if HAS_VFORK
    vfork();
 #else
    fork(); 
    exec();
 #endif
</PRE> 
and not an endless string of architecture names.

<P>

<P>

<H2><A NAME="SECTION000815000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF Data Type Autopromotion Support Policy and Guide</A>
</H2>

<P>
ESMF supports autopromotion of user code with respect to integer and real data types. This is data that a user would put in an array or field. By autopromotion we mean compiling user code with <SPAN CLASS="MATH"><IMG
 WIDTH="32" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img97.png"
 ALT="$-r8$"></SPAN>, <SPAN CLASS="MATH"><IMG
 WIDTH="30" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img98.png"
 ALT="$-i8$"></SPAN> or similar options on those platforms where these options are available. If a code is compiled with autopromotion, user data will be processed correctly by ESMF. That is because user data arguments in ESMF calls already are overloaded for all TKR(type-kind-rank). It is important to note that ESMF itself must not be compiled with autopromotion flags.

<P>
The ESMF API distinguishes four different flavors of integer and real arguments:

<UL>
<LI>integer parameters
</LI>
<LI>integer user data
</LI>
<LI>real parameters
</LI>
<LI>real user data
</LI>
</UL>

<P>
The ESMF API handles integer user data by overloading for TKR. The ESMF API handles real user data by overloading for TKR. The ESMF API handles integer parameters by using the system's default integer type. The ESMF API handles real parameters by explicitly specifying a kind.

<P>
As a result of the ESMF API conventions the autopromotion of integer and real user data is automatically handled within ESMF.

<P>
Integer parameters that are arguments to ESMF calls must be protected against integer autopromotion by explicitly specifying their kind as <TT>ESMF_KIND_I</TT> in the user code.

<P>
The safest way to handle real parameters is for the user to specify their explicit kind as expected by the API. However, the user may choose to omit the kind specifier for reasons of convenience. This however will make their code vulnerable with respect to autopromotion and make the user code less portable, breaking it where the system default real kind does not match the ESMF API.

<P>
The requirements for safe interfacing of autopromoted user code with ESMF are as follows:

<OL>
<LI>All integer parameter arguments (as opposed to user data) to ESMF routines must be of kind <TT>ESMF_KIND_I</TT>. Following is an example of an ESMF call that includes both a user data argument, and integer parameter arguments
<PRE>
    ...

 integer, dimension(:), pointer :: intptr        !User data arg.
                                                 !-&gt;No need for 
                                                 !kind specifier.

 integer(ESMF_KIND_I), dimension(3) :: counts    ! Integer 
                                                 ! parameter 

 integer(ESMF_KIND_I), dimension(3) :: lbounds   ! Integer 
                                                 ! parameter

 integer(ESMF_KIND_I), dimension(3) :: ubounds   ! Integer 
                                                 ! parameter

 integer(ESMF_KIND_I) :: rc                      ! Integer 
                                                 ! parameter
  ...
 call  ESMF_LocalArrayCreate(array, counts, intptr, &amp;
         lboounds, ubounds, rc)
</PRE>

<P>
</LI>
<LI>As explained in section I.3 above, all real parameters must be of the kind expected by the routine being called. e.g. In a call to <TT>ESMF_ClockGet()</TT>, the <TT>runTimeStepCount</TT> argument must be of kind <TT>ESMF_KIND_R8</TT>.
<PRE>
             ...
            type(ESMF_Clock)  :: clock
            real(ESMF_KIND_R8) :: runTimeStepCount
            integer(ESMF_KIND_I) :: rc
             ...
            call ESMF_ClockGet(clock, runTimeStepCount, rc)
</PRE>
</LI>
<LI>When user data is autopromoted, the <TT>ESMF_TypeKind_Flag</TT> parameter argument corresponding to the autopromoted data must be adjusted appropriately. The <TT>ESMF_TypeKind_Flag</TT> parameter for an array or field that has been autopromoted can be obtained during execution by using the function <TT>ESMF_TypeKindFind()</TT>. <TT>ESMF_TypeKindFind()</TT> is an overloaded function that returns the <TT>ESMF_TypeKind_Flag</TT> parameter corresponding to the runtime type and kind of an input scalar.

<P>
e.g. In the following code excerpt <TT>ESMF_TypeKindFind()</TT> is used to determine at runtime the correct <TT>ESMF_TypeKind_Flag</TT> parameter to use in the <TT>ESMF_ArraySpecSet()</TT> routine in preparation for creation of an ESMF Array that will store integer data that may or may not be autopromoted.
<PRE>
          ...
          integer :: iScalar
          ...
          type(ESMF_TypeKind_Flag) myTypeKind
          myTypeKind= ESMF_TypeKindFind(iScalar)
          call ESMF_ArraySpecSet(arrayspec, rank, myTypeKind, rc)
</PRE>
</LI>
</OL>

<P>

<H3><A NAME="SECTION000815100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> How We Arrived at This Autopromotion Support Policy</A>
</H3>

<P>
We considered the possibility of expanding autopromotion support to ESMF routine integer parameter arguments, in addition to those storing user data. Two options were considered as explained below. The reasons why we decided against such support, after discussion with the ESMF community, are as follows:

<OL>
<LI>All user interfaces would need to be overloaded -this in addition to the overloading already present on some routines for user data.
</LI>
<LI>Most likely, cpp macros for all user interfaces would be needed, which does not improve readability.
</LI>
<LI>The additional necessary overloading would double (or more, depending on the option) the size of our post-processor code base.
</LI>
<LI>Typecasting support would incur performance overhead, regardless of whether autopromotion is used or not.
</LI>
<LI>There are routines, such as <TT>ESMF_LocalArrayCreate()</TT>, where all integer parameter arguments are optional. Overloading those routines violates the Fortran 95 standard and will not compile.
</LI>
</OL>

<P>
Rejected Options:

<P>
We considered and rejected two alternate options for autopromotion support. Here we illustrate with an example their impact on both the user code and the ESMF code. Note that this routine is overloaded for data arrays for all TKR supported and thus supports both real and integer autopromotion of user data.

<P>
1st option: support autopromotion of integers (options sizes 4 or 8 bytes) as long as all integer parameter arguments are of the same kind.

<P>
2nd option: support autopromotion of integers (options sizes 4 or 8 bytes). Mixed integer argument kinds.

<P>
For our example we use a call to <TT>ESMF_LocalArrayCreate()</TT> in each of the 2 option scenarios. In reading these example scenarios please keep in mind that ESMF code will not be compiled with autopromotion.

<P>
That is because only user code autopromotion is being considered. Thus the following statement could have different meaning if it is found within ESMF than in user code:
<PRE>
                         integer :: foo

 In ESMF-------------------------------- ===&gt;  foo is of default 
                                               integer kind/size.

 In User code compiled with autopromotion ==&gt;  foo is an integer
                                               of kind/size 
                                               determined by
                                               autopromotion flag.
</PRE>

<P>
<B>With 1st Option:</B>

<P>
<PRE>
  USER CODE:
  ---- -----
      ...
     integer, dimension(:), pointer :: intptr
     integer             , dimension(3) :: counts
     integer             , dimension(3) :: lbounds
     integer             , dimension(3) :: ubounds
     integer              :: rc
      ...
      ...
     call  ESMF_LocalArrayCreate(array, counts, intptr, &amp;
           lboounds, ubounds, rc)
</PRE>

<P>
Changes in ESMF:

<P>
The routine would need to be further overloaded in order to insure that all integer parameter call arguments (<TT>counts, lbounds, ubounds,</TT> and <TT>rc</TT>), are typecast to default integer inside the method (note that ESMF kind can be of size 4 or 8). It would be something like this:
<PRE>
  
   subroutine ESMF_LocalArrayCreate(array, counts, intptr,.... &amp;
                       lbounds, ubounds, rc)
   ......
    integer(&lt;esmfKind&gt;) , intent(in), optional :: counts, &amp;
                          lbounds, ubounds
    integer(&lt;esmfKind&gt;), intent(out), optional :: rc 
    integer :: counts_noAP, lbounds_noAP, ubounds_noAP, rc_noAP
  
    if (PRESENT(counts)) counts_noAP=counts
    if (PRESENT(lbounds)) lbounds_noAP=lbounds
    if (PRESENT(ubounds)) ubounds_noAP=ubounds
   ...
   ....
    if (PRESENT(rc)) rc=rc_nonAP
   return
</PRE>

<P>
With <SPAN CLASS="MATH"><IMG
 WIDTH="114" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img99.png"
 ALT="$&lt;esmfKind&gt;$"></SPAN> = <TT>ESMF_KIND_I4</TT> in one copy and <TT>ESMF_KIND_I8</TT> in the other. The number of copies of the routine will increase from 42 to 84.

<P>
*(Note that in this particular routine, overloading is problematic because all the integer parameters are optional)

<P>
<B>With 2nd Option:</B>
<PRE>
  USER CODE:
  ---- -----
      ...
     integer, dimension(:), pointer :: intptr
     integer(ESMF_KIND_I4) , dimension(3) :: counts
     integer(ESMF_KIND_I8), dimension(3) :: lbounds
     integer             , dimension(3) :: ubounds
     integer              :: rc
      ...
      ...
     call  ESMF_LocalArrayCreate(array, counts, intptr, &amp;
                      lboounds, ubounds, rc)
</PRE>
Changes in ESMF:

<P>
The routine would need to be further overloaded to support call arguments <TT>counts, lbounds, ubounds,</TT> and <TT>rc</TT> each being of either 4-byte or 8-byte size. In order to provide for all possible combinations of data sizes for these 4 integer parameters, the number of overloads would increase from 42 to <!-- MATH
 $[42*(2**4)]=672$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="140" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img100.png"
 ALT="$[42*(2**4)]=672$"></SPAN>, which explains why support of this option is not practical. 

<P>

<P>

<P>

<H2><A NAME="SECTION000816000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">16</SPAN> Scripts: Script Coding Standard</A>
</H2>

<P>

<H3><A NAME="SECTION000816100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Content Rules</A>
</H3>

<P>

<UL>
<LI><B>Prologues</B> Scripts included in the ESMF should be identified 
with a header that includes the name of the script, a description, an 
interface summary, the author and the origination date.

<P>
</LI>
</UL>

<P>

<P>

<P>

<H2><A NAME="SECTION000817000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">17</SPAN> Lang: Interlanguage Coding Conventions</A>
</H2>

<P>
ESMF is written in a combination of C/C++ and Fortran.
Techniques used in ESMF for interfacing C/C++ and Fortran codes
are described in the <I>ESMF Implementation Report</I>[<A
 HREF="node12.html#bib:ESMFimplrep">9</A>],
which is available via the <B>Users</B> tab on the ESMF website.  These
techniques, which address issues of memory allocation, passing
objects across language boundaries, handling optional arguments,
and so on, are general and have been applied to multiple projects.  

<P>
We distinguish between these techniques and the conventions used
by the ESMF project when interfacing C/C++ and Fortran.  These
conventions, which represent specific implementation choices,
require additional input and explanation, and this section in 
the <I>Guide</I> is currently incomplete.  The list below outlines
the topics that we intend to address:

<P>

<OL>
<LI>Logicals across language interfaces
</LI>
<LI>Optional arguments across language interfaces
</LI>
<LI>Layering Fortran on top of C/C++
</LI>
<LI>Layering C/C++ on top of Fortran
</LI>
</OL>

<P>

<H3><A NAME="SECTION000817100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Optional Arguments Across Language Interfaces</A>
</H3>

<P>
It is often necessary for C++ code to call Fortran code where optional arguments are
used.  By convention, most Fortran compilers use a C NULL for the argument address
to indicate that the optional argument is missing.

<P>
The following Fortran subroutine has optional arguments.  Note that Fortran 77 style
adjustable size array dimensioning is used for array b:

<P>
<PRE>
    subroutine f_ESMF_SomeProcedure (a, b, b_size, rc)
      implicit none
      real,    intent(in),  optional :: a
      integer, intent(in)            :: b_size
      real,    intent(out), optional :: b(b_size)
      integer, intent(out), optional :: rc

      if (present (a)) then
        ... = a
      end if
      ...
      if (present (b)) then
        b(i) = ...
      end if
      ...
      if (present (rc)) then
        rc = localrc
      end if
    end subroutine f_ESMF_SomeProcedure
</PRE>

<P>
When calling the above from C++, NULL can be used to indicate missing arguments:

<P>
<PRE>
    extern "C" {
        FTN_X(f_esmf_someprocedure)(float &amp;a, float &amp;b, int &amp;b_size, int &amp;rc);
    }
    ...
    // array b not present, so use NULL.
    int b_size = 0;
    FTN_X(f_esmf_someprocedure)(&amp;a, NULL, &amp;b_size, &amp;rc);
    ...
    // array b is present.  Pass size and address.
    float *b = new float[20];
    int b_size = 20;
    FTN_X(f_esmf_someprocedure)(&amp;a, b, &amp;b_size, &amp;rc);
</PRE>

<P>

<H2><A NAME="SECTION000818000000000000000"></A>
<A NAME="sec:code_conv_cam"></A>
<BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">18</SPAN> Lang: Fortran Coding Standard
</H2>

<P>
This standard is derived from the <A NAME="tex2html23"
  HREF="http://www.gfdl.gov/~vb/FMSManual">GFDL Flexible
  Modeling System Developers'
  Manual</A>
and the
<A NAME="tex2html24"
  HREF="http://www.cesm.ucar.edu">coding standard for the NCAR Community Atmospheric
  Model(CAM)</A>
developed by Jim Rosinski. Other documents containing coding
conventions include the "Report on Column Physics Standards"
(<A NAME="tex2html25"
  HREF="http://nsipp.gsfc.nasa.gov/infra">http://nsipp.gsfc.nasa.gov/infra/</A>)
and "European Standards For Writing and Documenting Exchangeable
Fortran 90 Code"
(<A NAME="tex2html26"
  HREF="http://nsipp.gsfc.nasa.gov/infra/eurorules.html">http://nsipp.gsfc.nasa.gov/infra/eurorules.html</A>).

<P>
The conventions assume the use of embedded documentation extractor
<A NAME="tex2html27"
  HREF="http://dao.gsfc.nasa.gov/software/protex">ProTeX</A>.

<P>

<H3><A NAME="SECTION000818100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Content Rules</A>
</H3>

<P>
<DL>
<DT><STRONG>F95 Standard</STRONG></DT>
<DD>ESMF will adhere to the Fortran 95 language
  standard&nbsp;[<A
 HREF="node12.html#ref:f95">6</A>], to the extent that it is implemented.

<P>

<OL>
<LI>All elements of the ANSI <TT>f95</TT> standard are permitted,
  with a few listed exceptions whose use is discouraged or prohibited.
  These are enumerated below.
</LI>
<LI>Language extensions are severely restricted. They may be used in
  limited fashion, provided a pressing reason exists (e.g major
  performance enhancement using a particular proprietary software
  system), <SPAN  CLASS="textit">and</SPAN> an alternate formulation is provided for compiling
  environments that do not permit the extension.
</LI>
<LI>The standard may change in the future, e.g to Fortran 2003, or
  any other, after review.
</LI>
</OL>

<P>
</DD>
<DT><STRONG>Preprocessing</STRONG></DT>
<DD>The use of preprocessing directives is intended
  for language extensions, and in some circumstances, it is used to
  generate module procedures under a generic interface for variables
  of different type, kind and rank (thus circumventing <TT>f90</TT>'s
  strict typing), while maintaining a single copy of the source.

<P>
The use of preprocessor directives in ESMF is permitted under the
following conditions:

<P>

<OL>
<LI>Where language extensions are used, <TT>cpp</TT>
  <TT>#ifdef</TT> statements must be used to shield lines from
  compilers that may not recognize them.
</LI>
<LI>Use is restricted to the built-in preprocessor of the
  <TT>f90</TT> compiler (based on <TT>cpp</TT>), and cannot be based
  on external preprocessors such as <TT>m4</TT>. This condition may be
  relaxed on platforms where the builtin preprocessor proves to be
  inadequate.
</LI>
<LI>Use is restricted to short code sections (a useful rule of thumb
  is that an <TT>#ifdef</TT> and the matching <TT>#endif</TT> should
  both be visible on a single 80x24 editor
  window).
</LI>
<LI>Tokens must be uppercase.
</LI>
<LI>Owing to restrictions in certain compilers, preprocessor
  variable names may not exceed 31 characters.
</LI>
</OL>

<P>
</DD>
<DT><STRONG>Source files</STRONG></DT>
<DD>Each source code file defines a single
  <TT>program</TT> or <TT>f90 module</TT>. The filename must be the
  same as the module name with the following extensions:
<PRE>
filename.f - fixed format, no preprocessing.
filename.F - free format, no preprocessing.


filename.f90 - fixed format, with preprocessing.
filename.F90 - free format, with preprocessing.
</PRE>
</DD>
<DT><STRONG>Module name</STRONG></DT>
<DD>The names of Fortran procedure interfaces will be
  preceded by <TT>ESMF_</TT>.  Class names will normally be the first
  item in a procedure name, followed by the specific method, e.g.,
  <TT>ESMF_TimeMgrGetCurrDate</TT>. Compilers produce object code for
  each source file, usually with a <TT>.o</TT> extension. During
  linking, it is required that each object file have a unique name;
  extremely generic names must be avoided. This convention is used to
  prevent name collisions.

<P>
</DD>
<DT><STRONG>Scope</STRONG></DT>
<DD>Each module in ESMF must have <TT>private</TT> scope by
  default.  Each public interface therefore needs to be explicitly
  published.

<P>
</DD>
<DT><STRONG>Typing</STRONG></DT>
<DD>The use of implicit typing is forbidden. Every module
  must contain the line:

<P>
<PRE>
implicit none
</PRE>

<P>
in the module header, and every variable explicitly declared.

<P>
There are a few restrictions on the length of a character variable:

<P>

<OL>
<LI>Character variables that are <SPAN  CLASS="textit">arguments</SPAN> to routines should
  be declared with <TT>(len=*)</TT>. It has been observed that
  compilers are inconsistent in their &ldquo;padding&rdquo; practices, and the
  standard is silent on the subject.
</LI>
<LI>It is recommended that other character variables be declared
  with length a multiple of 4, or preferably 8. This is a
  <SPAN  CLASS="textit">requirement</SPAN> for variables that are components of derived
  types, since it has been observed that without these restriction,
  there are occasional word alignment fault errors generated.
</LI>
</OL>

<P>
</DD>
<DT><STRONG>Arguments</STRONG></DT>
<DD>The <TT>intent</TT> of arguments to subroutines and
  functions must be explictly specified.

<P>
</DD>
<DT><STRONG>Intrinsics</STRONG></DT>
<DD>The <TT>f90</TT> language provides a number of
  intrinsic functions for performing common operations. The use of the
  standard intrinsics is generally encouraged. Notes:

<P>

<OL>
<LI>The generic form of the intrinsic (e.g <TT>max()</TT>) must be
  used rather than the specific one (e.g <TT>dmax0()</TT>). This
  permits flexibility to later changes of type.
</LI>
<LI>Many of the intrinsic array operations have been found to be
  poorly optimized for performance (e.g <TT>reshape()</TT>,
  <TT>matmul()</TT>) since they have to be perfectly general. These
  must be used with care in code regions that are critical for
  performance.
</LI>
<LI>Several older standard intrinsic names have been declared
  obsolescent, and the current names are preferred (e.g
  <TT>modulo()</TT> instead of <TT>mod()</TT>, <TT>real()</TT> instead
  of <TT>float()</TT>).
</LI>
</OL>

<P>
</DD>
<DT><STRONG>Constants and magic numbers</STRONG></DT>
<DD>Shared constants
  must never be hardcoded: instead mnemonically useful names are
  required. This applies to physical constants such as the universal
  gas constant, gravity, and so on, but also for flags used to select
  code options. In particular, this coding construct:

<P>
<PRE>
subroutine advection(flag)
integer, intent(in) :: flag
...
if( flag.EQ.1 )then
    call upwind_advection( ... )
else if( flag.EQ.2 )then
    call smolar_advection( ... )
...
endif
end subroutine advection
...
call advection(1)
</PRE>

<P>
is discouraged. This should instead be written as:

<P>
<PRE>
integer, parameter :: UPWIND=1, SMOLAR=2
...
subroutine advection(flag)
integer, intent(in) :: flag
...
if( flag.EQ.UPWIND )then
    call upwind_advection( ... )
else if( flag.EQ.SMOLAR )then
    call smolar_advection( ... )
...
endif
end subroutine advection
...
call advection(UPWIND)
</PRE>

<P>
</DD>
<DT><STRONG>Procedural interfaces</STRONG></DT>
<DD>Procedural interfaces are the public
  interfaces to subroutines and functions provided by a module.

<P>

<OL>
<LI>Procedures that perform the same function on different datatypes
  (e.g of differing type, kind or rank) should have a single generic
  interface. When the generic public interface exists, all the
  module procedures that constitute it must be private.
</LI>
<LI>Optional arguments, if any, should <SPAN  CLASS="textit">follow</SPAN> the required
  arguments, so that the procedure may be called without explicit
  argument keywords.  Optional arguments in all new public interfaces <SPAN  CLASS="textit">must</SPAN>
  have a <TT>keywordEnforcer</TT> argument separating the required arguments from the
  optional arguments.  This requires the caller to specify keywords for the arguments,
  allowing for upward compatibility as new optional arguments are added over time.
</LI>
<LI>Argument lists should be as short as possible. If necessary, related elements of
  an argument list should be encapsulated in a public derived type.
</LI>
</OL>

<P>
</DD>
<DT><STRONG>Deprecated elements of the standard</STRONG></DT>
<DD>Deprecated language
  elements include:

<P>

<OL>
<LI>implicit typing.  Use <TT>implicit none</TT> in all modules and external
  procedures.
</LI>
<LI><TT>common</TT> blocks. Use module global variables instead;
</LI>
<LI>assumed size arrays: i.e declarations of the form <TT>a(*)</TT>
  or <TT>a(1)</TT> with the intention of over-indexing. This can
  inhibit effective bounds-checking at compile- and runtime.
</LI>
<LI><TT>STOP</TT> statements: this can generate single-processor
  exits in some parallel environments;
</LI>
<LI>array syntax. Though compact and concise, many compilers have
  trouble generating efficient code from source written in this
  notation.
</LI>
</OL>

<P>
</DD>
<DT><STRONG>mkmf</STRONG></DT>
<DD>The
  <A NAME="tex2html28"
  HREF="http://www.gfdl.noaa.gov/~vb/mkmf.html">mkmf</A>
tool
  may be used to generate Makefiles with correct dependencies for F90
  and hybrid-language codes. This places minor restrictions on
  <TT>module</TT> and <TT>use</TT> statements: these declarations must
  be on a single line, and the use of continuation lines, e.g:

<P>
<PRE>
module &amp;
  module_name
use &amp;
  module_name
</PRE>

<P>
is forbidden.

<P>
</DD>
<DT><STRONG>Use statement</STRONG></DT>
<DD><OL>
<LI>The <TT>use</TT> statement must appear on the same line as
  the module name, i.e, do not use:

<P>
<PRE>
use &amp;
  module_name
</PRE>

<P>
This is to be consistent with the dependency analysis performed by
  <TT>mkmf</TT> outlined above.
</LI>
<LI>The <TT>use, only:</TT> clause is <SPAN  CLASS="textit">required</SPAN> so that all
  imported elements are explicitly declared.
</LI>
<LI>Variables imported by a <TT>use</TT> statement must not be
  modified by the importing module.
</LI>
<LI>Modules cannot publish variables and interfaces imported from
  another module. Thus, each public element of a module is only
  available through that module. 
</LI>
</OL>

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION000818200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Style Rules</A>
</H3>

<P>
Style is somewhat personal, and it would be needlessly restrictive to
attempt to impose style requirements. These are recommendations which
we believe will lead to pleasant encounters with clear, legible and
understandable code. The only style requirement we place is that of
<I>consistency</I>: a single code unit is required to be rigorous in
using the author's preferred set of stylistic attributes.  It is not
onerous to follow a style: modern editors have many language-aware
features designed to produce a consistent, customizable style.

<P>
Style recommendations include the following:

<P>

<OL>
<LI>The use of free format;
</LI>
<LI>The use of do...end do constructs (as opposed to numbered loops
  as in Fortran-IV);
</LI>
<LI>The use of proper indentation of loops and blocks;
</LI>
<LI>The liberal use of blank lines to delimit code blocks;
</LI>
<LI>The use of comment lines of dashes or dots to delimit
  procedures;
</LI>
<LI>The use of useful descriptive names for physically meaningful
  variables; short conventional names for iterators (e.g
  <TT>(i,j,k)</TT> for spatial grid indices);
</LI>
<LI>The use of uppercase for constants (parameters), lowercase for
  variables;
</LI>
<LI>The use of verbose syntax on <TT>end</TT> statements (e.g
  <TT>subroutine&nbsp;sub...end&nbsp;subroutine&nbsp;sub</TT> rather than
  <TT>subroutine&nbsp;sub...end</TT>);
</LI>
<LI>The use of short comments on the same line to identify
  variables; longer comments in well-delineated blocks to describe
  what a portion of code is doing;
</LI>
<LI>Compact code units: long procedures should be split up if
  possible. 200 lines is a rule-of-thumb procedure length limit.
</LI>
</OL>

<P>

<H2><A NAME="SECTION000819000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">19</SPAN> Lang: C/C++ Coding Standard</A>
</H2>

<P>

<UL>
<LI><B>Use of namespaces</B>
To avoid conflict in symbols, ESMF C++ code will utilize namespaces to
add either ESMC (interface code) or ESMCI to symbol names.

<P>
Example: 

<P>
The header file for an <I>ESMC_Widget</I> is as follows:
<PRE>
**file ESMCI_Widget.h
// Internal Widget esmf class
#ifndef ESMCI_Widget_h
#define ESMCI_Widget_h

namespace ESMCI {

class Widget {
public:
Widget();
~Widget();
void Manufacture();
};

} // namespace ESMCI
</PRE>

<P>
The implementation file is:
<PRE>
***file ESMCI_Widget.C
#include &lt;ESMCI_Widget.h&gt;

namespace ESMCI {

Widget::Widget() {
...
}
Widget::~Widget() {
...
}
void Widget::Manufacture() {
...
}

} // namespace ESMCI
</PRE>

<P>
Lastly, when this object is used from C interface code, the following constructs are used:

<P>
<PRE>
*** file ESMC_SomeInterface_F.C
#include &lt;ESMCI_Widget.h&gt;

extern "C" {
// this cannot be in the ESMCI namespace, else it would change the
// linkage. We have two choices: 1) add using namespace ESMCI and
// then use Widget, else 2) qualify Widget, ESMCI::Widget
void FTN(c_esmc_someinterface)(
ESMCI::Widget **wptr, int *rc){
#undef ESMC_METHOD
#define ESMC_METHOD "c_esmc_someinterface()"
if (rc!=NULL)
*rc = ESMC_RC_NOT_IMPL;

.....
(*wptr)-&gt;Manufacture();

}

} // extern "C"
</PRE>

<P>
</LI>
<LI><B>Protex Prologues</B>  Each C or C++ function, subroutine, or 
module will include a prologue instrumented for use with the
  <A NAME="tex2html29"
  HREF="http://dao.gsfc.nasa.gov/software/protex">ProTeX auto-documentation script</A>.  Prologue templates are
included in the ESMF document templates package described in 
Section&nbsp;<A HREF="#sec:code_templates">7.1</A>.  This convention may be relaxed
when absorbing large external code bases that may have their own
documentation conventions.

<P>
</LI>
</UL>

<P>

<P>

<P>

<H2><A NAME="SECTION000820000000000000000"></A>
<A NAME="sec:tagging"></A>
<BR>
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">20</SPAN> Repo: Source Code Naming and Tagging Conventions
</H2>

<P>
We provide two types of releases, public and internal, with similar tagging conventions.

<P>

<H3><A NAME="SECTION000820100000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Public Releases</A>
</H3>
Public releases are each given a branch created from the main CVS repository ESMF trunk. The tagging convention
for public releases is
<TT>ESMF_*_*_*r[p#]</TT>, e.g., <TT>ESMF_0_2_1r</TT>, where the first digit represents a major release, the
second digit an incremental release, the third digit a routine update, and an official release <TT>r</TT>.
Subsequent patches to the release are identified with the letter <TT>p</TT> followed by the patch number,
e.g., <TT>ESMF_1_0_0rp2</TT>. Patches are tagged on the release branch.

<P>

<H3><A NAME="SECTION000820200000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Internal Releases</A>
</H3>
ESMF software internal releases are identified as tags on the CVS main trunk.
The tagging convention for internal releases is
<TT>ESMF_*_*_*</TT>, e.g., <TT>ESMF_1_0_1</TT>, where the first digit represents a
major release, the second digit an incremental release, and the third digit a routine update.

<P>

<P>

<H2><A NAME="SECTION000821000000000000000">
<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">21</SPAN> Data Management Conventions</A>
</H2>

<P>
The ESMF team will adopt the Climate and Forecast (CF) Metadata 
conventions.  These are available at:
<BR>
<A NAME="tex2html30"
  HREF="http://www.unidata.ucar.edu/software/netcdf/conventions.html"><B>http://www.unidata.ucar.edu/software/netcdf/conventions.html</B></A>
<P>

<P>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html569"
  HREF="node9.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html565"
  HREF="dev_guide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html559"
  HREF="node7.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html567"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html570"
  HREF="node9.html">8 Tracking and Metrics</A>
<B> Up:</B> <A NAME="tex2html566"
  HREF="dev_guide.html">dev_guide</A>
<B> Previous:</B> <A NAME="tex2html560"
  HREF="node7.html">6 Test Harness</A>
 &nbsp; <B>  <A NAME="tex2html568"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
