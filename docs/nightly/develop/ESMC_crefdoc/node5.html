<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>4 Infrastructure: Fields and Grids</TITLE>
<META NAME="description" CONTENT="4 Infrastructure: Fields and Grids">
<META NAME="keywords" CONTENT="ESMC_crefdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMC_crefdoc.css">

<LINK REL="next" HREF="node6.html">
<LINK REL="previous" HREF="node4.html">
<LINK REL="up" HREF="ESMC_crefdoc.html">
<LINK REL="next" HREF="node6.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html628"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html624"
  HREF="ESMC_crefdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html618"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html626"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html629"
  HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html625"
  HREF="ESMC_crefdoc.html">ESMC_crefdoc</A>
<B> Previous:</B> <A NAME="tex2html619"
  HREF="node4.html">3 Superstructure</A>
 &nbsp; <B>  <A NAME="tex2html627"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><A NAME="tex2html630"
  HREF="node5.html#SECTION05010000000000000000"><SPAN CLASS="arabic">15</SPAN> Overview of Infrastructure Data Handling</A>
<UL>
<LI><A NAME="tex2html631"
  HREF="node5.html#SECTION05011000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Infrastructure Data Classes</A>
<LI><A NAME="tex2html632"
  HREF="node5.html#SECTION05012000000000000000"><SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">2</SPAN> Design and Implementation Notes</A>
</UL>
<LI><A NAME="tex2html633"
  HREF="node5.html#SECTION05020000000000000000"><SPAN CLASS="arabic">16</SPAN> Field Class</A>
<UL>
<LI><A NAME="tex2html634"
  HREF="node5.html#SECTION05021000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html635"
  HREF="node5.html#SECTION05022000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html636"
  HREF="node5.html#SECTION05022100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_REGRIDMETHOD</A>
</UL>
<LI><A NAME="tex2html637"
  HREF="node5.html#SECTION05023000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html638"
  HREF="node5.html#SECTION05023100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field create and destroy</A>
</UL>
<LI><A NAME="tex2html639"
  HREF="node5.html#SECTION05024000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html640"
  HREF="node5.html#SECTION05024100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_FieldCreateGridArraySpec</A>
<LI><A NAME="tex2html641"
  HREF="node5.html#SECTION05024200000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_FieldCreateGridTypeKind</A>
<LI><A NAME="tex2html642"
  HREF="node5.html#SECTION05024300000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_FieldCreateMeshArraySpec</A>
<LI><A NAME="tex2html643"
  HREF="node5.html#SECTION05024400000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_FieldCreateMeshTypeKind</A>
<LI><A NAME="tex2html644"
  HREF="node5.html#SECTION05024500000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_FieldCreateLocStreamArraySpec</A>
<LI><A NAME="tex2html645"
  HREF="node5.html#SECTION05024600000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_FieldCreateLocStreamTypeKind</A>
<LI><A NAME="tex2html646"
  HREF="node5.html#SECTION05024700000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMC_FieldDestroy</A>
<LI><A NAME="tex2html647"
  HREF="node5.html#SECTION05024800000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMC_FieldGetArray</A>
<LI><A NAME="tex2html648"
  HREF="node5.html#SECTION05024900000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMC_FieldGetMesh</A>
<LI><A NAME="tex2html649"
  HREF="node5.html#SECTION050241000000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMC_FieldGetPtr</A>
<LI><A NAME="tex2html650"
  HREF="node5.html#SECTION050241100000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMC_FieldGetBounds</A>
<LI><A NAME="tex2html651"
  HREF="node5.html#SECTION050241200000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMC_FieldPrint</A>
<LI><A NAME="tex2html652"
  HREF="node5.html#SECTION050241300000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMC_FieldRegridGetArea</A>
<LI><A NAME="tex2html653"
  HREF="node5.html#SECTION050241400000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMC_FieldRegridStore</A>
<LI><A NAME="tex2html654"
  HREF="node5.html#SECTION050241500000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMC_FieldRegridStoreFile</A>
<LI><A NAME="tex2html655"
  HREF="node5.html#SECTION050241600000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMC_FieldRegrid</A>
<LI><A NAME="tex2html656"
  HREF="node5.html#SECTION050241700000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMC_FieldRegridRelease</A>
<LI><A NAME="tex2html657"
  HREF="node5.html#SECTION050241800000000000000"><SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMC_FieldSMMStore</A>
</UL>
</UL>
<LI><A NAME="tex2html658"
  HREF="node5.html#SECTION05030000000000000000"><SPAN CLASS="arabic">17</SPAN> Array Class</A>
<UL>
<LI><A NAME="tex2html659"
  HREF="node5.html#SECTION05031000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html660"
  HREF="node5.html#SECTION05032000000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html661"
  HREF="node5.html#SECTION05032100000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_ArrayCreate</A>
<LI><A NAME="tex2html662"
  HREF="node5.html#SECTION05032200000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_ArrayDestroy</A>
<LI><A NAME="tex2html663"
  HREF="node5.html#SECTION05032300000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_ArrayGetName</A>
<LI><A NAME="tex2html664"
  HREF="node5.html#SECTION05032400000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_ArrayGetPtr</A>
<LI><A NAME="tex2html665"
  HREF="node5.html#SECTION05032500000000000000"><SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_ArrayPrint</A>
</UL>
</UL>
<LI><A NAME="tex2html666"
  HREF="node5.html#SECTION05040000000000000000"><SPAN CLASS="arabic">18</SPAN> ArraySpec Class</A>
<UL>
<LI><A NAME="tex2html667"
  HREF="node5.html#SECTION05041000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html668"
  HREF="node5.html#SECTION05042000000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html669"
  HREF="node5.html#SECTION05042100000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_ArraySpecGet</A>
<LI><A NAME="tex2html670"
  HREF="node5.html#SECTION05042200000000000000"><SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_ArraySpecSet</A>
</UL>
</UL>
<LI><A NAME="tex2html671"
  HREF="node5.html#SECTION05050000000000000000"><SPAN CLASS="arabic">19</SPAN> Grid Class</A>
<UL>
<LI><A NAME="tex2html672"
  HREF="node5.html#SECTION05051000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A NAME="tex2html673"
  HREF="node5.html#SECTION05051100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Representation in ESMF</A>
<LI><A NAME="tex2html674"
  HREF="node5.html#SECTION05051200000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Grids</A>
<LI><A NAME="tex2html675"
  HREF="node5.html#SECTION05051300000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Grid Topologies and Periodicity</A>
<LI><A NAME="tex2html676"
  HREF="node5.html#SECTION05051400000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Grid Distribution</A>
<LI><A NAME="tex2html677"
  HREF="node5.html#SECTION05051500000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Coordinates</A>
<LI><A NAME="tex2html678"
  HREF="node5.html#SECTION05051600000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Coordinate Specification and Generation</A>
<LI><A NAME="tex2html679"
  HREF="node5.html#SECTION05051700000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> Staggering</A>
<LI><A NAME="tex2html680"
  HREF="node5.html#SECTION05051800000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> Masking</A>
</UL>
<LI><A NAME="tex2html681"
  HREF="node5.html#SECTION05052000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html682"
  HREF="node5.html#SECTION05052100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_COORDSYS</A>
<LI><A NAME="tex2html683"
  HREF="node5.html#SECTION05052200000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_GRIDITEM</A>
<LI><A NAME="tex2html684"
  HREF="node5.html#SECTION05052300000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_GRIDSTATUS</A>
<LI><A NAME="tex2html685"
  HREF="node5.html#SECTION05052400000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_POLEKIND</A>
<LI><A NAME="tex2html686"
  HREF="node5.html#SECTION05052500000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_STAGGERLOC</A>
<LI><A NAME="tex2html687"
  HREF="node5.html#SECTION05052600000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_FILEFORMAT</A>
</UL>
<LI><A NAME="tex2html688"
  HREF="node5.html#SECTION05053000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html689"
  HREF="node5.html#SECTION05054000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html690"
  HREF="node5.html#SECTION05054100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Topology</A>
</UL>
<LI><A NAME="tex2html691"
  HREF="node5.html#SECTION05055000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API: General Grid Methods</A>
<UL>
<LI><A NAME="tex2html692"
  HREF="node5.html#SECTION05055100000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_GridCreateNoPeriDim</A>
<LI><A NAME="tex2html693"
  HREF="node5.html#SECTION05055200000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_GridCreate1PeriDim</A>
<LI><A NAME="tex2html694"
  HREF="node5.html#SECTION05055300000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_GridCreateCubedSphere</A>
<LI><A NAME="tex2html695"
  HREF="node5.html#SECTION05055400000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_GridCreateFromFile</A>
<LI><A NAME="tex2html696"
  HREF="node5.html#SECTION05055500000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_GridDestroy</A>
<LI><A NAME="tex2html697"
  HREF="node5.html#SECTION05055600000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_GridAddItem</A>
<LI><A NAME="tex2html698"
  HREF="node5.html#SECTION05055700000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMC_GridGetItem</A>
<LI><A NAME="tex2html699"
  HREF="node5.html#SECTION05055800000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMC_GridAddCoord</A>
<LI><A NAME="tex2html700"
  HREF="node5.html#SECTION05055900000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMC_GridGetCoord</A>
<LI><A NAME="tex2html701"
  HREF="node5.html#SECTION050551000000000000000"><SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMC_GridGetCoordBounds</A>
</UL>
</UL>
<LI><A NAME="tex2html702"
  HREF="node5.html#SECTION05060000000000000000"><SPAN CLASS="arabic">20</SPAN> Mesh Class</A>
<UL>
<LI><A NAME="tex2html703"
  HREF="node5.html#SECTION05061000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A NAME="tex2html704"
  HREF="node5.html#SECTION05061100000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh Representation in ESMF</A>
<LI><A NAME="tex2html705"
  HREF="node5.html#SECTION05061200000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Meshes</A>
</UL>
<LI><A NAME="tex2html706"
  HREF="node5.html#SECTION05062000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html707"
  HREF="node5.html#SECTION05062100000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_MESHELEMTYPE</A>
<LI><A NAME="tex2html708"
  HREF="node5.html#SECTION05062200000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_FILEFORMAT</A>
</UL>
<LI><A NAME="tex2html709"
  HREF="node5.html#SECTION05063000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html710"
  HREF="node5.html#SECTION05063100000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_MeshGetMOAB</A>
<LI><A NAME="tex2html711"
  HREF="node5.html#SECTION05063200000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_MeshSetMOAB</A>
<LI><A NAME="tex2html712"
  HREF="node5.html#SECTION05063300000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_MeshAddElements</A>
<LI><A NAME="tex2html713"
  HREF="node5.html#SECTION05063400000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_MeshAddNodes</A>
<LI><A NAME="tex2html714"
  HREF="node5.html#SECTION05063500000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_MeshCreate</A>
<LI><A NAME="tex2html715"
  HREF="node5.html#SECTION05063600000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_MeshCreateFromFile</A>
<LI><A NAME="tex2html716"
  HREF="node5.html#SECTION05063700000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMC_MeshGetCoord</A>
<LI><A NAME="tex2html717"
  HREF="node5.html#SECTION05063800000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMC_MeshGetElemCoord</A>
<LI><A NAME="tex2html718"
  HREF="node5.html#SECTION05063900000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMC_MeshGetConnectivity</A>
<LI><A NAME="tex2html719"
  HREF="node5.html#SECTION050631000000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMC_MeshDestroy</A>
<LI><A NAME="tex2html720"
  HREF="node5.html#SECTION050631100000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMC_MeshFreeMemory</A>
<LI><A NAME="tex2html721"
  HREF="node5.html#SECTION050631200000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMC_MeshGetElementCount</A>
<LI><A NAME="tex2html722"
  HREF="node5.html#SECTION050631300000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMC_MeshGetNodeCount</A>
<LI><A NAME="tex2html723"
  HREF="node5.html#SECTION050631400000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMC_MeshGetOwnedElementCount</A>
<LI><A NAME="tex2html724"
  HREF="node5.html#SECTION050631500000000000000"><SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMC_MeshGetOwnedNodeCount</A>
</UL>
</UL>
<LI><A NAME="tex2html725"
  HREF="node5.html#SECTION05070000000000000000"><SPAN CLASS="arabic">21</SPAN> XGrid Class</A>
<UL>
<LI><A NAME="tex2html726"
  HREF="node5.html#SECTION05071000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html727"
  HREF="node5.html#SECTION05072000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN> Restrictions and Future Work</A>
<UL>
<LI><A NAME="tex2html728"
  HREF="node5.html#SECTION05072100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Restrictions and Future Work</A>
</UL>
<LI><A NAME="tex2html729"
  HREF="node5.html#SECTION05073000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html730"
  HREF="node5.html#SECTION05074000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html731"
  HREF="node5.html#SECTION05074100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_XGridCreate</A>
<LI><A NAME="tex2html732"
  HREF="node5.html#SECTION05074200000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_XGridDestroy</A>
<LI><A NAME="tex2html733"
  HREF="node5.html#SECTION05074300000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_XGridGetSideAGridCount</A>
<LI><A NAME="tex2html734"
  HREF="node5.html#SECTION05074400000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_XGridGetSideAMeshCount</A>
<LI><A NAME="tex2html735"
  HREF="node5.html#SECTION05074500000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_XGridGetSideBGridCount</A>
<LI><A NAME="tex2html736"
  HREF="node5.html#SECTION05074600000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_XGridGetSideBMeshCount</A>
<LI><A NAME="tex2html737"
  HREF="node5.html#SECTION05074700000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMC_XGridGetDimCount</A>
<LI><A NAME="tex2html738"
  HREF="node5.html#SECTION05074800000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMC_XGridGetElementCount</A>
<LI><A NAME="tex2html739"
  HREF="node5.html#SECTION05074900000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMC_XGridGetMesh</A>
<LI><A NAME="tex2html740"
  HREF="node5.html#SECTION050741000000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMC_XGridGetElementArea</A>
<LI><A NAME="tex2html741"
  HREF="node5.html#SECTION050741100000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMC_XGridGetElementCentroid</A>
<LI><A NAME="tex2html742"
  HREF="node5.html#SECTION050741200000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMC_XGridGetSparseMatA2X</A>
<LI><A NAME="tex2html743"
  HREF="node5.html#SECTION050741300000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMC_XGridGetSparseMatA2X</A>
<LI><A NAME="tex2html744"
  HREF="node5.html#SECTION050741400000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMC_XGridGetSparseMatB2X</A>
<LI><A NAME="tex2html745"
  HREF="node5.html#SECTION050741500000000000000"><SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMC_XGridGetSparseMatB2X</A>
</UL>
</UL>
<LI><A NAME="tex2html746"
  HREF="node5.html#SECTION05080000000000000000"><SPAN CLASS="arabic">22</SPAN> DistGrid Class</A>
<UL>
<LI><A NAME="tex2html747"
  HREF="node5.html#SECTION05081000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html748"
  HREF="node5.html#SECTION05082000000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html749"
  HREF="node5.html#SECTION05082100000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_DistGridCreate</A>
<LI><A NAME="tex2html750"
  HREF="node5.html#SECTION05082200000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_DistGridDestroy</A>
<LI><A NAME="tex2html751"
  HREF="node5.html#SECTION05082300000000000000"><SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_DistGridPrint</A>
</UL>
</UL>
<LI><A NAME="tex2html752"
  HREF="node5.html#SECTION05090000000000000000"><SPAN CLASS="arabic">23</SPAN> RouteHandle Class</A>
<UL>
<LI><A NAME="tex2html753"
  HREF="node5.html#SECTION05091000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html754"
  HREF="node5.html#SECTION05092000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<LI><A NAME="tex2html755"
  HREF="node5.html#SECTION05093000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html756"
  HREF="node5.html#SECTION05094000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html757"
  HREF="node5.html#SECTION05095000000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html758"
  HREF="node5.html#SECTION05095100000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_RouteHandleCreateFromFile</A>
<LI><A NAME="tex2html759"
  HREF="node5.html#SECTION05095200000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_RouteHandlePrint</A>
<LI><A NAME="tex2html760"
  HREF="node5.html#SECTION05095300000000000000"><SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_RouteHandleWrite</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION05000000000000000000">
<SPAN CLASS="arabic">4</SPAN> Infrastructure: Fields and Grids</A>
</H1>


<P>

<H1><A NAME="SECTION05010000000000000000">
<SPAN CLASS="arabic">15</SPAN> Overview of Infrastructure Data Handling</A>
</H1>

<P>
The ESMF infrastructure data classes are part of the framework's 
hierarchy of structures for handling Earth system model data and 
metadata on parallel platforms.  The hierarchy is in complexity; the 
simplest data class in the infrastructure represents a distributed data
array and the most complex data class represents a bundle of physical 
fields that are discretized on the same grid.  However, the current C API 
does not support bundled data structures yet. Array and Field are the two
data classes offered by the ESMF C language binding.  Data class methods 
are called both from user-written code and from other classes 
internal to the framework. 

<P>
Data classes are distributed over <B>DE</B>s, or <B>Decomposition Elements</B>.  
A DE represents a piece of a decomposition.  A DELayout is a collection
of DEs with some associated connectivity that describes a specific 
distribution.  For example, the distribution of a grid divided 
into four segments in the x-dimension would be expressed in ESMF as
a DELayout with four DEs lying along an x-axis. This abstract concept 
enables a data decomposition to be defined in 
terms of threads, MPI processes, virtual decomposition elements, or
combinations of these without changes to user code.  This is a
primary strategy for ensuring optimal performance and portability
for codes using the ESMF for communications.

<P>
ESMF data classes provide a standard,
convenient way for developers to collect together information 
related to model or observational data.  The information assembled 
in a data class includes a data pointer, a set of attributes 
(e.g. units, although attributes can also be user-defined), and a 
description of an associated grid.  The same set of information within 
an ESMF data object can be used by the framework to arrange 
intercomponent data transfers, to perform I/O, for communications
such as gathers and scatters, for simplification of interfaces 
within user code, for debugging, and for other functions.  
This unifies and organizes codes overall so that the user need not
define different representations of metadata for the same field 
for I/O and for component coupling.  

<P>
Since it is critical that users be able to introduce ESMF into their
codes easily and incrementally, ESMF data classes can be created based 
on native Fortran pointers.  Likewise, there are methods for retrieving 
native Fortran pointers from within ESMF data objects.  This allows
the user to perform allocations using ESMF, and to retrieve Fortran
arrays later for optimized model calculations.  The ESMF data classes 
do not have associated differential operators or other mathematical 
methods.

<P>
For flexibility, it is not necessary to build an ESMF data object 
all at once.  For example, it's possible to create a 
field but to defer allocation of the associated field data until 
a later time.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchy of data structures designed specifically for the Earth 
system domain and high performance, parallel computing.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multi-use ESMF structures simplify user code overall.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Data objects support incremental construction and deferred allocation.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Native Fortran arrays can be associated with or retrieved from ESMF data
objects, for ease of adoption, convenience, and performance.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION05011000000000000000">
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Infrastructure Data Classes</A>
</H2>

<P>
The main classes that are used for model and observational data manipulation
are as follows:

<P>

<UL>
<LI><B>Array</B>  An ESMF Array contains a data pointer, 
information about its associated datatype, precision, and 
dimension.  

<P>
Data elements in Arrays are partitioned into categories 
defined by the role the data element plays in distributed halo 
operations.  Haloing - sometimes called ghosting - is the 
practice of copying portions of array data to multiple memory 
locations to ensure that data dependencies can be satisfied 
quickly when performing a calculation.  ESMF Arrays contain 
an <B>exclusive</B> domain, which contains data elements
updated exclusively and definitively by a given DE; a 
<B>computational</B> domain, which contains all data elements
with values that are updated by the DE in computations; and 
a <B>total</B> domain, which includes both the computational 
domain and data elements from other DEs which may be read 
but are not updated in computations.

<P>
</LI>
<LI><B>Field</B>  A Field holds model and/or observational 
data together with its underlying grid or set of spatial 
locations.  It provides methods for configuration, 
initialization, setting and retrieving data values, 
data I/O, data regridding, and manipulation of attributes.

<P>
</LI>
</UL>

<P>

<P>

<H2><A NAME="SECTION05012000000000000000">
<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">2</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>In communication methods such as Regrid, Redist, Scatter, etc. 
the Field code cascades down through the Array code, so 
that the actual implementation exist in only one place in the source.

<P>
</LI>
</OL>

<H1><A NAME="SECTION05020000000000000000">
<SPAN CLASS="arabic">16</SPAN> Field Class</A>
</H1>

<H2><A NAME="SECTION05021000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
An ESMF Field represents a physical field, such as temperature.
The motivation for including Fields in ESMF is that bundles of 
Fields are the entities that are normally exchanged when coupling
Components.  

<P>
The ESMF Field class contains distributed and discretized field data, a reference 
to its associated grid, and metadata.  The Field class stores the grid <I>staggering</I>
for that physical field.
This is the relationship of how the data array of a field maps onto a grid 
(e.g. one item per
cell located at the cell center, one item per cell located at the NW
corner,  one item per cell vertex, etc.).  This means that different Fields
which are on the same underlying ESMF Grid but have different
staggerings can share the same Grid object without needing to replicate
it multiple times. 

<P>
Fields can be added to States for use in inter-Component
data communications.

<P>
Field communication capabilities include: data redistribution, regridding, scatter,
gather, sparse-matrix multiplication, and halo update.  These are discussed
in more detail in the documentation for the specific method calls.  
ESMF does not currently support vector fields, so the components of 
a vector field must be stored as separate Field objects.  

<H2><A NAME="SECTION05022000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05022100000000000000"></A>
<A NAME="opt:cregridmethod"></A>
<BR>
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_REGRIDMETHOD
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>  
Specify which interpolation method to use during regridding. 

<P>
The type of this flag is:

<P>
<TT>type(ESMC_RegridMethod_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_REGRIDMETHOD_BILINEAR</STRONG></DT>
<DD>Bilinear interpolation. Destination value is a linear combination of the source values in the cell which contains the destination point. The weights for the linear combination are based on the distance of destination point from each source value. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_PATCH</STRONG></DT>
<DD>Higher-order patch recovery interpolation. Destination value is a weighted average of 2D polynomial patches constructed from cells surrounding the source cell which contains the destination point. This method typically results in better approximations to values and derivatives than bilinear. However, because of its larger stencil, it also results in a much larger interpolation matrix (and thus routeHandle) than the bilinear. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_NEAREST_STOD</STRONG></DT>
<DD>In this version of nearest neighbor interpolation each destination point is mapped to the closest source point. A given source point may go to multiple destination points, but no destination point will receive input from more than one source point. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_NEAREST_DTOS</STRONG></DT>
<DD>In this version of nearest neighbor interpolation each source point is mapped to the closest destination point. A given destination point may receive input from multiple source points, but no source point will go to more than one destination point. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_CONSERVE</STRONG></DT>
<DD>First-order conservative interpolation. The main purpose of this method is to preserve the integral of the field between the source and destination. 
      Will typically give a less accurate approximation to the individual field values than the bilinear or patch methods. The value of a destination cell is calculated as the weighted sum of the values of the source cells that it overlaps. The weights are determined by the amount the source cell overlaps the destination cell. Needs corner coordinate values to be provided in the Grid. Currently only works for Fields created on the Grid center stagger or the Mesh element location. 
</DD>
<DT><STRONG>ESMC_REGRIDMETHOD_CONSERVE_2ND</STRONG></DT>
<DD>Second-order conservative interpolation. As with first-order, preserves the integral of the value between the source and destination. However, typically produces a smoother more accurate result than first-order. Also like first-order, the value of a destination cell is calculated as the weighted sum of the values of the source cells that it overlaps. However, second-order also includes additional terms to take into account the gradient of the field across the source cell. Needs corner coordinate values to be provided in the Grid. Currently only works for Fields created on the Grid center stagger or the Mesh element location. 
</DD>
</DL>

<H2><A NAME="SECTION05023000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
A Field serves as an annotator of data, since it carries 
a description of the grid it is associated with and metadata 
such as name and units.  Fields can be used in this capacity
alone, as convenient, descriptive containers into which arrays 
can be placed and retrieved.  However, for most codes the primary 
use of Fields is in the context of import and export States,
which are the objects that carry coupling information between 
Components.  Fields enable data to be self-describing, and a
State holding ESMF Fields contains data in a standard format
that can be queried and manipulated.  

<P>
The sections below go into more detail about Field usage.

<P>

<H3><A NAME="SECTION05023100000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Field create and destroy</A>
</H3>

<P>
Fields can be created and destroyed at any time during 
application execution.  However, these Field methods require 
some time to complete.  We do not recommend that the user
create or destroy Fields inside performance-critical 
computational loops.

<P>
All versions of the <TT>ESMC_FieldCreate()</TT> 
routines require a Mesh object as input.
The Mesh contains the information needed to know which 
Decomposition Elements (DEs) are participating in 
the processing of this Field, and which subsets of the data
are local to a particular DE.

<P>
The details of how the create process happens depend
on which of the variants of the <TT>ESMC_FieldCreate()</TT> 
call is used.

<P>
When finished with an <TT>ESMC_Field</TT>, the <TT>ESMC_FieldDestroy</TT> method
removes it.  However, the objects inside the <TT>ESMC_Field</TT>
created externally should be destroyed separately, 
since objects can be added to
more than one <TT>ESMC_Field</TT>.  For example, the same <TT>ESMF_Mesh</TT>
can be referenced by multiple <TT>ESMC_Field</TT>s.  In this case the
internal Mesh is not deleted by the <TT>ESMC_FieldDestroy</TT> call.

<H2><A NAME="SECTION05024000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05024100000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_FieldCreateGridArraySpec - Create a Field from Grid and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Field ESMC_FieldCreateGridArraySpec(
   ESMC_Grid grid,                           // in
   ESMC_ArraySpec arrayspec,                 // in
   enum ESMC_StaggerLoc staggerloc,          // in
   ESMC_InterArrayInt *gridToFieldMap,       // in
   ESMC_InterArrayInt *ungriddedLBound,      // in
   ESMC_InterArrayInt *ungriddedUBound,      // in
   const char *name,                         // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Field object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a <TT>ESMC_Field</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>A <TT>ESMC_Grid</TT> object.
    
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>A <TT>ESMC_ArraySpec</TT> object describing data type and kind specification.
    
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Stagger location of data in grid cells. The default value is 
      ESMF_STAGGERLOC_CENTER.
    
</DD>
<DT><STRONG>gridToFieldMap</STRONG></DT>
<DD>List with number of elements equal to the grid's dimCount. The list
      elements map each dimension of the grid to a dimension in the field by
      specifying the appropriate field dimension index. The default is to map all of
      the grid's dimensions against the lowest dimensions of the field in sequence,
      i.e. gridToFieldMap = (/1,2,3,.../). The values of all gridToFieldMap entries
      must be greater than or equal to one and smaller than or equal to the field
      rank. It is erroneous to specify the same gridToFieldMap entry multiple times.
      The total ungridded dimensions in the field  are the total field dimensions
      less the dimensions in the grid. Ungridded dimensions must be in the same order
      they are stored in the field. If the Field dimCount is less than the Mesh
      dimCount then the default gridToFieldMap will contain zeros for the rightmost
      entries. A zero entry in the gridToFieldMap indicates that the particular Mesh
      dimension will be replicating the Field across the DEs along this direction.
    
</DD>
<DT><STRONG>ungriddedLBound</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedLBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>ungriddedUBound</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedUBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created field.  If not specified, i.e. NULL,
      a default unique name will be generated: "FieldNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05024200000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_FieldCreateGridTypeKind - Create a Field from Grid and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Field ESMC_FieldCreateGridTypeKind(
   ESMC_Grid grid,                           // in
   enum ESMC_TypeKind_Flag typekind,         // in
   enum ESMC_StaggerLoc staggerloc,          // in
   ESMC_InterArrayInt *gridToFieldMap,       // in
   ESMC_InterArrayInt *ungriddedLBound,      // in
   ESMC_InterArrayInt *ungriddedUBound,      // in
   const char *name,                         // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Field object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a <TT>ESMC_Field</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>A <TT>ESMC_Grid</TT> object.
    
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The ESMC_TypeKind_Flag that describes this Field data.
    
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Stagger location of data in grid cells. The default value is 
      ESMF_STAGGERLOC_CENTER.
    
</DD>
<DT><STRONG>gridToFieldMap</STRONG></DT>
<DD>List with number of elements equal to the grid's dimCount. The list
      elements map each dimension of the grid to a dimension in the field by
      specifying the appropriate field dimension index. The default is to map all of
      the grid's dimensions against the lowest dimensions of the field in sequence,
      i.e. gridToFieldMap = (/1,2,3,.../). The values of all gridToFieldMap entries
      must be greater than or equal to one and smaller than or equal to the field
      rank. It is erroneous to specify the same gridToFieldMap entry multiple times.
      The total ungridded dimensions in the field  are the total field dimensions
      less the dimensions in the grid. Ungridded dimensions must be in the same order
      they are stored in the field. If the Field dimCount is less than the Mesh
      dimCount then the default gridToFieldMap will contain zeros for the rightmost
      entries. A zero entry in the gridToFieldMap indicates that the particular Mesh
      dimension will be replicating the Field across the DEs along this direction.
    
</DD>
<DT><STRONG>ungriddedLBound</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedLBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>ungriddedUBound</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedUBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created field.  If not specified, i.e. NULL,
      a default unique name will be generated: "FieldNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05024300000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_FieldCreateMeshArraySpec - Create a Field from Mesh and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Field ESMC_FieldCreateMeshArraySpec(
   ESMC_Mesh mesh,                           // in
   ESMC_ArraySpec arrayspec,                 // in
   ESMC_InterArrayInt *gridToFieldMap,       // in
   ESMC_InterArrayInt *ungriddedLBound,      // in
   ESMC_InterArrayInt *ungriddedUBound,      // in
   const char *name,                         // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Field object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a <TT>ESMC_Field</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>A <TT>ESMC_Mesh</TT> object.
    
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>A <TT>ESMC_ArraySpec</TT> object describing data type and kind specification.
    
</DD>
<DT><STRONG>gridToFieldMap</STRONG></DT>
<DD>List with number of elements equal to the grid's dimCount. The list
      elements map each dimension of the grid to a dimension in the field by
      specifying the appropriate field dimension index. The default is to map all of
      the grid's dimensions against the lowest dimensions of the field in sequence,
      i.e. gridToFieldMap = (/1,2,3,.../). The values of all gridToFieldMap entries
      must be greater than or equal to one and smaller than or equal to the field
      rank. It is erroneous to specify the same gridToFieldMap entry multiple times.
      The total ungridded dimensions in the field  are the total field dimensions
      less the dimensions in the grid. Ungridded dimensions must be in the same order
      they are stored in the field. If the Field dimCount is less than the Mesh
      dimCount then the default gridToFieldMap will contain zeros for the rightmost
      entries. A zero entry in the gridToFieldMap indicates that the particular Mesh
      dimension will be replicating the Field across the DEs along this direction.
    
</DD>
<DT><STRONG>ungriddedLBound</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedLBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>ungriddedUBound</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedUBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created field.  If not specified, i.e. NULL,
      a default unique name will be generated: "FieldNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05024400000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_FieldCreateMeshTypeKind - Create a Field from Mesh and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Field ESMC_FieldCreateMeshTypeKind(
   ESMC_Mesh mesh,                           // in
   enum ESMC_TypeKind_Flag typekind,         // in
   enum ESMC_MeshLoc_Flag meshloc,           // in
   ESMC_InterArrayInt *gridToFieldMap,       // in
   ESMC_InterArrayInt *ungriddedLBound,      // in
   ESMC_InterArrayInt *ungriddedUBound,      // in
   const char *name,                         // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Field object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a <TT>ESMC_Field</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>A <TT>ESMC_Mesh</TT> object.
    
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The ESMC_TypeKind_Flag that describes this Field data.
    
</DD>
<DT><STRONG>meshloc</STRONG></DT>
<DD>The ESMC_MeshLoc_Flag that describes this Field data.
    
</DD>
<DT><STRONG>gridToFieldMap</STRONG></DT>
<DD>List with number of elements equal to the grid's dimCount. The list
      elements map each dimension of the grid to a dimension in the field by
      specifying the appropriate field dimension index. The default is to map all of
      the grid's dimensions against the lowest dimensions of the field in sequence,
      i.e. gridToFieldMap = (/1,2,3,.../). The values of all gridToFieldMap entries
      must be greater than or equal to one and smaller than or equal to the field
      rank. It is erroneous to specify the same gridToFieldMap entry multiple times.
      The total ungridded dimensions in the field  are the total field dimensions
      less the dimensions in the grid. Ungridded dimensions must be in the same order
      they are stored in the field. If the Field dimCount is less than the Mesh
      dimCount then the default gridToFieldMap will contain zeros for the rightmost
      entries. A zero entry in the gridToFieldMap indicates that the particular Mesh
      dimension will be replicating the Field across the DEs along this direction.
    
</DD>
<DT><STRONG>ungriddedLBound</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedLBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>ungriddedUBound</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedUBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created field.  If not specified, i.e. NULL,
      a default unique name will be generated: "FieldNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05024500000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_FieldCreateLocStreamArraySpec - Create a Field from LocStream and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Field ESMC_FieldCreateLocStreamArraySpec(
   ESMC_LocStream locstream,                 // in
   ESMC_ArraySpec arrayspec,                 // in
   ESMC_InterArrayInt *gridToFieldMap,       // in
   ESMC_InterArrayInt *ungriddedLBound,      // in
   ESMC_InterArrayInt *ungriddedUBound,      // in
   const char *name,                         // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Field object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a <TT>ESMC_Field</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>A <TT>ESMC_LocStream</TT> object.
    
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>A <TT>ESMC_ArraySpec</TT> object describing data type and kind specification.
    
</DD>
<DT><STRONG>gridToFieldMap</STRONG></DT>
<DD>List with number of elements equal to the grid's dimCount. The list
      elements map each dimension of the grid to a dimension in the field by
      specifying the appropriate field dimension index. The default is to map all of
      the grid's dimensions against the lowest dimensions of the field in sequence,
      i.e. gridToFieldMap = (/1,2,3,.../). The values of all gridToFieldMap entries
      must be greater than or equal to one and smaller than or equal to the field
      rank. It is erroneous to specify the same gridToFieldMap entry multiple times.
      The total ungridded dimensions in the field  are the total field dimensions
      less the dimensions in the grid. Ungridded dimensions must be in the same order
      they are stored in the field. If the Field dimCount is less than the Mesh
      dimCount then the default gridToFieldMap will contain zeros for the rightmost
      entries. A zero entry in the gridToFieldMap indicates that the particular Mesh
      dimension will be replicating the Field across the DEs along this direction.
    
</DD>
<DT><STRONG>ungriddedLBound</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedLBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>ungriddedUBound</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedUBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created field.  If not specified, i.e. NULL,
      a default unique name will be generated: "FieldNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05024600000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_FieldCreateLocStreamTypeKind - Create a Field from LocStream and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Field ESMC_FieldCreateLocStreamTypeKind(
   ESMC_LocStream locstream,                 // in
   enum ESMC_TypeKind_Flag typekind,         // in
   ESMC_InterArrayInt *gridToFieldMap,       // in
   ESMC_InterArrayInt *ungriddedLBound,      // in
   ESMC_InterArrayInt *ungriddedUBound,      // in
   const char *name,                         // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Field object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a <TT>ESMC_Field</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>A <TT>ESMC_LocStream</TT> object.
    
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The ESMC_TypeKind_Flag that describes this Field data.
    
</DD>
<DT><STRONG>gridToFieldMap</STRONG></DT>
<DD>List with number of elements equal to the grid's dimCount. The list
      elements map each dimension of the grid to a dimension in the field by
      specifying the appropriate field dimension index. The default is to map all of
      the grid's dimensions against the lowest dimensions of the field in sequence,
      i.e. gridToFieldMap = (/1,2,3,.../). The values of all gridToFieldMap entries
      must be greater than or equal to one and smaller than or equal to the field
      rank. It is erroneous to specify the same gridToFieldMap entry multiple times.
      The total ungridded dimensions in the field  are the total field dimensions
      less the dimensions in the grid. Ungridded dimensions must be in the same order
      they are stored in the field. If the Field dimCount is less than the Mesh
      dimCount then the default gridToFieldMap will contain zeros for the rightmost
      entries. A zero entry in the gridToFieldMap indicates that the particular Mesh
      dimension will be replicating the Field across the DEs along this direction.
    
</DD>
<DT><STRONG>ungriddedLBound</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedLBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>ungriddedUBound</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedUBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created field.  If not specified, i.e. NULL,
      a default unique name will be generated: "FieldNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05024700000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMC_FieldDestroy - Destroy a Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_FieldDestroy(
   ESMC_Field *field     // inout
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Releases all resources associated with this <TT>ESMC_Field</TT>.
      Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Destroy contents of this <TT>ESMC_Field</TT>.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05024800000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMC_FieldGetArray - Get the internal Array stored in the Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Array ESMC_FieldGetArray(
   ESMC_Field field,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The ESMC_Array object stored in the ESMC_Field.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the internal Array stored in the <TT>ESMC_Field</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Get the internal Array stored in this <TT>ESMC_Field</TT>.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05024900000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMC_FieldGetMesh - Get the internal Mesh stored in the Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Mesh ESMC_FieldGetMesh(
   ESMC_Field field,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The ESMC_Mesh object stored in the ESMC_Field.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the internal Mesh stored in the <TT>ESMC_Field</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Get the internal Mesh stored in this <TT>ESMC_Field</TT>.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241000000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMC_FieldGetPtr - Get the internal Fortran data pointer stored in the Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void *ESMC_FieldGetPtr(
   ESMC_Field field,     // in
   int localDe,          // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The Fortran data pointer stored in the ESMC_Field.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the internal Fortran data pointer stored in the <TT>ESMC_Field</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Get the internal Fortran data pointer stored in this <TT>ESMC_Field</TT>.
    
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>. 
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241100000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMC_FieldGetBounds - Get the Field bounds</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_FieldGetBounds(
   ESMC_Field field,      // in
   int *localDe,
   int *exclusiveLBound,
   int *exclusiveUBound,
   int rank
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the Field bounds from the <TT>ESMC_Field</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMC_Field</TT> whose bounds will be returned
    
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>The local DE of the <TT>ESMC_Field</TT> (not implemented)
    
</DD>
<DT><STRONG>exclusiveLBound</STRONG></DT>
<DD>The exclusive lower bounds of the <TT>ESMC_Field</TT>
    
</DD>
<DT><STRONG>exclusiveUBound</STRONG></DT>
<DD>The exclusive upper bounds of the <TT>ESMC_Field</TT>
    
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>The rank of the <TT>ESMC_Field</TT>, to size the bounds arrays
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241200000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMC_FieldPrint - Print the internal information of a Field</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_FieldPrint(
   ESMC_Field field      // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print the internal information within this <TT>ESMC_Field</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Print contents of this <TT>ESMC_Field</TT>.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241300000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMC_FieldRegridGetArea - Get the area of the cells used for </A>
</H3>

<P>
conservative interpolation

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_FieldRegridGetArea(
   ESMC_Field field      // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine gets the area of the cells used for conservative interpolation for the grid object 
       associated with <TT>areaField</TT> and puts them into <TT>areaField</TT>. If created on a 2D Grid, it must 
       be built on the <TT>ESMF_STAGGERLOC_CENTER</TT> stagger location. 
       If created on a 3D Grid, it must be built on the <TT>ESMF_STAGGERLOC_CENTER_VCENTER</TT> stagger 
       location. If created on a Mesh, it must be built on the <TT>ESMF_MESHLOC_ELEMENT</TT> mesh location. 

<P>
The arguments are:
       <DL>
<DT><STRONG>areaField</STRONG></DT>
<DD>The Field to put the area values in. 
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241400000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMC_FieldRegridStore - Precompute a Field regridding operation and return a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_FieldRegridStore( 
     ESMC_Field srcField,                           // in
     ESMC_Field dstField,                           // in
     ESMC_InterArrayInt *srcMaskValues,             // in
     ESMC_InterArrayInt *dstMaskValues,             // in
     ESMC_RouteHandle *routehandle,                 // inout
     enum ESMC_RegridMethod_Flag *regridmethod,     // in
     enum ESMC_PoleMethod_Flag *polemethod,         // in
     int *regridPoleNPnts,                          // in
     enum ESMC_LineType_Flag *lineType,             // in
     enum ESMC_NormType_Flag *normType,             // in
     enum ESMC_ExtrapMethod_Flag *extrapMethod,     // in
     int *extrapNumSrcPnts,                         // in
     float *extrapDistExponent,                     // in
     int *extrapNumLevels,                          // in
     enum ESMC_UnmappedAction_Flag *unmappedaction, // in
     enum ESMC_Logical *ignoreDegenerate,           // in
     double **factorList,                           // inout
     int **factorIndexList,                         // inout
     int *numFactors,                               // inout
     ESMC_Field *srcFracField,                      // inout
     ESMC_Field *dstFracField);                     // inout
</PRE><EM>RETURN VALUE:</EM>
<PRE>     Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a sparse matrix operation (stored in routehandle) that contains 
     the calculations and communications necessary to interpolate from srcField 
     to dstField. The routehandle can then be used in the call ESMC_FieldRegrid() 
     to interpolate between the Fields. 

<P>
The arguments are:
    <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD>ESMC_Field with source data.
    
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>ESMC_Field with destination data.
    
</DD>
<DT><STRONG>srcMaskValues</STRONG></DT>
<DD>List of values that indicate a source point should be masked out. 
      If not specified, no masking will occur.
    
</DD>
<DT><STRONG>dstMaskValues</STRONG></DT>
<DD>List of values that indicate a destination point should be masked out. 
      If not specified, no masking will occur.
    
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>The handle that implements the regrid, to be used in <TT>ESMC_FieldRegrid()</TT>.
    
</DD>
<DT><STRONG>regridmethod</STRONG></DT>
<DD>The type of interpolation. If not specified, defaults to <TT>ESMF_REGRIDMETHOD_BILINEAR</TT>.
    
</DD>
<DT><STRONG>polemethod</STRONG></DT>
<DD>Which type of artificial pole
      to construct on the source Grid for regridding. 
      If not specified, defaults to <TT>ESMF_POLEMETHOD_ALLAVG</TT> for non-conservative regrid methods, 
      and <TT>ESMF_POLEMETHOD_NONE</TT> for conservative methods. 
      If not specified, defaults to <TT>ESMC_POLEMETHOD_ALLAVG</TT>. 
    
</DD>
<DT><STRONG>regridPoleNPnts</STRONG></DT>
<DD>If <TT>polemethod</TT> is <TT>ESMC_POLEMETHOD_NPNTAVG</TT>.
      This parameter indicates how many points should be averaged
      over. Must be specified if <TT>polemethod</TT> is 
      <TT>ESMC_POLEMETHOD_NPNTAVG</TT>.
    
</DD>
<DT><STRONG>[lineType]</STRONG></DT>
<DD>This argument controls the path of the line which connects two points on a sphere surface. This in
      turn controls the path along which distances are calculated and the shape of the edges that make
      up a cell. Both of these quantities can influence how interpolation weights are calculated.
      As would be expected, this argument is only applicable when <TT>srcField</TT> and <TT>dstField</TT> are
      built on grids which lie on the surface of a sphere. Section&nbsp;<A HREF="node9.html#opt:lineType">34.8</A> shows a
      list of valid options for this argument. If not specified, the default depends on the
      regrid method. Section&nbsp;<A HREF="node9.html#opt:lineType">34.8</A> has the defaults by line type.
    
</DD>
<DT><STRONG>normType</STRONG></DT>
<DD>This argument controls the type of normalization used when generating conservative weights.
      This option only applies to weights generated with <TT>regridmethod=ESMF_REGRIDMETHOD_CONSERVE</TT>.
      If not specified normType defaults to <TT>ESMF_NORMTYPE_DSTAREA</TT>.
    
</DD>
<DT><STRONG>[extrapMethod]</STRONG></DT>
<DD>The type of extrapolation. Please see Section&nbsp;<A HREF="node9.html#opt:cextrapmethod">34.3</A> 
      for a list of valid options. If not specified, defaults to 
      <TT>ESMC_EXTRAPMETHOD_NONE</TT>.
    
</DD>
<DT><STRONG>[extrapNumSrcPnts]</STRONG></DT>
<DD>The number of source points to use for the extrapolation methods that use more than one source point 
      (e.g. <TT>ESMC_EXTRAPMETHOD_NEAREST_IDAVG</TT>). If not specified, defaults to 8.
    
</DD>
<DT><STRONG>[extrapDistExponent]</STRONG></DT>
<DD>The exponent to raise the distance to when calculating weights for 
      the <TT>ESMC_EXTRAPMETHOD_NEAREST_IDAVG</TT> extrapolation method. A higher value reduces the influence 
      of more distant points. If not specified, defaults to 2.0.
    
</DD>
<DT><STRONG>[extrapNumLevels]</STRONG></DT>
<DD>The number of levels to output for the extrapolation methods that fill levels 
      (e.g. ESMC_EXTRAPMETHOD_CREEP). When a method is used that requires this, then 
      an error will be returned if it is not specified.
    
</DD>
<DT><STRONG>unmappedaction</STRONG></DT>
<DD>Specifies what should happen if there are destination points that can't 
      be mapped to a source cell. Options are <TT>ESMF_UNMAPPEDACTION_ERROR</TT> or
      <TT>ESMF_UNMAPPEDACTION_IGNORE</TT>. If not specified, defaults to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>.
    
</DD>
<DT><STRONG>[factorList]</STRONG></DT>
<DD>The list of coefficients for a sparse matrix which interpolates from <TT>srcField</TT> to 
      <TT>dstField</TT>. The array coming out of this variable is in the appropriate format to be used
      in other ESMF sparse matrix multiply calls, for example <TT>ESMC_FieldSMMStore()</TT>. 
      The <TT>factorList</TT> array is allocated by the method and the user is responsible for 
      deallocating it. 
    
</DD>
<DT><STRONG>[factorIndexList]</STRONG></DT>
<DD>The indices for a sparse matrix which interpolates from <TT>srcField</TT> to 
      <TT>dstField</TT>. This argument is a 2D array containing pairs of source and destination
      sequence indices corresponding to the coefficients in the <TT>factorList</TT> argument. 
      The first dimension of <TT>factorIndexList</TT> is of size 2. <TT>factorIndexList(1,:)</TT> specifies 
      the sequence index of the source element in the <TT>srcField</TT>. <TT>factorIndexList(2,:)</TT> specifies 
      the sequence index of the destination element in the <TT>dstField</TT>. The second dimension of 
      <TT>factorIndexList</TT> steps through the list of pairs, i.e. <TT>size(factorIndexList,2)==size(factorList)</TT>.
      The array coming out of this variable is in the appropriate format to be used
      in other ESMF sparse matrix multiply calls, for example <TT>ESMC_FieldSMMStore()</TT>. 
      The <TT>factorIndexList</TT> array is allocated by the method and the user is responsible for deallocating it. 
    
</DD>
<DT><STRONG>[numFactors]</STRONG></DT>
<DD>The number of factors returned in <TT>factorList</TT>.
    
</DD>
<DT><STRONG>[srcFracField]</STRONG></DT>
<DD>The fraction of each source cell participating in the regridding. Only 
      valid when regridmethod is <TT>ESMC_REGRIDMETHOD_CONSERVE</TT>.
      This Field needs to be created on the same location (e.g staggerloc) 
      as the srcField.
    
</DD>
<DT><STRONG>[dstFracField]</STRONG></DT>
<DD>The fraction of each destination cell participating in the regridding. Only 
      valid when regridmethod is <TT>ESMF_REGRIDMETHOD_CONSERVE</TT>.
      This Field needs to be created on the same location (e.g staggerloc) 
      as the dstField.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241500000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMC_FieldRegridStoreFile - Precompute a Field regridding operation and return a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_FieldRegridStoreFile(
     ESMC_Field srcField,                           // in
     ESMC_Field dstField,                           // in
     const char *filename,                          // in
     ESMC_InterArrayInt *srcMaskValues,             // in
     ESMC_InterArrayInt *dstMaskValues,             // in
     ESMC_RouteHandle *routehandle,                 // inout
     enum ESMC_RegridMethod_Flag *regridmethod,     // in
     enum ESMC_PoleMethod_Flag *polemethod,         // in
     int *regridPoleNPnts,                          // in
     enum ESMC_LineType_Flag *lineType,             // in
     enum ESMC_NormType_Flag *normType,             // in
     enum ESMC_UnmappedAction_Flag *unmappedaction, // in
     enum ESMC_Logical *ignoreDegenerate,           // in
     enum ESMC_Logical *create_rh,                  // in
     enum ESMC_FileMode_Flag *filemode,                  // in
     const char *srcFile,                           // in
     const char *dstFile,                           // in
     enum ESMC_FileFormat_Flag *srcFileType,        // in
     enum ESMC_FileFormat_Flag *dstFileType,        // in
     enum ESMC_Logical *largeFileFlag,              // in
     ESMC_Field *srcFracField,                      // out
     ESMC_Field *dstFracField);                     // out
</PRE><EM>RETURN VALUE:</EM>
<PRE>     Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a sparse matrix operation (stored in routehandle) that contains
     the calculations and communications necessary to interpolate from srcField
     to dstField. The routehandle can then be used in the call ESMC_FieldRegrid()
     to interpolate between the Fields. The weights will be output to the file
     with name <TT>filename</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD>ESMC_Field with source data.
    
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>ESMC_Field with destination data.
    
</DD>
<DT><STRONG>[filename]</STRONG></DT>
<DD>The output filename for the factorList and factorIndexList.
    
</DD>
<DT><STRONG>[srcMaskValues]</STRONG></DT>
<DD>List of values that indicate a source point should be masked out.
      If not specified, no masking will occur.
    
</DD>
<DT><STRONG>[dstMaskValues]</STRONG></DT>
<DD>List of values that indicate a destination point should be masked out.
      If not specified, no masking will occur.
    
</DD>
<DT><STRONG>[routehandle]</STRONG></DT>
<DD>The handle that implements the regrid, to be used in <TT>ESMC_FieldRegrid()</TT>.
    
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. If not specified, defaults to <TT>ESMC_REGRIDMETHOD_BILINEAR</TT>.
    
</DD>
<DT><STRONG>[polemethod]</STRONG></DT>
<DD>Which type of artificial pole
      to construct on the source Grid for regridding.
      If not specified, defaults to <TT>ESMC_POLEMETHOD_ALLAVG</TT> for non-conservative regrid methods,
      and <TT>ESMC_POLEMETHOD_NONE</TT> for conservative methods.
      If not specified, defaults to <TT>ESMC_POLEMETHOD_ALLAVG</TT>.
    
</DD>
<DT><STRONG>[regridPoleNPnts]</STRONG></DT>
<DD>If <TT>polemethod</TT> is <TT>ESMC_POLEMETHOD_NPNTAVG</TT>.
      This parameter indicates how many points should be averaged
      over. Must be specified if <TT>polemethod</TT> is
      <TT>ESMC_POLEMETHOD_NPNTAVG</TT>.
    
</DD>
<DT><STRONG>[lineType]</STRONG></DT>
<DD>This argument controls the path of the line which connects two points on a sphere surface. This in
      turn controls the path along which distances are calculated and the shape of the edges that make
      up a cell. Both of these quantities can influence how interpolation weights are calculated.
      As would be expected, this argument is only applicable when <TT>srcField</TT> and <TT>dstField</TT> are
      built on grids which lie on the surface of a sphere. Section&nbsp;<A HREF="node9.html#opt:lineType">34.8</A> shows a
      list of valid options for this argument. If not specified, the default depends on the
      regrid method. Section&nbsp;<A HREF="node9.html#opt:lineType">34.8</A> has the defaults by line type.
    
</DD>
<DT><STRONG>[normType]</STRONG></DT>
<DD>This argument controls the type of normalization used when generating conservative weights.
      This option only applies to weights generated with <TT>regridmethod=ESMC_REGRIDMETHOD_CONSERVE</TT>.
      If not specified normType defaults to <TT>ESMC_NORMTYPE_DSTAREA</TT>.
    
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that can't
      be mapped to a source cell. Options are <TT>ESMC_UNMAPPEDACTION_ERROR</TT> or
      <TT>ESMC_UNMAPPEDACTION_IGNORE</TT>. If not specified, defaults to <TT>ESMC_UNMAPPEDACTION_ERROR</TT>.
    
</DD>
<DT><STRONG>create_rh</STRONG></DT>
<DD>Specifies whether or not to create a routehandle, or just write weights to file.
      If not specified, defaults to <TT>ESMF_TRUE</TT>.
    
</DD>
<DT><STRONG>filemode</STRONG></DT>
<DD>Specifies the mode to use when creating the weight file. Options are
      <TT>ESMC_FILEMODE_BASIC</TT> and <TT>ESMC_FILEMODE_WITHAUX</TT>, which will
      write a file that includes center coordinates of the grids. The default 
      value is <TT>ESMC_FILEMODE_BASIC</TT>.
    
</DD>
<DT><STRONG>srcFile</STRONG></DT>
<DD>The name of the source file used to create the <TT>ESMC_Grid</TT> used
      in this regridding operation.
    
</DD>
<DT><STRONG>dstFile</STRONG></DT>
<DD>The name of the destination file used to create the <TT>ESMC_Grid</TT> used
      in this regridding operation.
    
</DD>
<DT><STRONG>srcFileType</STRONG></DT>
<DD>The type of the file used to represent the source grid.
    
</DD>
<DT><STRONG>dstFileType</STRONG></DT>
<DD>The type of the file used to represent the destination grid.
    
</DD>
<DT><STRONG>[srcFracField]</STRONG></DT>
<DD>The fraction of each source cell participating in the regridding. Only
      valid when regridmethod is <TT>ESMC_REGRIDMETHOD_CONSERVE</TT>.
      This Field needs to be created on the same location (e.g staggerloc)
      as the srcField.
    
</DD>
<DT><STRONG>[dstFracField]</STRONG></DT>
<DD>The fraction of each destination cell participating in the regridding. Only
      valid when regridmethod is <TT>ESMC_REGRIDMETHOD_CONSERVE</TT>.
      This Field needs to be created on the same location (e.g staggerloc)
      as the dstField.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241600000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMC_FieldRegrid - Compute a regridding operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   int ESMC_FieldRegrid( 
     ESMC_Field srcField,                  // in
     ESMC_Field dstField,                  // inout
     ESMC_RouteHandle routehandle,         // in
     enum ESMC_Region_Flag *zeroregion);   // in
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Execute the precomputed regrid operation stored in routehandle to interpolate 
    from srcField to dstField. See ESMF_FieldRegridStore() on how to precompute
    the routehandle.  It is erroneous to specify the identical Field object for
    srcField and dstField arguments.  This call is collective across the 
    current VM.

<P>
The arguments are:
    <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD>ESMC_Field with source data.
    
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>ESMC_Field with destination data.
    
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
    
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMC_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
      all DEs in <TT>dstField</TT> will be initialized to zero before updating the 
      elements with the results of the sparse matrix multiplication. If set to
      <TT>ESMC_REGION_EMPTY</TT> the elements in <TT>dstField</TT> will not be
      modified prior to the sparse matrix multiplication and results will be
      added to the incoming element values. Setting <TT>zeroregion</TT> to 
      <TT>ESMC_REGION_SELECT</TT> will only zero out those elements in the 
      destination Array that will be updated by the sparse matrix
      multiplication.
      
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241700000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMC_FieldRegridRelease - Free resources used by a regridding operation</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   int ESMC_FieldRegridRelease(ESMC_RouteHandle *routehandle);  // inout
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Free resources used by regrid object

<P>
The arguments are:
    <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle carrying the sparse matrix
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050241800000000000000">
<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMC_FieldSMMStore - Precompute a Field regridding operation and return a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_FieldSMMStore(
     ESMC_Field srcField,                           // in
     ESMC_Field dstField,                           // in
     const char *filename,                          // in
     ESMC_RouteHandle *routehandle,                 // out
     enum ESMC_Logical *ignoreUnmatchedIndices,     // in
     int *srcTermProcessing,                        // in
     int *pipeLineDepth);                           // in
</PRE><EM>RETURN VALUE:</EM>
<PRE>     Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a sparse matrix operation (stored in routehandle) that contains
     the calculations and communications necessary to interpolate from srcField
     to dstField. The routehandle can then be used in the call ESMC_FieldRegrid()
     to interpolate between the Fields.

<P>
The arguments are:
    <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD>ESMC_Field with source data.
    
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>ESMC_Field with destination data.
    
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Path to the file containing weights for creating an <TT>ESMC_RouteHandle</TT>.
      Only "row", "col", and "S" variables are required. They
      must be one-dimensionsal with dimension "n_s".
    
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>The handle that implements the regrid, to be used in <TT>ESMC_FieldRegrid()</TT>.
    
</DD>
<DT><STRONG>[ignoreUnmatchedIndices]</STRONG></DT>
<DD>A logical flag that affects the behavior for when sequence indices
      in the sparse matrix are encountered that do not have a match on the
      <TT>srcField</TT> or <TT>dstField</TT> side. The default setting is
      <TT>.false.</TT>, indicating that it is an error when such a situation is
      encountered. Setting <TT>ignoreUnmatchedIndices</TT> to <TT>.true.</TT> ignores
      entries with unmatched indices.
    
</DD>
<DT><STRONG>[srcTermProcessing]</STRONG></DT>
<DD>The <TT>srcTermProcessing</TT> parameter controls how many source terms,
      located on the same PET and summing into the same destination element,
      are summed into partial sums on the source PET before being transferred
      to the destination PET. A value of 0 indicates that the entire arithmetic
      is done on the destination PET; source elements are neither multiplied
      by their factors nor added into partial sums before being sent off by the
      source PET. A value of 1 indicates that source elements are multiplied
      by their factors on the source side before being sent to the destination
      PET. Larger values of <TT>srcTermProcessing</TT> indicate the maximum number
      of terms in the partial sums on the source side.
      Note that partial sums may lead to bit-for-bit differences in the results.
      See section <A HREF="#RH:bfb"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for an in-depth discussion of <EM>all</EM>
      bit-for-bit reproducibility aspects related to route-based communication
      methods.
      The <TT>ESMC_FieldSMMStore()</TT> method implements an auto-tuning scheme
      for the <TT>srcTermProcessing</TT> parameter. The intent on the
      <TT>srcTermProcessing</TT> argument is "<TT>inout</TT>" in order to
      support both overriding and accessing the auto-tuning parameter.
      If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
      <TT>srcTermProcessing</TT> parameter, and the auto-tuning phase is skipped.
      In this case the <TT>srcTermProcessing</TT> argument is not modified on
      return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>srcTermProcessing</TT>
      parameter is determined internally using the auto-tuning scheme. In this
      case the <TT>srcTermProcessing</TT> argument is re-set to the internally
      determined value on return. Auto-tuning is also used if the optional
      <TT>srcTermProcessing</TT> argument is omitted.
    
</DD>
<DT><STRONG>[pipelineDepth]</STRONG></DT>
<DD>The <TT>pipelineDepth</TT> parameter controls how many messages a PET
      may have outstanding during a sparse matrix exchange. Larger values
      of <TT>pipelineDepth</TT> typically lead to better performance. However,
      on some systems too large a value may lead to performance degradation,
      or runtime errors.
      Note that the pipeline depth has no effect on the bit-for-bit
      reproducibility of the results. However, it may affect the performance
      reproducibility of the exchange.
      The <TT>ESMC_FieldSMMStore()</TT> method implements an auto-tuning scheme
      for the <TT>pipelineDepth</TT> parameter. The intent on the
      <TT>pipelineDepth</TT> argument is "<TT>inout</TT>" in order to
      support both overriding and accessing the auto-tuning parameter.
      If an argument <SPAN CLASS="MATH"><IMG
 WIDTH="41" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$&gt;= 0$"></SPAN> is specified, it is used for the
      <TT>pipelineDepth</TT> parameter, and the auto-tuning phase is skipped.
      In this case the <TT>pipelineDepth</TT> argument is not modified on
      return. If the provided argument is <SPAN CLASS="MATH"><IMG
 WIDTH="29" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$&lt; 0$"></SPAN>, the <TT>pipelineDepth</TT>
      parameter is determined internally using the auto-tuning scheme. In this
      case the <TT>pipelineDepth</TT> argument is re-set to the internally
      determined value on return. Auto-tuning is also used if the optional
      <TT>pipelineDepth</TT> argument is omitted.
    
</DD>
</DL>

<P>


<H1><A NAME="SECTION05030000000000000000">
<SPAN CLASS="arabic">17</SPAN> Array Class</A>
</H1>

<H2><A NAME="SECTION05031000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The Array class is an alternative to the Field class for representing 
distributed, structured data.  Unlike Fields, which are built to carry 
grid coordinate information, Arrays can only carry information about the 
<I>indices</I> associated with grid cells.  Since they do not have coordinate 
information, Arrays cannot be used to calculate interpolation weights.  
However, if the user can supply interpolation weights, the Array sparse 
matrix multiply operation can be used to apply the weights and transfer 
data to the new grid.  Arrays can also perform redistribution, scatter, 
and gather communication operations.

<P>
Like Fields, Arrays can be added to a State and used in inter-Component 
data communications.

<P>
From a technical standpoint, the ESMF Array class is an index space 
based, distributed data storage class. It provides DE-local memory allocations 
within DE-centric index regions and defines the relationship to the index 
space described by the ESMF DistGrid. The Array class offers common 
communication patterns within the index space formalism.

<H2><A NAME="SECTION05032000000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05032100000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_ArrayCreate - Create an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Array ESMC_ArrayCreate(
   ESMC_ArraySpec arrayspec,   // in
   ESMC_DistGrid distgrid,     // in
   const char* name,           // in
   int *rc                     // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Array object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD><TT>ESMC_ArraySpec</TT> object containing the type/kind/rank information.
    
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMC_DistGrid</TT> object that describes how the Array is decomposed and
      distributed over DEs. The dimCount of distgrid must be smaller or equal
      to the rank specified in arrayspec, otherwise a runtime ESMF error will be
      raised.
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the Array object. If not specified, i.e. NULL,
      a default unique name will be generated: "ArrayNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05032200000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_ArrayDestroy - Destroy an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_ArrayDestroy(
   ESMC_Array *array           // inout
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMC_Array</TT> object to be destroyed.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05032300000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_ArrayGetName - Get the name of an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> const char *ESMC_ArrayGetName(
   ESMC_Array array,           // in
   int *rc                     // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Pointer to the Array name string.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the name of the specified <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMC_Array</TT> object to be queried.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05032400000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_ArrayGetPtr - Get pointer to Array data.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void *ESMC_ArrayGetPtr(
   ESMC_Array array,           // in
   int localDe,                // in
   int *rc                     // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Pointer to the Array data.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get pointer to the data of the specified <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMC_Array</TT> object to be queried.
    
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local De for which to data pointer is queried.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05032500000000000000">
<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_ArrayPrint - Print an Array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_ArrayPrint(
   ESMC_Array array            // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMC_Array</TT> object to be printed.
    
</DD>
</DL>

<P>


<H1><A NAME="SECTION05040000000000000000">
<SPAN CLASS="arabic">18</SPAN> ArraySpec Class</A>
</H1>

<H2><A NAME="SECTION05041000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
An ArraySpec is a very simple class that contains type, kind, and
rank information about an Array.  This information is stored in two
parameters.  <B>TypeKind</B> describes the data type of the elements
in the Array and their precision.  <B>Rank</B> is the number of dimensions
in the Array.

<P>
The only methods that are associated with the ArraySpec class are those 
that allow you to set and retrieve this information.

<P>

<H2><A NAME="SECTION05042000000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05042100000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_ArraySpecGet - Get values from an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_ArraySpecGet(
   ESMC_ArraySpec arrayspec,         // in
   int *rank,                        // out
   enum ESMC_TypeKind_Flag *typekind // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns information about the contents of an <TT>ESMC_ArraySpec</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMC_ArraySpec</TT> to query.
    
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum allowed is 7D.
    
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind. See section&nbsp;<A HREF="node9.html#const:ctypekind">34.18</A> for valid values.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05042200000000000000">
<SPAN CLASS="arabic">18</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_ArraySpecSet - Set values for an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_ArraySpecSet(
   ESMC_ArraySpec *arrayspec,         // inout 
   int rank,                          // in
   enum ESMC_TypeKind_Flag typekind        // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set an Array specification - typekind, and rank.

<P>
The arguments are:
    <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMC_ArraySpec</TT> to set.
    
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum allowed is 7D.
    
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind. See section&nbsp;<A HREF="node9.html#const:ctypekind">34.18</A> for valid values.
    
</DD>
</DL>

<P>


<H1><A NAME="SECTION05050000000000000000">
<SPAN CLASS="arabic">19</SPAN> Grid Class</A>
</H1>

<H2><A NAME="SECTION05051000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF Grid class is used to describe the geometry and discretization
of logically rectangular physical grids.  It also contains the
description of the grid's underlying topology and the decomposition
of the physical grid across the available computational resources.
The most frequent use of the Grid class is to describe physical grids
in user code so that sufficient information is available to perform ESMF
methods such as regridding.  

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Representation of grids formed by logically rectangular regions,
including uniform and rectilinear grids (e.g. lat-lon grids),
curvilinear grids (e.g. displaced pole grids), and grids formed
by connected logically rectangular regions (e.g. cubed sphere grids).</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for 1D, 2D, 3D, and higher dimension grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Distribution of grids across computational resources for parallel
operations - users set which grid dimensions are distributed.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Grids can be created already distributed, so that no single
resource needs global information during the creation process.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options to define periodicity and other edge connectivities either 
explicitly or implicitly via shape shortcuts.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for users to define grid coordinates themselves or call
prefabricated coordinate generation routines for standard grids
[NO GENERATION ROUTINES YET].</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for incremental construction of grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for using a set of pre-defined stagger locations or for setting
custom stagger locations.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION05051100000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Representation in ESMF</A>
</H3>

<P>
ESMF Grids are based on the concepts described in <I>A Standard
Description of Grids Used in Earth System Models</I> [Balaji 2006].  In this document
Balaji introduces the mosaic concept as a means of describing
a wide variety of Earth system model grids.  A <B>mosaic</B> is
composed of grid tiles connected at their edges.  Mosaic grids
includes simple, single tile grids as a special case.  

<P>
The ESMF Grid class is a representation of a mosaic grid.  Each ESMF
Grid is constructed of one or more logically rectangular <B>Tiles</B>.
A Tile will usually have some physical significance (e.g. the region
of the world covered by one face of a cubed sphere grid).

<P>
The piece of a Tile that resides on one DE (for simple cases, a DE
can be thought of as a processor - see section on the DELayout)
is called a <B>LocalTile</B>.  For example, the six faces of a cubed
sphere grid are each Tiles, and each Tile can be divided into many
LocalTiles.  

<P>
Every ESMF Grid contains a DistGrid object, which defines the Grid's
index space, topology, distribution, and connectivities.  It enables
the user to define the complex edge relationships of tripole and other
grids.  The DistGrid can be created explicitly and passed into a Grid
creation routine, or it can be created implicitly if the user takes
a Grid creation shortcut. The DistGrid used
in Grid creation describes the properties of the Grid cells. In addition
to this one, the Grid internally creates DistGrids for each stagger location. 
These stagger DistGrids are related to the original DistGrid, but may 
contain extra padding to represent the extent of the index space of
the stagger. These DistGrids are what are used when a Field is created 
on a Grid. 

<P>

<H3><A NAME="SECTION05051200000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Grids</A>
</H3>

<P>
The range of supported grids in ESMF can be defined by:

<UL>
<LI>Types of topologies and shapes supported.  ESMF supports one or
more logically rectangular grid Tiles with connectivities specified
between cells.  For more details see section <A HREF="#sec:ShapeShortcut">19.1.3</A>.
</LI>
<LI>Types of distributions supported.  ESMF supports  regular,
irregular, or arbitrary distributions of data.  
For more details see section <A HREF="#sec:desc:dist">19.1.4</A>.
</LI>
<LI>Types of coordinates supported.  ESMF supports uniform, rectilinear,
and curvilinear coordinates.  For more details see section <A HREF="#sec:coordspec">19.1.5</A>.
</LI>
</UL>

<P>

<H3><A NAME="SECTION05051300000000000000"></A>
<A NAME="sec:ShapeShortcut"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Grid Topologies and Periodicity
</H3>

ESMF has shortcuts for the creation of standard Grid topologies 
or <B>shapes</B> up to 3D.  In many cases, these enable the user to
bypass the step of creating a DistGrid before creating the Grid. 
There are two sets of methods which allow the user to do this. These two sets of methods cover the same set of topologies, but
allow the user to specify them in different ways.

<P>
The first set of these are a group of overloaded
calls broken up by the number of periodic dimensions they specify. With these the user can pick 
the method which creates a Grid with the number of periodic dimensions they need, and then specify other connectivity 
options via arguments to the method. The following is a description of these methods:

<P>

<P>
<BR>

<P>
<DL>
<DT><STRONG>ESMF_GridCreateNoPeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with no edge connections, for example, a regional Grid with closed boundaries.

<P>
</DD>
<DT><STRONG>ESMF_GridCreate1PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 1 periodic dimension and supports a range of options for what to do at the pole (see&nbsp;Section&nbsp;<A HREF="#const:cpolekind">19.2.4</A>. Some examples of Grids which can be created here are tripole spheres, bipole spheres, cylinders with open poles. 

<P>
</DD>
<DT><STRONG>ESMF_GridCreate2PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 2 periodic dimensions, for example a torus, or a regional Grid with
doubly periodic boundaries. 
</DD>
</DL>

<P>
More detailed information can be found in the API description of each.

<P>

<P>
<BR>

<P>
The second set of shortcut methods is a set of methods overloaded under the name <TT>ESMF_GridCreate()</TT>. These methods
allow the user to specify the connectivites at the end of each dimension, by using the ESMF_GridConn_Flag flag. The table below shows the ESMF_GridConn_Flag settings used to create 
standard shapes in 2D using the ESMF_GridCreate() call.  Two values
are specified for each dimension, one for the low end and one for 
the high end of the dimension's index values.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">2D Shape</TD>
<TD ALIGN="CENTER"><B>connflagDim1(1)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim1(2)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim2(1)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim2(2)</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Rectangle</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Bipole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Tripole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">BIPOLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Cylinder</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Torus</B></TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
</TABLE>

<P>
<BR>

<P>
If the user's grid shape is too complex for an ESMF shortcut routine,
or involves more than three dimensions, a DistGrid can be created
to specify the shape in detail.  This DistGrid is then passed
into a Grid create call.

<P>

<H3><A NAME="SECTION05051400000000000000"></A>
<A NAME="sec:desc:dist"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">4</SPAN> Grid Distribution
</H3>

<P>
ESMF Grids have several options for data distribution (also referred to
as decomposition).  As ESMF Grids are cell based, these 
options are all specified  in terms of how the cells in the Grid
are broken up between DEs. 

<P>
The main distribution options are regular, irregular, and arbitrary.
A <B>regular</B> distribution is one in which the same number of
contiguous grid cells are assigned to each DE in the
distributed dimension.  An <B>irregular</B> distribution is one in which
unequal numbers of contiguous grid cells are assigned to each
DE in the distributed dimension.  An <B>arbitrary</B> distribution is
one in which any grid cell can be assigned to any DE.  Any of these
distribution options can be applied to any of the grid shapes (i.e.,
rectangle) or types (i.e., rectilinear).  Support for arbitrary distribution 
is limited in the current version of ESMF.

<P>
Figure <A HREF="#fig:GridDecomps">7</A> illustrates options for distribution.

<DIV ALIGN="CENTER"><A NAME="fig:GridDecomps"></A><A NAME="4925"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 7:</STRONG>
Examples of regular and irregular decomposition of
a grid <B>a</B> that is 6x6, and an arbitrary decomposition of
a grid <B>b</B> that is 6x3.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{GridDecomps}}$
 -->
<IMG
 WIDTH="630" HEIGHT="192" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="\scalebox{0.9}{\includegraphics{GridDecomps}}"></TD></TR>
</TABLE>
</DIV>

<P>
A distribution can also be specified using the DistGrid, by passing
object into a Grid create call.

<P>

<H3><A NAME="SECTION05051500000000000000"></A>
<A NAME="sec:coordspec"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">5</SPAN> Grid Coordinates
</H3>
Grid Tiles can have uniform, rectilinear, or curvilinear
coordinates.  The coordinates of <B>uniform</B> grids are equally spaced along
their axes, and can be fully specified by the coordinates of the two opposing points
that define the grid's physical span.  The coordinates of <B>rectilinear</B> grids
are unequally spaced along their axes, and can be fully specified by giving
the spacing of grid points along each axis.  The coordinates of <B>curvilinear 
grids</B> must be specified by giving the explicit set of coordinates for each
grid point.  Curvilinear grids are often uniform or rectilinear grids that 
have been warped; for example, to place a pole over a land mass so that it
does not affect the computations performed on an ocean model grid.  Figure
<A HREF="#fig:LogRectGrids">8</A> shows examples of each type of grid.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:LogRectGrids"></A><A NAME="4893"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 8:</STRONG>
Types of logically rectangular grid tiles.  Red circles show the
values needed to specify grid coordinates for each type.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{LogRectGrids}}$
 -->
<IMG
 WIDTH="636" HEIGHT="210" ALIGN="BOTTOM" BORDER="0"
 SRC="img11.png"
 ALT="\scalebox{0.9}{\includegraphics{LogRectGrids}}"></TD></TR>
</TABLE>
</DIV>

<P>
Each of these coordinate types can be set for each of the standard grid shapes
described in section <A HREF="#sec:ShapeShortcut">19.1.3</A>.  

<P>
The table below shows how examples of common single Tile grids fall 
into this shape and coordinate taxonomy.  Note that any
of the grids in the table can have a regular or arbitrary distribution.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Uniform</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Rectilinear</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Curvilinear</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58><B>Sphere</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Global uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Gaussian grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Displaced pole grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58><B>Rectangle</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Regional uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Gaussian grid section</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Polar stereographic grid section</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION05051600000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">6</SPAN> Coordinate Specification and Generation</A>
</H3>

<P>
There are two ways of specifying coordinates in ESMF.  The
first way is for the user to <B>set</B> the coordinates.  The second 
way is to take a shortcut and have the framework <B>generate</B>
the coordinates.  

<P>
No ESMF generation routines are currently available.

<P>

<H3><A NAME="SECTION05051700000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">7</SPAN> Staggering</A>
</H3>

<P>
<B>Staggering</B> is a finite difference technique in which the values 
of different physical quantities are placed at different locations
within a grid cell. 

<P>
The ESMF Grid class supports a variety of stagger locations, including
cell centers, corners, and edge centers. The default stagger location in 
ESMF is the cell center, and cell counts in Grid are based on this assumption.
Combinations of the 2D ESMF stagger locations are sufficient to specify any of the
Arakawa staggers.  ESMF also supports staggering in 3D and higher dimensions.
There are shortcuts for standard staggers, and interfaces through which users 
can create custom staggers.  

<P>
As a default the ESMF Grid class provides symmetric staggering, so
that cell centers are enclosed by cell perimeter (e.g. corner) 
stagger locations. This means the coordinate arrays for stagger
locations other than the center will have an additional element of 
padding in order to enclose the cell center locations.
However, to achieve other types of staggering, the user may alter 
or eliminate this padding by using the appropriate options when adding
coordinates to a Grid. 

<P>

<H3><A NAME="SECTION05051800000000000000"></A>
<A NAME="sec:usage:items"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">8</SPAN> Masking
</H3>

<P>
Masking is the process whereby parts of a grid can be marked to be
ignored during an operation, such as regridding.  Masking can be
used on a source grid to indicate that certain portions of the grid
should not be used to generate regridded data.  This is useful, for
example, if a portion of the source grid contains unusable values.
Masking can also be used on a destination grid to indicate that the
portion of the field built on that part of the Grid should not
receive regridded data.  This is useful, for example, when part of
the grid isn't being used (e.g. the land portion of an ocean grid).

<P>
ESMF regrid currently supports masking for Fields built on
structured Grids and element masking for Fields built on
unstructured Meshes. The user may mask out points in the source
Field or destination Field or both. To do masking the user sets
mask information in the Grid 
or Mesh 
upon which the Fields passed into the
<TT>ESMC_FieldRegridStore()</TT> call are built. The <TT>srcMaskValues</TT> 
and <TT>dstMaskValues</TT> arguments to that
call can then be used to specify which values in that mask
information indicate that a location should be masked out. For
example, if <TT>dstMaskValues</TT> is set to (/1,2/), then any location that
has a value of 1 or 2 in the mask information of the Grid or Mesh
upon which the destination Field is built will be masked out.

<P>
Masking behavior differs slightly between regridding methods. For
non-conservative regridding methods (e.g. bilinear or high-order
patch), masking is done on points. For these methods, masking a
destination point means that that point won't participate in
regridding (e.g. won't be interpolated to). For these methods,
masking a source point means that the entire source cell using
that point is masked out. In other words, if any corner point
making up a source cell is masked then the cell is masked. For
conservative regridding methods (e.g. first-order conservative)
masking is done on cells. Masking a destination cell means that
the cell won't participate in regridding (e.g. won't be
interpolated to). Similarly, masking a source cell means that the
cell won't participate in regridding (e.g. won't be interpolated
from).  For any type of interpolation method (conservative or
non-conservative) the masking is set on the location upon
which the Fields passed into the regridding call are built.
For example, if Fields built on  <TT>ESMC_STAGGERLOC_CENTER</TT> are
passed into the <TT>ESMC_FieldRegridStore()</TT> call then the masking
should also be set on <TT>ESMC_STAGGERLOC_CENTER</TT>.

<H2><A NAME="SECTION05052000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05052100000000000000"></A>
<A NAME="const:ccoordsys"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_COORDSYS
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
 A set of values which indicates in which system the coordinates in the Grid are. This value is useful both to indicate to 
other users the type of the coordinates, but also to control how the coordinates are interpreted in regridding methods 
(e.g. <TT>ESMC_FieldRegridStore()</TT>).

<P>
The type of this flag is:

<P>
<TT>type(ESMC_CoordSys_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_COORDSYS_CART</STRONG></DT>
<DD>Cartesian coordinate system. In this system, the cartesian coordinates are mapped to the Grid coordinate dimensions in the following order: x,y,z. (E.g. using <TT>coordDim=2</TT> in ESMC_GridGetCoord() references the y dimension) 

<P>
</DD>
<DT><STRONG>ESMC_COORDSYS_SPH_DEG</STRONG></DT>
<DD>Spherical coordinates in degrees. In this system, the spherical coordinates are mapped to the Grid coordinate dimensions in the following order: longitude, latitude, radius. (E.g. using <TT>coordDim=2</TT> in ESMC_GridGetCoord() references the latitude dimension) Note, however, that ESMC_FieldRegridStore() currently just supports longitude and latitude (i.e. with this system, only Grids of dimension 2 are supported in the regridding).

<P>
</DD>
<DT><STRONG>ESMC_COORDSYS_SPH_RAD</STRONG></DT>
<DD>Spherical coordinates in radians. In this system, the spherical coordinates are mapped to the Grid coordinate dimensions in the following order: longitude, latitude, radius. (E.g. using <TT>coordDim=2</TT> in ESMC_GridGetCoord() references the latitude dimension) Note, however, that ESMC_FieldRegridStore() currently just supports longitude and latitude (i.e. with this system, only Grids of dimension 2 are supported in the regridding).

<P>
</DD>
</DL>

<P>

<H3><A NAME="SECTION05052200000000000000"></A>
<A NAME="const:cgriditem"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_GRIDITEM
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
The ESMC Grid can contain other kinds of data besides coordinates. 
This data is referred to as Grid &ldquo;items&rdquo;. Some items may be used
by ESMC for calculations involving the Grid. The following
are the valid values of ESMC_GridItem_Flag.

<P>
The type of this flag is:

<P>
<TT>type(ESMC_GridItem_Flag)</TT>

<P>
The valid values are:
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Item Label</TD>
<TD ALIGN="CENTER"><B>Type Restriction</B></TD>
<TD ALIGN="CENTER"><B>Type Default</B></TD>
<TD ALIGN="CENTER"><B>ESMC Uses</B></TD>
<TD ALIGN="CENTER"><B>Controls</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMC_GRIDITEM_MASK</B></TD>
<TD ALIGN="CENTER">ESMC_TYPEKIND_I4</TD>
<TD ALIGN="CENTER">ESMC_TYPEKIND_I4</TD>
<TD ALIGN="CENTER">YES</TD>
<TD ALIGN="CENTER">Masking in Regrid</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMC_GRIDITEM_AREA</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">ESMC_TYPEKIND_R8</TD>
<TD ALIGN="CENTER">YES</TD>
<TD ALIGN="CENTER">Conservation in Regrid</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION05052300000000000000"></A>
<A NAME="const:cgridstatus"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_GRIDSTATUS
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
The ESMC Grid class can exist in two states. These states are
present so that the library code can detect if a Grid has been
appropriately setup for the task at hand. The following
are the valid values of ESMC_GRIDSTATUS.

<P>
The type of this flag is:

<P>
<TT>type(ESMC_GridStatus_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_GRIDSTATUS_EMPTY:</STRONG></DT>
<DD>Status after a Grid has been created with 
      <TT>ESMC_GridEmptyCreate</TT>.  A Grid object container is allocated but
      space for internal objects is not.  Topology information and coordinate
      information is incomplete.  This object can be used in <TT>ESMC_GridEmptyComplete()</TT>
      methods in which additional information is added to the Grid.
</DD>
<DT><STRONG>ESMC_GRIDSTATUS_COMPLETE:</STRONG></DT>
<DD>The Grid has a specific topology and
      distribution, but incomplete coordinate arrays.  The Grid can be used
      as the basis for allocating a Field, and coordinates can be added
      via <TT>ESMC_GridCoordAdd()</TT> to allow other functionality. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION05052400000000000000"></A>
<A NAME="const:cpolekind"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_POLEKIND
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
This type describes the type of connection that occurs at the pole when a Grid is 
created with <TT>ESMC_GridCreate1PeriodicDim()</TT>.

<P>
The type of this flag is:

<P>
<TT>type(ESMC_PoleKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_POLEKIND_NONE</STRONG></DT>
<DD>No connection at pole.

<P>
</DD>
<DT><STRONG>ESMC_POLEKIND_MONOPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element i+n/2.

<P>
</DD>
<DT><STRONG>ESMC_POLEKIND_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i+1.
</DD>
</DL>

<P>

<H3><A NAME="SECTION05052500000000000000"></A>
<A NAME="const:cstaggerloc"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_STAGGERLOC
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
 In the ESMC Grid class, data can be located at different positions in a
 Grid cell.  When setting or retrieving coordinate data the stagger location is
 specified to tell the Grid method  from where in the cell to get the data. 
 Although the user may define their own custom stagger locations, 
 ESMC provides a set of predefined locations for ease of use. The
following are the valid predefined stagger locations. 

<P>

<P>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridstaggerloc2d"></A><A NAME="5148"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 9:</STRONG>
2D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}$
 -->
<IMG
 WIDTH="465" HEIGHT="275" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The 2D predefined stagger locations (illustrated in figure&nbsp;<A HREF="#fig:gridstaggerloc2d">9</A>) are:
<BR><DL>
<DT><STRONG>ESMC_STAGGERLOC_CENTER:</STRONG></DT>
<DD>The center of the cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_CORNER:</STRONG></DT>
<DD>The corners of the cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE1:</STRONG></DT>
<DD>The edges offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE2:</STRONG></DT>
<DD>The edges offset from the center in the 2nd dimension.
</DD>
</DL>

<P>

<P>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridstaggerloc3d"></A><A NAME="5159"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 10:</STRONG>
3D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}$
 -->
<IMG
 WIDTH="433" HEIGHT="333" ALIGN="BOTTOM" BORDER="0"
 SRC="img13.png"
 ALT="\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The 3D predefined stagger locations (illustrated in figure&nbsp;<A HREF="#fig:gridstaggerloc3d">10</A>) are:
<BR><DL>
<DT><STRONG>ESMC_STAGGERLOC_CENTER_VCENTER:</STRONG></DT>
<DD>The center of the 3D cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_CORNER_VCENTER:</STRONG></DT>
<DD>Half way up the vertical edges of the cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE1_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 1 and the vertical dimension.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE2_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 2 and the vertical dimension. 
</DD>
<DT><STRONG>ESMC_STAGGERLOC_CORNER_VFACE:</STRONG></DT>
<DD>The corners of the 3D cell.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE1_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_EDGE2_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 2nd dimension.
</DD>
<DT><STRONG>ESMC_STAGGERLOC_CENTER_VFACE:</STRONG></DT>
<DD>The center of the top and bottom face. The face bounded by the 1st and 2nd dimensions. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION05052600000000000000"></A>
<A NAME="const:cfileformat"></A>
<BR>
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_FILEFORMAT
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
This option is used by <TT>ESMC_GridCreateFromFile</TT> to specify the type of the input grid file.

<P>
The type of this flag is:

<P>
<TT>type(ESMC_FileFormat_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMC_FILEFORMAT_SCRIP</STRONG></DT>
<DD>SCRIP format grid file. The SCRIP format is the format accepted by the SCRIP regridding tool&nbsp;[<A
 HREF="node8.html#ref:SCRIP">1</A>].   For Grid creation, files of this type only work when the <TT>grid_rank</TT> in the file is equal to 2.

<P>
</DD>
<DT><STRONG>ESMC_FILEFORMAT_GRIDSPEC</STRONG></DT>
<DD>a single tile grid file comforming with the proposed CF-GRIDSPEC conventions.
</DD>
</DL>

<H2><A NAME="SECTION05053000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Grids with factorized coordinates can only be redisted when they are 2D.</B>
Using the ESMF_GridCreate() interface that allows the user to create a copy of an existing Grid with a new distribution will give incorrect results when used on a Grid with 3 or more dimensions and whose coordinate arrays are less than the full dimension of the Grid (i.e. it contains factorized coordinates).

<P>
</LI>
<LI><B>7D limit.</B>  Only grids up to 7D will be supported.

<P>
</LI>
<LI><B>Future adaptation.</B>  Currently Grids
are created and then remain unchanged. In the future, it would
be useful to provide support for the various forms of grid
adaptation. This would allow the grids to dynamically change
their resolution to more closely match what is needed at a particular
time and position during a computation for front tracking or adaptive meshes.

<P>
</LI>
<LI><B>Future Grid generation.</B> This class for now only contains
the basic functionality for operating on the grid. In the future
methods will be added to enable the automatic generation of various types of
grids. 

<P>
</LI>
</UL>

<H2><A NAME="SECTION05054000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<H3><A NAME="SECTION05054100000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Grid Topology</A>
</H3> 

<P>
The <TT>ESMF_Grid</TT> class depends upon the <TT>ESMF_DistGrid</TT> class
for the specification of its topology. That is, when 
creating a Grid, first an <TT>ESMF_DistGrid</TT> is created to describe the 
appropriate index space topology. This decision was
made because it seemed redundant to have a system for doing this
in both classes. It also seems most appropriate for
the machinary for topology creation to be located at the lowest
level possible so that it can be used by other
classes (e.g. the <TT>ESMF_Array</TT> class). Because of this, however,
the authors recommend that as a natural part of the 
implementation of subroutines to generate standard grid shapes
(e.g. <TT>ESMF_GridGenSphere</TT>) a set of standard
topology generation subroutines be implemented (e.g. <TT>ESMF_DistGridGenSphere</TT>) for users who want to create a standard topology, but a custom geometry.

<P>

<H2><A NAME="SECTION05055000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API: General Grid Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05055100000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_GridCreateNoPeriDim - Create a Grid with no periodic dimensions</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Grid ESMC_GridCreateNoPeriDim(
   ESMC_InterArrayInt *maxIndex,           // in
   enum ESMC_CoordSys_Flag *coordSys,      // in
   enum ESMC_TypeKind_Flag *coordTypeKind, // in
   enum ESMC_IndexFlag *indexflag,         // in
   int *rc                                 // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    type(ESMC_Grid)
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call creates an ESMC_Grid with no periodic dimensions.

<P>
The arguments are:
    <DL>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
    
</DD>
<DT><STRONG>coordSys</STRONG></DT>
<DD>The coordinated system of the grid coordinate data. If not specified then
        defaults to ESMF_COORDSYS_SPH_DEG.
    
</DD>
<DT><STRONG>coordTypeKind</STRONG></DT>
<DD>The type/kind of the grid coordinate data.  If not specified then the
        type/kind will be 8 byte reals.
    
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. If not present,
        defaults to ESMC_INDEX_DELOCAL.
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055200000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_GridCreate1PeriDim - Create a Grid with 1 periodic dimension</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Grid ESMC_GridCreate1PeriDim(
   ESMC_InterArrayInt *maxIndex,           // in
   ESMC_InterArrayInt *polekindflag,       // in
   int *periodicDim,                       // in
   int *poleDim,                           // in
   enum ESMC_CoordSys_Flag *coordSys,      // in
   enum ESMC_TypeKind_Flag *coordTypeKind, // in
   enum ESMC_IndexFlag *indexflag,         // in
   int *rc                                 // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    type(ESMC_Grid)
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call creates an ESMC_Grid with 1 periodic dimension.

<P>
The arguments are:
    <DL>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
    
</DD>
<DT><STRONG>polekindflag</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the
        pole. polekindflag(1) the connection that occurs at the minimum end of the
        index dimension. polekindflag(2) the connection that occurs at the maximum
        end of the index dimension. If not specified, the default is
        ESMF_POLETYPE_MONOPOLE for both.
    
</DD>
<DT><STRONG>periodicDim</STRONG></DT>
<DD>The periodic dimension.  If not specified, defaults to 1.
    
</DD>
<DT><STRONG>poleDim</STRONG></DT>
<DD>The dimension at which the poles are located at the ends.  If not
        specified, defaults to 2.
    
</DD>
<DT><STRONG>coordSys</STRONG></DT>
<DD>The coordinated system of the grid coordinate data. If not specified then
        defaults to ESMF_COORDSYS_SPH_DEG.
    
</DD>
<DT><STRONG>coordTypeKind</STRONG></DT>
<DD>The type/kind of the grid coordinate data.  If not specified then the
        type/kind will be 8 byte reals.
    
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. If not present,
        defaults to ESMC_INDEX_DELOCAL.
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055300000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_GridCreateCubedSphere - Create a cubed sphere Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Grid ESMC_GridCreateCubedSphere(
   int *tilesize,                      // in
   ESMC_InterArrayInt *regDecompPTile, // in
   //ESMC_InterArrayInt *decompFlagPTile,  // in
   //ESMC_InterArrayInt *deLabelList,    // in
   //ESMC_DELayout *delayout,            // in
   ESMC_InterArrayInt *staggerLocList,   // in
   const char *name,                   // in
   int *rc);                           // out
</PRE><EM>RETURN VALUE:</EM>
<PRE>    type(ESMC_Grid)
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a six-tile <TT>ESMC_Grid</TT> for a cubed sphere grid using regular
    decomposition.  Each tile can have different decomposition. The grid
    coordinates are generated based on the algorithm used by GEOS-5. The tile
    resolution is defined by tileSize.

<P>
The arguments are:
    <DL>
<DT><STRONG>tilesize</STRONG></DT>
<DD>The number of elements on each side of the tile of the cubed sphere grid.
    
</DD>
<DT><STRONG>regDecompPTile</STRONG></DT>
<DD>List of DE counts for each dimension. The second index steps through
        the tiles. The total <TT>deCount</TT> is determined as the sum over
        the products of <TT>regDecompPTile</TT> elements for each tile.
        By default every tile is decomposed in the same way.  If the total
        PET count is less than 6, one tile will be assigned to one DE and the DEs
        will be assigned to PETs sequentially, therefore, some PETs may have
        more than one DE. If the total PET count is greater than 6, the total
        number of DEs will be a multiple of 6 and less than or equal to the total
        PET count. For instance, if the total PET count is 16, the total DE count
        will be 12 with each tile decomposed into 1x2 blocks. The 12 DEs are mapped
        to the first 12 PETs and the remaining 4 PETs have no DEs locally, unless
        an optional <TT>delayout</TT> is provided.
    
</DD>
<DT><STRONG>staggerLocList</STRONG></DT>
<DD>The list of stagger locations to fill with coordinates. Only <TT>ESMF_STAGGERLOC_CENTER</TT> and
        <TT>ESMF_STAGGERLOC_CORNER</TT> are supported. If not present, no coordinates will be added or filled.
    
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the <TT>ESMC_Grid</TT>.
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055400000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_GridCreateFromFile - Create a Grid from a NetCDF file specification.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Grid ESMC_GridCreateFromFile(const char *filename, int fileTypeFlag, 
                   int *regDecomp, int *decompflag,
                   int *isSphere, ESMC_InterArrayInt *polekindflag,
                   int *addCornerStagger,
                   int *addUserArea, enum ESMC_IndexFlag *indexflag,
                   int *addMask, const char *varname,
                   const char **coordNames, int *rc);
</PRE><EM>RETURN VALUE:</EM>
<PRE>    type(ESMC_Grid)
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This function creates a <TT>ESMC_Grid</TT> object from the specification in
   a NetCDF file.

<P>
The arguments are:
    <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The NetCDF Grid filename.
   
</DD>
<DT><STRONG>fileTypeFlag</STRONG></DT>
<DD>The Grid file format, please see Section&nbsp;<A HREF="#const:cfileformat">19.2.6</A>
           for a list of valid options. 
   
</DD>
<DT><STRONG>regDecomp</STRONG></DT>
<DD>A 2 element array specifying how the grid is decomposed.
        Each entry is the number of decounts for that dimension.
        The total decounts cannot exceed the total number of PETs.  In other
        word, at most one DE is allowed per processor.
        If not specified, the default decomposition will be petCountx1.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node9.html#const:cdecompflag">34.3</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[isSphere]</STRONG></DT>
<DD>Set to 1 for a spherical grid, or 0 for regional. Defaults to 1.
    
</DD>
<DT><STRONG>polekindflag</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the
        pole. polekindflag(1) the connection that occurs at the minimum end of the
        index dimension. polekindflag(2) the connection that occurs at the maximum
        end of the index dimension. If not specified, the default is
        ESMF_POLETYPE_MONOPOLE for both.
   
</DD>
<DT><STRONG>[addCornerStagger]</STRONG></DT>
<DD>Set to 1 to use the information in the grid file to add the Corner stagger to 
        the Grid. The coordinates for the corner stagger are required for conservative
        regridding. If not specified, defaults to 0. 
   
</DD>
<DT><STRONG>[addUserArea]</STRONG></DT>
<DD>Set to 1 to read in the cell area from the Grid file; otherwise, ESMF will 
        calculate it.  This feature is only supported when the grid file is in the SCRIP
        format.  
    
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. If not present,
        defaults to ESMC_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[addMask]</STRONG></DT>
<DD>Set to 1 to generate the mask using the missing_value attribute defined in 'varname'.
        This flag is only needed when the grid file is in the GRIDSPEC format.
   
</DD>
<DT><STRONG>[varname]</STRONG></DT>
<DD>If addMask is non-zero, provide a variable name stored in the grid file and
        the mask will be generated using the missing value of the data value of
        this variable.  The first two dimensions of the variable has to be the
        longitude and the latitude dimension and the mask is derived from the
        first 2D values of this variable even if this data is 3D, or 4D array.
  
</DD>
<DT><STRONG>[coordNames]</STRONG></DT>
<DD>A two-element array containing the longitude and latitude variable names in a
        GRIDSPEC file if there are multiple coordinates defined in the file.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055500000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_GridDestroy - Destroy a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_GridDestroy(
   ESMC_Grid *grid             // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy the Grid.

<P>
The arguments are:
    <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid object whose memory is to be freed. 
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055600000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_GridAddItem - Add items to a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_GridAddItem(
   ESMC_Grid grid,                   // in
   enum ESMC_GridItem_Flag itemflag, // in
   enum ESMC_StaggerLoc staggerloc   // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add an item (e.g. a mask) to the Grid.

<P>
The arguments are:
    <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid object to which the coordinates will be added
    
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The grid item to add.
    
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to add.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055700000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMC_GridGetItem - Get item from a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void * ESMC_GridGetItem(
   ESMC_Grid grid,                         // in
   enum ESMC_GridItem_Flag itemflag,       // in
   enum ESMC_StaggerLoc staggerloc,        // in
   int *localDE,                           // in
   int *rc                                 // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    A pointer to the item data.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a pointer to item data (e.g. mask data) in the Grid.

<P>
The arguments are:
    <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid object from which to obtain the coordinates.
    
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The grid item to add.
    
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to add.
    
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local decompositional element. If not present, defaults to 0.
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055800000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMC_GridAddCoord - Add coordinates to a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_GridAddCoord(
   ESMC_Grid grid,                   // in
   enum ESMC_StaggerLoc staggerloc   // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add coordinates to the Grid.

<P>
The arguments are:
    <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid object to which the coordinates will be added
    
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to add.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055900000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMC_GridGetCoord - Get coordinates from a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void * ESMC_GridGetCoord(
   ESMC_Grid grid,                         // in
   int coordDim,                           // in
   enum ESMC_StaggerLoc staggerloc,        // in
   int *localDE,
   int *exclusiveLBound,                   // out
   int *exclusiveUBound,                   // out
   int *rc                                 // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    A pointer to coordinate data in the Grid.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a pointer to coordinate data in the Grid.

<P>
The arguments are:
    <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid object from which to obtain the coordinates.
    
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension from which to get the data.
    
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to add.
    
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local decompositional element. If not present, defaults to 0.
    
</DD>
<DT><STRONG>exclusiveLBound</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region. This bound
      must be allocated to be of size equal to the coord dimCount.  
    
</DD>
<DT><STRONG>exclusiveUBound</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region. This bound
      must be allocated to be of size equal to the coord dimCount.  
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551000000000000000">
<SPAN CLASS="arabic">19</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMC_GridGetCoordBounds - Get coordinate bounds from a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_GridGetCoordBounds(
   ESMC_Grid grid,                         // in
   enum ESMC_StaggerLoc staggerloc,        // in
   int *localDE,                           // in
   int *exclusiveLBound,                   // out
   int *exclusiveUBound,                   // out
   int *rc                                 // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get coordinates bounds from the Grid.

<P>
The arguments are:
    <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid object from which to obtain the coordinates.
    
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to add.
    
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local decompositional element. If not present, defaults to 0.
    
</DD>
<DT><STRONG>exclusiveLBound</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region. This bound
      must be allocated to be of size equal to the coord dimCount.  
    
</DD>
<DT><STRONG>exclusiveUBound</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region. This bound
      must be allocated to be of size equal to the coord dimCount.  
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
    
</DD>
</DL>

<P>


<H1><A NAME="SECTION05060000000000000000">
<SPAN CLASS="arabic">20</SPAN> Mesh Class</A>
</H1>

<H2><A NAME="SECTION05061000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
Unstructured grids are commonly used in the computational solution of Partial Differential equations.  These are especially useful for problems that involve complex geometry, where using the less flexible structured grids can
result in grid representation of regions where no computation is needed.  Finite
element and finite volume methods map naturally to unstructured grids and are used commonly
in hydrology, ocean modeling, and many other applications.

<P>
In order to provide support for application codes using unstructured grids, the ESMF library provides a class for representing 
unstructured grids called the <B>Mesh</B>. Fields can be created on a Mesh to hold data. In Fortran, Fields created on a Mesh can also be used 
as either the source or destination or both of an interpolation (i.e. an <TT>ESMF_FieldRegridStore()</TT> call). This capability is currently
not supported with the C interface, however, if the C Field is passed via a State to a component written in Fortran then the regridding
can be performed there. The rest of this section describes the Mesh class and how to create and use them in ESMF. 

<P>

<H3><A NAME="SECTION05061100000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Mesh Representation in ESMF</A>
</H3>

<P>
A Mesh in ESMF is described in terms of <B>nodes</B> and <B>elements</B>. A node is a point in space which represents where the coordinate 
information in a Mesh is located. An element is a higher dimensional shape constructed of nodes. Elements give a Mesh its shape and define the relationship of the nodes to one another. Field data may be located on a Mesh's nodes. 

<P>

<H3><A NAME="SECTION05061200000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Supported Meshes</A>
</H3>

<P>
The range of Meshes supported by ESMF are defined by several factors: dimension, element types, and distribution.

<P>
ESMF currently only supports Meshes whose number of coordinate dimensions (spatial dimension) is 2 or 3. The dimension of the elements in a Mesh
(parametric dimension) must be less than or equal to the spatial dimension, but also must be either 2 or 3. This means that an ESMF mesh may be
either 2D elements in 2D space, 3D elements in 3D space, or a manifold constructed of 2D elements embedded in 3D space. 

<P>
ESMF currently supports two types of elements for each Mesh parametric dimension. For a parametric dimension of 2 the 
supported element types are triangles or quadrilaterals. For a parametric dimension of 3 the supported element types are tetrahedrons
and hexahedrons. See Section&nbsp;<A HREF="#const:cmeshelemtype">20.2.1</A> for diagrams of these. The Mesh supports any combination of element types within a particular
dimension, but types from different dimensions may not be mixed, for example, a Mesh cannot be constructed of both quadrilaterals and tetrahedra.

<P>
ESMF currently only supports distributions where every node on a PET must be a part of an element on that PET. In other words, there 
must not be nodes without an element on a PET. 

<H2><A NAME="SECTION05062000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05062100000000000000"></A>
<A NAME="const:cmeshelemtype"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_MESHELEMTYPE
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
 An ESMF Mesh can be constructed from a combination of different elements. The type of elements that can
be used in a Mesh depends on the Mesh's parametric dimension, which is set during Mesh creation. The
following are the valid Mesh element types for each valid Mesh parametric dimension (2D or 3D) .

<P>

<P>
<BR>

<P>
<PRE>
                     3                          4 ---------- 3
                    / \                         |            |  
                   /   \                        |            |
                  /     \                       |            |
                 /       \                      |            |
                /         \                     |            |
               1 --------- 2                    1 ---------- 2

           ESMC_MESHELEMTYPE_TRI            ESMC_MESHELEMTYPE_QUAD

2D element types (numbers are the order for elementConn during 
                  Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 2 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMC_MESHELEMTYPE_TRI</TD>
<TD ALIGN="CENTER">3</TD>
<TD ALIGN="LEFT">A triangle</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMC_MESHELEMTYPE_QUAD</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A quadrilateral (e.g. a rectangle)</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<BR>

<P>
<PRE>
                                            
                 3                               8---------------7
                /|\                             /|              /|
               / | \                           / |             / |
              /  |  \                         /  |            /  |
             /   |   \                       /   |           /   |
            /    |    \                     5---------------6    |
           4-----|-----2                    |    |          |    |
            \    |    /                     |    4----------|----3
             \   |   /                      |   /           |   /
              \  |  /                       |  /            |  /
               \ | /                        | /             | /
                \|/                         |/              |/
                 1                          1---------------2

       ESMC_MESHELEMTYPE_TETRA             ESMC_MESHELEMTYPE_HEX  

3D element types (numbers are the order for elementConn during 
                  Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 3 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMC_MESHELEMTYPE_TETRA</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A tetrahedron (CAN'T BE USED IN REGRID)</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMC_MESHELEMTYPE_HEX</TD>
<TD ALIGN="CENTER">8</TD>
<TD ALIGN="LEFT">A hexahedron (e.g. a cube)</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION05062200000000000000"></A>
<A NAME="const:mesh:cfileformat"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_FILEFORMAT
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
This option is used by <TT>ESMF_MeshCreate</TT> to specify the type of the input grid file.  

<P>
The type of this flag is:

<P>
<TT>type(ESMF_FileFormat_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_FILEFORMAT_SCRIP</STRONG></DT>
<DD>SCRIP format grid file. The SCRIP format is the format accepted by the SCRIP regridding tool&nbsp;[<A
 HREF="node8.html#ref:SCRIP">1</A>].   For Mesh creation, files of this type only work when the <TT>grid_rank</TT> in the file is equal to 1.

<P>
</DD>
<DT><STRONG>ESMF_FILEFORMAT_ESMFMESH</STRONG></DT>
<DD>ESMF unstructured grid file format. This format was developed by the ESMF team to match the capabilities of the Mesh class and to be efficient to convert to that class. 

<P>
</DD>
<DT><STRONG>ESMF_FILEFORMAT_UGRID</STRONG></DT>
<DD>CF-convention unstructured grid file format. This format is a proposed extension to the 
CF-conventions for unstructured grid data model. Currently, only the 2D flexible mesh topology is supported in ESMF.
</DD>
</DL>

<H2><A NAME="SECTION05063000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05063100000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_MeshGetMOAB - Query if the MOAB mesh backend is enabled</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_MeshGetMOAB(
   bool *moabOn,
   int *rc
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    None
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call will query whether or not the MOAB mesh backend is enabled.

<P>
The arguments are:
    <DL>
<DT><STRONG>moabOn</STRONG></DT>
<DD>This parameter will receive a boolean value indicating if MOAB is enabled.
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063200000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_MeshSetMOAB - Toggle the MOAB mesh backend</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_MeshSetMOAB(
   bool moabOn,
   int *rc
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    None
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call will toggle the MOAB mesh backend.

<P>
The arguments are:
    <DL>
<DT><STRONG>moabOn</STRONG></DT>
<DD>This parameter will hold a boolean value to indicate the setting for the
      MOAB mesh back end (on or off).
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063300000000000000"></A><A NAME="sec:mesh:capi:meshaddelements"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_MeshAddElements - Add elements to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_MeshAddElements(
   ESMC_Mesh mesh,           // inout
   int  elementCount,        // in
   int *elementIds,          // in
   int *elementTypes,        // in
   int *elementConn,         // in
   int *elementMask,         // in
   double *elementArea,      // in
   double *elementCoords     // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call is the third and last part of the three part mesh create
     sequence and should be called after the mesh is created with <TT>ESMF_MeshCreate()</TT>
     (<A HREF="#sec:mesh:capi:meshcreate">20.3.5</A>)
     and after the nodes are added with <TT>ESMF_MeshAddNodes()</TT> (<A HREF="#sec:mesh:capi:meshaddnodes">20.3.4</A>).
     This call adds the elements to the
     mesh and finalizes the create. After this call the Mesh is usable, for
     example a Field may be built on the created Mesh object and
     this Field may be used in a <TT>ESMF_FieldRegridStore()</TT> call.

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementConn</TT> describe the elements to be created. The description
     for a particular element lies at the same index location in <TT>elementIds</TT>
     and <TT>elementTypes</TT>. Each entry in <TT>elementConn</TT> consists of the list of
     nodes used to create that element, so the connections for element <SPAN CLASS="MATH"><IMG
 WIDTH="11" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$e$"></SPAN> in the
     <TT>elementIds</TT> array will start at <!-- MATH
 $number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
     \cdots + number\_of\_nodes\_in\_element(e-1) + 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="840" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="$number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
\cdots + number\_of\_nodes\_in\_element(e-1) + 1$"></SPAN> in <TT>elementConn</TT>.

<P>
<DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object.
     
</DD>
<DT><STRONG>elementCount</STRONG></DT>
<DD>The number of elements on this PET.
     
</DD>
<DT><STRONG>elementIds</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET.
            This input consists of a 1D array of size <TT>elementCount</TT>.
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="#const:cmeshelemtype">20.2.1</A> for the list of options. This
            input consists of a 1D array of size <TT>elementCount</TT>.
     
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids,
           but rather each entry is a local index (1 based) into the list of nodes which were
           created on this PET by the previous <TT>ESMC_MeshAddNodes()</TT> call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. passed into the
           <TT>ESMC_MeshAddNodes()</TT> call on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="#const:cmeshelemtype">20.2.1</A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with
           a total size equal to the sum of the number of nodes in each element on
           this PET. The number of nodes in each element is implied by its element type in
           <TT>elementTypes</TT>. The nodes for each element
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.).
     
</DD>
<DT><STRONG>[elementMask]</STRONG></DT>
<DD>An array containing values which can be used for element masking.
           Which values indicate masking are chosen via the srcMaskValues or
           dstMaskValues arguments to ESMF_FieldRegridStore() call. This input
           consists of a 1D array the size of the number of elements on this
           PET. If not specified (i.e. NULL is passed in), then no masking will occur.
     
</DD>
<DT><STRONG>[elementArea]</STRONG></DT>
<DD>An array containing element areas.  This input consists of a 1D array
            the size of the number of elements on this PET. If not specified (i.e. NULL is passed in), the
            element areas are internally calculated.
     
</DD>
<DT><STRONG>[elementCoords]</STRONG></DT>
<DD>An array containing the physical coordinates of the elements to be created on this
            PET. This input consists of a 1D array the size of the number of elements on this PET times the Mesh's
            spatial dimension (<TT>spatialDim</TT>). The coordinates in this array are ordered
            so that the coordinates for an element lie in sequence in memory. (e.g. for a
            Mesh with spatial dimension 2, the coordinates for element 1 are in elementCoords(1) and
            elementCoords(2), the coordinates for element 2 are in elementCoords(3) and elementCoords(4),
            etc.).

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063400000000000000"></A><A NAME="sec:mesh:capi:meshaddnodes"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_MeshAddNodes - Add nodes to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_MeshAddNodes(
   ESMC_Mesh mesh,          // inout
   int nodeCount,           // in
   int *nodeIds,            // in
   double *nodeCoords,      // in
   int *nodeOwners          // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call is the second part of the three part mesh create
     sequence and should be called after the mesh's dimensions are set
     using <TT>ESMC_MeshCreate()</TT>.
     This call adds the nodes to the
     mesh. The next step is to call <TT>ESMC_MeshAddElements()</TT> (<A HREF="#sec:mesh:capi:meshcreate">20.3.5</A>).

<P>
The parameters to this call <TT>nodeIds</TT>, <TT>nodeCoords</TT>, and
     <TT>nodeOwners</TT> describe the nodes to be created on this PET.
     The description for a particular node lies at the same index location in
     <TT>nodeIds</TT> and <TT>nodeOwners</TT>. Each entry
     in <TT>nodeCoords</TT> consists of spatial dimension coordinates, so the coordinates
     for node <SPAN CLASS="MATH"><IMG
 WIDTH="14" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img16.png"
 ALT="$n$"></SPAN> in the <TT>nodeIds</TT> array will start at <!-- MATH
 $(n-1)*spatialDim+1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="177" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$(n-1)*spatialDim+1$"></SPAN>.

<P>
<DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object.
     
</DD>
<DT><STRONG>nodeCount</STRONG></DT>
<DD>The number of nodes on this PET.
     
</DD>
<DT><STRONG>nodeIds</STRONG></DT>
<DD>An array containing the global ids of the nodes to be created on this PET.
          This input consists of a 1D array the size of the number of nodes on this PET (i.e. <TT>nodeCount</TT>).
     
</DD>
<DT><STRONG>nodeCoords</STRONG></DT>
<DD>An array containing the physical coordinates of the nodes to be created on this
            PET. The coordinates in this array are ordered
            so that the coordinates for a node lie in sequence in memory. (e.g. for a
            Mesh with spatial dimension 2, the coordinates for node 1 are in nodeCoords(0) and
            nodeCoords(1), the coordinates for node 2 are in nodeCoords(2) and nodeCoords(3),
            etc.). This input consists of a 1D array the size of <TT>nodeCount</TT> times the Mesh's
            spatial dimension (<TT>spatialDim</TT>).
     
</DD>
<DT><STRONG>nodeOwners</STRONG></DT>
<DD>An array containing the PETs that own the nodes to be created on this PET.
           If the node is shared with another PET, the value
           may be a PET other than the current one. Only nodes owned by this PET
           will have PET local entries in a Field created on the Mesh. This
           input consists of a 1D array the size of the number of nodes on this PET (i.e. <TT>nodeCount</TT>).
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063500000000000000"></A><A NAME="sec:mesh:capi:meshcreate"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_MeshCreate - Create a Mesh as a 3 step process 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Mesh ESMC_MeshCreate(
   int parametricDim,         // in
   int spatialDim,            // in
   enum ESMC_CoordSys_Flag *coordSys, // in
   int *rc                    // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    type(ESMC_Mesh)         :: ESMC_MeshCreate
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call is the first part of the three part mesh create sequence. This call sets the dimension of the elements
    in the mesh (<TT>parametricDim</TT>) and the number of coordinate dimensions in the mesh (<TT>spatialDim</TT>).
    The next step is to call <TT>ESMC_MeshAddNodes()</TT> (<A HREF="#sec:mesh:capi:meshaddnodes">20.3.4</A>) to add the nodes and then
    <TT>ESMC_MeshAddElements(</TT>)  (<A HREF="#sec:mesh:capi:meshaddelements">20.3.3</A>)
    to add the elements and finalize the mesh.

<P>
The arguments are:
    <DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would have a parametric dimension
      of 2, whereas a Mesh constructed of cubes would have one of 3.)
    
</DD>
<DT><STRONG>spatialDim</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes making up the Mesh. For a
    manifold, the spatial dimension can be larger than the parametric dim (e.g. the 2D
    surface of a sphere in 3D space),
     but it can't be smaller.
    
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>Set the coordinate system of the mesh. If not specified, then
    defaults to ESMC_COORDSYS_SPH_DEG.
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063600000000000000"></A><A NAME="sec:mesh:capi:meshcreatefromfile"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_MeshCreateFromFile - Create a Mesh from a NetCDF grid file 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Mesh ESMC_MeshCreateFromFile(
                                   const char *filename, // in (required)
                                   int fileTypeFlag,     // in (required)
                                   int *convertToDual,   // in (optional)
                                   int *addUserArea,     // in (optional)
                                   const char *meshname, // in (optional)
                                   int *maskFlag,        // in (optional)
                                   const char *varname,  // in (optional)
                                   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    type(ESMC_Mesh)         :: ESMC_MeshCreateFromFile
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Method to create a Mesh object from a NetCDF file in either SCRIP, UGRID,
   or ESMF file formats.

<P>
The required arguments are:
    <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The name of the grid file
     
</DD>
<DT><STRONG>filetypeflag</STRONG></DT>
<DD>The file type of the grid file to be read, please see Section&nbsp;<A HREF="#const:mesh:cfileformat">20.2.2</A>
           for a list of valid options.
     
</DD>
<DT><STRONG>[convertToDual]</STRONG></DT>
<DD>if 1, the mesh will be converted to its dual. If not specified,
           defaults to 0. Converting to dual is only supported with
           file type <TT>ESMF_FILEFORMAT_SCRIP</TT>.
     
</DD>
<DT><STRONG>[addUserArea]</STRONG></DT>
<DD>if 1, the cell area will be read in from the GRID file.  This feature is
           only supported when the grid file is in the SCRIP or ESMF format. If not specified,
           defaults to 0.
     
</DD>
<DT><STRONG>[meshname]</STRONG></DT>
<DD>The dummy variable for the mesh metadata in the UGRID file if the <TT>filetypeflag</TT>
           is <TT>ESMF_FILEFORMAT_UGRID</TT>.  If not specified, defaults to empty string.
     
</DD>
<DT><STRONG>[maskFlag]</STRONG></DT>
<DD>An enumerated integer that, if specified, tells whether a mask in
           a UGRID file should be defined on the nodes (MeshLoc.NODE) or
           elements (MeshLoc.ELEMENT) of the mesh.  If specified, generate
           the mask using the missing_value attribute defined in 'varname'.
           This flag is only supported when the grid file is in the UGRID
           format.  If not specified, defaults to no mask.
     
</DD>
<DT><STRONG>[varname]</STRONG></DT>
<DD>If maskFlag is specified, provide a variable name stored in the UGRID file and
           the mask will be generated using the missing value of the data value of
           this variable.  The first two dimensions of the variable has to be the
           the longitude and the latitude dimension and the mask is derived from the
           first 2D values of this variable even if this data is 3D, or 4D array. If not
           specified, defaults to empty string.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063700000000000000"></A><A NAME="sec:mesh:capi:meshgetcoord"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMC_MeshGetCoord - Get lat/lon coordinates from a Mesh 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_MeshGetCoord(
                          ESMC_Mesh mesh_in, // in (required)
                          double *nodeCoord, // out
                          int *num_nodes,    // out
                          int *num_dims,     // out
                          int *rc            // out
                          );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    None
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call returns the node coordinates of the given <TT>ESMC_Mesh</TT>
   in the provided <TT>nodeCoord</TT> buffer of doubles.  At completion, this
   buffer is a 1-D array with the coordinates for a given node
   in adjacent indices.  For example, for <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$d$"></SPAN>-dimensional coordinates, the first
   <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$d$"></SPAN> values in the returned array are the coordinates for the first node,
   the second <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$d$"></SPAN> values are the coordinates for the second node, etc.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh_in</STRONG></DT>
<DD>Mesh object.
   
</DD>
<DT><STRONG>nodeCoord</STRONG></DT>
<DD>Pointer to doubles.  The node coordinates are returned here.
   
</DD>
<DT><STRONG>num_nodes</STRONG></DT>
<DD>Pointer to an integer.  The number of nodes found in
   the input Mesh is returned here.
   
</DD>
<DT><STRONG>num_dims</STRONG></DT>
<DD>Pointer to an integer.  The number of coordinate dimensions
   is returned here.
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no
   errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063800000000000000"></A><A NAME="sec:mesh:capi:meshgetelemcoord"></A>
<BR>
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMC_MeshGetElemCoord - Get lat/lon element center coordinates from a Mesh 
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_MeshGetElemCoord(
                          ESMC_Mesh mesh_in, // in (required)
                          double *elemCoord, // out
                          int *num_elems,    // out
                          int *num_dims,     // out
                          int *rc            // out
                          );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    None
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call returns the element coordinates of the given <TT>ESMC_Mesh</TT>
   in the provided <TT>elemCoord</TT> buffer of doubles.  At completion, this
   buffer is a 1-D array with the coordinates for a given element
   in adjacent indices.  For example, for <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$d$"></SPAN>-dimensional coordinates, the first
   <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$d$"></SPAN> values in the returned array are the coordinates for the first element,
   the second <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="15" ALIGN="BOTTOM" BORDER="0"
 SRC="img18.png"
 ALT="$d$"></SPAN> values are the coordinates for the second element, etc.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh_in</STRONG></DT>
<DD>Mesh object.
   
</DD>
<DT><STRONG>elemCoord</STRONG></DT>
<DD>Pointer to doubles.  The element coordinates are returned here.
   
</DD>
<DT><STRONG>num_elems</STRONG></DT>
<DD>Pointer to an integer.  The number of elements found in
   the input Mesh is returned here.
   
</DD>
<DT><STRONG>num_dims</STRONG></DT>
<DD>Pointer to an integer.  The number of coordinate dimensions
   is returned here.
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no
   errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063900000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMC_MeshGetConnectivity - Get Mesh connectivity</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_MeshGetConnectivity(
                          ESMC_Mesh mesh_in,     // in (required)
                          double *connCoord,     // out
                          int *nodesPerElem,  // out
                          int *rc                // out
                          );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    None
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
NOTE: At this time the connectivity that is returned from this call is
          not necessarily in the same format as how it was passed into the
          creation routine.

<P>
This call returns the connectivity of the given <TT>ESMC_Mesh</TT>
   in the provided <TT>connCoord</TT> buffer of doubles.  At completion, this
   buffer is a 1-D array with the coordinates for the nodes of a given element
   in counterclockwise order.  The /tt nodesPerElem buffer of integers
   contains the number of nodes to expect per element.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh_in</STRONG></DT>
<DD>Mesh object.
   
</DD>
<DT><STRONG>connCoord</STRONG></DT>
<DD>Pointer to doubles.  The connectivity is returned here.
   
</DD>
<DT><STRONG>nodesPerElem</STRONG></DT>
<DD>Pointer to integers.  The number of nodes in each
      element.
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no
   errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050631000000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMC_MeshDestroy - Destroy a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_MeshDestroy(
   ESMC_Mesh *mesh             // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy the Mesh. This call removes all internal memory associated with <TT>mesh</TT>. After this call mesh will no longer be usable.

<P>
The arguments are:
    <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object whose memory is to be freed.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050631100000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMC_MeshFreeMemory - Remove a Mesh and its memory</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_MeshFreeMemory(
   ESMC_Mesh mesh            // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This call removes the portions of <TT>mesh</TT> which contain connection and coordinate
      information. After this call, Fields build on <TT>mesh</TT> will no longer be usable
      as part of an <TT>ESMF_FieldRegridStore()</TT> operation. However, after this call
      Fields built on <TT>mesh</TT> can still be used in an <TT>ESMF_FieldRegrid()</TT>
      operation if the routehandle was generated beforehand. New Fields may also
      be built on <TT>mesh</TT> after this call.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object whose memory is to be freed.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050631200000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMC_MeshGetElementCount - Get the number of elements in a Mesh on the current PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_MeshGetElementCount(
   ESMC_Mesh mesh,           // in
   int *elementCount         // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query the number of elements in a mesh on the local PET.
   The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>The mesh
   
</DD>
<DT><STRONG>elementCount</STRONG></DT>
<DD>The number of elements on this PET.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050631300000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMC_MeshGetNodeCount - Get the number of nodes in a Mesh on the current PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_MeshGetNodeCount(
   ESMC_Mesh mesh,          // in
   int *nodeCount           // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query the number of nodes in a mesh on the local PET.
   The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>The mesh
   
</DD>
<DT><STRONG>nodeCount</STRONG></DT>
<DD>The number of nodes on this PET.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050631400000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMC_MeshGetOwnedElementCount - Get the number of elements in a Mesh owned by the current PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_MeshGetOwnedElementCount(
   ESMC_Mesh mesh,           // in
   int *elementCount         // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query the number of elements in a mesh owned by the local PET. This number will be equal or less than the
   local element count.
   The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>The mesh
   
</DD>
<DT><STRONG>elementCount</STRONG></DT>
<DD>The number of elements owned by this PET.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050631500000000000000">
<SPAN CLASS="arabic">20</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMC_MeshGetOwnedNodeCount - Get the number of nodes in a Mesh owned by the current PET</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_MeshGetOwnedNodeCount(
   ESMC_Mesh mesh,          // in
   int *nodeCount           // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Query the number of nodes in a mesh owned by the local PET.  This number will be equal or less than the
   local node count.
   The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>The mesh
   
</DD>
<DT><STRONG>nodeCount</STRONG></DT>
<DD>The number of nodes owned by this PET.
   
</DD>
</DL>

<P>


<H1><A NAME="SECTION05070000000000000000">
<SPAN CLASS="arabic">21</SPAN> XGrid Class</A>
</H1>

<H2><A NAME="SECTION05071000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:xgrid:desc"></A>An exchange grid represents the 2D boundary layer usually between the
atmosphere on one side and ocean and land on the other in an Earth
system model. There are dynamical and thermodynamical processes on
either side of the boundary layer and on the boundary layer itself.
The boundary layer exchanges fluxes from either side and adjusts
boundary conditions for the model components involved. For climate modeling,
it is critical that the fluxes transferred by the boundary layer are
conservative.

<P>
The ESMF exchange grid is implemented as the <TT>ESMC_XGrid</TT> class. 
Internally it's represented by a collection of the intersected cells
between atmosphere and ocean/land[<A
 HREF="node8.html#BalajiXGrid">2</A>] grids. 
These polygonal cells can have irregular shapes
and can be broken down into triangles facilitating a finite element
approach. 

<P>
Through the C API there is one way to create an <TT>ESMC_XGrid</TT> object from
user supplied information. The <TT>ESMC_XGrid</TT> takes
two lists of <TT>ESMC_Grid</TT> or <TT>ESMC_Mesh</TT> that represent the model component grids on
either side of the exchange grid. From the two lists of <TT>ESMC_Grid</TT> or <TT>ESMC_Mesh</TT>,
information required for flux exchange calculation between any pair of the 
model components from either side of the exchange grid is computed. In addition, the
internal representation of the <TT>ESMC_XGrid</TT> is computed and can be optionally stored
as an <TT>ESMC_Mesh</TT>. This internal representation is the collection of the intersected
polygonal cells as a result of merged <TT>ESMC_Mesh</TT>es from both sides of the exchange grid.
<TT>ESMC_Field</TT> can be created on the <TT>ESMC_XGrid</TT> and used for weight generation
and regridding as the internal representation in the <TT>ESMC_XGrid</TT> has
a complete geometrical description of the exchange grid.

<P>
Once an <TT>ESMC_XGrid</TT> has been created, information describing it (e.g. cell areas, mesh representation, etc.)
can be retrieved from the object using a set of get calls (e.g. <TT>ESMC_XGridGetElementArea()</TT>). The full extent of these
can be found in the API section below.  

<H2><A NAME="SECTION05072000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<H3><A NAME="SECTION05072100000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Restrictions and Future Work</A>
</H3>

<P>

<A NAME="XGrid:rest"></A>

<OL>
<LI><B>CAUTION:</B> Any Grid or Mesh pair picked from the A side and B side of the XGrid 
cannot point to the same Grid or Mesh in memory on a local PET. This prevents Regrid from
selecting the right source and destination grid automatically to calculate the regridding routehandle.
It's okay for the Grid and Mesh to have identical topological and geographical properties as long
as they are stored in different memory.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION05073000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">3</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>The XGrid class is implemented in Fortran, and as such is
defined inside the framework by a XGrid derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The XGrid class contains information needed to create Grid, Field, and
communication routehandle.

<P>
</LI>
<LI>XGrid follows the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same XGrids at the same point in their execution. 
In addition to the unison rule, XGrid creation also performs inter-PET
communication within the current executing VM. 
</LI>
</OL>

<H2><A NAME="SECTION05074000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05074100000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_XGridCreate - Create an XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ESMC_XGrid ESMC_XGridCreate(
                               int sideAGridCount,  ESMC_Grid *sideAGrid, // in
                               int sideAMeshCount,  ESMC_Mesh *sideAMesh, // in
                               int sideBGridCount,  ESMC_Grid *sideBGrid, // in
                               int sideBMeshCount,  ESMC_Mesh *sideBMesh, // in
                               ESMC_InterArrayInt *sideAGridPriority,     // in
                               ESMC_InterArrayInt *sideAMeshPriority,     // in
                               ESMC_InterArrayInt *sideBGridPriority,     // in
                               ESMC_InterArrayInt *sideBMeshPriority,     // in
                               ESMC_InterArrayInt *sideAMaskValues,       // in
                               ESMC_InterArrayInt *sideBMaskValues,       // in
                               int storeOverlay,                          // in
                               int *rc                                    // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_XGrid object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMC_XGrid</TT> object from user supplied input: the list of Grids or Meshes on side A and side B, 
    and other optional arguments. A user can supply both Grids and Meshes on one side to create
    the XGrid. By default, the Grids have a higher priority over Meshes but the order of priority 
    can be adjusted by the optional GridPriority and MeshPriority arguments. The priority order
    of Grids and Meshes can also be interleaved by rearranging the optional 
    GridPriority and MeshPriority arguments accordingly.

<P>
Sparse matrix multiplication coefficients are internally computed and
    uniquely determined by the Grids or Meshes provided in <TT>sideA</TT> and <TT>sideB</TT>. User can supply
    a single <TT>ESMC_Grid</TT> or an array of <TT>ESMC_Grid</TT> on either side of the 
    <TT>ESMC_XGrid</TT>. For an array of <TT>ESMC_Grid</TT> or <TT>ESMC_Mesh</TT> in <TT>sideA</TT> or <TT>sideB</TT>,
    a merging process concatenates all the <TT>ESMC_Grid</TT>s and <TT>ESMC_Mesh</TT>es 
    into a super mesh represented
    by <TT>ESMC_Mesh</TT>. The super mesh is then used to compute the XGrid. 
    Grid or Mesh objects in <TT>sideA</TT> and <TT>sideB</TT> arguments must have coordinates defined for
    the corners of a Grid or Mesh cell. XGrid creation can be potentially memory expensive given the
    size of the input Grid and Mesh objects. By default, the super mesh is not stored
    to reduce memory usage. 

<P>
If <TT>sideA</TT> and <TT>sideB</TT> have a single 
    Grid or Mesh object, it's erroneous
    if the two Grids or Meshes are spatially disjoint. 
    It is also erroneous to specify a Grid or Mesh object in <TT>sideA</TT> or <TT>sideB</TT>
    that is spatially disjoint from the <TT>ESMC_XGrid</TT>. 

<P>
This call is <EM>collective</EM> across the current VM. For more details please refer to the description 
    <A HREF="#sec:xgrid:desc">21.1</A> of the XGrid class. 

<P>
The arguments are:
       <DL>
<DT><STRONG>sideAGridCount</STRONG></DT>
<DD>The number of Grids in the <TT>sideAGrid</TT> array.
       
</DD>
<DT><STRONG>[sideAGrid]</STRONG></DT>
<DD>Parametric 2D Grids on side A, for example, 
             these Grids can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>sideAMeshCount</STRONG></DT>
<DD>The number of Meshes in the <TT>sideAMesh</TT> array.
       
</DD>
<DT><STRONG>[sideAMesh]</STRONG></DT>
<DD>Parametric 2D Meshes on side A, for example, 
             these Meshes can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>sideBGridCount</STRONG></DT>
<DD>The number of Grids in the <TT>sideBGrid</TT> array.
       
</DD>
<DT><STRONG>[sideBGrid]</STRONG></DT>
<DD>Parametric 2D Grids on side B, for example, 
             these Grids can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>sideBMeshCount</STRONG></DT>
<DD>The number of Meshes in the <TT>sideBMesh</TT> array.
       
</DD>
<DT><STRONG>[sideBMesh]</STRONG></DT>
<DD>Parametric 2D Meshes on side B, for example, 
             these Meshes can be either Cartesian 2D or Spherical.
       
</DD>
<DT><STRONG>[sideAGridPriority]</STRONG></DT>
<DD>Priority array of Grids on <TT>sideA</TT> during overlay generation.
             The priority arrays describe the priorities of Grids at the overlapping region.
             Flux contributions at the overlapping region are computed in the order from the Grid of the
             highest priority to the lowest priority.
       
</DD>
<DT><STRONG>[sideAMeshPriority]</STRONG></DT>
<DD>Priority array of Meshes on <TT>sideA</TT> during overlay generation.
             The priority arrays describe the priorities of Meshes at the overlapping region.
             Flux contributions at the overlapping region are computed in the order from the Mesh of the
             highest priority to the lowest priority.
       
</DD>
<DT><STRONG>[sideBGridPriority]</STRONG></DT>
<DD>Priority of Grids on <TT>sideB</TT> during overlay generation
             The priority arrays describe the priorities of Grids at the overlapping region.
             Flux contributions at the overlapping region are computed in the order from the Grid of the
             highest priority to the lowest priority.
       
</DD>
<DT><STRONG>[sideBMeshPriority]</STRONG></DT>
<DD>Priority array of Meshes on <TT>sideB</TT> during overlay generation.
             The priority arrays describe the priorities of Meshes at the overlapping region.
             Flux contributions at the overlapping region are computed in the order from the Mesh of the
             highest priority to the lowest priority.
       
</DD>
<DT><STRONG>[sideAMaskValues]</STRONG></DT>
<DD>Mask information can be set in the Grid (see&nbsp;<A HREF="#sec:usage:items">19.1.8</A>) or Mesh
             upon which the Field is built. The <TT>sideAMaskValues</TT> argument specifies the values in that 
             mask information which indicate a point should be masked out. In other words, a location is masked if and only if the
             value for that location in the mask information matches one of the values listed in <TT>sideAMaskValues</TT>.  
             If <TT>sideAMaskValues</TT> is not specified, no masking on side A will occur. 
       
</DD>
<DT><STRONG>[sideBMaskValues]</STRONG></DT>
<DD>Mask information can be set in the Grid (see&nbsp;<A HREF="#sec:usage:items">19.1.8</A>) or Mesh
             upon which the Field is built. The <TT>sideBMaskValues</TT> argument specifies the values in that 
             mask information which indicate a point should be masked out. In other words, a location is masked if and only if the
             value for that location in the mask information matches one of the values listed in <TT>sideBMaskValues</TT>.  
             If <TT>sideBMaskValues</TT> is not specified, no masking on side B will occur. 
       
</DD>
<DT><STRONG>storeOverlay</STRONG></DT>
<DD>Setting the <TT>storeOverlay</TT> optional argument to 0. 
             allows a user to bypass storage of the Mesh used to represent the XGrid.
             Only a DistGrid is stored to allow Field to be built on the XGrid.
             If the temporary mesh object is of interest, <TT>storeOverlay</TT> can be set to a value not equal to 0.
             so a user can retrieve it for future use.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> only if the <TT>ESMF_XGrid</TT> 
             is created.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05074200000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_XGridDestroy - Destroy a XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_XGridDestroy(
   ESMC_XGrid *xgrid     // inout
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Releases all resources associated with this <TT>ESMC_XGrid</TT>.
      Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>Destroy contents of this <TT>ESMC_XGrid</TT>.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05074300000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_XGridGetSideAGridCount - Get the number of Grids on side A.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_XGridGetSideAGridCount(
   ESMC_XGrid xgrid,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The number of Grids on side A.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the number of Grids on side A. 

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05074400000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMC_XGridGetSideAMeshCount - Get the number of Meshes on side A.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_XGridGetSideAMeshCount(
   ESMC_XGrid xgrid,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The number of Meshes on side A.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the number of Meshes on side A. 

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05074500000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMC_XGridGetSideBGridCount - Get the number of Grids on side B.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_XGridGetSideBGridCount(
   ESMC_XGrid xgrid,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The number of Grids on side B.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the number of Grids on side B. 

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05074600000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMC_XGridGetSideBMeshCount - Get the number of Meshes on side B.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_XGridGetSideBMeshCount(
   ESMC_XGrid xgrid,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The number of Meshes on side B.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the number of Meshes on side B. 

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05074700000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMC_XGridGetDimCount - Get the dimension of the XGrid.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_XGridGetDimCount(
   ESMC_XGrid xgrid,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The dimension of the XGrid.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the dimension of the XGrid.

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05074800000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMC_XGridGetElementCount - Get the number of elements in the XGrid.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_XGridGetElementCount(
   ESMC_XGrid xgrid,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>       The number of elements in the XGrid.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the number of elements in the XGrid.

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05074900000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMC_XGridGetMesh - Get the Mesh representation of the XGrid. </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_Mesh ESMC_XGridGetMesh(
   ESMC_XGrid xgrid,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The ESMC_Mesh object representing the XGrid.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the ESMC_Mesh object representing the XGrid. 

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The xgrid from which to get the information. 
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050741000000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMC_XGridGetElementArea - Get the area of elements in the XGrid.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_XGridGetElementArea(
   ESMC_XGrid xgrid,     // in
   ESMC_R8 *area,        // out
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>       The number of elements in the XGrid.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the number of elements in the XGrid.

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>area</STRONG></DT>
<DD>An array to fill with element areas. The array must be allocated
      to size elementCount.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050741100000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMC_XGridGetElementCentroid - Get the centroid of elements in the XGrid.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_XGridGetElementCentroid(
   ESMC_XGrid xgrid,     // in
   ESMC_R8 *centroid,    // out
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>       The number of elements in the XGrid.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the centroid for each element in the exchange grid. 

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>centroid</STRONG></DT>
<DD>An array to fill with element centroids. The array must be allocated
      to size elementCount*dimCount.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050741200000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMC_XGridGetSparseMatA2X - Get the sparse matrix that goes from a side A grid to the exchange grid.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_XGridGetSparseMatA2X(
                                ESMC_XGrid xgrid,      // in
                                int sideAIndex,        // in
                                int *factorListCount,  // out
                                double **factorList,   // out
                                int **factorIndexList, // out
                                int *rc);
</PRE><EM>RETURN VALUE:</EM>
<PRE>       N/A
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the sparse matrix that goes from a side A grid to the exchange grid.

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>sideAIndex</STRONG></DT>
<DD>The 0 based index of the Grid/Mesh on side A to get the sparse matrix for.
      If a priority has been specified for Grids and Meshes, then this index is 
      in priority order. If no priority was specified, then the all the Grids are
      first followed by all the Meshes in the order they were passed into the XGrid 
      create call. 
    
</DD>
<DT><STRONG>factorListCount</STRONG></DT>
<DD>The size of the sparse matrix.
    
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>A pointer to the list of factors for the requested sparse matrix. 
      The list is of size <TT>factorListCount</TT>. To save space
      this is a pointer to the internal xgrid memory for this list. 
      Don't deallocate it. 
    
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>A pointer to the list of indices for the requested sparse matrix. 
      The list is of size 2*<TT>factorListCount</TT>. For each pair of entries
      in this array: entry 0 is the sequence index in the source grid, and entry 1 is
      the sequence index in the destination grid. To save space
      this is a pointer to the internal xgrid memory for this list. 
      Don't deallocate it. 
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050741300000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMC_XGridGetSparseMatA2X - Get the sparse matrix that goes from the exchange grid to a side A grid.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_XGridGetSparseMatX2A(
                                ESMC_XGrid xgrid,      // in
                                int sideAIndex,        // in
                                int *factorListCount,  // out
                                double **factorList,   // out
                                int **factorIndexList, // out
                                int *rc);
</PRE><EM>RETURN VALUE:</EM>
<PRE>       N/A
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the sparse matrix that goes from the exchange grid to a side A grid. 

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>sideAIndex</STRONG></DT>
<DD>The 0 based index of the Grid/Mesh on side A to get the sparse matrix for.
      If a priority has been specified for Grids and Meshes, then this index is 
      in priority order. If no priority was specified, then the all the Grids are
      first followed by all the Meshes in the order they were passed into the XGrid 
      create call. 
    
</DD>
<DT><STRONG>factorListCount</STRONG></DT>
<DD>The size of the sparse matrix.
    
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>A pointer to the list of factors for the requested sparse matrix. 
      The list is of size <TT>factorListCount</TT>. To save space
      this is a pointer to the internal xgrid memory for this list. 
      Don't deallocate it. 
    
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>A pointer to the list of indices for the requested sparse matrix. 
      The list is of size 2*<TT>factorListCount</TT>. For each pair of entries
      in this array: entry 0 is the sequence index in the source grid, and entry 1 is
      the sequence index in the destination grid. To save space 
      this is a pointer to the internal xgrid memory for this list. 
      Don't deallocate it. 
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050741400000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMC_XGridGetSparseMatB2X - Get the sparse matrix that goes from a side B grid to the exchange grid.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_XGridGetSparseMatB2X(
                                ESMC_XGrid xgrid,      // in
                                int sideBIndex,        // in
                                int *factorListCount,  // out
                                double **factorList,   // out
                                int **factorIndexList, // out
                                int *rc);
</PRE><EM>RETURN VALUE:</EM>
<PRE>       N/A
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the sparse matrix that goes from a side B grid to the exchange grid.

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>sideBIndex</STRONG></DT>
<DD>The 0 based index of the Grid/Mesh on side B to get the sparse matrix for.
      If a priority has been specified for Grids and Meshes, then this index is 
      in priority order. If no priority was specified, then the all the Grids are
      first followed by all the Meshes in the order they were passed into the XGrid 
      create call. 
    
</DD>
<DT><STRONG>factorListCount</STRONG></DT>
<DD>The size of the sparse matrix.
    
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>A pointer to the list of factors for the requested sparse matrix. 
      The list is of size <TT>factorListCount</TT>. To save space
      this is a pointer to the internal xgrid memory for this list. 
      Don't deallocate it. 
    
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>A pointer to the list of indices for the requested sparse matrix. 
      The list is of size 2*<TT>factorListCount</TT>. For each pair of entries
      in this array: entry 0 is the sequence index in the source grid, and entry 1 is
      the sequence index in the destination grid. To save space
      this is a pointer to the internal xgrid memory for this list. 
      Don't deallocate it. 
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050741500000000000000">
<SPAN CLASS="arabic">21</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMC_XGridGetSparseMatB2X - Get the sparse matrix that goes from the exchange grid to a side B grid.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> void ESMC_XGridGetSparseMatX2B(
                                ESMC_XGrid xgrid,      // in
                                int sideBIndex,        // in
                                int *factorListCount,  // out
                                double **factorList,   // out
                                int **factorIndexList, // out
                                int *rc);
</PRE><EM>RETURN VALUE:</EM>
<PRE>       N/A
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the sparse matrix that goes from the exchange grid to a side B grid. 

<P>
The arguments are:
    <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The XGrid from which to get the information.
    
</DD>
<DT><STRONG>sideBIndex</STRONG></DT>
<DD>The 0 based index of the Grid/Mesh on side B to get the sparse matrix for.
      If a priority has been specified for Grids and Meshes, then this index is 
      in priority order. If no priority was specified, then the all the Grids are
      first followed by all the Meshes in the order they were passed into the XGrid 
      create call. 
    
</DD>
<DT><STRONG>factorListCount</STRONG></DT>
<DD>The size of the sparse matrix.
    
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>A pointer to the list of factors for the requested sparse matrix. 
      The list is of size <TT>factorListCount</TT>. To save space
      this is a pointer to the internal xgrid memory for this list. 
      Don't deallocate it. 
    
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>A pointer to the list of indices for the requested sparse matrix. 
      The list is of size 2*<TT>factorListCount</TT>. For each pair of entries
      in this array: entry 0 is the sequence index in the source grid, and entry 1 is
      the sequence index in the destination grid. To save space 
      this is a pointer to the internal xgrid memory for this list. 
      Don't deallocate it. 
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>


<H1><A NAME="SECTION05080000000000000000">
<SPAN CLASS="arabic">22</SPAN> DistGrid Class</A>
</H1>

<H2><A NAME="SECTION05081000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:DistGrid"></A>The ESMF DistGrid class sits on top of the DELayout class (not currently
directly accessible through the ESMF C API) and holds domain
information in index space. 
A DistGrid object captures the index space topology
and describes its decomposition in terms of DEs. Combined with DELayout and VM
the DistGrid defines the data distribution of a domain decomposition across the
computational resources of an ESMF Component.

<P>
The global domain is defined as the union of logically
rectangular (LR) sub-domains or <EM>tiles</EM>. The DistGrid create methods allow
the specification of such a multi-tile global domain and its decomposition into
exclusive, DE-local LR regions according to various degrees of user specified
constraints. Complex index space topologies can be constructed by specifying
connection relationships between tiles during creation.

<P>
The DistGrid class holds domain information for all DEs. Each DE is associated
with a local LR region. No overlap of the regions is allowed. The DistGrid
offers query methods that allow DE-local topology information to be extracted,
e.g. for the construction of halos by higher classes.

<P>
A DistGrid object only contains decomposable dimensions. The minimum rank for a
DistGrid object is 1. A maximum rank does not exist for DistGrid objects, 
however, ranks greater than 7 may lead to difficulties with respect to the
Fortran API of higher classes based on DistGrid. The rank of a DELayout object
contained within a DistGrid object must be equal to the DistGrid rank. Higher
class objects that use the DistGrid, such as an Array object, may be of
different rank than the associated DistGrid object. The higher class object
will hold the mapping information between its dimensions and the DistGrid
dimensions.

<H2><A NAME="SECTION05082000000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05082100000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_DistGridCreate - Create a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_DistGrid ESMC_DistGridCreate(
   ESMC_InterArrayInt minIndexInterfaceArg,  // in
   ESMC_InterArrayInt maxIndexInterfaceArg,  // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_DistGrid object.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMC_DistGrid</TT> from a single logically rectangular (LR) 
    tile with default decomposition. The default decomposition is 
    <TT>deCount</TT><!-- MATH
 $\times 1 \times ... \times 1$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="85" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$\times 1 \times ... \times 1$"></SPAN>, where <TT>deCount</TT> is the
    number of DEs in a default DELayout, equal to <TT>petCount</TT>. This means
    that the default decomposition will be into as many DEs as there are PETs,
    with 1 DE per PET.

<P>
The arguments are:
    <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Global coordinate tuple of the lower corner of the tile.
    
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Global coordinate tuple of the upper corner of the tile.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05082200000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_DistGridDestroy - Destroy a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_DistGridDestroy(
   ESMC_DistGrid *distgrid         // inout
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMC_DistGrid</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMC_DistGrid</TT> object to be destroyed.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05082300000000000000">
<SPAN CLASS="arabic">22</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_DistGridPrint - Print a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_DistGridPrint(
   ESMC_DistGrid distgrid          // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMC_DistGrid</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMC_DistGrid</TT> object to be destroyed.
    
</DD>
</DL>

<P>


<H1><A NAME="SECTION05090000000000000000">
<SPAN CLASS="arabic">23</SPAN> RouteHandle Class</A>
</H1>

<H2><A NAME="SECTION05091000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:RHandle"></A>
<P>
The ESMF RouteHandle class provides a unified interface for all route-based communication methods across the Field, FieldBundle, Array, and ArrayBundle classes. All route-based communication methods implement a pre-computation step, returning a RouteHandle, an execution step, and a release step. Typically the pre-computation, or Store() step will be a lot more expensive (both in memory and time) than the execution step. The idea is that once precomputed, a RouteHandle will be executed many times over during a model run, making the execution time a very performance critical piece of code. In ESMF, Regridding, Redisting, and Haloing are implemented as route-based communication methods. The following sections discuss the RouteHandle concepts that apply uniformly to all route-based communication methods, across all of the above mentioned classes.

<P>

<H2><A NAME="SECTION05092000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
The user interacts with the RouteHandle class through the route-based communication methods of Field, FieldBundle, Array, and ArrayBundle. The usage of these methods are described in detail under their respective class documentation section. The following examples focus on the RouteHandle aspects common across classes and methods.

<H2><A NAME="SECTION05093000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Non-blocking</B> communication via the <TT>routesyncflag</TT> option is implemented for Fields and Arrays. It is <EM>not</EM> available for FieldBundles and ArrayBundles. The user is advised to use the VMEpoch approach for all cases to achive asynchronicity.

<P>
</LI>
<LI>The <B>dynamic masking</B> feature currently has the following limitations:

<P>

<UL>
<LI>Only available for <TT>ESMF_TYPEKIND_R8</TT> and <TT>ESMF_TYPEKIND_R4</TT> Fields and Arrays.

<P>
</LI>
<LI>Only available through the <TT>ESMF_FieldRegrid()</TT> and <TT>ESMF_ArraySMM()</TT> methods.

<P>
</LI>
<LI>Destination objects that have undistributed dimensions <EM>after</EM> any distributed dimension are not supported.

<P>
</LI>
<LI>No check is implemented that ensure the user-provided RouteHandle object is suitable for dynamic masking.

<P>
</LI>
</UL>

<P>
</LI>
</UL>

<H2><A NAME="SECTION05094000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">4</SPAN> Design and Implementation Notes</A>
</H2>

<P>
Internally all route-based communication calls are implemented as sparse matrix multiplications. The precompute step for all of the supported communication methods can be broken up into three steps:

<OL>
<LI>Construction of the sparse matrix for the specific communication method.
</LI>
<LI>Generation of the communication pattern according to the sparse matrix.
</LI>
<LI>Encoding of the communication pattern for each participating PET in form of an XXE stream.
</LI>
</OL>

<H2><A NAME="SECTION05095000000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05095100000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMC_RouteHandleCreateFromFile - Create a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> ESMC_RouteHandle ESMC_RouteHandleCreateFromFile(
   char *filename,
   int *rc
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    ESMC_RouteHandle
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMC_RouteHandle</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The file that describes the <TT>ESMC_RouteHandle</TT> object.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05095200000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMC_RouteHandlePrint - Print a RouteHandle</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_RouteHandlePrint(
   ESMC_RouteHandle rh            // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMC_RouteHandle</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>rh</STRONG></DT>
<DD><TT>ESMC_RouteHandle</TT> object to be printed.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05095300000000000000">
<SPAN CLASS="arabic">23</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMC_RouteHandleWrite - Write a RouteHandle to file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> int ESMC_RouteHandleWrite(
   ESMC_RouteHandle rh,          // in
   char *filename                // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write <TT>ESMC_RouteHandle</TT> object to file to save regrid information for
    fast input for regridding operations during runtime.

<P>
The arguments are:
    <DL>
<DT><STRONG>rh</STRONG></DT>
<DD><TT>ESMC_RouteHandle</TT> object to be printed.
    
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>The name of the file for writing the <TT>ESMC_RouteHandle</TT> object.
    
</DD>
</DL>

<P>


<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html628"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html624"
  HREF="ESMC_crefdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html618"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html626"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html629"
  HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html625"
  HREF="ESMC_crefdoc.html">ESMC_crefdoc</A>
<B> Previous:</B> <A NAME="tex2html619"
  HREF="node4.html">3 Superstructure</A>
 &nbsp; <B>  <A NAME="tex2html627"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
