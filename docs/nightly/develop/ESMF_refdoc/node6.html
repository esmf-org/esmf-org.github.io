<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<!--Converted with LaTeX2HTML 2018 (Released Feb 1, 2018) -->
<HTML>
<HEAD>
<TITLE>5 Infrastructure: Utilities</TITLE>
<META NAME="description" CONTENT="5 Infrastructure: Utilities">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2018">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node7.html">
<LINK REL="previous" HREF="node5.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node7.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>

<DIV CLASS="navigation"><!--Navigation Panel-->
<A NAME="tex2html2969"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2965"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2959"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2967"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2970"
  HREF="node7.html">6 References</A>
<B> Up:</B> <A NAME="tex2html2966"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html2960"
  HREF="node5.html">4 Infrastructure: Fields and</A>
 &nbsp; <B>  <A NAME="tex2html2968"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><UL>
<LI><A NAME="tex2html2971"
  HREF="node6.html#SECTION06010000000000000000"><SPAN CLASS="arabic">39</SPAN> Overview of Infrastructure Utility Classes</A>
<LI><A NAME="tex2html2972"
  HREF="node6.html#SECTION06020000000000000000"><SPAN CLASS="arabic">40</SPAN> Info Class (Object Attributes)</A>
<UL>
<LI><A NAME="tex2html2973"
  HREF="node6.html#SECTION06021000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN> Migrating from Attribute</A>
<UL>
<LI><A NAME="tex2html2974"
  HREF="node6.html#SECTION06021100000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Setting an Attribute</A>
<LI><A NAME="tex2html2975"
  HREF="node6.html#SECTION06021200000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Getting an Attribute</A>
</UL>
<LI><A NAME="tex2html2976"
  HREF="node6.html#SECTION06022000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">2</SPAN> Key Format Overview</A>
<LI><A NAME="tex2html2977"
  HREF="node6.html#SECTION06023000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">3</SPAN> Usage and Examples</A>
<UL>
<LI><A NAME="tex2html2978"
  HREF="node6.html#SECTION06023100000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Retrieve an Info Handle</A>
<LI><A NAME="tex2html2979"
  HREF="node6.html#SECTION06023200000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> General Usage Examples</A>
</UL>
<LI><A NAME="tex2html2980"
  HREF="node6.html#SECTION06024000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html2981"
  HREF="node6.html#SECTION06024100000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_InfoAssignment(=)</A>
<LI><A NAME="tex2html2982"
  HREF="node6.html#SECTION06024200000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_InfoOperator(==)</A>
<LI><A NAME="tex2html2983"
  HREF="node6.html#SECTION06024300000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_InfoOperator(/=)</A>
<LI><A NAME="tex2html2984"
  HREF="node6.html#SECTION06024400000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_InfoBroadcast</A>
<LI><A NAME="tex2html2985"
  HREF="node6.html#SECTION06024500000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_InfoCreate</A>
<LI><A NAME="tex2html2986"
  HREF="node6.html#SECTION06024600000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_InfoCreate</A>
<LI><A NAME="tex2html2987"
  HREF="node6.html#SECTION06024700000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_InfoCreate</A>
<LI><A NAME="tex2html2988"
  HREF="node6.html#SECTION06024800000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_InfoCreate</A>
<LI><A NAME="tex2html2989"
  HREF="node6.html#SECTION06024900000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_InfoDestroy</A>
<LI><A NAME="tex2html2990"
  HREF="node6.html#SECTION060241000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_InfoDump</A>
<LI><A NAME="tex2html2991"
  HREF="node6.html#SECTION060241100000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_InfoGet</A>
<LI><A NAME="tex2html2992"
  HREF="node6.html#SECTION060241200000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_InfoGetCharAlloc</A>
<LI><A NAME="tex2html2993"
  HREF="node6.html#SECTION060241300000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_InfoGet</A>
<LI><A NAME="tex2html2994"
  HREF="node6.html#SECTION060241400000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_InfoGetAlloc</A>
<LI><A NAME="tex2html2995"
  HREF="node6.html#SECTION060241500000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_InfoGet</A>
<LI><A NAME="tex2html2996"
  HREF="node6.html#SECTION060241600000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_InfoGetFromHost</A>
<LI><A NAME="tex2html2997"
  HREF="node6.html#SECTION060241700000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_InfoGetTK</A>
<LI><A NAME="tex2html2998"
  HREF="node6.html#SECTION060241800000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_InfoGetArrayMeta</A>
<LI><A NAME="tex2html2999"
  HREF="node6.html#SECTION060241900000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_InfoIsPresent</A>
<LI><A NAME="tex2html3000"
  HREF="node6.html#SECTION060242000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_InfoIsSet</A>
<LI><A NAME="tex2html3001"
  HREF="node6.html#SECTION060242100000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_InfoPrint</A>
<LI><A NAME="tex2html3002"
  HREF="node6.html#SECTION060242200000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_InfoReadJSON</A>
<LI><A NAME="tex2html3003"
  HREF="node6.html#SECTION060242300000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_InfoRemove</A>
<LI><A NAME="tex2html3004"
  HREF="node6.html#SECTION060242400000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_InfoSet</A>
<LI><A NAME="tex2html3005"
  HREF="node6.html#SECTION060242500000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_InfoSet</A>
<LI><A NAME="tex2html3006"
  HREF="node6.html#SECTION060242600000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_InfoSet</A>
<LI><A NAME="tex2html3007"
  HREF="node6.html#SECTION060242700000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_InfoSet</A>
<LI><A NAME="tex2html3008"
  HREF="node6.html#SECTION060242800000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_InfoSetNULL</A>
<LI><A NAME="tex2html3009"
  HREF="node6.html#SECTION060242900000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_InfoSync</A>
<LI><A NAME="tex2html3010"
  HREF="node6.html#SECTION060243000000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_InfoUpdate</A>
<LI><A NAME="tex2html3011"
  HREF="node6.html#SECTION060243100000000000000"><SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_InfoWriteJSON</A>
</UL>
</UL>
<LI><A NAME="tex2html3012"
  HREF="node6.html#SECTION06030000000000000000"><SPAN CLASS="arabic">41</SPAN> Time Manager Utility</A>
<UL>
<LI><A NAME="tex2html3013"
  HREF="node6.html#SECTION06031000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">1</SPAN> Time Manager Classes</A>
<LI><A NAME="tex2html3014"
  HREF="node6.html#SECTION06032000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">2</SPAN> Calendar</A>
<LI><A NAME="tex2html3015"
  HREF="node6.html#SECTION06033000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">3</SPAN> Time Instants and TimeIntervals</A>
<LI><A NAME="tex2html3016"
  HREF="node6.html#SECTION06034000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">4</SPAN> Clocks and Alarms</A>
<LI><A NAME="tex2html3017"
  HREF="node6.html#SECTION06035000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html3018"
  HREF="node6.html#SECTION06036000000000000000"><SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
</UL>
<LI><A NAME="tex2html3019"
  HREF="node6.html#SECTION06040000000000000000"><SPAN CLASS="arabic">42</SPAN> Calendar Class</A>
<UL>
<LI><A NAME="tex2html3020"
  HREF="node6.html#SECTION06041000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3021"
  HREF="node6.html#SECTION06042000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html3022"
  HREF="node6.html#SECTION06042100000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_CALKIND</A>
</UL>
<LI><A NAME="tex2html3023"
  HREF="node6.html#SECTION06043000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3024"
  HREF="node6.html#SECTION06043100000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Calendar creation</A>
<LI><A NAME="tex2html3025"
  HREF="node6.html#SECTION06043200000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Calendar comparison</A>
<LI><A NAME="tex2html3026"
  HREF="node6.html#SECTION06043300000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Time conversion between Calendars</A>
<LI><A NAME="tex2html3027"
  HREF="node6.html#SECTION06043400000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Add a time interval to a time on a Calendar</A>
<LI><A NAME="tex2html3028"
  HREF="node6.html#SECTION06043500000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Calendar destruction</A>
</UL>
<LI><A NAME="tex2html3029"
  HREF="node6.html#SECTION06044000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3030"
  HREF="node6.html#SECTION06045000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3031"
  HREF="node6.html#SECTION06045100000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_CalendarAssignment(=)</A>
<LI><A NAME="tex2html3032"
  HREF="node6.html#SECTION06045200000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_CalendarOperator(==)</A>
<LI><A NAME="tex2html3033"
  HREF="node6.html#SECTION06045300000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_CalendarOperator(/=)</A>
<LI><A NAME="tex2html3034"
  HREF="node6.html#SECTION06045400000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_CalendarCreate</A>
<LI><A NAME="tex2html3035"
  HREF="node6.html#SECTION06045500000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_CalendarCreate</A>
<LI><A NAME="tex2html3036"
  HREF="node6.html#SECTION06045600000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_CalendarCreate</A>
<LI><A NAME="tex2html3037"
  HREF="node6.html#SECTION06045700000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_CalendarDestroy</A>
<LI><A NAME="tex2html3038"
  HREF="node6.html#SECTION06045800000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_CalendarGet</A>
<LI><A NAME="tex2html3039"
  HREF="node6.html#SECTION06045900000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_CalendarIsCreated</A>
<LI><A NAME="tex2html3040"
  HREF="node6.html#SECTION060451000000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_CalendarIsLeapYear</A>
<LI><A NAME="tex2html3041"
  HREF="node6.html#SECTION060451100000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_CalendarPrint</A>
<LI><A NAME="tex2html3042"
  HREF="node6.html#SECTION060451200000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_CalendarSet</A>
<LI><A NAME="tex2html3043"
  HREF="node6.html#SECTION060451300000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_CalendarSet</A>
<LI><A NAME="tex2html3044"
  HREF="node6.html#SECTION060451400000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_CalendarSetDefault</A>
<LI><A NAME="tex2html3045"
  HREF="node6.html#SECTION060451500000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_CalendarSetDefault</A>
<LI><A NAME="tex2html3046"
  HREF="node6.html#SECTION060451600000000000000"><SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_CalendarValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3047"
  HREF="node6.html#SECTION06050000000000000000"><SPAN CLASS="arabic">43</SPAN> Time Class</A>
<UL>
<LI><A NAME="tex2html3048"
  HREF="node6.html#SECTION06051000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3049"
  HREF="node6.html#SECTION06052000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3050"
  HREF="node6.html#SECTION06052100000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Time initialization</A>
<LI><A NAME="tex2html3051"
  HREF="node6.html#SECTION06052200000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Time increment</A>
<LI><A NAME="tex2html3052"
  HREF="node6.html#SECTION06052300000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Time comparison</A>
</UL>
<LI><A NAME="tex2html3053"
  HREF="node6.html#SECTION06053000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3054"
  HREF="node6.html#SECTION06054000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3055"
  HREF="node6.html#SECTION06054100000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_TimeAssignment(=)</A>
<LI><A NAME="tex2html3056"
  HREF="node6.html#SECTION06054200000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_TimeOperator(+)</A>
<LI><A NAME="tex2html3057"
  HREF="node6.html#SECTION06054300000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_TimeOperator(-)</A>
<LI><A NAME="tex2html3058"
  HREF="node6.html#SECTION06054400000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_TimeOperator(-)</A>
<LI><A NAME="tex2html3059"
  HREF="node6.html#SECTION06054500000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_TimeOperator(==)</A>
<LI><A NAME="tex2html3060"
  HREF="node6.html#SECTION06054600000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_TimeOperator(/=)</A>
<LI><A NAME="tex2html3061"
  HREF="node6.html#SECTION06054700000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_TimeOperator(&lt;)</A>
<LI><A NAME="tex2html3062"
  HREF="node6.html#SECTION06054800000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_TimeOperator(&lt;=)</A>
<LI><A NAME="tex2html3063"
  HREF="node6.html#SECTION06054900000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_TimeOperator(&gt;)</A>
<LI><A NAME="tex2html3064"
  HREF="node6.html#SECTION060541000000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_TimeOperator(&gt;=)</A>
<LI><A NAME="tex2html3065"
  HREF="node6.html#SECTION060541100000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_TimeGet</A>
<LI><A NAME="tex2html3066"
  HREF="node6.html#SECTION060541200000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_TimeIsLeapYear</A>
<LI><A NAME="tex2html3067"
  HREF="node6.html#SECTION060541300000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_TimeIsSameCalendar</A>
<LI><A NAME="tex2html3068"
  HREF="node6.html#SECTION060541400000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_TimePrint</A>
<LI><A NAME="tex2html3069"
  HREF="node6.html#SECTION060541500000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_TimeSet</A>
<LI><A NAME="tex2html3070"
  HREF="node6.html#SECTION060541600000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_TimeSet</A>
<LI><A NAME="tex2html3071"
  HREF="node6.html#SECTION060541700000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_TimeSyncToRealTime</A>
<LI><A NAME="tex2html3072"
  HREF="node6.html#SECTION060541800000000000000"><SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_TimeValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3073"
  HREF="node6.html#SECTION06060000000000000000"><SPAN CLASS="arabic">44</SPAN> TimeInterval Class</A>
<UL>
<LI><A NAME="tex2html3074"
  HREF="node6.html#SECTION06061000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3075"
  HREF="node6.html#SECTION06062000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3076"
  HREF="node6.html#SECTION06062100000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> TimeInterval initialization</A>
<LI><A NAME="tex2html3077"
  HREF="node6.html#SECTION06062200000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> TimeInterval conversion</A>
<LI><A NAME="tex2html3078"
  HREF="node6.html#SECTION06062300000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> TimeInterval difference</A>
<LI><A NAME="tex2html3079"
  HREF="node6.html#SECTION06062400000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> TimeInterval multiplication</A>
<LI><A NAME="tex2html3080"
  HREF="node6.html#SECTION06062500000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> TimeInterval comparison</A>
</UL>
<LI><A NAME="tex2html3081"
  HREF="node6.html#SECTION06063000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3082"
  HREF="node6.html#SECTION06064000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3083"
  HREF="node6.html#SECTION06064100000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_TimeIntervalAssignment(=)</A>
<LI><A NAME="tex2html3084"
  HREF="node6.html#SECTION06064200000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_TimeIntervalOperator(+)</A>
<LI><A NAME="tex2html3085"
  HREF="node6.html#SECTION06064300000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_TimeIntervalOperator(-)</A>
<LI><A NAME="tex2html3086"
  HREF="node6.html#SECTION06064400000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_TimeIntervalOperator(-)</A>
<LI><A NAME="tex2html3087"
  HREF="node6.html#SECTION06064500000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_TimeIntervalOperator(/)</A>
<LI><A NAME="tex2html3088"
  HREF="node6.html#SECTION06064600000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_TimeIntervalOperator(/)</A>
<LI><A NAME="tex2html3089"
  HREF="node6.html#SECTION06064700000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_TimeIntervalFunction(MOD)</A>
<LI><A NAME="tex2html3090"
  HREF="node6.html#SECTION06064800000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_TimeIntervalOperator(*)</A>
<LI><A NAME="tex2html3091"
  HREF="node6.html#SECTION06064900000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_TimeIntervalOperator(==)</A>
<LI><A NAME="tex2html3092"
  HREF="node6.html#SECTION060641000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_TimeIntervalOperator(/=)</A>
<LI><A NAME="tex2html3093"
  HREF="node6.html#SECTION060641100000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_TimeIntervalOperator(&lt;)</A>
<LI><A NAME="tex2html3094"
  HREF="node6.html#SECTION060641200000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_TimeIntervalOperator(&lt;=)</A>
<LI><A NAME="tex2html3095"
  HREF="node6.html#SECTION060641300000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_TimeIntervalOperator(&gt;)</A>
<LI><A NAME="tex2html3096"
  HREF="node6.html#SECTION060641400000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_TimeIntervalOperator(&gt;=)</A>
<LI><A NAME="tex2html3097"
  HREF="node6.html#SECTION060641500000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_TimeIntervalAbsValue</A>
<LI><A NAME="tex2html3098"
  HREF="node6.html#SECTION060641600000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html3099"
  HREF="node6.html#SECTION060641700000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html3100"
  HREF="node6.html#SECTION060641800000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html3101"
  HREF="node6.html#SECTION060641900000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html3102"
  HREF="node6.html#SECTION060642000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_TimeIntervalNegAbsValue</A>
<LI><A NAME="tex2html3103"
  HREF="node6.html#SECTION060642100000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_TimeIntervalPrint</A>
<LI><A NAME="tex2html3104"
  HREF="node6.html#SECTION060642200000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html3105"
  HREF="node6.html#SECTION060642300000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html3106"
  HREF="node6.html#SECTION060642400000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html3107"
  HREF="node6.html#SECTION060642500000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html3108"
  HREF="node6.html#SECTION060642600000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html3109"
  HREF="node6.html#SECTION060642700000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html3110"
  HREF="node6.html#SECTION060642800000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html3111"
  HREF="node6.html#SECTION060642900000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html3112"
  HREF="node6.html#SECTION060643000000000000000"><SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_TimeIntervalValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3113"
  HREF="node6.html#SECTION06070000000000000000"><SPAN CLASS="arabic">45</SPAN> Clock Class</A>
<UL>
<LI><A NAME="tex2html3114"
  HREF="node6.html#SECTION06071000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3115"
  HREF="node6.html#SECTION06072000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html3116"
  HREF="node6.html#SECTION06072100000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DIRECTION</A>
</UL>
<LI><A NAME="tex2html3117"
  HREF="node6.html#SECTION06073000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3118"
  HREF="node6.html#SECTION06073100000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Clock creation</A>
<LI><A NAME="tex2html3119"
  HREF="node6.html#SECTION06073200000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Clock advance</A>
<LI><A NAME="tex2html3120"
  HREF="node6.html#SECTION06073300000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Clock examination</A>
<LI><A NAME="tex2html3121"
  HREF="node6.html#SECTION06073400000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Clock reversal</A>
<LI><A NAME="tex2html3122"
  HREF="node6.html#SECTION06073500000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Clock destruction</A>
</UL>
<LI><A NAME="tex2html3123"
  HREF="node6.html#SECTION06074000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3124"
  HREF="node6.html#SECTION06075000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3125"
  HREF="node6.html#SECTION06075100000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ClockAssignment(=)</A>
<LI><A NAME="tex2html3126"
  HREF="node6.html#SECTION06075200000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ClockOperator(==)</A>
<LI><A NAME="tex2html3127"
  HREF="node6.html#SECTION06075300000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ClockOperator(/=)</A>
<LI><A NAME="tex2html3128"
  HREF="node6.html#SECTION06075400000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ClockAdvance</A>
<LI><A NAME="tex2html3129"
  HREF="node6.html#SECTION06075500000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ClockCreate</A>
<LI><A NAME="tex2html3130"
  HREF="node6.html#SECTION06075600000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ClockCreate</A>
<LI><A NAME="tex2html3131"
  HREF="node6.html#SECTION06075700000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ClockDestroy</A>
<LI><A NAME="tex2html3132"
  HREF="node6.html#SECTION06075800000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_ClockGet</A>
<LI><A NAME="tex2html3133"
  HREF="node6.html#SECTION06075900000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_ClockGetAlarm</A>
<LI><A NAME="tex2html3134"
  HREF="node6.html#SECTION060751000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_ClockGetAlarmList</A>
<LI><A NAME="tex2html3135"
  HREF="node6.html#SECTION060751100000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_ClockGetNextTime</A>
<LI><A NAME="tex2html3136"
  HREF="node6.html#SECTION060751200000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_ClockIsCreated</A>
<LI><A NAME="tex2html3137"
  HREF="node6.html#SECTION060751300000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_ClockIsDone</A>
<LI><A NAME="tex2html3138"
  HREF="node6.html#SECTION060751400000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_ClockIsReverse</A>
<LI><A NAME="tex2html3139"
  HREF="node6.html#SECTION060751500000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_ClockIsStopTime</A>
<LI><A NAME="tex2html3140"
  HREF="node6.html#SECTION060751600000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_ClockIsStopTimeEnabled</A>
<LI><A NAME="tex2html3141"
  HREF="node6.html#SECTION060751700000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_ClockPrint</A>
<LI><A NAME="tex2html3142"
  HREF="node6.html#SECTION060751800000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_ClockSet</A>
<LI><A NAME="tex2html3143"
  HREF="node6.html#SECTION060751900000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_ClockStopTimeDisable</A>
<LI><A NAME="tex2html3144"
  HREF="node6.html#SECTION060752000000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_ClockStopTimeEnable</A>
<LI><A NAME="tex2html3145"
  HREF="node6.html#SECTION060752100000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_ClockSyncToRealTime</A>
<LI><A NAME="tex2html3146"
  HREF="node6.html#SECTION060752200000000000000"><SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_ClockValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3147"
  HREF="node6.html#SECTION06080000000000000000"><SPAN CLASS="arabic">46</SPAN> Alarm Class</A>
<UL>
<LI><A NAME="tex2html3148"
  HREF="node6.html#SECTION06081000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3149"
  HREF="node6.html#SECTION06082000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html3150"
  HREF="node6.html#SECTION06082100000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ALARMLIST</A>
</UL>
<LI><A NAME="tex2html3151"
  HREF="node6.html#SECTION06083000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3152"
  HREF="node6.html#SECTION06083100000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Clock initialization</A>
<LI><A NAME="tex2html3153"
  HREF="node6.html#SECTION06083200000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Alarm initialization</A>
<LI><A NAME="tex2html3154"
  HREF="node6.html#SECTION06083300000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Clock advance and Alarm processing</A>
<LI><A NAME="tex2html3155"
  HREF="node6.html#SECTION06083400000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Alarm and Clock destruction</A>
</UL>
<LI><A NAME="tex2html3156"
  HREF="node6.html#SECTION06084000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3157"
  HREF="node6.html#SECTION06085000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html3158"
  HREF="node6.html#SECTION06086000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3159"
  HREF="node6.html#SECTION06086100000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_AlarmAssignment(=)</A>
<LI><A NAME="tex2html3160"
  HREF="node6.html#SECTION06086200000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_AlarmOperator(==)</A>
<LI><A NAME="tex2html3161"
  HREF="node6.html#SECTION06086300000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_AlarmOperator(/=)</A>
<LI><A NAME="tex2html3162"
  HREF="node6.html#SECTION06086400000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_AlarmCreate</A>
<LI><A NAME="tex2html3163"
  HREF="node6.html#SECTION06086500000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_AlarmCreate</A>
<LI><A NAME="tex2html3164"
  HREF="node6.html#SECTION06086600000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_AlarmDestroy</A>
<LI><A NAME="tex2html3165"
  HREF="node6.html#SECTION06086700000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_AlarmDisable</A>
<LI><A NAME="tex2html3166"
  HREF="node6.html#SECTION06086800000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_AlarmEnable</A>
<LI><A NAME="tex2html3167"
  HREF="node6.html#SECTION06086900000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_AlarmGet</A>
<LI><A NAME="tex2html3168"
  HREF="node6.html#SECTION060861000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_AlarmIsCreated</A>
<LI><A NAME="tex2html3169"
  HREF="node6.html#SECTION060861100000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_AlarmIsEnabled</A>
<LI><A NAME="tex2html3170"
  HREF="node6.html#SECTION060861200000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_AlarmIsRinging</A>
<LI><A NAME="tex2html3171"
  HREF="node6.html#SECTION060861300000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_AlarmIsSticky</A>
<LI><A NAME="tex2html3172"
  HREF="node6.html#SECTION060861400000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_AlarmNotSticky</A>
<LI><A NAME="tex2html3173"
  HREF="node6.html#SECTION060861500000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_AlarmPrint</A>
<LI><A NAME="tex2html3174"
  HREF="node6.html#SECTION060861600000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_AlarmRingerOff</A>
<LI><A NAME="tex2html3175"
  HREF="node6.html#SECTION060861700000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_AlarmRingerOn</A>
<LI><A NAME="tex2html3176"
  HREF="node6.html#SECTION060861800000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_AlarmSet</A>
<LI><A NAME="tex2html3177"
  HREF="node6.html#SECTION060861900000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_AlarmSticky</A>
<LI><A NAME="tex2html3178"
  HREF="node6.html#SECTION060862000000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_AlarmValidate</A>
<LI><A NAME="tex2html3179"
  HREF="node6.html#SECTION060862100000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_AlarmWasPrevRinging</A>
<LI><A NAME="tex2html3180"
  HREF="node6.html#SECTION060862200000000000000"><SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_AlarmWillRingNext</A>
</UL>
</UL>
<LI><A NAME="tex2html3181"
  HREF="node6.html#SECTION06090000000000000000"><SPAN CLASS="arabic">47</SPAN> Config Class</A>
<UL>
<LI><A NAME="tex2html3182"
  HREF="node6.html#SECTION06091000000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A NAME="tex2html3183"
  HREF="node6.html#SECTION06091100000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Package history</A>
<LI><A NAME="tex2html3184"
  HREF="node6.html#SECTION06091200000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Resource files</A>
</UL>
<LI><A NAME="tex2html3185"
  HREF="node6.html#SECTION06092000000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3186"
  HREF="node6.html#SECTION06092100000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Variable declarations</A>
<LI><A NAME="tex2html3187"
  HREF="node6.html#SECTION06092200000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Creation of a Config</A>
<LI><A NAME="tex2html3188"
  HREF="node6.html#SECTION06092300000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> How to retrieve a label with a single value</A>
<LI><A NAME="tex2html3189"
  HREF="node6.html#SECTION06092400000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> How to retrieve a label with multiple values</A>
<LI><A NAME="tex2html3190"
  HREF="node6.html#SECTION06092500000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> How to retrieve a table</A>
<LI><A NAME="tex2html3191"
  HREF="node6.html#SECTION06092600000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Destruction of a Config</A>
<LI><A NAME="tex2html3192"
  HREF="node6.html#SECTION06092700000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Loading a YAML file</A>
<LI><A NAME="tex2html3193"
  HREF="node6.html#SECTION06092800000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Creating from HConfig object</A>
</UL>
<LI><A NAME="tex2html3194"
  HREF="node6.html#SECTION06093000000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3195"
  HREF="node6.html#SECTION06093100000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ConfigAssignment(=)</A>
<LI><A NAME="tex2html3196"
  HREF="node6.html#SECTION06093200000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ConfigOperator(==)</A>
<LI><A NAME="tex2html3197"
  HREF="node6.html#SECTION06093300000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ConfigOperator(/=)</A>
<LI><A NAME="tex2html3198"
  HREF="node6.html#SECTION06093400000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ConfigCreate</A>
<LI><A NAME="tex2html3199"
  HREF="node6.html#SECTION06093500000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ConfigCreate</A>
<LI><A NAME="tex2html3200"
  HREF="node6.html#SECTION06093600000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ConfigDestroy</A>
<LI><A NAME="tex2html3201"
  HREF="node6.html#SECTION06093700000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ConfigFindLabel</A>
<LI><A NAME="tex2html3202"
  HREF="node6.html#SECTION06093800000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_ConfigFindNextLabel</A>
<LI><A NAME="tex2html3203"
  HREF="node6.html#SECTION06093900000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_ConfigGet</A>
<LI><A NAME="tex2html3204"
  HREF="node6.html#SECTION060931000000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_ConfigGetAttribute</A>
<LI><A NAME="tex2html3205"
  HREF="node6.html#SECTION060931100000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_ConfigGetAttribute</A>
<LI><A NAME="tex2html3206"
  HREF="node6.html#SECTION060931200000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_ConfigGetChar</A>
<LI><A NAME="tex2html3207"
  HREF="node6.html#SECTION060931300000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_ConfigGetDim</A>
<LI><A NAME="tex2html3208"
  HREF="node6.html#SECTION060931400000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_ConfigGetLen</A>
<LI><A NAME="tex2html3209"
  HREF="node6.html#SECTION060931500000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_ConfigIsCreated</A>
<LI><A NAME="tex2html3210"
  HREF="node6.html#SECTION060931600000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_ConfigLoadFile</A>
<LI><A NAME="tex2html3211"
  HREF="node6.html#SECTION060931700000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_ConfigLog</A>
<LI><A NAME="tex2html3212"
  HREF="node6.html#SECTION060931800000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_ConfigNextLine</A>
<LI><A NAME="tex2html3213"
  HREF="node6.html#SECTION060931900000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_ConfigPrint</A>
<LI><A NAME="tex2html3214"
  HREF="node6.html#SECTION060932000000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_ConfigSetAttribute</A>
<LI><A NAME="tex2html3215"
  HREF="node6.html#SECTION060932100000000000000"><SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_ConfigValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3216"
  HREF="node6.html#SECTION060100000000000000000"><SPAN CLASS="arabic">48</SPAN> HConfig Class</A>
<UL>
<LI><A NAME="tex2html3217"
  HREF="node6.html#SECTION060101000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3218"
  HREF="node6.html#SECTION060102000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html3219"
  HREF="node6.html#SECTION060102100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_HCONFIGMATCH</A>
</UL>
<LI><A NAME="tex2html3220"
  HREF="node6.html#SECTION060103000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3221"
  HREF="node6.html#SECTION060103100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Create an empty HConfig object</A>
<LI><A NAME="tex2html3222"
  HREF="node6.html#SECTION060103200000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Set HConfig from string using YAML syntax</A>
<LI><A NAME="tex2html3223"
  HREF="node6.html#SECTION060103300000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Iterator based HConfig sequence parsing</A>
<LI><A NAME="tex2html3224"
  HREF="node6.html#SECTION060103400000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Index based random access HConfig sequence parsing</A>
<LI><A NAME="tex2html3225"
  HREF="node6.html#SECTION060103500000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Destroy a HConfig object</A>
<LI><A NAME="tex2html3226"
  HREF="node6.html#SECTION060103600000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create a HConfig object directly loading from YAML string</A>
<LI><A NAME="tex2html3227"
  HREF="node6.html#SECTION060103700000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Iterator based HConfig map parsing</A>
<LI><A NAME="tex2html3228"
  HREF="node6.html#SECTION060103800000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Key based random access HConfig map parsing</A>
<LI><A NAME="tex2html3229"
  HREF="node6.html#SECTION060103900000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Access HConfig from Config</A>
<LI><A NAME="tex2html3230"
  HREF="node6.html#SECTION0601031000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Load HConfig from YAML file</A>
<LI><A NAME="tex2html3231"
  HREF="node6.html#SECTION0601031100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Save HConfig to YAML file</A>
<LI><A NAME="tex2html3232"
  HREF="node6.html#SECTION0601031200000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Tags and Schemas</A>
<LI><A NAME="tex2html3233"
  HREF="node6.html#SECTION0601031300000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> Comparing HConfig objects</A>
<LI><A NAME="tex2html3234"
  HREF="node6.html#SECTION0601031400000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> Adding, Setting, and Removing elements from HConfig object</A>
<LI><A NAME="tex2html3235"
  HREF="node6.html#SECTION0601031500000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> Working with multiple YAML documents</A>
<LI><A NAME="tex2html3236"
  HREF="node6.html#SECTION0601031600000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">16</SPAN> Sequence shortcuts for: Create, As, Add, and Set</A>
</UL>
<LI><A NAME="tex2html3237"
  HREF="node6.html#SECTION060104000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3238"
  HREF="node6.html#SECTION060105000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html3239"
  HREF="node6.html#SECTION060106000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3240"
  HREF="node6.html#SECTION060106100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_HConfigAssignment(=)</A>
<LI><A NAME="tex2html3241"
  HREF="node6.html#SECTION060106200000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_HConfigOperator(==)</A>
<LI><A NAME="tex2html3242"
  HREF="node6.html#SECTION060106300000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_HConfigOperator(/=)</A>
<LI><A NAME="tex2html3243"
  HREF="node6.html#SECTION060106400000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_HConfigAdd</A>
<LI><A NAME="tex2html3244"
  HREF="node6.html#SECTION060106500000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_HConfigAddMapKey</A>
<LI><A NAME="tex2html3245"
  HREF="node6.html#SECTION060106600000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_HConfigAddMapVal</A>
<LI><A NAME="tex2html3246"
  HREF="node6.html#SECTION060106700000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;</A>
<LI><A NAME="tex2html3247"
  HREF="node6.html#SECTION060106800000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;MapKey</A>
<LI><A NAME="tex2html3248"
  HREF="node6.html#SECTION060106900000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;MapVal</A>
<LI><A NAME="tex2html3249"
  HREF="node6.html#SECTION0601061000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;Seq</A>
<LI><A NAME="tex2html3250"
  HREF="node6.html#SECTION0601061100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;SeqMapKey</A>
<LI><A NAME="tex2html3251"
  HREF="node6.html#SECTION0601061200000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;SeqMapVal</A>
<LI><A NAME="tex2html3252"
  HREF="node6.html#SECTION0601061300000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_HConfigCreate</A>
<LI><A NAME="tex2html3253"
  HREF="node6.html#SECTION0601061400000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_HConfigCreate</A>
<LI><A NAME="tex2html3254"
  HREF="node6.html#SECTION0601061500000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_HConfigCreate</A>
<LI><A NAME="tex2html3255"
  HREF="node6.html#SECTION0601061600000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_HConfigCreate</A>
<LI><A NAME="tex2html3256"
  HREF="node6.html#SECTION0601061700000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_HConfigCreateAt</A>
<LI><A NAME="tex2html3257"
  HREF="node6.html#SECTION0601061800000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_HConfigCreateAtMapKey</A>
<LI><A NAME="tex2html3258"
  HREF="node6.html#SECTION0601061900000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_HConfigCreateAtMapVal</A>
<LI><A NAME="tex2html3259"
  HREF="node6.html#SECTION0601062000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_HConfigDestroy</A>
<LI><A NAME="tex2html3260"
  HREF="node6.html#SECTION0601062100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_HConfigFileLoad</A>
<LI><A NAME="tex2html3261"
  HREF="node6.html#SECTION0601062200000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_HConfigFileSave</A>
<LI><A NAME="tex2html3262"
  HREF="node6.html#SECTION0601062300000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_HConfigGetDocCount</A>
<LI><A NAME="tex2html3263"
  HREF="node6.html#SECTION0601062400000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_HConfigGetSize</A>
<LI><A NAME="tex2html3264"
  HREF="node6.html#SECTION0601062500000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_HConfigGetSizeMapKey</A>
<LI><A NAME="tex2html3265"
  HREF="node6.html#SECTION0601062600000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_HConfigGetSizeMapVal</A>
<LI><A NAME="tex2html3266"
  HREF="node6.html#SECTION0601062700000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_HConfigGetTag</A>
<LI><A NAME="tex2html3267"
  HREF="node6.html#SECTION0601062800000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_HConfigGetTagMapKey</A>
<LI><A NAME="tex2html3268"
  HREF="node6.html#SECTION0601062900000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_HConfigGetTagMapVal</A>
<LI><A NAME="tex2html3269"
  HREF="node6.html#SECTION0601063000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_HConfigIs&lt;NodeType&gt;</A>
<LI><A NAME="tex2html3270"
  HREF="node6.html#SECTION0601063100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_HConfigIs&lt;NodeType&gt;MapKey</A>
<LI><A NAME="tex2html3271"
  HREF="node6.html#SECTION0601063200000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_HConfigIs&lt;NodeType&gt;MapVal</A>
<LI><A NAME="tex2html3272"
  HREF="node6.html#SECTION0601063300000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_HConfigIterBegin</A>
<LI><A NAME="tex2html3273"
  HREF="node6.html#SECTION0601063400000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_HConfigIterBeginMapKey</A>
<LI><A NAME="tex2html3274"
  HREF="node6.html#SECTION0601063500000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_HConfigIterBeginMapVal</A>
<LI><A NAME="tex2html3275"
  HREF="node6.html#SECTION0601063600000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_HConfigIterEnd</A>
<LI><A NAME="tex2html3276"
  HREF="node6.html#SECTION0601063700000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_HConfigIterEndMapKey</A>
<LI><A NAME="tex2html3277"
  HREF="node6.html#SECTION0601063800000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_HConfigIterEndMapVal</A>
<LI><A NAME="tex2html3278"
  HREF="node6.html#SECTION0601063900000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_HConfigIterIsMap</A>
<LI><A NAME="tex2html3279"
  HREF="node6.html#SECTION0601064000000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> ESMF_HConfigIterIsSequence</A>
<LI><A NAME="tex2html3280"
  HREF="node6.html#SECTION0601064100000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> ESMF_HConfigIterLoop</A>
<LI><A NAME="tex2html3281"
  HREF="node6.html#SECTION0601064200000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> ESMF_HConfigIterNext</A>
<LI><A NAME="tex2html3282"
  HREF="node6.html#SECTION0601064300000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">43</SPAN> ESMF_HConfigLog</A>
<LI><A NAME="tex2html3283"
  HREF="node6.html#SECTION0601064400000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">44</SPAN> ESMF_HConfigMatch</A>
<LI><A NAME="tex2html3284"
  HREF="node6.html#SECTION0601064500000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">45</SPAN> ESMF_HConfigRemove</A>
<LI><A NAME="tex2html3285"
  HREF="node6.html#SECTION0601064600000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">46</SPAN> ESMF_HConfigSet</A>
<LI><A NAME="tex2html3286"
  HREF="node6.html#SECTION0601064700000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">47</SPAN> ESMF_HConfigSetMapKey</A>
<LI><A NAME="tex2html3287"
  HREF="node6.html#SECTION0601064800000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">48</SPAN> ESMF_HConfigSetMapVal</A>
<LI><A NAME="tex2html3288"
  HREF="node6.html#SECTION0601064900000000000000"><SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">49</SPAN> ESMF_HConfigValidateMapKeys</A>
</UL>
</UL>
<LI><A NAME="tex2html3289"
  HREF="node6.html#SECTION060110000000000000000"><SPAN CLASS="arabic">49</SPAN> Log Class</A>
<UL>
<LI><A NAME="tex2html3290"
  HREF="node6.html#SECTION060111000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3291"
  HREF="node6.html#SECTION060112000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html3292"
  HREF="node6.html#SECTION060112100000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LOGERR</A>
<LI><A NAME="tex2html3293"
  HREF="node6.html#SECTION060112200000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LOGKIND</A>
<LI><A NAME="tex2html3294"
  HREF="node6.html#SECTION060112300000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LOGMSG</A>
</UL>
<LI><A NAME="tex2html3295"
  HREF="node6.html#SECTION060113000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3296"
  HREF="node6.html#SECTION060113100000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Default Log</A>
<LI><A NAME="tex2html3297"
  HREF="node6.html#SECTION060113200000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> User created Log</A>
<LI><A NAME="tex2html3298"
  HREF="node6.html#SECTION060113300000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Get and Set</A>
</UL>
<LI><A NAME="tex2html3299"
  HREF="node6.html#SECTION060114000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3300"
  HREF="node6.html#SECTION060115000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html3301"
  HREF="node6.html#SECTION060116000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
<LI><A NAME="tex2html3302"
  HREF="node6.html#SECTION060117000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3303"
  HREF="node6.html#SECTION060117100000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LogAssignment(=)</A>
<LI><A NAME="tex2html3304"
  HREF="node6.html#SECTION060117200000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LogOperator(==)</A>
<LI><A NAME="tex2html3305"
  HREF="node6.html#SECTION060117300000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LogOperator(/=)</A>
<LI><A NAME="tex2html3306"
  HREF="node6.html#SECTION060117400000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_LogClose</A>
<LI><A NAME="tex2html3307"
  HREF="node6.html#SECTION060117500000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_LogFlush</A>
<LI><A NAME="tex2html3308"
  HREF="node6.html#SECTION060117600000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_LogFoundAllocError</A>
<LI><A NAME="tex2html3309"
  HREF="node6.html#SECTION060117700000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_LogFoundDeallocError</A>
<LI><A NAME="tex2html3310"
  HREF="node6.html#SECTION060117800000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_LogFoundError</A>
<LI><A NAME="tex2html3311"
  HREF="node6.html#SECTION060117900000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_LogFoundNetCDFError</A>
<LI><A NAME="tex2html3312"
  HREF="node6.html#SECTION0601171000000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_LogGet</A>
<LI><A NAME="tex2html3313"
  HREF="node6.html#SECTION0601171100000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_LogOpen</A>
<LI><A NAME="tex2html3314"
  HREF="node6.html#SECTION0601171200000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_LogOpen</A>
<LI><A NAME="tex2html3315"
  HREF="node6.html#SECTION0601171300000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_LogSet</A>
<LI><A NAME="tex2html3316"
  HREF="node6.html#SECTION0601171400000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_LogSetError</A>
<LI><A NAME="tex2html3317"
  HREF="node6.html#SECTION0601171500000000000000"><SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_LogWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html3318"
  HREF="node6.html#SECTION060120000000000000000"><SPAN CLASS="arabic">50</SPAN> DELayout Class</A>
<UL>
<LI><A NAME="tex2html3319"
  HREF="node6.html#SECTION060121000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3320"
  HREF="node6.html#SECTION060122000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html3321"
  HREF="node6.html#SECTION060122100000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_PIN</A>
<LI><A NAME="tex2html3322"
  HREF="node6.html#SECTION060122200000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_SERVICEREPLY</A>
</UL>
<LI><A NAME="tex2html3323"
  HREF="node6.html#SECTION060123000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3324"
  HREF="node6.html#SECTION060123100000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Default DELayout</A>
<LI><A NAME="tex2html3325"
  HREF="node6.html#SECTION060123200000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> DELayout with specified number of DEs</A>
<LI><A NAME="tex2html3326"
  HREF="node6.html#SECTION060123300000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> DELayout with computational and communication weights</A>
<LI><A NAME="tex2html3327"
  HREF="node6.html#SECTION060123400000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> DELayout from petMap</A>
<LI><A NAME="tex2html3328"
  HREF="node6.html#SECTION060123500000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> DELayout from petMap with multiple DEs per PET</A>
<LI><A NAME="tex2html3329"
  HREF="node6.html#SECTION060123600000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Working with a DELayout - simple 1-to-1 DE-to-PET mapping</A>
<LI><A NAME="tex2html3330"
  HREF="node6.html#SECTION060123700000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Working with a DELayout - general DE-to-PET mapping</A>
<LI><A NAME="tex2html3331"
  HREF="node6.html#SECTION060123800000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Work queue dynamic load balancing</A>
</UL>
<LI><A NAME="tex2html3332"
  HREF="node6.html#SECTION060124000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3333"
  HREF="node6.html#SECTION060125000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html3334"
  HREF="node6.html#SECTION060126000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3335"
  HREF="node6.html#SECTION060126100000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DELayoutAssignment(=)</A>
<LI><A NAME="tex2html3336"
  HREF="node6.html#SECTION060126200000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_DELayoutOperator(==)</A>
<LI><A NAME="tex2html3337"
  HREF="node6.html#SECTION060126300000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_DELayoutOperator(/=)</A>
<LI><A NAME="tex2html3338"
  HREF="node6.html#SECTION060126400000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_DELayoutCreate</A>
<LI><A NAME="tex2html3339"
  HREF="node6.html#SECTION060126500000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_DELayoutCreate</A>
<LI><A NAME="tex2html3340"
  HREF="node6.html#SECTION060126600000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_DELayoutDestroy</A>
<LI><A NAME="tex2html3341"
  HREF="node6.html#SECTION060126700000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_DELayoutGet</A>
<LI><A NAME="tex2html3342"
  HREF="node6.html#SECTION060126800000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_DELayoutIsCreated</A>
<LI><A NAME="tex2html3343"
  HREF="node6.html#SECTION060126900000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_DELayoutPrint</A>
<LI><A NAME="tex2html3344"
  HREF="node6.html#SECTION0601261000000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_DELayoutServiceComplete</A>
<LI><A NAME="tex2html3345"
  HREF="node6.html#SECTION0601261100000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_DELayoutServiceOffer</A>
<LI><A NAME="tex2html3346"
  HREF="node6.html#SECTION0601261200000000000000"><SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_DELayoutValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html3347"
  HREF="node6.html#SECTION060130000000000000000"><SPAN CLASS="arabic">51</SPAN> VM Class</A>
<UL>
<LI><A NAME="tex2html3348"
  HREF="node6.html#SECTION060131000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3349"
  HREF="node6.html#SECTION060132000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
<UL>
<LI><A NAME="tex2html3350"
  HREF="node6.html#SECTION060132100000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_VMEPOCH</A>
</UL>
<LI><A NAME="tex2html3351"
  HREF="node6.html#SECTION060133000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3352"
  HREF="node6.html#SECTION060133100000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Global VM</A>
<LI><A NAME="tex2html3353"
  HREF="node6.html#SECTION060133200000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> VM and Components</A>
<LI><A NAME="tex2html3354"
  HREF="node6.html#SECTION060133300000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Accessing the MPI Communicator from an VM object</A>
<LI><A NAME="tex2html3355"
  HREF="node6.html#SECTION060133400000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Using the MPI Communicator with the Fortran 2008 MPI binding</A>
<LI><A NAME="tex2html3356"
  HREF="node6.html#SECTION060133500000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Nesting ESMF inside a user MPI application</A>
<LI><A NAME="tex2html3357"
  HREF="node6.html#SECTION060133600000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Nesting ESMF inside a user MPI application on a subset of MPI ranks</A>
<LI><A NAME="tex2html3358"
  HREF="node6.html#SECTION060133700000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Multiple concurrent instances of ESMF under separate MPI communicators</A>
<LI><A NAME="tex2html3359"
  HREF="node6.html#SECTION060133800000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Communication - Send and Recv</A>
<LI><A NAME="tex2html3360"
  HREF="node6.html#SECTION060133900000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Communication - Scatter and Gather</A>
<LI><A NAME="tex2html3361"
  HREF="node6.html#SECTION0601331000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Communication - AllReduce and AllFullReduce</A>
<LI><A NAME="tex2html3362"
  HREF="node6.html#SECTION0601331100000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Communication - Non-blocking option and VMEpochs</A>
<LI><A NAME="tex2html3363"
  HREF="node6.html#SECTION0601331200000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Using VM communication methods with data of rank greater than one</A>
</UL>
<LI><A NAME="tex2html3364"
  HREF="node6.html#SECTION060134000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3365"
  HREF="node6.html#SECTION060135000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
<LI><A NAME="tex2html3366"
  HREF="node6.html#SECTION060136000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3367"
  HREF="node6.html#SECTION060136100000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_VMAssignment(=)</A>
<LI><A NAME="tex2html3368"
  HREF="node6.html#SECTION060136200000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_VMOperator(==)</A>
<LI><A NAME="tex2html3369"
  HREF="node6.html#SECTION060136300000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_VMOperator(/=)</A>
<LI><A NAME="tex2html3370"
  HREF="node6.html#SECTION060136400000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_VMAllFullReduce</A>
<LI><A NAME="tex2html3371"
  HREF="node6.html#SECTION060136500000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_VMAllGather</A>
<LI><A NAME="tex2html3372"
  HREF="node6.html#SECTION060136600000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_VMAllGatherV</A>
<LI><A NAME="tex2html3373"
  HREF="node6.html#SECTION060136700000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_VMAllReduce</A>
<LI><A NAME="tex2html3374"
  HREF="node6.html#SECTION060136800000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_VMAllToAll</A>
<LI><A NAME="tex2html3375"
  HREF="node6.html#SECTION060136900000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_VMAllToAllV</A>
<LI><A NAME="tex2html3376"
  HREF="node6.html#SECTION0601361000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_VMBarrier</A>
<LI><A NAME="tex2html3377"
  HREF="node6.html#SECTION0601361100000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_VMBroadcast</A>
<LI><A NAME="tex2html3378"
  HREF="node6.html#SECTION0601361200000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_VMCommWait</A>
<LI><A NAME="tex2html3379"
  HREF="node6.html#SECTION0601361300000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_VMCommWaitAll</A>
<LI><A NAME="tex2html3380"
  HREF="node6.html#SECTION0601361400000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_VMEpochEnter</A>
<LI><A NAME="tex2html3381"
  HREF="node6.html#SECTION0601361500000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_VMEpochExit</A>
<LI><A NAME="tex2html3382"
  HREF="node6.html#SECTION0601361600000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_VMGather</A>
<LI><A NAME="tex2html3383"
  HREF="node6.html#SECTION0601361700000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_VMGatherV</A>
<LI><A NAME="tex2html3384"
  HREF="node6.html#SECTION0601361800000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_VMGet</A>
<LI><A NAME="tex2html3385"
  HREF="node6.html#SECTION0601361900000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_VMGet</A>
<LI><A NAME="tex2html3386"
  HREF="node6.html#SECTION0601362000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_VMGetGlobal</A>
<LI><A NAME="tex2html3387"
  HREF="node6.html#SECTION0601362100000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_VMGetCurrent</A>
<LI><A NAME="tex2html3388"
  HREF="node6.html#SECTION0601362200000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_VMIsCreated</A>
<LI><A NAME="tex2html3389"
  HREF="node6.html#SECTION0601362300000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_VMLog</A>
<LI><A NAME="tex2html3390"
  HREF="node6.html#SECTION0601362400000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_VMLogSystem</A>
<LI><A NAME="tex2html3391"
  HREF="node6.html#SECTION0601362500000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_VMPrint</A>
<LI><A NAME="tex2html3392"
  HREF="node6.html#SECTION0601362600000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_VMRecv</A>
<LI><A NAME="tex2html3393"
  HREF="node6.html#SECTION0601362700000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_VMReduce</A>
<LI><A NAME="tex2html3394"
  HREF="node6.html#SECTION0601362800000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_VMScatter</A>
<LI><A NAME="tex2html3395"
  HREF="node6.html#SECTION0601362900000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_VMScatterV</A>
<LI><A NAME="tex2html3396"
  HREF="node6.html#SECTION0601363000000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_VMSend</A>
<LI><A NAME="tex2html3397"
  HREF="node6.html#SECTION0601363100000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_VMSendRecv</A>
<LI><A NAME="tex2html3398"
  HREF="node6.html#SECTION0601363200000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_VMValidate</A>
<LI><A NAME="tex2html3399"
  HREF="node6.html#SECTION0601363300000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_VMWtime</A>
<LI><A NAME="tex2html3400"
  HREF="node6.html#SECTION0601363400000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_VMWtimeDelay</A>
<LI><A NAME="tex2html3401"
  HREF="node6.html#SECTION0601363500000000000000"><SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_VMWtimePrec</A>
</UL>
</UL>
<LI><A NAME="tex2html3402"
  HREF="node6.html#SECTION060140000000000000000"><SPAN CLASS="arabic">52</SPAN> Profiling and Tracing</A>
<UL>
<LI><A NAME="tex2html3403"
  HREF="node6.html#SECTION060141000000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<UL>
<LI><A NAME="tex2html3404"
  HREF="node6.html#SECTION060141100000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Profiling</A>
<LI><A NAME="tex2html3405"
  HREF="node6.html#SECTION060141200000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Tracing</A>
</UL>
<LI><A NAME="tex2html3406"
  HREF="node6.html#SECTION060142000000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3407"
  HREF="node6.html#SECTION060142100000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Output a Timing Profile to Text</A>
<LI><A NAME="tex2html3408"
  HREF="node6.html#SECTION060142200000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Summarize Timings across Multiple PETs</A>
<LI><A NAME="tex2html3409"
  HREF="node6.html#SECTION060142300000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Limit the Set of Profiled PETs</A>
<LI><A NAME="tex2html3410"
  HREF="node6.html#SECTION060142400000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Include MPI Communication in the Profile</A>
<LI><A NAME="tex2html3411"
  HREF="node6.html#SECTION060142500000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Output a Detailed Trace for Analysis</A>
<LI><A NAME="tex2html3412"
  HREF="node6.html#SECTION060142600000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Set the Clock used for Profiling/Tracing</A>
<LI><A NAME="tex2html3413"
  HREF="node6.html#SECTION060142700000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Tracing a simple ESMF application</A>
<LI><A NAME="tex2html3414"
  HREF="node6.html#SECTION060142800000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Profiling/Tracing User-defined Code Regions</A>
</UL>
<LI><A NAME="tex2html3415"
  HREF="node6.html#SECTION060143000000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
<LI><A NAME="tex2html3416"
  HREF="node6.html#SECTION060144000000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
<UL>
<LI><A NAME="tex2html3417"
  HREF="node6.html#SECTION060144100000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_TraceRegionEnter</A>
<LI><A NAME="tex2html3418"
  HREF="node6.html#SECTION060144200000000000000"><SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_TraceRegionExit</A>
</UL>
</UL>
<LI><A NAME="tex2html3419"
  HREF="node6.html#SECTION060150000000000000000"><SPAN CLASS="arabic">53</SPAN> Fortran I/O and System Utilities</A>
<UL>
<LI><A NAME="tex2html3420"
  HREF="node6.html#SECTION060151000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
<LI><A NAME="tex2html3421"
  HREF="node6.html#SECTION060152000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
<UL>
<LI><A NAME="tex2html3422"
  HREF="node6.html#SECTION060152100000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Fortran unit number management</A>
<LI><A NAME="tex2html3423"
  HREF="node6.html#SECTION060152200000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Flushing output</A>
</UL>
<LI><A NAME="tex2html3424"
  HREF="node6.html#SECTION060153000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN> Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html3425"
  HREF="node6.html#SECTION060153100000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Fortran unit number management</A>
<LI><A NAME="tex2html3426"
  HREF="node6.html#SECTION060153200000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Flushing output</A>
<LI><A NAME="tex2html3427"
  HREF="node6.html#SECTION060153300000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sorting algorithms</A>
</UL>
<LI><A NAME="tex2html3428"
  HREF="node6.html#SECTION060154000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN> Utility API</A>
<UL>
<LI><A NAME="tex2html3429"
  HREF="node6.html#SECTION060154100000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_UtilGetArg</A>
<LI><A NAME="tex2html3430"
  HREF="node6.html#SECTION060154200000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_UtilGetArgC</A>
<LI><A NAME="tex2html3431"
  HREF="node6.html#SECTION060154300000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_UtilGetArgIndex</A>
<LI><A NAME="tex2html3432"
  HREF="node6.html#SECTION060154400000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_UtilIOGetCWD</A>
<LI><A NAME="tex2html3433"
  HREF="node6.html#SECTION060154500000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_UtilIOMkDir</A>
<LI><A NAME="tex2html3434"
  HREF="node6.html#SECTION060154600000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_UtilIORmDir</A>
<LI><A NAME="tex2html3435"
  HREF="node6.html#SECTION060154700000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_UtilString2Double</A>
<LI><A NAME="tex2html3436"
  HREF="node6.html#SECTION060154800000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_UtilString2Int</A>
<LI><A NAME="tex2html3437"
  HREF="node6.html#SECTION060154900000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_UtilString2Real</A>
<LI><A NAME="tex2html3438"
  HREF="node6.html#SECTION0601541000000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_UtilStringInt2String</A>
<LI><A NAME="tex2html3439"
  HREF="node6.html#SECTION0601541100000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_UtilStringLowerCase</A>
<LI><A NAME="tex2html3440"
  HREF="node6.html#SECTION0601541200000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_UtilStringUpperCase</A>
<LI><A NAME="tex2html3441"
  HREF="node6.html#SECTION0601541300000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_UtilIOUnitFlush</A>
<LI><A NAME="tex2html3442"
  HREF="node6.html#SECTION0601541400000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_UtilIOUnitGet</A>
<LI><A NAME="tex2html3443"
  HREF="node6.html#SECTION0601541500000000000000"><SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_UtilSort</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION06000000000000000000">
<SPAN CLASS="arabic">5</SPAN> Infrastructure: Utilities</A>
</H1>


<P>

<H1><A NAME="SECTION06010000000000000000">
<SPAN CLASS="arabic">39</SPAN> Overview of Infrastructure Utility Classes</A>
</H1>

<P>
The ESMF utilities are a set of tools for quickly assembling modeling applications.

<P>
The ESMF Info class enables models to be self-describing via metadata, which are instances of JSON-compatible key-value pairs.

<P>
The Time Management Library provides utilities for time and time interval representation and calculation, and higher-level utilities that control model time stepping, via clocks, as well as alarming.

<P>
The ESMF Config class provides configuration management based on NASA DAO's Inpak package, a collection of methods for accessing files containing input parameters stored in an ASCII format.

<P>
The ESMF LogErr class consists of a variety of methods for writing error, warning, and informational messages to log files. A default Log is created during ESMF initialization. Other Logs can be created later in the code by the user.

<P>
The DELayout class provides a layer of abstraction on top of the Virtual Machine (VM) layer. DELayout does this by introducing DEs (Decomposition Elements) as logical resource units. The DELayout object keeps track of the relationship between its DEs and the resources of the associated VM object. A DELayout can be shaped by the user at creation time to best match the computational problem or other design criteria.

<P>
The ESMF VM (Virtual Machine) class is a generic representation of hardware and system software resources. There is exactly one VM object per ESMF Component, providing the execution environment for the Component code. The VM class handles all resource management tasks for the Component class and provides a description of the underlying configuration of the compute resources used by a Component.  In addition to resource description and management, the VM class offers the lowest level of ESMF communication methods.

<P>
The ESMF Fortran I/O utilities provide portable methods to access capabilities which are often implemented in different ways amongst different environments. Currently, two utility methods are implemented: one to find an unopened unit number, and one to flush an I/O buffer.

<H1><A NAME="SECTION06020000000000000000"></A>
<A NAME="esmf_info_class"></A>
<BR>
<SPAN CLASS="arabic">40</SPAN> Info Class (Object Attributes)
</H1>

<P>
All ESMF base objects (i.e. Array, ArrayBundle, Field, FieldBundle, Grid, Mesh, DistGrid) contain a key-value attribute storage object called <TT>ESMF_Info</TT>. <TT>ESMF_Info</TT> objects may also be created independent of a base object. <TT>ESMF_Info</TT> supports setting and getting key-value pairs where the <SPAN  CLASS="textit">key</SPAN> is a string and the <SPAN  CLASS="textit">value</SPAN> is a scalar or a list of common data types. An <TT>ESMF_Info</TT> object may have a flat or nested data structure. The purpose of <TT>ESMF_Info</TT> is to support I/O-compatible metadata structures (i.e. netCDF), internal record-keeping for model execution (NUOPC), and provide a mechanism for custom user metadata attributes.

<P>
<TT>ESMF_Info</TT> is designed for interoperability. To achieve this goal, <TT>ESMF_Info</TT> adopted the JSON (Javascript Object Notation) specification. Internally, <TT>ESMF_Info</TT> uses <SPAN  CLASS="textit">JSON for Modern C++</SPAN> [<A
 HREF="node8.html#json_for_modern_cpp">1</A>] to manage its storage map. There are numerous resources for JSON on the web [<A
 HREF="node8.html#json">11</A>]. Quoting from the <SPAN  CLASS="textit">json.org</SPAN> site [<A
 HREF="node8.html#json">11</A>] when it introduces the format:
<BLOCKQUOTE>
<SPAN  CLASS="textit">JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. It is based on a subset of the JavaScript Programming Language Standard ECMA-262 3rd Edition - December 1999. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. These properties make JSON an ideal data-interchange language.</SPAN>
    <SPAN  CLASS="textit">JSON is built on two structures:</SPAN>
    </BLOCKQUOTE>
<UL>
<LI><SPAN  CLASS="textit">A collection of name/value pairs. In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array.</SPAN>
</LI>
<LI><SPAN  CLASS="textit">An ordered list of values. In most languages, this is realized as an array, vector, list, or sequence.</SPAN>
    
</LI>
</UL><BLOCKQUOTE>
    <SPAN  CLASS="textit">These are universal data structures. Virtually all modern programming languages support them in one form or another. It makes sense that a data format that is interchangeable with programming languages also be based on these structures.</SPAN>

</BLOCKQUOTE>

<P>
By adopting JSON compliance for <TT>ESMF_Info</TT>, ESMF made its core metadata capabilities explicitly interoperable with a widely used data structure. If data may be represented with JSON, then it is compatible with <TT>ESMF_Info</TT>.

<P>
<SPAN  CLASS="textbf"><SPAN  CLASS="textit">There are some aspects of the <TT>ESMF_Info</TT> implementation related to JSON and <SPAN  CLASS="textit">JSON for Modern C++</SPAN> that should be noted:</SPAN></SPAN>

<OL>
<LI>JSON supports 64-bit data types for integers and reals ([<A
 HREF="node8.html#json_for_modern_cpp_64bit_int">3</A>], [<A
 HREF="node8.html#json_for_modern_cpp_64bit_float">2</A>]). I4/R4 is converted to I8/R8 and vice versa. <TT>ESMF_Info</TT> internally tracks 32-bit sets to ensure the data type may be appropriately queried.
</LI>
<LI>The memory overhead per JSON object (e.g. a key-value pair) requires an additional allocator pointer for type generalization [<A
 HREF="node8.html#json_for_modern_cpp_memory_overhead">6</A>]. Hence, the JSON map is not suited for big data storage, offering flexibility in exchange.
</LI>
<LI>Keys are stored in an unordered map sorted in lexicographical order.
</LI>
</OL>

<P>

<H2><A NAME="SECTION06021000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN> Migrating from Attribute</A>
</H2>
The <TT>ESMF_Info</TT> class is a replacement for the <TT>ESMF_Attribute</TT> class and is the preferred way of managing metadata attributes in ESMF moving forward. It is recommended that users migrate existing <TT>ESMF_Attribute</TT> calls to the new <TT>ESMF_Info</TT> API. The <TT>ESMF_Info</TT> class provides the backend for <TT>ESMF_Attribute</TT> since ESMF version 8.1. The <TT>ESMF_Attribute</TT> docs are located in appendix <A HREF="node9.html#appendix_attribute_legacy_api">57</A>. In practice, users should experience no friction when migrating client code. Please email ESMF support in the case of a migration issue. Some structural changes to <TT>ESMF_Attribute</TT> did occur:

<UL>
<LI>Changed behavior when getting fixed-size lists. List size in storage must match the size of the outgoing list.
</LI>
<LI>Removed ability to use a default value with list gets.
</LI>
<LI>Removed <TT>attPackInstanceName</TT> from all interfaces.
</LI>
<LI>Removed <TT>attcopyFlag</TT> from all interfaces.
</LI>
<LI>Removed <TT>ESMF_Attribute</TT>-managed object linking.
</LI>
<LI>Modified <TT>ESMF_AttributeAdd</TT> to set the target key to a null JSON value.
</LI>
<LI>Modified <TT>ESMF_AttributeSet</TT> to not require an attribute added to an <TT>ESMF_AttPack</TT> be added through <TT>ESMF_AttributeAdd</TT> before setting.
</LI>
<LI>Removed support for attribute XML I/O.
</LI>
<LI>Removed ability to add multiple nested Attribute packages.
</LI>
<LI>Removed retrieval of "internal" ESMF object Attributes.
</LI>
</UL>

<P>
Below are examples for setting and getting an attribute using <TT>ESMF_Info</TT> and the legacy <TT>ESMF_Attribute</TT>. The <TT>ESMF_Info</TT> interfaces are not overloaded for ESMF object types but rather work off a handle retrieved via a get call.

<P>

<H3><A NAME="SECTION06021100000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Setting an Attribute</A>
</H3>
With <TT>ESMF_Attribute</TT>:
<PRE>
call ESMF_AttributeSet(array, "aKey", 15, rc=rc)
</PRE>
With <TT>ESMF_Info</TT>:
<PRE>
call ESMF_InfoGetFromHost(array, info, rc=rc)
call ESMF_InfoSet(info, "aKey", 15, rc=rc)
</PRE>

<P>
Notice that the legacy <TT>ESMF_Attribute</TT> API expects the usage of what was called an "Attribute Package". This essentially corresponds to a namespace similar to what <TT>ESMF_Info</TT> provides for keys via the JSON Pointer syntax (see <A HREF="#info_key_format">40.2</A>). In the above <TT>ESMF_AttributeSet()</TT> call, without specification of <TT>convention</TT> and <TT>purpose</TT> arguments, the resulting JSON pointer of the key is "/ESMF/General/aKey". This is important to account for when mixing deprecated <TT>ESMF_Attribute</TT> calls with the <TT>ESMF_Info</TT> API.

<P>

<H3><A NAME="SECTION06021200000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Getting an Attribute</A>
</H3>
With <TT>ESMF_Attribute</TT>:
<PRE>
call ESMF_AttributeGet(array, "aKey", aKeyValue, rc=rc)
</PRE>
With <TT>ESMF_Info</TT>:
<PRE>
call ESMF_InfoGetFromHost(array, info, rc=rc)
call ESMF_InfoGet(info, "aKey", aKeyValue, rc=rc)
</PRE>

<P>
Notice again that the <TT>ESMF_Attribute</TT> API automatically prepends "/ESMF/General/" to the JSON pointer used for key in the absence of <TT>convention</TT> and <TT>purpose</TT> arguments.

<P>

<H2><A NAME="SECTION06022000000000000000"></A>
<A NAME="info_key_format"></A>
<BR>
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">2</SPAN> Key Format Overview
</H2>
A key in the <TT>ESMF_Info</TT> interface provides the location of a value to retrieve from the key-value storage. Keys in the <TT>ESMF_Info</TT> class use the JSON Pointer syntax [<A
 HREF="node8.html#json_for_modern_cpp_json_pointer">5</A>]. A forward slash is prepended to string keys if it does not exist. Hence, <TT>"aKey"</TT> and <TT>"/aKey"</TT> are equivalent. Note the indexing aspect of the JSON Pointer syntax is not supported.

<P>
Every "key" argument in the <TT>ESMF_Info</TT> class uses pathing following the JSON Pointer syntax [6]. A forward slash is prepended to string keys if it does not exist. Hence, "aKey" and "/aKey" are equivalent. Note the indexing aspect of the JSON Pointer syntax is not supported (i.e. "/my_list&nbsp;1").

<P>
Some examples for valid "key" arguments:

<UL>
<LI><TT>altitude</TT> :: A simple key argument with no nesting.
</LI>
<LI><TT>/altitude</TT> :: A simple key argument with no nesting with the prepended pointer forward slash.
</LI>
<LI><TT>/altitude/height_above_mean_sea_level</TT> :: A key for an attribute "height_above_mean_sea_level" nested in a map identified with key "altitude".
</LI>
</UL>

<H2><A NAME="SECTION06023000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">3</SPAN> Usage and Examples</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06023100000000000000"></A>
   <A NAME="get_info_handle_from_esmf_object"></A>
<BR>
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Retrieve an Info Handle
</H3>
   This example demonstrates how to retrieve an <TT>ESMF_Info</TT> object handle
   from an ESMF object. <TT>ESMF_Info</TT> handles are a view into the object's
   <TT>ESMF_Info</TT> storage and should <SPAN  CLASS="textbf"><SPAN  CLASS="textit">not</SPAN></SPAN> be created/destroyed
   as the <TT>ESMF_Info</TT>'s lifetime is determined by its host object's lifetime.
   Destroying the host object will leave a handle in an undefined state. 

<P>
Variable declarations:
<P>
<PRE>
    type(ESMF_DistGrid) :: distgrid
    type(ESMF_Array) :: array
    type(ESMF_Info) :: infoh
    real(ESMF_KIND_R8), dimension(10,10) :: farray
    integer :: rc
</PRE>

<P>
Create an ESMF Array.
<P>
<PRE>
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,10/), rc=rc)
</PRE>

<P>
<PRE>
    array = ESMF_ArrayCreate(distgrid, farray, indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
Get the <TT>ESMF_Info</TT> handle from the object. See example <A HREF="#info_tutorial">40.3.2</A> for
   additional usage examples.
<P>
<PRE>
    call ESMF_InfoGetFromHost(array, infoh, rc=rc)
</PRE>

<P>
<PRE>
</PRE>

<P>
Destroy everything except the <TT>ESMF_Info</TT> object. Attempting to destroy
   the <TT>ESMF_Info</TT> handle will result in an error.
<P>
<PRE>
    call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION06023200000000000000"></A>
   <A NAME="info_tutorial"></A>
<BR>
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> General Usage Examples
</H3>
   General usage examples for the <TT>ESMF_Info</TT> class. The demonstrated capabilities are:
   
<UL>
<LI>Creating an <TT>ESMF_Info</TT> object.
</LI>
<LI>Setting/getting a key-value pair.
</LI>
<LI>Setting/getting a list value and a list value by index.
</LI>
<LI>Printing and dumping <TT>ESMF_Info</TT> contents.
</LI>
<LI>Checking for key presence and set state (null value check).
</LI>
<LI>Setting/getting with nesting (hierarchies).
</LI>
<LI>Inquiring the <TT>ESMF_Info</TT> object for general item metadata and iteration purposes.
</LI>
<LI>Copying <TT>ESMF_Info</TT> contents.
</LI>
<LI>Removing a key-value pair from the <TT>ESMF_Info</TT> storage.
</LI>
<LI>Destroying the <TT>ESMF_Info</TT> object.
   
</LI>
</UL> 

<P>
Variable declarations:
<P>
<PRE>
    type(ESMF_Info) :: info, infoCopy, infoFromCh
    type(ESMF_TypeKind_Flag) :: typekind
    character(len=ESMF_MAXSTR) :: ikey
    character(:), allocatable :: output, getCh
    real(ESMF_KIND_R8), dimension(4) :: realList
    real(ESMF_KIND_R8), dimension(:), allocatable :: realListAlloc
    integer(ESMF_KIND_I4) :: getInt
    real(ESMF_KIND_R8) :: getReal
    integer :: rc, infoSize, ii
    logical :: isPresent, isSet
</PRE>

<P>
Create an <TT>ESMF_Info</TT> object. This object contains an empty key-value
   store called a JSON object [<A
 HREF="node8.html#json_for_modern_cpp_object">8</A>].

<P>
An <TT>ESMF_Info</TT> handle may also be retrieved from an ESMF object as opposed to
   creating a standalone <TT>ESMF_Info</TT> object. See example <A HREF="#get_info_handle_from_esmf_object">40.3.1</A>.
<P>
<PRE>
    info = ESMF_InfoCreate(rc=rc)
</PRE>

<P>
Add an integer value.
<P>
<PRE>
    call ESMF_InfoSet(info, "myIntegerKey", 54, rc=rc)
</PRE>

<P>
Get the integer value we just set.
<P>
<PRE>
    call ESMF_InfoGet(info, "myIntegerKey", getInt, rc=rc)
</PRE>

<P>
Set a list of reals.
<P>
<PRE>
    call ESMF_InfoSet(info, "myListOfReals", (/ 33.3, 44.4, 0.0, 99.0 /), rc=rc)
</PRE>

<P>
Set an index in the new list then retrieve the value.
<P>
<PRE>
    call ESMF_InfoSet(info, "myListOfReals", 1234.0, idx=3, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_InfoGet(info, "myListOfReals", getReal, idx=3, rc=rc)
</PRE>

<P>
Get the values from a list.
<P>
<PRE>
    call ESMF_InfoGet(info, "myListOfReals", realList, rc=rc)
</PRE>

<P>
Allocatable lists may be used through a specific interface.
<P>
<PRE>
    call ESMF_InfoGetAlloc(info, "myListOfReals", realListAlloc, rc=rc)
</PRE>

<P>
The storage contents may be printed directly or dumped to a character.
<P>
<PRE>
    call ESMF_InfoPrint(info, indent=4, rc=rc)
</PRE>

<P>
<PRE>
    output = ESMF_InfoDump(info, rc=rc)
</PRE>

<P>
<PRE>
    print *, "the Info dump: "//output
</PRE>

<P>
Check if a key is present.
<P>
<PRE>
    isPresent = ESMF_InfoIsPresent(info, "myIntegerKey", rc=rc)
</PRE>

<P>
<PRE>
    if (.not. isPresent) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Add a null value and check if it is set (has a non-null value).
<P>
<PRE>
    call ESMF_InfoSetNULL(info, "aNullKey", rc=rc)
</PRE>

<P>
<PRE>
    isSet = ESMF_InfoIsSet(info, "aNullKey", rc=rc)
</PRE>

<P>
<PRE>
    if (isSet) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    isSet = ESMF_InfoIsSet(info, "myIntegerKey", rc=rc)
</PRE>

<P>
<PRE>
    if (.not. isSet) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
The force flag, when set to false, will cause an error if the key exists in the
   map. The force flag is set to true by default.
<P>
<PRE>
    call ESMF_InfoSet(info, "myIntegerKey", 33, force=.false., rc=rc)
    if (rc .ne. ESMC_RC_CANNOT_SET) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Nesting uses the JSON Pointer <A HREF="#info_key_format">40.2</A> syntax. All key arguments
   in <TT>ESMF_Info</TT> may use this syntax unless noted otherwise. When creating
   a nested object, objects are created if they do not exist. Hence, it is not necessary
   to create the individual nested elements for deep hierarchies.
<P>
<PRE>
    call ESMF_InfoSet(info, "/Universe/Galaxy/Star/Planet", "Venus", rc=rc)
</PRE>

<P>
Using the get interface, it is possible to iterate over the storage contents.
   In the call below, we are retrieving the number of elements (key-value pairs)
   that exist in our root storage object. We then select the target element in root
   using an index and retrieve some additional metadata for the target object.
<P>
<PRE>
    call ESMF_InfoGet(info, size=infoSize, rc=rc)
</PRE>

<P>
<PRE>
    do ii=1,infoSize
      call ESMF_InfoGet(info, idx=ii, ikey=ikey, typekind=typekind, rc=rc)
</PRE>

<P>
<PRE>
      if (localPet == 0) then
        print *, "ESMF_Info inquire loop: "
        print *, "       idx= ", ii
        print *, "      ikey= ", trim(ikey)
        print *, "  typekind= ", typekind
      endif
    enddo
</PRE>

<P>
Copying the <TT>ESMF_Info</TT> object requires the copy to be destroyed/deallocated.
<P>
<PRE>
    infoCopy = ESMF_InfoCreate(info, rc=rc)
</PRE>

<P>
Comparison operators = and /= are implemented for <TT>ESMF_Info</TT> objects.
<P>
<PRE>
    if (infoCopy /= info) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
After removing a key from the copied <TT>ESMF_Info</TT> object, the two objects will no
   longer be equal.
<P>
<PRE>
    call ESMF_InfoRemove(infoCopy, "myIntegerKey", rc=rc)
</PRE>

<P>
<PRE>
    if (infoCopy == info) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
Destroy the copied object.
<P>
<PRE>
    call ESMF_InfoDestroy(infoCopy, rc=rc)
</PRE>

<P>
An <TT>ESMF_Info</TT> object may be created from a JSON string. Note the usage of quotes
   is required as below.
<P>
<PRE>
    infoFromCh = ESMF_InfoCreate('{"hello":"world"}', rc=rc)
</PRE>

<P>
The contents of an <TT>ESMF_Info</TT> object may be set in another <TT>ESMF_Info</TT> object.
<P>
<PRE>
    call ESMF_InfoSet(info, "infoFromCh", infoFromCh, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_InfoDestroy(infoFromCh, rc=rc)
</PRE>

<P>
An allocatable character get interface is available.
<P>
<PRE>
    call ESMF_InfoGetCharAlloc(info, "/infoFromCh/hello", getCh, rc=rc)
</PRE>

<P>
Destroy the <TT>ESMF_Info</TT> object.
<P>
<PRE>
    call ESMF_InfoDestroy(info, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION06024000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06024100000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_InfoAssignment(=) - Info assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     info1 = info2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Info) :: info1
     type(ESMF_Info) :: info2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign info1 as an alias to the same ESMF Info object in memory
     as info2. If info2 is invalid, then info1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>info1</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>info2</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06024200000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_InfoOperator(==) - Info equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> interface operator(==)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_Info), intent(in) :: info1
      type(ESMF_Info), intent(in) :: info2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test if the contents of two <TT>ESMF_Info</TT> objects are equal.

<P>
The arguments are:
     <DL>
<DT><STRONG>info1</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object on the left hand side of the operation.
       
</DD>
<DT><STRONG>info1</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object on the right hand side of the operation.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06024300000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_InfoOperator(/=) - Info not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> interface operator(/=)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_Info), intent(in) :: info1
      type(ESMF_Info), intent(in) :: info2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test if the contents of two <TT>ESMF_Info</TT> objects are not equal.

<P>
The arguments are:
     <DL>
<DT><STRONG>info1</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object on the left hand side of the operation.
       
</DD>
<DT><STRONG>info1</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object on the right hand side of the operation.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06024400000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_InfoBroadcast - Broadcast Info contents</A>
</H3>

<P>
<A NAME="esmf_infobroadcast"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> subroutine ESMF_InfoBroadcast(info, rootPet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(inout) :: info
   integer, intent(in) :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Broadcast an <TT>ESMF_Info</TT> object collectively across the current VM.

<P>
Users wishing to synchronize via broadcast an attribute hierarchy associated
       with an ESMF object should consult the <TT>ESMF_InfoSync</TT> documentation
       <A HREF="#esmf_infosync">40.4.29</A>

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object that is the source (on <SPAN  CLASS="textit">rootPet</SPAN>) or the
         destination object to populate (on all other PETs). On destination PETs,
         the structure of <SPAN  CLASS="textit">info</SPAN> is overwritten with data from <SPAN  CLASS="textit">rootPet</SPAN>.
       
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>The root PET identifier.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06024500000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_InfoCreate - Create a new Info object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_InfoCreate()
 function ESMF_InfoCreateEmpty(rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Info) :: ESMF_InfoCreateEmpty
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Info</TT> object. This object must be destroyed using
       <TT>ESMF_InfoDestroy</TT> to free its memory allocation

<P>
The arguments are:
       <DL>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06024600000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_InfoCreate - Create a new Info object using a key</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_InfoCreate()
 function ESMF_InfoCreateByKey(info, key, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
   character(len=*), intent(in) :: key
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Info) :: ESMF_InfoCreateByKey
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Info</TT> object from a location in <SPAN  CLASS="textit">info</SPAN>
       defined by <SPAN  CLASS="textit">key</SPAN>. Returned object is a deep copy. The value associated
       with <TT>key</TT> must be a nested object (i.e. a collection of key/value
       pairs).

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object providing source data.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06024700000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_InfoCreate - Create an Info object from another Info object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_InfoCreate()
 function ESMF_InfoCreateFromInfo(info, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Info) :: ESMF_InfoCreateFromInfo
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Info</TT> object from another <TT>ESMF_Info</TT> object.
       The returned object is a deep copy of the source object.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object acting as the source data.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06024800000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_InfoCreate - Create a new Info object by string parsing</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_InfoCreate()
 function ESMF_InfoCreateByParse(jsonString, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   character(len=*), intent(in) :: jsonString
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Info) :: ESMF_InfoCreateByParse
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Info</TT> object by parsing a JSON-formatted string.

<P>
The arguments are:
       <DL>
<DT><STRONG>jsonString</STRONG></DT>
<DD>The string to parse.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06024900000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_InfoDestroy - Destroy an Info object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> subroutine ESMF_InfoDestroy(info, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(inout) :: info
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_Info</TT> object. Destroying an <TT>ESMF_Info</TT>
       object created internally by an ESMF object results in an error

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_InfoDump - Dump Info contents to string</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> function ESMF_InfoDump(info, key, indent, rc) result(output)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character(*), intent(in), optional :: key
   integer, intent(in), optional :: indent
   integer, intent(out), optional :: rc
   RESULT:
   character(:), allocatable :: output
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Dump the contents of an <TT>ESMF_Info</TT> object as a JSON string.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>[key]</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>[indent]</STRONG></DT>
<DD>Default is 0. Specifying an indentation greater than 0 will result in a
         "pretty print" for JSON output string (string includes new line breaks).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241100000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_InfoGet - Get a numeric, logical, or fixed-size character value</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  subroutine ESMF_InfoGet(info, key, value, default, idx, attnestflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_Info), intent(in) :: info
    character(len=*), intent(in) :: key
    &lt;value&gt;, see below for supported value
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    &lt;default, optional&gt; see below for supported default value
    integer, intent(in), optional :: idx
    type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a value from an <TT>ESMF_Info</TT> object using a key. If the key is
       not found, <SPAN  CLASS="textit">rc</SPAN> will not equal <TT>ESMF_SUCCESS</TT>. The returned
       value is always a copy including gets with a <SPAN  CLASS="textit">default</SPAN>.

<P>
Overloaded <SPAN  CLASS="textit">value</SPAN> for the following types:
       
<UL>
<LI><TT>integer(kind=ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(kind=ESMF_KIND_I8)</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>character(:)</TT>
       
</LI>
</UL>

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The output value associated with the key.
       
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>A default value to use if the key is not present in the target <TT>ESMF_Info</TT>
         object. Must be the same typekind and size as <SPAN  CLASS="textit">value</SPAN>.
       
</DD>
<DT><STRONG>[idx]</STRONG></DT>
<DD>An integer index to get if the target key's value is a list.
       
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>Setting to <TT>ESMF_ATTNEST_ON</TT> triggers a recursive search. The
         first instance of the key (searching by depth) will be found in the hierarchy.
         Default is <TT>ESMF_ATTNEST_OFF</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241200000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_InfoGetCharAlloc - Get an allocatable character value</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  subroutine ESMF_InfoGetCharAlloc(info, key, value, default, idx, attnestflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_Info), intent(in) :: info
    character(len=*), intent(in) :: key
    character(:), allocatable, intent(out) :: value
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    character(len=*), intent(in), optional :: default
    integer, intent(in), optional :: idx
    type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a value from an <TT>ESMF_Info</TT> object using a key. If the key is
       not found, <SPAN  CLASS="textit">rc</SPAN> will not equal <TT>ESMF_SUCCESS</TT>. The returned
       value is always a copy including gets with a <SPAN  CLASS="textit">default</SPAN>.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The output value associated with the key.
       
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>A default value to use if the key is not present in the target <TT>ESMF_Info</TT>
         object. Must be the same typekind and size as <SPAN  CLASS="textit">value</SPAN>.
       
</DD>
<DT><STRONG>[idx]</STRONG></DT>
<DD>An integer index to get if the target key's value is a list.
       
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>Setting to <TT>ESMF_ATTNEST_ON</TT> triggers a recursive search. The
         first instance of the key (searching by depth) will be found in the hierarchy.
         Default is <TT>ESMF_ATTNEST_OFF</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241300000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_InfoGet - Get a list</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  subroutine ESMF_InfoGet(info, key, values, itemCount, attnestflag, scalarToArray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_Info), intent(in) :: info
    character(len=*), intent(in) :: key
    &lt;values&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    integer, intent(out), optional :: itemCount
    type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
    logical, intent(in), optional :: scalarToArray
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a value list from an <TT>ESMF_Info</TT> object using a key. If the key
       is not found, <SPAN  CLASS="textit">rc</SPAN> will not equal <TT>ESMF_SUCCESS</TT>. The returned
       value is always a copy.

<P>
The length of <SPAN  CLASS="textit">values</SPAN> must match its length in storage.

<P>
Overloaded <SPAN  CLASS="textit">values</SPAN> for the following types:
       
<UL>
<LI><TT>integer(kind=ESMF_KIND_I4), dimension(:)</TT>
</LI>
<LI><TT>integer(kind=ESMF_KIND_I8), dimension(:)</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R4), dimension(:)</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R8), dimension(:)</TT>
</LI>
<LI><TT>logical, dimension(:)</TT>
</LI>
<LI><TT>character(:), dimension(:)</TT>
       
</LI>
</UL>

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>values</STRONG></DT>
<DD>The output value list associated with the key.
       
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in <SPAN  CLASS="textit">values</SPAN>.
       
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>Default is <TT>ESMF_ATTNEST_OFF</TT>. Setting to <TT>ESMF_ATTNEST_ON</TT>
         triggers a recursive search. The first instance of the key will be found
         in the hierarchy.
       
</DD>
<DT><STRONG>[scalarToArray]</STRONG></DT>
<DD>Default is false. If true, allow conversion of scalar values in storage
         to single-valued lists.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241400000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_InfoGetAlloc - Get an allocatable list</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  subroutine ESMF_InfoGetAlloc(info, key, values, itemCount, attnestflag, scalarToArray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_Info), intent(in) :: info
    character(len=*), intent(in) :: key
    &lt;values&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    integer, intent(out), optional :: itemCount
    type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
    logical, intent(in), optional :: scalarToArray
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a value list from an <TT>ESMF_Info</TT> object using a key. If the key
       is not found, <SPAN  CLASS="textit">rc</SPAN> will not equal <TT>ESMF_SUCCESS</TT>. The returned
       value is always a copy.

<P>
Overloaded <SPAN  CLASS="textit">values</SPAN> for the following types:
       
<UL>
<LI><TT>integer(kind=ESMF_KIND_I4), dimension(:), allocatable</TT>
</LI>
<LI><TT>integer(kind=ESMF_KIND_I8), dimension(:), allocatable</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R4), dimension(:), allocatable</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R8), dimension(:), allocatable</TT>
</LI>
<LI><TT>logical, dimension(:), allocatable</TT>
</LI>
<LI><TT>character(:), dimension(:), allocatable</TT>
       
</LI>
</UL>

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>values</STRONG></DT>
<DD>The output value list associated with the key.
       
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in <SPAN  CLASS="textit">values</SPAN>.
       
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>Default is <TT>ESMF_ATTNEST_OFF</TT>. Setting to <TT>ESMF_ATTNEST_ON</TT>
         triggers a recursive search. The first instance of the key will be found
         in the hierarchy.
       
</DD>
<DT><STRONG>[scalarToArray]</STRONG></DT>
<DD>Default is false. If true, allow conversion of scalar values in storage
         to single-valued lists.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241500000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_InfoGet - Inquire an Info object for metadata</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_InfoGet()
  subroutine ESMF_InfoInquire(info, size, key, jsonType, isArray, &amp;
    isDirty, idx, typekind, ikey, isPresent, isStructured, isNull, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_Info), intent(in) :: info
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    integer, intent(out), optional :: size
    character(len=*), intent(in), optional :: key
    character(len=*), intent(out), optional :: jsonType
    logical, intent(out), optional :: isArray
    logical, intent(out), optional :: isDirty
    integer, intent(in), optional :: idx
    type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
    character(len=*), intent(out), optional :: ikey
    logical, intent(out), optional :: isPresent
    logical, intent(out), optional :: isStructured
    logical, intent(out), optional :: isNull
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Inquire an <TT>ESMF_Info</TT> object for metadata.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>[size]</STRONG></DT>
<DD>Returns the size of the target. The following rules apply:
         
<UL>
<LI>If the target is an object, return the number of key-value pairs.
</LI>
<LI>If the target is a scalar, return <TT>1</TT>.
</LI>
<LI>If the target is an array, return its length.
         
</LI>
</UL>
       
</DD>
<DT><STRONG>[key]</STRONG></DT>
<DD>If provided, use this location as the origin instead of root. See section
         <A HREF="#info_key_format">40.2</A> for an overview of the key format.
       
</DD>
<DT><STRONG>[jsonType]</STRONG></DT>
<DD>Returns the JSON object type name [<A
 HREF="node8.html#json_for_modern_cpp_typename">9</A>].
       
</DD>
<DT><STRONG>[isArray]</STRONG></DT>
<DD>Returns true if the target is an array.
       
</DD>
<DT><STRONG>[isDirty]</STRONG></DT>
<DD>Returns true if the <TT>ESMF_Info</TT> object should be synchronized during
         an <TT>ESMF_InfoSync</TT> operation.
       
</DD>
<DT><STRONG>[idx]</STRONG></DT>
<DD>An integer index to use. This will index into an object type providing
         the primary mechanism for iteration.
       
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>Get the ESMF typekind for the target. The minimum typekind required to
         hold the value is returned.
         See section <A HREF="node9.html#const:typekind">54.61</A> for valid values.
       
</DD>
<DT><STRONG>[ikey]</STRONG></DT>
<DD>If present, this will be set to the key's name for the current inquire.
         Useful when iterating using an index. This does <SPAN  CLASS="textit">not</SPAN> return the full key
         path if nested.
       
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Returns true if the <SPAN  CLASS="textit">key</SPAN> exists in storage. If no <SPAN  CLASS="textit">key</SPAN>
         is provided, this will return true.
       
</DD>
<DT><STRONG>[isStructured]</STRONG></DT>
<DD>Returns true if the target is structured [<A
 HREF="node8.html#json_for_modern_cpp_is_structured">4</A>].
         This means it is either an object (a map) or an array.
       
</DD>
<DT><STRONG>[isNull]</STRONG></DT>
<DD>Returns true if the target is null [<A
 HREF="node8.html#json_for_modern_cpp_null">7</A>].
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241600000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_InfoGetFromHost - Get an Info handle from an ESMF object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  subroutine ESMF_InfoGetFromHost(host, info, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_*), intent(inout) :: host
    type(ESMF_Info), intent(out) :: info
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get an <TT>ESMF_Info</TT> object handle from a host ESMF object. The returned
       handle should not be destroyed.

<P>
The arguments are:
       <DL>
<DT><STRONG>host</STRONG></DT>
<DD>Target ESMF object. Overloaded for:
         
<UL>
<LI><TT>ESMF_Array</TT>
</LI>
<LI><TT>ESMF_ArrayBundle</TT>
</LI>
<LI><TT>ESMF_CplComp</TT>
</LI>
<LI><TT>ESMF_GridComp</TT>
</LI>
<LI><TT>ESMF_SciComp</TT>
</LI>
<LI><TT>ESMF_DistGrid</TT>
</LI>
<LI><TT>ESMF_Field</TT>
</LI>
<LI><TT>ESMF_FieldBundle</TT>
</LI>
<LI><TT>ESMF_Grid</TT>
</LI>
<LI><TT>ESMF_State</TT>
</LI>
<LI><TT>ESMF_LocStream</TT>
</LI>
<LI><TT>ESMF_Mesh</TT>
         
</LI>
</UL>
       
</DD>
<DT><STRONG>info</STRONG></DT>
<DD>Outgoing <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241700000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_InfoGetTK - Retrieve the ESMF TypeKind for a key</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> function ESMF_InfoGetTK(info, key, attnestflag, rc) result(typekind)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
   character(len=*), intent(in) :: key
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_TypeKind_Flag) :: typekind
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the ESMF TypeKind of the value associated with <SPAN  CLASS="textit">key</SPAN>.
       See section <A HREF="node9.html#const:typekind">54.61</A> for valid return values.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>Setting to <TT>ESMF_ATTNEST_ON</TT> triggers a recursive search for
         <SPAN  CLASS="textit">keyParent</SPAN>. The first instance of the key will be found in the
         hierarchy. Default is <TT>ESMF_ATTNEST_OFF</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241800000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_InfoGetArrayMeta - Retrieve array metadata information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> subroutine ESMF_InfoGetArrayMeta(info, key, isArray, size, attnestflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
   character(len=*), intent(in) :: key
   logical, intent(out) :: isArray
   integer(C_INT), intent(out) :: size
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return a value's array status and size using a <SPAN  CLASS="textit">key</SPAN>.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>isArray</STRONG></DT>
<DD>Set to <TT>true</TT> if the target is an array in storage.
       
</DD>
<DT><STRONG>size</STRONG></DT>
<DD>Set to the size of the target object in storage (i.e. length of the array).
       
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>Setting to <TT>ESMF_ATTNEST_ON</TT> triggers a recursive search for
         <SPAN  CLASS="textit">keyParent</SPAN>. The first instance of the key will be found in the
         hierarchy. Default is <TT>ESMF_ATTNEST_OFF</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060241900000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_InfoIsPresent - Check for key presence</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> function ESMF_InfoIsPresent(info, key, attnestflag, isPointer, rc) result(is_present)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
   character(len=*), intent(in) :: key
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   logical, intent(in), optional :: isPointer
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: is_present
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return true if <SPAN  CLASS="textit">key</SPAN> exists in <TT>ESMF_Info</TT>'s storage.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>Setting to <TT>ESMF_ATTNEST_ON</TT> triggers a recursive search for
         <SPAN  CLASS="textit">keyParent</SPAN>. The first instance of the key will be found in the
         hierarchy. Default is <TT>ESMF_ATTNEST_OFF</TT>.
       
</DD>
<DT><STRONG>[isPointer]</STRONG></DT>
<DD>Default is true. If true, expect the <SPAN  CLASS="textit">key</SPAN> is using JSON Pointer
         syntax (see section <A HREF="#info_key_format">40.2</A>). Setting to false will trigger
         a slightly faster search.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_InfoIsSet - Check if a value is null</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> function ESMF_InfoIsSet(info, key, rc) result(is_set)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
   character(len=*), intent(in) :: key
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: is_set
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns true if the target value is not null [<A
 HREF="node8.html#json_for_modern_cpp_null">7</A>].

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242100000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_InfoPrint - Print contents of an Info object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> subroutine ESMF_InfoPrint(info, indent, preString, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character(*), intent(in), optional :: preString
   character(*), intent(out), optional :: unit
   integer, intent(in), optional :: indent
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print <TT>ESMF_Info</TT> contents in JSON format.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>[indent]</STRONG></DT>
<DD>Default is 0. Specify a "pretty print" indentation for the JSON output string.
       
</DD>
<DT><STRONG>[preString]</STRONG></DT>
<DD>Optionally prepended string. Default to empty string.
       
</DD>
<DT><STRONG>[unit]</STRONG></DT>
<DD>Internal unit, i.e. a string. Default to printing to stdout.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242200000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_InfoReadJSON - Read JSON data from file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> function ESMF_InfoReadJSON(filename, rc) result(info_r)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   character(len=*), intent(in) :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Info) :: info_r
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Read JSON data from a file and return a new <TT>ESMF_Info</TT> object.

<P>
The arguments are:
       <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>Path to the input file.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242300000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_InfoRemove - Remove a key-value pair from an Info object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> subroutine ESMF_InfoRemove(info, keyParent, keyChild, attnestflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(inout) :: info
   character(len=*), intent(in) :: keyParent
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character(len=*), intent(in), optional :: keyChild
   type(ESMF_AttNest_Flag), intent(in), optional :: attnestflag
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove a key-value pair from an <TT>ESMF_Info</TT> object.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>keyParent</STRONG></DT>
<DD>String key to identify the parent location for the removal. If no <SPAN  CLASS="textit">keyChild</SPAN>
         is specified, then the root location is assumed. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>[keyChild]</STRONG></DT>
<DD>String key to identify the value for the removal. This <SPAN  CLASS="textit">may not</SPAN>
         be a path.
       
</DD>
<DT><STRONG>[attnestflag]</STRONG></DT>
<DD>Setting to <TT>ESMF_ATTNEST_ON</TT> triggers a recursive search for
         <SPAN  CLASS="textit">keyParent</SPAN>. The first instance of the key will be found in the
         hierarchy. Default is <TT>ESMF_ATTNEST_OFF</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242400000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_InfoSet - Set a value</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  subroutine ESMF_InfoSet(info, key, value, force, idx, pkey, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_Info), intent(inout) :: info
    character(len=*), intent(in) :: key
    &lt;value&gt;, see below for supported value
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    logical, intent(in), optional :: force
    integer, intent(in), optional :: idx
    character(len=*), intent(in), optional :: pkey
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a <SPAN  CLASS="textit">value</SPAN> in an <TT>ESMF_Info</TT> object using a key.

<P>
Overloaded <SPAN  CLASS="textit">value</SPAN> for the following types:
       
<UL>
<LI><TT>integer(kind=ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(kind=ESMF_KIND_I8)</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>character(:)</TT>
       
</LI>
</UL>

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The input value associated with the key.
       
</DD>
<DT><STRONG>[force]</STRONG></DT>
<DD>Default is true. When true, insert the key even if it already exists in
         storage. If false, <SPAN  CLASS="textit">rc</SPAN> will not return <TT>ESMF_SUCCESS</TT> if the
         key already exists.
       
</DD>
<DT><STRONG>[idx]</STRONG></DT>
<DD>An integer index to set if the target key's value is a list.
       
</DD>
<DT><STRONG>[pkey]</STRONG></DT>
<DD>Use this key's location as the origin for the set call.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242500000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_InfoSet - Set a key to the contents of an Info object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_InfoSet
 subroutine ESMF_InfoSetINFO(info, key, value, force, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(inout) :: info
   character(len=*), intent(in) :: key
   type(ESMF_Info), intent(in) :: value
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   logical, intent(in), optional :: force
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a value to the contents of an <TT>ESMF_Info</TT> object. A copy of
       the source contents is made.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object to use as source data.
       
</DD>
<DT><STRONG>[force]</STRONG></DT>
<DD>Default is true. When true, insert the key even if it already exists in
         storage. If false, <SPAN  CLASS="textit">rc</SPAN> will not return <TT>ESMF_SUCCESS</TT> if the
         key already exists.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242600000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_InfoSet - Set contents from a HConfig object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_InfoSet
 recursive subroutine ESMF_InfoSetHConfig(info, value, keyPrefix, force, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(inout) :: info
   type(ESMF_HConfig), intent(in) :: value
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character(len=*), intent(in), optional :: keyPrefix
   logical, intent(in), optional :: force
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
The provided <TT>ESMF_HConfig</TT> object is expected to be a <EM>map</EM>.
       An error is returned if this condition is not met. Each key-value pair
       held by the <TT>ESMF_HConfig</TT> object is added to the
       <TT>ESMF_Info</TT> object. A copy of the source contents is made.

<P>
Transfer of <EM>scalar</EM>, <EM>sequence</EM>, and <EM>map</EM> values
       from <TT>ESMF_HConfig</TT> to <TT>ESMF_Info</TT> are supported.
       Maps are treated recursively. Sequences are restricted to scalar elements
       of the same typekind.

<P>
The keys of any map provided by the <TT>ESMF_HConfig</TT> object must
       be of scalar type. Keys are interpreted as strings when transferred to the
       <TT>ESMF_Info</TT> object. YAML merge keys "&#171;" are supported.

<P>
When existing keys in <TT>info</TT> are overridden by this operation, the
       typekind of the associated value element is allowed to change.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The <TT>ESMF_HConfig</TT> object to use as source data.
       
</DD>
<DT><STRONG>[keyPrefix]</STRONG></DT>
<DD>If provided, prepend <TT>keyPrefix</TT> to each of the keys found in the
         <TT>value</TT> map.
       
</DD>
<DT><STRONG>[force]</STRONG></DT>
<DD>Default is true. When true, insert the key even if it already exists in
         storage. If false, <SPAN  CLASS="textit">rc</SPAN> will not return <TT>ESMF_SUCCESS</TT> if the
         key already exists.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242700000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_InfoSet - Set a value list</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  subroutine ESMF_InfoSet(info, key, values, force, pkey, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_Info), intent(inout) :: info
    character(len=*), intent(in) :: key
    &lt;values&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    logical, intent(in), optional :: force
    character(len=*), intent(in), optional :: pkey
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a value list in an <TT>ESMF_Info</TT> object using a key. List values
       are initialized to null.

<P>
Overloaded <SPAN  CLASS="textit">values</SPAN> for the following types:
       
<UL>
<LI><TT>integer(kind=ESMF_KIND_I4), dimension(:)</TT>
</LI>
<LI><TT>integer(kind=ESMF_KIND_I8), dimension(:)</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R4), dimension(:)</TT>
</LI>
<LI><TT>real(kind=ESMF_KIND_R8), dimension(:)</TT>
</LI>
<LI><TT>logical, dimension(:)</TT>
</LI>
<LI><TT>character(:), dimension(:)</TT>
       
</LI>
</UL>

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>values</STRONG></DT>
<DD>The input value list associated with the key.
       
</DD>
<DT><STRONG>[force]</STRONG></DT>
<DD>Default is true. When true, insert the key even if it already exists in
         storage. If false, <SPAN  CLASS="textit">rc</SPAN> will not return <TT>ESMF_SUCCESS</TT> if the
         key already exists.
       
</DD>
<DT><STRONG>[pkey]</STRONG></DT>
<DD>Use this key's location as the origin for the set call. Used primarily
         for recursive requirements related to <TT>ESMF_Attribute</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242800000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_InfoSetNULL - Set a value to null</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> subroutine ESMF_InfoSetNULL(info, key, force, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(inout) :: info
   character(len=*), intent(in) :: key
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   logical, intent(in), optional :: force
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set a value to null [<A
 HREF="node8.html#json_for_modern_cpp_null">7</A>].

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>key</STRONG></DT>
<DD>String key to access in <TT>ESMF_Info</TT> storage. See section <A HREF="#info_key_format">40.2</A>
         for an overview of the key format.
       
</DD>
<DT><STRONG>[force]</STRONG></DT>
<DD>Default is true. When true, insert the key even if it already exists in
         storage. If false, <SPAN  CLASS="textit">rc</SPAN> will not return <TT>ESMF_SUCCESS</TT> if the
         key already exists.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060242900000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_InfoSync - Synchronize Info contents across a VM</A>
</H3>

<P>
<A NAME="esmf_infosync"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>  subroutine ESMF_InfoSync(host, rootPet, vm, markClean, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>    type(ESMF_*), intent(inout) :: host
    integer, intent(in) :: rootPet
    type(ESMF_VM), intent(in) :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
    logical, intent(in), optional :: markClean
    integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Synchronize <TT>ESMF_Info</TT> contents collectively across the current VM.
       Contents on the <SPAN  CLASS="textit">rootPet</SPAN> are set as the contents on matching objects
       sharing the VM. An attempt is made to optimize by only communicating updated
       contents (i.e. something set or modified). This subroutine will traverse
       the ESMF object hierarchy associated with <TT>host</TT> (i.e. Arrays in
       an ArrayBundle, Fields in a FieldBundle, etc.).

<P>
Users interested in broadcasting only the <TT>ESMF_Info</TT> object should
       consult the <TT>ESMF_InfoBroadcast</TT> documentation <A HREF="#esmf_infobroadcast">40.4.4</A>.

<P>
The arguments are:
       <DL>
<DT><STRONG>host</STRONG></DT>
<DD>Target ESMF object. Overloaded for:
         
<UL>
<LI><TT>ESMF_State</TT>
</LI>
<LI><TT>ESMF_CplComp</TT>
</LI>
<LI><TT>ESMF_GridComp</TT>
</LI>
<LI><TT>ESMF_SciComp</TT>
</LI>
<LI><TT>ESMF_Field</TT>
</LI>
<LI><TT>ESMF_FieldBundle</TT>
         
</LI>
</UL>
       
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>The root PET to use for the synchronization.
       
</DD>
<DT><STRONG>vm</STRONG></DT>
<DD>The VM to synchronize across.
       
</DD>
<DT><STRONG>[markClean]</STRONG></DT>
<DD>Default is false. If true, mark changed <TT>ESMF_Info</TT> contents as
         clean once synchronized. These contents will no longer be broadcast in
         consecutive calls to <TT>ESMF_InfoSync</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060243000000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_InfoUpdate - Update the contents of an Info object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> subroutine ESMF_InfoUpdate(lhs, rhs, recursive, overwrite, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(inout) :: lhs
   type(ESMF_Info), intent(in) :: rhs
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   logical, intent(in), optional :: recursive
   logical, intent(in), optional :: overwrite
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Update the contents of <SPAN  CLASS="textit">lhs</SPAN> using the contents of <SPAN  CLASS="textit">rhs</SPAN>. The
       operation inserts or overwrites any key in <SPAN  CLASS="textit">lhs</SPAN> if it exists in <SPAN  CLASS="textit">rhs</SPAN>.
       Otherwise, the contents of <SPAN  CLASS="textit">lhs</SPAN> is left unaltered. See the JSON
       documentation for implementation details [<A
 HREF="node8.html#json_for_modern_cpp_update">10</A>].
       If <SPAN  CLASS="textit">recursive</SPAN> is <SPAN  CLASS="textit">.true.</SPAN> (default is <TT>.false.</TT>),
       nested objects will be updated by their component key/values. Otherwise,
       the first instance or top-level key is replaced without the child contents
       being updated element-by-element.

<P>
The arguments are:
       <DL>
<DT><STRONG>lhs</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object to update.
       
</DD>
<DT><STRONG>rhs</STRONG></DT>
<DD>The <TT>ESMF_Info</TT> object whose contents are used to update <SPAN  CLASS="textit">lhs</SPAN>.
       
</DD>
<DT><STRONG>[recursive]</STRONG></DT>
<DD>Default is <TT>.false.</TT>. If <TT>.true.</TT>, descend into nested objects
         and recursively update the contents.
       
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>Default is <TT>.false.</TT>. If <TT>.true.</TT>, key-values that exist
         in <SPAN  CLASS="textit">lhs</SPAN> will be overwritten by key-values in <SPAN  CLASS="textit">rhs</SPAN>. Flag
         is only applicable when <SPAN  CLASS="textit">recursive</SPAN> is <TT>.true.</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060243100000000000000">
<SPAN CLASS="arabic">40</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_InfoWriteJSON - Write Info contents to file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> subroutine ESMF_InfoWriteJSON(info, filename, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Info), intent(in) :: info
   character(len=*), intent(in) :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write <TT>ESMF_Info</TT> contents to file using the JSON format.

<P>
The arguments are:
       <DL>
<DT><STRONG>info</STRONG></DT>
<DD>Target <TT>ESMF_Info</TT> object.
       
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Path to the output file.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>


<H1><A NAME="SECTION06030000000000000000">
<SPAN CLASS="arabic">41</SPAN> Time Manager Utility</A>
</H1>
  
<P>
The ESMF Time Manager utility includes software for time and date 
representation and calculations, model time advancement, and the 
identification of unique and periodic events.  Since multi-component 
geophysical applications often require synchronization across
the time management schemes of the individual components, the 
Time Manager's standard calendars and consistent time representation 
promote component interoperability.
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Drift-free timekeeping through an integer-based internal time 
representation.  Both integers and reals can be specified at the interface.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>The ability to represent time as a rational fraction, to support 
exact timekeeping in applications that involve grid refinement.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for many calendar kinds, including user-customized calendars.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for both concurrent and sequential modes of component execution.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for varying and negative time steps.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION06031000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">1</SPAN> Time Manager Classes</A>
</H2>
There are five ESMF classes that represent time concepts:

<UL>
<LI><B>Calendar</B>  A Calendar can be used to keep track of the 
date as an ESMF Gridded Component advances in time. Standard calendars 
(such as Gregorian and 360-day) and user-specified calendars are 
supported.  Calendars can be queried for quantities such as seconds 
per day, days per month, and days per year.  
</LI>
<LI><B>Time</B> A Time represents a time instant in a particular
calendar, such as November 28, 1964, at 7:31pm EST in the Gregorian 
calendar.  The Time class can be used 
to represent the start and stop time of a time integration.
</LI>
<LI><B>TimeInterval</B> TimeIntervals represent a period 
of time, such as 300 milliseconds.  Time steps can be represented 
using TimeIntervals.  
</LI>
<LI><B>Clock</B> Clocks collect the parameters and 
methods used for model time advancement into a convenient 
package.  A Clock can be queried for quantities such
as start time, stop time, current time, and time step.  Clock
methods include incrementing the current time, and determining
if it is time to stop.  
</LI>
<LI><B>Alarm</B> Alarms identify unique or periodic events
by &ldquo;ringing&rdquo; - returning a true value - at specified times.  
For example, an Alarm might be set to ring on the day of the 
year when leaves start falling from the trees in a climate model.
</LI>
</UL>

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="691" HEIGHT="202" ALIGN="BOTTOM" BORDER="0"
 SRC="img195.png"
 ALT="\includegraphics{TimeMgr_desc}">

</DIV>

<P>
In the remainder of this section, we briefly summarize the 
functionality that the Time Manager classes provide.  Detailed 
descriptions and usage examples precede the API listing for each 
class.

<P>

<H2><A NAME="SECTION06032000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">2</SPAN> Calendar</A>
</H2>
An ESMF Calendar can be queried for seconds per day, days per month 
and days per year.  The flexible definition of Calendars allows them
to be defined for planetary bodies other than Earth.  The set of supported 
calendars includes:
<DL>
<DT><STRONG>Gregorian</STRONG></DT>
<DD>The standard Gregorian calendar.
</DD>
<DT><STRONG>no-leap</STRONG></DT>
<DD>The Gregorian calendar with no leap years.
</DD>
<DT><STRONG>Julian</STRONG></DT>
<DD>The standard Julian date calendar.
</DD>
<DT><STRONG>Julian Day</STRONG></DT>
<DD>The standard Julian days calendar.
</DD>
<DT><STRONG>Modified Julian Day</STRONG></DT>
<DD>The Modified Julian days calendar.
</DD>
<DT><STRONG>360-day</STRONG></DT>
<DD>A 30-day-per-month, 12-month-per-year calendar.
</DD>
<DT><STRONG>no calendar</STRONG></DT>
<DD>Tracks only elapsed model time in hours, minutes, seconds.
</DD>
</DL>
See Section&nbsp;<A HREF="#sec:Calendar">42.1</A> for more details on supported standard 
calendars, and how to create a customized ESMF Calendar.

<P>

<H2><A NAME="SECTION06033000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">3</SPAN> Time Instants and TimeIntervals</A>
</H2>

<P>
<A NAME="subsec:Time_Instants_and_TimeIntervals"></A>TimeIntervals and Time instants (simply called Times) are the computational 
building blocks of the Time Manager utility.  TimeIntervals support operations
such as add, subtract, compare size, reset value, copy value, and subdivide
by a scalar.  Times, which are moments in time associated with specific
Calendars, can be incremented or decremented by TimeIntervals, compared to
determine which of two Times is later, differenced to obtain the TimeInterval
between two Times, copied, reset, and manipulated in other useful ways.
Times support a host of different queries, both for values of individual Time 
components such as year, month, day, and second, and for derived values such 
as day of year, middle of current month and Julian day.  It is also possible 
to retrieve the value of the hardware realtime clock in the form of a 
Time.  See Sections&nbsp;<A HREF="#sec:Time">43.1</A> and&nbsp;<A HREF="#sec:TimeInterval">44.1</A>, respectively,
for use and examples of Times and TimeIntervals.

<P>
Since climate modeling, numerical weather prediction and other 
Earth and space applications have widely varying time scales and require 
different sorts of calendars, Times and TimeIntervals must support 
a wide range of time specifiers, spanning nanoseconds to years.  The
interfaces to these time classes are defined so that the user can specify a time
using a combination of units selected from the list shown in 
Table&nbsp;<A HREF="#table:timeOpts">41.4</A>.  

<P>

<H2><A NAME="SECTION06034000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">4</SPAN> Clocks and Alarms</A>
</H2>
Although it is possible to repeatedly step a Time forward by a 
TimeInterval using arithmetic on these basic types, it is useful to 
identify a higher-level concept to represent this function.  We refer to 
this capability as a Clock, and include in its required features the 
ability to store the start and stop times of 
a model run, to check when time advancement should cease, 
and to query the value of quantities such as the current time and the
time at the previous time step.  The Time Manager includes a class 
with methods that return a true value when a periodic or unique event 
has taken place; we refer to these as Alarms.  Applications may contain 
temporary or multiple Clocks and Alarms.  Sections&nbsp;<A HREF="#sec:Clock">45.1</A> and
<A HREF="#sec:Alarm">46.1</A> describe the use of Clocks and Alarms in detail.

<P>

<A NAME="table:timeOpts"></A>
<DIV ALIGN="CENTER">
</DIV>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="79612"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 4:</STRONG>
Specifiers for Times and TimeIntervals</CAPTION>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72>Unit</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Meaning</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;yy|yy_i8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Year.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>mm</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Month of the year.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>dd</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Day of the month.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;d|d_i8|d_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Julian or Modified Julian day.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;h|h_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Hour.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;m|m_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Minute.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;s|s_i8|s_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Second.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;ms|ms_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Millisecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;us|us_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Microsecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;ns|ns_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Nanosecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>O</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Time zone offset in integer number of hours and minutes.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;sN|sN_i8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Numerator for times of the form s <B><!-- MATH
 $+
\frac{{\rm sN}}{{\rm sD}}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img196.png"
 ALT="$+
\frac{{\rm sN}}{{\rm sD}}$"></SPAN></B>, where s is seconds and s, sN, and
sD are integers.  This format provides a mechanism for supporting
exact behavior.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;sD|sD_i8</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Denominator for times of the form s <B><!-- MATH
 $+
\frac{{\rm sN}}{{\rm sD}}$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="35" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img196.png"
 ALT="$+
\frac{{\rm sN}}{{\rm sD}}$"></SPAN></B>, where s is seconds and s, sN, and
sD are integers.</TD>
</TR>
</TABLE>
</DIV>
<BR>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION06035000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<OL>
<LI><B>Base TimeIntervals and Times on the same integer representation.</B> 
It is useful to allow both TimeIntervals and Times to 
inherit from a single class, BaseTime.  In C++, this can be
implemented by using inheritance.  In Fortran, it can be implemented
by having the derived types TimeIntervals and Times
contain a derived type BaseTime.  In both cases, the 
BaseTime class can be made private and invisible to the user.

<P>
The result of this strategy is that Time Intervals and 
Times gain a consistent core representation of time as well a set
of basic methods.

<P>
The BaseTime class can be designed with a minimum number of elements
to represent any required time.  The design is based on the idea used
in the real-time POSIX 1003.1b-1993 standard.  That is, to represent
time simply as a pair of integers: one for seconds (whole) and one for
nanoseconds (fractional).  These can then be converted at the interface
level to any desired format.

<P>
For ESMF, this idea can be modified and extended, in order to handle the
requirements for a large time range (&gt; 200,000 years) and to exactly
represent any rational fraction, not just nanoseconds.  To handle the
large time range, a 64-bit or greater integer is used for whole seconds.
Any rational fractional second is expressed using two additional integers:
a numerator and a denominator.  Both the whole seconds and fractional
numerator are signed to handle negative time intervals and instants.
For arithmetic consistency both must carry the same sign (both positive
or both negative), except, of course, for zero values.  The fractional
seconds element (numerator) is bounded with respect to whole seconds. 
If the absolute value of the
numerator becomes greater than or equal to the denominator, whole
seconds are incremented or decremented accordingly and the numerator is
reset to the remainder.  Conversions are performed upon demand by
interface methods within the TimeInterval and
Time classes.  This is done because different applications require different
representations of time intervals and time instances.  Floating point values as well as integers can be specified for the various time units in the interfaces, see Table&nbsp;<A HREF="#table:timeOpts">41.4</A>.  Floating point values are represented internally as integer-based rational fractions.

<P>
The BaseTime class defines increment and decrement methods for basic
TimeInterval calculations between Time instants.  It is done here rather
than in the Calendar class because it can be done with simple 
second-based arithmetic that is calendar independent.  

<P>
Comparison methods can also be defined in the BaseTime class.  These
perform equality/inequality, less than, and greater than comparisons
between any two TimeIntervals or Times.  These methods capture
the common comparison logic between TimeIntervals and Times and
hence are defined here for sharing.

<P>
</LI>
<LI><B>The Time class depends on a calendar.</B> The Time class contains 
an internal Calendar class.  
Upon demand by a user, the results of an increment or decrement operation are 
converted to user units, which may be calendar-dependent, via methods 
obtained from their internal Calendar.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION06036000000000000000">
<SPAN CLASS="arabic">41</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
Time Manager utility.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="687" HEIGHT="315" ALIGN="BOTTOM" BORDER="0"
 SRC="img197.png"
 ALT="\includegraphics{TimeMgr_obj}">   

</DIV>

<H1><A NAME="SECTION06040000000000000000">
<SPAN CLASS="arabic">42</SPAN> Calendar Class</A>
</H1>

<H2><A NAME="SECTION06041000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:Calendar"></A>The Calendar class represents the standard calendars used in 
geophysical modeling:  Gregorian, Julian, Julian Day, Modified Julian Day, 
no-leap, 360-day, and no-calendar.  It also supports a user-customized 
calendar.  Brief descriptions are provided for each calendar below.  For more 
information on standard calendars, see&nbsp;[<A
 HREF="node8.html#Seidelman">30</A>] and&nbsp;[<A
 HREF="node8.html#Meyer1">26</A>].

<H2><A NAME="SECTION06042000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>
<A NAME="subsec:Calendar_options"></A>
<P>

<H3><A NAME="SECTION06042100000000000000"></A>
<A NAME="const:calkindflag"></A>
<BR>
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_CALKIND
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Supported calendar kinds.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_CalKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_CALKIND_360DAY</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
In the 360-day calendar, there are 12 months, each of which has 30 days.  
Like the no-leap calendar, this is a simple approximation to the Gregorian
calendar sometimes used by modelers.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_CUSTOM</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
The user can set calendar parameters in the generic calendar.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_GREGORIAN</STRONG></DT>
<DD><I>Valid range: 3/1/4801 BC to 10/29/292,277,019,914 </I>
<BR>
The Gregorian calendar is the calendar currently in use 
throughout Western countries.  Named after Pope Gregory XIII, it is a minor 
correction to the older Julian calendar. In the Gregorian calendar every
fourth year is a leap year in which February has 29 and not 28 days;
however, years divisible by 100 are not leap years unless they are also 
divisible  by 400.  As in the Julian calendar, days begin at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_JULIAN</STRONG></DT>
<DD><I>Valid range: 3/1/4713 BC to 4/24/292,271,018,333 </I> 
<BR>
The Julian calendar was introduced by Julius Caesar in 46 B.C., and 
reached its final form in 4 A.D.  The Julian calendar differs from the 
Gregorian only in the determination of leap years, lacking the correction 
for years divisible by 100 and 400 in the Gregorian calendar.  In the Julian 
calendar, any year is a leap year if divisible by 4.  Days are considered to 
begin at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_JULIANDAY</STRONG></DT>
<DD><I>Valid range:  +/- 1x10<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img198.png"
 ALT="$^{14}$"></SPAN></I> 
<BR>
Julian days simply enumerate the days and fraction of a day which 
have elapsed since the start of the Julian era, defined as beginning at noon 
on Monday, 1st January of year 4713 B.C. in the Julian calendar.  Julian days, 
unlike the dates in the Julian and Gregorian calendars, begin at noon.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_MODJULIANDAY</STRONG></DT>
<DD><I>Valid range:  +/- 1x10<SPAN CLASS="MATH"><IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img198.png"
 ALT="$^{14}$"></SPAN></I>
<BR>
The Modified Julian Day (MJD) was introduced by space scientists in
 the late 1950's.  It is defined as an offset from the Julian Day (JD):

<P>
MJD = JD - 2400000.5

<P>
The half day is subtracted so that the day starts at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_NOCALENDAR</STRONG></DT>
<DD><I>Valid range: machine limits</I>
<BR>
The no-calendar option simply tracks the elapsed model time in seconds.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_NOLEAP</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
The no-leap calendar is the Gregorian calendar with no leap years - 
February is always assumed to have 28 days.  Modelers sometimes use this 
calendar as a simple, close approximation to the Gregorian calendar.

<P>
</DD>
</DL>

<H2><A NAME="SECTION06043000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
In most multi-component Earth system applications, the timekeeping in 
each component 
must refer to the same standard calendar in order for the components 
to properly synchronize.  It therefore makes sense to create as few 
ESMF Calendars as possible, preferably one per application.
A typical strategy would be to create a single Calendar at the start
of an application, and use that Calendar in all subsequent calls that
accept a Calendar, such as <TT>ESMF_TimeSet</TT>.

<P>
The following example shows how to set up an ESMF Calendar.  

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_CalendarEx - Calendar creation examples
!
! !DESCRIPTION:
!
! This program shows examples of how to create different calendar kinds
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate calendars
      type(ESMF_Calendar) :: gregorianCalendar
      type(ESMF_Calendar) :: julianDayCalendar
      type(ESMF_Calendar) :: marsCalendar

      ! local variables for Get methods
      integer :: sols
      integer(ESMF_KIND_I8) :: dl
      type(ESMF_Time) :: time, marsTime
      type(ESMF_TimeInterval) :: marsTimeStep

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultlogfilename="CalendarEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06043100000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Calendar creation</A>
</H3>

<P>
This example shows how to create three <TT>ESMF_Calendars</TT>.
<P>
<PRE>
      ! create a Gregorian calendar
      gregorianCalendar = ESMF_CalendarCreate(ESMF_CALKIND_GREGORIAN, &amp;
                                              name="Gregorian", rc=rc)
</PRE>

<P>
<PRE>
      ! create a Julian Day calendar
      julianDayCalendar = ESMF_CalendarCreate(ESMF_CALKIND_JULIANDAY, &amp;
                                              name="JulianDay", rc=rc)
</PRE>

<P>
<PRE>
      ! create a Custom calendar for the planet Mars
      ! 1 Mars solar day = 24 hours, 39 minutes, 35 seconds = 88775 seconds
      ! 1 Mars solar year = 668.5921 Mars solar days = 668 5921/10000 sols/year
      ! http://www.giss.nasa.gov/research/briefs/allison_02
      ! http://www.giss.nasa.gov/tools/mars24/help/notes.html
      marsCalendar = ESMF_CalendarCreate(secondsPerDay=88775, &amp;
                                         daysPerYear=668, &amp;
                                         daysPerYearDn=5921, &amp;
                                         daysPerYearDd=10000, &amp;
                                         name="MarsCalendar", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06043200000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Calendar comparison</A>
</H3>

<P>
This example shows how to compare an <TT>ESMF_Calendar</TT> with a known
   calendar kind.
<P>
<PRE>
      ! compare calendar kind against a known type
      if (gregorianCalendar == ESMF_CALKIND_GREGORIAN) then
        print *, "gregorianCalendar is of type ESMF_CALKIND_GREGORIAN."
      else
        print *, "gregorianCalendar is not of type ESMF_CALKIND_GREGORIAN."
      end if
</PRE>

<P>

<H3><A NAME="SECTION06043300000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Time conversion between Calendars</A>
</H3>

<P>
This example shows how to convert a time from one <TT>ESMF_Calendar</TT>
   to another.
<P>
<PRE>
      call ESMF_TimeSet(time, yy=2004, mm=4, dd=17, &amp;
                        calendar=gregorianCalendar, rc=rc)
</PRE>

<P>
<PRE>
      ! switch time's calendar to perform conversion
      call ESMF_TimeSet(time, calendar=julianDayCalendar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeGet(time, d_i8=dl, rc=rc)
      print *, "Gregorian date 2004/4/17 is ", dl, &amp;
               " days in the Julian Day calendar."
</PRE>

<P>

<H3><A NAME="SECTION06043400000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Add a time interval to a time on a Calendar</A>
</H3>

<P>
This example shows how to increment a time using a custom <TT>ESMF_Calendar</TT>.
<P>
<PRE>
      ! Set a time to Mars solar year 3, sol 100
      call ESMF_TimeSet(marsTime, yy=3, d=100, &amp;
                        calendar=marsCalendar, rc=rc)
</PRE>

<P>
<PRE>
      ! Set a 1 solar year time step
      call ESMF_TimeIntervalSet(marsTimeStep, yy=1, rc=rc)
</PRE>

<P>
<PRE>
      ! Perform the increment
      marsTime = marsTime + marsTimeStep
</PRE>

<P>
<PRE>
      ! Get the result in sols (2774 = (3+1)*668.5921 + 100)
      call ESMF_TimeGet(marsTime, d=sols, rc=rc)
      print *, "For Mars, 3 solar years, 100 sols + 1 solar year = ", &amp;
                sols, "sols."
</PRE>

<P>

<H3><A NAME="SECTION06043500000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Calendar destruction</A>
</H3>

<P>
This example shows how to destroy three <TT>ESMF_Calendars</TT>.
<P>
<PRE>
      call ESMF_CalendarDestroy(julianDayCalendar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CalendarDestroy(gregorianCalendar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CalendarDestroy(marsCalendar, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_CalendarEx
</PRE>

<P>


<H2><A NAME="SECTION06044000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>
<A NAME="subsec:Calendar_rest"></A>
<P>

<OL>
<LI><B>Months per year set to 12.</B> Due to the requirement of only Earth modeling, the number of months per year is hard-coded at 12.  However, for easy modification, this is implemented via a C preprocessor #define MONTHS_PER_YEAR in ESMCI_Calendar.h.

<P>
</LI>
<LI><B>Calendar date conversions.</B> Date conversions are currently defined between the Gregorian, Julian, Julian Day, and Modified Julian Day calendars. Further research and work would need to be done to determine conversion algorithms with and between the other calendars:  No Leap, 360 Day, and Custom.

<P>
</LI>
<LI><B>ESMF_CALKIND_CUSTOM.</B> Currently, there is no provision for a custom calendar to define a leap year rule, so <TT>ESMF_CalendarIsLeapYear()</TT> will always return <TT>.false.</TT> in this case.  However, the arguments <TT>daysPerYear</TT>, <TT>daysPerYearDn</TT>, and <TT>daysPerYearDd</TT> in <TT>ESMF_CalendarCreate()</TT> and <TT>ESMF_CalendarSet()</TT> can be used to set a fractional number of days per year, for example, 365.25 = 365 25/100.  Also, if further timekeeping precision is required, fractional and/or floating point <TT>secondsPerDay</TT> and <TT>secondsPerYear</TT> could be added to the interfaces <TT>ESMF_CalendarCreate()</TT>, <TT>ESMF_CalendarSet()</TT>, and <TT>ESMF_CalendarGet()</TT> and implemented.

<P>
</LI>
</OL>

<H2><A NAME="SECTION06045000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06045100000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_CalendarAssignment(=) - Assign a Calendar to another Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface assignment(=)
       calendar1 = calendar2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar) :: calendar1
       type(ESMF_Calendar) :: calendar2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign <TT>calendar1</TT> as an alias to the same <TT>ESMF_Calendar</TT> 
       object in memory as <TT>calendar2</TT>. If <TT>calendar2</TT> is invalid, then 
       <TT>calendar1</TT> will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar1</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object on the left hand side of the 
            assignment.
       
</DD>
<DT><STRONG>calendar2</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object on the right hand side of the 
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045200000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_CalendarOperator(==) - Test if Calendar argument 1 is equal to Calendar argument 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(==)
       if (&lt;calendar argument 1&gt; == &lt;calendar argument 2&gt;) then ... endif
                                   OR
       result = (&lt;calendar argument 1&gt; == &lt;calendar argument 2&gt;)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       &lt;calendar argument 1&gt;, see below for supported values
       &lt;calendar argument 2&gt;, see below for supported values
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Calendar</TT> class.
       Compare an <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> with
       another calendar object or calendar kind for equality.  Return
       <TT>.true.</TT> if equal, <TT>.false.</TT> otherwise.  Comparison is based on
       calendar kind, which is a property of a calendar object.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and both are of  
       type <TT>ESMF_CALKIND_CUSTOM</TT>, then all the calendar's properties, 
       except name, are compared.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and either of them
       is not in the <TT>ESMF_INIT_CREATED</TT> status, an error will be logged.
       However, this does not affect the return value, which is <TT>.true.</TT> 
       when both arguments are in the <EM>same</EM> status, and <TT>.false.</TT>
       otherwise.

<P>
If one argument is an <TT>ESMF_Calendar</TT> object, and the other is an
       <TT>ESMF_CalKind_Flag</TT>, and the calendar object is not in the
       <TT>ESMF_INIT_CREATED</TT> status, an error will be logged and
       <TT>.false.</TT> will be returned.

<P>
Supported values for &lt;calendar argument 1&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar1
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag1
       
</DD>
</DL>
       Supported values for &lt;calendar argument 2&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar2
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag2
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>&lt;calendar argument 1&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            left hand side of the equality operation.
       
</DD>
<DT><STRONG>&lt;calendar argument 2&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            right hand side of the equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045300000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_CalendarOperator(/=) - Test if Calendar argument 1 is not equal to Calendar argument 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/=)
       if (&lt;calendar argument 1&gt; /= &lt;calendar argument 2&gt;) then ... endif
                                   OR
       result = (&lt;calendar argument 1&gt; /= &lt;calendar argument 2&gt;)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       &lt;calendar argument 1&gt;, see below for supported values
       &lt;calendar argument 2&gt;, see below for supported values
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Calendar</TT> class.
       Compare a <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> with
       another calendar object or calendar kind for inequality.  Return
       <TT>.true.</TT> if not equal, <TT>.false.</TT> otherwise.  Comparison is based
       on calendar kind, which is a property of a calendar object.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and both are of  
       type <TT>ESMF_CALKIND_CUSTOM</TT>, then all the calendar's properties,
       except name, are compared.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and either of them
       is not in the <TT>ESMF_INIT_CREATED</TT> status, an error will be logged.
       However, this does not affect the return value, which is <TT>.true.</TT> 
       when both arguments are <EM>not</EM> in the <EM>same</EM> status, and
       <TT>.false.</TT> otherwise.

<P>
If one argument is an <TT>ESMF_Calendar</TT> object, and the other is an
       <TT>ESMF_CalKind_Flag</TT>, and the calendar object is not in the
       <TT>ESMF_INIT_CREATED</TT> status, an error will be logged and
       <TT>.true.</TT> will be returned.

<P>
Supported values for &lt;calendar argument 1&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar1
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag1
       
</DD>
</DL>
       Supported values for &lt;calendar argument 2&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar2
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag2
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>&lt;calendar argument 1&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            left hand side of the non-equality operation.
       
</DD>
<DT><STRONG>&lt;calendar argument 2&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            right hand side of the non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045400000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_CalendarCreate - Create a new ESMF Calendar of built-in type</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateBuiltIn(calkindflag, &amp;
         name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateBuiltIn
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates and sets a <TT>calendar</TT> to the given built-in
       <TT>ESMF_CalKind_Flag</TT>. 

<P>
The arguments are:
       <DL>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The built-in <TT>ESMF_CalKind_Flag</TT>.  Valid values are:
              <BR>
              <TT>ESMF_CALKIND_360DAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_GREGORIAN</TT>,
              <BR>
              <TT>ESMF_CALKIND_JULIAN</TT>, 
              <BR>
              <TT>ESMF_CALKIND_JULIANDAY</TT>,
              <BR>
              <TT>ESMF_CALKIND_MODJULIANDAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_NOCALENDAR</TT>,
              <BR>
and <TT>ESMF_CALKIND_NOLEAP</TT>.
              <BR>
See Section&nbsp;<A HREF="#subsec:Calendar_options">42.2</A> for a description of each
            calendar kind.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created calendar.  If not specified, a
            default unique name will be generated: "CalendarNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045500000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_CalendarCreate - Create a copy of an ESMF Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateCopy(calendar, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a complete (deep) copy of a given <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045600000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_CalendarCreate - Create a new custom ESMF Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateCustom(&amp;
         daysPerMonth, secondsPerDay, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateCustom
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,               intent(in),  optional :: daysPerMonth(:)
       integer(ESMF_KIND_I4), intent(in),  optional :: secondsPerDay
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYear
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYearDn
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYearDd
       character (len=*),     intent(in),  optional :: name
       integer,               intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a custom <TT>ESMF_Calendar</TT> and sets its properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
            The number of months per year is variable and taken from the
            size of the array.  If unspecified, months per year = 0,
            with the days array undefined.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.  Defaults to 0 if not 
            specified.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  Use with daysPerYearDn and
            daysPerYearDd (see below) to specify a days-per-year calendar
            for any planetary body.  Default = 0.
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer numerator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear (see above) and daysPerYearDd (see below) to
            specify a days-per-year calendar for any planetary body.
            Default = 0.

</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer denominator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear and daysPerYearDn (see above) to
            specify a days-per-year calendar for any planetary body.
            Default = 1.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created calendar.  If not specified, a
            default unique name will be generated: "CalendarNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045700000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_CalendarDestroy - Release resources associated with a Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarDestroy(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(inout)          :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Calendar</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045800000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_CalendarGet - Get Calendar properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarGet(calendar, &amp;
         name, calkindflag, daysPerMonth, monthsPerYear, &amp;
         secondsPerDay, secondsPerYear, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),    intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_CalKind_Flag),intent(out), optional :: calkindflag
       integer,                intent(out), optional :: daysPerMonth(:)
       integer,                intent(out), optional :: monthsPerYear
       integer(ESMF_KIND_I4),  intent(out), optional :: secondsPerDay
       integer(ESMF_KIND_I4),  intent(out), optional :: secondsPerYear
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYear
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYearDn
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYearDd
       character (len=*),      intent(out), optional :: name
       integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets one or more of an <TT>ESMF_Calendar</TT>'s properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>The <TT>CalKind_Flag</TT> ESMF_CALKIND_GREGORIAN, 
            ESMF_CALKIND_JULIAN, etc.
       
</DD>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
       
</DD>
<DT><STRONG>[monthsPerYear]</STRONG></DT>
<DD>Integer number of months per year; the size of the
            daysPerMonth array.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.
       
</DD>
<DT><STRONG>[secondsPerYear]</STRONG></DT>
<DD>Integer number of seconds per year.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  For calendars with
            intercalations, daysPerYear is the number of days for years without
            an intercalation.  For other calendars, it is the number of days in
            every year.
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer fractional number of days per year (numerator).
            For calendars with intercalations, daysPerYearDn/daysPerYearDd is
            the average fractional number of days per year (e.g. 25/100 for
            Julian 4-year intercalation).  For other calendars, it is zero.

</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer fractional number of days per year (denominator).  See
            daysPerYearDn above.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045900000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_CalendarIsCreated - Check whether a Calendar object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_CalendarIsCreated(calendar, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_CalendarIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Calendar), intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>calendar</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451000000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_CalendarIsLeapYear - Determine if given year is a leap year</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarIsLeapYear()
       function ESMF_CalendarIsLeapYear&lt;kind&gt;(calendar, yy, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_CalendarIsLeapYear&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),       intent(in)            :: calendar
       integer(ESMF_KIND_&lt;kind&gt;), intent(in)            :: yy
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the given year is a leap year within the given
       calendar, and <TT>.false.</TT> otherwise.  Custom calendars do not define
       leap years, so <TT>.false.</TT> will always be returned in this case;
       see Section&nbsp;<A HREF="#subsec:Calendar_rest">42.4</A>.
       See also <TT>ESMF_TimeIsLeapYear()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to determine leap year within.
       
</DD>
<DT><STRONG>yy</STRONG></DT>
<DD>Year to check for leap year.  The type is integer and the &lt;kind&gt; can
            be either I4 or I8:  <TT>ESMF_KIND_I4</TT> or <TT>ESMF_KIND_I8</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451100000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_CalendarPrint - Print Calendar information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarPrint(calendar, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
       character (len=*),   intent(in),  optional :: options
       integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Calendar</TT>'s properties to <TT>stdio</TT>, 
       in support of testing and debugging.  The options control the 
       type of information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all calendar property
                               values. 
<BR>            "calkindflag"    - print the calendar's type 
                                 (e.g. ESMF_CALKIND_GREGORIAN). 
<BR>            "daysPerMonth"   - print the array of number of days for
                                 each month. 
<BR>            "daysPerYear"    - print the number of days per year
                               (integer and fractional parts). 
<BR>            "monthsPerYear"  - print the number of months per year. 
<BR>            "name"           - print the calendar's name. 
<BR>            "secondsPerDay"  - print the number of seconds in a day. 
<BR>            "secondsPerYear" - print the number of seconds in a year. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451200000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_CalendarSet - Set a Calendar to a built-in type</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSet()
       subroutine ESMF_CalendarSetBuiltIn(calendar, calkindflag, &amp;
         name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),     intent(inout)         :: calendar
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets <TT>calendar</TT> to the given built-in <TT>ESMF_CalKind_Flag</TT>. 

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The built-in <TT>CalKind_Flag</TT>.  Valid values are:
              <BR>
              <TT>ESMF_CALKIND_360DAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_GREGORIAN</TT>,
              <BR>
              <TT>ESMF_CALKIND_JULIAN</TT>, 
              <BR>
              <TT>ESMF_CALKIND_JULIANDAY</TT>,
              <BR>
              <TT>ESMF_CALKIND_MODJULIANDAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_NOCALENDAR</TT>,
              <BR>
and <TT>ESMF_CALKIND_NOLEAP</TT>.
              <BR>
See Section&nbsp;<A HREF="#subsec:Calendar_options">42.2</A> for a description of each
            calendar kind.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451300000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_CalendarSet - Set properties of a custom Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSet()
       subroutine ESMF_CalendarSetCustom(calendar, &amp;
         daysPerMonth, secondsPerDay, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),  intent(inout)         :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,              intent(in),  optional :: daysPerMonth(:)
       integer(ESMF_KIND_I4),intent(in),  optional :: secondsPerDay
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYear
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYearDn
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYearDd
       character (len=*),    intent(in),  optional :: name
       integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets properties in a custom <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
            The number of months per year is variable and taken from the
            size of the array.  If unspecified, months per year = 0,
            with the days array undefined.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.  Defaults to 0 if not 
            specified.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  Use with daysPerYearDn and
            daysPerYearDd (see below) to specify a days-per-year calendar
            for any planetary body.  Default = 0.
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer numerator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear (see above) and daysPerYearDd (see below) to
            specify a days-per-year calendar for any planetary body.
            Default = 0.
       
</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer denominator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear and daysPerYearDn (see above) to
            specify a days-per-year calendar for any planetary body.
            Default = 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451400000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_CalendarSetDefault - Set the default Calendar kind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSetDefault()
       subroutine ESMF_CalendarSetDefaultKind(calkindflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the default <TT>calendar</TT> to the given type.  Subsequent Time
       Manager operations requiring a calendar where one isn't specified will
       use the internal calendar of this type.

<P>
The arguments are:
       <DL>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The calendar kind to be the default.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451500000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_CalendarSetDefault - Set the default Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSetDefault()
       subroutine ESMF_CalendarSetDefaultCal(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),     intent(in)            :: calendar
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the default <TT>calendar</TT> to the one given.  Subsequent Time
       Manager operations requiring a calendar where one isn't specified will
       use this calendar.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to be the default.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451600000000000000">
<SPAN CLASS="arabic">42</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_CalendarValidate - Validate a Calendar's properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarValidate(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>calendar</TT> is valid.  
       Must be one of the defined calendar kinds.  daysPerMonth, daysPerYear,
       secondsPerDay must all be greater than or equal to zero.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION06050000000000000000">
<SPAN CLASS="arabic">43</SPAN> Time Class</A>
</H1>

<H2><A NAME="SECTION06051000000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>
<A NAME="sec:Time"></A>
<P>
A Time represents a specific point in time.  In order to accommodate
the range of time scales in Earth system applications, Times in
the ESMF can be specified in many different ways, from years to
nanoseconds.  The Time interface is designed so that you select one or 
more options from a list of time units in order to specify a 
Time. The options for specifying a Time are shown in 
Table&nbsp;<A HREF="#table:timeOpts">41.4</A>.  

<P>
There are Time methods defined for setting and getting a
Time, incrementing and decrementing a Time by a TimeInterval,
taking the difference between two Times, and comparing Times.
Special quantities such as the middle of the month and the 
day of the year associated with a particular Time can be retrieved. 
There is a method for returning the Time value as a string in 
the ISO 8601 format YYYY-MM-DDThh:mm:ss [<A
 HREF="node8.html#ISO">24</A>].

<P>
A Time that is specified in hours, minutes, seconds, or subsecond intervals 
does not need to be associated with a standard calendar; a Time whose
specification includes time units of a day and greater must be.  The 
ESMF representation
of a calendar, the Calendar class, is described in Section&nbsp;<A HREF="#sec:Calendar">42.1</A>.
The <TT>ESMF_TimeSet</TT> method is used to initialize a Time as well as
associate it with a Calendar.  If a Time method is invoked in which a Calendar
is necessary and one has not been set, the ESMF method will return an error
condition.

<P>
In the ESMF the TimeInterval class is used to represent time periods.
This class is frequently used in combination with the Time class.
The Clock class, for example, advances model time by incrementing a
Time with a TimeInterval. 

<P>

<H2><A NAME="SECTION06052000000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
Times are most frequently used to represent start, stop, and current 
model times.  The following examples show how to create, initialize, and
manipulate <TT>Time</TT>.

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_TimeEx - Time initialization and manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of Time initialization and manipulation
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate two times
      type(ESMF_Time) :: time1, time2

      type(ESMF_VM) :: vm

      ! instantiate a time interval
      type(ESMF_TimeInterval) :: timeinterval1

      ! local variables for Get methods
      integer :: YY, MM, DD, H, M, S

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(vm=vm, defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="TimeEx.Log", &amp;
        logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06052100000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Time initialization</A>
</H3>

<P>
This example shows how to initialize an <TT>ESMF_Time</TT>.
<P>
<PRE>
      ! initialize time1 to 2/28/2000 2:24:45
      call ESMF_TimeSet(time1, yy=2000, mm=2, dd=28, h=2, m=24, s=45, rc=rc)
</PRE>

<P>
<PRE>
      print *, "Time1 = "
      call ESMF_TimePrint(time1, options="string", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06052200000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Time increment</A>
</H3>

<P>
This example shows how to increment an <TT>ESMF_Time</TT> by
   an <TT>ESMF_TimeInterval</TT>.
<P>
<PRE>
      ! initialize a time interval to 2 days, 8 hours, 36 minutes, 15 seconds
      call ESMF_TimeIntervalSet(timeinterval1, d=2, h=8, m=36, s=15, rc=rc)
</PRE>

<P>
<PRE>
      print *, "Timeinterval1 = "
      call ESMF_TimeIntervalPrint(timeinterval1, options="string", rc=rc)
</PRE>

<P>
<PRE>
      ! increment time1 with timeinterval1
      time2 = time1 + timeinterval1

      call ESMF_TimeGet(time2, yy=YY, mm=MM, dd=DD, h=H, m=M, s=S, rc=rc)
      print *, "time2 = time1 + timeinterval1 = ", YY, "/", MM, "/", DD, &amp;
               " ",  H, ":", M, ":", S
</PRE>

<P>

<H3><A NAME="SECTION06052300000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Time comparison</A>
</H3>

<P>
This example shows how to compare two <TT>ESMF_Times</TT>.
<P>
<PRE>
      if (time2 &gt; time1) then
        print *, "time2 is larger than time1"
      else
        print *, "time1 is smaller than or equal to time2"
      endif
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_TimeEx
</PRE>

<P>


<H2><A NAME="SECTION06053000000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limits on size and resolution of Time.</B>  The limits on the size and 
resolution of the time representation are based on the
64-bit integer types used.  For seconds, a signed 64-bit integer
will have a range of +/- <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img199.png"
 ALT="$2^{63}$"></SPAN>-1, or +/- 9,223,372,036,854,775,807.  This
corresponds to a maximum size of +/- (<SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img199.png"
 ALT="$2^{63}$"></SPAN>-1)/(86400 * 365.25) or
+/- 292,271,023,045 years.

<P>
For fractional seconds, a signed 64-bit integer will handle a resolution of
+/- <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img200.png"
 ALT="$2^{31}$"></SPAN>-1, or +/- 9,223,372,036,854,775,807 parts of a second.

<P>
</LI>
</OL>

<H2><A NAME="SECTION06054000000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06054100000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_TimeAssignment(=) - Assign a Time to another Time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface assignment(=)
       time1 = time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time) :: time1
       type(ESMF_Time) :: time2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set <TT>time1</TT> equal to <TT>time2</TT>.  This is the default Fortran
       assignment, which creates a complete, independent copy of <TT>time2</TT> 
       as <TT>time1</TT>.  If <TT>time2</TT> is an invalid <TT>ESMF_Time</TT> object then
       <TT>time1</TT> will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be set.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be copied.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054200000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_TimeOperator(+) - Increment a Time by a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(+)
       time2 = time1 + timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Time) :: time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (+) operator for the <TT>ESMF_Time</TT> class to increment
       <TT>time1</TT> with <TT>timeinterval</TT> and return the result as an
       <TT>ESMF_Time</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to increment.
       
</DD>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to add to the given <TT>ESMF_Time</TT>.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054300000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_TimeOperator(-) - Decrement a Time by a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(-)
       time2 = time1 - timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Time) :: time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_Time</TT> class to decrement
       <TT>time1</TT> with <TT>timeinterval</TT>, and return the result as an
       <TT>ESMF_Time</TT>.

<P>
The arguments are:      
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to decrement.
       
</DD>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to subtract from the given
            <TT>ESMF_Time</TT>.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054400000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_TimeOperator(-) - Return the difference between two Times</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(-)
       timeinterval = time1 - time2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: timeinterval
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_Time),         intent(in) :: time2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_Time</TT> class to return the
       difference between <TT>time1</TT> and <TT>time2</TT> as an
       <TT>ESMF_TimeInterval</TT>.  It is assumed that <TT>time1</TT> is later than
       <TT>time2</TT>; if not, the resulting <TT>ESMF_TimeInterval</TT> will have a
       negative value.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The first <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054500000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_TimeOperator(==) - Test if Time 1 is equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(==)
       if (time1 == time2) then ... endif
                    OR
       result = (time1 == time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> and <TT>time2</TT> represent the same instant 
       in time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054600000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_TimeOperator(/=) - Test if Time 1 is not equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/=)
       if (time1 /= time2) then ... endif
                    OR
       result = (time1 /= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> and <TT>time2</TT> do not represent the same 
       instant in time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054700000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_TimeOperator(&lt;) - Test if Time 1 is less than Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(&lt;)
       if (time1 &lt; time2) then ... endif
                    OR
       result = (time1 &lt; time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is earlier in time than <TT>time2</TT>, and 
       <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054800000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_TimeOperator(&lt;=) - Test if Time 1 is less than or equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(&lt;=)
       if (time1 &lt;= time2) then ... endif
                    OR
       result = (time1 &lt;= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is earlier in time or the same time as 
       <TT>time2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054900000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_TimeOperator(&gt;) - Test if Time 1 is greater than Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(&gt;)
       if (time1 &gt; time2) then ... endif
                    OR
       result = (time1 &gt; time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is later in time than <TT>time2</TT>, and 
       <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541000000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_TimeOperator(&gt;=) - Test if Time 1 is greater than or equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(&gt;=)
       if (time1 &gt;= time2) then ... endif
                    OR
       result = (time1 &gt;= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is later in time or the same time as 
       <TT>time2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541100000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_TimeGet - Get a Time value </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_TimeGet(time, &amp;
         yy, yy_i8, &amp;
         mm, dd, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         calendar, calkindflag, timeZone, &amp;
         timeString, timeStringISOFrac, &amp;
         dayOfWeek, midMonth, &amp;
         dayOfYear,  dayOfYear_r8, &amp;
         dayOfYear_intvl, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in)            :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer,                 intent(out), optional :: mm
       integer,                 intent(out), optional :: dd
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       integer,                 intent(out), optional :: timeZone ! not imp
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: dayOfWeek
       type(ESMF_Time),         intent(out), optional :: midMonth
       integer(ESMF_KIND_I4),   intent(out), optional :: dayOfYear
       real(ESMF_KIND_R8),      intent(out), optional :: dayOfYear_r8
       type(ESMF_TimeInterval), intent(out), optional :: dayOfYear_intvl
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>time</TT> in units specified by the user
       via Fortran optional arguments.  See <TT>ESMF_TimeSet()</TT> above for a
       description of time units and calendars.

<P>
The ESMF Time Manager represents and manipulates time internally with 
       integers to maintain precision.  Hence, user-specified floating point 
       values are converted internally from integers.  For example, if a time
       value is 5 and 3/8 seconds (s=5, sN=3, sD=8), and you want to get it as
       floating point seconds, you would get 5.375 (s_r8=5.375).

<P>
Units are bound (normalized) by the next larger unit specified.  For
       example, if a time is defined to be 2:00 am on February 2, 2004, then
       <TT>ESMF_TimeGet(dd=day, h=hours, s=seconds)</TT> would return
         <TT>day = 2</TT>, <TT>hours = 2</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeGet(dd = day, s=seconds)</TT> would return
         <TT>day = 2</TT>, <TT>seconds = 7200</TT>.
       Note that <TT>hours</TT> and <TT>seconds</TT> are bound by a day.  If bound
       by a month,
       <TT>ESMF_TimeGet(mm=month, h=hours, s=seconds)</TT> would return
         <TT>month = 2</TT>, <TT>hours = 26</TT>, <TT>seconds = 0</TT>,
       and <TT>ESMF_TimeGet(mm = month, s=seconds)</TT> would return
         <TT>month = 2</TT>, <TT>seconds = 93600</TT> (26 * 3600).
       Similarly, if bound to a year,
       <TT>ESMF_TimeGet(yy=year, h=hours, s=seconds)</TT> would return
         <TT>year = 2004</TT>, <TT>hours = 770</TT> (32*24 + 2), <TT>seconds = 0</TT>,
       and <TT>ESMF_TimeGet(yy = year, s=seconds)</TT> would return
         <TT>year = 2004</TT>, <TT>seconds = 2772000</TT> (770 * 3600).

<P>
For <TT>timeString</TT>, <TT>timeStringISOFrac</TT>, <TT>dayOfWeek</TT>,
       <TT>midMonth</TT>, <TT>dayOfYear</TT>, <TT>dayOfYear_intvl</TT>, and
       <TT>dayOfYear_r8</TT> described below, valid calendars are Gregorian,
       Julian, No Leap, 360 Day and Custom calendars.  Not valid for
       Julian Day, Modified Julian Day, or No Calendar. 
<BR>
<P>
For <TT>timeString</TT> and <TT>timeStringISOFrac</TT>, YYYY format returns
       at least 4 digits; years &lt;= 999 are padded on the left with zeroes and
       years &gt;= 10000 return the number of digits required.

<P>
For timeString, convert <TT>ESMF_Time</TT>'s value into partial ISO 8601
       format YYYY-MM-DDThh:mm:ss[:n/d].  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].
       See also method <TT>ESMF_TimePrint()</TT>.

<P>
For timeStringISOFrac, convert <TT>ESMF_Time</TT>'s value into full ISO 8601
       format YYYY-MM-DDThh:mm:ss[.f].  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].
       See also method <TT>ESMF_TimePrint()</TT>.

<P>
For dayOfWeek, gets the day of the week the given <TT>ESMF_Time</TT>
       instant falls on.  ISO 8601 standard:  Monday = 1 through Sunday = 7.
       See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].

<P>
For midMonth, gets the middle time instant of the month that the given
       <TT>ESMF_Time</TT> instant falls on.

<P>
For dayOfYear, gets the day of the year that the given <TT>ESMF_Time</TT>
       instant falls on.  See range discussion in argument list below.
       Return as an integer value.

<P>
For dayOfYear_r8, gets the day of the year the given <TT>ESMF_Time</TT>
       instant falls on.  See range discussion in argument list below.
       Return as floating point value; fractional part represents the time of
       day.

<P>
For dayOfYear_intvl, gets the day of the year the given <TT>ESMF_Time</TT>
       instant falls on.  Return as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month.
       
</DD>
<DT><STRONG>[dd]</STRONG></DT>
<DD>Integer day of the month.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian date, or Modified Julian date (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian date, or Modified Julian date (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, &lt;= 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, &lt;= 64-bit).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>Associated timezone (hours offset from UCT, e.g. EST = -5).
            (Not implemented yet).
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time value to format string YYYY-MM-DDThh:mm:ss[:n/d],
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimePrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time value to strict ISO 8601 format string
            YYYY-MM-DDThh:mm:ss[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method
            <TT>ESMF_TimePrint()</TT>.
       
</DD>
<DT><STRONG>[dayOfWeek]</STRONG></DT>
<DD>The time instant's day of the week [1-7].
       
</DD>
<DT><STRONG>[MidMonth]</STRONG></DT>
<DD>The given time instant's middle-of-the-month time instant.
       
</DD>
<DT><STRONG>[dayOfYear]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's integer day of the year.
            [1-366] for Gregorian and Julian calendars, [1-365] for No-Leap
            calendar.  [1-360] for 360-Day calendar.  User-defined range
            for Custom calendar.
       
</DD>
<DT><STRONG>[dayOfYear_r8]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's floating point day of the year.
            [1.x-366.x] for Gregorian and Julian calendars, [1.x-365.x] for
            No-Leap calendar.  [1.x-360.x] for 360-Day calendar.  User-defined
            range for Custom calendar.
       
</DD>
<DT><STRONG>[dayOfYear_intvl]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's day of the year as an
            <TT>ESMF_TimeInterval</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541200000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_TimeIsLeapYear - Determine if a Time is in a leap year</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_TimeIsLeapYear(time, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_TimeIsLeapYear
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in)            :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,         intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if given time is in a leap year, and <TT>.false.</TT>
       otherwise.  See also <TT>ESMF_CalendarIsLeapYear()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to check for leap year.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541300000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_TimeIsSameCalendar - Compare Calendars of two Times</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_TimeIsSameCalendar(time1, time2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_TimeIsSameCalendar
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in)            :: time1
       type(ESMF_Time), intent(in)            :: time2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,         intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the Calendars in these Times are
       the same, <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The first <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The second <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541400000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_TimePrint - Print Time information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_TimePrint(time, options, preString, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),   intent(in)            :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in),  optional :: options
       character(*),      intent(in),  optional :: preString
       character(*),      intent(out), optional :: unit
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints out the contents of an <TT>ESMF_Time</TT> to <TT>stdout</TT>, in
       support of testing and debugging.  The options control the type of
       information and level of detail.  For options "string" and "string
       isofrac", YYYY format returns at least 4 digits; years &lt;= 999 are
       padded on the left with zeroes and years &gt;= 10000 return the number
       of digits required. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all Time property values. 
<BR>            "string" - prints <TT>time</TT>'s value in ISO 8601 format for all units
                       through seconds.  For any non-zero fractional seconds,
                       prints in integer rational fraction form n/d.  Format is
                       YYYY-MM-DDThh:mm:ss[:n/d], where [:n/d] is the 
                       integer numerator and denominator of the fractional
                       seconds value, if present.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method
                       <TT>ESMF_TimeGet(..., timeString= , ...)</TT> 
<BR>            "string isofrac" - prints <TT>time</TT>'s value in strict ISO 8601
                       format for all units, including any fractional seconds
                       part.  Format is YYYY-MM-DDThh:mm:ss[.f] where [.f]
                       represents fractional seconds in decimal form, if present.
                       See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method
                       <TT>ESMF_TimeGet(..., timeStringISOFrac= , ...)</TT> 
<BR>       
</DD>
<DT><STRONG>[preString]</STRONG></DT>
<DD>Optionally prepended string. Default to empty string.
       
</DD>
<DT><STRONG>[unit]</STRONG></DT>
<DD>Internal unit, i.e. a string. Default to printing to stdout.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541500000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_TimeSet - Initialize or set a Time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_TimeSet()
       subroutine ESMF_TimeSetDefault(time, &amp;
         yy, yy_i8, &amp;
         mm, dd, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         calendar, calkindflag, &amp;
         timeZone, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(inout)         :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer,                 intent(in),  optional :: mm
       integer,                 intent(in),  optional :: dd
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       type(ESMF_Calendar),     intent(in),  optional :: calendar
       type(ESMF_CalKind_Flag), intent(in),  optional :: calkindflag
       integer,                 intent(in),  optional :: timeZone ! not imp
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Initializes an <TT>ESMF_Time</TT> with a set of user-specified units
       via Fortran optional arguments.

<P>
The range of valid values for mm and dd depend on the calendar used.
       For Gregorian, Julian, and No-Leap calendars, mm is [1-12] and dd is
       [1-28,29,30, or 31], depending on the value of mm and whether yy or
       yy_i8 is a leap year.  For the 360-day calendar, mm is [1-12] and dd is
       [1-30].  For Julian Day, Modified Julian Day, and No-Calendar,
       yy, yy_i8, mm, and dd are invalid inputs, since these calendars do not
       define them.  When valid, the yy and yy_i8 arguments should be fully
       specified, e.g. 2003 instead of 03.  yy and yy_i8 ranges are only
       limited by machine word size, except for the Gregorian and Julian
       calendars, where the lowest (proleptic) date limits are 3/1/-4800 and
       3/1/-4712, respectively.  This is a limitation of the Gregorian
       date-to-Julian day and Julian date-to-Julian day conversion algorithms
       used to convert Gregorian and Julian dates to the internal representation
       of seconds.  See&nbsp;[<A
 HREF="node8.html#Fli68">21</A>] for a description of the Gregorian
       date-to-Julian day algorithm and&nbsp;[<A
 HREF="node8.html#Hat84">23</A>] for a description of the
       Julian date-to-Julian day algorithm.  The Custom calendar will have
       user-defined values for yy, yy_i8, mm, and dd.

<P>
The Julian day specifier, d or d_i8, can only be used with the
       Julian Day and Modified Julian Day calendars, and has a valid range
       depending on the word size.  For a signed 32-bit d, the range for
       Julian day is [+/- 24855].  For a signed 64-bit d_i8, the valid
       range for Julian day is [+/- 106,751,991,167,300].  The Julian day
       number system adheres to the conventional standard where the reference
       day of d=0 corresponds to 11/24/-4713 in the proleptic Gregorian calendar
       and 1/1/-4712 in the proleptic Julian calendar.  See&nbsp;[<A
 HREF="node8.html#Meyer2">27</A>] and
&nbsp;[<A
 HREF="node8.html#JDNcalculator">12</A>].

<P>
The Modified Julian Day system, introduced by space scientists in the late
       1950's, is defined as Julian Day - 2400000.5.  See&nbsp;[<A
 HREF="node8.html#MJD">31</A>].

<P>
Note that d and d_i8 are not valid for the No-Calendar.  To remain
       consistent with non-Earth calendars added to ESMF in the future, ESMF
       requires a calendar to be planet-specific.  Hence the No-Calendar does
       not know what a day is; it cannot assume an Earth day of 86400 seconds.

<P>
Hours, minutes, seconds, and sub-seconds can be used with any calendar,
       since they are standardized units that are the same for any planet.

<P>
Time manager represents and manipulates time internally with integers
       to maintain precision. Hence, user-specified floating point values are
       converted internally to integers.  Sub-second values are represented
       internally with an integer numerator and denominator fraction (sN/sD).
       The smallest required resolution is nanoseconds (denominator).
       For example, pi can be represented as s=3,
       sN=141592654, sD=1000000000.  However, via sN_i8 and sD_i8, larger
       values can be used.  If specifying a constant floating point value, be
       sure to provide at least 16 digits to take full advantage of double
       precision, for example s_r8=2.718281828459045d0 for 'e' seconds.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month.  Default = 1.
       
</DD>
<DT><STRONG>[dd]</STRONG></DT>
<DD>Integer day of the month.  Default = 1.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian Day, or Modified Julian Day (32-bit).  Must not be
            specified with Gregorian calendars.  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian Day, or Modified Julian Day (large, 64-bit).  Must not be
            specified with Gregorian calendars.  Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>.  Defaults to calendar
            <TT>ESMF_CALKIND_NOCALENDAR</TT> or default specified in
            <TT>ESMF_Initialize()</TT> or <TT>ESMF_CalendarSetDefault()</TT>.
            Alternate to, and mutually exclusive with, calkindflag
            below.  Primarily for specifying a custom calendar kind.

</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Alternate to, and mutually exclusive with, calendar above.  More
            convenient way of specifying a built-in calendar kind.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>Associated timezone (hours offset from UTC, e.g. EST = -5).
            Default = 0 (UTC).  (Not implemented yet).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541600000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_TimeSet - Initialize or set a Time from ISO format string</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_TimeSet()
       subroutine ESMF_TimeSetString(time, timeString, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(inout)         :: time
       character(*),            intent(in)            :: timeString
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Initializes an <TT>ESMF_Time</TT> with a set of user-specified string.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>timeString</STRONG></DT>
<DD>ISO format time string. E.g. 2012-10-24T18:00:00.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541700000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_TimeSyncToRealTime - Get system real time (wall clock time)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_TimeSyncToRealTime(time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(inout) :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the system real time (wall clock time), and returns it as an
       <TT>ESMF_Time</TT>.  Accurate to the nearest second.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to receive the real time.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541800000000000000">
<SPAN CLASS="arabic">43</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_TimeValidate - Validate a Time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_TimeValidate(time, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),   intent(in)            :: time
       character (len=*), intent(in),  optional :: options
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Checks whether an <TT>ESMF_Time</TT> is valid.
       Must be a valid date/time on a valid calendar.
       The options control the type of validation.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD><TT>ESMF_Time</TT> instant to be validated.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options. If none specified, validates all <TT>time</TT> property
              values. 
<BR>            "calendar" - validate only the <TT>time</TT>'s calendar. 
<BR>            "timezone" - validate only the <TT>time</TT>'s timezone. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION06060000000000000000">
<SPAN CLASS="arabic">44</SPAN> TimeInterval Class</A>
</H1>

<H2><A NAME="SECTION06061000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>
<A NAME="sec:TimeInterval"></A>A TimeInterval represents a period between time instants.  
It can be either positive or negative.  Like the Time interface, 
the TimeInterval interface is designed so that you can choose 
one or more options from a list of time units in order 
to specify a TimeInterval.
See Section&nbsp;<A HREF="#subsec:Time_Instants_and_TimeIntervals">41.3</A>, 
Table&nbsp;<A HREF="#table:timeOpts">41.4</A> for the available options.

<P>
There are TimeInterval methods defined for setting and getting 
a TimeInterval, for incrementing and decrementing a TimeInterval 
by another TimeInterval, and for multiplying and dividing 
TimeIntervals by integers, reals, fractions and other TimeIntervals.  
Methods are also defined to take the absolute value and negative 
absolute value of a TimeInterval, and for comparing the length of two
TimeIntervals.

<P>
The class used to represent time instants in ESMF is Time,
and this class is frequently used in operations along with 
TimeIntervals.  For example, the difference between two
Times is a TimeInterval.  

<P>
When a TimeInterval is used in calculations that involve an absolute 
reference time, such as incrementing a Time with a TimeInterval, calendar 
dependencies may be introduced.  The length of the time period that the 
TimeInterval represents will depend on the reference Time and the 
standard calendar that is associated with it.  The calendar dependency becomes 
apparent when, for example, adding a TimeInterval of 1 day to the Time 
of February 28, 1996, at 4:00pm EST.  In a 360 day calendar, the 
resulting date would be February 29, 1996, at 4:00pm EST.  In a no-leap 
calendar, the result would be March 1, 1996, at 4:00pm EST.

<P>
TimeIntervals are used by other parts of the ESMF timekeeping
system, such as Clocks (Section&nbsp;<A HREF="#sec:Clock">45.1</A>) and Alarms 
(Section&nbsp;<A HREF="#sec:Alarm">46.1</A>).

<P>

<H2><A NAME="SECTION06062000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>
A typical use for a TimeInterval in a geophysical model 
is representation of the time step by which the model is 
advanced.  Some models change the size of their time step as 
the model run progresses; this could
be done by incrementing or decrementing the original time 
step by another TimeInterval, or by dividing or multiplying
the time step by an integer value.  An example of advancing 
model time using a TimeInterval representation of a time
step is shown in Section&nbsp;<A HREF="#sec:Clock">45.1</A>.

<P>
The following brief example shows how to create, initialize 
and manipulate <TT>TimeInterval</TT>.

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_TimeIntervalEx - Time Interval initialization and 
!                                 manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of Time Interval initialization and manipulation
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate some time intervals
      type(ESMF_TimeInterval) :: timeinterval1, timeinterval2, timeinterval3

      ! local variables
      integer :: d, h, m, s

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="TimeIntervalEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06062100000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> TimeInterval initialization</A>
</H3>

<P>
This example shows how to initialize two <TT>ESMF_TimeIntervals</TT>.
<P>
<PRE>
      ! initialize time interval1 to 1 day
      call ESMF_TimeIntervalSet(timeinterval1, d=1, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalPrint(timeinterval1, options="string", rc=rc)
</PRE>

<P>
<PRE>
      ! initialize time interval2 to 4 days, 1 hour, 30 minutes, 10 seconds
      call ESMF_TimeIntervalSet(timeinterval2, d=4, h=1, m=30, s=10, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalPrint(timeinterval2, options="string", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06062200000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> TimeInterval conversion</A>
</H3>

<P>
This example shows how to convert <TT>ESMF_TimeIntervals</TT> into 
   different units.
<P>
<PRE>
      call ESMF_TimeIntervalGet(timeinterval1, s=s, rc=rc)
      print *, "Time Interval1 = ", s, " seconds."
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalGet(timeinterval2, h=h, m=m, s=s, rc=rc)
      print *, "Time Interval2 = ", h, " hours, ", m, " minutes, ", &amp;
                                    s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062300000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> TimeInterval difference</A>
</H3>

<P>
This example shows how to calculate the difference between two 
   <TT>ESMF_TimeIntervals</TT>. 
<P>
<PRE>
      ! difference between two time intervals
      timeinterval3 = timeinterval2 - timeinterval1
     call ESMF_TimeIntervalGet(timeinterval3, d=d, h=h, m=m, s=s, rc=rc)
     print *, "Difference between TimeInterval2 and TimeInterval1 = ", &amp;
           d, " days, ", h, " hours, ", m, " minutes, ", s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062400000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> TimeInterval multiplication</A>
</H3>

<P>
This example shows how to multiply an <TT>ESMF_TimeInterval</TT>. 
<P>
<PRE>
      ! multiply time interval by an integer
      timeinterval3 = timeinterval2 * 3
      call ESMF_TimeIntervalGet(timeinterval3, d=d, h=h, m=m, s=s, rc=rc)
      print *, "TimeInterval2 multiplied by 3 = ", d, " days, ", h, &amp;
               " hours, ", m, " minutes, ", s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062500000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> TimeInterval comparison</A>
</H3>

<P>
This example shows how to compare two <TT>ESMF_TimeIntervals</TT>. 
<P>
<PRE>
      ! comparison
      if (timeinterval1 &lt; timeinterval2) then
        print *, "TimeInterval1 is smaller than TimeInterval2"
      else 
        print *, "TimeInterval1 is larger than or equal to TimeInterval2"
      end if
</PRE>

<P>
<PRE>
      end program ESMF_TimeIntervalEx
</PRE>

<P>


<H2><A NAME="SECTION06063000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limits on time span.</B> The limits on the time span that can be
represented are based on the 64-bit integer types used.  For
seconds, a signed 64-bit integer will have a range of +/- <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img199.png"
 ALT="$2^{63}$"></SPAN>-1, or
+/- 9,223,372,036,854,775,807.  This corresponds to a range of
+/- (<SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img199.png"
 ALT="$2^{63}$"></SPAN>-1)/(86400 * 365.25) or +/- 292,271,023,045 years.

<P>
For fractional seconds, a signed 64-bit integer will handle a resolution of
+/- <SPAN CLASS="MATH"><IMG
 WIDTH="26" HEIGHT="17" ALIGN="BOTTOM" BORDER="0"
 SRC="img200.png"
 ALT="$2^{31}$"></SPAN>-1, or +/- 9,223,372,036,854,775,807 parts of a second.

<P>
</LI>
</OL>

<H2><A NAME="SECTION06064000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06064100000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_TimeIntervalAssignment(=) - Assign a TimeInterval to another TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface assignment(=)
       timeinterval1 = timeinterval2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval) :: timeinterval1
       type(ESMF_TimeInterval) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set <TT>timeinterval1</TT> equal to <TT>timeinterval2</TT>.  This is the default
       Fortran assignment, which creates a complete, independent copy of
       <TT>timeinterval2</TT> as <TT>timeinterval1</TT>.  If <TT>timeinterval2</TT> is an
       invalid <TT>ESMF_TimeInterval</TT> object then <TT>timeinterval1</TT> will be
       equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to be set.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to be copied.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064200000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_TimeIntervalOperator(+) - Add two TimeIntervals</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(+)
       sum = timeinterval1 + timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: sum
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (+) operator for the <TT>ESMF_TimeInterval</TT> class to
       add <TT>timeinterval1</TT> to <TT>timeinterval2</TT> and return the
       sum as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The augend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The addend.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064300000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_TimeIntervalOperator(-) - Subtract one TimeInterval from another</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(-)
       difference = timeinterval1 - timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: difference
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_TimeInterval</TT> class to
       subtract <TT>timeinterval2</TT> from <TT>timeinterval1</TT> and return
       the difference as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The minuend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The subtrahend.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064400000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_TimeIntervalOperator(-) - Perform unary negation on a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(-)
       timeinterval = -timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: -timeInterval
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_TimeInterval</TT> class to
       perform unary negation on <TT>timeinterval</TT> and return the result.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The time interval to be negated.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064500000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_TimeIntervalOperator(/) - Divide two TimeIntervals, return double precision quotient</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/)
       quotient = timeinterval1 / timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       real(ESMF_KIND_R8) :: quotient
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>timeinterval1</TT> divided by <TT>timeinterval2</TT> as a
       double precision quotient.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064600000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_TimeIntervalOperator(/) - Divide a TimeInterval by an integer, return TimeInterval quotient </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/)
       quotient = timeinterval / divisor
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: quotient
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
       integer(ESMF_KIND_I4),   intent(in) :: divisor
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/) operator for the <TT>ESMF_TimeInterval</TT> class to
       divide a <TT>timeinterval</TT> by an integer <TT>divisor</TT>, and
       return the quotient as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>divisor</STRONG></DT>
<DD>Integer divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064700000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_TimeIntervalFunction(MOD) - Divide two TimeIntervals, return TimeInterval remainder</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface MOD
       function MOD(timeinterval1, timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: MOD
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the Fortran intrinsic MOD() function for the
       <TT>ESMF_TimeInterval</TT> class to return the remainder of 
       <TT>timeinterval1</TT> divided by <TT>timeinterval2</TT> as an 
       <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064800000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_TimeIntervalOperator(*) - Multiply a TimeInterval by an integer</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(*)
       product = timeinterval * multiplier
                     OR
       product = multiplier * timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: product
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
       integer(ESMF_KIND_I4),   intent(in) :: multiplier
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (*) operator for the <TT>ESMF_TimeInterval</TT> class to
       multiply a <TT>timeinterval</TT> by an integer <TT>multiplier</TT>,
       and return the product as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The multiplicand.
       
</DD>
<DT><STRONG>multiplier</STRONG></DT>
<DD>The integer multiplier.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064900000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_TimeIntervalOperator(==) - Test if TimeInterval 1 is equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(==)
       if (timeinterval1 == timeinterval2) then ... endif
                    OR
       result = (timeinterval1 == timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> and <TT>timeinterval2</TT> 
       represent an equal duration of time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_TimeIntervalOperator(/=) - Test if TimeInterval 1 is not equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/=)
       if (timeinterval1 /= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 /= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> and <TT>timeinterval2</TT> do not 
       represent an equal duration of time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641100000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_TimeIntervalOperator(&lt;) - Test if TimeInterval 1 is less than TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(&lt;)
       if (timeinterval1 &lt; timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &lt; timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a lesser duration of time 
       than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641200000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_TimeIntervalOperator(&lt;=) - Test if TimeInterval 1 is less than or equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(&lt;=)
       if (timeinterval1 &lt;= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &lt;= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a lesser or equal duration 
       of time than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641300000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_TimeIntervalOperator(&gt;) - Test if TimeInterval 1 is greater than TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(&gt;)
       if (timeinterval1 &gt; timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &gt; timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a greater duration of time 
       than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641400000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_TimeIntervalOperator(&gt;=) - Test if TimeInterval 1 is greater than or equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(&gt;=)
       if (timeinterval1 &gt;= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &gt;= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a greater or equal 
       duration of time than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641500000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_TimeIntervalAbsValue - Get the absolute value of a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_TimeIntervalAbsValue(timeinterval)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: ESMF_TimeIntervalAbsValue
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns the absolute value of <TT>timeinterval</TT>.

<P>
The argument is:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to take the absolute value of.
            Absolute value is returned as the value of the function.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641600000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDur(timeinterval, &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641700000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurStart(timeinterval, startTimeIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTimeIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>startTimeIn</STRONG></DT>
<DD>INPUT argument:  pins a calendar interval to a specific point
            in time to allow conversion between relative units (yy, mm, d) and
            absolute units (d, h, m, s).  Overrides any startTime and/or endTime
            previously set.  Mutually exclusive with endTimeIn and calendarIn.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641800000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurCal(timeinterval, calendarIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendarIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>calendarIn</STRONG></DT>
<DD>INPUT argument:  pins a calendar interval to a specific calendar
            to allow conversion between relative units (yy, mm, d) and
            absolute units (d, h, m, s).  Mutually exclusive with startTimeIn
            and endTimeIn since they contain a calendar.  Alternate to, and
            mutually exclusive with, calkindflagIn below.  Primarily for
            specifying a custom calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit). 
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit). 
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641900000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurCalTyp(timeinterval, calkindflagIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, &amp;
         timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflagIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>calkindflagIn</STRONG></DT>
<DD>INPUT argument:  Alternate to, and mutually exclusive with,
            calendarIn above.  More convenient way of specifying a built-in
            calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_TimeIntervalNegAbsValue - Return the negative absolute value of a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_TimeIntervalNegAbsValue(timeinterval)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: ESMF_TimeIntervalNegAbsValue
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns the negative absolute value of <TT>timeinterval</TT>.

<P>
The argument is:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to take the negative absolute value of.
            Negative absolute value is returned as the value of the function.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642100000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_TimeIntervalPrint - Print TimeInterval information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_TimeIntervalPrint(timeinterval, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       character (len=*),       intent(in),  optional :: options
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints out the contents of an <TT>ESMF_TimeInterval</TT> to <TT>stdout</TT>,
       in support of testing and debugging.  The options control the type of
       information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>Time interval to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options.  If none specified, prints all <TT>timeinterval</TT>
            property values. 
<BR>            "string" - prints <TT>timeinterval</TT>'s value in ISO 8601 format
                       for all units through seconds.  For any non-zero
                       fractional seconds, prints in integer rational
                       fraction form n/d.  Format is PyYmMdDThHmMs[:n/d]S,
                       where [:n/d] is the integer numerator and denominator
                       of the fractional seconds value, if present.
                       See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].  See also method
                       <TT>ESMF_TimeIntervalGet(..., timeString= , ...)</TT> 
<BR>            "string isofrac" - prints <TT>timeinterval</TT>'s value in strict
                       ISO 8601 format for all units, including any fractional
                       seconds part.  Format is PyYmMdDThHmMs[.f]S, where [.f]
                       represents fractional seconds in decimal form,
                       if present.  See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>].
                       See also method <TT>ESMF_TimeIntervalGet(..., timeStringISOFrac= , ...)</TT> 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642200000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDur(timeinterval, &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642300000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurStart(timeinterval, startTime, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>startTime</STRONG></DT>
<DD>Starting time of an absolute calendar interval 
            (yy, mm, and/or d); pins a calendar interval to a specific point 
            in time.  If not set, and calendar also not set, calendar interval 
            "floats" across all calendars and times.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8).
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642400000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurCal(timeinterval, calendar, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>Calendar</TT> used to give better definition to 
            calendar interval (yy, mm, and/or d) for arithmetic, comparison, 
            and conversion operations.  Allows calendar interval to "float" 
            across all times on a specific calendar.  Default = NULL; 
            if startTime also not specified, calendar interval "floats" across 
            all calendars and times.  Mutually exclusive with startTime since 
            it contains a calendar.  Alternate to, and mutually exclusive with, 
            calkindflag below.  Primarily for specifying a custom calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanosecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8).
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8).
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642500000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurCalTyp(timeinterval, calkindflag, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>Alternate to, and mutually exclusive with, 
            calendar above.  More convenient way of specifying a built-in 
            calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer month (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian day, or Modified Julian day (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hour.  Default = 0.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minute.  Default = 0.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer second (32-bit).  Default = 0.
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer second (large, 64-bit).  Default = 0.
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer millisecond.  Default = 0.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microsecond.  Default = 0.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanosecond.  Default = 0.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision day.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hour.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minute.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision second.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision millisecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microsecond.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional second (sN/sD).
            Default = 0.
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 0.
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional second (sN/sD).
            Default = 1.
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional second (sN_i8/sD_i8)
                                                             (large, 64-bit).
            Default = 1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642600000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_TimeIntervalSet - Initialize or set a TimeInterval from an ISO 8601 format string</A>
</H3>

<P>
<A NAME="API:TimeIntervalSetStr"></A>
<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   Private name; call using ESMF_TimeIntervalSet()
 
       subroutine ESMF_TimeIntervalSetStr(timeinterval, timeIntervalString, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       character(*),            intent(in)            :: timeIntervalString  
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the value of an <TT>ESMF_TimeInterval</TT> using a
       string in ISO 8601 duration format P[y]Y[mm]M[d]DT[h]H[m]M[s]S. See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>] for information about the format. In ESMF's implementation the time values can have the following types: 
       <DL>
<DT><STRONG>y</STRONG></DT>
<DD>- the number of years expressed in up to a 64-bit integer
        
</DD>
<DT><STRONG>mm</STRONG></DT>
<DD>- the number of months expressed in up to a 64-bit integer
        
</DD>
<DT><STRONG>d</STRONG></DT>
<DD>- the number of days expressed in up to a 64-bit integer or a 64-bit floating point value (double)
        
</DD>
<DT><STRONG>h</STRONG></DT>
<DD>- the number of hours expressed in up to a 32-bit integer or a 64-bit floating point value (double)
        
</DD>
<DT><STRONG>m</STRONG></DT>
<DD>- the number of minutes expressed in up to a 32-bit integer or a 64-bit floating point value (double)
        
</DD>
<DT><STRONG>s</STRONG></DT>
<DD>- the number of seconds expressed in up to a 64-bit integer or a 64-bit floating point value (double)
       
</DD>
</DL>

<P>
As with the ISO format, in ESMF's implementation the specifier and value can be left out if the value is 0. For example, P1YT1H3M4S is a valid format if the number of months and
     days are both 0. The time part including the T can also be left off if the time values are all 0, so P1Y is a valid string if just 1 year is being specified. 

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>timeIntervalString</STRONG></DT>
<DD>ISO 8601 format duration string (e.g. P[y]Y[mm]M[d]DT[h]H[m]M[s]S).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642700000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_TimeIntervalSet - Initialize or set a TimeInterval from an ISO 8601 format string and calendar</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetStrCal(timeinterval, calendar, &amp;
            timeIntervalString, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendar
       character(*),            intent(in)            :: timeIntervalString  
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the value of an <TT>ESMF_TimeInterval</TT> using a
    string in ISO 8601 duration format P[y]Y[mm]M[d]DT[h]H[m]M[s]S. See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>] for
    information about the format. Also, see the description for the method
   <TT>ESMF_TimeIntervalSetStr()</TT>&nbsp;<A HREF="#API:TimeIntervalSetStr">44.4.26</A>
   for the specific types supported by ESMF for the values in the duration string. 

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>Calendar</TT> used to give better definition to 
            calendar interval (yy, mm, and/or d) for arithmetic, comparison, 
            and conversion operations.  Allows calendar interval to "float" 
            across all times on a specific calendar.  Default = NULL; 
            if startTime also not specified, calendar interval "floats" across 
            all calendars and times.  Mutually exclusive with startTime since 
            it contains a calendar.  Alternate to, and mutually exclusive with, 
            calkindflag below.  Primarily for specifying a custom calendar kind.
       
</DD>
<DT><STRONG>timeIntervalString</STRONG></DT>
<DD>ISO 8601 format duration string (e.g. P[y]Y[mm]M[d]DT[h]H[m]M[s]S).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642800000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_TimeIntervalSet - Initialize or set a TimeInterval from an ISO 8601 format string and calendar kind</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetStrCalTyp(timeinterval, calkindflag, &amp;
            timeIntervalString, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
       character(*),            intent(in)            :: timeIntervalString  
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the value of an <TT>ESMF_TimeInterval</TT> using a
    string in ISO 8601 duration format P[y]Y[mm]M[d]DT[h]H[m]M[s]S. See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>] for
    information about the format. Also, see the description for the method
   <TT>ESMF_TimeIntervalSetStr()</TT>&nbsp;<A HREF="#API:TimeIntervalSetStr">44.4.26</A>
   for the specific types supported by ESMF for the values in the duration string. 

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>Alternate to, and mutually exclusive with, 
            calendar above.  More convenient way of specifying a built-in 
            calendar kind.
       
</DD>
<DT><STRONG>timeIntervalString</STRONG></DT>
<DD>ISO 8601 format duration string (e.g. P[y]Y[mm]M[d]DT[h]H[m]M[s]S).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642900000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_TimeIntervalSet - Initialize or set a TimeInterval from an ISO 8601 format string and start time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetStrStart(timeinterval, startTime, &amp;
            timeIntervalString, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTime
       character(*),            intent(in)            :: timeIntervalString  
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets the value of an <TT>ESMF_TimeInterval</TT> using a
    string in ISO 8601 duration format P[y]Y[mm]M[d]DT[h]H[m]M[s]S. See&nbsp;[<A
 HREF="node8.html#ISO">24</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">14</A>] for
    information about the format. Also, see the description for the method
   <TT>ESMF_TimeIntervalSetStr()</TT>&nbsp;<A HREF="#API:TimeIntervalSetStr">44.4.26</A>
   for the specific types supported by ESMF for the values in the duration string. 

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>startTime</STRONG></DT>
<DD>Starting time of an absolute calendar interval 
            (yy, mm, and/or d); pins a calendar interval to a specific point 
            in time.  If not set, and calendar also not set, calendar interval 
            "floats" across all calendars and times.
       
</DD>
<DT><STRONG>timeIntervalString</STRONG></DT>
<DD>ISO 8601 format duration string (e.g. P[y]Y[mm]M[d]DT[h]H[m]M[s]S).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060643000000000000000">
<SPAN CLASS="arabic">44</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_TimeIntervalValidate - Validate a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_TimeIntervalValidate(timeinterval, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>timeinterval</TT> is valid.
       If fractional value, denominator must be non-zero.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD><TT>ESMF_TimeInterval</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION06070000000000000000">
<SPAN CLASS="arabic">45</SPAN> Clock Class</A>
</H1>

<H2><A NAME="SECTION06071000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:Clock"></A>
<P>
The Clock class advances model time and tracks its associated
date on a specified Calendar.  It stores start time, stop time,
current time, previous time, and a time step.  It can also store
a reference time, typically the time instant at which a simulation 
originally began.  For a restart run, the reference time can be 
different than the start time, when the application execution resumes.

<P>
A user can call the <TT>ESMF_ClockSet</TT> method and reset the time 
step as desired.  

<P>
A Clock also stores a list of Alarms, which can be set to flag 
events that occur at a specified time instant or at 
a specified time interval.  See Section&nbsp;<A HREF="#sec:Alarm">46.1</A> for 
details on how to use Alarms.

<P>
There are methods for setting and getting the Times and 
Alarms associated with a Clock.  Methods are defined for 
advancing the Clock's current time, checking if the 
stop time has been reached, reversing direction, and 
synchronizing with a real clock. 

<H2><A NAME="SECTION06072000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION06072100000000000000"></A>
<A NAME="const:direction"></A>
<BR>
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DIRECTION
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

Specifies the time-stepping direction of a clock.  Use with "direction"
argument to methods <TT>ESMF_ClockSet()</TT> and <TT>ESMF_ClockGet()</TT>.
Cannot be used with method <TT>ESMF_ClockCreate()</TT>, since it only
initializes a clock in the default forward mode; a clock must be advanced
(timestepped) at least once before reversing direction via
<TT>ESMF_ClockSet()</TT>.  This also holds true for negative timestep clocks
which are initialized (created) with stopTime &lt; startTime, since "forward"
means timestepping from startTime towards stopTime
(see <TT>ESMF_DIRECTION_FORWARD</TT> below).

<P>
"Forward" and "reverse" directions are distinct from positive and negative
timesteps.  "Forward" means timestepping in the direction established at
<TT>ESMF_ClockCreate()</TT>, from startTime towards stopTime, regardless
of the timestep sign.  "Reverse" means timestepping in the opposite direction,
back towards the clock's startTime, regardless of the timestep sign.

<P>
Clocks and alarms run in reverse in such a way that the state of a clock and
its alarms after each time step is precisely replicated as it was in forward
time-stepping mode.  All methods which query clock and alarm state will
return the same result for a given timeStep, regardless of the direction of
arrival.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Direction_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DIRECTION_FORWARD</STRONG></DT>
<DD>Upon calling <TT>ESMF_ClockAdvance()</TT>, the clock will timestep from
its startTime toward its stopTime.  This is the default direction.  A user
can use either <TT>ESMF_ClockIsStopTime()</TT> or <TT>ESMF_ClockIsDone()</TT>
methods to determine when stopTime is reached.  This forward behavior also
holds for negative timestep clocks which are initialized (created) with
stopTime &lt; startTime.

<P>
</DD>
<DT><STRONG>ESMF_DIRECTION_REVERSE</STRONG></DT>
<DD>Upon calling <TT>ESMF_ClockAdvance()</TT>, the clock will timestep backwards
toward its startTime.  Use method <TT>ESMF_ClockIsDone()</TT> to determine when
startTime is reached.  This reverse behavior also holds for negative timestep
clocks which are initialized (created) with stopTime &lt; startTime.

<P>
</DD>
</DL>

<H2><A NAME="SECTION06073000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The following is a typical sequence for using a Clock in a 
geophysical model.

<P>
<B>At initialize:</B>

<UL>
<LI>Set a Calendar.
</LI>
<LI>Set start time, stop time and time step as Times and 
Time Intervals.
</LI>
<LI>Create and Initialize a Clock using the start time, stop time and time
step.
</LI>
<LI>Define Times and Time Intervals associated with special
events, and use these to set Alarms.
</LI>
</UL>

<P>
<B>At run:</B>

<UL>
<LI>Advance the Clock, checking for ringing alarms as needed.
</LI>
<LI>Check if it is time to stop.
</LI>
</UL>

<P>
<B>At finalize:</B>

<UL>
<LI>Since Clocks and Alarms are deep classes, they need to be explicitly
destroyed at finalization.  Times and TimeIntervals are lightweight classes,
so they don't need explicit destruction.
</LI>
</UL>

<P>
The following code example illustrates Clock usage.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_ClockEx - Clock initialization and time-stepping
!
! !DESCRIPTION:
!
! This program shows an example of how to create, initialize, advance, and
! examine a basic clock
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate a clock 
      type(ESMF_Clock) :: clock

      ! instantiate time_step, start and stop times
      type(ESMF_TimeInterval) :: timeStep
      type(ESMF_Time) :: startTime
      type(ESMF_Time) :: stopTime

      ! local variables for Get methods
      type(ESMF_Time) :: currTime
      integer(ESMF_KIND_I8) :: advanceCount
      integer :: YY, MM, DD, H, M, S

      ! return code
      integer :: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="ClockEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06073100000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Clock creation</A>
</H3>

<P>
This example shows how to create and initialize an <TT>ESMF_Clock</TT>.
<P>
<PRE>
      ! initialize time interval to 2 days, 4 hours (6 timesteps in 13 days)
      call ESMF_TimeIntervalSet(timeStep, d=2, h=4, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize start time to 4/1/2003 2:24:00 ( 1/10 of a day )
      call ESMF_TimeSet(startTime, yy=2003, mm=4, dd=1, h=2, m=24, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize stop time to 4/14/2003 2:24:00 ( 1/10 of a day )
      call ESMF_TimeSet(stopTime, yy=2003, mm=4, dd=14, h=2, m=24, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize the clock with the above values
      clock = ESMF_ClockCreate(timeStep, startTime, stopTime=stopTime, &amp;
                               name="Clock 1", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06073200000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Clock advance</A>
</H3>

<P>
This example shows how to time-step an <TT>ESMF_Clock</TT>.
<P>
<PRE>
      ! time step clock from start time to stop time
      do while (.not.ESMF_ClockIsStopTime(clock, rc=rc))
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockAdvance(clock, rc=rc)
</PRE>

<P>
<PRE>
      end do
</PRE>

<P>

<H3><A NAME="SECTION06073300000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Clock examination</A>
</H3>

<P>
This example shows how to examine an <TT>ESMF_Clock</TT>.
<P>
<PRE>
      ! get the clock's final current time
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeGet(currTime, yy=YY, mm=MM, dd=DD, h=H, m=M, s=S, rc=rc) 
      print *, "The clock's final current time is ", YY, "/", MM, "/", DD, &amp;
               " ", H, ":", M, ":", S
</PRE>

<P>
<PRE>
      ! get the number of times the clock was advanced
      call ESMF_ClockGet(clock, advanceCount=advanceCount, rc=rc)
      print *, "The clock was advanced ", advanceCount, " times."
</PRE>

<P>

<H3><A NAME="SECTION06073400000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Clock reversal</A>
</H3>

<P>
This example shows how to time-step an <TT>ESMF_Clock</TT> in reverse mode.
<P>
<PRE>
      call ESMF_ClockSet(clock, direction=ESMF_DIRECTION_REVERSE, rc=rc)
</PRE>

<P>
<PRE>
      ! time step clock in reverse from stop time back to start time;
      !  note use of ESMF_ClockIsDone() rather than ESMF_ClockIsStopTime()
      do while (.not.ESMF_ClockIsDone(clock, rc=rc))
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockAdvance(clock, rc=rc)
</PRE>

<P>
<PRE>
      end do
</PRE>

<P>

<H3><A NAME="SECTION06073500000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Clock destruction</A>
</H3>

<P>
This example shows how to destroy an <TT>ESMF_Clock</TT>.
<P>
<PRE>
      ! destroy clock
      call ESMF_ClockDestroy(clock, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_ClockEx
</PRE>

<P>


<H2><A NAME="SECTION06074000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Alarm list allocation factor</B>  The alarm list within a clock is
dynamically allocated automatically, 200 alarm references at a time.
This constant is defined in both Fortran and C++ with a #define for ease
of modification.

<P>
</LI>
<LI><B>Clock variable timesteps in reverse</B> 

In order for a clock with
variable timesteps to be run in <TT>ESMF_DIRECTION_REVERSE</TT>, the user must
supply those timesteps to <TT>ESMF_ClockAdvance()</TT>.  Essentially, the user
must save the timesteps while in forward mode.  In a future release, the
Time Manager will assume this responsibility by saving the clock state
(including the timeStep) at every timestep while in forward mode.

<P>
</LI>
</OL>

<H2><A NAME="SECTION06075000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06075100000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ClockAssignment(=) - Assign a Clock to another Clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface assignment(=)
       clock1 = clock2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock) :: clock1
       type(ESMF_Clock) :: clock2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign <TT>clock1</TT> as an alias to the same <TT>ESMF_Clock</TT> object in
       memory as <TT>clock2</TT>. If <TT>clock2</TT> is invalid, then <TT>clock1</TT>
       will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the
            assignment.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075200000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ClockOperator(==) - Test if Clock 1 is equal to Clock 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(==)
       if (clock1 == clock2) then ... endif
                    OR
       result = (clock1 == clock2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in) :: clock1
       type(ESMF_Clock), intent(in) :: clock2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Clock</TT> class.
       Compare two clocks for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created clocks and identical for clocks created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both
       sides are in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075300000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ClockOperator(/=) - Test if Clock 1 is not equal to Clock 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/=)
       if (clock1 /= clock2) then ... endif
                    OR
       result = (clock1 /= clock2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in) :: clock1
       type(ESMF_Clock), intent(in) :: clock2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Clock</TT> class.
       Compare two clocks for inequality; return <TT>.true.</TT> if not equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created clocks and identical for clocks created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both sides
       are <EM>not</EM> in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the
            non-equality operation.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the
            non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075400000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ClockAdvance - Advance a Clock's current time by one time step</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockAdvance(clock, &amp;
         timeStep, ringingAlarmList, ringingAlarmCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       type(ESMF_Alarm),        intent(out), optional :: ringingAlarmList(:)
       integer,                 intent(out), optional :: ringingAlarmCount
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Advances the <TT>clock</TT>'s current time by one time step:  either the
       <TT>clock</TT>'s, or the passed-in <TT>timeStep</TT> (see below).  When the
       <TT>clock</TT> is in <TT>ESMF_DIRECTION_FORWARD</TT> (default), this method
       adds the <TT>timeStep</TT> to the <TT>clock</TT>'s current time.
       In <TT>ESMF_DIRECTION_REVERSE</TT>, <TT>timeStep</TT> is subtracted from the
       current time.  In either case, <TT>timeStep</TT> can be positive or negative.
       See the "direction" argument in method <TT>ESMF_ClockSet()</TT>.
       <TT>ESMF_ClockAdvance()</TT> optionally returns a list and number of ringing
       <TT>ESMF_Alarm</TT>s.  See also method <TT>ESMF_ClockGetRingingAlarms()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to advance.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Time step is performed with given timeStep, instead of
            the <TT>ESMF_Clock</TT>'s.  Does not replace the <TT>ESMF_Clock</TT>'s
            timeStep; use <TT>ESMF_ClockSet(clock, timeStep, ...)</TT> for
            this purpose.  Supports applications with variable time steps.
            timeStep can be positive or negative.
       
</DD>
<DT><STRONG>[ringingAlarmList]</STRONG></DT>
<DD>Returns the array of alarms that are ringing after the
            time step.
       
</DD>
<DT><STRONG>[ringingAlarmCount]</STRONG></DT>
<DD>The number of alarms ringing after the time step.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075500000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ClockCreate - Create a new ESMF Clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_ClockCreate()
       function ESMF_ClockCreateNew(timeStep, startTime, &amp;
         stopTime, runDuration, runTimeStepCount, refTime, repeatDuration, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Clock) :: ESMF_ClockCreateNew
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeStep
       type(ESMF_Time),         intent(in)            :: startTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: runDuration
       integer,                 intent(in),  optional :: runTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       type(ESMF_TimeInterval), intent(in),  optional :: repeatDuration
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.7.0</STRONG></DT>
<DD>Added argument <TT>repeatDuration</TT>.
                The new argument allows the user to specify that they want the
                clock to be a repeat clock and repeatedly go through the same
                interval of time.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates and sets the initial values in a new <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeStep</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval, which can be
            positive or negative.
       
</DD>
<DT><STRONG>startTime</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.  Can be less than or
            or greater than stopTime, depending on a positive or negative
            timeStep, respectively, and whether a stopTime is specified;
            see below.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.  Can be greater than or
            less than the startTime, depending on a positive or negative
            timeStep, respectively.  If neither stopTime, runDuration, nor
            runTimeStepCount is specified, clock runs "forever"; user must
            use other means to know when to stop (e.g. ESMF_Alarm or
            ESMF_ClockGet(clock, currTime)).  Mutually exclusive with
            runDuration and runTimeStepCount.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + runDuration.
            Can be positive or negative, consistent with the timeStep's sign.
            Mutually exclusive with stopTime and runTimeStepCount.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + (runTimeStepCount * timeStep).
            stopTime can be before startTime if timeStep is negative.
            Mutually exclusive with stopTime and runDuration.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.  Provides reference point
            for simulation time (see currSimTime in ESMF_ClockGet() below).
       
</DD>
<DT><STRONG>[repeatDuration]</STRONG></DT>
<DD>If specified and not 0, then makes <TT>ESMF_Clock</TT> a repeating clock that stays within
            the range of <TT>startTime</TT> to <TT>startTime</TT>+<TT>repeatDuration</TT>. For example, when advancing
            if the current time goes past <TT>startTime</TT>+<TT>repeatDuration</TT>, then it resets
            back to <TT>startTime</TT> to continue. Currently, the repeat functionality is not supported with clocks
            that run backwards (e.g. that have a negative timeStep). 
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created clock.  If not specified, a
            default unique name will be generated: "ClockNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075600000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ClockCreate - Create a copy of an existing ESMF Clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_ClockCreate()
       function ESMF_ClockCreateCopy(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Clock) :: ESMF_ClockCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a deep copy of a given <TT>ESMF_Clock</TT>, but does not copy its
       list of <TT>ESMF_Alarm</TT>s (pointers), since an <TT>ESMF_Alarm</TT> can only
       be associated with one <TT>ESMF_Clock</TT>.  Hence, the returned
       <TT>ESMF_Clock</TT> copy has no associated <TT>ESMF_Alarm</TT>s, the same as
       with a newly created <TT>ESMF_Clock</TT>.  If desired, new
       <TT>ESMF_Alarm</TT>s must be created and associated with this copied
       <TT>ESMF_Clock</TT> via <TT>ESMF_AlarmCreate()</TT>, or existing
       <TT>ESMF_Alarm</TT>s must be re-associated with this copied
       <TT>ESMF_Clock</TT> via <TT>ESMF_AlarmSet(...clock=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075700000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ClockDestroy - Release resources associated with a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockDestroy(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)          :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Clock</TT>.  This releases
       the list of associated <TT>ESMF_Alarm</TT>s (pointers), but not the
       <TT>ESMF_Alarm</TT>s themselves; the user must explicitly call
       <TT>ESMF_AlarmDestroy()</TT> on each <TT>ESMF_Alarm</TT> to release its
       resources.  <TT>ESMF_ClockDestroy()</TT> and corresponding
       <TT>ESMF_AlarmDestroy()</TT>s can be called in either order.

<P>
If <TT>ESMF_ClockDestroy()</TT> is called before <TT>ESMF_AlarmDestroy()</TT>,
       any <TT>ESMF_Alarm</TT>s that were in the <TT>ESMF_Clock</TT>'s list will
       no longer be associated with any <TT>ESMF_Clock</TT>.  If desired,
       these "orphaned" <TT>ESMF_Alarm</TT>s can be associated with a different
       <TT>ESMF_Clock</TT> via a call to <TT>ESMF_AlarmSet(...clock=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Clock</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075800000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_ClockGet - Get a Clock's properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGet(clock, &amp;
         timeStep, startTime, stopTime, &amp;
         runDuration, runTimeStepCount, refTime, currTime, prevTime, &amp;
         currSimTime, prevSimTime, calendar, calkindflag, timeZone, &amp;
         advanceCount, alarmCount, direction, repeatDuration, repeatCount, &amp;
         name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(out), optional :: timeStep
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Time),         intent(out), optional :: stopTime
       type(ESMF_TimeInterval), intent(out), optional :: runDuration
       real(ESMF_KIND_R8),      intent(out), optional :: runTimeStepCount
       type(ESMF_Time),         intent(out), optional :: refTime
       type(ESMF_Time),         intent(out), optional :: currTime
       type(ESMF_Time),         intent(out), optional :: prevTime
       type(ESMF_TimeInterval), intent(out), optional :: currSimTime
       type(ESMF_TimeInterval), intent(out), optional :: prevSimTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       integer,                 intent(out), optional :: timeZone
       integer(ESMF_KIND_I8),   intent(out), optional :: advanceCount
       integer,                 intent(out), optional :: alarmCount
       type(ESMF_Direction_Flag),    intent(out), optional :: direction
       type(ESMF_TimeInterval), intent(out), optional :: repeatDuration
       integer(ESMF_KIND_I8),   intent(out), optional :: repeatCount
       character (len=*),       intent(out), optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.7.0</STRONG></DT>
<DD>Added arguments <TT>repeatDuration</TT> and <TT>repeatCount</TT>.
                The argument <TT>repeatDuration</TT> allows the user to get information
                about how far the clock will advance before repeating. The argument
                <TT>repeatCount</TT> tells how many times the clock has repeated.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets one or more of the properties of an <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval.
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to get <TT>ESMF_Clock</TT>'s stopping time;
               runDuration = stopTime - startTime.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to get <TT>ESMF_Clock</TT>'s stopping time;
               runTimeStepCount = (stopTime - startTime) / timeStep.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.
       
</DD>
<DT><STRONG>[currTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s current time.
       
</DD>
<DT><STRONG>[prevTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s previous time.  Equals currTime at
            the previous time step.
       
</DD>
<DT><STRONG>[currSimTime]</STRONG></DT>
<DD>The current simulation time (currTime - refTime).
       
</DD>
<DT><STRONG>[prevSimTime]</STRONG></DT>
<DD>The previous simulation time.  Equals currSimTime at
            the previous time step.
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>The <TT>Calendar</TT> on which all the <TT>Clock</TT>'s times are defined.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>The <TT>CalKind_Flag</TT> on which all the <TT>Clock</TT>'s times are
            defined.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>The timezone within which all the <TT>Clock</TT>'s times are defined.
       
</DD>
<DT><STRONG>[advanceCount]</STRONG></DT>
<DD>The number of times the <TT>ESMF_Clock</TT> has been advanced.
            Increments in <TT>ESMF_DIRECTION_FORWARD</TT> and decrements in
            <TT>ESMF_DIRECTION_REVERSE</TT>; see "direction" argument below and
            in <TT>ESMF_ClockSet()</TT>.

</DD>
<DT><STRONG>[alarmCount]</STRONG></DT>
<DD>The number of <TT>ESMF_Alarm</TT>s in the <TT>ESMF_Clock</TT>'s
            <TT>ESMF_Alarm</TT> list.
       
</DD>
<DT><STRONG>[direction]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time stepping direction.  See also
            <TT>ESMF_ClockIsReverse()</TT>, an alternative for convenient use in
            "if" and "do while" constructs.
       
</DD>
<DT><STRONG>[repeatDuration]</STRONG></DT>
<DD>If not 0, then tells how long the clock will advance before going back to
            startTime. If 0, then the clock is not a repeat clock. 
       
</DD>
<DT><STRONG>[repeatCount]</STRONG></DT>
<DD>If this clock is a repeat clock, then gives the number of times this
            clock has gone back to startTime.     
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this clock.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075900000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_ClockGetAlarm - Get an Alarm in a Clock's Alarm list</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetAlarm(clock, alarmname, alarm, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
       character (len=*), intent(in)            :: alarmname
       type(ESMF_Alarm),  intent(out)           :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the <TT>alarm</TT> whose name is the value of alarmname in the
       <TT>clock</TT>'s <TT>ESMF_Alarm</TT> list.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to get the <TT>ESMF_Alarm</TT> from.
       
</DD>
<DT><STRONG>alarmname</STRONG></DT>
<DD>The name of the desired <TT>ESMF_Alarm</TT>.
       
</DD>
<DT><STRONG>alarm</STRONG></DT>
<DD>The desired alarm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_ClockGetAlarmList - Get a list of Alarms from a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetAlarmList(clock, alarmlistflag, &amp;
         timeStep, alarmList, alarmCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),          intent(in)            :: clock
       type(ESMF_AlarmList_Flag), intent(in)            :: alarmlistflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval),   intent(in),  optional :: timeStep
       type(ESMF_Alarm),          intent(out), optional :: alarmList(:)
       integer,                   intent(out), optional :: alarmCount
       integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the <TT>clock</TT>'s list of alarms and/or number of alarms.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance from which to get an <TT>ESMF_Alarm</TT> list
            and/or count of <TT>ESMF_Alarm</TT>s.
       
</DD>
<DT><STRONG>alarmlistflag</STRONG></DT>
<DD>The kind of list to get:

<P>
<TT>ESMF_ALARMLIST_ALL</TT> :
                  Returns the <TT>ESMF_Clock</TT>'s entire list of alarms.

<P>
<TT>ESMF_ALARMLIST_NEXTRINGING</TT> :
                  Return only those alarms that will ring upon the next
                  <TT>clock</TT> time step.  Can optionally specify argument
                  <TT>timeStep</TT> (see below) to use instead of the <TT>clock</TT>'s.
                  See also method <TT>ESMF_AlarmWillRingNext()</TT> for checking a
                  single alarm.

<P>
<TT>ESMF_ALARMLIST_PREVRINGING</TT> :
                  
                  Return only those alarms that were ringing on the previous
                  <TT>ESMF_Clock</TT> time step.  See also method
                  <TT>ESMF_AlarmWasPrevRinging()</TT> for checking a single alarm.

<P>
<TT>ESMF_ALARMLIST_RINGING</TT> :
                  Returns only those <TT>clock</TT> alarms that are currently
                  ringing.  See also method <TT>ESMF_ClockAdvance()</TT> for
                  getting the list of ringing alarms subsequent to a time step.
                  See also method <TT>ESMF_AlarmIsRinging()</TT> for checking a
                  single alarm.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Optional time step to be used instead of the <TT>clock</TT>'s.
            Only used with <TT>ESMF_ALARMLIST_NEXTRINGING alarmlistflag</TT>
            (see above); ignored if specified with other <TT>alarmlistflags</TT>.

</DD>
<DT><STRONG>[alarmList]</STRONG></DT>
<DD>The array of returned alarms.  If given, the array must be large
            enough to hold the number of alarms of the specified
            <TT>alarmlistflag</TT> in the specified <TT>clock</TT>.
       
</DD>
<DT><STRONG>[alarmCount]</STRONG></DT>
<DD>If specified, returns the number of <TT>ESMF_Alarm</TT>s of the
            specified <TT>alarmlistflag</TT> in the specified <TT>clock</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751100000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_ClockGetNextTime - Calculate a Clock's next time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetNextTime(clock, nextTime, &amp;
         timeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
       type(ESMF_Time),         intent(out)           :: nextTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Calculates what the next time of the <TT>clock</TT> will be, based on
       the <TT>clock</TT>'s current time step or an optionally passed-in
       <TT>timeStep</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance for which to get the next time.
       
</DD>
<DT><STRONG>nextTime</STRONG></DT>
<DD>The resulting <TT>ESMF_Clock</TT>'s next time.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The time step interval to use instead of the clock's.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751200000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_ClockIsCreated - Check whether a Clock object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_ClockIsCreated(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_ClockIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>clock</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>clock</STRONG></DT>
<DD><TT>ESMF_Clock</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751300000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_ClockIsDone - Based on its direction, test if the Clock has reached or exceeded its stop time or start time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_ClockIsDone(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsDone
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns true if currentTime is greater than or equal to stopTime
       in <TT>ESMF_DIRECTION_FORWARD</TT>, or if currentTime is less than or
       equal to startTime in <TT>ESMF_DIRECTION_REVERSE</TT>.  It returns false
       otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751400000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_ClockIsReverse - Test if the Clock is in reverse mode</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_ClockIsReverse(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsReverse
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns true if clock is in <TT>ESMF_DIRECTION_REVERSE</TT>, and false if
       in <TT>ESMF_DIRECTION_FORWARD</TT>.  Allows convenient use in "if" and
       "do while" constructs.  Alternative to
       <TT>ESMF_ClockGet(...direction=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751500000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_ClockIsStopTime - Test if the Clock has reached or exceeded its stop time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_ClockIsStopTime(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsStopTime
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns true if the <TT>clock</TT> has reached or exceeded its stop time,
       and false otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751600000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_ClockIsStopTimeEnabled - Test if the Clock's stop time is enabled</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_ClockIsStopTimeEnabled(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsStopTimeEnabled
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns true if the <TT>clock</TT>'s stop time is set and enabled,
       and false otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751700000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_ClockPrint - Print Clock information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockPrint(clock, options, preString, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in),  optional :: options
       character(*),      intent(in),  optional :: preString
       character(*),      intent(out), optional :: unit
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Clock</TT>'s properties to <TT>stdout</TT>, in
       support of testing and debugging.  The options control the type of
       information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD><TT>ESMF_Clock</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all <TT>clock</TT> property
            values.
<BR>            "advanceCount" - print the number of times the clock has been
                             advanced. 
<BR>            "alarmCount"   - print the number of alarms in the clock's list. 
<BR>            "alarmList"    - print the clock's alarm list. 
<BR>            "currTime"     - print the current clock time. 
<BR>            "direction"    - print the clock's timestep direction. 
<BR>            "name"         - print the clock's name. 
<BR>            "prevTime"     - print the previous clock time. 
<BR>            "refTime"      - print the clock's reference time. 
<BR>            "startTime"    - print the clock's start time. 
<BR>            "stopTime"     - print the clock's stop time. 
<BR>            "timeStep"     - print the clock's time step. 
<BR>       
</DD>
<DT><STRONG>[preString]</STRONG></DT>
<DD>Optionally prepended string. Default to empty string.
       
</DD>
<DT><STRONG>[unit]</STRONG></DT>
<DD>Internal unit, i.e. a string. Default to printing to stdout.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751800000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_ClockSet - Set one or more properties of a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockSet(clock, &amp;
         timeStep, startTime, stopTime, &amp;
         runDuration, runTimeStepCount, refTime, currTime, advanceCount, &amp;
         direction, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       type(ESMF_Time),         intent(in),  optional :: startTime
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: runDuration
       integer,                 intent(in),  optional :: runTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       type(ESMF_Time),         intent(in),  optional :: currTime
       integer(ESMF_KIND_I8),   intent(in),  optional :: advanceCount
       type(ESMF_Direction_Flag),    intent(in),  optional :: direction
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets/resets one or more of the properties of an <TT>ESMF_Clock</TT> that
       was previously initialized via <TT>ESMF_ClockCreate()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to set.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval, which can be positive or
            negative.  This is used to change a clock's timestep property for
            those applications that need variable timesteps.  See
            <TT>ESMF_ClockAdvance()</TT> below for specifying variable timesteps
            that are NOT saved as the clock's internal time step property.
            See "direction" argument below for behavior with
            
<BR>
t ESMF_DIRECTION_REVERSE direction.
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.  Can be less than or
            or greater than stopTime, depending on a positive or negative
            timeStep, respectively, and whether a stopTime is specified;
            see below.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.  Can be greater than or
            less than the startTime, depending on a positive or negative
            timeStep, respectively.  If neither stopTime, runDuration, nor
            runTimeStepCount is specified, clock runs "forever"; user must
            use other means to know when to stop (e.g. ESMF_Alarm or
            ESMF_ClockGet(clock, currTime)).
            Mutually exclusive with runDuration and runTimeStepCount.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + runDuration.
            Can be positive or negative, consistent with the timeStep's sign.
            Mutually exclusive with stopTime and runTimeStepCount.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + (runTimeStepCount * timeStep).
            stopTime can be before startTime if timeStep is negative.
            Mutually exclusive with stopTime and runDuration.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.
            See description in <TT>ESMF_ClockCreate()</TT> above.
       
</DD>
<DT><STRONG>[currTime]</STRONG></DT>
<DD>The current time.
       
</DD>
<DT><STRONG>[advanceCount]</STRONG></DT>
<DD>The number of times the clock has been timestepped.
       
</DD>
<DT><STRONG>[direction]</STRONG></DT>
<DD>Sets the clock's time-stepping direction.  If called with
            <TT>ESMF_DIRECTION_REVERSE</TT>, sets the clock in "reverse" mode,
            causing it to timestep back towards its startTime.  If called
            with <TT>ESMF_DIRECTION_FORWARD</TT>, sets the clock in normal,
            "forward" mode, causing it to timestep in the direction of its
            startTime to stopTime.  This holds true for negative timestep
            clocks as well, which are initialized (created) with
            stopTime &lt; startTime.  The default mode is
            <TT>ESMF_DIRECTION_FORWARD</TT>, established at
            <TT>ESMF_ClockCreate()</TT>.  timeStep can also be specified as an
            argument at the same time, which allows for a change in magnitude
            and/or sign of the clock's timeStep.  If not specified with
            <TT>ESMF_DIRECTION_REVERSE</TT>, the clock's current timeStep is
            effectively negated.  If timeStep is specified, its sign is used as
            specified; it is not negated internally.  E.g., if the specified
            timeStep is negative and the clock is placed in
            <TT>ESMF_DIRECTION_REVERSE</TT>, subsequent calls to
            <TT>ESMF_ClockAdvance()</TT> will cause the clock's current time to
            be decremented by the new timeStep's magnitude.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this clock.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751900000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_ClockStopTimeDisable - Disable a Clock's stop time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockStopTimeDisable(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Disables a <TT>ESMF_Clock</TT>'s stop time; <TT>ESMF_ClockIsStopTime()</TT>
       will always return false, allowing a clock to run past its stopTime.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance whose stop time to disable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060752000000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_ClockStopTimeEnable - Enable an Clock's stop time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockStopTimeEnable(clock, stopTime, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),  intent(in),  optional :: stopTime
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Enables a <TT>ESMF_Clock</TT>'s stop time, allowing
       <TT>ESMF_ClockIsStopTime()</TT> to respect the stopTime.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance whose stop time to enable.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time to set or reset.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060752100000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_ClockSyncToRealTime - Set Clock's current time to wall clock time</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockSyncToRealTime(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets a <TT>clock</TT>'s current time to the wall clock time.  It is
       accurate to the nearest second.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to be synchronized with wall clock time.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060752200000000000000">
<SPAN CLASS="arabic">45</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_ClockValidate - Validate a Clock's properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ClockValidate(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>clock</TT> is valid.
       Must have a valid startTime and timeStep.  If <TT>clock</TT> has a
       stopTime, its currTime must be within startTime to stopTime, inclusive;
       also startTime's and stopTime's calendars must be the same.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD><TT>ESMF_Clock</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION06080000000000000000">
<SPAN CLASS="arabic">46</SPAN> Alarm Class</A>
</H1>

<H2><A NAME="SECTION06081000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:Alarm"></A>The Alarm class identifies events that occur at specific Times
or specific TimeIntervals by returning a true value at those times
or subsequent times, and a false value otherwise.  

<H2><A NAME="SECTION06082000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION06082100000000000000"></A>
<A NAME="const:alarmlist"></A>
<BR>
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ALARMLIST
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Specifies the characteristics of Alarms that populate
a retrieved Alarm list.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AlarmList_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ALARMLIST_ALL</STRONG></DT>
<DD>All alarms.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_NEXTRINGING</STRONG></DT>
<DD>Alarms that will ring before or at the next timestep.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_PREVRINGING</STRONG></DT>
<DD>Alarms that rang at or since the last timestep.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_RINGING</STRONG></DT>
<DD>Only ringing alarms.

<P>
</DD>
</DL>

<H2><A NAME="SECTION06083000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
Alarms are used in conjunction with Clocks (see Section&nbsp;<A HREF="#sec:Clock">45.1</A>).
Multiple Alarms can be associated with a Clock.  During the
<TT>ESMF_ClockAdvance()</TT> method, a Clock iterates over its internal Alarms
to determine if any are ringing.  Alarms ring when a specified Alarm 
time is reached or exceeded, taking into account whether the time step is
positive or negative.  In <TT>ESMF_DIRECTION_REVERSE</TT>
(see Section&nbsp;<A HREF="#sec:Clock">45.1</A>), alarms ring in reverse, i.e., they begin
ringing when they originally ended, and end ringing when they originally
began.  On completion of the time advance call, the Clock optionally returns
a list of ringing alarms.

<P>
Each ringing Alarm can then be processed using Alarm methods for identifying,
turning off, disabling or resetting the Alarm.

<P>
Alarm methods are defined for obtaining the ringing state, turning the
ringer on/off, enabling/disabling the Alarm, and getting/setting 
associated times.

<P>
The following example shows how to set and process Alarms.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_AlarmEx - Alarm examples
!
! !DESCRIPTION:
!
! This program shows an example of how to create, initialize, and process
! alarms associated with a clock.
!-----------------------------------------------------------------------------
#include "ESMF.h"

      ! ESMF Framework module
      use ESMF
      use ESMF_TestMod
      implicit none

      ! instantiate time_step, start, stop, and alarm times
      type(ESMF_TimeInterval) :: timeStep, alarmInterval
      type(ESMF_Time) :: alarmTime, startTime, stopTime

      ! instantiate a clock 
      type(ESMF_Clock) :: clock

      ! instantiate Alarm lists
      integer, parameter :: NUMALARMS = 2
      type(ESMF_Alarm) :: alarm(NUMALARMS)

      ! local variables for Get methods
      integer :: ringingAlarmCount  ! at any time step (0 to NUMALARMS)

      ! name, loop counter, result code
      character (len=ESMF_MAXSTR) :: name
      integer :: i, rc, result
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="AlarmEx.Log", &amp;
        logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083100000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Clock initialization</A>
</H3>

<P>
This example shows how to create and initialize an <TT>ESMF_Clock</TT>.
<P>
<PRE>
      ! initialize time interval to 1 day
      call ESMF_TimeIntervalSet(timeStep, d=1, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize start time to 9/1/2003
      call ESMF_TimeSet(startTime, yy=2003, mm=9, dd=1, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize stop time to 9/30/2003
      call ESMF_TimeSet(stopTime, yy=2003, mm=9, dd=30, rc=rc)
</PRE>

<P>
<PRE>
      ! create &amp; initialize the clock with the above values
      clock = ESMF_ClockCreate(timeStep, startTime, stopTime=stopTime, &amp;
                               name="The Clock", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083200000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Alarm initialization</A>
</H3>

<P>
This example shows how to create and initialize two <TT>ESMF_Alarms</TT> and
   associate them with the clock.
<P>
<PRE>
      ! Initialize first alarm to be a one-shot on 9/15/2003 and associate
      ! it with the clock
      call ESMF_TimeSet(alarmTime, yy=2003, mm=9, dd=15, rc=rc)
</PRE>

<P>
<PRE>
      alarm(1) = ESMF_AlarmCreate(clock, &amp;
         ringTime=alarmTime, name="Example alarm 1", rc=rc)
</PRE>

<P>
<PRE>
      ! Initialize second alarm to ring on a 1 week interval starting 9/1/2003
      ! and associate it with the clock
      call ESMF_TimeSet(alarmTime, yy=2003, mm=9, dd=1, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalSet(alarmInterval, d=7, rc=rc)
</PRE>

<P>
<PRE>
      ! Alarm gets default name "Alarm002"
      alarm(2) = ESMF_AlarmCreate(clock=clock, ringTime=alarmTime, &amp;
                                  ringInterval=alarmInterval, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083300000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Clock advance and Alarm processing</A>
</H3>

<P>
This example shows how to advance an <TT>ESMF_Clock</TT> and process any 
   resulting ringing alarms.
<P>
<PRE>
      ! time step clock from start time to stop time
      do while (.not.ESMF_ClockIsStopTime(clock, rc=rc))
</PRE>

<P>
<PRE>
        ! perform time step and get the number of any ringing alarms
        call ESMF_ClockAdvance(clock, ringingAlarmCount=ringingAlarmCount, &amp;
                               rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        ! check if alarms are ringing
        if (ringingAlarmCount &gt; 0) then
          print *, "number of ringing alarms = ", ringingAlarmCount

          do i = 1, NUMALARMS
            if (ESMF_AlarmIsRinging(alarm(i), rc=rc)) then
</PRE>

<P>
<PRE>
              call ESMF_AlarmGet(alarm(i), name=name, rc=rc)
              print *, trim(name), " is ringing!"
</PRE>

<P>
<PRE>
              ! after processing alarm, turn it off
              call ESMF_AlarmRingerOff(alarm(i), rc=rc)
</PRE>

<P>
<PRE>
            end if ! this alarm is ringing
          end do ! each ringing alarm
        endif ! ringing alarms
      end do ! timestep clock
</PRE>

<P>

<H3><A NAME="SECTION06083400000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Alarm and Clock destruction</A>
</H3>

<P>
This example shows how to destroy <TT>ESMF_Alarms</TT> and <TT>ESMF_Clocks</TT>.
<P>
<PRE>
      call ESMF_AlarmDestroy(alarm(1), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AlarmDestroy(alarm(2), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_ClockDestroy(clock, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_AlarmEx
</PRE>

<P>


<H2><A NAME="SECTION06084000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Alarm list allocation factor</B>  The alarm list within a clock is
dynamically allocated automatically, 200 alarm references at a time.
This constant is defined in both Fortran and C++ with a #define for ease
of modification.

<P>
</LI>
<LI><B>Sticky alarm end times in reverse</B>  For sticky alarms, there is
an implicit limitation that in order to properly reverse timestep through a
ring end time, that time must have already been traversed in the forward
direction.  This is due to the fact that the Time Manager cannot predict
when user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
will be logged when this limitation is not satisfied.

<P>
</LI>
<LI><B>Sticky alarm ring interval in reverse</B>  

For repeating sticky alarms,
it is currently assumed that the ringInterval is constant, so that only the
time of the last call to <TT>ESMF_AlarmRingerOff()</TT> is saved.  In
<TT>ESMF_DIRECTION_REVERSE</TT>, this information is used to turn sticky alarms
back on.  In a future release, ringIntervals will be allowed to be variable,
by saving alarm state at every timestep.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION06085000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The Alarm class is designed as a deep, dynamically allocatable class,
based on a pointer type.  This allows for both indirect and direct
manipulation of alarms.  Indirect alarm manipulation is where ESMF_Alarm API
methods, such as ESMF_AlarmRingerOff(), are invoked on alarm references
(pointers) returned from ESMF_Clock queries such as "return ringing alarms."
Since the method is performed on an alarm reference, the actual alarm held
by the clock is affected, not just a user's local copy.  Direct alarm
manipulation is the more common case where alarm API methods are invoked on
the original alarm objects created by the user.

<P>
For consistency, the ESMF_Clock class is also designed as a deep, dynamically
allocatable class. 

<P>
An additional benefit from this approach is that Clocks and Alarms can be
created and used from anywhere in a user's code without regard to the scope
in which they were created.  In contrast, statically created Alarms and
Clocks would disappear if created within a user's routine that returns,
whereas dynamically allocated Alarms and Clocks will persist until explicitly
destroyed by the user.

<H2><A NAME="SECTION06086000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06086100000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_AlarmAssignment(=) - Assign an Alarm to another Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface assignment(=)
       alarm1 = alarm2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm) :: alarm1
       type(ESMF_Alarm) :: alarm2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign <TT>alarm1</TT> as an alias to the same <TT>ESMF_Alarm</TT> object in
       memory as <TT>alarm2</TT>. If <TT>alarm2</TT> is invalid, then <TT>alarm1</TT>
       will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the
            assignment.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086200000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_AlarmOperator(==) - Test if Alarm 1 is equal to Alarm 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(==)
       if (alarm1 == alarm2) then ... endif
                    OR
       result = (alarm1 == alarm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in) :: alarm1
       type(ESMF_Alarm), intent(in) :: alarm2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Alarm</TT> class.
       Compare two alarms for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created alarms and identical for alarms created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both
       sides are in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086300000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_AlarmOperator(/=) - Test if Alarm 1 is not equal to Alarm 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/=)
       if (alarm1 /= alarm2) then ... endif
                    OR
       result = (alarm1 /= alarm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in) :: alarm1
       type(ESMF_Alarm), intent(in) :: alarm2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Alarm</TT> class.
       Compare two alarms for inequality; return <TT>.true.</TT> if not equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created alarms and identical for alarms created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both sides
       are <EM>not</EM> in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the
            non-equality operation.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the
            non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086400000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_AlarmCreate - Create a new ESMF Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_AlarmCreate()
       function ESMF_AlarmCreateNew(clock, &amp;
         ringTime, ringInterval, stopTime, ringDuration, ringTimeStepCount, &amp;
         refTime, enabled, sticky, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Alarm) :: ESMF_AlarmCreateNew
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),         intent(in),  optional :: ringTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringInterval
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       logical,                 intent(in),  optional :: enabled
       logical,                 intent(in),  optional :: sticky
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates and sets the initial values in a new <TT>ESMF_Alarm</TT>.

<P>
In <TT>ESMF_DIRECTION_REVERSE</TT> (see Section&nbsp;<A HREF="#sec:Clock">45.1</A>), alarms
       ring in reverse, i.e., they begin ringing when they originally ended,
       and end ringing when they originally began.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The clock with which to associate this newly created alarm.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The ring time for a one-shot alarm or the first ring time for a
            repeating (interval) alarm.  Must specify at least one of ringTime
            or ringInterval.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.  If
            <TT>ringTime</TT> is not also specified (first ring time), it will be
            calculated as the <TT>clock</TT>'s current time plus <TT>ringInterval</TT>.
            Must specify at least one of ringTime or ringInterval.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.  If not
            specified, an interval alarm will repeat forever.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The absolute ring duration.  If not sticky (see argument below),
            alarms rings for ringDuration, then turns itself off.  Default is
            zero (unused).  Mutually exclusive with ringTimeStepCount (below);
            used only if set to a non-zero duration and ringTimeStepCount is 1
            (see below).
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The relative ring duration.  If not sticky (see argument below),
            alarms rings for ringTimeStepCount, then turns itself off.
            Default is 1: a non-sticky alarm will ring for one clock time step.
            Mutually exclusive with ringDuration (above); used if
            ringTimeStepCount &gt; 1.  If ringTimeStepCount is 1 (default) and
            ringDuration is non-zero, ringDuration is used (see above), otherwise
            ringTimeStepCount is used.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>Sets the enabled state; default is on (true).  If disabled,
            an alarm will not function at all.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>Sets the sticky state; default is on (true).  If sticky,
            once an alarm is ringing, it will remain ringing until turned off
            manually via a user call to <TT>ESMF_AlarmRingerOff()</TT>.
            If not sticky, an alarm will turn itself off after a certain
            ring duration specified by either ringDuration or
            ringTimeStepCount (see above).  There is an implicit limitation
            that in order to properly reverse timestep through a ring end
            time in <TT>ESMF_DIRECTION_REVERSE</TT>, that time must have already
            been traversed in the forward direction.  This is due to the fact
            that the Time Manager cannot predict when user code will call
            <TT>ESMF_AlarmRingerOff()</TT>.  An error message will be logged
            when this limitation is not satisfied.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created alarm.  If not specified,
            a default unique name will be generated: "AlarmNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086500000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_AlarmCreate - Create a copy of an existing ESMF Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_AlarmCreate()
       function ESMF_AlarmCreateCopy(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Alarm) :: ESMF_AlarmCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Creates a complete (deep) copy of a given <TT>ESMF_Alarm</TT>.
       The returned <TT>ESMF_Alarm</TT> copy is associated with the same
       <TT>ESMF_Clock</TT> as the original <TT>ESMF_Alarm</TT>.  If desired, use
       <TT>ESMF_AlarmSet(...clock=...)</TT> to re-associate the
       <TT>ESMF_Alarm</TT> copy with a different <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086600000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_AlarmDestroy - Release resources associated with an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmDestroy(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)          :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Alarm</TT>.  Also
       removes this <TT>ESMF_Alarm</TT> from its associated <TT>ESMF_Clock</TT>'s
       list of <TT>ESMF_Alarm</TT>s (removes the <TT>ESMF_Alarm</TT> pointer from
       the list).

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Alarm</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086700000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_AlarmDisable - Disable an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmDisable(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Disables an <TT>ESMF_Alarm</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to disable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06086800000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_AlarmEnable - Enable an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmEnable(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Enables an <TT>ESMF_Alarm</TT> to function.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to enable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06086900000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_AlarmGet - Get Alarm properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmGet(alarm, &amp;
         clock, ringTime, prevRingTime, ringInterval, stopTime, ringDuration, &amp;
         ringTimeStepCount, timeStepRingingCount, ringBegin, ringEnd, &amp;
         refTime, ringing, ringingOnPrevTimeStep, enabled, sticky, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Clock),        intent(out), optional :: clock
       type(ESMF_Time),         intent(out), optional :: ringTime
       type(ESMF_Time),         intent(out), optional :: prevRingTime
       type(ESMF_TimeInterval), intent(out), optional :: ringInterval
       type(ESMF_Time),         intent(out), optional :: stopTime
       type(ESMF_TimeInterval), intent(out), optional :: ringDuration
       integer,                 intent(out), optional :: ringTimeStepCount
       integer,                 intent(out), optional :: timeStepRingingCount
       type(ESMF_Time),         intent(out), optional :: ringBegin
       type(ESMF_Time),         intent(out), optional :: ringEnd
       type(ESMF_Time),         intent(out), optional :: refTime
       logical,                 intent(out), optional :: ringing
       logical,                 intent(out), optional :: ringingOnPrevTimeStep
       logical,                 intent(out), optional :: enabled
       logical,                 intent(out), optional :: sticky
       character (len=*),       intent(out), optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets one or more of an <TT>ESMF_Alarm</TT>'s properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>The associated clock.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The ring time for a one-shot alarm or the next repeating alarm.
       
</DD>
<DT><STRONG>[prevRingTime]</STRONG></DT>
<DD>The previous ring time.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The ring duration.  Mutually exclusive with
            ringTimeStepCount (see below).
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The number of time steps comprising the ring duration.  Mutually
            exclusive with ringDuration (see above).
       
</DD>
<DT><STRONG>[timeStepRingingCount]</STRONG></DT>
<DD>The number of time steps for which the alarm has been ringing thus
            far.  Used internally for tracking ringTimeStepCount ring
            durations (see above).  Mutually exclusive with ringBegin
            (see below).  Increments in <TT>ESMF_DIRECTION_FORWARD</TT> and
            decrements in <TT>ESMF_DIRECTION_REVERSE</TT>;
            see Section&nbsp;<A HREF="#sec:Clock">45.1</A>.
       
</DD>
<DT><STRONG>[ringBegin]</STRONG></DT>
<DD>The time when the alarm began ringing.  Used internally for tracking
            ringDuration (see above).  Mutually exclusive with
            timeStepRingingCount (see above).
       
</DD>
<DT><STRONG>[ringEnd]</STRONG></DT>
<DD>The time when the alarm ended ringing.  Used internally for
            re-ringing alarm in <TT>ESMF_DIRECTION_REVERSE</TT>.

</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[ringing]</STRONG></DT>
<DD>The current ringing state.
            See also <TT>ESMF_AlarmRingerOn()</TT>, <TT>ESMF_AlarmRingerOff()</TT>.
       
</DD>
<DT><STRONG>[ringingOnPrevTimeStep]</STRONG></DT>
<DD>The ringing state upon the previous time step. Same as
            <TT>ESMF_AlarmWasPrevRinging()</TT>.

</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>The enabled state.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>The sticky state.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this alarm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_AlarmIsCreated - Check whether a Alarm object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_AlarmIsCreated(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_AlarmIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>alarm</TT> has been created. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD><TT>ESMF_Alarm</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861100000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_AlarmIsEnabled - Check if Alarm is enabled</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_AlarmIsEnabled(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsEnabled
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> is enabled.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for enabled state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861200000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_AlarmIsRinging - Check if Alarm is ringing</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_AlarmIsRinging(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsRinging
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> is ringing.

<P>
See also method
             <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_RINGING, ...)</TT>
       to get a list of all ringing alarms belonging to an <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The alarm to check for ringing state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861300000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_AlarmIsSticky - Check if Alarm is sticky</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_AlarmIsSticky(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsSticky
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Check if <TT>alarm</TT> is sticky.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for sticky state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861400000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_AlarmNotSticky - Unset an Alarm's sticky flag</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmNotSticky(alarm, &amp;
         ringDuration, ringTimeStepCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Unset an <TT>ESMF_Alarm</TT>'s sticky flag; once alarm is ringing,
       it turns itself off after ringDuration.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to unset sticky.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>If not sticky, alarms rings for ringDuration, then turns itself off.
            Mutually exclusive with ringTimeStepCount (see below and full
            description in method <TT>ESMF_AlarmCreate()</TT> or
            <TT>ESMF_AlarmSet()</TT>).
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>If not sticky, alarms rings for ringTimeStepCount, then turns
            itself off.  Mutually exclusive with ringDuration (see above and
            full description in method <TT>ESMF_AlarmCreate()</TT> or
            <TT>ESMF_AlarmSet()</TT>).

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861500000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_AlarmPrint - Print Alarm information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmPrint(alarm, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),  intent(in)            :: alarm
       character (len=*), intent(in),  optional :: options
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Alarm</TT>'s properties to <TT>stdout</TT>, in support
       of testing and debugging.  The options control the type of information
       and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD><TT>ESMF_Alarm</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all <TT>alarm</TT> property values.
<BR>            "clock"        - print the associated clock's name. 
<BR>            "enabled"      - print the alarm's ability to ring. 
<BR>            "name"         - print the alarm's name. 
<BR>            "prevRingTime" - print the alarm's previous ring time. 
<BR>            "ringBegin"    - print time when the alarm actually begins to ring.
<BR>            "ringDuration" - print how long this alarm is to remain ringing. 
<BR>            "ringEnd"      - print time when the alarm actually ends ringing.
<BR>            "ringing"                - print the alarm's current ringing state.
<BR>            "ringingOnPrevTimeStep"  - print whether the alarm was ringing
                                       immediately after the previous clock
                                       time step. 
<BR>            "ringInterval" - print the alarm's periodic ring interval. 
<BR>            "ringTime"     - print the alarm's next time to ring. 
<BR>            "ringTimeStepCount" - print how long this alarm is to remain
                                  ringing, in terms of a number of clock time
                                  steps. 
<BR>            "refTime"      - print the alarm's interval reference (base) time. 
<BR>            "sticky"       - print whether the alarm must be turned off
                             manually. 
<BR>            "stopTime"     - print when alarm intervals end. 
<BR>            "timeStepRingingCount"   - print the number of time steps the
                                       alarm has been ringing thus far. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861600000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_AlarmRingerOff - Turn off an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmRingerOff(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Turn off an <TT>ESMF_Alarm</TT>; unsets ringing state.  For a sticky
       alarm, this method must be called to turn off its ringing state.
       This is true for either <TT>ESMF_DIRECTION_FORWARD</TT> (default) or
       <TT>ESMF_DIRECTION_REVERSE</TT>.  See Section&nbsp;<A HREF="#sec:Clock">45.1</A>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to turn off.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861700000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_AlarmRingerOn - Turn on an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmRingerOn(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Turn on an <TT>ESMF_Alarm</TT>; sets ringing state.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to turn on.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861800000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_AlarmSet - Set Alarm properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmSet(alarm, &amp;
         clock, ringTime, ringInterval, stopTime, ringDuration, &amp;
         ringTimeStepCount, refTime, ringing, enabled, sticky, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Clock),        intent(in),  optional :: clock
       type(ESMF_Time),         intent(in),  optional :: ringTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringInterval
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       logical,                 intent(in),  optional :: ringing
       logical,                 intent(in),  optional :: enabled
       logical,                 intent(in),  optional :: sticky
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets/resets one or more of the properties of an <TT>ESMF_Alarm</TT> that
       was previously initialized via <TT>ESMF_AlarmCreate()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to set.
       
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Re-associates this alarm with a different clock.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The next ring time for a one-shot alarm or a repeating (interval)
            alarm.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The absolute ring duration.  If not sticky (see argument below),
            alarms rings for ringDuration, then turns itself off.  Default is
            zero (unused).  Mutually exclusive with ringTimeStepCount (below);
            used only if set to a non-zero duration and ringTimeStepCount is 1
            (see below).
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The relative ring duration.  If not sticky (see argument below),
            alarms rings for ringTimeStepCount, then turns itself off.
            Default is 1: a non-sticky alarm will ring for one clock time step.
            Mutually exclusive with ringDuration (above); used if
            ringTimeStepCount &gt; 1.  If ringTimeStepCount is 1 (default) and
            ringDuration is non-zero, ringDuration is used (see above), otherwise
            ringTimeStepCount is used.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[ringing]</STRONG></DT>
<DD>Sets the ringing state.
            See also <TT>ESMF_AlarmRingerOn()</TT>, <TT>ESMF_AlarmRingerOff()</TT>.
       
</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>Sets the enabled state.  If disabled, an alarm will not function
            at all.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>Sets the sticky state.  If sticky, once an alarm is ringing, it
            will remain ringing until turned off manually via a user call to
            <TT>ESMF_AlarmRingerOff()</TT>.  If not sticky, an alarm will turn
            itself off after a certain ring duration specified by either
            ringDuration or ringTimeStepCount (see above).
            There is an implicit limitation that in order to properly reverse
            timestep through a ring end time in <TT>ESMF_DIRECTION_REVERSE</TT>,
            that time must have already been traversed in the forward direction.
            This is due to the fact that the Time Manager cannot predict when
            user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
            will be logged when this limitation is not satisfied.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this alarm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861900000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_AlarmSticky - Set an Alarm's sticky flag</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmSticky(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set an <TT>ESMF_Alarm</TT>'s sticky flag; once alarm is ringing,
       it remains ringing until <TT>ESMF_AlarmRingerOff()</TT> is called.
       There is an implicit limitation that in order to properly reverse
       timestep through a ring end time in <TT>ESMF_DIRECTION_REVERSE</TT>, that
       time must have already been traversed in the forward direction.
       This is due to the fact that an <TT>ESMF_Alarm</TT> cannot predict when
       user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
       will be logged when this limitation is not satisfied.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to be set sticky.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060862000000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_AlarmValidate - Validate an Alarm's properties</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmValidate(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),  intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Performs a validation check on an <TT>ESMF_Alarm</TT>'s properties.
       Must have a valid ringTime, set either directly or indirectly via
       ringInterval.  See <TT>ESMF_AlarmCreate()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD><TT>ESMF_Alarm</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060862100000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_AlarmWasPrevRinging - Check if Alarm was ringing on the previous Clock timestep</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_AlarmWasPrevRinging(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmWasPrevRinging
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> was ringing on the previous clock timestep.

<P>
See also method
         <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_PREVRINGING, ...)</TT>
       get a list of all alarms belonging to a <TT>ESMF_Clock</TT> that were
       ringing on the previous time step.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for previous ringing state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060862200000000000000">
<SPAN CLASS="arabic">46</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_AlarmWillRingNext - Check if Alarm will ring upon the next Clock timestep</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_AlarmWillRingNext(alarm, timeStep, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmWillRingNext
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> will ring on the next clock timestep, either
       the current clock timestep or a passed-in timestep.

<P>
See also method
         <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_NEXTRINGING, ...)</TT>
       to get a list of all alarms belonging to a <TT>ESMF_Clock</TT> that will
       ring on the next time step.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The alarm to check for next ringing state.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Optional timestep to use instead of the clock's.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>


<H1><A NAME="SECTION06090000000000000000">
<SPAN CLASS="arabic">47</SPAN> Config Class</A>
</H1>

<H2><A NAME="SECTION06091000000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:Config"></A>
<P>
ESMF Configuration Management is based on NASA DAO's 
Inpak 90 package, a Fortran 90 collection of routines/functions
for accessing <EM>Resource Files</EM> in ASCII format.The package 
is optimized for minimizing formatted I/O, performing all of its 
string operations in memory using Fortran intrinsic functions.
<BR>
<P>

<H3><A NAME="SECTION06091100000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Package history</A>
</H3>

<P>
The ESMF Configuration Management Package was evolved by
Leonid Zaslavsky and Arlindo da Silva from Ipack90 package
created by Arlindo da Silva at NASA DAO.

<P>
Back in the 70's Eli Isaacson wrote IOPACK in Fortran
66.  In June of 1987 Arlindo da Silva wrote Inpak77 using
Fortran 77 string functions; Inpak 77 is a vastly
simplified IOPACK, but has its own goodies not found in
IOPACK.  Inpak 90 removes some obsolete functionality in
Inpak77, and parses the whole resource file in memory for
performance.

<P>

<H3><A NAME="SECTION06091200000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Resource files</A>
</H3>

<P>
A <EM>Resource File (RF)</EM> is a text file consisting of list of 
   <EM>label</EM>-<EM>value</EM> pairs. There is a buffer limit of 256,000 
   characters for the entire Resource File. Each <EM>label</EM> is limited 
   to 1,000 characters. Each label should be followed by some data, the 
   <EM>value</EM>. An example Resource File follows. It is the file used 
   in the example below. 

<P>
<PRE>
 # This is an example Resource File.  
 # It contains a list of &lt;label,value&gt; pairs.
 # The colon after the label is required. 

 # The values after the label can be an list.
 # Multiple types are authorized.
  
  my_file_names:         jan87.dat jan88.dat jan89.dat  # all strings
  constants:             3.1415   25                    # float and integer
  my_favorite_colors:    green blue 022               


 # Or, the data can be a list of single value pairs. 
 # It is simplier to retrieve data in this format:

  radius_of_the_earth:   6.37E6         
  parameter_1:           89
  parameter_2:           78.2
  input_file_name:       dummy_input.nc


 # Or, the data can be located in a table using the following
 # syntax:

  my_table_name::
   1000     3000     263.0
    925     3000     263.0
    850     3000     263.0
    700     3000     269.0
    500     3000     287.0
    400     3000     295.8
    300     3000     295.8
  ::
</PRE>

<P>
Note that the colon after the label is required and that the double colon is required
 to declare tabular data. 

<P>
Resource files are intended for random access (except between ::'s in a 
 table definition). This means that order in which a particular 
 <EM>label-value</EM> pair is retrieved is not dependent upon the original order 
 of the pairs. The only exception to this, however, is when the same <EM>label</EM> appears 
 multiple times within the Resource File.

<P>

<H2><A NAME="SECTION06092000000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>

<P>

<P>
This example/test code performs simple Config/Resource File routines. It does not
   include attaching a Config to a component. The important thing to remember there
   is that you can have one Config per component. 

<P>
There are two methodologies for accessing data in a Resource File.  This example will
   demonstrate both.

<P>
Note the API section contains a complete description of arguments in
   the methods/functions demonstrated in this example. 

<P>

<H3><A NAME="SECTION06092100000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Variable declarations</A>
</H3>

<P>
The following are the variable declarations used as arguments in the following code 
   fragments. They represent the locals names for the variables listed in the Resource 
   File (RF).  Note they do not need to be the same.
<P>
<PRE>
      character(ESMF_MAXPATHLEN) :: fname ! config file name
      character(ESMF_MAXPATHLEN) :: fn1, fn2, fn3, input_file ! strings to be read in
      integer       :: rc            ! error return code (0 is OK)
      integer       :: i_n           ! the first constant in the RF
      real          :: param_1       ! the second constant in the RF
      real          :: radius        ! radius of the earth
      real          :: table(7,3)    ! an array to hold the table in the RF

      type(ESMF_Config)   :: cf      ! the Config itself
      type(ESMF_HConfig)  :: hconfig ! HConfig variable
</PRE>

<P>

<H3><A NAME="SECTION06092200000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Creation of a Config</A>
</H3>

<P>
While there are two methodologies for accessing the data within a Resource File, 
   there is only one way to create the initial Config and load its ASCII text into 
   memory. This is the first step in the process.

<P>
Note that subsequent calls to <TT>ESMF_ConfigLoadFile</TT> will OVERWRITE the current
   Config NOT append to it. There is no means of appending to a Config. 
  
<P>
<PRE>
      cf = ESMF_ConfigCreate(rc=rc)             ! Create the empty Config
</PRE>

<P>
<PRE>
      fname = "myResourceFile.rc"                ! Name the Resource File
      call ESMF_ConfigLoadFile(cf, fname, rc=rc) ! Load the Resource File 
                                                 ! into the empty Config
</PRE>

<P>

<H3><A NAME="SECTION06092300000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> How to retrieve a label with a single value</A>
</H3>
   The first method for retrieving information from the 
   Resource File takes advantage of the &lt;label,value&gt; relationship
   within the file and access the data in a dictionary-like manner. This is the
   simplest methodology, but it does imply the use of only one value per label
   in the Resource File.  

<P>
Remember,
   that the order in which a particular label/value pair is retrieved
   is not dependent upon the order which they exist within the Resource File. 
<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, radius, label='radius_of_the_earth:', &amp;
                                 default=1.0, rc=rc)
</PRE>

<P>
Note that the colon must be included in the label string when using this
   methodology.  It is also important to provide a default value in case the label
   does not exist in the file 

<P>
This methodology works for all types. The following is an example of retrieving a 
   string:
<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, input_file, label='input_file_name:', &amp;
                                 default="./default.nc", rc=rc)
</PRE>

<P>
The same code fragment can be used to demonstrate what happens when the label is not 
   present.  Note that "file_name" does not exist in the Resource File. The result of 
   its absence is the default value provided in the call.
<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, input_file, label='file_name:', &amp;
                                 default="./default.nc", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06092400000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> How to retrieve a label with multiple values</A>
</H3>
   When there are multiple, mixed-typed values associated with a label, the 
   values can be retrieved in two steps:  1) Use ESMF_ConfigFindLabel() 
   to find the label in the Config class; 2) use
   ESMF_ConfigGetAttribute() without the optional 'label' argument to 
   retrieve the values one at a time, reading from left to right in
   the record. 

<P>
A second reminder that the order in which a particular label/value pair is 
   retrieved is not dependent upon the order which they exist within the 
   Resource File. The label used in this method allows the user to skip to
   any point in the file. 
<P>
<PRE>
      call ESMF_ConfigFindLabel(cf, 'constants:', rc=rc) ! Step a) Find the 
                                                         ! label
</PRE>

<P>
Two constants, radius and i_n, can now be retrieved without having to specify their
   label or use an array. They are also different types.
<P>
<PRE>
      call ESMF_ConfigGetAttribute(cf, param_1, rc=rc) ! Step b) read in the 
                                                       ! first constant in 
                                                       ! the sequence
      call ESMF_ConfigGetAttribute(cf, i_n, rc=rc)     ! Step c) read in the 
                                                       ! second constant in 
                                                       ! the sequence
</PRE>

<P>
This methodology also works with strings.
<P>
<PRE>
       call ESMF_ConfigFindLabel(cf, 'my_file_names:', &amp;
               rc=rc)                       ! Step a) find the label
</PRE>

<P>
<PRE>
       call ESMF_ConfigGetAttribute(cf, fn1, &amp;
                 rc=rc)                    ! Step b) retrieve the 1st filename
       call ESMF_ConfigGetAttribute(cf, fn2, &amp;
                 rc=rc)                    ! Step c) retrieve the 2nd filename
       call ESMF_ConfigGetAttribute(cf, fn3, &amp;
                 rc=rc)                    ! Step d) retrieve the 3rd filename
</PRE>

<P>

<H3><A NAME="SECTION06092500000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> How to retrieve a table</A>
</H3>

<P>
To access tabular data, the user must use the multi-value method. 
<P>
<PRE>
      call ESMF_ConfigFindLabel(cf, 'my_table_name::', &amp;
               rc=rc)        ! Step a) Set the label location to the 
                             ! beginning of the table
</PRE>

<P>
Subsequently, <TT>call ESMF_ConfigNextLine()</TT> is used to move the location 
   to the next row of the table. The example table in the Resource File contains
   7 rows and 3 columns (7,3).
<P>
<PRE>
      do i = 1, 7
        call ESMF_ConfigNextLine(cf, rc=rc) ! Step b) Increment the rows
        do j = 1, 3                         ! Step c) Fill in the table 
          call ESMF_ConfigGetAttribute(cf, table(i,j), rc=rc)
        enddo
      enddo
</PRE>

<P>

<H3><A NAME="SECTION06092600000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Destruction of a Config</A>
</H3>

<P>
The work with the Config object <TT>cf</TT> is finalized by callling
   <TT>ESMF_ConfigDestroy()</TT>.
<P>
<PRE>
      call ESMF_ConfigDestroy(cf, rc=rc) ! Destroy the Config object
</PRE>

<P>

<H3><A NAME="SECTION06092700000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Loading a YAML file</A>
</H3>

<P>
The Config class supports loading of YAML files. As before, an empty Config
   object is created with <TT>ESMF_ConfigCreate()</TT> and then populated via the
   <TT>ESMF_ConfigLoadFile()</TT> method.
<P>
<PRE>
      cf = ESMF_ConfigCreate(rc=rc)          ! Create the empty Config object
</PRE>

<P>
Files ending in <TT>.yaml</TT>, <TT>.yml</TT>, or any combination of upper and lower
   case letters that can be mapped to these two options, are interpreted as YAML
   files. All other names are interpreted as classic Config <EM>RFs</EM> as
   documented earlier.
<P>
<PRE>
      call ESMF_ConfigLoadFile(cf, "myResourceFile.yaml", &amp; ! Load the YAML File
        rc=rc)                                    ! into the empty Config object
</PRE>

<P>
Here the <TT>myResourceFile.yaml</TT> contains a YAML version of the previously
   used <TT>myResourceFile.rc</TT> file contents:

<P>
<PRE>
  # YAML representation of the myResourceFile.rc RF
  
  # mapping to sequences
  
  my_file_names:      [jan87.dat, jan88.dat, jan89.dat]  # all strings
  constants:          [3.1415, 25]                       # float and integer
  my_favorite_colors: [green, blue, 022]
  
  # mapping to scalars
  
  radius_of_the_earth:   6.37E6
  parameter_1:           89
  parameter_2:           78.2
  input_file_name:       dummy_input.nc
  
  # represent table as mapping to sequence of sequences
  
  my_table_name:
  - [1000,    3000,    263.0]
  - [ 925,    3000,    263.0]
  - [ 850,    3000,    263.0]
  - [ 700,    3000,    269.0]
  - [ 500,    3000,    287.0]
  - [ 400,    3000,    295.8]
  - [ 300,    3000,    295.8]
</PRE>

<P>
Notice that YAML support is limited to a small subset of the full YAML
   language specification, allowing access through the classic Config API.
   Specifically, the top level in the YAML file is expected to be a mapping
   (dictionary) of scalar keys to any of the following three value options:
    
<UL>
<LI>Scalars
</LI>
<LI>List of scalars
</LI>
<LI>List of lists of scalars
    
</LI>
</UL>
   All other YAML constructs are silently ignored when loaded through this
   interface. Constructs successfully ingested become available in the
   <TT>cf</TT> object, and can be accessed via the regular <TT>ESMF_Config</TT>
   methods as outlined in the previous sections.

<P>
As an example, access the <TT>my_table_name</TT> element:
<P>
<PRE>
      call ESMF_ConfigFindLabel(cf, 'my_table_name::', &amp;
               rc=rc)        ! Step a) Set the label location to the 
                             ! beginning of the table
</PRE>

<P>
When done, the resources held by the Config object are released by calling
   the <TT>ESMF_ConfigDestroy()</TT> method.
<P>
<PRE>
      call ESMF_ConfigDestroy(cf, rc=rc) ! Destroy the Config object
</PRE>

<P>

<H3><A NAME="SECTION06092800000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Creating from HConfig object</A>
</H3>

<P>
The Config class supports creating a Config object from a HConfig object.
   Here the HConfig object is created from the same YAML file as used before.
<P>
<PRE>
      ! Create HConfig object
      hconfig = ESMF_HConfigCreate(filename="myResourceFile.yaml", rc=rc)
</PRE>

<P>
The <TT>myResourceFile.yaml</TT> contains the following YAML contents:

<P>
<PRE>
  # YAML representation of the myResourceFile.rc RF
  
  # mapping to sequences
  
  my_file_names:      [jan87.dat, jan88.dat, jan89.dat]  # all strings
  constants:          [3.1415, 25]                       # float and integer
  my_favorite_colors: [green, blue, 022]
  
  # mapping to scalars
  
  radius_of_the_earth:   6.37E6
  parameter_1:           89
  parameter_2:           78.2
  input_file_name:       dummy_input.nc
  
  # represent table as mapping to sequence of sequences
  
  my_table_name:
  - [1000,    3000,    263.0]
  - [ 925,    3000,    263.0]
  - [ 850,    3000,    263.0]
  - [ 700,    3000,    269.0]
  - [ 500,    3000,    287.0]
  - [ 400,    3000,    295.8]
  - [ 300,    3000,    295.8]
</PRE>

<P>
A Config object can be created from the HConfig object simply by passing
   <TT>hconfig</TT> into <TT>ESMF_CreateConfig()</TT> as argument.
<P>
<PRE>
      ! Create Config object from HConfig
      cf = ESMF_ConfigCreate(hconfig=hconfig, rc=rc)
</PRE>

<P>
Notice that <TT>cf</TT> uses the specified <TT>hconfig</TT> object via reference.
   It remains the callers responsibility to destroy the <TT>hconfig</TT> object
   when finished. Care must be taken to <EM>not</EM> destroy until access via
   <TT>cf</TT> is complete.

<P>
Here, as an example, access the <TT>my_table_name</TT> element:
<P>
<PRE>
      call ESMF_ConfigFindLabel(cf, 'my_table_name::', &amp;
               rc=rc)        ! Step a) Set the label location to the 
                             ! beginning of the table
</PRE>

<P>
<PRE>
      call ESMF_ConfigDestroy(cf, rc=rc) ! Destroy the Config object
</PRE>

<P>
As discussed above, the <TT>hconfig</TT> object requires its own destroy call
   for a complete release.
<P>
<PRE>
      call ESMF_HConfigDestroy(hconfig, rc=rc) ! Destroy the HConfig object
</PRE>

<P>


<H2><A NAME="SECTION06093000000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06093100000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_ConfigAssignment(=) - Config assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     config1 = config2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config) :: config1
     type(ESMF_Config) :: config2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign <TT>config1</TT> as an alias to the same <TT>ESMF_Config</TT> object in memory
     as <TT>config2</TT>. If <TT>config2</TT> is invalid, then <TT>config1</TT> will be
     equally invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>config1</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>config2</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093200000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_ConfigOperator(==) - Test if Config objects are equivalent</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(==)
       if (config1 == config2) then ... endif
                    OR
       result = (config1 == config2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       configical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(in) :: config1
       type(ESMF_Config), intent(in) :: config2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Config</TT> class.
       Compare two configs for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on whether the objects
       are distinct, as with two newly created objects, or are simply aliases
       to the same object as would be the case when assignment was involved.

<P>
The arguments are:
       <DL>
<DT><STRONG>config1</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>config2</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093300000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_ConfigOperator(/=) - Test if Config objects are not equivalent</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/=)
       if (config1 /= config2) then ... endif
                    OR
       result = (config1 /= config2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       configical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(in) :: config1
       type(ESMF_Config), intent(in) :: config2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Config</TT> class.
       Compare two configs for equality; return <TT>.true.</TT> if not equivalent,
       <TT>.false.</TT> otherwise. Comparison is based on whether the Config objects
       are distinct, as with two newly created objects, or are simply aliases
       to the same object as would be the case when assignment was involved.

<P>
The arguments are:
       <DL>
<DT><STRONG>config1</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>config2</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093400000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_ConfigCreate - Instantiate a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ConfigCreate()
     type(ESMF_Config) function ESMF_ConfigCreateDefault(hconfig, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_HConfig), intent(in),  optional   :: hconfig
       integer,            intent(out), optional   :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.6.0</STRONG></DT>
<DD>Added the <TT>hconfig</TT> argument to support creation from HConfig
      object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Instantiates an <TT>ESMF_Config</TT> object. Optionally create from HConfig.

<P>
The arguments are:
     <DL>
<DT><STRONG>[hconfig]</STRONG></DT>
<DD>If specified, create Config from HConfig. By default create an empty
       Config object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093500000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_ConfigCreate - Instantiate a new Config object from a Config section</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ConfigCreate()
     type(ESMF_Config) function ESMF_ConfigCreateFromSection(config, &amp;
       openlabel, closelabel, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config)             :: config
       character(len=*),  intent(in) :: openlabel, closelabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Instantiates an <TT>ESMF_Config</TT> object from a section of an existing
     <TT>ESMF_Config</TT> object delimited by <TT>openlabel</TT> and <TT>closelabel</TT>.
     An error is returned if neither of the input labels is found in input
     <TT>config</TT>.

<P>
Note that a section is intended as the content of a given <TT>ESMF_Config</TT>
     object delimited by two distinct labels. Such content, as well as each of the
     surrounding labels, are still within the scope of the parent <TT>ESMF_Config</TT>
     object. Therefore, including in a section labels used outside that
     section should be done carefully to prevent parsing conflicts.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>The input <TT>ESMF_Config</TT> object.
       
</DD>
<DT><STRONG>openlabel</STRONG></DT>
<DD>Label marking the beginning of a section in <TT>config</TT>.
       
</DD>
<DT><STRONG>closelabel</STRONG></DT>
<DD>Label marking the end of a section in <TT>config</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if a section is found
        and a new <TT>ESMF_Config</TT> object returned.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093600000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_ConfigDestroy - Destroy a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigDestroy(config, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys the <TT>config</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093700000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_ConfigFindLabel - Find a label in a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigFindLabel(config, label, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)           :: config 
       character(len=*),  intent(in)              :: label
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,           intent(out),  optional  :: isPresent
       integer,           intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>6.1.0</STRONG></DT>
<DD>Added the <TT>isPresent</TT> argument.  Allows detection of
    end-of-line condition to be separate from the <TT>rc</TT>.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Finds the <TT>label</TT> (key) string in the <TT>config</TT> object 
     starting from the beginning of its content.

<P>
Since the search is done by looking for a string, possibly multi-worded,
     in the whole <TT>Config</TT> object, it is important to use special 
     conventions to distinguish <TT>labels</TT> from other words. This is done 
     in the Resource File by using the NASA/DAO convention to finish
     line labels with a colon (:) and table labels with a double colon (::).

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Identifying label. 
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the item is found.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       If the label is not found, and the <TT>isPresent</TT> argument is
       not present, an error is returned.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093800000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_ConfigFindNextLabel - Find a label in Config object starting from current position</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigFindNextLabel(config, label, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)           :: config
       character(len=*),  intent(in)              :: label
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,           intent(out),  optional  :: isPresent
       integer,           intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Finds the <TT>label</TT> (key) string in the <TT>config</TT> object, 
     starting from the current position pointer.

<P>
This method is equivalent to <TT>ESMF_ConfigFindLabel</TT>, but the search
     is performed starting from the current position pointer.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Identifying label.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Set to <TT>.true.</TT> if the item is found.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       If the label is not found, and the <TT>isPresent</TT> argument is
       not present, an error is returned.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093900000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_ConfigGet - Generic accessor method</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ConfigGet(config, hconfig, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config),  intent(inout)          :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_HConfig), intent(out),  optional :: hconfig
     integer,            intent(out),  optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access Config internals. 

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[hconfig]</STRONG></DT>
<DD>Internally kept <TT>ESMF_HConfig</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931000000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_ConfigGetAttribute - Get an attribute value from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>        subroutine ESMF_ConfigGetAttribute(config, &lt;value&gt;, &amp;
          label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Config), intent(inout)         :: config
        &lt;value argument&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        character(len=*),  intent(in),  optional :: label
        character(len=*),  intent(in),  optional :: default
        integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets a value from the <TT>config</TT> object.  When the
        value is a sequence of characters
        it will be terminated by the first white space.

<P>
Supported values for &lt;value argument&gt; are:
        <DL>
<DT></DT>
<DD>character(len=*), intent(out)          :: value
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), intent(out)      :: value
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), intent(out)      :: value
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out)   :: value
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out)   :: value
        
</DD>
<DT></DT>
<DD>logical, intent(out)                   :: value
        
</DD>
</DL>

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>Returned value.
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifing label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if <TT>label</TT> is not found in <TT>config</TT> object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060931100000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_ConfigGetAttribute - Get a list of attribute values from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>        subroutine ESMF_ConfigGetAttribute(config, &lt;value list argument&gt;, &amp;
          count, label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Config), intent(inout)         :: config
        &lt;value list argument&gt;, see below for values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,           intent(in)   optional :: count
        character(len=*),  intent(in),  optional :: label
        character(len=*),  intent(in),  optional :: default
        integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets a list of values from the <TT>config</TT> object.  

<P>
Supported values for &lt;value list argument&gt; are:
        <DL>
<DT></DT>
<DD>character(len=*), intent(out)            :: valueList(:)
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), intent(inout)      :: valueList(:)
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), intent(inout)      :: valueList(:)
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(inout)   :: valueList(:)
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(inout)   :: valueList(:)
        
</DD>
<DT></DT>
<DD>logical, intent(inout)                   :: valueList(:)
        
</DD>
</DL>

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value list argument&gt;</STRONG></DT>
<DD>Returned value.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of returned values expected.  
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifing label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if <TT>label</TT> is not found in <TT>config</TT> object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060931200000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_ConfigGetChar - Get a character attribute value from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ConfigGetChar(config, value, &amp;
         label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)         :: config
       character,         intent(out)           :: value
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),  optional :: label
       character,         intent(in),  optional :: default
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets a character <TT>value</TT> from the <TT>config</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>Returned value. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if label is not found in configuration object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931300000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_ConfigGetDim - Get table sizes from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigGetDim(config, lineCount, columnCount, &amp;
       label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)         :: config
       integer,           intent(out)           :: lineCount
       integer,           intent(out)           :: columnCount
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),  optional :: label
       integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Returns the number of lines in the table in <TT>lineCount</TT> and 
    the maximum number of words in a table line in <TT>columnCount</TT>.

<P>
After the call, the line pointer is positioned to the end of the table.
    To reset it to the beginning of the table, use <TT>ESMF_ConfigFindLabel</TT>. 

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>lineCount</STRONG></DT>
<DD>Returned number of lines in the table. 
     
</DD>
<DT><STRONG>columnCount</STRONG></DT>
<DD>Returned maximum number of words in a table line. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label (if present), otherwise current line.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931400000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_ConfigGetLen - Get the length of the line in words from Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     integer function ESMF_ConfigGetLen(config, label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),   optional :: label
       integer,           intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Gets the length of the line in words by counting words
   disregarding types.  Returns the word count as an integer.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label.   If not specified, use the current line.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931500000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_ConfigIsCreated - Check whether a Config object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_ConfigIsCreated(config, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_ConfigIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config), intent(in)            :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,           intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>config</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD><TT>ESMF_Config</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931600000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_ConfigLoadFile - Load resource file into Config object memory</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigLoadFile(config, filename, &amp;
       delayout, &amp; ! DEPRECATED ARGUMENT
       unique, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config),   intent(inout)         :: config
       character(len=*),    intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_DELayout), intent(in),  optional :: delayout  ! DEPRECATED ARGUMENT
       logical,             intent(in),  optional :: unique
       integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.5.0</STRONG></DT>
<DD>Added support for loading basic YAML files.
<BR>
Marked argument <TT>delayout</TT> as deprecated. This argument was
      never used internally, and it is unclear what the original intention was.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
The resource file named <TT>filename</TT> is loaded into memory. Both the
    classic Config file format, described in this document, and the YAML file
    format are supported. YAML support is limited to a small subset of the full
    YAML language specification, allowing access through the classic Config API.
    Specifically, in YAML mode, the top level is expected to be a mapping
    (dictionary) of scalar keys to the following value options:
    
<UL>
<LI>Scalars
</LI>
<LI>List of scalars
</LI>
<LI>List of lists of scalars
    
</LI>
</UL>
    All other YAML constructs are silently ignored when loaded through this
    interface. Constructs successfully ingested become available in the
    <TT>config</TT> object, and can be accessed via the regular <TT>ESMF_Config</TT>
    methods.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of the configuration file. Files ending in <TT>.yaml</TT>, <TT>.yml</TT>,
       or any combination of upper and lower case letters that can be mapped
       to these two options, are interpreted as YAML files. All other names
       are interpreted as classic Config files.
     
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>! DEPRECATED ARGUMENT
       <TT>ESMF_DELayout</TT> associated with this <TT>config</TT> object.
       This argument is not currently used.
     
</DD>
<DT><STRONG>[unique]</STRONG></DT>
<DD>If specified as true, uniqueness of labels are checked and 
       error code set if duplicates found.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931700000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_ConfigLog - Write content of Config object to log</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_ConfigLog(config, raw, prefix, logMsgFlag, &amp;
     log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config),      intent(in)              :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: raw
     character (len=*),      intent(in),    optional :: prefix
     type(ESMF_LogMsg_Flag), intent(in),    optional :: logMsgFlag
     type(ESMF_Log),         intent(inout), optional :: log
     integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write content of <TT>ESMF_Config</TT> object to ESMF log.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object to be logged.
     
</DD>
<DT><STRONG>[raw]</STRONG></DT>
<DD>For <TT>.true.</TT> output the internal buffer as is, for <TT>.false.</TT>
       output in the interpreted format. The default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[prefix]</STRONG></DT>
<DD>String to prefix the memory info message. Default is no prefix.
     
</DD>
<DT><STRONG>[logMsgFlag]</STRONG></DT>
<DD>Type of log message generated. See section <A HREF="#const:logmsgflag">49.2.3</A> for
       a list of valid message types. Default is <TT>ESMF_LOGMSG_INFO</TT>.
     
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD><TT>ESMF_Log</TT> object that can be used instead of the default Log.
       Default is to use the default log.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931800000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_ConfigNextLine - Find next line in a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigNextLine(config, tableEnd, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,           intent(out),  optional :: tableEnd
       integer,           intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Selects the next line (for tables).

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[tableEnd]</STRONG></DT>
<DD>Returns <TT>.true.</TT> if end of table mark (::) is encountered.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931900000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_ConfigPrint - Write content of Config object to unit</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigPrint(config, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(in)  :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional, intent(in)  :: unit
       integer, optional, intent(out) :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write content of input <TT>ESMF_Config</TT> object to unit <TT>unit</TT>.
     If <TT>unit</TT> not provided, writes to standard output.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>The input <TT>ESMF_Config</TT> object.
       
</DD>
<DT><STRONG>[unit]</STRONG></DT>
<DD>Output unit. Defaults to <TT>stdout</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060932000000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_ConfigSetAttribute - Set a value in Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_ConfigSetAttribute(config, &lt;value argument&gt;, &amp;
         label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)           :: config
       &lt;value argument&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),   optional  :: label
       integer,           intent(out),  optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Sets a value in the <TT>config</TT> object.

<P>
Supported values for &lt;value argument&gt; are:
        <DL>
<DT></DT>
<DD>character(len=*),        intent(in)            :: value
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in)            :: value
        
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>Value to set. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying attribute label. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060932100000000000000">
<SPAN CLASS="arabic">47</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_ConfigValidate - Validate a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigValidate(config, &amp;
       options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in),   optional :: options
       integer,           intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>config</TT> object is valid.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD><TT>ESMF_Config</TT> object to be validated.
     
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>If none specified:  simply check that the buffer is not full and the
         pointers are within range.
       "unusedAttributes" - Report to the default logfile all attributes not
         retrieved via a call to <TT>ESMF_ConfigGetAttribute()</TT> or
         <TT>ESMF_ConfigGetChar()</TT>.  The attribute name (label) will be
         logged via <TT>ESMF_LogErr</TT> with the WARNING log message type.
         For an array-valued attribute, retrieving at least one value via
         <TT>ESMF_ConfigGetAttribute()</TT> or <TT>ESMF_ConfigGetChar()</TT>
         constitutes being "used."

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       Equals <TT>ESMF_RC_ATTR_UNUSED</TT> if any unused attributes are found
       with option "unusedAttributes" above.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION060100000000000000000">
<SPAN CLASS="arabic">48</SPAN> HConfig Class</A>
</H1>

<H2><A NAME="SECTION060101000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:HConfig"></A>
<P>
The ESMF HConfig class implements a hierarchical configuration facility that is
compatible with YAML Ain't Markup Language (YAML<SUP><SMALL>TM</SMALL></SUP>). ESMF HConfig
can be understood as a Fortran interface to YAML. However, no claim is made that
<EM>all</EM> YAML language features are supported in their entirety.

<P>
The purpose of the HConfig class under ESMF is to provide a migration path
toward more standard configuration management for ESMF applications. To this end
ESMF_HConfig integrates with the traditional ESMF_Config class. Through this
integration the traditional Config class API offers basic access to YAML
configuration files, in addition to providing backward compatible support of the
traditional config file format. This is discussed in more detail in the Config
class section. For more complete YAML support, applications are encouraged to
migrate to the HConfig API discussed in this section.

<H2><A NAME="SECTION060102000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION060102100000000000000"></A>
<A NAME="const:hconfigmatch"></A>
<BR>
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_HCONFIGMATCH
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Indicates the level to which two HConfig variables match.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_HConfigMatch_Flag)</TT>

<P>
The valid values in ascending order are:
<DL>
<DT><STRONG>ESMF_HCONFIGMATCH_INVALID:</STRONG></DT>
<DD>Indicates a non-valid matching level. One
  or both HConfig objects are invalid.
</DD>
<DT><STRONG>ESMF_HCONFIGMATCH_NONE:</STRONG></DT>
<DD>The lowest valid level of HConfig matching.
  This indicates that the HConfig objects are valid, but their YAML
  representation does not match.
</DD>
<DT><STRONG>ESMF_HCONFIGMATCH_EXACT:</STRONG></DT>
<DD>There is an exact match between the YAML
  representation of both HConfig objects. They may or may not be aliases to
  the same object in memory.
</DD>
<DT><STRONG>ESMF_HCONFIGMATCH_ALIAS:</STRONG></DT>
<DD>Both HConfig variables are aliases to the
  exact same HConfig object in memory.
</DD>
</DL>

<H2><A NAME="SECTION060103000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how a user typically interacts with the
HConfig API. The HConfig class introduces two derived types:

<UL>
<LI><TT>ESMF_HConfig</TT>
</LI>
<LI><TT>ESMF_HConfigIter</TT>
</LI>
</UL>

<P>
<TT>ESMF_HConfig</TT> objects can be created explicitly by the user, or they
can be accessed from an existing <TT>ESMF_Config</TT> object, e.g. queried from
a Component. They can play a number of roles when interacting with
a HConfig hierarchy:

<P>

<OL>
<LI>The root node of the entire hierarchy. In YAML terminology, this
refers to a <EM>document</EM>.
</LI>
<LI><EM>Any</EM> node within the hierarchy.
</LI>
<LI>Collection of hierarchies, i.e. a set of YAML <EM>documents</EM>.
</LI>
</OL>

<P>
<TT>ESMF_HConfigIter</TT> objects are iterators, <EM>referencing</EM> a specific
node within the hierarchy. They are created from <TT>ESMF_HConfig</TT> objects.
The iterator approach allows convenient sequential traversal of a particular
location in the HConfig hierarchy. There are <EM>two</EM> flavors of iterators in
HConfig: <EM>sequence</EM> and <EM>map</EM> iterators.
Both are represented by the same <TT>ESMF_HConfigIter</TT> derived type, and the
distinction is made at run-time.

<P>
Notice that there are redundancies built into the HConfig API, where different
ways are available to achieve the same goal. This is mostly done for
convenience, allowing the user to pick the approach most suitable to their
needs.

<P>
For instance, while it can be convenient to use iterators in some cases, in
others, it might be more appropriate to access elements directly by <EM>index</EM>
(for sequences) or <EM>key</EM> (for maps). Both options are available.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060103100000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Create an empty HConfig object</A>
</H3>

<P>
By default, <TT>ESMF_HConfigCreate()</TT> creates an empty HConfig object.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060103200000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Set HConfig from string using YAML syntax</A>
</H3>

<P>
An empty HConfig object can be set directly from a string using YAML
   syntax.
<P>
<PRE>
  call ESMF_HConfigSet(hconfig, content="[1, 2, 3, abc, b, TRUE]", rc=rc)
</PRE>

<P>
This sets <TT>hconfig</TT> as a <EM>sequence</EM> of six scalar members. 

<P>

<H3><A NAME="SECTION060103300000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Iterator based HConfig sequence parsing</A>
</H3>

<P>
One way to parse the elements contained in <TT>hconfig</TT> is to use the
   iterator pattern known from laguages such as C++ or Python. HConfig
   iterators are implemented as <TT>type(ESMF_HConfigIter)</TT> objects that
   are initialized using one of the <TT>HConfigIter*()</TT> methods. An iterator
   can then be used to traverse the elements in a <EM>sequence</EM> or <EM>map</EM>
   by calling the <TT>ESMF_HConfigIterNext()</TT> method, taking one step forward
   each time the method is called.

<P>
Being a HConfig object, an iterator can be passed into any of the usual
   HConfig methods. The operation is applied to the element that the iterator is
   currently referencing. 

<P>
Notice that iterators are merely references, not associated with their own
   deep allocation. This is reflected in the fact that iterators are
   <EM>not</EM> created by an assignment that has a <TT>Create()</TT> call on the right
   hand side. As such, HConfig iterators need <EM>not</EM> be destroyed
   explicitly when done.

<P>
Two special HConfig iterators are defined, referencing the beginning and
   the end of a HConfig sequence or map object.
<P>
<PRE>
  ! type(ESMF_HConfigIter) :: hconfigIterBegin, hconfigIterEnd
  hconfigIterBegin = ESMF_HConfigIterBegin(hconfig, rc=rc)
</PRE>

<P>
<PRE>
  hconfigIterEnd = ESMF_HConfigIterEnd(hconfig, rc=rc)
</PRE>

<P>
In analogy to the C++ iterator pattern, <TT>hconfigIterBegin</TT> points to the
   first element in <TT>hconfig</TT>, while <TT>hconfigIterEnd</TT> points one step
   beyond the last element. Using these elements together, an iterator loop
   can be written in the following intuitive way, using <TT>hconfigIter</TT> as the
   loop variable.
<P>
<PRE>
  ! type(ESMF_HConfigIter) :: hconfigIter
  hconfigIter = hconfigIterBegin
  do while (hconfigIter /= hconfigIterEnd)

    ! Code here that uses hconfigIter
    ! to access the currently referenced
    ! element in hconfig.  .......

    call ESMF_HConfigIterNext(hconfigIter, rc=rc)
</PRE>

<P>
<PRE>
  enddo
</PRE>

<P>
One <EM>major</EM> concern with the above iterator loop implementation is when
   Fortran <TT>cycle</TT> statements are introduced. In orde to make the above loop
   <TT>cycle</TT>-safe, each such <TT>cycle</TT> statement needs to be matched with
   its own call to <TT>ESMF_HConfigIterNext()</TT>. This needs to be done to
   prevent endless-loop conditions, where the exit condition of the
   <TT>do while</TT> is never reached.

<P>
The <TT>cycle</TT>-safe alternative implementation of the iterator loop
   leverages the <TT>ESMF_HConfigIterLoop()</TT> function instead of 
   <TT>ESMF_HConfigIterNext()</TT>. This approach is more akin to the
   C++
   <PRE>
     for (element : container){
       ...
     }
</PRE>
   or the Python
   <PRE>
     for element in container:
       ...
</PRE>
   approach. It is the preferable way to write HConfig iterator loops due to its
   simplicity and inherent <TT>cycle</TT>-safety.

<P>
The <TT>ESMF_HConfigIterLoop()</TT> function takes three required arguments.
   The first is the loop iterator, followed by the begin and end iterators. The
   loop iterator must enter equal to the begin iterator at the start of the loop.
   Each time the <TT>ESMF_HConfigIterLoop()</TT> function is called, the loop
   iterator is stepped forward as appropriate, and the exit condition of having
   reached the end iterator is checked. Having both the stepping and exit logic
   in one place provided by the HConfig API simplifies the usage. In addition,
   the approach is <TT>cycle</TT>-safe: no matter where a <TT>cycle</TT> statement is
   inserted in the loop body, it always brings the execution back to the top of
   the while loop, which in turn calls the <TT>ESMF_HConfigIterLoop()</TT>
   function.
<P>
<PRE>
  ! type(ESMF_HConfigIter) :: hconfigIter
  hconfigIter = hconfigIterBegin
  do while (ESMF_HConfigIterLoop(hconfigIter, hconfigIterBegin, hconfigIterEnd, rc=rc))
</PRE>

<P>
<PRE>
    ! Check whether the current element is a scalar.
    ! logical :: isScalar
    isScalar = ESMF_HConfigIsScalar(hconfigIter, rc=rc)
</PRE>

<P>
<PRE>
    if (isScalar) then

      ! Any scalar can be accessed as a string.
      ! character(len=:), allocatable :: string
      string = ESMF_HConfigAsString(hconfigIter, rc=rc)
</PRE>

<P>
<PRE>
      ! The attempt can be made to interpret the scalar as any of the other
      ! supported data types. By default, if the scalar cannot be interpreted
      ! as the requested data type, rc /= ESMF_SUCCESS is returned. To prevent
      ! such error condition, the optional, intent(out) argument "asOkay" can
      ! be provided. If asOkay == .true. is returned, the interpretation was
      ! successful. Otherwise asOkay == .false. is returned.

      ! logical :: asOkay

      ! integer(ESMF_KIND_I4) :: valueI4
      valueI4 = ESMF_HConfigAsI4(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! integer(ESMF_KIND_I8) :: valueI8
      valueI8 = ESMF_HConfigAsI8(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! real(ESMF_KIND_R4) :: valueR4
      valueR4 = ESMF_HConfigAsR4(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! real(ESMF_KIND_R8) :: valueR8
      valueR8 = ESMF_HConfigAsR8(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! logical :: valueL
      valueL = ESMF_HConfigAsLogical(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
    else
      ! Possible recursive iteration over the current hconfigIter element.
    endif

  enddo
</PRE>

<P>

<H3><A NAME="SECTION060103400000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Index based random access HConfig sequence parsing</A>
</H3>

<P>
An alternative way to loop over the elements contained in <TT>hconfig</TT>,
   and parsing them, is to use an <TT>index</TT> variable. For this approach the
   size of <TT>hconfig</TT> is queried.
<P>
<PRE>
  ! integer :: size
  size = ESMF_HConfigGetSize(hconfig, rc=rc)
</PRE>

<P>
Then looping over the elements is done with a simple do loop. Index based
   access allows random order of access, versus the iterator approach that
   only supports begin to end iteration. This is demonstrated here by writing
   the do loop in reverse order.
<P>
<PRE>
  ! integer :: i
  do i=size, 1, -1

    ! Check whether the current element is a scalar.
    ! logical :: isScalar
    isScalar = ESMF_HConfigIsScalar(hconfig, index=i, rc=rc)
</PRE>

<P>
<PRE>
    if (isScalar) then

      ! Any scalar can be accessed as a string.
      ! character(len=:), allocatable :: string
      string = ESMF_HConfigAsString(hconfig, index=i, rc=rc)
</PRE>

<P>
<PRE>
      ! The attempt can be made to interpret the scalar as any of the other
      ! supported data types. By default, if the scalar cannot be interpreted
      ! as the requested data type, rc /= ESMF_SUCCESS is returned. To prevent
      ! such error condition, the optional, intent(out) argument "asOkay" can
      ! be provided. If asOkay == .true. is returned, the interpretation was
      ! successful. Otherwise asOkay == .false. is returned.
      ! logical :: asOkay

      ! integer(ESMF_KIND_I4) :: valueI4
      valueI4 = ESMF_HConfigAsI4(hconfig, index=i, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! integer(ESMF_KIND_I8) :: valueI8
      valueI8 = ESMF_HConfigAsI8(hconfig, index=i, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! real(ESMF_KIND_R4) :: valueR4
      valueR4 = ESMF_HConfigAsR4(hconfig, index=i, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! real(ESMF_KIND_R8) :: valueR8
      valueR8 = ESMF_HConfigAsR8(hconfig, index=i, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! logical :: valueL
      valueL = ESMF_HConfigAsLogical(hconfig, index=i, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
    else
      ! Possible recursive iteration over the current index=i element.
    endif
  enddo
</PRE>

<P>
The above loop is safe with respect to <TT>index</TT> potentially being specified
   with an out-of-range value. This is because <TT>ESMF_HConfigIsScalar()</TT>
   returns <TT>.false.</TT> in this case. There are only four valid options of what
   <TT>type</TT> a valid HConfig element can be. Each has an associated <TT>Is</TT>
   method:
   
<UL>
<LI>Null: <TT>ESMF_HConfigIsNull()</TT>
</LI>
<LI>Scalar: <TT>ESMF_HConfigIsScalar()</TT>
</LI>
<LI>Sequence: <TT>ESMF_HConfigIsSequence()</TT>
</LI>
<LI>Map: <TT>ESMF_HConfigIsMap()</TT>
   
</LI>
</UL>
   The general check to see whether an index points to a valid element is
   provided by <TT>ESMF_HConfigIsDefined()</TT>.
<P>
<PRE>
  ! logical :: isDefined
  isDefined = ESMF_HConfigIsDefined(hconfig, index=10, rc=rc)
</PRE>

<P>
This returns <TT>isDefined == .false.</TT> because for <TT>hconfig</TT> a value of
   <TT>index=10</TT> is out of range. 

<P>

<H3><A NAME="SECTION060103500000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Destroy a HConfig object</A>
</H3>

<P>
When done with <TT>hconfig</TT>, it should be destroyed in the usual manner.
<P>
<PRE>
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060103600000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Create a HConfig object directly loading from YAML string</A>
</H3>

<P>
The <TT>ESMF_HConfigCreate()</TT> method supports loading contents from
   string using YAML syntax directly via the optional <TT>content</TT> argument.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(content="{car: red, bike: 22, plane: TRUE}", rc=rc)
</PRE>

<P>
Here a map is created. In this case, all of the keys are scalars (car,
   bike, plane), as are all of the associated values (red, 22, TRUE). 

<P>

<H3><A NAME="SECTION060103700000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Iterator based HConfig map parsing</A>
</H3>

<P>
The elements of the <EM>map</EM> contained in <TT>hconfig</TT> can be iterated over
   analogous to the <EM>sequence</EM> case demonstrated earlier. Again the begin
   and end iterator variables are defined.
<P>
<PRE>
  ! type(ESMF_HConfigIter) :: hconfigIterBegin, hconfigIterEnd
  hconfigIterBegin = ESMF_HConfigIterBegin(hconfig, rc=rc)
</PRE>

<P>
<PRE>
  hconfigIterEnd = ESMF_HConfigIterEnd(hconfig, rc=rc)
</PRE>

<P>
Then iterate over the elements in <TT>hconfig</TT> using an iterator loop
   variable as before.

<P>
The difference of the code below, compared to the <EM>sequence</EM> case, is
   that all the <TT>As</TT> access methods here are either of the form
   <TT>As*MapKey</TT> or <TT>As*MapVal</TT>. This is necessary to selectively access
   the <EM>map key</EM> or <EM>map value</EM>, respectively.
<P>
<PRE>
  ! type(ESMF_HConfigIter) :: hconfigIter
  hconfigIter = hconfigIterBegin
  do while (ESMF_HConfigIterLoop(hconfigIter, hconfigIterBegin, hconfigIterEnd, rc=rc))
</PRE>

<P>
<PRE>
    ! Check whether the current element is a scalar both for the map key
    ! and the map value.
    ! logical :: isScalar
    isScalar = ESMF_HConfigIsScalarMapKey(hconfigIter, rc=rc)
</PRE>

<P>
<PRE>
    isScalar = isScalar .and. ESMF_HConfigIsScalarMapVal(hconfigIter, rc=rc)
</PRE>

<P>
<PRE>
    if (isScalar) then

      ! Any scalar can be accessed as a string. Use this for the map key.
      ! character(len=:), allocatable :: stringKey
      stringKey = ESMF_HConfigAsStringMapKey(hconfigIter, rc=rc)
</PRE>

<P>
<PRE>
      ! Now access the map value. Again first access as a string, which
      ! always works.
      ! character(len=:), allocatable :: string
      string = ESMF_HConfigAsStringMapVal(hconfigIter, rc=rc)
</PRE>

<P>
<PRE>
      ! The attempt can be made to interpret the scalar as any of the other
      ! supported data types. By default, if the scalar cannot be interpreted
      ! as the requested data type, rc /= ESMF_SUCCESS is returned. To prevent
      ! such error condition, the optional, intent(out) argument "asOkay" can
      ! be provided. If asOkay == .true. is returned, the interpretation was
      ! successful. Otherwise asOkay == .false. is returned.
      ! logical :: asOkay

      ! integer(ESMF_KIND_I4) :: valueI4
      valueI4 = ESMF_HConfigAsI4MapVal(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! integer(ESMF_KIND_I8) :: valueI8
      valueI8 = ESMF_HConfigAsI8MapVal(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! real(ESMF_KIND_R4) :: valueR4
      valueR4 = ESMF_HConfigAsR4MapVal(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! real(ESMF_KIND_R8) :: valueR8
      valueR8 = ESMF_HConfigAsR8MapVal(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! logical :: valueL
      valueL = ESMF_HConfigAsLogicalMapVal(hconfigIter, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
    else
      ! Deal with case where either key or value are not scalars themselves.
    endif

  enddo
</PRE>

<P>

<H3><A NAME="SECTION060103800000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Key based random access HConfig map parsing</A>
</H3>

<P>
The <EM>map values</EM> stored in <TT>hconfig</TT> can be accessed
   in random order providing the <EM>map key</EM>.

<P>
To demonstrate this, a temporary array holding keys in random order is defined.
<P>
<PRE>
  ! character(5) :: keyList(3)
  keyList = ["bike ", "plane", "car  "]
</PRE>

<P>
Then loop over the elements of <TT>keyList</TT> and use them as <EM>map key</EM>
   to access the <EM>map values</EM> in <TT>hconfig</TT>.
<P>
<PRE>
  ! integer :: i
  do i=1,3

    ! Ensure that all white space padding is removed.
    ! character :: stringKey
    stringKey = trim(keyList(i))

    ! Check whether the accessed map value is a scalar.
    ! logical :: isScalar
    isScalar = ESMF_HConfigIsScalar(hconfig, keyString=stringKey, rc=rc)
</PRE>

<P>
<PRE>
    if (isScalar) then

      ! Access as a string always works.
      ! character(len=:), allocatable :: string
      string = ESMF_HConfigAsString(hconfig, keyString=stringKey, rc=rc)
</PRE>

<P>
<PRE>
      ! The attempt can be made to interpret the scalar as any of the other
      ! supported data types. By default, if the scalar cannot be interpreted
      ! as the requested data type, rc /= ESMF_SUCCESS is returned. To prevent
      ! such error condition, the optional, intent(out) argument "asOkay" can
      ! be provided. If asOkay == .true. is returned, the interpretation was
      ! successful. Otherwise asOkay == .false. is returned.
      ! logical :: asOkay

      ! integer(ESMF_KIND_I4) :: valueI4
      valueI4 = ESMF_HConfigAsI4(hconfig, keyString=stringKey, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! integer(ESMF_KIND_I8) :: valueI8
      valueI8 = ESMF_HConfigAsI8(hconfig, keyString=stringKey, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! real(ESMF_KIND_R4) :: valueR4
      valueR4 = ESMF_HConfigAsR4(hconfig, keyString=stringKey, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! real(ESMF_KIND_R8) :: valueR8
      valueR8 = ESMF_HConfigAsR8(hconfig, keyString=stringKey, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
      ! logical :: valueL
      valueL = ESMF_HConfigAsLogical(hconfig, keyString=stringKey, asOkay=asOkay, rc=rc)
</PRE>

<P>
<PRE>
    else
      ! Deal with case where either key or value are not scalars themselves.
    endif

  enddo
</PRE>

<P>
The above loop is safe with respect to <TT>stringKey</TT> potentially
   specifying a value that is not a valid <EM>map key</EM>. This is because
   <TT>ESMF_HConfigIsScalar()</TT> returns <TT>.false.</TT> in this case.

<P>
The general check to see whether a <EM>map key</EM> refers to a valid element
   is provided by <TT>ESMF_HConfigIsDefined()</TT>.
<P>
<PRE>
  ! logical :: isDefined
  isDefined = ESMF_HConfigIsDefined(hconfig, keyString="bad-key", rc=rc)
</PRE>

<P>
This returns <TT>isDefined == .false.</TT> because <TT>hconfig</TT> does not
   contain <TT>"bad-key"</TT> as one of its valid <EM>map keys</EM>.

<P>
Finally destroy <TT>hconfig</TT> when done.
<P>
<PRE>
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060103900000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Access HConfig from Config</A>
</H3>

<P>
The <TT>ESMF_Config</TT> class can be queried for a HConfig object. This allows
   the use of the HConfig API to access information contained in a Config object.
<P>
<PRE>
  ! type(ESMF_Config) :: config
  ! type(ESMF_HConfig) :: hconfig
  call ESMF_ConfigGet(config, hconfig=hconfig, rc=rc)
</PRE>

<P>
The <TT>hconfig</TT> obtained this way is indistinguishable from an explicitly
   created HConfig instance. E.g. it can be queried for its <EM>type</EM> using the
   <TT>Is</TT> methods:
<P>
<PRE>
  ! logical :: isDefined
  isDefined = ESMF_HConfigIsDefined(hconfig, rc=rc)
</PRE>

<P>
<PRE>
  ! logical :: isNull
  isNull = ESMF_HConfigIsNull(hconfig, rc=rc)
</PRE>

<P>
<PRE>
  ! logical :: isSequence
  isSequence = ESMF_HConfigIsSequence(hconfig, rc=rc)
</PRE>

<P>
<PRE>
  ! logical :: isMap
  isMap = ESMF_HConfigIsMap(hconfig, rc=rc)
</PRE>

<P>
Once done with <TT>hconfig</TT> it must <EM>not</EM> be destroyed explicitly by
   the user. The <TT>hconfig</TT> is still owned by the <TT>config</TT> object, and
   will be destroyed automatically when the <TT>config</TT> object is destroyed.
   This follows the simple rule that a user only owns those objects created
   explicitly by calling a <TT>Create()</TT> method. 

<P>

<H3><A NAME="SECTION0601031000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Load HConfig from YAML file</A>
</H3>

<P>
One option to load a YAML file is to first create an empty HConfig object,
   followed by calling <TT>ESMF_HConfigFileLoad()</TT>.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigFileLoad(hconfig, filename="example.yaml", rc=rc)
</PRE>

<P>
<PRE>
  ! When done destroy as usual.
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>
The alternative option is to create and load the HConfig object in a single
   call to <TT>ESMF_HConfigCreate()</TT> using the optional <TT>filename</TT>
   argument to specify the YAML file.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(filename="example.yaml", rc=rc)
</PRE>

<P>
<PRE>
  ! And again destroy hconfig when done with it.
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION0601031100000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Save HConfig to YAML file</A>
</H3>

<P>
A HConfig object can be saved to a YAML file by calling the
   <TT>ESMF_HConfigFileSave()</TT> method. To demonstrate this, a YAML file
   containing:
   <PRE>
   # An example of YAML configuration file
  
   simple_list: [1, 2, 3, abc, b, TRUE]
   simple_map:
     car: red
     [bike, {p1: 10, p2: 20}]: [bmx, mountain, street]
     plane: [TRUE, FALSE]
</PRE>

<P>
is loaded to create the <TT>hconfig</TT> object:
<P>
<PRE>
  hconfig = ESMF_HConfigCreate(filename="example.yaml", rc=rc)
</PRE>

<P>
Now the <TT>hconfig</TT> object can be saved to file using the
   <TT>ESMF_HConfigFileSave()</TT> method.
<P>
<PRE>
  call ESMF_HConfigFileSave(hconfig, filename="saveMe.yml", rc=rc)
</PRE>

<P>
Notice that the resulting contents of file <TT>saveMe.yml</TT> does <EM>not</EM>
   contain the comments of the original file. The YAML structure is saved.
   <PRE>
   simple_list: [1, 2, 3, abc, b, TRUE]
   simple_map:
     car: red
     [bike, {p1: 10, p2: 20}]: [bmx, mountain, street]
     plane: [TRUE, FALSE]
</PRE>

<P>
The object specified in <TT>ESMF_HConfigFileSave()</TT> can be a regular node
   (of any type) or a <EM>sequence</EM> iterator. In either case the file written
   represents the YAML hierarchy with the specified object as the root node.

<P>
In the case of a <EM>map</EM> iterator, it is necessary to first create an
   appropriate root node utilizing the appropriate <TT>CreateAt</TT> method. This
   allows saving either the <EM>map key</EM> or <EM>map value</EM> node at the
   current iterator. This is demonstrated below.

<P>
In the current example, where <TT>hconfig</TT> is a map with two elements, a
   map iterator can be set to the beginning using the following call.
<P>
<PRE>
  ! type(ESMF_HConfigIter) :: hconfigIter
  hconfigIter = ESMF_HConfigIterBegin(hconfig, rc=rc)
</PRE>

<P>
Here <TT>hconfigIter</TT> cannot be saved to file directly. To write the
   <EM>key</EM> node, first create a HConfig object for it using method
   <TT>ESMF_HConfigCreateAtMapKey()</TT>.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = ESMF_HConfigCreateAtMapKey(hconfigIter, rc=rc)
</PRE>

<P>
Then save it.
<P>
<PRE>
  call ESMF_HConfigFileSave(hconfigTemp, filename="mapKeyBegin.yaml", rc=rc)
</PRE>

<P>
And finally destroy <TT>hconfigTemp</TT> again.
<P>
<PRE>
  call ESMF_HConfigDestroy(hconfigTemp, rc=rc)
</PRE>

<P>
Similarly, to write the <EM>value</EM> node to file, first create a HConfig
   object for it using method <TT>ESMF_HConfigCreateAtMapVal()</TT>.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = ESMF_HConfigCreateAtMapVal(hconfigIter, rc=rc)
</PRE>

<P>
Then save it.
<P>
<PRE>
  call ESMF_HConfigFileSave(hconfigTemp, filename="mapValBegin.yaml", rc=rc)
</PRE>

<P>
And destroy it.
<P>
<PRE>
  call ESMF_HConfigDestroy(hconfigTemp, rc=rc)
</PRE>

<P>
Since <TT>hconfig</TT> is a <EM>map</EM> node, it is also possible to directly
   create a <EM>value</EM> node by calling <TT>ESMF_HConfigCreateAt()</TT>
   on it, using the desired <EM>key</EM>.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = ESMF_HConfigCreateAt(hconfig, keyString="simple_map", rc=rc)
</PRE>

<P>
Now <TT>hconfigTemp</TT> points to the <EM>value</EM> node, that is
   associated with the "simple_map" key, which is in turn a map:
   <PRE>
   car: red
   [bike, {p1: 10, p2: 20}]: [bmx, mountain, street]
   plane: [TRUE, FALSE]
</PRE>
   It can be saved to file as usual.
<P>
<PRE>
  call ESMF_HConfigFileSave(hconfigTemp, filename="mapValAtKey.yaml", rc=rc)
</PRE>

<P>
Any of the <EM>value</EM> nodes of <TT>hconfigTemp</TT> can be accessed through
   recursive usage of the <TT>ESMF_HConfigCreateAt()</TT> method.
   For example, the following call accesses the <EM>value</EM> node that is
   associated with <TT>keyString="[bike, p1: 10, p2: 20]"</TT>. Here the
   <TT>keyString</TT> is interpreted as YAML syntax, for which an internal HConfig
   representation is created, and finally the map held by <TT>hconfigTemp</TT> is
   searched for a matching key.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp2
  hconfigTemp2 = ESMF_HConfigCreateAt(hconfigTemp, &amp;
    keyString="[bike, {p1: 10, p2: 20}]", rc=rc)
</PRE>

<P>
Now <TT>hconfigTemp2</TT> points to the <EM>sequence node</EM> with contents
   <TT>[bmx, mountain, street]</TT>. It, too, can be saved to file.
<P>
<PRE>
  call ESMF_HConfigFileSave(hconfigTemp2, filename="mapValRecursive.yaml", rc=rc)
</PRE>

<P>
Finally <TT>hconfigTemp2</TT>, <TT>hconfigTemp</TT> and <TT>hconfig</TT> should be destroyed.
<P>
<PRE>
  call ESMF_HConfigDestroy(hconfigTemp2, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigDestroy(hconfigTemp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION0601031200000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Tags and Schemas</A>
</H3>

<P>
The HConfig class implements tags to identify a node's data type according to
   the YAML standard. The combination of a set of defined tags and a mechanism
   to resolve non-specific tags is called a schema under YAML. The HConfig class
   implements the YAML Core schema, which is an extension of the JSON schema.

<P>
This example starts with an empty HConfig object.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(rc=rc)
</PRE>

<P>
Method <TT>ESMF_HConfigGetTag()</TT> is used to query the tag.
<P>
<PRE>
  ! character(len=:), allocatable :: tag
  tag = ESMF_HConfigGetTag(hconfig, rc=rc)
</PRE>

<P>

<H4><A NAME="SECTION0601031210000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN> Null</A>
</H4>
   The <TT>hconfig</TT> is an empty object, in other words it is associated with
   NULL. The Core schema tag for this situation is
   <TT><B>tag:yaml.org,2002:null</B></TT>.

<P>
Next, file <TT>exampleWithTags.yaml</TT> is loaded.
<P>
<PRE>
  call ESMF_HConfigFileLoad(hconfig, filename="exampleWithTags.yaml", rc=rc)
</PRE>

<P>
The file contains the following YAML:
   <PRE>
   value_one:    {word1: this, word2: is, word3: a, word4: map}
   value_two:    [this, is, a, list]
   value_three:            123
   value_four:   !!float   123
   value_five:             2.5
   value_six:    !!str     2.5
   value_seven:            False
   value_eight:  !!str     true
   value_nine:             0x234
   value_ten:              Null
   value_eleven:
   value_twelve:  !myStuff xyz
   value_thirteen:         NO
   value_fourteen:         "NO"
</PRE>

<P>
The value associated with <EM>map key</EM> "value_ten" is explicitly set to
   <TT>Null</TT>. The associated tag for this node can be obtained
   directly by supplying the <TT>keyString</TT> argument.
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_ten", rc=rc)
</PRE>

<P>
The resolved Core schema tag is again <TT><B>tag:yaml.org,2002:null</B></TT>. There
   are four special values that resolve to this tag: <TT>null</TT>, <TT>Null</TT>,
   <TT>NULL</TT>, and <TT><SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="16" ALIGN="BOTTOM" BORDER="0"
 SRC="img110.png"
 ALT="$\sim$"></SPAN></TT>. In addition to those special values, an <EM>empty</EM>
   value, as demonstrated by <EM>key</EM> "value_eleven", also automatically
   resolves to <TT><B>tag:yaml.org,2002:null</B></TT>.
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_eleven", rc=rc)
</PRE>

<P>

<H4><A NAME="SECTION0601031220000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">2</SPAN> Map</A>
</H4>
   On the top level, after loading the YAML file, <TT>hconfig</TT> is a map. 
   Querying again for the tag of <TT>hconfig</TT>,
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, rc=rc)
</PRE>

<P>
results in the Core schema tag of <TT><B>tag:yaml.org,2002:map</B></TT>.

<P>

<H4><A NAME="SECTION0601031230000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sequence</A>
</H4>
   The value associated with <EM>map key</EM> "value_two" in the current
   <TT>hconfig</TT> object is a sequence. The tag for this node can be obtained
   directly by supplying the <TT>keyString</TT> argument.
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_two", rc=rc)
</PRE>

<P>
The resolved Core schema tag for a sequence is <TT><B>tag:yaml.org,2002:seq</B></TT>.

<P>

<H4><A NAME="SECTION0601031240000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">4</SPAN> String</A>
</H4>
   All of the <EM>keys</EM> of the currently loaded <TT>hconfig</TT> object are
   strings. To obtain the tag that is associated with the first key node,
   an iterator is used to access the map nodes individually.
<P>
<PRE>
  ! type(ESMF_HConfigIter) :: hconfigIter
  hconfigIter = ESMF_HConfigIterBegin(hconfig, rc=rc)
</PRE>

<P>
Now the <TT>ESMF_HConfigGetTagMapKey()</TT> method can be used to obtain
   the tag for the first key node.
<P>
<PRE>
  tag = ESMF_HConfigGetTagMapKey(hconfigIter, rc=rc)
</PRE>

<P>
Here the Core schema tag resolves to <TT><B>tag:yaml.org,2002:str</B></TT>.

<P>

<H4><A NAME="SECTION0601031250000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">5</SPAN> Integer</A>
</H4>
   The value associated with <EM>map key</EM> "value_three" in the current
   <TT>hconfig</TT> object is an integer number. The tag for this node can be
   obtained as before by directly supplying the <TT>keyString</TT> argument.
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_three", rc=rc)
</PRE>

<P>
The Core schema tag resolves to <TT><B>tag:yaml.org,2002:int</B></TT>.

<P>
The value associated with <EM>map key</EM> "value_nine" in the current
   <TT>hconfig</TT> object is an integer number in hex. The tag for this node can be
   obtained as before by directly supplying the <TT>keyString</TT> argument.
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_nine", rc=rc)
</PRE>

<P>
The Core schema tag resolves to <TT><B>tag:yaml.org,2002:int</B></TT>.

<P>

<H4><A NAME="SECTION0601031260000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">6</SPAN> Floating Point</A>
</H4>
   The value associated with <EM>map key</EM> "value_five" in the current
   <TT>hconfig</TT> object is a floating point number. The tag for this node can be
   obtained as before by directly supplying the <TT>keyString</TT> argument.
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_five", rc=rc)
</PRE>

<P>
The Core schema tag resolves to <TT><B>tag:yaml.org,2002:float</B></TT>.

<P>

<H4><A NAME="SECTION0601031270000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">7</SPAN> Boolean</A>
</H4>
   The value associated with <EM>map key</EM> "value_seven" in the current
   <TT>hconfig</TT> object is a boolean. The tag for this node can be
   obtained as before by directly supplying the <TT>keyString</TT> argument.
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_seven", rc=rc)
</PRE>

<P>
The Core schema tag resolves to <TT><B>tag:yaml.org,2002:bool</B></TT>. The
   supported boolean values are:
   <PRE>
        true   |   false
        True   |   False
        TRUE   |   FALSE
</PRE>

<P>

<H4><A NAME="SECTION0601031280000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">8</SPAN> Additional Boolean values and the "Norway problem"</A>
</H4>
   The YAMLCPP backend used by <TT>ESMF_HConfig</TT> interprets all of the values
   recognized as such under  <A NAME="tex2html61"
  HREF="https://yaml.org/type/bool.html">YAML 1.1</A>
as boolean. This extends the above list with
   additional options:
   <PRE>
        yes    |   no
        Yes    |   No
        YES    |   NO
        y      |   n
        Y      |   N
        on     |   off
        On     |   Off
        ON     |   OFF
</PRE>
   The interpretation of value <TT>NO</TT> as a boolean, instead of a literal
   string, can be problematic. It leads to the so-called <EM>"Norway problem"</EM>,
   because the same string is often used as country code instead. The underlying
   problem is the misinterpretation of values by YAML. 

<P>
Strictly speaking this is not a YAML problem, but instead a schema specific
   issue. Fortunately there are two simple solutions to ensure the correct and
   intended interpretation of values by <TT>ESMF_HConfig</TT>:

<P>

<OL>
<LI>Explicit quotation of strings: See for instance the <EM>map value</EM>
   for <TT>value_fourteen</TT> in the current example. Using explicit quotes for
   <TT>"NO"</TT>, the entry is safely interpreted as a literal string, and if
   queried for its tag, will return <TT>tag:yaml.org,2002:str</TT>.

<P>
</LI>
<LI>Explicit standard tags: This option allows explicit specificaiton of any
   tag, e.g. the standard short-hand tag <TT>!str</TT> for literal strings. This
   approach is discussed in more detal below.
   
</LI>
</OL> 

<P>

<H4><A NAME="SECTION0601031290000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">9</SPAN> Explicit standard tags</A>
</H4>
   Standard short-hand tags can be specified to change the default resolution.
   This is demonstrated for <EM>map keys</EM> "value_four", "value_six", and
   "value_eight".
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_four", rc=rc)
</PRE>

<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_six", rc=rc)
</PRE>

<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_eight", rc=rc)
</PRE>

<P>
The default resolution of these three keys would be
   <TT>tag:yaml.org,2002:int</TT>, <TT>tag:yaml.org,2002:float</TT>, and
   <TT>tag:yaml.org,2002:bool</TT>, respectively. However, with the explict tags
   in place, they are resolved to <TT>tag:yaml.org,2002:float</TT>,
   <TT>tag:yaml.org,2002:str</TT>, <TT>tag:yaml.org,2002:str</TT>, instead.

<P>

<H4><A NAME="SECTION06010312100000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">10</SPAN> Explicit custom tags</A>
</H4>
   The HConfig class supports application-specific local tags as per the YAML
   standard. These are tags that are not known by the Core schema. If such a
   tag is encountered on a node, it is preserved and no further automatic
   tag resolution is performed.

<P>
The value associated with <EM>map key</EM> "value_twelve" in the current
   <TT>hconfig</TT> object has a custom tag. The tag for this node can be
   obtained as before by directly supplying the <TT>keyString</TT> argument.
<P>
<PRE>
  tag = ESMF_HConfigGetTag(hconfig, keyString="value_twelve", rc=rc)
</PRE>

<P>
The returned tag is <TT><B>!myStuff</B></TT>.

<P>
Finally clean up <TT>hconfig</TT>.
<P>
<PRE>
  ! Destroy hconfig when done with it.
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION0601031300000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">13</SPAN> Comparing HConfig objects</A>
</H3>

<P>
The HConfig class follows the standard behavior of ESMF deep classes as
   described in section <A HREF="node2.html#assignment_equality_copy_compare">8.4</A>. To demonstrate
   the operations of assignment, equality, and comparison based on content, we
   start by creating a simple HConfig object.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(content="{car: red, bike: 22, plane: TRUE}", rc=rc)
</PRE>

<P>
A simple assignment results in an alias to the same deep HConfig object.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = hconfig
</PRE>

<P>
The equality <TT>(==)</TT> and inequality <TT>(/=)</TT> operators are
   overloaded to check for the alias condition when used between two
   HConfig objects.
<P>
<PRE>
  ! logical :: isAlias
  isAlias = (hconfigTemp == hconfig)
</PRE>

<P>
<PRE>
  ! logical :: isNotAlias
  isNotAlias = (hconfigTemp /= hconfig)
</PRE>

<P>
Alias equality can also be tested by using the <TT>ESMF_HConfigMatch()</TT>
   function. The return value of this function is of type
   <TT>ESMF_HConfigMatch_Flag</TT>, which allows for a wider range of possible
   comparison results. See section&nbsp;<A HREF="#const:hconfigmatch">48.2.1</A> for all the
   implemented return values.
<P>
<PRE>
  ! type(ESMF_HConfigMatch_Flag)  :: match
  match = ESMF_HConfigMatch(hconfig, hconfigTemp, rc=rc)
</PRE>

<P>
For the case of an alias match, the value of <TT>ESMF_HCONFIGMATCH_ALIAS</TT>
   is returned.
<P>
<PRE>
  isAlias = (match == ESMF_HCONFIGMATCH_ALIAS)
</PRE>

<P>
To demonstrate content matching for HConfig objects that are not aliases, we
   create a separate object with the same content as <TT>hconfig</TT>.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = ESMF_HConfigCreate(content="{car: red, bike: 22, plane: TRUE}", rc=rc)
</PRE>

<P>
The simple alias check now returns <TT>.false.</TT>.
<P>
<PRE>
  ! logical :: isAlias
  isAlias = (hconfigTemp == hconfig)
</PRE>

<P>
However, for two separate HConfig objects that have exactly matching
   content, as is the case for <TT>hconfig</TT> and <TT>hconfigTemp</TT>, function
   <TT>ESMF_HConfigMatch()</TT> returns value <TT>ESMF_HCONFIGMATCH_EXACT</TT>.
<P>
<PRE>
  ! type(ESMF_HConfigMatch_Flag)  :: match
  match = ESMF_HConfigMatch(hconfig, hconfigTemp, rc=rc)
</PRE>

<P>
<PRE>
  ! logical :: isExact
  isExact = (match == ESMF_HCONFIGMATCH_EXACT)
</PRE>

<P>
The values returned by <TT>ESMF_HConfigMatch()</TT> are constructed in
   a monotonically increasing manner to simplify general comparisons that
   ensure two objects are either aliases of each other <EM>or</EM> their content
   matches exactly. This common case is demonstrated in the following code that
   sets <TT>isMatch</TT> to <TT>.true.</TT> for the alias or exact match condition,
   and <TT>.false.</TT> otherwise, using <TT>(&gt;=)</TT> logic.
<P>
<PRE>
  ! logical :: isMatch
  isMatch = (match &gt;= ESMF_HCONFIGMATCH_EXACT)
</PRE>

<P>
While there is an exact match of the content of <TT>hconfig</TT> and
   <TT>hconfigTemp</TT>, they are distinct objects in memory, which can be modified
   independent of each other. E.g. another key-value pair can be added to
   <TT>hconfigTemp</TT> without affecting the content of <TT>hconfig</TT>.
<P>
<PRE>
  call ESMF_HConfigAdd(hconfigTemp, addKeyString="kNew", content=7, rc=rc)
</PRE>

<P>
Now that the content of <TT>hconfig</TT> and <TT>hconfigTemp</TT> differs, function
   <TT>ESMF_HConfigMatch()</TT> returns value <TT>ESMF_HCONFIGMATCH_NONE</TT>.
<P>
<PRE>
  ! type(ESMF_HConfigMatch_Flag)  :: match
  match = ESMF_HConfigMatch(hconfig, hconfigTemp, rc=rc)
</PRE>

<P>
<PRE>
  ! logical :: isNone
  isNone = (match == ESMF_HCONFIGMATCH_NONE)
</PRE>

<P>
Finally clean up both HConfig objects.
<P>
<PRE>
  ! Destroy hconfig when done with it.
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>
<PRE>
  ! Destroy hconfigTemp when done with it.
  call ESMF_HConfigDestroy(hconfigTemp, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION0601031400000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">14</SPAN> Adding, Setting, and Removing elements from HConfig object</A>
</H3>

<P>
After creating a HConfig object without specifying <TT>content</TT> or
   <TT>filename</TT>, it is empty.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(rc=rc)
</PRE>

<P>
Now the <TT>ESMF_HConfigAdd()</TT> method can be used to add new elements to
   an existing HConfig object. The <TT>Add()</TT> interfaces are heavily overloaded,
   each specific entry point featuring a number of optional arguments. The two
   fundamentally different ways of using <TT>Add()</TT> are: (1) adding an element
   at the end of a <EM>sequence</EM> or (2) adding an element to a <EM>map</EM>.
   Here, where <TT>hconfig</TT> is empty, either option is possible. The way the
   first element is added determines whether <TT>hconfig</TT> is a sequence or
   a map.

<P>
The following call adds an element to <TT>hconfig</TT> without specifying the
   <TT>addKey</TT> or <TT>addKeyString</TT> argument. This indicates that a sequence
   element is added to the end, and as a consequence rendering <TT>hconfig</TT>
   a <EM>sequence</EM>.
<P>
<PRE>
  call ESMF_HConfigAdd(hconfig, "first added item", rc=rc)
</PRE>

<P>
Additional elements can be added at the end of <TT>hconfig</TT>.
<P>
<PRE>
  call ESMF_HConfigAdd(hconfig, 12.57_ESMF_KIND_R8, rc=rc)
</PRE>

<P>
At this point, the content of <TT>hconfig</TT> is a sequence with two elements.
   <PRE>
   - first added item
   - 12.5700000000
</PRE>

<P>
It is also possible to add an entire HConfig structure as an item to the
   existing sequence. One way to do this is to use standar YAML syntax when
   adding the element. Here a <EM>map</EM> is added to the end of <TT>hconfig</TT>.
<P>
<PRE>
  call ESMF_HConfigAdd(hconfig, "{k1: 7, k2: 25}", rc=rc)
</PRE>

<P>
This results in the following content, where the third element of the sequence
   is the map that was just added.
   <PRE>
   - first added item
   - 12.5700000000
   - {k1: 7, k2: 25}
</PRE>

<P>
A HConfig structure can even be loaded from file and added to the end of 
   <TT>hconfig</TT>. This requires a temporary HConfig object.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = ESMF_HConfigCreate(filename="example.yaml", rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigAdd(hconfig, hconfigTemp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigDestroy(hconfigTemp, rc=rc)
</PRE>

<P>
The result is the following content for <TT>hconfig</TT>.
   <PRE>
   - first added item
   - 12.5700000000
   - {k1: 7, k2: 25}
   - simple_list: [1, 2, 3, abc, b, TRUE]
     simple_map:
       car: red
       [bike, {p1: 10, p2: 20}]: [bmx, mountain, street]
       plane: [TRUE, FALSE]
</PRE>

<P>
Using the <TT>CreateAt()</TT> method, it is easy to gain access to any specific
   element in <TT>hconfig</TT>. Since <TT>hconfig</TT> is a <EM>sequence</EM>, the proper
   access is by <EM>index</EM>.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = ESMF_HConfigCreateAt(hconfig, index=3, rc=rc)
</PRE>

<P>
This creates a temporary HConfig object that <EM>references</EM> the 3rd element
   of the sequence stored by <TT>hconfig</TT>. If <TT>hconfigTemp</TT> were to be
   saved to file, it would have the following content.
   <PRE>
   {k1: 7, k2: 25}
</PRE>

<P>
Using the <TT>Set()</TT> methods, contents in <TT>hconfigTemp</TT>, and thus in
   the 3rd element of <TT>hconfig</TT> can be modified. The content of
   <TT>hconfigTemp</TT> is a <EM>map</EM>, and the proper access is by <EM>map key</EM>.
   Here key "k2" is being modified.
<P>
<PRE>
  call ESMF_HConfigSet(hconfigTemp, 12.5, keyString="k2", rc=rc)
</PRE>

<P>
The <TT>hconfigTemp</TT> is a reference to a <EM>map</EM>, and new elements can be
   added using the <TT>addKeyString</TT> argument.
<P>
<PRE>
  call ESMF_HConfigAdd(hconfigTemp, .true., addKeyString="k3", rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigDestroy(hconfigTemp, rc=rc)
</PRE>

<P>
After these operations, the content of <TT>hconfig</TT> has changed to
   <PRE>
   - first added item
   - 12.5700000000
   - {k1: 7, k2: 12.5000000000, k3: True}
   - simple_list: [1, 2, 3, abc, b, TRUE]
     simple_map:
       car: red
       [bike, {p1: 10, p2: 20}]: [bmx, mountain, street]
       plane: [TRUE, FALSE]
</PRE>
   Notice that while <TT>hconfigTemp</TT> should be destroyed explicitly, as in the
   example above, doing so does <EM>not</EM> affect the referenced node inside the
   <TT>hconfig</TT> object. In other words, <TT>hconfigTemp</TT> was a reference, and
   <EM>not</EM> a deep copy of the node! There is some allocated memory associated
   with the <TT>hconfigTemp</TT> reference that gets cleaned up with the
   <TT>Destroy()</TT> call, but it does not affect the reference itself.

<P>
The <TT>Set()</TT> method can also be used to edit the element referenced
   itself. Here the 4th element in the <TT>hconfig</TT> sequence is set to be a
   simple scalar string value using this approach.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = ESMF_HConfigCreateAt(hconfig, index=4, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigSet(hconfigTemp, "Simple scalar string value", rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigDestroy(hconfigTemp, rc=rc)
</PRE>

<P>
The content of <TT>hconfig</TT> has been updated as below.
   <PRE>
   - first added item
   - 12.5700000000
   - {k1: 7, k2: 12.5000000000, k3: True}
   - Simple scalar string value
</PRE>

<P>
There is a simpler alternative for <EM>direct</EM> element editing in an
   HConfig object via the <TT>Set()</TT> method. Using the <TT>index</TT> or
   <TT>keyString</TT> argument, a sequence or map element, respectively, can
   be edited directly. For instance,
<P>
<PRE>
  call ESMF_HConfigSet(hconfig, "[a, b, c]", index=4, rc=rc)
</PRE>

<P>
sets the 4th element of <TT>hconfig</TT> directly, without the need of a
   temporary HConfig variable. This updates the content to:
   <PRE>
   - first added item
   - 12.5700000000
   - {k1: 7, k2: 12.5000000000, k3: True}
   - [a, b, c]
</PRE>

<P>
Elements can be deleted from a HConfig object holding a sequence or map
   using the <TT>Remove()</TT> method, specifying the <EM>index</EM> or
   <EM>map key</EM>, respectively. Here the 2nd element of the sequence held by
   <TT>hconfig</TT> is removed.
<P>
<PRE>
  call ESMF_HConfigRemove(hconfig, index=2, rc=rc)
</PRE>

<P>
The result is a sequence with only three remaining elements.
   <PRE>
   - first added item
   - {k1: 7, k2: 12.5000000000, k3: True}
   - [a, b, c]
</PRE>

<P>
To demonstrate removal of an element from a <EM>map</EM>, the second
   <TT>hconfig</TT> element is referenced by a temporary HConfig object. The element
   with key "k2" is then removed using the respective <TT>Remove()</TT> method.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfigTemp
  hconfigTemp = ESMF_HConfigCreateAt(hconfig, index=2, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigRemove(hconfigTemp, keyString="k2", rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_HConfigDestroy(hconfigTemp, rc=rc)
</PRE>

<P>
The resulting <TT>hconfig</TT> content is as expected.
   <PRE>
   - first added item
   - {k1: 7, k3: True}
   - [a, b, c]
</PRE>

<P>
Finally the entire contents of <TT>hconfig</TT> can be deleted by setting the
   node itself to one of the special NULL values.
<P>
<PRE>
  call ESMF_HConfigSet(hconfig, "NULL", rc=rc)
</PRE>

<P>
If saved to file, the contents of <TT>hconfig</TT> shows up as a simple tilde
   character, indicating its NULL value.
   <PRE>
   ~
</PRE>

<P>
At this point <TT>hconfig</TT> is neither a <EM>sequence</EM> nor a <EM>map</EM>. It is
   NULL. Adding a map element, i.e. an element with a <EM>key</EM>, turns
   <TT>hconfig</TT> into a map.
<P>
<PRE>
  call ESMF_HConfigAdd(hconfig, "first added item", addKeyString="item1", rc=rc)
</PRE>

<P>
The contents of <TT>hconfig</TT> now is a map with a single entry:
   character, indicating its NULL value.
   <PRE>
   item1: first added item
</PRE>

<P>
As in other contexts before, the content as well as the specified
   <TT>addKeyString</TT> can be of any legal YAML syntax. This is demonstrated
   in the following <TT>Add()</TT> calls.
<P>
<PRE>
  ! Add YAML sequence content with simple scalar key.
  call ESMF_HConfigAdd(hconfig, "[2, added, item]", addKeyString="item2", rc=rc)
</PRE>

<P>
<PRE>
  ! Add simple scalar content with a YAML map as key.
  call ESMF_HConfigAdd(hconfig, "third added item", addKeyString="{item: 3}", &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  ! Add complex YAML content with YAML sequence as key.
  call ESMF_HConfigAdd(hconfig, "{4th: item, 5th: [true, false]}", &amp;
    addKeyString="[1, 2, 3, 4]", rc=rc)
</PRE>

<P>
Resulting in the final contents of <TT>hconfig</TT>:
   <PRE>
   item1: first added item
   item2: [2, added, item]
   {item: 3}: third added item
   [1, 2, 3, 4]: {4th: item, 5th: [true, false]}
</PRE>
   Finally clean up <TT>hconfig</TT>.
<P>
<PRE>
  ! Destroy hconfig when done with it.
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION0601031500000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">15</SPAN> Working with multiple YAML documents</A>
</H3>

<P>
The YAML standard supports multiple documents in a single file by separating
   each document with a line containing three dashes (--). Optionally the
   end of each document may be indicated by three periods (...). For example,
   the following YAML file contains three documents (notice the optional usage
   of the document end marker):
   <PRE>
   ---
   - This
   - is
   - the
   - first document.
   ...
   ---
   - And
   - a second document.
   ---
   - And
   - finally a
   - third document.
</PRE>
   All of the documents contained in a YAML file can be loaded into a single
   HConfig object all at once.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(filename="multiDoc.yaml", rc=rc)
</PRE>

<P>
The number of documents held by <TT>hconfig</TT> can be queried.
<P>
<PRE>
  ! integer :: docCount
  docCount = ESMF_HConfigGetDocCount(hconfig, rc=rc)
</PRE>

<P>
When saving <TT>hconfig</TT>, a multi-document YAML file will be written.
<P>
<PRE>
  call ESMF_HConfigFileSave(hconfig, filename="multi_00.yaml", rc=rc)
</PRE>

<P>
The <TT>ESMF_HConfigFileSave()</TT> method implements strict usage of both
   document markers when saving a multi-document HConfig object.
   <PRE>
   ---
   - This
   - is
   - the
   - first document.
   ...
   ---
   - And
   - a second document.
   ...
   ---
   - And
   - finally a
   - third document.
   ...
</PRE>

<P>
The content of the <TT>hconfig</TT> object can be written to the ESMF log file
   as usual.
<P>
<PRE>
  call ESMF_HConfigLog(hconfig, prefix="my-multi-doc: ", rc=rc)
</PRE>

<P>
The optional <TT>doc</TT> argument can be specified to save or log a specific
   document of the multi-document <TT>hconfig</TT> object.
<P>
<PRE>
  call ESMF_HConfigFileSave(hconfig, filename="multi_01.yaml", doc=2, rc=rc)
</PRE>

<P>
This operation results in a single document file:
   <PRE>
   - And
   - a second document.
</PRE>
   The <TT>ESMF_HConfigFileLoad()</TT> method also accepts the optional <TT>doc</TT>
   argument. When specified, the result is a single-document <TT>hconfig</TT>
   object, holding the content of the indicated document within the loaded file.
<P>
<PRE>
  call ESMF_HConfigFileLoad(hconfig, filename="multiDoc.yaml", doc=3, rc=rc)
</PRE>

<P>
Saving <TT>hconfig</TT> to file shows the expected situation.
<P>
<PRE>
  call ESMF_HConfigFileSave(hconfig, filename="multi_02.yaml", rc=rc)
</PRE>

<P>
Resulting in:
   <PRE>
   - And
   - finally a
   - third document.
</PRE>

<P>
Most HConfig methods provide the optional <TT>doc</TT> argument. If present,
   the method applies to the specified document. The default for when the
   <TT>doc</TT> argument is not present, for most methods is to use the first
   document in the object. The exceptions to this rule are the
   <TT>ESMF_HConfigFileSave()</TT> and <TT>ESMF_HConfigFileLoad()</TT> methods.
   Here the default is to apply the operation to <EM>all</EM> documents.

<P>
When done, clean up <TT>hconfig</TT> as usual.
<P>
<PRE>
  ! Destroy hconfig when done with it.
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION0601031600000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">16</SPAN> Sequence shortcuts for: Create, As, Add, and Set</A>
</H3>

<P>
The HConfig class offers shortcut methods for the sake of convenience when
   working with sequences where all elements are of the same typekind. In these
   cases a sequence can be represented as a one-dimensional Fortran array. The
   interfaces are overloaded for one-dimensional string, logical, I4, I8, R4,
   and R8 typekinds.

<P>
Using a Fortran array constructor for the actual argument, a sequence of I4
   data is created.
<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate([1,2,3], rc=rc)
</PRE>

<P>
The content of <TT>hconfig</TT> can be accessed in the usual manner, via
   iterators or indexed access. Alternatively, the sequence of I4 elements
   can be retrieved in a single call using a one-dimensional allocatable
   Fortran array of the appropriate typekind.
<P>
<PRE>
  ! integer(ESMF_KIND_I4), allocatable :: valueI4Seq(:)
  valueI4Seq = ESMF_HConfigAsI4Seq(hconfig, rc=rc)
</PRE>

<P>
The optional, intent(out) argument <TT>asOkay</TT> is available as in the scalar
   access methods. If specified, errors triggered by unsupported typekind
   conversion exceptions are suppressed, and instead <TT>asOkay == .false.</TT> is
   returned by the call.

<P>
Here an attempt is made to access the content of <TT>hconfig</TT> as a sequence
   of logicals. This is not supported, and will be flagged in the return value
   of <TT>asOkay</TT>.
<P>
<PRE>
  ! logical, allocatable :: valueLSeq(:)
  valueLSeq = ESMF_HConfigAsLogicalSeq(hconfig, asOkay=asOkay, rc=rc)
</PRE>

<P>
Finally the content of <TT>hconfig</TT> is accessed as a sequence of strings.
   This is always supported since every typekind can be represented in string
   form.
<P>
<PRE>
  ! character(len=:), allocatable :: valueSSeq(:)
  valueSSeq = ESMF_HConfigAsStringSeq(hconfig, stringLen=10, asOkay=asOkay, rc=rc)
</PRE>

<P>
Next <TT>hconfig</TT> is cleaned up before re-creating it as an empty HConfig
   object.
<P>
<PRE>
  ! Clean up hconfig.
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>
<PRE>
  ! type(ESMF_HConfig) :: hconfig
  hconfig = ESMF_HConfigCreate(rc=rc)
</PRE>

<P>
Sequences can be added to <TT>hconfig</TT> conveniently using the overloaded
   <TT>Add()</TT> interfaces that accept one-dimensional Fortran arrays. Here a
   sequence of strings is added as the value of a map entry with key string "k1".
<P>
<PRE>
  call ESMF_HConfigAdd(hconfig, ["aaa","bbb","ccc"], addKeyString="k1", rc=rc)
</PRE>

<P>
Next a sequence of R4 values is added to the map held by <TT>hconfig</TT>,
   under key string "k2".
<P>
<PRE>
  call ESMF_HConfigAdd(hconfig, [1.0,1.25,1.5], addKeyString="k2", rc=rc)
</PRE>

<P>
At this point <TT>hconfig</TT> contains the following information:
   <PRE>
   k1:
     - aaa
     - bbb
     - ccc
   k2:
     - 1
     - 1.25
     - 1.5
</PRE>

<P>
The <TT>Set()</TT> interfaces are also overloaded to accept one-dimensional
   Fortran arrays as input. This makes it easy to set any node to a sequence
   that is available as Fortran array. Here the value associated with key "k1"
   is changed to a list of two logicals.
<P>
<PRE>
  call ESMF_HConfigSet(hconfig, [.true.,.false.], keyString="k1", rc=rc)
</PRE>

<P>
This changes the content of <TT>hconfig</TT> as expected.
   <PRE>
   k1:
     - True
     - False
   k2:
     - 1
     - 1.25
     - 1.5
</PRE>

<P>
Finally clean up <TT>hconfig</TT> as usual.
<P>
<PRE>
  ! Destroy hconfig when done with it.
  call ESMF_HConfigDestroy(hconfig, rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION060104000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>The YAML Core schema, which is an extension of the JSON schema, is
  implemented and used to resolve non-specific tags under HConfig.
  There is currently no mechanism implemented to switch to a different schema
  for tag resolution.
</LI>
<LI>Currently the only available removal method for HConfig <EM>map</EM>
  objects requires that <EM>keys</EM> be simple scalar strings.
</LI>
<LI>There is currently no method implemented that allows setting of tags from
  from the API.
</LI>
</UL>

<H2><A NAME="SECTION060105000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The ESMF HConfig class is implemented on top of YAML-CPP (https://github.com/jbeder/yaml-cpp).
A copy of YAML-CPP is included in the ESMF source tree under ./src/prologue/yaml-cpp. It is
used by a number of ESMF/NUOPC functions, including HConfig.

<H2><A NAME="SECTION060106000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060106100000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_HConfigAssignment(=) - HConfig assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     hconfig1 = hconfig2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig) :: hconfig1
     type(ESMF_HConfig) :: hconfig2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign hconfig1 as an alias to the same ESMF HConfig object in memory
     as hconfig2. If hconfig2 is invalid, then hconfig1 will be equally
     invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig1</STRONG></DT>
<DD>The <TT>ESMF_HConfig</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>hconfig2</STRONG></DT>
<DD>The <TT>ESMF_HConfig</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060106200000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_HConfigOperator(==) - HConfig equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (hconfig1 == hconfig2) then ... endif
               OR
     result = (hconfig1 == hconfig2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig), intent(in) :: hconfig1
     type(ESMF_HConfig), intent(in) :: hconfig2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether hconfig1 and hconfig2 are valid aliases to the same ESMF
     HConfig object in memory. For a more general comparison of two
     ESMF HConfigs, going beyond the simple alias test, the
     <TT>ESMF_HConfigMatch()</TT> function (<A HREF="#HConfigMatch">48.6.44</A>) must
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig1</STRONG></DT>
<DD>The <TT>ESMF_HConfig</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>hconfig2</STRONG></DT>
<DD>The <TT>ESMF_HConfig</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060106300000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_HConfigOperator(/=) - HConfig not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (hconfig1 /= hconfig2) then ... endif
               OR
     result = (hconfig1 /= hconfig2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig), intent(in) :: hconfig1
     type(ESMF_HConfig), intent(in) :: hconfig2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether hconfig1 and hconfig2 are <I>not</I> valid aliases to the
     same ESMF HConfig object in memory. For a more general comparison of two
     ESMF HConfigs, going beyond the simple alias test, the
     <TT>ESMF_HConfigMatch()</TT> function (<A HREF="#HConfigMatch">48.6.44</A>) must
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig1</STRONG></DT>
<DD>The <TT>ESMF_HConfig</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>hconfig2</STRONG></DT>
<DD>The <TT>ESMF_HConfig</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060106400000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_HConfigAdd - Add &lt;Type&gt; content to HConfig object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_HConfigAdd(hconfig, content, &amp;
      addKey, addKeyString, index, keyString, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
      &lt;Type&gt;,             intent(in)            :: content[(:)]
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_HConfig), intent(in),  optional :: addKey
      character(*),       intent(in),  optional :: addKeyString
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add the content of type &lt;Type&gt; to the <TT>hconfig</TT>,
     at the current location, or as specified by <TT>index</TT> or <TT>keyString</TT>
     (mutually exclusive!).
     Most &lt;Type&gt; options support the sequence array variant <TT>(:)</TT> in
     addition to the scalar variant.

<P>
If either <TT>addKey</TT> or <TT>addKeyString</TT> (mutually exclusive!) is
     specified, then add a new map element with the respective <EM>key</EM>.
     Otherwise add a new list element at the end of the list. Error checking
     is implemented to ensure respective conditions are met.

<P>
The supported &lt;Type&gt; options are:
     
<UL>
<LI><TT>type(HConfig)</TT> (Scalar only variant!
                               Only a single HConfig object can be provided.)
</LI>
<LI><TT>integer(ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>
</LI>
<LI><TT>character(*)</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>content</STRONG></DT>
<DD>The content to be added.
     
</DD>
<DT><STRONG>[addKey]</STRONG></DT>
<DD>The key under which to add the new map item.
       Muturally exclusive with <TT>addKeyString</TT>.
     
</DD>
<DT><STRONG>[addKeyString]</STRONG></DT>
<DD>The key string under which to add the new map item.
       Muturally exclusive with <TT>addKey</TT>.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060106500000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_HConfigAddMapKey - Add &lt;Type&gt; content to HConfig MapKey object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_HConfigAddMapKey(hconfig, content, &amp;
      addKey, addKeyString, index, keyString, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)        :: hconfig
      &lt;Type&gt;,             intent(in)            :: content[(:)]
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_HConfig), intent(in),  optional :: addKey
      character(*),       intent(in),  optional :: addKeyString
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add the content of type &lt;Type&gt; to the <TT>hconfig</TT> map key,
     at the current location, or as specified by <TT>index</TT> or <TT>keyString</TT>
     (mutually exclusive!).
     Most &lt;Type&gt; options support the sequence array variant <TT>(:)</TT> in
     addition to the scalar variant.

<P>
If either <TT>addKey</TT> or <TT>addKeyString</TT> (mutually exclusive!) is
     specified, then add a new map element with the respective <EM>key</EM>.
     Otherwise add a new list element at the end of the list. Error checking
     is implemented to ensure respective conditions are met.

<P>
The supported &lt;Type&gt; options are:
     
<UL>
<LI><TT>type(HConfig)</TT> (Scalar only variant!
                               Only a single HConfig object can be provided.)
</LI>
<LI><TT>integer(ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>
</LI>
<LI><TT>character(*)</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>content</STRONG></DT>
<DD>The content to be added.
     
</DD>
<DT><STRONG>[addKey]</STRONG></DT>
<DD>The key under which to add the new map item.
       Muturally exclusive with <TT>addKeyString</TT>.
     
</DD>
<DT><STRONG>[addKeyString]</STRONG></DT>
<DD>The key string under which to add the new map item.
       Muturally exclusive with <TT>addKey</TT>.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060106600000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_HConfigAddMapVal - Add &lt;Type&gt; content to HConfig MapVal object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_HConfigAddMapVal(hconfig, content, &amp;
      addKey, addKeyString, index, keyString, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)        :: hconfig
      &lt;Type&gt;,             intent(in)            :: content[(:)]
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_HConfig), intent(in),  optional :: addKey
      character(*),       intent(in),  optional :: addKeyString
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Add the content of type &lt;Type&gt; to the <TT>hconfig</TT> map value,
     at the current location, or as specified by <TT>index</TT> or <TT>keyString</TT>
     (mutually exclusive!).
     Most &lt;Type&gt; options support the sequence array variant <TT>(:)</TT> in
     addition to the scalar variant.

<P>
If either <TT>addKey</TT> or <TT>addKeyString</TT> (mutually exclusive!) is
     specified, then add a new map element with the respective <EM>key</EM>.
     Otherwise add a new list element at the end of the list. Error checking
     is implemented to ensure respective conditions are met.

<P>
The supported &lt;Type&gt; options are:
     
<UL>
<LI><TT>type(HConfig)</TT> (Scalar only variant!
                               Only a single HConfig object can be provided.)
</LI>
<LI><TT>integer(ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>
</LI>
<LI><TT>character(*)</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>content</STRONG></DT>
<DD>The content to be added.
     
</DD>
<DT><STRONG>[addKey]</STRONG></DT>
<DD>The key under which to add the new map item.
       Muturally exclusive with <TT>addKeyString</TT>.
     
</DD>
<DT><STRONG>[addKeyString]</STRONG></DT>
<DD>The key string under which to add the new map item.
       Muturally exclusive with <TT>addKey</TT>.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060106700000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt; - Return value as &lt;Type&gt;</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigAs&lt;TypeSpec&gt;(hconfig, index, keyString, &amp;
      doc, asOkay, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      &lt;Type&gt; :: ESMF_HConfigAs&lt;TypeSpec&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]) , intent(in)     :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      logical,            intent(out), optional :: asOkay
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the value of item <TT>hconfig</TT> interpreted as &lt;Type&gt;.
     The returned value is only valid if <TT>rc == ESMF_SUCCESS</TT>, and, if
     provided, <TT>asOkay == .true.</TT>.

<P>
The supported &lt;Type&gt; / &lt;TypeSpec&gt; options are:
     
<UL>
<LI><TT>integer(ESMF_KIND_I4)</TT> / <TT>I4</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT> / <TT>I8</TT>
</LI>
<LI><TT>logical</TT>                 / <TT>Logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>    / <TT>R4</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>    / <TT>R8</TT>
</LI>
<LI><TT>character(len=:), allocatable</TT> / <TT>String</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[asOkay]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for successful convertion to the requested typekind.
       Set to <TT>.false.</TT> otherwise. By default, i.e. without <TT>asOkay</TT>,
       the latter condition leads to <TT>rc /= ESMF_SUCCESS</TT>.
       Providing <TT>asOkay</TT> returns <TT>rc == ESMF_SUCCESS</TT> in either case,
       and the validity of the returned converted value is determined by
       <TT>asOkay</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060106800000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;MapKey - Return map key as &lt;Type&gt;</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigAs&lt;TypeSpec&gt;MapKey(hconfig, index, keyString, &amp;
      doc, asOkay, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      &lt;Type&gt; :: ESMF_HConfigAs&lt;TypeSpec&gt;MapKey
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      logical,            intent(out), optional :: asOkay
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the map key of item <TT>hconfig</TT> interpreted as &lt;Type&gt;.
     The returned value is only valid if <TT>rc == ESMF_SUCCESS</TT>, and, if
     provided, <TT>asOkay == .true.</TT>.

<P>
The supported &lt;Type&gt; / &lt;TypeSpec&gt; options are:
     
<UL>
<LI><TT>integer(ESMF_KIND_I4)</TT> / <TT>I4</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT> / <TT>I8</TT>
</LI>
<LI><TT>logical</TT>                 / <TT>Logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>    / <TT>R4</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>    / <TT>R8</TT>
</LI>
<LI><TT>character(len=:), allocatable</TT> / <TT>String</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[asOkay]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for successful convertion to the requested typekind.
       Set to <TT>.false.</TT> otherwise. By default, i.e. without <TT>asOkay</TT>,
       the latter condition leads to <TT>rc /= ESMF_SUCCESS</TT>.
       Providing <TT>asOkay</TT> returns <TT>rc == ESMF_SUCCESS</TT> in either case,
       and the validity of the returned converted value is determined by
       <TT>asOkay</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060106900000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;MapVal - Return map value as &lt;Type&gt;</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigAs&lt;TypeSpec&gt;MapVal(hconfig, index, keyString, &amp;
      doc, asOkay, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      &lt;Type&gt; :: ESMF_HConfigAs&lt;TypeSpec&gt;MapVal
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      logical,            intent(out), optional :: asOkay
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the map value of item <TT>hconfig</TT> interpreted as &lt;Type&gt;.
     The returned value is only valid if <TT>rc == ESMF_SUCCESS</TT>, and, if
     provided, <TT>asOkay == .true.</TT>.

<P>
The supported &lt;Type&gt; / &lt;TypeSpec&gt; options are:
     
<UL>
<LI><TT>integer(ESMF_KIND_I4)</TT> / <TT>I4</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT> / <TT>I8</TT>
</LI>
<LI><TT>logical</TT>                 / <TT>Logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>    / <TT>R4</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>    / <TT>R8</TT>
</LI>
<LI><TT>character(len=:), allocatable</TT> / <TT>String</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[asOkay]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for successful convertion to the requested typekind.
       Set to <TT>.false.</TT> otherwise. By default, i.e. without <TT>asOkay</TT>,
       the latter condition leads to <TT>rc /= ESMF_SUCCESS</TT>.
       Providing <TT>asOkay</TT> returns <TT>rc == ESMF_SUCCESS</TT> in either case,
       and the validity of the returned converted value is determined by
       <TT>asOkay</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;Seq - Return value as sequence array of &lt;Type&gt;</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigAs&lt;TypeSpec&gt;Seq(hconfig, index, keyString, &amp;
      doc, asOkay, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      &lt;Type&gt;, allocatable :: ESMF_HConfigAs&lt;TypeSpec&gt;Seq(:)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      logical,            intent(out), optional :: asOkay
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the value of item <TT>hconfig</TT> interpreted as sequence of &lt;Type&gt;.
     The returned value is only valid if <TT>rc == ESMF_SUCCESS</TT>, and, if
     provided, <TT>asOkay == .true.</TT>.

<P>
The supported &lt;Type&gt; / &lt;TypeSpec&gt; options are:
     
<UL>
<LI><TT>integer(ESMF_KIND_I4)</TT> / <TT>I4</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT> / <TT>I8</TT>
</LI>
<LI><TT>logical</TT>                 / <TT>Logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>    / <TT>R4</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>    / <TT>R8</TT>
</LI>
<LI><TT>character(len=:), allocatable</TT> / <TT>String</TT> (See note about <TT>stringLen</TT> argument below!)
     
</LI>
</UL>

<P>
An extra non-optional argument <TT>stringLen</TT> must be provided for the
     <B>String</B> option. This argument specifies the number of characters in
     each of the output strings. Longer actual string values are tuncated, while
     shorter actual string values are padded with white space.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[asOkay]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for successful convertion to the requested typekind.
       Set to <TT>.false.</TT> otherwise. By default, i.e. without <TT>asOkay</TT>,
       the latter condition leads to <TT>rc /= ESMF_SUCCESS</TT>.
       Providing <TT>asOkay</TT> returns <TT>rc == ESMF_SUCCESS</TT> in either case,
       and the validity of the returned converted value is determined by
       <TT>asOkay</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061100000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;SeqMapKey - Return map key value as sequence array of &lt;Type&gt;</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigAs&lt;TypeSpec&gt;SeqMapKey(hconfig, index, keyString, &amp;
      doc, asOkay, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      &lt;Type&gt;, allocatable :: ESMF_HConfigAs&lt;TypeSpec&gt;SeqMapKey(:)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      logical,            intent(out), optional :: asOkay
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the map key of item <TT>hconfig</TT> interpreted as sequence of &lt;Type&gt;.
     The returned value is only valid if <TT>rc == ESMF_SUCCESS</TT>, and, if
     provided, <TT>asOkay == .true.</TT>.

<P>
The supported &lt;Type&gt; / &lt;TypeSpec&gt; options are:
     
<UL>
<LI><TT>integer(ESMF_KIND_I4)</TT> / <TT>I4</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT> / <TT>I8</TT>
</LI>
<LI><TT>logical</TT>                 / <TT>Logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>    / <TT>R4</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>    / <TT>R8</TT>
</LI>
<LI><TT>character(len=:), allocatable</TT> / <TT>String</TT> (See note about <TT>stringLen</TT> argument below!)
     
</LI>
</UL>

<P>
An extra non-optional argument <TT>stringLen</TT> must be provided for the
     <B>String</B> option. This argument specifies the number of characters in
     each of the output strings. Longer actual string values are tuncated, while
     shorter actual string values are padded with white space.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[asOkay]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for successful convertion to the requested typekind.
       Set to <TT>.false.</TT> otherwise. By default, i.e. without <TT>asOkay</TT>,
       the latter condition leads to <TT>rc /= ESMF_SUCCESS</TT>.
       Providing <TT>asOkay</TT> returns <TT>rc == ESMF_SUCCESS</TT> in either case,
       and the validity of the returned converted value is determined by
       <TT>asOkay</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061200000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_HConfigAs&lt;TypeSpec&gt;SeqMapVal - Return map value as sequence array of &lt;Type&gt;</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigAs&lt;TypeSpec&gt;SeqMapVal(hconfig, index, keyString, &amp;
      doc, asOkay, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      &lt;Type&gt;, allocatable :: ESMF_HConfigAs&lt;TypeSpec&gt;SeqMapVal(:)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      logical,            intent(out), optional :: asOkay
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the map value of item <TT>hconfig</TT> interpreted as sequence of &lt;Type&gt;.
     The returned value is only valid if <TT>rc == ESMF_SUCCESS</TT>, and, if
     provided, <TT>asOkay == .true.</TT>.

<P>
The supported &lt;Type&gt; / &lt;TypeSpec&gt; options are:
     
<UL>
<LI><TT>integer(ESMF_KIND_I4)</TT> / <TT>I4</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT> / <TT>I8</TT>
</LI>
<LI><TT>logical</TT>                 / <TT>Logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>    / <TT>R4</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>    / <TT>R8</TT>
</LI>
<LI><TT>character(len=:), allocatable</TT> / <TT>String</TT> (See note about <TT>stringLen</TT> argument below!)
     
</LI>
</UL>

<P>
An extra non-optional argument <TT>stringLen</TT> must be provided for the
     <B>String</B> option. This argument specifies the number of characters in
     each of the output strings. Longer actual string values are tuncated, while
     shorter actual string values are padded with white space.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[asOkay]</STRONG></DT>
<DD>Set to <TT>.true.</TT> for successful convertion to the requested typekind.
       Set to <TT>.false.</TT> otherwise. By default, i.e. without <TT>asOkay</TT>,
       the latter condition leads to <TT>rc /= ESMF_SUCCESS</TT>.
       Providing <TT>asOkay</TT> returns <TT>rc == ESMF_SUCCESS</TT> in either case,
       and the validity of the returned converted value is determined by
       <TT>asOkay</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061300000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_HConfigCreate - Create HConfig object from YAML string or file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_HConfigCreate()
   function ESMF_HConfigCreateDefault(content, filename, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfig) :: ESMF_HConfigCreateDefault
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),   intent(in),  optional :: content
     character(len=*),   intent(in),  optional :: filename
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new HConfig object. The object is empty unless either the
     <TT>content</TT> or <TT>filename</TT> argument is specified.

<P>
The arguments are:
     <DL>
<DT><STRONG>[content]</STRONG></DT>
<DD>String containing the YAML text. Mutually exclusive with
       <TT>filename</TT> argument.
     
</DD>
<DT><STRONG>[filename]</STRONG></DT>
<DD>Name of the YAML file to be loaded. Mutually exclusive with
       <TT>content</TT> argument.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061400000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_HConfigCreate - Create HConfig object from HConfig object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_HConfigCreate()
   function ESMF_HConfigCreateHConfig(content, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfig) :: ESMF_HConfigCreateHConfig
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig), intent(in)            :: content
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new HConfig object from existing HConfig object as a deep copy.

<P>
The arguments are:
     <DL>
<DT><STRONG>content</STRONG></DT>
<DD>HConfig content.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061500000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_HConfigCreate - Create HConfig object from &lt;Type&gt; content</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigCreate(content, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_HConfig) :: ESMF_HConfigCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE>      &lt;Type&gt;,  intent(in)            :: content[(:)]
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new HConfig object from content of type &lt;Type&gt;. All &lt;Type&gt; options
     support the sequence array variant <TT>(:)</TT> in addition to the scalar
     variant.

<P>
The supported &lt;Type&gt; options are:
     
<UL>
<LI><TT>integer(ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>content</STRONG></DT>
<DD>Content of type &lt;Type&gt;.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061600000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_HConfigCreate - Create HConfig object from String sequence array</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_HConfigCreate()
   function ESMF_HConfigCreateStringSeq(content, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfig) :: ESMF_HConfigCreateStringSeq
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),   intent(in)            :: content(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new HConfig object.

<P>
The arguments are:
     <DL>
<DT><STRONG>content</STRONG></DT>
<DD>String content.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061700000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_HConfigCreateAt - Return HConfig object at location</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigCreateAt(hconfig, index, key, &amp;
      keyString, doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_HConfig) :: ESMF_HConfigCreateAt
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      type(ESMF_HConfig), intent(in),  optional :: key
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new HConfig object at the current iteration, or
     as specified by <TT>index</TT>, <TT>key</TT> or <TT>keyString</TT>.
     The <TT>hconfig</TT> must <EM>not</EM> be a map iterator.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>key</TT> and <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[key]</STRONG></DT>
<DD>Attempt to access by key if specified. Muturally exclusive with
       <TT>index</TT> and <TT>keyString</TT>,
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT> and <TT>key</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061800000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_HConfigCreateAtMapKey - Return HConfig object at location</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigCreateAtMapKey(hconfig, index, key, &amp;
     keyString, doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfig) :: ESMF_HConfigCreateAtMapKey
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: index
     type(ESMF_HConfig), intent(in),  optional :: key
     character(*),       intent(in),  optional :: keyString
     integer,            intent(in),  optional :: doc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new HConfig object for a map key at the current iteration, or
     as specified by <TT>index</TT>, <TT>key</TT> or <TT>keyString</TT>.
     The <TT>hconfig</TT> <EM>must</EM> be a map iterator.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>key</TT> and <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[key]</STRONG></DT>
<DD>Attempt to access by key if specified. Muturally exclusive with
       <TT>index</TT> and <TT>keyString</TT>,
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT> and <TT>key</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601061900000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_HConfigCreateAtMapVal - Return HConfig object at location</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigCreateAtMapVal(hconfig, index, key, &amp;
     keyString, doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfig) :: ESMF_HConfigCreateAtMapVal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: index
     type(ESMF_HConfig), intent(in),  optional :: key
     character(*),       intent(in),  optional :: keyString
     integer,            intent(in),  optional :: doc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create a new HConfig object for a map value at the current iteration, or
     as specified by <TT>index</TT>, <TT>key</TT> or <TT>keyString</TT>.
     The <TT>hconfig</TT> <EM>must</EM> be a map iterator.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>key</TT> and <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[key]</STRONG></DT>
<DD>Attempt to access by key if specified. Muturally exclusive with
       <TT>index</TT> and <TT>keyString</TT>,
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT> and <TT>key</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_HConfigDestroy - Release resources associated with a HConfig</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_HConfigDestroy(hconfig, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig), intent(inout)          :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_HConfig</TT>, releasing the resources associated
     with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062100000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_HConfigFileLoad - Load file into HConfig</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_HConfigFileLoad(hconfig, filename, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig), intent(in)            :: hconfig
     character(len=*),   intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: doc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Load YAML file into <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object.
     
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of the YAML file to be loaded.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index inside the file. If specified, only this single document
       is loaded from file, resulting in a single document <TT>hconfig</TT> object.
       Defaults to <EM>all</EM> docs.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062200000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_HConfigFileSave - Save HConfig to file</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_HConfigFileSave(hconfig, filename, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig), intent(in)            :: hconfig
     character(len=*),   intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: doc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Save HConfig into YAML file. Only <TT>localPet == 0</TT> does the writing.
     The <TT>hconfig</TT> must <EM>not</EM> be a map iterator.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object.
     
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of the YAML file into which to save.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index inside <TT>hconfig</TT>. Defaults to <EM>all</EM> docs.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062300000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_HConfigGetDocCount - Get number of docs in HConfig</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigGetDocCount(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     integer :: ESMF_HConfigGetDocCount
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig), intent(in)            :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the number of documents held by <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062400000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_HConfigGetSize - Get size of HConfig node</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigGetSize(hconfig, index, keyString, doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      integer :: ESMF_HConfigGetSize
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the number of elements in collection <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062500000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_HConfigGetSizeMapKey - Get size of HConfig node</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigGetSizeMapKey(hconfig, index, keyString, &amp;
     doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     integer :: ESMF_HConfigGetSizeMapKey
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: index
     character(*),       intent(in),  optional :: keyString
     integer,            intent(in),  optional :: doc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return size of the <TT>hconfig</TT> node.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062600000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_HConfigGetSizeMapVal - Get size of HConfig node</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigGetSizeMapVal(hconfig, index, keyString, &amp;
     doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     integer :: ESMF_HConfigGetSizeMapVal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: index
     character(*),       intent(in),  optional :: keyString
     integer,            intent(in),  optional :: doc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return size of the <TT>hconfig</TT> node.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062700000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_HConfigGetTag - Get tag of HConfig node</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigGetTag(hconfig, index, keyString, doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      character(len=:), allocatable :: ESMF_HConfigGetTag
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return tag string of the <TT>hconfig</TT> node.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062800000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_HConfigGetTagMapKey - Get tag of map key node</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigGetTagMapKey(hconfig, index, keyString, &amp;
     doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     character(len=:), allocatable :: ESMF_HConfigGetTagMapKey
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: index
     character(*),       intent(in),  optional :: keyString
     integer,            intent(in),  optional :: doc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return tag string of map key of the <TT>hconfig</TT> node.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601062900000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_HConfigGetTagMapVal - Get tag of map key node</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigGetTagMapVal(hconfig, index, keyString, &amp;
     doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     character(len=:), allocatable :: ESMF_HConfigGetTagMapVal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: index
     character(*),       intent(in),  optional :: keyString
     integer,            intent(in),  optional :: doc
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return tag string of map key of the <TT>hconfig</TT> node.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_HConfigIs&lt;NodeType&gt; - Check for HConfig node type</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigIs&lt;NodeType&gt;(hconfig, index, keyString, &amp;
      doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      logical :: ESMF_HConfigIs&lt;NodeType&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>hconfig</TT> node is of node type
     &lt;NodeType&gt;. Otherwise return <TT>.false.</TT>. If an error occurs, i.e.
     <TT>rc /= ESMF_SUCCESS</TT> is returned, the return value of the function
     will be <TT>.false.</TT>.

<P>
The supported &lt;NodeType&gt; options are:
     
<UL>
<LI>Defined
</LI>
<LI>Null
</LI>
<LI>Map
</LI>
<LI>Scalar
</LI>
<LI>Sequence
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063100000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_HConfigIs&lt;NodeType&gt;MapKey - Check for HConfig MapKey node type</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigIs&lt;NodeType&gt;MapKey(hconfig, index, keyString, &amp;
      doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      logical :: ESMF_HConfigIs&lt;NodeType&gt;MapKey
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)       :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>hconfig</TT> MapKey node is of node type
     &lt;NodeType&gt;. Otherwise return <TT>.false.</TT>. If an error occurs, i.e.
     <TT>rc /= ESMF_SUCCESS</TT> is returned, the return value of the function
     will be <TT>.false.</TT>.

<P>
The supported &lt;NodeType&gt; options are:
     
<UL>
<LI>Defined
</LI>
<LI>Null
</LI>
<LI>Map
</LI>
<LI>Scalar
</LI>
<LI>Sequence
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063200000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_HConfigIs&lt;NodeType&gt;MapVal - Check for HConfig MapVal node type</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigIs&lt;NodeType&gt;MapVal(hconfig, index, keyString, &amp;
      doc, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      logical :: ESMF_HConfigIs&lt;NodeType&gt;MapVal
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)       :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>hconfig</TT> MapVal node is of node type
     &lt;NodeType&gt;. Otherwise return <TT>.false.</TT>. If an error occurs, i.e.
     <TT>rc /= ESMF_SUCCESS</TT> is returned, the return value of the function
     will be <TT>.false.</TT>.

<P>
The supported &lt;NodeType&gt; options are:
     
<UL>
<LI>Defined
</LI>
<LI>Null
</LI>
<LI>Map
</LI>
<LI>Scalar
</LI>
<LI>Sequence
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063300000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_HConfigIterBegin - Iterator at the beginning</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigIterBegin(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_HConfigIter) :: ESMF_HConfigIterBegin
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return an iterator that points to the first item in <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063400000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_HConfigIterBeginMapKey - Iterator at the beginning</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigIterBeginMapKey(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfigIter) :: ESMF_HConfigIterBeginMapKey
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return an iterator that points to the first item in <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063500000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_HConfigIterBeginMapVal - Iterator at the beginning</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigIterBeginMapVal(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfigIter) :: ESMF_HConfigIterBeginMapVal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return an iterator that points to the first item in <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063600000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">36</SPAN> ESMF_HConfigIterEnd - Iterator at the end</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    function ESMF_HConfigIterEnd(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_HConfigIter) :: ESMF_HConfigIterEnd
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return an iterator that points to one past the last item in <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063700000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">37</SPAN> ESMF_HConfigIterEndMapKey - Iterator at the end</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigIterEndMapKey(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfigIter) :: ESMF_HConfigIterEndMapKey
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return an iterator that points to one past the last item in <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063800000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">38</SPAN> ESMF_HConfigIterEndMapVal - Iterator at the end</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigIterEndMapVal(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfigIter) :: ESMF_HConfigIterEndMapVal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return an iterator that points to one past the last item in <TT>hconfig</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601063900000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">39</SPAN> ESMF_HConfigIterIsMap - Check whether HConfig iterator is Map</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigIterIsMap(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_HConfigIterIsMap
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>hconfig</TT> node is Null. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064000000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">40</SPAN> ESMF_HConfigIterIsSequence - Check whether HConfig iterator is Sequence</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigIterIsSequence(hconfig, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_HConfigIterIsSequence
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(in)        :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>hconfig</TT> node is Null. Otherwise return
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064100000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">41</SPAN> ESMF_HConfigIterLoop - Step iterator forward</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigIterLoop(hconfig, hconfigBegin, hconfigEnd, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_HConfigIterLoop
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(inout)     :: hconfig
     type(ESMF_HConfigIter), intent(in)        :: hconfigBegin
     type(ESMF_HConfigIter), intent(in)        :: hconfigEnd
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Step the iterator <TT>hconfig</TT> forward. starting at <TT>hconfigBegin</TT>
     until <TT>hconfigEnd</TT> is reached. Returns <TT>.true.</TT> as long as
     <TT>hconfig</TT> has not reached <TT>hconfigEnd</TT>. Once this condition has
     been reached, returns <TT>.false.</TT>.

<P>
The intended usage of <TT>ESMF_HConfigIterLoop()</TT> is as the conditional
     in a <TT>do while</TT> loop, iterating over the elements of a HConfig object.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD>The <TT>ESMF_HConfigIter</TT> object. Must enter equal to
       <TT>hconfigBegin</TT> on the first loop step.
     
</DD>
<DT><STRONG>hconfigBegin</STRONG></DT>
<DD>The <TT>ESMF_HConfigIter</TT> to begin at.
     
</DD>
<DT><STRONG>hconfigEnd</STRONG></DT>
<DD>The <TT>ESMF_HConfigIter</TT> that marks the end of the loop.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064200000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">42</SPAN> ESMF_HConfigIterNext - Step iterator forward</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_HConfigIterNext(hconfig, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfigIter), intent(inout)         :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Step the iterator <TT>hconfig</TT> one step forward.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064300000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">43</SPAN> ESMF_HConfigLog - Log HConfig contents</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_HConfigLog(hconfig, prefix, logMsgFlag, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig),     intent(in)            :: hconfig
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),       intent(in),  optional :: prefix
     type(ESMF_LogMsg_Flag), intent(in),  optional :: logMsgFlag
     integer,                intent(in),  optional :: doc
     integer,                intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write the contents of <TT>hconfig</TT> to the ESMF default Log.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object written to log.
     
</DD>
<DT><STRONG>[prefix]</STRONG></DT>
<DD>String to prefix the log message. Default is no prefix.
     
</DD>
<DT><STRONG>[logMsgFlag]</STRONG></DT>
<DD>Type of log message generated. See section <A HREF="#const:logmsgflag">49.2.3</A> for
       a list of valid message types. Default is <TT>ESMF_LOGMSG_INFO</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. If specified, only content of the indicated
       single document is written to log. Defaults to <EM>all</EM> docs.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064400000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">44</SPAN> ESMF_HConfigMatch - Check if two HConfig objects match</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigMatch(hconfig1, hconfig2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_HConfigMatch_Flag) :: ESMF_HConfigMatch
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig),  intent(in)             :: hconfig1
     type(ESMF_HConfig),  intent(in)             :: hconfig2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
<A NAME="HConfigMatch"></A>     Determine the level to which <TT>hconfig1</TT> and <TT>hconfig2</TT> match.

<P>
Returns a value of type <TT>ESMF_HConfigMatch_Flag</TT>,
     indicating how closely the two HConfig objects match. For a description of
     the possible return values, see&nbsp;<A HREF="#const:hconfigmatch">48.2.1</A>.
     Note that this call only performs PET local matching. Different match values
     may be returned on different PETs for the same HConfig pair.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig1</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object.
     
</DD>
<DT><STRONG>hconfig2</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064500000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">45</SPAN> ESMF_HConfigRemove - Remove element from HConfig object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_HConfigRemove(hconfig, index, keyString, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfigIter
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Remove an element from a squence or map HConfig object. Either <TT>index</TT>
     (for sequence) or <TT>keyString</TT> (for map) must be provided. An error is
     flagged if neither optional argument is specified.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> object.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064600000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">46</SPAN> ESMF_HConfigSet - Set &lt;Type&gt; content in HConfig object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_HConfigSet(hconfig, content, &amp;
      index, keyString, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfig[Iter]), intent(in)      :: hconfig
      &lt;Type&gt;,             intent(in)            :: content[(:)]
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the content of type &lt;Type&gt; to <TT>hconfig</TT>,
     at the current location, or as specified by <TT>index</TT> or <TT>keyString</TT>
     (mutually exclusive!).
     Most &lt;Type&gt; options support the sequence array variant <TT>(:)</TT> in
     addition to the scalar variant.

<P>
The supported &lt;Type&gt; options are:
     
<UL>
<LI><TT>type(HConfig)</TT> (Scalar only variant!
                               Only a single HConfig object can be provided.)
</LI>
<LI><TT>integer(ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>
</LI>
<LI><TT>character(*)</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>content</STRONG></DT>
<DD>The content to be set.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064700000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">47</SPAN> ESMF_HConfigSetMapKey - Set &lt;Type&gt; content in HConfig MapKey object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_HConfigSet(hconfig, content, &amp;
      index, keyString, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)        :: hconfig
      &lt;Type&gt;,             intent(in)            :: content[(:)]
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the content of type &lt;Type&gt; to the <TT>hconfig</TT> map key,
     at the current location, or as specified by <TT>index</TT> or <TT>keyString</TT>
     (mutually exclusive!).
     Most &lt;Type&gt; options support the sequence array variant <TT>(:)</TT> in
     addition to the scalar variant.

<P>
The supported &lt;Type&gt; options are:
     
<UL>
<LI><TT>type(HConfig)</TT> (Scalar only variant!
                               Only a single HConfig object can be provided.)
</LI>
<LI><TT>integer(ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>
</LI>
<LI><TT>character(*)</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>content</STRONG></DT>
<DD>The content to be set.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064800000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">48</SPAN> ESMF_HConfigSetMapVal - Set &lt;Type&gt; content in HConfig MapVal object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_HConfigSet(hconfig, content, &amp;
      index, keyString, doc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_HConfigIter), intent(in)        :: hconfig
      &lt;Type&gt;,             intent(in)            :: content[(:)]
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,            intent(in),  optional :: index
      character(*),       intent(in),  optional :: keyString
      integer,            intent(in),  optional :: doc
      integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Set the content of type &lt;Type&gt; to the <TT>hconfig</TT> map value,
     at the current location, or as specified by <TT>index</TT> or <TT>keyString</TT>
     (mutually exclusive!).
     Most &lt;Type&gt; options support the sequence array variant <TT>(:)</TT> in
     addition to the scalar variant.

<P>
The supported &lt;Type&gt; options are:
     
<UL>
<LI><TT>type(HConfig)</TT> (Scalar only variant!
                               Only a single HConfig object can be provided.)
</LI>
<LI><TT>integer(ESMF_KIND_I4)</TT>
</LI>
<LI><TT>integer(ESMF_KIND_I8)</TT>
</LI>
<LI><TT>logical</TT>
</LI>
<LI><TT>real(ESMF_KIND_R4)</TT>
</LI>
<LI><TT>real(ESMF_KIND_R8)</TT>
</LI>
<LI><TT>character(*)</TT>
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD><TT>ESMF_HConfig</TT> or <TT>ESMF_HConfigIter</TT> object.
     
</DD>
<DT><STRONG>content</STRONG></DT>
<DD>The content to be set.
     
</DD>
<DT><STRONG>[index]</STRONG></DT>
<DD>Attempt to access by index if specified.
       Requires <TT>hconfig</TT> of NodeType Sequence.
       Muturally exclusive with <TT>keyString</TT>.
     
</DD>
<DT><STRONG>[keyString]</STRONG></DT>
<DD>Attempt to access by key string if specified.
       Requires <TT>hconfig</TT> of NodeType Map.
       Muturally exclusive with <TT>index</TT>.
     
</DD>
<DT><STRONG>[doc]</STRONG></DT>
<DD>The doc index. Defaults to the first document.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601064900000000000000">
<SPAN CLASS="arabic">48</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">49</SPAN> ESMF_HConfigValidateMapKeys - Validate map keys against list of vocabulary</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_HConfigValidateMapKeys(hconfig, vocabulary, &amp;
     badKey, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_HConfigValidateMapKeys
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_HConfig),        intent(in)            :: hconfig
     character(len=*),          intent(in)            :: vocabulary(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(:), allocatable, intent(out), optional :: badKey
     integer,                   intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validate that the <EM>map</EM> held in <TT>hconfig</TT> only uses <EM>keys</EM> that
     are listed in <TT>vocabulary</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>hconfig</STRONG></DT>
<DD>A map HConfig object.
     
</DD>
<DT><STRONG>vocabulary</STRONG></DT>
<DD>List of <EM>keys</EM> to validate against.
     
</DD>
<DT><STRONG>[badKey]</STRONG></DT>
<DD>If returning <TT>.false.</TT> with <TT>ESMF_SUCCESS</TT>, then <TT>badKey</TT> is
       set to the first <EM>key</EM> in <TT>hconfig</TT> that was <EM>not</EM> found in
       <TT>vocabulary</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION060110000000000000000"></A>
<A NAME="log_class"></A>
<BR>
<SPAN CLASS="arabic">49</SPAN> Log Class
</H1>

<H2><A NAME="SECTION060111000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:Log"></A>
<P>
The Log class consists of a variety of methods for writing error, warning, and
informational messages to files.  A default Log is created at ESMF
initialization.  Other Logs can be created later in the code by the user.  Most
Log methods take a Log as an optional argument and apply to the default Log
when another Log is not specified.  A set of standard return codes and
associated messages are provided for error handling.  

<P>
Log provides capabilities to store message entries in a buffer, which is 
flushed to a file, either when the buffer is full, or when the user calls an 
<TT>ESMF_LogFlush()</TT> method.  Currently, the default is for the Log to flush
after every ten entries.  This can easily be changed by using the 
<TT>ESMF_LogSet()</TT> method and setting the <TT>maxElements</TT> property to 
another value.  The <TT>ESMF_LogFlush()</TT> method is automatically called when 
the program exits by any means (program completion, halt on error, or when the
Log is closed).

<P>
The user has the capability to abort the program on conditions such as
an error or on a warning by using the <TT>ESMF_LogSet()</TT> method with
the <TT>logmsgAbort</TT> argument.  For example if the  <TT>logmsgAbort</TT> array
is set to <TT>(ESMF_LOGMSG_ERROR,ESMF_LOGMSG_WARNING)</TT>, the program will 
stop on any and all warning or errors.  When the <TT>logmsgAbort</TT> argument
is set to  <TT>ESMF_LOGMSG_ERROR</TT>, the program will only abort on
errors.  Lastly, the user can choose to never abort by using
<TT>ESMF_LOGMSG_NONE</TT>; this is the default.

<P>
Log will automatically put the PET number into the Log.  Also, the user can 
either specify <TT>ESMF_LOGKIND_SINGLE</TT> which writes all the entries to a single 
Log or <TT>ESMF_LOGKIND_MULTI</TT> which writes entries to multiple Logs according to 
the PET number.  To distinguish Logs from each other when using 
<TT>ESMF_LOGKIND_MULTI</TT>, the PET number (in the format <TT>PETx.</TT>) will be 
prepended to the file name where x is the PET number.

<P>
Opening multiple log files and writing log messages from all the processors
may affect the application performance while running on a large number of
processors.  For that reason, <TT>ESMF_LOGKIND_NONE</TT> is provided to
switch off the Log capability.  All the Log methods have no effect
in the <TT>ESMF_LOGKIND_NONE</TT> mode.

<P>
A tracing capability may be enabled by setting the <TT>trace</TT> flag by
using the <TT>ESMF_LogSet()</TT> method.  When tracing is enabled, calls to
methods such as <TT>ESMF_LogFoundError</TT>, <TT>ESMF_LogFoundAllocError</TT>,
and <TT>ESMF_LogFoundDeallocError</TT> are logged in the default log file.
This can result in voluminous output.  It is typically used only around areas
of code which are being debugged.

<P>
Other options that are planned for Log are to adjust the verbosity of output, and to optionally write to <TT>stdout</TT> instead of file(s).

<P>

<H2><A NAME="SECTION060112000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION060112100000000000000"></A>
<A NAME="const:logerr"></A>
<BR>
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LOGERR
</H3>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGERR_PASSTHRU</STRONG></DT>
<DD>A named character constant, with a predefined generic error message, 
		that can be used for the <TT>msg</TT> argument in any <TT>ESMF_Log</TT> 
		routine.  The message indicated 
		by this named constant is &ldquo;<I>Passing error in return code</I>."
</DD>
</DL>

<P>

<H3><A NAME="SECTION060112200000000000000"></A>
<A NAME="const:logkindflag"></A>
<BR>
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LOGKIND
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Specifies a single log file, multiple log files (one per PET), or no log files.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_LogKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGKIND_SINGLE</STRONG></DT>
<DD>Use a single log file, combining messages from all of the PETs.  Not supported on some platforms.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_MULTI</STRONG></DT>
<DD>Use multiple log files -- one per PET.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_MULTI_ON_ERROR</STRONG></DT>
<DD>Use multiple log files -- one per PET.  A log file is only opened when a message
         of type <TT>ESMF_LOGMSG_ERROR</TT> is encountered.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_NONE</STRONG></DT>
<DD>Do not issue messages to a log file.
</DD>
</DL>

<P>

<H3><A NAME="SECTION060112300000000000000"></A>
<A NAME="const:logmsgflag"></A>
<BR>
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LOGMSG
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

Specifies a message level

<P>
The type of this flag is:

<P>
<TT>type(ESMF_LogMsg_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGMSG_INFO</STRONG></DT>
<DD>Informational messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_WARNING</STRONG></DT>
<DD>Warning messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_ERROR</STRONG></DT>
<DD>Error messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_TRACE</STRONG></DT>
<DD>Trace messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_DEBUG</STRONG></DT>
<DD>DEBUG messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_JSON</STRONG></DT>
<DD>JSON format messages
</DD>
</DL>

<P>
Valid predefined named array constant values are:

<P>
<DL>
<DT><STRONG>ESMF_LOGMSG_ALL</STRONG></DT>
<DD>All messages
	
</DD>
<DT><STRONG>ESMF_LOGMSG_NONE</STRONG></DT>
<DD>No messages
	
</DD>
<DT><STRONG>ESMF_LOGMSG_NOTRACE</STRONG></DT>
<DD>All messages EXCEPT trace messages
</DD>
</DL>

<P>

<H2><A NAME="SECTION060113000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
By default <TT>ESMF_Initialize()</TT> opens a default Log in 
<TT>ESMF_LOGKIND_MULTI</TT> mode. ESMF handles the initialization and finalization
of the default Log so the user can immediately start using it. If additional Log
objects are desired, they must be explicitly created or opened using
<TT>ESMF_LogOpen()</TT>.

<P>
<TT>ESMF_LogOpen()</TT> requires a Log object and filename argument. Additionally,
the user can specify single or multi Logs by setting the <TT>logkindflag</TT> property
to <TT>ESMF_LOGKIND_SINGLE</TT> or <TT>ESMF_LOGKIND_MULTI</TT>.
This is useful as the PET numbers are automatically added to the Log entries.
A single Log will put all entries, regardless of PET number, into a single
log while a multi Log will create multiple Logs with the PET number prepended
to the filename and all entries will be written to their corresponding Log 
by their PET number.

<P>
By default, the Log file is not truncated at the start of a new run; it just
gets appended each time.  Future functionality may include an option to
either truncate or append to the Log file. 

<P>
In all cases where a Log is opened, a Fortran unit number is assigned to a specific
Log.  A Log is assigned an unused unit number using the algorithm described in
the <TT>ESMF_IOUnitGet()</TT> method.

<P>
The user can then set or get options on how the Log should be used 
with the <TT>ESMF_LogSet()</TT> and <TT>ESMF_LogGet()</TT> methods.  These are 
partially implemented at this time. 

<P>
Depending on how the options are set, <TT>ESMF_LogWrite()</TT> either writes user
messages directly to a Log file or writes to a buffer that can be flushed when 
full or by using the <TT>ESMF_LogFlush()</TT> method.  The default is to flush 
after every ten entries because <TT>maxElements</TT> is initialized to ten 
(which means the buffer reaches its full state after every ten writes and then
flushes).

<P>
A message filtering option may be set with <TT>ESMF_LogSet()</TT> so
that only selected message types are actually written to the log.  One key
use of this feature is to allow placing informational log write requests
into the code for debugging or tracing.  Then, when the informational entries
are not needed, the messages at that level may be turned off -- leaving only
warning and error messages in the logs. 

<P>
For every <TT>ESMF_LogWrite()</TT>, a time and date stamp is prepended to the
Log entry.  The time is given in microsecond precision.  The user can call 
other methods to write to the Log.  In every case, all methods eventually make 
a call implicitly to <TT>ESMF_LogWrite()</TT> even though the user may never 
explicitly call it.

<P>
When calling <TT>ESMF_LogWrite()</TT>, the user can supply an optional line,
file and method.  These arguments can be passed in explicitly or with the help
of cpp macros.  In the latter case, a define for an <TT>ESMF_FILENAME</TT> must 
be placed at the beginning of a file and a define for <TT>ESMF_METHOD</TT> must
be placed at the beginning of each method.  The user can then use the
<TT>ESMF_CONTEXT</TT> cpp macro in place of line, file and method to insert the 
parameters into the method.  The user does not have to specify line number as
it is a value supplied by cpp.

<P>
An example of Log output is given below running with <TT>logkindflag</TT> 
property set to <TT>ESMF_LOGKIND_MULTI</TT> (default) using the default Log:

<P>
(Log file <TT>PET0.ESMF_LogFile</TT>)
<PRE>
20041105 163418.472210 INFO      PET0     Running with ESMF Version 2.2.1
</PRE>

<P>
(Log file <TT>PET1.ESMF_LogFile</TT>)
<PRE>
20041105 163419.186153 ERROR     PET1     ESMF_Field.F90             812  
ESMF_FieldGet No Grid or Bad Grid attached to Field
</PRE>

<P>
The first entry shows date and time stamp.  The time is given in microsecond 
precision.  The next item shown is the type of message (INFO in this case).  
Next, the PET number is added.  Lastly, the content is written.

<P>
The second entry shows something slightly different.  In this case, we have
an ERROR.  The method name (ESMF_Field.F90) is automatically provided from 
the cpp macros as well as the line number (812).  Then the content of the 
message is written.

<P>
When done writing messages, the default Log is closed by calling 
<TT>ESMF_LogFinalize()</TT>  or <TT>ESMF_LogClose()</TT> for user created Logs.  
Both methods will release the assigned unit number.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_LogErrEx - Log Error examples
!
! !DESCRIPTION:
!
! This program shows examples of Log Error writing
!-----------------------------------------------------------------------------
</PRE>

<P>
<PRE>
! Macros for cpp usage
! File define
#define ESMF_FILENAME "ESMF_LogErrEx.F90"
! Method define
#define ESMF_METHOD "program ESMF_LogErrEx"
#include "ESMF_LogMacros.inc"

    ! ESMF Framework module
    use ESMF
    use ESMF_TestMod
    implicit none

    ! return variables
    integer :: rc1, rc2, rc3, rcToTest, allocRcToTest, result
    type(ESMF_LOG) :: alog  ! a log object that is not the default log
    type(ESMF_LogKind_Flag) :: logkindflag
    type(ESMF_Time) :: time
    type(ESMF_VM) :: vm
    integer, pointer :: intptr(:)
</PRE>

<P>

<H3><A NAME="SECTION060113100000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Default Log</A>
</H3>

<P>
This example shows how to use the default Log.  This example does not use cpp
   macros but does use multi Logs.  A separate Log will be created for each PET.
<P>
<PRE>
    ! Initialize ESMF to initialize the default Log
    call ESMF_Initialize(vm=vm, defaultlogfilename="LogErrEx.Log", &amp;
                     logkindflag=ESMF_LOGKIND_MULTI, rc=rc1)
</PRE>

<P>
<PRE>
    ! LogWrite
    call ESMF_LogWrite("Log Write 2", ESMF_LOGMSG_INFO, rc=rc2)
</PRE>

<P>
<PRE>
    ! LogMsgSetError
    call ESMF_LogSetError(ESMF_RC_OBJ_BAD, msg="Convergence failure", &amp;
                             rcToReturn=rc2)
</PRE>

<P>
<PRE>
    ! LogMsgFoundError
    call ESMF_TimeSet(time, calkindflag=ESMF_CALKIND_NOCALENDAR)
    call ESMF_TimeSyncToRealTime(time, rc=rcToTest)
    if (ESMF_LogFoundError(rcToTest, msg="getting wall clock time", &amp;
                              rcToReturn=rc2)) then
        ! Error getting time. The previous call will have printed the error
        ! already into the log file.  Add any additional error handling here.
        ! (This call is expected to provoke an error from the Time Manager.)
    endif

    ! LogMsgFoundAllocError
    allocate(intptr(10), stat=allocRcToTest)
    if (ESMF_LogFoundAllocError(allocRcToTest, msg="integer array", &amp;
                                   rcToReturn=rc2)) then
        ! Error during allocation.  The previous call will have logged already
        ! an error message into the log.
    endif
    deallocate(intptr)
</PRE>

<P>

<H3><A NAME="SECTION060113200000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> User created Log</A>
</H3>
   This example shows how to use a user created Log.  This example uses
   cpp macros.
<P>
<PRE>
    ! Open a Log named "Testlog.txt" associated with alog.
    call ESMF_LogOpen(alog, "TestLog.txt", rc=rc1)
</PRE>

<P>
<PRE>
%/////////////////////////////////////////////////////////////

 \begin{verbatim}
    ! LogWrite
    call ESMF_LogWrite("Log Write 2", ESMF_LOGMSG_INFO, &amp;
                       line=__LINE__, file=ESMF_FILENAME, &amp;
                       method=ESMF_METHOD, log=alog, rc=rc2)
</PRE>

<P>
<PRE>
    ! LogMsgSetError
    call ESMF_LogSetError(ESMF_RC_OBJ_BAD,  msg="Interpolation Failure", &amp;
                          line=__LINE__, file=ESMF_FILENAME, &amp;
                           method=ESMF_METHOD, rcToReturn=rc2, log=alog)
</PRE>

<P>

<H3><A NAME="SECTION060113300000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Get and Set</A>
</H3>
   This example shows how to use Get and Set routines, on both the default Log
   and the user created Log from the previous examples.
<P>
<PRE>
    ! This is an example showing a query of the default Log.  Please note that
    ! no Log is passed in the argument list, so the default Log will be used.
    call ESMF_LogGet(logkindflag=logkindflag, rc=rc3)
</PRE>

<P>
<PRE>
    ! This is an example setting a property of a Log that is not the default.
    ! It was opened in a previous example, and the handle for it must be
    ! passed in the argument list.
    call ESMF_LogSet(log=alog, logmsgAbort=(/ESMF_LOGMSG_ERROR/), rc=rc2)
</PRE>

<P>
<PRE>
    ! Close the user log.
    call ESMF_LogClose(alog, rc=rc3)
</PRE>

<P>
<PRE>
    ! Finalize ESMF to close the default log
    call ESMF_Finalize(rc=rc1)
</PRE>

<P>


<H2><A NAME="SECTION060114000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Line, file and method are only available when using the C 
preprocessor</B>
Message writing methods are expanded using the ESMF macro ESMF_CONTEXT 
that adds the predefined symbolic constants __LINE__ and __FILE__ (or 
the ESMF constant ESMF_FILENAME if defined) and the ESMF constant ESMF_METHOD 
to the argument list.  Using these constants, we can associate a file name, 
line number and method name with the message.  If the CPP preprocessor is not 
used, this expansion will not be done and hence the ESMF macro ESMF_CONTEXT 
can not be used, leaving the file name, line number and method out of the Log 
text.

<P>
</LI>
<LI><B>Get and set methods are partially implemented.</B>
Currently, the <TT>ESMF_LogGet()</TT> and <TT>ESMF_LogSet()</TT> methods are 
partially implemented.   

<P>
</LI>
<LI><B>Log only appends entries.</B>
All writing to the Log is appended rather than overwriting the Log.  Future 
enhancements include the option to either append to an existing Log or 
overwrite the existing Log.

<P>
</LI>
<LI><B>Avoiding conflicts with the default Log.</B>

The private methods <TT>ESMF_LogInitialize()</TT> and <TT>ESMF_LogFinalize()</TT> 
are called during <TT>ESMF_Initialize()</TT> and <TT>ESMF_Finalize()</TT> 
respectively, so they do not need to be called if the default Log is used. 
If a new Log is required, <TT>ESMF_LogOpen()</TT> is used with a new Log object 
passed in so that there are no conflicts with the default Log.

<P>
</LI>
<LI><B>ESMF_LOGKIND_SINGLE does not work properly.</B>
When the <TT>ESMF_LogKind_Flag</TT> is set to <TT>ESMF_LOGKIND_SINGLE</TT>, different system may behave
differently.  The log messages from some processors may be lost or overwritten
by other processors.  Users are advised not to use this mode.  The MPI-based
I/O will be implemented to fix the problem in the future release. 

<P>
</LI>
</OL>

<H2><A NAME="SECTION060115000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<OL>
<LI>The Log class was implemented in Fortran and uses the Fortran I/O 
libraries when the class methods are called from Fortran. The C/C++ Log
methods use the Fortran I/O library by calling utility functions that are
written in Fortran. These utility functions call the standard Fortran write, 
open and close functions.  At initialization an <TT>ESMF_LOG</TT> is created. 
The <TT>ESMF_LOG</TT> stores information for a specific Log file.   When working 
with more than one Log file, multiple <TT>ESMF_LOG</TT>'s are required (one 
<TT>ESMF_LOG</TT> for each Log file).  For each Log, a handle is returned 
through the <TT>ESMF_LogInitialize</TT> method for the default log or <TT>ESMF_LogOpen</TT> for a user created log.  The user can specify single or multi logs by 
setting the <TT>logkindflag</TT> property in the <TT>ESMF_LogInitialize</TT> or 
<TT>ESMF_Open</TT> method to <TT>ESMF_LOGKIND_SINGLE</TT> or <TT>ESMF_LOGKIND_MULTI</TT>.
Similarly, the user can set the <TT>logkindflag</TT> property for the default
Log with the <TT>ESMF_Initialize</TT> method call.
The <TT>logkindflag</TT> is useful as the PET numbers are automatically added to the 
log entries.  A single log will put all entries, regardless of PET number, 
into a single log while a multi log will create multiple logs with the PET 
number prepended to the filename and all entries will be written to their 
corresponding log by their PET number.

<P>
The properties for a Log are set with the <TT>ESMF_LogSet()</TT> method and 
retrieved with the <TT>ESMF_LogGet()</TT> method.

<P>
Additionally, buffering is enabled.  Buffering allows <TT>ESMF</TT> to manage 
output data streams in a desired way.  Writing to the buffer is transparent 
to the user because all the Log entries are handled automatically by the 
<TT>ESMF_LogWrite()</TT> method.  All the user has to do is specify the buffer
size (the default is ten) by setting the <TT>maxElements</TT> property.  Every 
time the <TT>ESMF_LogWrite()</TT> method is called, a LogEntry element is 
populated with the <TT>ESMF_LogWrite()</TT> information.  When the buffer is 
full (i.e., when all the LogEntry elements are populated), the buffer will be 
flushed and all the contents will be written to file.  If buffering is not 
needed, that is <TT>maxElements=1</TT> or <TT>flushImmediately=ESMF_TRUE</TT>, 
the <TT>ESMF_LogWrite()</TT> method will immediately write to the Log file(s).
</LI>
</OL>

<H2><A NAME="SECTION060116000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">6</SPAN> Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
Log class.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="125" HEIGHT="306" ALIGN="BOTTOM" BORDER="0"
 SRC="img201.png"
 ALT="\includegraphics{Log_obj}">   

</DIV>

<H2><A NAME="SECTION060117000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060117100000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_LogAssignment(=) - Log assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     log1 = log2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Log) :: log1
     type(ESMF_Log) :: log2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign <TT>log1</TT> as an alias to the same <TT>ESMF_Log</TT> object in memory
     as <TT>log2</TT>. If <TT>log2</TT> is invalid, then <TT>log1</TT> will be
     equally invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>log1</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>log2</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060117200000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_LogOperator(==) - Test if Log 1 is equivalent to Log 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(==)
       if (log1 == log2) then ... endif
                    OR
       result = (log1 == log2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(in) :: log1
       type(ESMF_Log), intent(in) :: log2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Log</TT> class.
       Compare two logs for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on whether the objects
       are distinct, as with two newly created logs, or are simply aliases
       to the same log as would be the case when assignment was involved.

<P>
The arguments are:
       <DL>
<DT><STRONG>log1</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>log2</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060117300000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_LogOperator(/=) - Test if Log 1 is not equivalent to Log 2</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       interface operator(/=)
       if (log1 /= log2) then ... endif
                    OR
       result = (log1 /= log2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(in) :: log1
       type(ESMF_Log), intent(in) :: log2
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Log</TT> class.
       Compare two logs for inequality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise.  Comparison is based on whether the objects
       are distinct, as with two newly created logs, or are simply aliases
       to the same log as would be the case when assignment was involved.

<P>
The arguments are:
       <DL>
<DT><STRONG>log1</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the left hand side of the non-equality
            operation.
       
</DD>
<DT><STRONG>log2</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the right hand side of the non-equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060117400000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_LogClose - Close Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_LogClose(log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(inout), optional :: log
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This routine closes the log file(s) associated with <TT>log</TT>.
        If the log is not explicitly closed, it will be closed by
        <TT>ESMF_Finalize</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An <TT>ESMF_Log</TT> object.  If not specified, the default log is closed.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060117500000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_LogFlush - Flush the Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_LogFlush(log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(inout), optional :: log
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        intent(out),   optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine flushes the file buffer associated with <TT>log</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060117600000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_LogFoundAllocError - Check Fortran allocation status error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_LogFoundAllocError(statusToCheck,  &amp;
                                        msg,line,file, &amp;
                                        method,rcToReturn,log)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical                                    :: ESMF_LogFoundAllocError
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,          intent(in)              :: statusToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(inout), optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when <TT>statusToCheck</TT> indicates
        an allocation error, otherwise it returns <TT>.false.</TT>.  The status
        value is typically returned from a Fortran ALLOCATE statement.
        If an error is indicated, a ESMF memory allocation error message
        will be written to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>,
        <TT>line</TT>, <TT>file</TT> and <TT>method</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>statusToCheck</STRONG></DT>
<DD>Fortran allocation status to check.  Fortran specifies
              that a status of 0 (zero) indicates success.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, when the allocation status indicates an error,
              set the <TT>rcToReturn</TT> value to <TT>ESMF_RC_MEM</TT>.  Otherwise,
              <TT>rcToReturn</TT> is not modified.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060117700000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_LogFoundDeallocError - Check Fortran deallocation status error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_LogFoundDeallocError(statusToCheck,  &amp;
                                          msg,line,file, &amp;
                                          method,rcToReturn,log)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical ::ESMF_LogFoundDeallocError
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,          intent(in)              :: statusToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(inout), optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when <TT>statusToCheck</TT> indicates
        a deallocation error, otherwise it returns <TT>.false.</TT>.  The status
        value is typically returned from a Fortran DEALLOCATE statement.
        If an error is indicated, a ESMF memory allocation error message
        will be written to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>,
        <TT>line</TT>, <TT>file</TT> and <TT>method</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>statusToCheck</STRONG></DT>
<DD>Fortran deallocation status to check.  Fortran specifies
              that a status of 0 (zero) indicates success.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, when the deallocation status indicates an error,
              set the <TT>rcToReturn</TT> value to <TT>ESMF_RC_MEM</TT>.  Otherwise,
              <TT>rcToReturn</TT> is not modified.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060117800000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_LogFoundError - Check ESMF return code for error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive function ESMF_LogFoundError(rcToCheck,   &amp;
                                   msg, line, file, method, &amp;
                                   rcToReturn, log) result (LogFoundError)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: LogFoundError
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,          intent(in),    optional :: rcToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(inout), optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when <TT>rcToCheck</TT> indicates
        an return code other than <TT>ESMF_SUCCESS</TT>, otherwise it returns
        <TT>.false.</TT>.
        If an error is indicated, a ESMF predefined error message
        will be written to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>,
        <TT>line</TT>, <TT>file</TT> and <TT>method</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>[rcToCheck]</STRONG></DT>
<DD>Return code to check. Default is <TT>ESMF_SUCCESS</TT>.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, when <TT>rcToCheck</TT> indicates an error,
              set the <TT>rcToReturn</TT> to the value of <TT>rcToCheck</TT>.
              Otherwise, <TT>rcToReturn</TT> is not modified.
              This is not the return code for this function; it allows
              the calling code to do an assignment of the error code
              at the same time it is testing the value.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060117900000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_LogFoundNetCDFError - Check NetCDF status code for success or log the associated NetCDF error message.</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE> function ESMF_LogFoundNetCDFError(ncerrToCheck, msg, line, &amp;
                                   file, method, rcToReturn, log)
 
 #if defined ESMF_NETCDF
   use netcdf
 #elif defined ESMF_PNETCDF
   use pnetcdf
 #endif
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: ESMF_LogFoundNetCDFError
</PRE><EM>ARGUMENTS:</EM>
<PRE>   integer,          intent(in)              :: ncerrToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character(len=*), intent(in),    optional :: msg
   integer,          intent(in),    optional :: line
   character(len=*), intent(in),    optional :: file
   character(len=*), intent(in),    optional :: method
   integer,          intent(inout), optional :: rcToReturn
   type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when <TT>ncerrToCheck</TT> indicates
        an return code other than <TT>0</TT> (the success code from NetCDF Fortran)
        or <TT>NF_NOERR</TT> (the success code for PNetCDF). Otherwise it returns
        <TT>.false.</TT>.
        If an error is indicated, a predefined ESMF error message
        will be written to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>,
        <TT>line</TT>, <TT>file</TT> and <TT>method</TT>. The NetCDF string error
        representation will also be logged.

<P>
The arguments are:
        <DL>
<DT><STRONG>[ncerrToCheck]</STRONG></DT>
<DD>NetCDF error code to check.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by using the
              preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, when <TT>ncerrToCheck</TT> indicates an error,
              set <TT>rcToReturn</TT> to <TT>ESMF_RC_NETCDF_ERROR</TT>. The string
              representation for the error code will be retrieved from the NetCDF
              Fortran library and logged alongside any user-provided message
              string.
              Otherwise, <TT>rcToReturn</TT> is not modified.
              This is not the return code for this function; it allows the
              calling code to do an assignment of the error code at the same time
              it is testing the value.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601171000000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_LogGet - Return information about a log object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_LogGet(log,  &amp;
                              flush,    &amp;
                              logmsgAbort, logkindflag, &amp;
                              maxElements, trace, fileName,  &amp;
                              highResTimestampFlag, indentCount,  &amp;
                              noPrefix, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log),          intent(in),  optional :: log
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                 intent(out), optional :: flush
       type(ESMF_LogMsg_Flag),  pointer,     optional :: logmsgAbort(:)
       type(ESMF_LogKind_Flag), intent(out), optional :: logkindflag
       integer,                 intent(out), optional :: maxElements
       logical,                 intent(out), optional :: trace
       character(*),            intent(out), optional :: fileName
       logical,                 intent(out), optional :: highResTimestampFlag
       integer,                 intent(out), optional :: indentCount
       logical,                 intent(out), optional :: noPrefix
       integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine returns properties about a Log object.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.
        
</DD>
<DT><STRONG>[flush]</STRONG></DT>
<DD>Flush flag.
        
</DD>
<DT><STRONG>[logmsgAbort]</STRONG></DT>
<DD>Returns an array containing current message halt settings.
              If the array is not pre-allocated, <TT>ESMF_LogGet</TT> will
              allocate an array of the correct size.  If no message types
              are defined, an array of length zero is returned.  It is the
              callers responsibility to deallocate the array.
        
</DD>
<DT><STRONG>[logkindflag]</STRONG></DT>
<DD>Defines either single or multilog.
        
</DD>
<DT><STRONG>[maxElements]</STRONG></DT>
<DD>Maximum number of elements in the Log.
        
</DD>
<DT><STRONG>[trace]</STRONG></DT>
<DD>Current setting of the Log call tracing flag.
        
</DD>
<DT><STRONG>[fileName]</STRONG></DT>
<DD>Current file name.  When the log has been opened with
              <TT>ESMF_LOGKIND_MULTI</TT>, the filename has a PET number
              prefix.
        
</DD>
<DT><STRONG>[highResTimestampFlag]</STRONG></DT>
<DD>Current setting of the extended elapsed timestamp flag.
        
</DD>
<DT><STRONG>[indentCount]</STRONG></DT>
<DD>Current setting of the leading white space padding.
        
</DD>
<DT><STRONG>[noPrefix]</STRONG></DT>
<DD>Current setting of the message prefix enable/disable flag.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601171100000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_LogOpen - Open Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_LogOpen(log, filename,  &amp;
         appendflag, logkindflag, noPrefix, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Log),          intent(inout)         :: log
     character(len=*),        intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(in),  optional :: appendFlag
     type(ESMF_LogKind_Flag), intent(in),  optional :: logkindFlag
     logical,                 intent(in),  optional :: noPrefix
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This routine opens a file named <TT>filename</TT> and associates
        it with the <TT>ESMF_Log</TT>.  When <TT>logkindflag</TT> is set to
        <TT>ESMF_LOGKIND_MULTI</TT> or <TT>ESMF_LOGKIND_MULTI_ON_ERROR</TT>
        the file name is prepended with PET number identification.  If the
        incoming log is already open, an error is returned.

<P>
The arguments are:
        <DL>
<DT><STRONG>log</STRONG></DT>
<DD>An <TT>ESMF_Log</TT> object.
        
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of log file to be opened.
        
</DD>
<DT><STRONG>[appendFlag]</STRONG></DT>
<DD>If the log file exists, setting to <TT>.false.</TT> will set the file position
              to the beginning of the file.  Otherwise, new records will be appended to the
              end of the file.  If not specified, defaults to <TT>.true.</TT>.
        
</DD>
<DT><STRONG>[logkindFlag]</STRONG></DT>
<DD>Set the logkindflag. See section <A HREF="#const:logkindflag">49.2.2</A> for a list of
              valid options.  When the <TT>ESMF_LOGKIND_MULTI_ON_ERROR</TT> is selected,
              the log opening is deferred until a <TT>ESMF_LogWrite</TT> with log message of
              type <TT>ESMF_LOGMSG_ERROR</TT> is written.
              If not specified, defaults to <TT>ESMF_LOGKIND_MULTI</TT>.
        
</DD>
<DT><STRONG>[noPrefix]</STRONG></DT>
<DD>Set the noPrefix flag.  If set to <TT>.false.</TT>, log messages are prefixed
              with time stamps, message type, and PET number.  If set to <TT>.true.</TT> the
              messages will be written without prefixes.  If not specified, defaults to
              <TT>.false.</TT>.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601171200000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_LogOpen - Open Default Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LogOpen ()
     subroutine ESMF_LogOpenDefault (filename,  &amp;
         appendflag, logkindflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),        intent(in)            :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(in),  optional :: appendflag
     type(ESMF_LogKind_Flag), intent(in),  optional :: logkindflag
     integer,                 intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This routine opens a file named <TT>filename</TT> and associates
        it with the default log.  When <TT>logkindflag</TT> is set to
        <TT>ESMF_LOGKIND_MULTI</TT> the file name is prepended with PET
        number identification.  If the incoming default log is already open,
        an error is returned.

<P>
The arguments are:
        <DL>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of DEFAULT log file to be opened.
        
</DD>
<DT><STRONG>[appendflag]</STRONG></DT>
<DD>If the log file exists, setting to <TT>.false.</TT> will set the file position
              to the beginning of the file.  Otherwise, new records will be appended to the
              end of the file.  If not specified, defaults to <TT>.true.</TT>.
        
</DD>
<DT><STRONG>[logkindflag]</STRONG></DT>
<DD>Set the logkindflag. See section <A HREF="#const:logkindflag">49.2.2</A> for a list of
              valid options.
              If not specified, defaults to <TT>ESMF_LOGKIND_MULTI</TT>.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601171300000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_LogSet - Set Log parameters</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     subroutine ESMF_LogSet(log,  &amp;
         flush,  &amp;
         logmsgAbort, maxElements, logmsgList,  &amp;
         errorMask, trace, highResTimestampFlag, indentCount,  &amp;
         noPrefix, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log),         intent(inout), optional :: log
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(in),    optional :: flush
       type(ESMF_LogMsg_Flag), intent(in),    optional :: logmsgAbort(:)
       integer,                intent(in),    optional :: maxElements
       type(ESMF_LogMsg_Flag), intent(in),    optional :: logmsgList(:)
       integer,                intent(in),    optional :: errorMask(:)
       logical,                intent(in),    optional :: trace
       logical,                intent(in),    optional :: highResTimestampFlag
       integer,                intent(in),    optional :: indentCount
       logical,                intent(in),    optional :: noPrefix
       integer,                intent(out),   optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine sets the properties for the Log object.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object.  The default is to use the
              default log that was opened at <TT>ESMF_Initialize</TT> time.
        
</DD>
<DT><STRONG>[flush]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, flush log messages immediately, rather
              than buffering them.  Default is to flush after <TT>maxElements</TT>
              messages.
        
</DD>
<DT><STRONG>[logmsgAbort]</STRONG></DT>
<DD>Sets the condition on which ESMF aborts.  The array
              can contain any combination of <TT>ESMF_LOGMSG</TT> named constants.  These
              named constants are described in section <A HREF="#const:logmsgflag">49.2.3</A>.
              Default is to always continue processing.
        
</DD>
<DT><STRONG>[maxElements]</STRONG></DT>
<DD>Maximum number of elements in the Log buffer before flushing occurs.
              Default is to flush when 10 messages have been accumulated.
        
</DD>
<DT><STRONG>[logmsgList]</STRONG></DT>
<DD>An array of message types that will be logged.  Log write requests
              not matching the list will be ignored.  If an empty array is
              provided, no messages will be logged.
              See section <A HREF="#const:logmsgflag">49.2.3</A> for a list of
              valid message types.  By default, all non-trace messages will be
              logged.
        
</DD>
<DT><STRONG>[errorMask]</STRONG></DT>
<DD>List of error codes that will <EM>not</EM> be logged as errors.
              Default is to log all error codes.
        
</DD>
<DT><STRONG>[trace]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, calls such as <TT>ESMF_LogFoundError()</TT>,
              <TT>ESMF_LogFoundAllocError()</TT>, and
              <TT>ESMF_LogFoundDeallocError()</TT>
              will be logged in the default log files.  This option is intended
              to be used as a tool for debugging and program flow tracing
              within the ESMF library. Voluminous output may appear in the log,
              with a consequent slowdown in performance.  Therefore, it is
              recommended that this option only be enabled before a problematic
              call to a ESMF method, and disabled afterwards. Default is to
              not trace these calls.

</DD>
<DT><STRONG>[highResTimestampFlag]</STRONG></DT>
<DD>Sets the extended elapsed timestamp flag.  If set to <TT>.true.</TT>, a timestamp
              from <TT>ESMF_VMWtime</TT> will be included in each log message.  Default is
              to not add the additional timestamps.
        
</DD>
<DT><STRONG>[indentCount]</STRONG></DT>
<DD>Number of leading white spaces.
        
</DD>
<DT><STRONG>[noPrefix]</STRONG></DT>
<DD>If set to <TT>.false.</TT>, log messages are prefixed with time stamps,
              message type and PET number.  If set to <TT>.true.</TT> the messages will be
              written without the prefixes.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601171400000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_LogSetError - Set ESMF return code for error and write msg</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       subroutine ESMF_LogSetError(rcToCheck,  &amp;
                                   msg, line, file, method, &amp;
                                   rcToReturn, log)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer,          intent(in)              :: rcToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(out),   optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine sets the <TT>rcToReturn</TT> value to <TT>rcToCheck</TT> if
        <TT>rcToReturn</TT> is present and writes this error code to the <TT>ESMF_Log</TT>
        if an error is generated.  A predefined error message will added to the
        <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>, <TT>line</TT>, <TT>file</TT>
        and <TT>method</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>rcToCheck</STRONG></DT>
<DD>rc value for set
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor macro <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, copy the <TT>rcToCheck</TT> value to <TT>rcToreturn</TT>.
              This is not the return code for this function; it allows
              the calling code to do an assignment of the error code
              at the same time it is testing the value.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601171500000000000000">
<SPAN CLASS="arabic">49</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_LogWrite - Write to Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       recursive subroutine ESMF_LogWrite(msg, logmsgFlag, &amp;
                         logmsgList,      &amp; ! DEPRECATED ARGUMENT
                         line, file, method, log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*),      intent(in)             :: msg
       type(ESMF_LogMsg_Flag),intent(in),optional    :: logmsgFlag
       type(ESMF_LogMsg_Flag),intent(in),optional::logmsgList ! DEPRECATED ARG
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,               intent(in),   optional :: line
       character(len=*),      intent(in),   optional :: file
       character(len=*),      intent(in),   optional :: method
       type(ESMF_Log),        intent(inout),optional :: log
       integer,               intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.2.0rp1</STRONG></DT>
<DD>Added argument <TT>logmsgFlag</TT>.
                   Started to deprecate argument <TT>logmsgList</TT>.
                   This corrects inconsistent use of the <TT>List</TT> suffix on
                   the argument name. In ESMF this suffix indicates
                   one-dimensional array arguments.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This subroutine writes to the file associated with an <TT>ESMF_Log</TT>.
        A message is passed in along with the <TT>logmsgFlag</TT>, <TT>line</TT>,
        <TT>file</TT> and <TT>method</TT>.  If the write to the <TT>ESMF_Log</TT>
        is successful, the function will return a logical <TT>true</TT>.  This
        function is the base function used by all the other <TT>ESMF_Log</TT>
        writing methods.

<P>
The arguments are:
        <DL>
<DT><STRONG>msg</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[logmsgFlag]</STRONG></DT>
<DD>The type of message.  See Section&nbsp;<A HREF="#const:logmsgflag">49.2.3</A> for
              possible values.  If not specified, the default is <TT>ESMF_LOGMSG_INFO</TT>.
        
</DD>
<DT><STRONG>[logmsgList]</STRONG></DT>
<DD><B>DEPRECATED ARGUMENT!</B> Please use the argument <TT>logmsgFlag</TT> instead.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor macro <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name.
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>


<H1><A NAME="SECTION060120000000000000000">
<SPAN CLASS="arabic">50</SPAN> DELayout Class</A>
</H1>

<H2><A NAME="SECTION060121000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The DELayout class provides an additional layer of abstraction on top of the Virtual Machine (VM) layer. DELayout does this by introducing DEs (Decomposition Elements) as logical resource units. The DELayout object keeps track of the relationship between its DEs and the resources of the associated VM object. 

<P>
The relationship between DEs and VM resources (PETs (Persistent Execution Threads) and VASs (Virtual Address Spaces)) contained in a DELayout object is defined during its creation and cannot be changed thereafter. There are, however, a number of hint and specification arguments that can be used to shape the DELayout during its creation.

<P>
Contrary to the number of PETs and VASs contained in a VM object, which are fixed by the available resources, the number of DEs contained in a DELayout can be chosen freely to best match the computational problem or other design criteria. Creating a DELayout with less DEs than there are PETs in the associated VM object can be used to share resources between decomposed objects within an ESMF component. Creating a DELayout with more DEs than there are PETs in the associated VM object can be used to evenly partition the computation over the available resources.

<P>
The simplest case, however, is where the DELayout contains the same number of DEs as there are PETs in the associated VM context. In this case the DELayout may be used to re-label the hardware and operating system resources held by the VM. For instance, it is possible to order the resources so that specific DEs have best available communication paths. The DELayout will map the DEs to the PETs of the VM according to the resource details provided by the VM instance. 

<P>
Furthermore, general DE to PET mapping can be used to offer computational resources with finer granularity than the VM does. The DELayout can be queried for computational and communication capacities of DEs and DE pairs, respectively. This information can be used to best utilize the DE resources when partitioning the computational problem. In combination with other ESMF classes, general DE to PET mapping can be used to realize cache blocking, communication hiding and dynamic load balancing.

<P>
Finally, the DELayout layer offers primitives that allow a work queue style dynamic load balancing between DEs.

<H2><A NAME="SECTION060122000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION060122100000000000000"></A>
<A NAME="const:pin_flag"></A>
<BR>
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_PIN
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Specifies which VM resource DEs are pinned to (PETs, VASs, SSIs).

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Pin_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_PIN_DE_TO_PET</STRONG></DT>
<DD>Pin DEs to PETs. Only the owning PET has access to a DE.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_VAS</STRONG></DT>
<DD>Pin DEs to virtual address spaces (VAS). DEs are accessible from all PETs
    within the same VAS.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_SSI</STRONG></DT>
<DD>Pin DEs to single system images (SSI) - typically shared memory nodes.
    DEs are accessible from all PETs within the same SSI. The memory allocation
    between different DEs is allowed to be non-contiguous.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_SSI_CONTIG</STRONG></DT>
<DD>Same as <TT>ESMF_PIN_DE_TO_SSI</TT>, but the shared memory allocation
    across DEs located on the same SSI must be contigous throughout.
</DD>
</DL>

<P>

<H3><A NAME="SECTION060122200000000000000"></A>
<A NAME="const:servicereply_flag"></A>
<BR>
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_SERVICEREPLY
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Reply when a PET offers to service a DE.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_ServiceReply_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_SERVICEREPLY_ACCEPT</STRONG></DT>
<DD>The service offer has been accepted. The PET is expected to service the DE.
  
</DD>
<DT><STRONG>ESMF_SERVICEREPLY_DENY</STRONG></DT>
<DD>The service offer has been denied. The PET is expected to not service the
    DE.
</DD>
</DL>

<H2><A NAME="SECTION060123000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to create, use and destroy DELayout objects.

<P>

<P>

<P>

<H3><A NAME="SECTION060123100000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Default DELayout</A>
</H3>

<P>
Without specifying any of the optional parameters the created 
   <TT>ESMF_DELayout</TT>
   defaults into having as many DEs as there are PETs in the associated VM 
   object. Consequently the resulting DELayout describes a simple 1-to-1 DE to
   PET mapping.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(rc=rc)
</PRE>

<P>
The default DE to PET mapping is simply:
   <PRE>
   DE 0  -&gt; PET 0
   DE 1  -&gt; PET 1
   ...
</PRE>

<P>
DELayout objects that are not used any longer should be destroyed.
<P>
<PRE>
  call ESMF_DELayoutDestroy(delayout, rc=rc)
</PRE>

<P>
The optional <TT>vm</TT> argument can be provided to DELayoutCreate() to lower 
   the method's overhead by the amount it takes to determine the current VM.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(vm=vm, rc=rc)
</PRE>

<P>
By default all PETs of the associated VM will be considered. However, if the 
   optional argument <TT>petList</TT> is present DEs will only be mapped against
   the PETs contained in the list. When the following example is executed on
   four PETs it creates a DELayout with four DEs by default that are mapped 
   to the provided PETs in their given order. It is erroneous to specify PETs 
   that are not part of the VM context on which the DELayout is defined. 
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petList=(/(i,i=petCount-1,1,-1)/), rc=rc)
</PRE>

<P>
Once the end of the petList has been reached the DE to PET mapping 
   continues from the beginning of the list. For a 4 PET VM the above created
   DELayout will end up with the following DE to PET mapping:

<P>
<PRE>
   DE 0  -&gt; PET 3
   DE 1  -&gt; PET 2
   DE 2  -&gt; PET 1
   DE 2  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION060123200000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> DELayout with specified number of DEs</A>
</H3>

<P>
The <TT>deCount</TT> argument can be used to specify the number of DEs. In this
   example a DELayout is created that contains four times as many DEs as there 
   are PETs in the VM.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=4*petCount, rc=rc)
</PRE>

<P>
Cyclic DE to PET mapping is the default. For 4 PETs this means:
   <PRE>
   DE 0, 4,  8, 12  -&gt; PET 0
   DE 1, 5,  9, 13  -&gt; PET 1
   DE 2, 6, 10, 14  -&gt; PET 2
   DE 3, 7, 11, 15  -&gt; PET 3
</PRE>
   The default DE to PET mapping can be overridden by providing the
   <TT>deGrouping</TT> argument. This argument provides a positive integer group 
   number for each DE in the DELayout. All of the DEs of a group will be mapped 
   against the same PET. The actual group index is arbitrary (but must be 
   positive) and its value is of no consequence.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=4*petCount, &amp;
    deGrouping=(/(i/4,i=0,4*petCount-1)/), rc=rc)
</PRE>

<P>
This will achieve blocked DE to PET mapping. For 4 PETs this means:
   <PRE>
   DE  0,  1,  2,  3  -&gt; PET 0
   DE  4,  5,  6,  7  -&gt; PET 1
   DE  8,  9, 10, 11  -&gt; PET 2
   DE 12, 13, 14, 15  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION060123300000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> DELayout with computational and communication weights</A>
</H3>

<P>
The quality of the partitioning expressed by the DE to PET mapping depends
   on the amount and quality of information provided during DELayout creation.
   In the following example the <TT>compWeights</TT> argument is used to specify
   relative computational weights for all DEs and communication weights for
   DE pairs are provided by the <TT>commWeights</TT> argument. The example assumes
   four DEs.
<P>
<PRE>
  allocate(compWeights(4))
  allocate(commWeights(4, 4))
  ! setup compWeights and commWeights according to computational problem
  delayout = ESMF_DELayoutCreate(deCount=4, compWeights=compWeights, &amp;
    commWeights=commWeights, rc=rc)
  deallocate(compWeights, commWeights)
</PRE>

<P>
The resulting DE to PET mapping depends on the specifics of the VM object and
   the provided compWeights and commWeights arrays. 

<P>

<H3><A NAME="SECTION060123400000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> DELayout from petMap</A>
</H3>

<P>
Full control over the DE to PET mapping is provided via the <TT>petMap</TT>
   argument. This example maps the DEs to PETs in reverse order. In the 4-PET
   case this will result in the following mapping:
   <PRE>
   DE 0 -&gt; PET 3
   DE 1 -&gt; PET 2
   DE 2 -&gt; PET 1
   DE 3 -&gt; PET 0
</PRE>
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/(i,i=petCount-1,0,-1)/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060123500000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> DELayout from petMap with multiple DEs per PET</A>
</H3>

<P>
The <TT>petMap</TT> argument gives full control over DE to PET mapping. The 
   following example run on 4 or more PETs maps DEs to PETs according to the 
   following table:
   <PRE>
   DE 0 -&gt; PET 3
   DE 1 -&gt; PET 3
   DE 2 -&gt; PET 1
   DE 3 -&gt; PET 0
   DE 4 -&gt; PET 2
   DE 5 -&gt; PET 1
   DE 6 -&gt; PET 3
   DE 7 -&gt; PET 1
</PRE>
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/3, 3, 1, 0, 2, 1, 3, 1/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060123600000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Working with a DELayout - simple 1-to-1 DE-to-PET mapping</A>
</H3>

<P>
The simplest case is a DELayout where there is exactly one DE for every PET.
   Of course this implies that the number of DEs equals the number of PETs. 
   This special 1-to-1 DE-to-PET mapping is very common and many applications
   assume it. The following example shows how a DELayout can be queried about
   its mapping.

<P>
First a default DELayout is created where the number of DEs equals the number
   of PETs, and are associated 1-to-1.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(rc=rc)
</PRE>

<P>
Next the DELayout is queried for the <TT>oneToOneFlag</TT>, and the user code
   makes a decision based on its value.
<P>
<PRE>
  call ESMF_DELayoutGet(delayout, oneToOneFlag=oneToOneFlag, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  if (.not. oneToOneFlag) then
    ! handle the unexpected case of not dealing with a 1-to-1 mapping
  else
</PRE>

<P>
1-to-1 mapping is guaranteed in this branch and the following code can
   work under the simplifying assumption that every PET holds exactly one DE:
<P>
<PRE>
    allocate(localDeToDeMap(1))
    call ESMF_DELayoutGet(delayout, localDeToDeMap=localDeToDeMap, rc=rc)
    if (rc /= ESMF_SUCCESS) finalrc=rc
    myDe = localDeToDeMap(1)
    deallocate(localDeToDeMap)
    if (finalrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>

<H3><A NAME="SECTION060123700000000000000"></A>
   <A NAME="DELayout_general_mapping"></A>
<BR>
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Working with a DELayout - general DE-to-PET mapping
</H3>

<P>
In general a DELayout may map any number (including zero) of DEs against
   a single PET. The exact situation can be detected by querying the DELayout
   for the <TT>oneToOneFlag</TT>. If this flag comes back as <TT>.true.</TT> then the 
   DELayout maps exactly one DE against each PET, but if it comes back as
   <TT>.false.</TT> the DELayout describes a more general DE-to-PET layout. The 
   following example shows how code can be be written to work for a general
   DELayout.

<P>
First a DELayout is created with two more DEs than there are PETs. The 
   DELayout will consequently map some DEs to the same PET.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=petCount+2, rc=rc)
</PRE>

<P>
The first piece of information needed on each PET is the <TT>localDeCount</TT>.
   This number may be different on each PET and indicates how many DEs are 
   mapped against the local PET.
<P>
<PRE>
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
</PRE>

<P>
The DELayout can further be queried for a list of DEs that are held by
   the local PET. This information is provided by the <TT>localDeToDeMap</TT>
   argument. In ESMF a <TT>localDe</TT> is an index that enumerates the DEs that
   are associated with the local PET. In many cases the exact bounds of the
   <TT>localDe</TT> index range, e.g. <!-- MATH
 $[0...localDeCount-1]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="160" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img202.png"
 ALT="$[0...localDeCount-1]$"></SPAN>, or <!-- MATH
 $[1...localDeCount]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="133" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img203.png"
 ALT="$[1...localDeCount]$"></SPAN> 
   does not matter, since it only affects how user code indexes into variables
   the user allocated, and therefore set the specific bounds. However, there are 
   a few Array and Field level calls that take <TT>localDe</TT> input arguments. In 
   all those cases where the <TT>localDe</TT> index variable is passed into an ESMF
   call as an input argument, it <EM>must</EM> be defined with a range starting at
   zero, i.e. <!-- MATH
 $[0...localDeCount-1]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="160" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img202.png"
 ALT="$[0...localDeCount-1]$"></SPAN>.

<P>
For consistency with Array and Field, the following code uses a 
   <!-- MATH
 $[0...localDeCount-1]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="160" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img202.png"
 ALT="$[0...localDeCount-1]$"></SPAN> range for the <TT>localDe</TT> index variable, 
   although it is not strictly necessary here:
<P>
<PRE>
  allocate(localDeToDeMap(0:localDeCount-1))
  call ESMF_DELayoutGet(delayout, localDeToDeMap=localDeToDeMap, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  do localDe=0, localDeCount-1
    workDe = localDeToDeMap(localDe)
!    print *, "I am PET", localPET, " and I am working on DE ", workDe
  enddo
  deallocate(localDeToDeMap)
  if (finalrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION060123800000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Work queue dynamic load balancing</A>
</H3>

<P>
The DELayout API includes two calls that can be used to easily implement
   work queue dynamic load balancing. The workload is broken up into DEs
   (more than there are PETs) and processed by the PETs. Load balancing is
   only possible for ESMF multi-threaded VMs and requires that DEs are pinned
   to VASs instead of the PETs (default). The following example will
   run for any VM and DELayout, however, load balancing will only occur under the
   mentioned conditions.
<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=petCount+2, &amp;
    pinflag=ESMF_PIN_DE_TO_VAS, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, vasLocalDeCount=localDeCount, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  allocate(localDeToDeMap(localDeCount))
  call ESMF_DELayoutGet(delayout, vasLocalDeToDeMap=localDeToDeMap, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  do i=1, localDeCount
    workDe = localDeToDeMap(i)
    print *, "I am PET", localPET, &amp;
             " and I am offering service for DE ", workDe
    reply = ESMF_DELayoutServiceOffer(delayout, de=workDe, rc=rc)
    if (rc /= ESMF_SUCCESS) finalrc=rc
    if (reply == ESMF_SERVICEREPLY_ACCEPT) then
      ! process work associated with workDe
      print *, "I am PET", localPET, ", service offer for DE ", workDe, &amp;
        " was accepted."
      call ESMF_DELayoutServiceComplete(delayout, de=workDe, rc=rc)
      if (rc /= ESMF_SUCCESS) finalrc=rc
    endif
  enddo
  deallocate(localDeToDeMap)
  if (finalrc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>


<H2><A NAME="SECTION060124000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<H2><A NAME="SECTION060125000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The DELayout class is a light weight object. It stores the DE to PET and VAS mapping for all DEs within all PET instances and a list of local DEs for each PET instance. The DELayout does not store the computational and communication weights optionally provided as arguments to the create method. These hints are only used during create while they are available in user owned arrays.

<H2><A NAME="SECTION060126000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060126100000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_DELayoutAssignment(=) - DELayout assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     delayout1 = delayout2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout) :: delayout1
     type(ESMF_DELayout) :: delayout2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign delayout1 as an alias to the same ESMF DELayout object in memory
     as delayout2. If delayout2 is invalid, then delayout1 will be equally
     invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060126200000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_DELayoutOperator(==) - DELayout equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (delayout1 == delayout2) then ... endif
               OR
     result = (delayout1 == delayout2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout), intent(in) :: delayout1
     type(ESMF_DELayout), intent(in) :: delayout2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether delayout1 and delayout2 are valid aliases to the same ESMF
     DELayout object in memory. For a more general comparison of two
     ESMF DELayouts, going beyond the simple alias test, the 
     ESMF_DELayoutMatch() function (not yet implemented) must
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060126300000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_DELayoutOperator(/=) - DELayout not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (delayout1 /= delayout2) then ... endif
               OR
     result = (delayout1 /= delayout2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout), intent(in) :: delayout1
     type(ESMF_DELayout), intent(in) :: delayout2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether delayout1 and delayout2 are <I>not</I> valid aliases to the
     same ESMF DELayout object in memory. For a more general comparison of two
     ESMF DELayouts, going beyond the simple alias test, the 
     ESMF_DELayoutMatch() function (not yet implemented) must
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060126400000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_DELayoutCreate - Create DELayout object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DELayoutCreate()
   recursive function ESMF_DELayoutCreateDefault(deCount, &amp;
     deGrouping, pinflag, petList, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DELayout) :: ESMF_DELayoutCreateDefault
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                      intent(in),  optional :: deCount
     integer, target,              intent(in),  optional :: deGrouping(:)
     type(ESMF_Pin_Flag),          intent(in),  optional :: pinflag
     integer, target,              intent(in),  optional :: petList(:)
     type(ESMF_VM),                intent(in),  optional :: vm
     integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DELayout</TT> object on the basis of optionally provided
       restrictions. By default a DELayout with deCount equal to petCount will
       be created, each DE mapped to a single PET. However, the number of DEs
       as well grouping of DEs and PETs can be specified via the optional
       arguments.

<P>
The arguments are:
       <DL>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>Number of DEs to be provided by the created DELayout. By default
            the number of DEs equals the number of PETs in the associated VM
            context. Specifying a <TT>deCount</TT> smaller than the number
            of PETs will result in unassociated PETs.
            This may be used to share VM resources between DELayouts within the
            same ESMF component. Specifying a <TT>deCount</TT> greater than the 
            number of PETs will result in multiple DE to PET mapping.
       
</DD>
<DT><STRONG>[deGrouping]</STRONG></DT>
<DD>This optional argument must be of size deCount. Its content assigns
            a DE group index to each DE of the DELayout. A group index of -1 
            indicates that the associated DE isn't member of any particular 
            group. The significance of DE groups is that all the DEs belonging
            to a certain group will be mapped against the <EM>same</EM> PET. This
            does not, however, mean that DEs belonging to different DE groups 
            must be mapped to different PETs.
       
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>This flag specifies which type of resource DEs are pinned to. 
            The default is to pin DEs to PETs. Alternatively it is
            also possible to pin DEs to VASs. See section 
            <A HREF="#const:pin_flag">50.2.1</A> for a list of valid pinning options.
       
</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List specifying PETs to be used by this DELayout. This can be used
            to control the PET overlap between DELayouts within the same
            ESMF component. It is erroneous to specify PETs that are not within 
            the provided VM context. The default is to include all the PETs of
            the VM.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the DELayout object is created on the specified 
            <TT>ESMF_VM</TT> object. The default is to create on the VM of the 
            current context.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060126500000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_DELayoutCreate - Create DELayout from petMap</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DELayoutCreate()
   recursive function ESMF_DELayoutCreateFromPetMap(petMap, &amp;
     pinflag, vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DELayout) :: ESMF_DELayoutCreateFromPetMap
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                      intent(in)            :: petMap(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Pin_Flag),          intent(in),  optional :: pinflag
     type(ESMF_VM),                intent(in),  optional :: vm
     integer,                      intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DELayout</TT> with exactly specified DE to PET mapping.

<P>
This ESMF method must be called in unison by all PETs of the VM. Calling
       this method from a PET not part of the VM or not calling it from a PET
       that is part of the VM will result in undefined behavior. ESMF does not
       guard against violation of the unison requirement. The call is not
       collective, there is no communication between PETs.

<P>
The arguments are:
       <DL>
<DT><STRONG>petMap</STRONG></DT>
<DD>List specifying the DE-to-PET mapping. The list elements correspond 
            to DE 0, 1, 2, ... and map against the specified PET of the VM
            context. The size of the <TT>petMap</TT> 
            argument determines the number of DEs in the created DELayout. It is
            erroneous to specify a PET identifier that lies outside the VM 
            context.
       
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>This flag specifies which type of resource DEs are pinned to. 
            The default is to pin DEs to PETs. Alternatively it is
            also possible to pin DEs to VASs. See section 
            <A HREF="#const:pin_flag">50.2.1</A> for a list of valid pinning options.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>If present, the DELayout object is created on the specified 
            <TT>ESMF_VM</TT> object. The default is to create on the VM of the 
            current context.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060126600000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_DELayoutDestroy - Release resources associated with DELayout object</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_DELayoutDestroy(delayout, noGarbage, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(inout)          :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,              intent(in),   optional :: noGarbage
     integer,              intent(out),  optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>noGarbage</TT>.
     The argument provides a mechanism to override the default garbage collection
     mechanism when destroying an ESMF object.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_DELayout</TT> object, releasing the resources associated
     with the object.

<P>
By default a small remnant of the object is kept in memory in order to 
     prevent problems with dangling aliases. The default garbage collection
     mechanism can be overridden with the <TT>noGarbage</TT> argument.

<P>
The arguments are:
   <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[noGarbage]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the object will be fully destroyed and removed
        from the ESMF garbage collection system. Note however that under this 
        condition ESMF cannot protect against accessing the destroyed object 
        through dangling aliases - a situation which may lead to hard to debug 
        application crashes.

<P>
It is generally recommended to leave the <TT>noGarbage</TT> argument
        set to <TT>.FALSE.</TT> (the default), and to take advantage of the ESMF 
        garbage collection system which will prevent problems with dangling
        aliases or incorrect sequences of destroy calls. However this level of
        support requires that a small remnant of the object is kept in memory
        past the destroy call. This can lead to an unexpected increase in memory
        consumption over the course of execution in applications that use 
        temporary ESMF objects. For situations where the repeated creation and 
        destruction of temporary objects leads to memory issues, it is 
        recommended to call with <TT>noGarbage</TT> set to <TT>.TRUE.</TT>, fully 
        removing the entire temporary object from memory.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060126700000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_DELayoutGet - Get object-wide DELayout information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_DELayoutGet(delayout, vm, deCount,&amp;
     petMap, vasMap, oneToOneFlag, pinflag, localDeCount, localDeToDeMap, &amp;
     localDeList, &amp;      ! DEPRECATED ARGUMENT
     vasLocalDeCount, vasLocalDeToDeMap, &amp;
     vasLocalDeList, &amp;   ! DEPRECATED ARGUMENT
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),      intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_VM),            intent(out), optional :: vm
     integer,                  intent(out), optional :: deCount
     integer, target,          intent(out), optional :: petMap(:)
     integer, target,          intent(out), optional :: vasMap(:)
     logical,                  intent(out), optional :: oneToOneFlag
     type(ESMF_Pin_Flag),      intent(out), optional :: pinflag
     integer,                  intent(out), optional :: localDeCount
     integer, target,          intent(out), optional :: localDeToDeMap(:)
     integer, target, intent(out), optional :: localDeList(:)  !DEPRECATED ARG
     integer,                  intent(out), optional :: vasLocalDeCount
     integer, target,          intent(out), optional :: vasLocalDeToDeMap(:)
     integer, target, intent(out), optional :: vasLocalDeList(:) !DEPRECATED ARG
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>5.2.0rp1</STRONG></DT>
<DD>Added arguments <TT>localDeToDeMap</TT> and <TT>vasLocalDeToDeMap</TT>.
                   Started to deprecate arguments <TT>localDeList</TT> and 
                   <TT>vasLocalDeList</TT>. 
                   The new argument names correctly use the <TT>Map</TT> suffix and
                   better describe the returned information.
                   This was pointed out by user request.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Access to DELayout information.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Queried <TT>ESMF_DELayout</TT> object.
     
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on which <TT>delayout</TT> is defined.
     
</DD>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>The total number of DEs in the DELayout.
     
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>List of PETs against which the DEs are mapped. The <TT>petMap</TT> 
       argument must at least be of size <TT>deCount</TT>.
     
</DD>
<DT><STRONG>[vasMap]</STRONG></DT>
<DD>List of VASs against which the DEs are mapped. The <TT>vasMap</TT>
       argument must at least be of size <TT>deCount</TT>.
     
</DD>
<DT><STRONG>[oneToOneFlag]</STRONG></DT>
<DD>A value of <TT>.TRUE.</TT> indicates that <TT>delayout</TT> maps each DE to a
       single PET, and each PET maps to a single DE. All other layouts return
       a value of <TT>.FALSE.</TT>.
     
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>The type of DE pinning. See section <A HREF="#const:pin_flag">50.2.1</A> for a list
       of valid pinning options.
     
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>The number of DEs in the DELayout associated with the local PET.
     
</DD>
<DT><STRONG>[localDeToDeMap]</STRONG></DT>
<DD>Mapping between localDe indices and the (global) DEs associated with
       the local PET. The localDe index variables are discussed in sections
       <A HREF="#DELayout_general_mapping">50.3.7</A> and <A HREF="node5.html#Array_native_language_localde">28.2.5</A>.
       The provided actual argument must be of size <TT>localDeCount</TT>.
     
</DD>
<DT><STRONG>[localDeList]</STRONG></DT>
<DD><B>DEPRECATED ARGUMENT!</B> Please use the argument <TT>localDeToDeMap</TT> instead.
     
</DD>
<DT><STRONG>[vasLocalDeCount]</STRONG></DT>
<DD>The number of DEs in the DELayout associated with the local VAS.
     
</DD>
<DT><STRONG>[vasLocalDeToDeMap]</STRONG></DT>
<DD>Mapping between localDe indices and the (global) DEs associated with
       the local VAS. The localDe index variables are discussed in sections
       <A HREF="#DELayout_general_mapping">50.3.7</A> and <A HREF="node5.html#Array_native_language_localde">28.2.5</A>.
       The provided actual argument must be of size <TT>localDeCount</TT>.
     
</DD>
<DT><STRONG>[vasLocalDeList]</STRONG></DT>
<DD><B>DEPRECATED ARGUMENT!</B> Please use the argument <TT>vasLocalDeToDeMap</TT> instead.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060126800000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_DELayoutIsCreated - Check whether a DELayout object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_DELayoutIsCreated(delayout, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_DELayoutIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout), intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>delayout</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060126900000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_DELayoutPrint - Print DELayout information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DELayoutPrint(delayout, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Prints internal information about the specified <TT>ESMF_DELayout</TT> 
       object to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601261000000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_DELayoutServiceComplete - Close service window</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_DELayoutServiceComplete(delayout, de, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
     integer,              intent(in)            :: de
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
The PET who's service offer was accepted for <TT>de</TT> must use 
     <TT>ESMF_DELayoutServiceComplete</TT> to close the service window.

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>de</STRONG></DT>
<DD>DE for which to close service window.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601261100000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_DELayoutServiceOffer - Offer service for a DE in DELayout</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive function ESMF_DELayoutServiceOffer(delayout, de, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_ServiceReply_Flag) :: ESMF_DELayoutServiceOffer
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
     integer,              intent(in)            :: de
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Offer service for a DE in the <TT>ESMF_DELayout</TT> object. This call
       together with <TT>ESMF_DELayoutServiceComplete()</TT> provides the
       synchronization primitives between the PETs of an ESMF multi-threaded VM
       necessary for dynamic load balancing via a work queue approach.

<P>
The calling PET will either receive <TT>ESMF_SERVICEREPLY_ACCEPT</TT> if
       the service offer has been accepted by DELayout or 
       <TT>ESMF_SERVICEREPLY_DENY</TT> if the service offer was denied. The 
       service offer paradigm is different from a simple mutex approach in that
       the DELayout keeps track of the number of service offers issued for each
       DE by each PET and accepts only one PET's offer for each offer increment.
       This requires that all PETs use <TT>ESMF_DELayoutServiceOffer()</TT> in 
       unison. See section <A HREF="#const:servicereply_flag">50.2.2</A> for the potential return
       values.

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>de</STRONG></DT>
<DD>DE for which service is offered by the calling PET.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601261200000000000000">
<SPAN CLASS="arabic">50</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_DELayoutValidate - Validate DELayout internals</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_DELayoutValidate(delayout, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>delayout</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<H1><A NAME="SECTION060130000000000000000">
<SPAN CLASS="arabic">51</SPAN> VM Class</A>
</H1>

<H2><A NAME="SECTION060131000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
The ESMF VM (Virtual Machine) class is a generic representation of hardware and system software resources. There is exactly one VM object per ESMF Component, providing the execution environment for the Component code. The VM class handles all resource management tasks for the Component class and provides a description of the underlying configuration of the compute resources used by a Component.

<P>
In addition to resource description and management, the VM class offers the lowest level of ESMF communication methods. The VM communication calls are very similar to MPI. Data references in VM communication calls must be provided as raw, language-specific, one-dimensional, contiguous data arrays. The similarity between VM and MPI communication calls is striking and there are many equivalent point-to-point and collective communication calls. However, unlike MPI, the VM communication calls support communication between threaded PETs in a completely transparent fashion.

<P>
Many ESMF applications do not interact with the VM class directly very much. The  resource management aspect is wrapped completely transparent into the ESMF Component concept. Often the only reason that user code queries a Component
object for the associated VM object is to inquire about resource information, such as the <TT>localPet</TT> or the <TT>petCount</TT>. Further, for most applications the use of higher level communication APIs, such as provided by Array and Field, are much more convenient than using the low level VM communication calls.

<P>
The basic elements of a VM are called PETs, which stands for Persistent Execution Threads. These are equivalent to OS threads with a lifetime of at least that of the associated component. All VM functionality is expressed in terms of PETs. In the simplest, and most common case, a PET is equivalent to an MPI process. However, ESMF also supports multi-threading, where multiple PETs run as Pthreads inside the same virtual address space (VAS).

<P>
The resource management functions of the VM class become visible when a component, or the driver code, creates sub-components. Section <A HREF="node4.html#sec:AppDriverSetVM">16.4.8</A> discusses this aspect from the Superstructure 
perspective and provides links to the relevant Component examples in the documentation.

<P>
There are two parts to resource management, the parent and the child. When the parent component creates a child component, the parent VM object provides the resources on which the child is created with <TT>ESMF_GridCompCreate()</TT> or <TT>ESMF_CplCompCreate()</TT>. The optional <TT>petList</TT> argument to these calls limits the resources that the parent gives to a specific child. The child component, may specify - during its optional 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> method - how it wants to arrange the inherited resources in its own VM. After this, all standard ESMF methods of the Component, including <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, will execute in the child VM. Notice that the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> routine, although part of the child Component, must execute <EM>before</EM> the child VM has been started up. It runs in the parent VM context. The child VM is created and started up just before the user-written set services routine, specified as an argument to <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, is entered.

<H2><A NAME="SECTION060132000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">2</SPAN> Constants</A>
</H2>

<P>

<H3><A NAME="SECTION060132100000000000000"></A>
<A NAME="const:vmepoch_flag"></A>
<BR>
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_VMEPOCH
</H3>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>
Specifies the kind of VM Epoch being entered.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_VMEpoch_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_VMEPOCH_NONE</STRONG></DT>
<DD>An epoch wihout special behavior.
  
</DD>
<DT><STRONG>ESMF_VMEPOCH_BUFFER</STRONG></DT>
<DD>This option must only be used for parts of the code with distinct sending
    and receiving PETs, i.e. where no PETs are both sender and receiver.
    All non-blocking messages are being buffered. A single message is sent
    between unique pairs of src-dst PETs. This can significantly improve
    performance for cases with a large imbalance in the number of sending
    versus receiving PETs. The extra buffering also improves the overall
    asynchronous behavior between the sending and receiving side.
</DD>
</DL>

<H2><A NAME="SECTION060133000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN> Use and Examples</A>
</H2>

<P>
The concept of the ESMF Virtual Machine (VM) is so fundamental to the framework that every ESMF application uses it. However, for many user applications the VM class is transparently hidden behind the ESMF Component concept and higher data classes (e.g. Array, Field). The interaction between user code and VM is often only indirect. The following examples provide an overview of where the VM class can come into play in user code.

<P>

<P>

<P>

<H3><A NAME="SECTION060133100000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Global VM</A>
</H3>

<P>
This complete example program demonstrates the simplest ESMF application, 
   consisting of only a main program without any Components. The global
   VM, which is automatically created during the <TT>ESMF_Initialize()</TT> call,
   is obtained using two different methods. First the global VM will be returned
   by <TT>ESMF_Initialize()</TT> if the optional <TT>vm</TT> argument is specified.
   The example uses the VM object obtained this way to call the VM print method.
   Second, the global VM can be obtained anywhere in the user application using
   the <TT>ESMF_VMGetGlobal()</TT> call. The identical VM is returned and several
   VM query methods are called to inquire about the associated resources.
  
<P>
<PRE>
program ESMF_VMDefaultBasicsEx
#include "ESMF.h"

  use ESMF
  use ESMF_TestMod
  
  implicit none
  
  ! local variables
  integer:: rc
  type(ESMF_VM):: vm
  integer:: localPet, petCount, peCount, ssiId, vas
</PRE>

<P>
<PRE>
  call ESMF_Initialize(vm=vm, defaultlogfilename="VMDefaultBasicsEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  ! Providing the optional vm argument to ESMF_Initialize() is one way of
  ! obtaining the global VM.
</PRE>

<P>
<PRE>
  call ESMF_VMPrint(vm, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_VMGetGlobal(vm=vm, rc=rc)
  ! Calling ESMF_VMGetGlobal() anywhere in the user application is the other
  ! way to obtain the global VM object.
</PRE>

<P>
<PRE>
  call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, peCount=peCount, &amp;
    rc=rc)
  ! The VM object contains information about the associated resources. If the
  ! user code requires this information it must query the VM object.
</PRE>

<P>
<PRE>
  print *, "This PET is localPet: ", localPet
  print *, "of a total of ",petCount," PETs in this VM."
  print *, "There are ", peCount," PEs referenced by this VM"

  call ESMF_VMGet(vm, localPet, peCount=peCount, ssiId=ssiId, vas=vas, rc=rc)
</PRE>

<P>
<PRE>
  print *, "This PET is executing in virtual address space (VAS) ", vas
  print *, "located on single system image (SSI) ", ssiId
  print *, "and is associated with ", peCount, " PEs."
</PRE>

<P>
<PRE>
end program
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060133200000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> VM and Components</A>
</H3>

<P>
The following example shows the role that the VM plays in connection with ESMF 
   Components. A single Component is created in the main program. Through the
   optional <TT>petList</TT> argument the driver code specifies that only resources
   associated with PET 0 are given to the <TT>gcomp</TT> object. 

<P>
When the Component code is invoked through the standard ESMF Component methods
   Initialize, Run, or Finalize the Component's VM is automatically entered.
   Inside of the user-written Component code the Component VM can be obtained
   by querying the Component object. The VM object will indicate that only a
   single PET is executing the Component code.
  
<P>
<PRE>
module ESMF_VMComponentEx_gcomp_mod
</PRE>

<P>
<PRE>
  recursive subroutine mygcomp_init(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc

    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

  
  recursive subroutine mygcomp_run(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc
    
    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

  recursive subroutine mygcomp_final(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc
    
    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

end module
</PRE>

<P>
<PRE>
program ESMF_VMComponentEx
#include "ESMF.h"
  use ESMF
  use ESMF_TestMod
  use ESMF_VMComponentEx_gcomp_mod
  implicit none
  
  ! local variables
</PRE>

<P>
<PRE>
  gcomp = ESMF_GridCompCreate(petList=(/0/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompSetServices(gcomp, userRoutine=mygcomp_register, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompInitialize(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompRun(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompFinalize(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompDestroy(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060133300000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Accessing the MPI Communicator from an VM object</A>
</H3>

<P>
Sometimes user code requires access to the MPI communicator, e.g. to support
   legacy code that contains explict MPI communication calls. The correct way of
   wrapping such code into ESMF is to obtain the MPI intra-communicator out of
   the VM object. In order not to interfere with ESMF communications it is
   advisable to duplicate the communicator before using it in user-level MPI
   calls. In this example the duplicated communicator is used for a user
   controlled <TT>MPI_Barrier()</TT>.
  
<P>
<PRE>
  integer:: mpic
</PRE>

<P>
<PRE>
  integer:: mpic2
</PRE>

<P>
<PRE>
  call ESMF_VMGet(vm, mpiCommunicator=mpic, rc=rc)
  ! The returned MPI communicator spans the same MPI processes that the VM
  ! is defined on.
</PRE>

<P>
<PRE>
  call MPI_Comm_dup(mpic, mpic2, ierr)
  ! Duplicate the MPI communicator not to interfere with ESMF communications.
  ! The duplicate MPI communicator can be used in any MPI call in the user
  ! code. Here the MPI_Barrier() routine is called.
  call MPI_Barrier(mpic2, ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060133400000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">4</SPAN> Using the MPI Communicator with the Fortran 2008 MPI binding</A>
</H3>

<P>
The Fortran 2008 MPI language binding defines <TT>type MPI_Comm</TT> to
   represent the MPI communicator. The following example demonstrates
   how the MPI communicator queried from the VM object can be used with the
   Fortran 2008 MPI binding.
   
<P>
<PRE>
  use mpi_f08
</PRE>

<P>
<PRE>
  integer       :: int_mpic
  type(MPI_Comm):: mpic
</PRE>

<P>
<PRE>
  type(MPI_Comm):: mpic2
</PRE>

<P>
<PRE>
  call ESMF_VMGet(vm, mpiCommunicator=int_mpic, rc=rc)
  ! The returned MPI communicator spans the same MPI processes that the VM
  ! is defined on.
</PRE>

<P>
<PRE>
  mpic%mpi_val = int_mpic ! integer version of communicator -&gt; type(MPI_Comm)

  ! Now mpic can be used in the Fortran 2008 MPI binding interfaces

  call MPI_Comm_dup(mpic, mpic2, ierr)
  ! Duplicate the MPI communicator not to interfere with ESMF communications.
  ! The duplicate MPI communicator can be used in any MPI call in the user
  ! code. Here the MPI_Barrier() routine is called.
  call MPI_Barrier(mpic2, ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060133500000000000000"></A>
   <A NAME="vm_inside_user_mpi"></A>
<BR>
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Nesting ESMF inside a user MPI application
</H3>

<P>
It is possible to nest an ESMF application inside a user application that 
   explicitly calls <TT>MPI_Init()</TT> and <TT>MPI_Finalize()</TT>. The
   <TT>ESMF_Initialize()</TT> call automatically checks whether MPI has already
   been initialized, and if so does not call <TT>MPI_Init()</TT> internally. 
   On the finalize side, <TT>ESMF_Finalize()</TT> can be instructed to <EM>not</EM>
   call <TT>MPI_Finalize()</TT>, making it the responsibility of the outer code
   to finalize MPI.
   
  
<P>
<PRE>
  ! For cases where ESMF resource management is desired (e.g. for threading),
  ! ESMF_InitializePreMPI() must be called before MPI_Init().
  call ESMF_InitializePreMPI(rc=rc)
</PRE>

<P>
<PRE>
  ! User code initializes MPI.
  call MPI_Init(ierr)
</PRE>

<P>
<PRE>
  ! ESMF_Initialize() does not call MPI_Init() if it finds MPI initialized.
  call ESMF_Initialize(defaultlogfilename="VMUserMpiEx.Log", &amp;
    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
  ! Use ESMF here...
</PRE>

<P>
<PRE>
  ! Calling ESMF_Finalize() with endflag=ESMF_END_KEEPMPI instructs ESMF
  ! to keep MPI active.
  call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
</PRE>

<P>
<PRE>
  ! It is the responsibility of the outer user code to finalize MPI.
  call MPI_Finalize(ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060133600000000000000"></A>
   <A NAME="vm_nesting_esmf"></A>
<BR>
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">6</SPAN> Nesting ESMF inside a user MPI application on a subset of MPI ranks
</H3>

<P>
The previous example demonstrated that it is possible to nest an ESMF 
   application, i.e. <TT>ESMF_Initialize()</TT>...<TT>ESMF_Finalize()</TT> inside
   <TT>MPI_Init()</TT>...<TT>MPI_Finalize()</TT>. It is not necessary that all
   MPI ranks enter the ESMF application. The following example shows how the
   user code can pass an MPI communicator to <TT>ESMF_Initialize()</TT>, and
   enter the ESMF application on a subset of MPI ranks.
   
  
<P>
<PRE>
  ! User code initializes MPI.
  call MPI_Init(ierr)
</PRE>

<P>
<PRE>
  ! User code determines the local rank.
  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
</PRE>

<P>
<PRE>
  ! User code prepares MPI communicator "esmfComm", that allows rank 0 and 1
  ! to be grouped together.
  if (rank &lt; 2) then
    ! first communicator split with color=0
    call MPI_Comm_split(MPI_COMM_WORLD, 0, 0, esmfComm, ierr)
  else
    ! second communicator split with color=1
    call MPI_Comm_split(MPI_COMM_WORLD, 1, 0, esmfComm, ierr)
  endif
</PRE>

<P>
<PRE>
  if (rank &lt; 2) then
    ! Only call ESMF_Initialize() on rank 0 and 1, passing the prepared MPI
    ! communicator that spans these ranks.
    call ESMF_Initialize(mpiCommunicator=esmfComm, &amp;
      defaultlogfilename="VMUserMpiCommEx.Log", &amp;
      logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
    ! Use ESMF here...
</PRE>

<P>
<PRE>
    ! Calling ESMF_Finalize() with endflag=ESMF_END_KEEPMPI instructs ESMF
    ! to keep MPI active.
    call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
</PRE>

<P>
<PRE>
  else
    ! Ranks 2 and above do non-ESMF work...
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
<PRE>
  ! Free the MPI communicator before finalizing MPI.
  call MPI_Comm_free(esmfComm, ierr)
  
  ! It is the responsibility of the outer user code to finalize MPI.
  call MPI_Finalize(ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060133700000000000000"></A>
   <A NAME="vm_multi_instance_esmf"></A>
<BR>
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">7</SPAN> Multiple concurrent instances of ESMF under separate MPI communicators
</H3>

<P>
Multiple instances of ESMF can run concurrently under the same user main 
   program on separate MPI communicators. The user program first splits
   <TT>MPI_COMM_WORLD</TT> into separate MPI communicators. Each communicator is
   then used to run a separate ESMF instance by passing it into 
   <TT>ESMF_Initialize()</TT> on the appropriate MPI ranks.

<P>
Care must be taken to set the <TT>defaultlogfilename</TT> to be unique on each
   ESMF instances. This prevents concurrent ESMF instances from writing to the
   same log file. 
   Further, each ESMF instances must call 
   <TT>ESMF_Finalize()</TT> with the <TT>endflag=ESMF_END_KEEPMPI</TT> option in
   order to hand MPI control back to the user program. The outer user program is
   ultimately responsible for destroying the MPI communicators and to cleanly
   shut down MPI. 
   
  
<P>
<PRE>
  ! User code initializes MPI.
  call MPI_Init(ierr)
</PRE>

<P>
<PRE>
  ! User code determines the local rank and overall size of MPI_COMM_WORLD
  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
  call MPI_Comm_size(MPI_COMM_WORLD, size, ierr)
</PRE>

<P>
<PRE>
  ! User code prepares different MPI communicators.
  ! Here a single MPI_Comm_split() call is used to split MPI_COMM_WORLD
  ! into two non-overlapping communicators:
  ! One communicator for ranks 0 and 1, and the other for ranks 2 and above.
  if (rank &lt; 2) then
    ! first communicator split with color=0
    call MPI_Comm_split(MPI_COMM_WORLD, 0, 0, esmfComm, ierr)
  else
    ! second communicator split with color=1
    call MPI_Comm_split(MPI_COMM_WORLD, 1, 0, esmfComm, ierr)
  endif
</PRE>

<P>
<PRE>
  if (rank &lt; 2) then
    ! Ranks 0 and 1 enter ESMF_Initialize() with the prepared communicator.
    ! Care is taken to set a unique log file name.
    call ESMF_Initialize(mpiCommunicator=esmfComm, &amp;
      defaultlogfilename="VMUserMpiCommMultiEx1.Log", &amp;
      logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
    ! Use ESMF here...
</PRE>

<P>
<PRE>
    ! Finalize ESMF without finalizing MPI. The user application will call
    ! MPI_Finalize() on all ranks.
    call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
</PRE>

<P>
<PRE>
  else
    ! Ranks 2 and above enter ESMF_Initialize() with the prepared communicator.
    ! Care is taken to set a unique log file name.
    call ESMF_Initialize(mpiCommunicator=esmfComm, &amp;
      defaultlogfilename="VMUserMpiCommMultiEx2.Log", &amp;
      logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
    ! Use ESMF here...
</PRE>

<P>
<PRE>
    ! Finalize ESMF without finalizing MPI. The user application will call
    ! MPI_Finalize() on all ranks.
    call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
<PRE>
  ! Free the MPI communicator(s) before finalizing MPI.
  call MPI_Comm_free(esmfComm, ierr)
  
  ! It is the responsibility of the outer user code to finalize MPI.
  call MPI_Finalize(ierr)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060133800000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">8</SPAN> Communication - Send and Recv</A>
</H3>

<P>
The VM layer provides MPI-like point-to-point communication. Use 
   <TT>ESMF_VMSend()</TT> and <TT>ESMF_VMRecv()</TT> to pass data between two PETs.
   The following code sends data from PET 'src' and receives it on PET 'dst'.
   Both PETs must be part of the same VM.

<P>
Set up the <TT>localData</TT> array.
<P>
<PRE>
  count = 10
  allocate(localData(count))
  do i=1, count
    localData(i) = localPet*100 + i
  enddo
</PRE>

<P>
Carry out the data transfer between <TT>src</TT> PET and <TT>dst</TT> PET.
<P>
<PRE>
  if (localPet==src) then
    call ESMF_VMSend(vm, sendData=localData, count=count, dstPet=dst, rc=rc)
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMRecv(vm, recvData=localData, count=count, srcPet=src, rc=rc)
  endif
</PRE>

<P>
Finally, on <TT>dst</TT> PET, test the received data for correctness.
<P>
<PRE>
  if (localPet==dst) then
    do i=1, count
      if (localData(i) /= src*100 + i) then
        finalrc = ESMF_RC_VAL_WRONG
      endif
    enddo 
  endif
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION060133900000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">9</SPAN> Communication - Scatter and Gather</A>
</H3>

<P>
The VM layer provides MPI-like collective communication. <TT>ESMF_VMScatter()</TT>
   scatters data located on <TT>root</TT> PET across all the PETs of the VM. 
   <TT>ESMF_VMGather()</TT> provides the opposite operation, gathering data from
   all the PETs of the VM onto <TT>root</TT> PET.
  
<P>
<PRE>
  integer, allocatable:: array1(:), array2(:)
</PRE>

<P>
<PRE>
  ! allocate data arrays
  nsize = 2
  nlen = nsize * petCount
  allocate(array1(nlen))
  allocate(array2(nsize))

  ! prepare data array1
  do i=1, nlen
    array1(i) = localPet * 100 + i
  enddo
</PRE>

<P>
<PRE>
  call ESMF_VMScatter(vm, sendData=array1, recvData=array2, count=nsize, &amp;
    rootPet=scatterRoot, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_VMGather(vm, sendData=array2, recvData=array1, count=nsize, &amp;
    rootPet=gatherRoot, rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION0601331000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">10</SPAN> Communication - AllReduce and AllFullReduce</A>
</H3>

<P>
Use <TT>ESMF_VMAllReduce()</TT> to reduce data distributed across the PETs of a 
   VM into a result vector, returned on all the PETs. Further, use
   <TT>ESMF_VMAllFullReduce()</TT> to reduce the data into a single scalar returned
   on all PETs.
  
<P>
<PRE>
  integer, allocatable:: array1(:), array2(:)
</PRE>

<P>
<PRE>
  ! allocate data arrays
  nsize = 2
  allocate(array1(nsize))
  allocate(array2(nsize))

  ! prepare data array1
  do i=1, nsize
    array1(i) = localPet * 100 + i
  enddo
</PRE>

<P>
<PRE>
  call ESMF_VMAllReduce(vm, sendData=array1, recvData=array2, count=nsize, &amp;
    reduceflag=ESMF_REDUCE_SUM, rc=rc)
  ! Reduce distributed sendData, element by element into recvData and
  ! return it on all the PETs.
</PRE>

<P>
<PRE>
  call ESMF_VMAllFullReduce(vm, sendData=array1, recvData=result, &amp;
    count=nsize, reduceflag=ESMF_REDUCE_SUM, rc=rc)
  ! Fully reduce the distributed sendData into a single scalar and
  ! return it in recvData on all PETs.
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION0601331100000000000000"></A>
   <A NAME="VM:NBVMEpoch"></A>
<BR>
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">11</SPAN> Communication - Non-blocking option and VMEpochs
</H3>
   The VM communication methods offer the option to execute in non-blocking
   mode. In this mode, both sending and receving calls return immediatly on each
   local PET. A separate synchronization call is needed to assure completion of
   the data transfer.

<P>
The separation of initiation and completion of the data transfer provides
   the opportunity for the underlying communication system to progress 
   concurrently with other operations on the same PET. This can be leveraged to
   have profound impact on the performance of an algorithm that requires both
   computation and communication.

<P>
Another critical application of the non-blocking communication mode is the
   prevention of deadlocks. In the default blocking mode, a receiving method
   will not return until the data transfer has completed. Sending methods may
   also not return, especially if the message being sent is above the 
   implementation dependent internal buffer size. This behavior makes it often
   hard, if not impossible, to write safe algorithms that guarantee to not
   deadlock when communicating between a group of PETs.
   Using the communication calls in non-blocking mode simplifies this problem
   immensely.

<P>
The following code shows how <TT>ESMF_VMSend()</TT> and <TT>ESMF_VMRecv()</TT>
   are used in non-blocking mode by passing in the <TT>ESMF_SYNC_NONBLOCKING</TT>
   argument.

<P>
Set up the <TT>localData</TT> array.
<P>
<PRE>
  do i=1, count
    localData(i) = localPet*100 + i
  enddo
</PRE>

<P>
Initiate the data transfer between <TT>src</TT> PET and <TT>dst</TT> PET.
<P>
<PRE>
  if (localPet==src) then
    call ESMF_VMSend(vm, sendData=localData, count=count, dstPet=dst, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, rc=rc)
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMRecv(vm, recvData=localData, count=count, srcPet=src, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, rc=rc)
  endif
</PRE>

<P>
There is no garantee at this point that the data transfer has actually 
   started, let along completed. For this reason it is unsafe to overwrite
   the data in the <TT>localData</TT> array on <TT>src</TT> PET, or to access
   the <TT>localData</TT> array on <TT>dst</TT> PET. However both PETs are free
   to engage in other work while the data transfer may proceed concurrently.
<P>
<PRE>
  ! local computational work here, or other communications
</PRE>

<P>
Wait for the completion of all outstanding non-blocking communication calls
   by issuing the <TT>ESMF_VMCommWaitAll()</TT> call.
<P>
<PRE>
  call ESMF_VMCommWaitAll(vm, rc=rc)
</PRE>

<P>
Finally, on <TT>dst</TT> PET, test the received data for correctness.
<P>
<PRE>
  if (localPet==dst) then
    do i=1, count
      if (localData(i) /= src*100 + i) then
        finalrc = ESMF_RC_VAL_WRONG
      endif
    enddo 
  endif
</PRE>

<P>
Sometimes it is necessary to wait for individual outstanding communications
   specifically. This can be accomplished by using <TT>ESMF_CommHandle</TT>
   objects. To demonstrate this, first re-initialize the <TT>localData</TT> array.
<P>
<PRE>
  do i=1, count
    localData(i) = localPet*100 + i
    localData2(i) = localPet*1000 + i
  enddo
</PRE>

<P>
Initiate the data transfer between <TT>src</TT> PET and <TT>dst</TT> PET, but this
   time also pass the <TT>commhandle</TT> variable of type <TT>ESMF_CommHandle</TT>.
   Here send two message between <TT>src</TT> and <TT>dst</TT> in order to have
   different outstanding messages to wait for.
<P>
<PRE>
  if (localPet==src) then
    call ESMF_VMSend(vm, sendData=localData, count=count, dstPet=dst, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, commhandle=commhandle(1), rc=rc)
    call ESMF_VMSend(vm, sendData=localData2, count=count, dstPet=dst, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, commhandle=commhandle(2), rc=rc)
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMRecv(vm, recvData=localData, count=count, srcPet=src, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, commhandle=commhandle(1), rc=rc)
    call ESMF_VMRecv(vm, recvData=localData2, count=count, srcPet=src, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, commhandle=commhandle(2), rc=rc)
  endif
</PRE>

<P>
Now it is possible to specifically wait for the first data transfer, e.g. on
   the <TT>dst</TT> PET.
<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMCommWait(vm, commhandle=commhandle(1), rc=rc)
  endif
</PRE>

<P>
At this point there are still 2 outstanding communications on the <TT>src</TT>
   PET, and one outstanding communication on the <TT>dst</TT> PET. However, having
   returned from the specific <TT>ESMF_VMCommWait()</TT> call guarantees that the
   first communication on the <TT>dst</TT> PET has completed, i.e. the data has 
   been received from the <TT>src</TT> PET, and can now be accessed in the
   <TT>localData</TT> array.
<P>
<PRE>
  if (localPet==dst) then
    do i=1, count
      if (localData(i) /= src*100 + i) then
        finalrc = ESMF_RC_VAL_WRONG
      endif
    enddo
  endif
</PRE>

<P>
Before accessing data from the second transfer, it is necessary to wait on
   the associated commhandle for completion.
<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMCommWait(vm, commhandle=commhandle(2), rc=rc)
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    do i=1, count
      if (localData2(i) /= src*1000 + i) then
        finalrc = ESMF_RC_VAL_WRONG
      endif
    enddo
  endif
</PRE>

<P>
Finally the <TT>commhandle</TT> elements on the <TT>src</TT> side need to be
   cleared by waiting for them. This could be done using specific 
   <TT>ESMF_VMCommWait()</TT> calls, similar to the <TT>dst</TT> side, or simply 
   by waiting for all/any outstanding communications using
   <TT>ESMF_VMCommWaitAll()</TT> as in the previous example. This call can be
   issued without <TT>commhandle</TT> on all of the PETs.
<P>
<PRE>
  call ESMF_VMCommWaitAll(vm, rc=rc)
</PRE>

<P>
For cases where multiple messages are being sent between the same
   <TT>src</TT>-<TT>dst</TT> pairs using non-blocking communications, performance
   can often be improved by aggregating individual messages. An extra buffer
   is needed to hold the collected messages. The result is a single data
   transfer for each PET pair. In many cases this can significantly reduce the
   time spent in communications. The ESMF VM class provides access to such a
   buffering technique through the <TT>ESMF_VMEpoch</TT> API.

<P>
The <TT>ESMF_VMEpoch</TT> API consists of two interfaces:
   <TT>ESMF_VMEpochEnter()</TT> and <TT>ESMF_VMEpochExit()</TT>. When entering an
   epoch, the user specifies the type of epoch that is to be entered. Currently
   only <TT>ESMF_VMEPOCH_BUFFER</TT> is available. Inside this epoch,
   non-blocking communication calls are aggregated and data transfers on the 
   <TT>src</TT> side are not issued until the epoch is exited. On the <TT>dst</TT> side
   a single data transfer is received, and then divided over the actual
   non-blocking receive calls.

<P>
The following code repeates the previous example with two messages between
   <TT>src</TT> and <TT>dst</TT>. It is important that every PET only must act either
   as sender or receiver. A sending PET can send to many different PETs, and a 
   receiving PET can receive from many PETs, but no PET must send <EM>and</EM>
   receive within the same epoch!

<P>
First re-initialize the <TT>localData</TT> array.
<P>
<PRE>
  do i=1, count
    localData(i) = localPet*100 + i
    localData2(i) = localPet*1000 + i
  enddo
</PRE>

<P>
Enter the <TT>ESMF_VMEPOCH_BUFFER</TT>.
<P>
<PRE>
  call ESMF_VMEpochEnter(epoch=ESMF_VMEPOCH_BUFFER, rc=rc)
</PRE>

<P>
Now issue non-blocking send and receive calls as usual.
<P>
<PRE>
  if (localPet==src) then
    call ESMF_VMSend(vm, sendData=localData, count=count, dstPet=dst, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, commhandle=commhandle(1), rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_VMSend(vm, sendData=localData2, count=count, dstPet=dst, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, commhandle=commhandle(2), rc=rc)
</PRE>

<P>
<PRE>
  endif
  if (localPet==dst) then
    call ESMF_VMRecv(vm, recvData=localData, count=count, srcPet=src, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, commhandle=commhandle(1), rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_VMRecv(vm, recvData=localData2, count=count, srcPet=src, &amp;
      syncflag=ESMF_SYNC_NONBLOCKING, commhandle=commhandle(2), rc=rc)
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
No data transfer has been initiated at this point due to the fact that this
   code is inside the <TT>ESMF_VMEPOCH_BUFFER</TT>. On the <TT>dst</TT> side the
   same methods are used to wait for the data transfer. However, it is not until
   the exit of the epoch on the <TT>src</TT> side that data is transferred to the
   <TT>dst</TT> side.
<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMCommWait(vm, commhandle=commhandle(1), rc=rc)
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    do i=1, count
      if (localData(i) /= src*100 + i) then
        finalrc = ESMF_RC_VAL_WRONG
      endif
    enddo 
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMCommWait(vm, commhandle=commhandle(2), rc=rc)
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    do i=1, count
      if (localData2(i) /= src*1000 + i) then
        finalrc = ESMF_RC_VAL_WRONG
      endif
    enddo
  endif
</PRE>

<P>
Now exit the epoch, to trigger the data transfer on the <TT>src</TT> side.
<P>
<PRE>
  call ESMF_VMEpochExit(rc=rc)
</PRE>

<P>
Finally clear the outstanding communication handles on the <TT>src</TT> side.
   This needs to happen first inside the <EM>next</EM> <TT>ESMF_VMEPOCH_BUFFER</TT>.
   As before, waits could be issued either for the specific <TT>commhandle</TT>
   elements not yet explicitly cleared, or a general call to
   <TT>ESMF_VMCommWaitAll()</TT> can be used for simplicity.
<P>
<PRE>
  call ESMF_VMEpochEnter(epoch=ESMF_VMEPOCH_BUFFER, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_VMCommWaitAll(vm, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_VMEpochExit(rc=rc)
</PRE>

<P>


<P>

<P>

<P>

<H3><A NAME="SECTION0601331200000000000000"></A>
   <A NAME="vm_higherrank"></A>
<BR>
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">12</SPAN> Using VM communication methods with data of rank greater than one
</H3>

<P>
In the current implementation of the VM communication methods all the data
   array arguments are declared as <EM>assumed shape</EM> dummy arrays of rank one.
   The assumed shape flavor was chosen in order to minimize the chance of 
   copy in/out problems, associated with the other options for declaring the 
   dummy data arguments.
   However, currently the interfaces are not overloaded for higher ranks. This
   restriction requires that users that need to communicate data arrays with
   rank greater than one, must only pass the first dimension of the data array
   into the VM communication calls. Specifying the full size of the data arrays
   (considering <EM>all</EM> dimensions) ensure that the complete data is
   transferred in or out of the contiguous array memory.
<P>
<PRE>
  integer, allocatable:: sendData(:,:)
  integer, allocatable:: recvData(:,:,:,:)
</PRE>

<P>
<PRE>
  count1 = 5
  count2 = 8
  allocate(sendData(count1,count2)) ! 5 x 8 = 40 elements
  do j=1, count2
    do i=1, count1
      sendData(i,j) = localPet*100 + i + (j-1)*count1
    enddo
  enddo
  
  count1 = 2
  count2 = 5
  count3 = 1
  count4 = 4
  allocate(recvData(count1,count2,count3,count4)) ! 2 x 5 x 1 x 4 = 40 elements
  do l=1, count4
    do k=1, count3
      do j=1, count2
        do i=1, count1
          recvData(i,j,k,l) = 0
        enddo
      enddo
    enddo
  enddo
</PRE>

<P>
<PRE>
  if (localPet==src) then
    call ESMF_VMSend(vm, &amp;
      sendData=sendData(:,1), &amp; ! 1st dimension as contiguous array section
      count=count1*count2, &amp;    ! total count of elements
      dstPet=dst, rc=rc)
  endif
</PRE>

<P>
<PRE>
  if (localPet==dst) then
    call ESMF_VMRecv(vm, &amp;
      recvData=recvData(:,1,1,1), &amp; ! 1st dimension as contiguous array section
      count=count1*count2*count3*count4, &amp;  ! total count of elements
      srcPet=src, rc=rc)
  endif
</PRE>

<P>


<H2><A NAME="SECTION060134000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">4</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Only array section syntax that leads to contiguous sub sections is supported</B>. The source and destination arguments in VM communication calls must reference contiguous data arrays. Fortran array sections are not guaranteed to be contiguous in all cases.

<P>
</LI>
<LI><B>Non-blocking <TT>Reduce()</TT> operations <EM>not</EM> implemented.</B> None of the reduce communication calls have an implementation for the non-blocking feature. This affects:

<UL>
<LI><TT>ESMF_VMAllFullReduce()</TT>,
</LI>
<LI><TT>ESMF_VMAllReduce()</TT>,
</LI>
<LI><TT>ESMF_VMReduce()</TT>.
</LI>
</UL>

<P>
</LI>
<LI><B>Limitations when using <TT>mpiuni</TT> mode.</B> In <TT>mpiuni</TT> mode non-blocking communications are limited to one outstanding message per source-destination PET pair. Furthermore, in <TT>mpiuni</TT> mode the message length must be smaller than the internal ESMF buffer size.

<P>
</LI>
<LI><B>Alternative communication paths not accessible.</B> All user accessible VM communication calls are currently implemented using MPI-1.2. VM's implementation of alternative communication techniques, such as shared memory between threaded PETs and POSIX IPC between PETs located on the same single system image, are currently inaccessible to the user. (One exception to this is the <TT>mpiuni</TT> case for which the VM automatically utilizes a shared memory path.)

<P>
</LI>
<LI><B>Data arrays in VM comm calls are <EM>assumed shape</EM> with rank=1.</B> Currently all dummy arrays in VM comm calls are defined as <EM>assumed shape</EM> arrays of rank=1. The motivation for this choice is that the use of assumed shape dummy arrays guards against the Fortran copy in/out problem. However it may not be as flexible as desired from the user perspective. Alternatively all dummy arrays could be defined as <EM>assumed size</EM> arrays, as it is done in most MPI implementations, allowing arrays of various rank to be passed into the comm methods. Arrays of higher rank can be passed into the current interfaces using Fortran array syntax. This approach is explained in section <A HREF="#vm_higherrank">51.3.12</A>.

<P>
</LI>
<LI><B>Limitations when using VMEpoch.</B> Using a blocking collective call (e.g. <TT>ESMF_VMBroadcast()</TT>, the <TT>MPI_Bcast()</TT> used by <TT>ESMF_InfoBroadcast()</TT>, etc.) within the region enclosed by <TT>ESMF_VMEpochEnter()</TT> and <TT>ESMF_VMEpochExit()</TT> will result in a deadlock. 

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION060135000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">5</SPAN> Design and Implementation Notes</A>
</H2>

<P>
The VM class provides an additional layer of abstraction on top of the POSIX machine model, making it suitable for HPC applications. There are four key aspects the VM class deals with.

<P>

<OL>
<LI>Encapsulation of hardware and operating system details within the concept of Persistent Execution Threads (PETs).

<P>
</LI>
<LI>Resource management in terms of PETs with a guard against over-subscription.

<P>
</LI>
<LI>Topological description of the underlying configuration of the compute resources in terms of PETs.

<P>
</LI>
<LI>Transparent communication API for point-to-point and collective PET-based primitives, hiding the many different communication channels and offering best possible performance.

<P>
</LI>
</OL>

<P>
<DIV ALIGN="CENTER">
<!-- MATH
 $\scalebox{0.6}{\includegraphics{VM_design}}$
 -->
<IMG
 WIDTH="723" HEIGHT="527" ALIGN="BOTTOM" BORDER="0"
 SRC="img204.png"
 ALT="\scalebox{0.6}{\includegraphics{VM_design}}">
</DIV>

<P>
<B>Definition of terms used in the diagram</B>

<P>

<UL>
<LI>PE: A processing element (PE) is an alias for the smallest physical processing unit available on a particular hardware platform. In the language of today's microprocessor architecture technology a PE is identical to a core, however, if future microprocessor designs change the smallest physical processing unit the mapping of the PE to actual hardware will change accordingly. Thus the PE layer separates the hardware specific part of the VM from the hardware-independent part. Each PE is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>Core: A Core is the smallest physical processing unit which typically comprises a register set, an integer arithmetic unit, a floating-point unit and various control units. Each Core is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>CPU: The central processing unit (CPU) houses single or multiple cores, providing them with the interface to system memory, interconnects and I/O. Typically the CPU provides some level of caching for the instruction and data streams in and out of the Cores. Cores in a multi-core CPU typically share some caches. Each CPU is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>SSI: A single system image (SSI) spans all the CPUs controlled by a single running instance of the operating system. SMP and NUMA are typical multi-CPU SSI architectures. Each SSI is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>TOE: A thread of execution (TOE) executes an instruction sequence. TOE's come in two flavors: PET and TET.

<P>
</LI>
<LI>PET: A persistent execution thread (PET) executes an instruction sequence on an associated set of data. The PET has a lifetime at least as long as the associated data set. In ESMF the PET is the central concept of abstraction provided by the VM class. The PETs of an VM object are labeled from 0 to N-1 where N is the total number of PETs in the VM object.

<P>
</LI>
<LI>TET: A transient execution thread (TET) executes an instruction sequence on an associated set of data. A TET's lifetime might be shorter than that of the associated data set.

<P>
</LI>
<LI>OS-Instance: The OS-Instance of a TOE describes how a particular TOE is instantiated on the OS level. Using POSIX terminology a TOE will run as a single thread within a single- or multi-threaded process.

<P>
</LI>
<LI>Pthreads: Communication via the POSIX Thread interface.

<P>
</LI>
<LI>MPI-1, MPI-2: Communication via MPI standards 1 and 2.

<P>
</LI>
<LI>armci: Communication via the aggregate remote memory copy interface.

<P>
</LI>
<LI>SHMEM: Communication via the SHMEM interface.

<P>
</LI>
<LI>OS-IPC: Communication via the operating system's inter process communication interface. Either POSIX IPC or System V IPC.

<P>
</LI>
<LI>InterCon-lib: Communication via the interconnect's library native interface. An example is the Elan library for Quadrics.

<P>
</LI>
</UL>

<P>
The POSIX machine abstraction, while a very powerful concept, needs augmentation when applied to HPC applications. Key elements of the POSIX abstraction are processes, which provide virtually unlimited resources (memory, I/O, sockets, ...) to possibly multiple threads of execution. Similarly POSIX threads create the illusion that there is virtually unlimited processing power available to each POSIX process. While the POSIX abstraction is very suitable for many multi-user/multi-tasking applications that need to share limited physical resources, it does not directly fit the HPC workload where over-subscription of resources is one of the most expensive modes of operation.

<P>
ESMF's virtual machine abstraction is based on the POSIX machine model but holds additional information about the available physical processing units in terms of Processing Elements (PEs). A PE is the smallest physical processing unit and encapsulates the hardware details (Cores, CPUs and SSIs).

<P>
There is exactly one physical machine layout for each application, and all VM instances have access to this information. The PE is the smallest processing unit which, in today's microprocessor technology, corresponds to a single Core. Cores are arranged in CPUs which in turn are arranged in SSIs. The setup of the physical machine layout is part of the ESMF initialization process.

<P>
On top of the PE concept the key abstraction provided by the VM is the PET. All user code is executed by PETs while OS and hardware details are hidden. The VM class contains a number of methods which allow the user to prescribe how the PETs of a desired virtual machine should be instantiated on the OS level and how they should map onto the hardware. This prescription is kept in a private virtual machine plan object which is created at the same time the associated component is being created. Each time component code is entered through one of the component's registered top-level methods (Initialize/Run/Finalize), the virtual machine plan along with a pointer to the respective user function is used to instantiate the user code on the PETs of the associated VM in form of single- or multi-threaded POSIX processes.

<P>
The process of starting, entering, exiting and shutting down a VM is very transparent, all spawning and joining of threads is handled by VM methods "behind the scenes". Furthermore, fundamental synchronization and communication primitives are provided on the PET level through a uniform API, hiding details related to the actual instantiation of the participating PETs.

<P>
Within a VM object each PE of the physical machine maps to 0 or 1 PETs. Allowing unassigned PEs provides a means to prevent over-subscription between multiple concurrently running virtual machines. Similarly a maximum of one PET per PE prevents over-subscription within a single VM instance. However, over-subscription is possible by subscribing PETs from different virtual machines to the same PE. This type of over-subscription can be desirable for PETs associated with I/O workloads expected to be used infrequently and to block often on I/O requests.

<P>
On the OS level each PET of a VM object is represented by a POSIX thread (Pthread) either belonging to a single- or multi-threaded process and maps to at least 1 PE of the physical machine, ensuring its execution. Mapping a single PET to multiple PEs provides resources for user-level multi-threading, in which case the user code inquires how many PEs are associated with its PET and if there are multiple PEs available the user code can spawn an equal number of threads (e.g. OpenMP) without risking over-subscription. Typically these user spawned threads are short-lived and used for fine-grained parallelization in form of TETs. All PEs mapped against a single PET must be part of a unique SSI in order to allow user-level multi-threading!

<P>
In addition to discovering the physical machine the ESMF initialization process sets up the default global virtual machine. This VM object, which is the ultimate parent of all VMs created during the course of execution, contains as many PETs as there are PEs in the physical machine. All of its PETs are instantiated in form of single-threaded MPI processes and a 1:1 mapping of PETs to PEs is used for the default global VM.

<P>
The VM design and implementation is based on the POSIX process and thread model as well as the MPI-1.2 standard. As a consequence of the latter standard the number of processes is static during the course of execution and is determined at start-up. The VM implementation further requires that the user starts up the ESMF application with as many MPI processes as there are PEs in the available physical machine using the platform dependent mechanism to ensure proper process placement. 

<P>
All MPI processes participating in a VM are grouped together by means of an MPI_Group object and their context is defined via an MPI_Comm object (MPI intra-communicator). The PET local process id within each virtual machine is equal to the MPI_Comm_rank in the local MPI_Comm context whereas the PET process id is equal to the MPI_Comm_rank in MPI_COMM_WORLD. The PET process id is used within the VM methods to determine the virtual memory space a PET is operating in. 

<P>
In order to provide a migration path for legacy MPI-applications the VM offers accessor functions to its MPI_Comm object. Once obtained this object may be used in explicit user-code MPI calls within the same context.

<P>

<H2><A NAME="SECTION060136000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060136100000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_VMAssignment(=) - VM assignment</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     interface assignment(=)
     vm1 = vm2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM) :: vm1
     type(ESMF_VM) :: vm2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Assign vm1 as an alias to the same ESMF VM object in memory
     as vm2. If vm2 is invalid, then vm1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060136200000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_VMOperator(==) - VM equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(==)
     if (vm1 == vm2) then ... endif
               OR
     result = (vm1 == vm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in) :: vm1
     type(ESMF_VM), intent(in) :: vm2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether vm1 and vm2 are valid aliases to the same ESMF
     VM object in memory. For a more general comparison of two ESMF VMs,
     going beyond the simple alias test, the ESMF_VMMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060136300000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_VMOperator(/=) - VM not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   interface operator(/=)
     if (vm1 /= vm2) then ... endif
               OR
     result = (vm1 /= vm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in) :: vm1
     type(ESMF_VM), intent(in) :: vm2
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Test whether vm1 and vm2 are <I>not</I> valid aliases to the
     same ESMF VM object in memory. For a more general comparison of two ESMF
     VMs, going beyond the simple alias test, the ESMF_VMMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060136400000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_VMAllFullReduce - Fully reduce data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllFullReduce(vm, sendData, recvData, &amp;
      count, reduceflag, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;),         intent(out)           :: recvData
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data
     array of &lt;type&gt;&lt;kind&gt; across the <TT>ESMF_VM</TT> object 
     into a single value of the same &lt;type&gt;&lt;kind&gt;. The result is
     returned on all PETs. Different reduction operations can be specified.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData. Allowed to be different across the 
          PETs, as long as <TT>count</TT> &gt; 0.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node9.html#const:reduce">54.49</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060136500000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_VMAllGather - Gather data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllGather(vm, sendData, recvData, count, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data
     of &lt;type&gt;&lt;kind&gt; from all PETs of an <TT>ESMF_VM</TT> object into an array on
     each PET. The data received in <TT>recvData</TT> is identical across all PETs.
     The <TT>count</TT> elements sent from the <TT>sendData</TT> array on PET <TT>i</TT>
     are stored contiguously in the <TT>recvData</TT> array starting at position
     <TT>i</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img205.png"
 ALT="$\times$"></SPAN> <TT>count</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img206.png"
 ALT="$+$"></SPAN> 1.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array. The first <TT>count</TT> elements on each PET are sent.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument large enough to accommodate the received
          data.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be gathered from each PET. Must be the
          same on all PETs.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060136600000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_VMAllGatherV - GatherV data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllGatherV(vm, sendData, sendCount, &amp;
      recvData, recvCounts, recvOffsets, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data
     of &lt;type&gt;&lt;kind&gt; from all PETs of an <TT>ESMF_VM</TT> object into an array on
     each PET. The data received in <TT>recvData</TT> is identical across all PETs.
     The <TT>sendCount</TT> elements sent from the <TT>sendData</TT> array on PET
     <TT>i</TT> are stored contiguously in the <TT>recvData</TT> array starting at
     position <TT>recvOffsets(i)</TT>.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to all other
          PETs.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument large enough to accommodate the received
          data.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received from the corresponding
          source PET.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking the start of
          element sequence to be received from source PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060136700000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_VMAllReduce - Reduce data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllReduce(vm, sendData, recvData, count, &amp;
      reduceflag, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data
     array across the <TT>ESMF_VM</TT> object into a contiguous data array of the
     same &lt;type&gt;&lt;kind&gt;. The result array is returned on all PETs. 
     Different reduction operations can be specified.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData and recvData. Must be the same on all
          PETs.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node9.html#const:reduce">54.49</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060136800000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_VMAllToAll - AllToAll communications across VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllToAll(vm, sendData, sendCount, &amp;
      recvData, recvCount, syncflag, &amp;
      commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCount
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.3.0r. If code using this interface compiles with any version of ESMF starting with 5.3.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that performs a total exchange
     operation on the contiguous data of &lt;type&gt;&lt;kind&gt;. PET <TT>i</TT> sends
     contiguous <TT>sendCount</TT> elements of its <TT>sendData</TT> array to every
     PET, including itself. The <TT>sendCount</TT> elements sent to PET <TT>j</TT> are
     those starting at position <TT>j</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img205.png"
 ALT="$\times$"></SPAN> <TT>sendCount</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img206.png"
 ALT="$+$"></SPAN> 1, and are
     stored in <TT>recvData</TT> on PET <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> in position <TT>i</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img205.png"
 ALT="$\times$"></SPAN>
     <TT>recvCount</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img206.png"
 ALT="$+$"></SPAN> 1.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to
          each destination PET.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument large enough to accommodate the received
          data.
     
</DD>
<DT><STRONG>recvCount</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received by local PET from
          each source PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060136900000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_VMAllToAllV - AllToAllV communications across VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllToAllV(vm, sendData, sendCounts, &amp;
      sendOffsets, recvData, recvCounts, recvOffsets, syncflag, &amp;
      commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCounts(:)
      integer,                          intent(in)            :: sendOffsets(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that performs a total exchange
     operation on the contiguous data of &lt;type&gt;&lt;kind&gt;. PET <TT>i</TT> sends
     contiguous elements of its <TT>sendData</TT> array to all PETs, including
     itself. The <TT>sendCounts(j)</TT> elements sent to PET <TT>j</TT> are
     those starting at position <TT>sendOffsets(j)</TT>, and are
     stored in <TT>recvData</TT> on PET <SPAN CLASS="MATH"><IMG
 WIDTH="12" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$j$"></SPAN> in position <TT>recvOffsets(i)</TT>.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCounts</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to
          destination PET.
     
</DD>
<DT><STRONG>sendOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>sendData</TT> marking to start of
          element sequence to be sent from local PET to destination PET.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument large enough to accommodate the received
          data.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received by local PET from
          source PET.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking to start of
          element sequence to be received by local PET from source PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_VMBarrier - VM wide barrier</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMBarrier(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),  intent(in),  optional :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,        intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Made argument <TT>vm</TT> optional to simplify usage when calling
     on the current VM.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that blocks calling PET until
     all PETs of the VM context have issued the call.

<P>
The arguments are:
     <DL>
<DT><STRONG>[vm]</STRONG></DT>
<DD><TT>ESMF_VM</TT> object. Default use current VM.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361100000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_VMBroadcast - Broadcast data across VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMBroadcast(vm, bcstData, count, rootPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(inout)         :: bcstData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that broadcasts a contiguous 
     data array of &lt;type&gt;&lt;kind&gt; from <TT>rootPet</TT> to all other PETs of the 
     <TT>ESMF_VM</TT> object. When the call returns, the <TT>bcstData</TT> array
     on all PETs contains the same data as on <TT>rootPet</TT>.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>bcstData</STRONG></DT>
<DD>Contiguous data array. On <TT>rootPet</TT> <TT>bcstData</TT> holds data that
          is to be broadcasted to all other PETs. On all other PETs 
          <TT>bcstData</TT> is used to receive the broadcasted data and must be
          large enough to accommodate the received data.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in /bcstData. Must be the same on all PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being broadcast.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361200000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_VMCommWait - Wait for non-blocking VM communication to complete</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMCommWait(vm, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),         intent(in)            :: vm
     type(ESMF_CommHandle), intent(in)            :: commhandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,               intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Wait for non-blocking VM communication specified by the <TT>commhandle</TT> to
     complete.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>commhandle</STRONG></DT>
<DD>Handle specifying a previously issued non-blocking communication 
          request.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361300000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_VMCommWaitAll - Wait for all non-blocking VM comms to complete</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMCommWaitAll(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Wait for <EM>all</EM> pending non-blocking VM communication within the 
     specified VM context to complete.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361400000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_VMEpochEnter - Enter an ESMF epoch</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMEpochEnter(vm, epoch, keepAlloc, throttle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_VM),            intent(in),  optional :: vm
     type(ESMF_VMEpoch_Flag),  intent(in),  optional :: epoch
     logical,                  intent(in),  optional :: keepAlloc
     integer,                  intent(in),  optional :: throttle
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Enter a specific VM epoch. VM epochs change low level communication behavior
     which can have significant performance implications. It is an error to call
     <TT>ESMF_VMEpochEnter()</TT> again before exiting a previous epoch with 
     <TT>ESMF_VMEpochExit()</TT>. Also, blocking collective calls
     (e.g. <TT>ESMF_VMBroadcast()</TT>) should not be used within a VMEpoch region.
     Doing so will result in a deadlock. 

<P>
The arguments are:
     <DL>
<DT><STRONG>[vm]</STRONG></DT>
<DD><TT>ESMF_VM</TT> object. Defaults to the current VM.
     
</DD>
<DT><STRONG>[epoch]</STRONG></DT>
<DD>The epoch to be entered. See section <A HREF="#const:vmepoch_flag">51.2.1</A> for a
          complete list of options. Defaults to <TT>ESMF_VMEPOCH_NONE</TT>.
     
</DD>
<DT><STRONG>[keepAlloc]</STRONG></DT>
<DD>For <TT>.true.</TT>, keep internal allocations to be reused by consecutive
          epoch phases. For <TT>.false.</TT>, deallocate all internal buffers not
          actively used.
          The flag only affects the local PET. Defaults to <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[throttle]</STRONG></DT>
<DD>Maximum number of outstanding communication calls beween any two PETs.
          Lower numbers reduce memory pressure at the expense of the level of
          asynchronizity achievable. Defaults to 10.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361500000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_VMEpochExit - Exit an ESMF epoch</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMEpochExit(vm, keepAlloc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_VM),            intent(in),  optional :: vm
     logical,                  intent(in),  optional :: keepAlloc
     integer,                  intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Exit the current VM epoch.

<P>
The arguments are:
     <DL>
<DT><STRONG>[vm]</STRONG></DT>
<DD><TT>ESMF_VM</TT> object. Defaults to the current VM.
     
</DD>
<DT><STRONG>[keepAlloc]</STRONG></DT>
<DD>For <TT>.true.</TT>, keep internal allocations to be reused by consecutive
          epoch phases. For <TT>.false.</TT>, deallocate all internal buffers not
          actively used.
          The flag only affects the local PET. Defaults to <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361600000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">16</SPAN> ESMF_VMGather - Gather data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMGather(vm, sendData, recvData, count, rootPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data
     of &lt;type&gt;&lt;kind&gt; from all PETs of an <TT>ESMF_VM</TT> object (including the 
     <TT>rootPet</TT> itself) into an array on <TT>rootPet</TT>.
     The <TT>count</TT> elements sent from the <TT>sendData</TT> array on PET <TT>i</TT>
     are stored contiguously in the <TT>recvData</TT> array on <TT>rootPet</TT>
     starting at position <TT>i</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img205.png"
 ALT="$\times$"></SPAN> <TT>count</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img206.png"
 ALT="$+$"></SPAN> 1.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. Only <TT>recvData</TT>
          specified by the <TT>rootPet</TT> will be used by this method, and must
          be large enough to accommodate the received data.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be sent from each PET to <TT>rootPet</TT>. Must be
          the same on all PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which data is gathereds.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361700000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">17</SPAN> ESMF_VMGatherV - GatherV data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMGatherV(vm, sendData, sendCount, recvData, &amp;
      recvCounts, recvOffsets, rootPet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data
     of &lt;type&gt;&lt;kind&gt; from all PETs of an <TT>ESMF_VM</TT> object (including the 
     <TT>rootPet</TT> itself) into an array on <TT>rootPet</TT>.
     The <TT>sendCount</TT> elements sent from the <TT>sendData</TT> array on PET
     <TT>i</TT> are stored contiguously in the <TT>recvData</TT> array on <TT>rootPet</TT>
     starting at position <TT>recvOffsets(i)</TT>.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to all other
          PETs.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. Only <TT>recvData</TT>
          specified by the <TT>rootPet</TT> will be used by this method, and must
          be large enough to accommodate the received data.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>An integer array (of length group size, specified in VM object) containing 
          number of <TT>recvData</TT> elements to be received from corresponding
          source PET. This argument is significant only at rootPet.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking the start of
          element sequence to be received from source PET.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which data is gathered.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361800000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">18</SPAN> ESMF_VMGet - Get general information from a VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_VMGet()
   recursive subroutine ESMF_VMGetDefault(vm, localPet, &amp;
     currentSsiPe, petCount, peCount, ssiCount, ssiMap, ssiMinPetCount, ssiMaxPetCount, &amp;
     ssiLocalPetCount, ssiLocalPet, ssiLocalDevCount, ssiLocalDevList, mpiCommunicator, &amp;
     pthreadsEnabledFlag, openMPEnabledFlag, ssiSharedMemoryEnabledFlag, esmfComm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),        intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: localPet
     integer,              intent(out), optional :: currentSsiPe
     integer,              intent(out), optional :: petCount
     integer,              intent(out), optional :: peCount
     integer,              intent(out), optional :: ssiCount
     integer, allocatable, intent(out), optional :: ssiMap(:)
     integer,              intent(out), optional :: ssiMinPetCount
     integer,              intent(out), optional :: ssiMaxPetCount
     integer,              intent(out), optional :: ssiLocalPetCount
     integer,              intent(out), optional :: ssiLocalPet
     integer,              intent(out), optional :: ssiLocalDevCount
     integer, allocatable, intent(out), optional :: ssiLocalDevList(:)
     integer,              intent(out), optional :: mpiCommunicator
     logical,              intent(out), optional :: pthreadsEnabledFlag
     logical,              intent(out), optional :: openMPEnabledFlag
     logical,              intent(out), optional :: ssiSharedMemoryEnabledFlag
     character(:), allocatable, intent(out), optional :: esmfComm
     integer,              intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>8.0.0</STRONG></DT>
<DD>Added arguments <TT>ssiCount</TT>, <TT>ssiMinPetCount</TT>, 
     <TT>ssiMaxPetCount</TT>, and <TT>ssiLocalPetCount</TT> to provide access 
     to information about how the VM is mapped across the single system images
     (SSIs) - typically synonymous to nodes - of the compute environment. This
     information is useful when constructing custom petLists. <BR>
Added argument <TT>ssiSharedMemoryEnabledFlag</TT> that allows the user to 
     query whether ESMF was compiled with support for shared memory 
     access between PETs on the same SSI.
   
</DD>
<DT><STRONG>8.1.0</STRONG></DT>
<DD>Added argument <TT>currentSsiPe</TT> for easy query of the
     current PE within the local SSI that is executing the request.
<BR>
Added argument <TT>ssiMap</TT> for a convenient way to obtain a view
     of the mapping of PETs to single system images across the entire VM.
   
</DD>
<DT><STRONG>8.2.0</STRONG></DT>
<DD>Added argument <TT>esmfComm</TT> to provide easy access to the
     <TT>ESMF_COMM</TT> setting used by the ESMF installation.
   
</DD>
<DT><STRONG>8.6.0</STRONG></DT>
<DD>Added arguments <TT>ssiLocalDevCount</TT> and <TT>ssiLocalDevCount</TT>
     to provide information about devices associated with the VM on the local
     SSI. <BR>
Added argument <TT>ssiLocalPet</TT> to help with SSI specific assignment
     between PET and device resources.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get internal information about the specified <TT>ESMF_VM</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Queried <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[localPet]</STRONG></DT>
<DD>Upon return this holds the id of the local PET that issued this call.
          The valid range of <TT>localPet</TT> is <!-- MATH
 $[0..petCount-1]$
 -->
<SPAN CLASS="MATH"><IMG
 WIDTH="123" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img207.png"
 ALT="$[0..petCount-1]$"></SPAN>. A value of <SPAN CLASS="MATH"><IMG
 WIDTH="24" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img87.png"
 ALT="$-1$"></SPAN>
          is returned on PETs that are not active under the specified <TT>vm</TT>.
     
</DD>
<DT><STRONG>[currentSsiPe]</STRONG></DT>
<DD>Upon return this holds the id of the PE within the local SSI on which
          the calling PET (i.e. localPet) is currently executing. If the PET is
          associated with a set of PEs, or PETs are not pinned, the returned
          value might change each time the call is made.
     
</DD>
<DT><STRONG>[petCount]</STRONG></DT>
<DD>Upon return this holds the number of PETs running under <TT>vm</TT>.
     
</DD>
<DT><STRONG>[peCount]</STRONG></DT>
<DD>Upon return this holds the number of PEs referenced by <TT>vm</TT>.
     
</DD>
<DT><STRONG>[ssiCount]</STRONG></DT>
<DD>Upon return this holds the number of single system images referenced 
          by <TT>vm</TT>.
     
</DD>
<DT><STRONG>[ssiMap]</STRONG></DT>
<DD>Upon return this array is allocated and holds the single system image
          id for each PET across the <TT>vm</TT>. The size of <TT>ssiMap</TT> is
          equal to <TT>petCount</TT>, with lower bound 0 and upper bound
          <TT>petCount - 1</TT>.
     
</DD>
<DT><STRONG>[ssiMinPetCount]</STRONG></DT>
<DD>Upon return this holds the smallest number of PETs running in the same
          single system images under <TT>vm</TT>.
     
</DD>
<DT><STRONG>[ssiMaxPetCount]</STRONG></DT>
<DD>Upon return this holds the largest number of PETs running in the same
          single system images under <TT>vm</TT>.
     
</DD>
<DT><STRONG>[ssiLocalPetCount]</STRONG></DT>
<DD>Upon return this holds the number of PETs running in the same
          single system as <TT>localPet</TT>.
     
</DD>
<DT><STRONG>[ssiLocalPet]</STRONG></DT>
<DD>Upon return this holds the SSI local index of the executing
          <TT>localPet</TT>.
     
</DD>
<DT><STRONG>[ssiLocalDevCount]</STRONG></DT>
<DD>Upon return this holds the number of devices associated with this VM
          on the local single system.
     
</DD>
<DT><STRONG>[ssiLocalDevList]</STRONG></DT>
<DD>Upon return this array is allocated and holds the local device ids
          of devices associated with this VM. The size of <TT>ssiLocalDevList</TT>
          is equal to <TT>ssiLocalDevCount</TT>, with lower bound 0 and upper
          bound <TT>ssiLocalDevCount - 1</TT>. Local device ids can be used to
          target specific devices using OpenMP, OpenACC, or similar device
          API.
     
</DD>
<DT><STRONG>[mpiCommunicator]</STRONG></DT>
<DD>Upon return this holds the MPI intra-communicator used by the 
          specified <TT>ESMF_VM</TT> object. This communicator may be used for
          user-level MPI communications. It is recommended that the user
          duplicates the communicator via <TT>MPI_Comm_Dup()</TT> in order to
          prevent any interference with ESMF communications.
          <TT>MPI_COMM_NULL</TT> is returned on PETs that are not active
          under the specified <TT>vm</TT>.
     
</DD>
<DT><STRONG>[pthreadsEnabledFlag]</STRONG></DT>
<DD><DL>
<DT><STRONG><TT>.TRUE.</TT></STRONG></DT>
<DD>ESMF has been compiled with Pthreads, and the MPI environment
               supports threading.
          
</DD>
<DT><STRONG><TT>.FALSE.</TT></STRONG></DT>
<DD>ESMF has <EM>not</EM> been compiled with Pthreads, or the MPI
               environment does <EM>not</EM> support threading.
          
</DD>
</DL>
     
</DD>
<DT><STRONG>[openMPEnabledFlag]</STRONG></DT>
<DD><DL>
<DT><STRONG><TT>.TRUE.</TT></STRONG></DT>
<DD>ESMF has been compiled with OpenMP.
          
</DD>
<DT><STRONG><TT>.FALSE.</TT></STRONG></DT>
<DD>ESMF has <EM>not</EM> been compiled with OpenMP.
          
</DD>
</DL>
     
</DD>
<DT><STRONG>[ssiSharedMemoryEnabledFlag]</STRONG></DT>
<DD><DL>
<DT><STRONG><TT>.TRUE.</TT></STRONG></DT>
<DD>ESMF has been compiled to support shared memory access
               between PETs that are on the same single system image (SSI).
          
</DD>
<DT><STRONG><TT>.FALSE.</TT></STRONG></DT>
<DD>ESMF has <EM>not</EM> been compiled to support shared memory access
               between PETs that are on the same single system image (SSI).
          
</DD>
</DL>
     
</DD>
<DT><STRONG>[esmfComm]</STRONG></DT>
<DD>Upon return this string is allocated to the appropriate size and holds
          the exact value of the <TT>ESMF_COMM</TT> build environment variable used
          by the ESMF installation. This provides a convenient way for the user
          to determine the underlying MPI implementation.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601361900000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">19</SPAN> ESMF_VMGet - Get PET specific information from a VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_VMGet()
   subroutine ESMF_VMGetPetSpecific(vm, pet, peCount, &amp;
     accDeviceCount, &amp;   ! DEPRECATED ARGUMENT
     ssiId, threadCount, threadId, vas, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
     integer,       intent(in)            :: pet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: peCount
     integer,       intent(out), optional :: accDeviceCount ! DEPRECATED ARGUMENT
     integer,       intent(out), optional :: ssiId
     integer,       intent(out), optional :: threadCount
     integer,       intent(out), optional :: threadId
     integer,       intent(out), optional :: vas
     integer,       intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
</LI>
<LI>This interface was modified since ESMF version 5.2.0r. The fact that code using this interface compiles with the current ESMF version does not guarantee that it compiles with previous versions of this interface. If user code compatibility with version 5.2.0r is desired then care must be taken to limit the use of this interface to features that were available in the 5.2.0r release. 
<BR>
Changes made after the 5.2.0r release:
   <DL>
<DT><STRONG>7.0.0</STRONG></DT>
<DD>Added argument <TT>accDeviceCount</TT>.
     The argument provides access to the number of available accelerator devices.
   
</DD>
<DT><STRONG>8.6.0</STRONG></DT>
<DD>Started deprecation of argument <TT>accDeviceCount</TT> in favor of
     the new arguments <TT>ssiLocalDevCount</TT> and <TT>ssiLocalDevList</TT> offered
     by the general <TT>ESMF_VMGet()</TT> method.
   
</DD>
</DL>
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get internal information about a specific PET within an <TT>ESMF_VM</TT> 
     object.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Queried <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>pet</STRONG></DT>
<DD>Queried PET id within the specified <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[peCount]</STRONG></DT>
<DD>Upon return this holds the number of PEs associated with the specified
          PET in the <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[accDeviceCount]</STRONG></DT>
<DD>Upon return this holds the number of accelerated devices accessible
          from the specified PET in the <TT>ESMF_VM</TT> object.
         <B>DEPRECATED ARGUMENT!</B> Please use the argument <TT>ssiLocalDevCount</TT> instead.
     
</DD>
<DT><STRONG>[ssiId]</STRONG></DT>
<DD>Upon return this holds the id of the single-system image (SSI) the
          specified PET is running on.
     
</DD>
<DT><STRONG>[threadCount]</STRONG></DT>
<DD>Upon return this holds the number of PETs in the specified PET"s 
          thread group.
     
</DD>
<DT><STRONG>[threadId]</STRONG></DT>
<DD>Upon return this holds the thread id of the specified PET within the 
          PET"s thread group.
     
</DD>
<DT><STRONG>[vas]</STRONG></DT>
<DD>Virtual address space in which this PET operates.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">20</SPAN> ESMF_VMGetGlobal - Get Global VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMGetGlobal(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(out)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional  :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the global <TT>ESMF_VM</TT> object. This is the VM object
     that is created during <TT>ESMF_Initialize()</TT> and is the ultimate
     parent of all VM objects in an ESMF application. It is identical to the VM
     object returned by <TT>ESMF_Initialize(..., vm=vm, ...)</TT>.

<P>
The <TT>ESMF_VMGetGlobal()</TT> call provides access to information about the
     global execution context via the global VM. This call is necessary because
     ESMF does not created a global ESMF Component during
     <TT>ESMF_Initialize()</TT> that could be queried for information about
     the global execution context of an ESMF application.

<P>
Usage of <TT>ESMF_VMGetGlobal()</TT> from within Component code is
     strongly discouraged. ESMF Components should only access their own VM
     objects through Component methods. Global information, if required by
     the Component user code, should be passed down to the Component from the 
     driver through the Component calling interface.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Upon return this holds the <TT>ESMF_VM</TT> object of the global execution 
       context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362100000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">21</SPAN> ESMF_VMGetCurrent - Get Current VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMGetCurrent(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(out)           :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get the <TT>ESMF_VM</TT> object of the current execution context. Calling
     <TT>ESMF_VMGetCurrent()</TT> within an ESMF Component, will return the
     same VM object as
     <TT>ESMF_GridCompGet(..., vm=vm, ...)</TT> or
     <TT>ESMF_CplCompGet(..., vm=vm, ...)</TT>.

<P>
The main purpose of providing <TT>ESMF_VMGetCurrent()</TT> is to simplify ESMF
     adoption in legacy code. Specifically, code that uses <TT>MPI_COMM_WORLD</TT>
     deep within its calling tree can easily be modified to use the correct MPI
     communicator of the current ESMF execution context. The advantage is that
     these modifications are very local, and do not require wide reaching
     interface changes in the legacy code to pass down the ESMF component object,
     or the MPI communicator.

<P>
The use of <TT>ESMF_VMGetCurrent()</TT> is strongly discouraged in newly
     written Component code. Instead, the ESMF Component object should be used as
     the appropriate container of ESMF context information. This object should be
     passed between the subroutines of a Component, and be queried for any
     Component specific information.

<P>
Outside of a Component context, i.e. within the driver context, the call
     to <TT>ESMF_VMGetCurrent()</TT> is identical to <TT>ESMF_VMGetGlobal()</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Upon return this holds the <TT>ESMF_VM</TT> object of the current execution
       context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362200000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">22</SPAN> ESMF_VMIsCreated - Check whether a VM object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_VMIsCreated(vm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_VMIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>vm</TT> has been created. Otherwise return 
     <TT>.false.</TT>. If an error occurs, i.e. <TT>rc /= ESMF_SUCCESS</TT> is 
     returned, the return value of the function will also be <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> queried.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362300000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">23</SPAN> ESMF_VMLog - Log VM information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMLog(vm, prefix, logMsgFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),          intent(in)              :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),       intent(in),   optional  :: prefix
     type(ESMF_LogMsg_Flag), intent(in),   optional  :: logMsgFlag
     integer, intent(out),                 optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Write information about <TT>vm</TT> to the ESMF default Log.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object logged.
     
</DD>
<DT><STRONG>[prefix]</STRONG></DT>
<DD>String to prefix the log message. Default is no prefix.
     
</DD>
<DT><STRONG>[logMsgFlag]</STRONG></DT>
<DD>Type of log message generated. See section <A HREF="#const:logmsgflag">49.2.3</A> for
       a list of valid message types. Default is <TT>ESMF_LOGMSG_INFO</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362400000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">24</SPAN> ESMF_VMLogSystem - LogSystem</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMLogSystem(prefix, logMsgFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),       intent(in),   optional  :: prefix
     type(ESMF_LogMsg_Flag), intent(in),   optional  :: logMsgFlag
     integer, intent(out),                 optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Log the VM.

<P>
The arguments are:
     <DL>
<DT><STRONG>[prefix]</STRONG></DT>
<DD>String to prefix the log message. Default is no prefix.
     
</DD>
<DT><STRONG>[logMsgFlag]</STRONG></DT>
<DD>Type of log message generated. See section <A HREF="#const:logmsgflag">49.2.3</A> for
       a list of valid message types. Default is <TT>ESMF_LOGMSG_INFO</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362500000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">25</SPAN> ESMF_VMPrint - Print VM information</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMPrint(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),  intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,        intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Print internal information about the specified <TT>ESMF_VM</TT> to
     <TT>stdout</TT>.
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Specified <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362600000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">26</SPAN> ESMF_VMRecv - Receive data from srcPet</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMRecv(vm, recvData, count, srcPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                     intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target,  intent(out)           :: recvData(:)
      integer,                           intent(in)            :: count
      integer,                           intent(in)            :: srcPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),              intent(in),  optional :: syncflag
      type(ESMF_CommHandle),             intent(out), optional :: commhandle
      integer,                           intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Receive contiguous data from <TT>srcPet</TT> within the same <TT>ESMF_VM</TT> 
     object.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be received.
     
</DD>
<DT><STRONG>srcPet</STRONG></DT>
<DD>Sending PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362700000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">27</SPAN> ESMF_VMReduce - Reduce data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMReduce(vm, sendData, recvData, count, &amp;
      reduceflag, rootPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data
     array across the <TT>ESMF_VM</TT> object into a contiguous data array of 
     the same &lt;type&gt;&lt;kind&gt;. The result array is returned on <TT>rootPet</TT>. 
     Different reduction operations can be specified.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT>, error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. Only the <TT>recvData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData and recvData. Must be the same on all
          PETs.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node9.html#const:reduce">54.49</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which reduced data is returned.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362800000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">28</SPAN> ESMF_VMScatter - Scatter data across VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMScatter(vm, sendData, recvData, count, &amp;
      rootPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that scatters contiguous data
     of &lt;type&gt;&lt;kind&gt; from <TT>rootPet</TT> across all the PETs of an <TT>ESMF_VM</TT>
     object. Every PET, including <TT>rootPet</TT>, receives a portion of the data.
     The <TT>count</TT> number of elements received by PET <TT>i</TT> originate from
     the <TT>sendData</TT> array on <TT>rootPet</TT>, starting at position <TT>i</TT>
     <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img205.png"
 ALT="$\times$"></SPAN> <TT>count</TT> <SPAN CLASS="MATH"><IMG
 WIDTH="16" HEIGHT="29" ALIGN="MIDDLE" BORDER="0"
 SRC="img206.png"
 ALT="$+$"></SPAN> 1. Each PET stores the received contiguous data
     portion at the start of its <TT>recvData</TT> array.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. Only the <TT>sendData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid destination array large enough to accommodate the received data.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be sent from <TT>rootPet</TT> to each of the PETs.
          Must be the same on all PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being scattered.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601362900000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">29</SPAN> ESMF_VMScatterV - ScatterV across VM</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMScatterV(vm, sendData, sendCounts, &amp;
      sendOffsets, recvData, recvCount, rootPet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCounts(:)
      integer,                          intent(in)            :: sendOffsets(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCount
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that scatters contiguous data
     of &lt;type&gt;&lt;kind&gt; from <TT>rootPet</TT> across all the PETs of an <TT>ESMF_VM</TT>
     object. Every PET, including <TT>rootPet</TT>, receives a portion of the data.
     The <TT>recvCount</TT> number of elements received by PET <TT>i</TT> originate
     from the <TT>sendData</TT> array on <TT>rootPet</TT>, starting at position
     <TT>sendOffsets(i)</TT>. Each PET stores the received contiguous data
     portion at the start of its <TT>recvData</TT> array.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent. Only the <TT>sendData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>sendCounts</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to be sent to corresponding
          receive PET.
     
</DD>
<DT><STRONG>sendOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>sendData</TT> marking the start of
          element sequence to be sent to receive PET.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument large enough to accommodate the received
          data.
     
</DD>
<DT><STRONG>recvCount</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to receive by local PET from
          <TT>rootPet</TT>.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being scattered.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601363000000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">30</SPAN> ESMF_VMSend - Send data to dstPet</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMSend(vm, sendData, count, dstPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: dstPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Send contiguous data to <TT>dstPet</TT> within the same <TT>ESMF_VM</TT> object.

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be sent.
     
</DD>
<DT><STRONG>dstPet</STRONG></DT>
<DD>Receiving PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601363100000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">31</SPAN> ESMF_VMSendRecv - Send and Recv data to and from PETs</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_VMSendRecv(vm, sendData, sendCount, dstPet, &amp;
      recvData, recvCount, srcPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      integer,                          intent(in)            :: dstPet
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCount
      integer,                          intent(in)            :: srcPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Send contiguous data to <TT>dstPet</TT> within the same <TT>ESMF_VM</TT> object
     while receiving contiguous data from <TT>srcPet</TT> within the same 
     <TT>ESMF_VM</TT> object. The <TT>sendData</TT> and <TT>recvData</TT> arrays must be
     disjoint!

<P>
This method is overloaded for:
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>,
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be sent.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of elements to be sent.
     
</DD>
<DT><STRONG>dstPet</STRONG></DT>
<DD>PET that holds <TT>recvData</TT>.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received.
     
</DD>
<DT><STRONG>recvCount</STRONG></DT>
<DD>Number of elements to be received.
     
</DD>
<DT><STRONG>srcPet</STRONG></DT>
<DD>PET that holds <TT>sendData</TT>.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node9.html#const:sync">54.59</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601363200000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">32</SPAN> ESMF_VMValidate - Validate VM internals</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMValidate(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>vm</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Specified <TT>ESMF_VM</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601363300000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">33</SPAN> ESMF_VMWtime - Get floating-point number of seconds</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMWtime(time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(out)           :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get floating-point number of seconds of elapsed wall-clock time since the
     beginning of execution of the application.

<P>
The arguments are:
     <DL>
<DT><STRONG>time</STRONG></DT>
<DD>Time in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601363400000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">34</SPAN> ESMF_VMWtimeDelay - Delay execution</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   recursive subroutine ESMF_VMWtimeDelay(delay, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(in)            :: delay
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Delay execution for amount of seconds.

<P>
The arguments are:
     <DL>
<DT><STRONG>delay</STRONG></DT>
<DD>Delay time in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601363500000000000000">
<SPAN CLASS="arabic">51</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">35</SPAN> ESMF_VMWtimePrec - Timer precision as floating-point number of seconds</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_VMWtimePrec(prec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(out)           :: prec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Get a run-time estimate of the timer precision as floating-point number 
     of seconds. This is a relatively expensive call since the timer precision
     is measured several times before the maximum is returned as the estimate.
     The returned value is PET-specific and may differ across the VM 
     context.

<P>
The arguments are:
     <DL>
<DT><STRONG>prec</STRONG></DT>
<DD>Timer precision in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<H1><A NAME="SECTION060140000000000000000">
<SPAN CLASS="arabic">52</SPAN> Profiling and Tracing</A>
</H1>

<H2><A NAME="SECTION060141000000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>

<H3><A NAME="SECTION060141100000000000000"></A>
<A NAME="sec:Profiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Profiling
</H3>

<P>
ESMF's built in <EM>profiling</EM> capability collects runtime statistics
of an executing ESMF application through both automatic and manual code
instrumentation. Timing information for all phases of all ESMF components
executing in an application can be automatically collected using the
<TT>ESMF_RUNTIME_PROFILE</TT> environment variable (see below for settings).
Additionally, arbitrary user-defined code regions can be timed by
manually instrumenting code with special API calls.  Timing profiles
of component phases and user-defined regions can be output in several
different formats:

<UL>
<LI>in text at the end of ESMF Log files
</LI>
<LI>in separate text file, one per PET (if the ESMF Logs are turned off)
</LI>
<LI>in a single summary text file that aggregates timings over multiple PETs
</LI>
<LI>in a binary format for import into the <A NAME="tex2html62"
  HREF="https://github.com/esmf-org/esmf-profiler">esmf-profiler</A>
for profile visualization
</LI>
</UL>

<P>
The following table lists important environment variables that control
aspects of ESMF profiling.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Environment Variable</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><B>Description</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Example Values</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Default</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_PROFILE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Enable/disables all profiling functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ON</TT> or <TT>OFF</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>OFF</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_PROFILE_PETLIST</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Limits profiling to an explicit list of PETs</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>&ldquo;<TT>0-9 50 99</TT>&rdquo;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><EM>profile all PETs</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_PROFILE_OUTPUT</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Controls output format of profiles;  multiple can be specified in a space separated list</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>TEXT</TT>, <TT>SUMMARY</TT>, <TT>BINARY</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>TEXT</TT></TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION060141200000000000000"></A>
<A NAME="sec:Tracing"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Tracing
</H3>

<P>
Whereas profiling collects summary information from an application,
<EM>tracing</EM> records a more detailed set of events for later analysis. Trace
analysis can be used to understand what happened during a program's
execution and is often used for diagnosing problems, debugging, and
performance analysis.

<P>
ESMF has a built-in tracing capability that records events into special
binary log files.  Unlike log files written by the <TT>ESMF_Log</TT> class,
which are primarily for human consumption (see Section <A HREF="#sec:Log">49.1</A>),
the trace output files are
recorded in a compact binary representation and are processed by tools
to produce various analyses. ESMF event streams are recorded in the
<A NAME="tex2html63"
  HREF="http://diamon.org/ctf/">Common Trace Format</A>
(CTF).
CTF traces include one or more event streams,
as well as a metadata file describing the events in the streams.

<P>
Several tools are available for reading in the CTF traces output by ESMF.
Of the tools listed below, the first one is designed specifically for
analyzing ESMF applications and the second two are general purpose tools
for working with all CTF traces.

<UL>
<LI><A NAME="tex2html64"
  HREF="https://github.com/esmf-org/esmf-profiler">esmf-profiler</A>
is a tool that ingests traces from an ESMF application and generates
  performance profile plots.
</LI>
<LI><A NAME="tex2html65"
  HREF="http://tracecompass.org/">TraceCompass</A>
is a general purpose tool for reading, analyzing, and visualizing traces.
</LI>
<LI><A NAME="tex2html66"
  HREF="http://www.efficios.com/babeltrace">Babeltrace</A>
is a command-line tool and library for trace conversion
  that can read and write CTF traces. Python bindings are available
  to open CTF traces are iterate through events.  
</LI>
</UL>

<P>
Events that can be captured by the ESMF tracer include the following. Events
are recorded with a high-precision timestamp to allow timing analyses.
<DL>
<DT><STRONG>phase_enter</STRONG></DT>
<DD>indicates entry into an initialize, run, or finalize ESMF component routine
</DD>
<DT><STRONG>phase_exit</STRONG></DT>
<DD>indicates exit from an initialize, run, or finalize ESMF component routine
</DD>
<DT><STRONG>region_enter</STRONG></DT>
<DD>indicates entry into a user-defined code region
</DD>
<DT><STRONG>region_exit</STRONG></DT>
<DD>indicates exit from a user-defined code region
</DD>
</DL>

<P>
The following table lists important environment variables that control
aspects of ESMF tracing.

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Environment Variable</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227><B>Description</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Example Values</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Default</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Enable/disables all tracing functions</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ON</TT> or <TT>OFF</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>OFF</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE_CLOCK</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Sets the type of clock for timestamping events (see Section <A HREF="#sec:TracingClocks">52.2.6</A>).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>REALTIME</TT> or <TT>MONOTONIC</TT> or <TT>MONOTONIC_SYNC</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>REALTIME</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE_PETLIST</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Limits tracing to an explicit list of PETs</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170>&ldquo;<TT>0-9 50 99</TT>&rdquo;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><EM>trace all PETs</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE_COMPONENT</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Enables/disable tracing of Component phase_enter and phase_exit events</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ON</TT> or <TT>OFF</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ON</TT></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>ESMF_RUNTIME_TRACE_FLUSH</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=227>Controls frequency of event stream flushing to file</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>DEFAULT</TT> or <TT>EAGER</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>DEFAULT</TT></TD>
</TR>
</TABLE>

<P>

<H2><A NAME="SECTION060142000000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>

<H3><A NAME="SECTION060142100000000000000"></A>
<A NAME="sec:BasicProfiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Output a Timing Profile to Text
</H3>

<P>
ESMF profiling is disabled by default. To profile an application,
set the <TT>ESMF_RUNTIME_PROFILE</TT> variable to <TT>ON</TT> prior
to executing the application.  You do not need to recompile
your code to enable profiling.

<P>
<PRE>
# csh shell
$ setenv ESMF_RUNTIME_PROFILE ON

# bash shell
$ export ESMF_RUNTIME_PROFILE=ON

# (from now on, only the csh shell version will be shown)
</PRE>

<P>
Then execute the application in the usual way. At the end of
the run the profile information will be available at the end
of each PET log (if ESMF Logs are turned on) or in a set of
separate files, one per PET, with names <EM>ESMF_Profile.XXX</EM>
where XXX is the PET number.  Below is an example timing
profile.  Some regions are left out for brevity.

<P>
<PRE>
Region                           Count  Total (s)   Self (s)    Mean (s)    Min (s)     Max (s)
  [esm] Init 1                   1      4.0878      0.0341      4.0878      4.0878      4.0878
    [OCN-TO-ATM] IPDv05p6b       1      2.6007      2.6007      2.6007      2.6007      2.6007
    [ATM-TO-OCN] IPDv05p6b       1      1.4333      1.4333      1.4333      1.4333      1.4333
    [ATM] IPDv00p2               1      0.0055      0.0055      0.0055      0.0055      0.0055
    [OCN] IPDv00p2               1      0.0023      0.0023      0.0023      0.0023      0.0023
    [ATM] IPDv00p1               1      0.0011      0.0011      0.0011      0.0011      0.0011
    [OCN] IPDv00p1               1      0.0009      0.0009      0.0009      0.0009      0.0009
    [ATM-TO-OCN] IPDv05p3        1      0.0008      0.0008      0.0008      0.0008      0.0008
    [ATM-TO-OCN] IPDv05p1        1      0.0008      0.0008      0.0008      0.0008      0.0008
    [ATM-TO-OCN] IPDv05p2b       1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p4        1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p2a       1      0.0007      0.0007      0.0007      0.0007      0.0007
    [ATM-TO-OCN] IPDv05p5        1      0.0007      0.0007      0.0007      0.0007      0.0007
    [OCN-TO-ATM] IPDv05p3        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p4        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p2b       1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p2a       1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p5        1      0.0006      0.0006      0.0006      0.0006      0.0006
    [OCN-TO-ATM] IPDv05p1        1      0.0005      0.0005      0.0005      0.0005      0.0005
  [esm] RunPhase1                1      2.7423      0.9432      2.7423      2.7423      2.7423
    [OCN-TO-ATM] RunPhase1       864    0.6094      0.6094      0.0007      0.0006      0.0179
    [ATM] RunPhase1              864    0.5296      0.2274      0.0006      0.0005      0.0011
      ATM:ModelAdvance           864    0.3022      0.3022      0.0003      0.0003      0.0005
    [ATM-TO-OCN] RunPhase1       864    0.3345      0.3345      0.0004      0.0002      0.0299
    [OCN] RunPhase1              864    0.3256      0.3256      0.0004      0.0003      0.0010
  [esm] FinalizePhase1           1      0.0029      0.0020      0.0029      0.0029      0.0029
    [OCN-TO-ATM] FinalizePhase1  1      0.0006      0.0006      0.0006      0.0006      0.0006
    [ATM-TO-OCN] FinalizePhase1  1      0.0002      0.0002      0.0002      0.0002      0.0002
    [OCN] FinalizePhase1         1      0.0001      0.0001      0.0001      0.0001      0.0001
    [ATM] FinalizePhase1         1      0.0000      0.0000      0.0000      0.0000      0.0000
</PRE>

<P>
A timed region is either an ESMF component phase (e.g., initialize,
run, or finalize) or a user-defined region of code surrounded by calls to
<TT>ESMF_TraceRegionEnter()</TT> and <TT>ESMF_TraceRegionExit()</TT>. (See
section <A HREF="#ex:TraceUserEx">52.2.8</A> for more information on instrumenting
user-defined regions.)
Regions are organized hierarchically with sub-regions nested.
For example, in the profile above,
the <TT>[OCN] RunPhase1</TT> is a sub-region of <TT>[esm] RunPhase1</TT> and is
entirely contained inside that region. Regions with the same name may appear
at multiple places in the hierarchy, and so would appear in multiple rows
in the table.  The statistics in that row apply to that region at that
location in the hierarchy. Component names appear in square brackets,
e.g., <TT>[ATM]</TT>,  <TT>[OCN]</TT>, and <TT>[ATM-TO-OCN]</TT>.
By default, timings are based on elapsed wall clock time and are collected
on a per-PET basis. Therefore, regions timings may differ across PETs. Regions
are sorted with the most expensive regions appearing at the top. The following
describes the meaning of the statistics in each column:

<P>
<table width="90%"><tr><td align="right" valign="top"><TT>Count</TT></td><td valign="top">&nbsp;the number of times the region is executed</td></tr>
<tr><td align="right" valign="top"><TT>Total</TT></td><td valign="top">&nbsp;the aggregate time spent in the region, inclusive of all sub-regions</td></tr>
<tr><td align="right" valign="top"><TT>Self</TT></td><td valign="top">&nbsp;the aggregate time spend in the region, exclusive of all sub-regions</td></tr>
<tr><td align="right" valign="top"><TT>Mean</TT></td><td valign="top">&nbsp;the average amount of time for one execution of the region</td></tr>
<tr><td align="right" valign="top"><TT>Min</TT></td><td valign="top">&nbsp;time of the fastest execution of the region</td></tr>
<tr><td align="right" valign="top"><TT>Max</TT></td><td valign="top">&nbsp;time of the slowest execution of the region
</td></tr></table>

<P>

<H3><A NAME="SECTION060142200000000000000"></A>
<A NAME="sec:SummaryProfiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Summarize Timings across Multiple PETs
</H3>

<P>
By default, separate timing profiles are generated for each PET
in the application.  The per-PET profiles can be aggregated together
and output to a single file, <EM>ESMF_Profile.summary</EM>, by setting the
<TT>ESMF_RUNTIME_PROFILE_OUTPUT</TT> environment variable as follows:

<P>
<PRE>
$ setenv ESMF_RUNTIME_PROFILE ON              # turn on profiling
$ setenv ESMF_RUNTIME_PROFILE_OUTPUT SUMMARY  # specify summary output
</PRE>

<P>
Note the <TT>ESMF_RUNTIME_PROFILE</TT> environment variable must
also be set to <TT>ON</TT> since this controls all profiling capabilities.
The <EM>ESMF_Profile.summary</EM> file will contain a tree of
timed regions, but aggregated across all PETs. For example:

<P>
<PRE>
Region                           PETs   PEs    Count    Mean (s)    Min (s)     Min PET Max (s)     Max PET
  [esm] Init 1                   4      4      1        4.0880      4.0878      2       4.0883      1
    [OCN-TO-ATM] IPDv05p6b       4      4      1        2.6007      2.6007      2       2.6007      3
    [ATM-TO-OCN] IPDv05p6b       4      4      1        1.4335      1.4333      0       1.4337      3
    [ATM-TO-OCN] IPDv05p4        4      4      1        0.0037      0.0007      0       0.0060      1
    [ATM] IPDv00p2               4      4      1        0.0034      0.0020      1       0.0055      0
    [ATM-TO-OCN] IPDv05p1        4      4      1        0.0020      0.0007      2       0.0033      3
    [OCN] IPDv00p2               4      4      1        0.0019      0.0015      3       0.0024      2
    [ATM-TO-OCN] IPDv05p3        4      4      1        0.0010      0.0008      0       0.0013      1
    [ATM-TO-OCN] IPDv05p2a       4      4      1        0.0009      0.0007      0       0.0012      3
    [ATM] IPDv00p1               4      4      1        0.0009      0.0007      3       0.0011      0
    [ATM-TO-OCN] IPDv05p2b       4      4      1        0.0008      0.0007      0       0.0010      3
    [ATM-TO-OCN] IPDv05p5        4      4      1        0.0008      0.0007      0       0.0010      3
    [ATM-TO-OCN] IPDv05p6a       4      4      1        0.0008      0.0005      2       0.0012      3
    [OCN-TO-ATM] IPDv05p3        4      4      1        0.0008      0.0006      2       0.0010      3
    [OCN-TO-ATM] IPDv05p4        4      4      1        0.0008      0.0006      0       0.0009      3
    [OCN-TO-ATM] IPDv05p2b       4      4      1        0.0007      0.0006      2       0.0009      3
    [OCN] IPDv00p1               4      4      1        0.0007      0.0005      1       0.0009      2
    [OCN-TO-ATM] IPDv05p2a       4      4      1        0.0007      0.0006      2       0.0009      1
    [OCN-TO-ATM] IPDv05p5        4      4      1        0.0007      0.0006      0       0.0009      3
    [OCN-TO-ATM] IPDv05p1        4      4      1        0.0006      0.0005      0       0.0008      1
    [OCN-TO-ATM] IPDv05p6a       4      4      1        0.0006      0.0004      2       0.0007      1
  [esm] RunPhase1                4      4      1        2.7444      2.7423      0       2.7454      1
    [OCN-TO-ATM] RunPhase1       4      4      864      0.6123      0.6004      2       0.6244      1
    [ATM] RunPhase1              4      4      864      0.5386      0.5296      0       0.5530      1
      ATM:ModelAdvance           4      4      864      0.3038      0.3022      0       0.3065      1
    [OCN] RunPhase1              4      4      864      0.3471      0.3256      0       0.3824      1
    [ATM-TO-OCN] RunPhase1       4      4      864      0.2843      0.1956      1       0.3345      0
  [esm] FinalizePhase1           4      4      1        0.0029      0.0029      1       0.0030      2
    [OCN-TO-ATM] FinalizePhase1  4      4      1        0.0007      0.0006      0       0.0008      3
    [ATM-TO-OCN] FinalizePhase1  4      4      1        0.0002      0.0001      3       0.0002      1
    [OCN] FinalizePhase1         4      4      1        0.0001      0.0001      3       0.0001      0
    [ATM] FinalizePhase1         4      4      1        0.0001      0.0000      0       0.0001      2
</PRE>

<P>
The meaning of the statistics in each column in as follows:
<table width="90%"><tr><td align="right" valign="top"><TT>PETs</TT></td><td valign="top">&nbsp;the number of reporting PETs that executed the region</td></tr>
<tr><td align="right" valign="top"><TT>PEs</TT></td><td valign="top">&nbsp;the number of PEs associated with the reporting PETs that executed the region</td></tr>
<tr><td align="right" valign="top"><TT>Count</TT></td><td valign="top">&nbsp;the number of times each reporting PET executed the region
      or &ldquo;MULTIPLE&rdquo; if not all PETs executed the region the same number of times</td></tr>
<tr><td align="right" valign="top"><TT>Mean</TT></td><td valign="top">&nbsp;the mean across all reporting PETs of the total time spent in the region</td></tr>
<tr><td align="right" valign="top"><TT>Min</TT></td><td valign="top">&nbsp;the minimum across all reporting PETs of the total time spent in the region</td></tr>
<tr><td align="right" valign="top"><TT>Min PET</TT></td><td valign="top">&nbsp;the PET that reported the minimum time</td></tr>
<tr><td align="right" valign="top"><TT>Max</TT></td><td valign="top">&nbsp;the maximum across all reporting PETs of the total time spent in the region</td></tr>
<tr><td align="right" valign="top"><TT>Max PET</TT></td><td valign="top">&nbsp;the PET that reported the maximum time
</td></tr></table>

<P>
Note that setting the <TT>ESMF_RUNTIME_PROFILE_PETLIST</TT> environment variable
(described below) may reduce the number of reporting PETs. Only reporting PETs are
included in the summary profile. To output both the per-PET and summary timing profiles,
set the <TT>ESMF_RUNTIME_PROFILE_OUTPUT</TT> environment variable as follows:

<P>
<PRE>
$ setenv ESMF_RUNTIME_PROFILE_OUTPUT "TEXT SUMMARY"
</PRE>

<P>

<H3><A NAME="SECTION060142300000000000000"></A>
<A NAME="sec:LimitProfiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">3</SPAN> Limit the Set of Profiled PETs
</H3>

<P>
By default, all PETs in an application are profiled. It may be desirable
to only profile a subset of PETs to reduce the amount of output.
An explicit list of PETs can be specified by setting the
<TT>ESMF_RUNTIME_PROFILE_PETLIST</TT> environment variable.
The syntax of this environment variable is to list
PET numbers separated by spaces. PET ranges are also supported using
the &ldquo;X-Y&rdquo; syntax where X &lt; Y.
For example:

<P>
<PRE>
# only profile PETs 0, 20, and 35 through 39
$ setenv ESMF_RUNTIME_PROFILE_PETLIST "0 20 35-39"
</PRE>

<P>
When used in conjunction with the <TT>SUMMARY</TT> option above, the summarized
profile will only aggregate over the specified set of PETs. The one exception is that
PET 0 is always profiled if <TT>ESMF_RUNTIME_PROFILE=ON</TT>, regardless of the
<TT>ESMF_RUNTIME_TRACE_PETLIST</TT> setting.

<P>

<H3><A NAME="SECTION060142400000000000000"></A>
<A NAME="sec:MPIProfiling"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">4</SPAN> Include MPI Communication in the Profile
</H3>

<P>
MPI functions can be included in the timing profile to indicate how much time
is spent inside communication calls.  This can also help to determine load imbalance
in the system, since large times spent inside MPI may indicate that communication
between PETs is not tightly synchronized.  This option includes <EM>all</EM> MPI calls in
the application, whether or not they originate from the ESMF library.  Here is a partial
example summary profile that contains MPI times:

<P>
<PRE>
Region                           PETs   Count    Mean (s)    Min (s)     Min PET Max (s)     Max PET
  [esm] RunPhase1                8      1        4.9307      4.6867      0       4.9656      1
    [OCN] RunPhase1              8      1824     0.8344      0.8164      0       0.8652      1
    [MED] RunPhase1              8      1824     0.8203      0.7900      5       0.8584      1
    [ATM] RunPhase1              8      1824     0.6387      0.6212      5       0.6610      1
    [ATM-TO-MED] RunPhase1       8      1824     0.5975      0.5317      0       0.6583      5
      MPI_Bcast                  8      1824     0.0443      0.0025      4       0.1231      5
      MPI_Wait                   8      MULTIPLE 0.0421      0.0032      0       0.0998      2
    [MED-TO-OCN] RunPhase1       8      1824     0.4879      0.4497      0       0.5362      4
      MPI_Wait                   8      MULTIPLE 0.0234      0.0030      0       0.0821      4
      MPI_Bcast                  8      1824     0.0111      0.0024      4       0.0273      5
    [OCN-TO-MED] RunPhase1       8      1824     0.4541      0.4075      0       0.4918      4
      MPI_Wait                   8      MULTIPLE 0.0339      0.0017      0       0.0824      4
      MPI_Bcast                  8      1824     0.0194      0.0026      4       0.0452      6
    [MED-TO-ATM] RunPhase1       8      1824     0.4487      0.4005      0       0.4911      5
      MPI_Bcast                  8      1824     0.0338      0.0026      4       0.0942      5
      MPI_Wait                   8      MULTIPLE 0.0241      0.0022      1       0.0817      2
  [esm] Init 1                   8      1        0.6287      0.6287      1       0.6287      4
    [ATM-TO-MED] IPDv05p6b       8      1        0.1501      0.1500      1       0.1501      2
      MPI_Barrier                8      242      0.0082      0.0006      3       0.0157      7
      MPI_Wait                   8      MULTIPLE 0.0034      0.0010      0       0.0053      7
      MPI_Allreduce              8      62       0.0030      0.0003      3       0.0063      7
      MPI_Alltoall               8      6        0.0015      0.0000      1       0.0022      5
      MPI_Allgather              8      21       0.0010      0.0002      1       0.0017      7
      MPI_Waitall                8      MULTIPLE 0.0006      0.0001      3       0.0015      7
      MPI_Send                   8      MULTIPLE 0.0004      0.0001      7       0.0008      6
      MPI_Allgatherv             8      6        0.0001      0.0001      4       0.0001      0
      MPI_Scatter                8      5        0.0000      0.0000      0       0.0000      7
      MPI_Reduce                 8      5        0.0000      0.0000      1       0.0000      0
      MPI_Recv                   8      MULTIPLE 0.0000      0.0000      0       0.0000      3
      MPI_Bcast                  8      1        0.0000      0.0000      0       0.0000      7
</PRE>

<P>
The procedure for including MPI
functions in the timing profile depends on whether the application is
dynamically or statically linked. Most applications are dynamically linked,
however on some systems (such as Cray), static linking may be used.
Note that for either option, ESMF must be built with <TT>ESMF_TRACE_LIB_BUILD=ON</TT>,
which is the default.

<P>
In <EM>dynamically linked applications</EM>, the <TT>LD_PRELOAD</TT> (Linux) or
<TT>DYLD_INSERT_LIBRARIES</TT> (Darwin) environment variable must be used when
executing the MPI application.  This instructs the dynamic loader to interpose
certain MPI symbols so they can be captured by the ESMF profiler.  To simplify
this process, a script is provided at <TT>$(ESMF_INSTALL_LIBDIR)/preload.sh</TT>
that sets the appropriate variable.

<P>
For example, if you typically execute your application as as follows:

<P>
<PRE>
$ mpirun -np 8 ./myApp
</PRE>

<P>
then you should add the <EM>preload.sh</EM> script in front of the
executable when starting the application as follows:

<P>
<PRE>
# replace $(ESMF_INSTALL_LIBDIR) with absolute path
# ... to the ESMF installation lib directory
$ mpirun -np 8 $(ESMF_INSTALL_LIBDIR)/preload.sh ./myApp
</PRE>

<P>
An advantage of this approach is that your application does <EM>not</EM> need to
be recompiled. The MPI timing information will be included in the per-PET profiles and/or the summary
profile, depending on the setting of environment variable
<TT>ESMF_RUNTIME_PROFILE_OUTPUT</TT>.

<P>
Notice that an additional step is required for dynamically linked applications
on <EM>Darwin</EM> systems with System Integrity Protection (SIP) enabled! In
addition to using the <TT>$(ESMF_INSTALL_LIBDIR)/preload.sh</TT> script during
launching of the executable as shown above, the executable must <EM>also be
linked</EM> against the dynamic ESMF trace preload library. This must happen during
the link step of the executable. It is most easily accomplished by using
variable <TT>$(ESMF_F90ESMFPRELOADLINKLIBS)</TT> instead of the typical
<TT>$(ESMF_F90ESMFLINKLIBS)</TT> variable for the final link command. Both
variables are defined in the <EM>esmf.mk</EM> file that should be imported by
the application Makefile. For example:

<P>
<PRE>
# import esmf.mk
include $(ESMFMKFILE)

# other makefile targets here...

# example final link command, with $(ESMF_F90ESMFPRELOADLINKLIBS)
myApp: myApp.o driver.o model.o
        $(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) \
        $(ESMF_F90LINKRPATHS) -o $@ $^ $(ESMF_F90ESMFPRELOADLINKLIBS)
</PRE>

<P>
In <EM>statically linked applications</EM>, the application must be re-linked
with specific options provided to the linker.  These options instruct the linker
to wrap the MPI symbols with the ESMF profiling functions. The linking flags that
must be provided are included in the <EM>esmf.mk</EM> Makefile fragment that
is part of the ESMF installation. These link flags should be imported into
your application Makefile, and included in the final link command. To do this,
first import the <EM>esmf.mk</EM> file into your application Makefile. The path
to this file is typically stored in the <TT>ESMFMKFILE</TT> environment variable.
Then, pass the variables <TT>$(ESMF_TRACE_STATICLINKOPTS)</TT> and
<TT>$(ESMF_TRACE_STATICLINKLIBS)</TT> to the final linking command.  For example:

<P>
<PRE>
# import esmf.mk
include $(ESMFMKFILE)

# other makefile targets here...

# example final link command, with $(ESMF_TRACE_STATICLINKOPTS)
# ... and $(ESMF_TRACE_STATICLINKLIBS) added
myApp: myApp.o driver.o model.o
        $(ESMF_F90LINKER) $(ESMF_F90LINKOPTS) $(ESMF_F90LINKPATHS) \
        $(ESMF_F90LINKRPATHS) -o $@ $^ $(ESMF_F90ESMFLINKLIBS) \
        $(ESMF_TRACE_STATICLINKOPTS) $(ESMF_TRACE_STATICLINKLIBS)
</PRE>

<P>
This option will statically wrap all of the MPI functions and include them
in the profile output.  Execute the application in the normal way
with the environment variable <TT>ESMF_RUNTIME_PROFILE</TT> set to <TT>ON</TT>.
You will see the MPI functions included in the timing profile.

<P>

<H3><A NAME="SECTION060142500000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">5</SPAN> Output a Detailed Trace for Analysis</A>
</H3>

<P>
ESMF tracing is disabled by default. To enable tracing, set the
<TT>ESMF_RUNTIME_TRACE</TT> environment variable to <TT>ON</TT>. You
do not need to recompile your code to enable tracing.

<P>
<PRE>
# csh shell
$ setenv ESMF_RUNTIME_TRACE ON

# bash shell
$ export ESMF_RUNTIME_TRACE=ON
</PRE>

<P>
When enabled, the default behavior is to trace all PETs of the
ESMF application. Although the ESMF tracer is designed to write
events in a compact form, tracing can produce an extremely
large number of events depending on the total number of PETs and
the length of the run. To reduce output, it is possible to restrict
the PETs that produce trace output by setting the <TT>ESMF_RUNTIME_TRACE_PETLIST</TT>
environment variable. For example, this setting:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_PETLIST "0 101 192-196"
</PRE>

<P>
will instruct the tracer to only trace PETs 0, 101, and 192 through 196
(inclusive). The syntax of this environment variable is to list
PET numbers separated by spaces. PET ranges are also supported using
the &ldquo;X-Y&rdquo; syntax where X &lt; Y. For PET counts greater than 100, it is
recommended to set this environment variable. The one exception is that
PET 0 is always traced, regardless of the <TT>ESMF_RUNTIME_TRACE_PETLIST</TT>
setting.

<P>
ESMF's profiling and tracing options can be used together.  A typical
use would be to set <TT>ESMF_RUNTIME_PROFILE=ON</TT> for all PETs to
capture summary timings, and set <TT>ESMF_RUNTIME_TRACE=ON</TT> and
<TT>ESMF_RUNTIME_TRACE_PETLIST</TT> to a subset of of PETs,
such as the root PET of each ESMF component. This helps to keep trace
sizes small while still providing timing summaries over all PETs.

<P>
When tracing is enabled, <TT>phase_enter</TT> and <TT>phase_exit</TT> events will
automatically be recorded for all initialize, run, and finalize phases of all
Components in the application. To trace <EM>only</EM> user-instrumented regions (via
the <TT>ESMF_TraceRegionEnter()</TT> and <TT>ESMF_TraceRegionExit()</TT> calls),
Component-level tracing can be turned off by setting:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_COMPONENT OFF
</PRE>

<P>
After running an ESMF application with tracing enabled, a directory
called <EM>traceout</EM> will be created in the run directory and it will
contain a <EM>metadata</EM> file and an event stream file <EM>esmf_stream_XXXX</EM>
for each PET with tracing enabled. Together these files form a valid
CTF trace which may be analyzed with any of the tools listed above.

<P>
Trace events are flushed to file at a regular interval. If the application
crashes, some of the most recent events may not be flushed to file. To
maximize the number of events appearing in the trace, an option is available
to flush events to file more frequently. Because this option may have
negative performance implications due to increased file I/O, it is not
recommended unless needed. To turn on eager flushing use:

<P>
<PRE>
$ setenv ESMF_RUNTIME_TRACE_FLUSH EAGER
</PRE>

<P>

<H3><A NAME="SECTION060142600000000000000"></A>
<A NAME="sec:TracingClocks"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">6</SPAN> Set the Clock used for Profiling/Tracing
</H3>

<P>
There are three options for the kind of clock to use to timestamp
events when profiling/tracing an application.
These options are controlled by setting the environment variable
<TT>ESMF_RUNTIME_TRACE_CLOCK</TT>.
<table width="90%"><tr><td align="right" valign="top"><TT>REALTIME</TT></td><td valign="top">&nbsp;The <TT>REALTIME</TT> clock timestamps events with the current time on
      the system.  This is the default clock if the above environment
      variable is not set.  This setting can be useful when tracing PETs that
      span multiple physical computing nodes assuming that the system clocks
      on each node are adequately synchronized.  On most HPC systems, system
      clocks are periodically updated to stay in sync.  A disadvantage of this
      clock is that periodic adjustments mean the clock is not monotonically
      increasing so some timings may be inaccurate if the system clock jumps
      forward or backward significantly. Testing has shown that this is not
      typically an issue on most systems.</td></tr>
<tr><td align="right" valign="top"><TT>MONOTONIC</TT></td><td valign="top">&nbsp;The <TT>MONOTONIC</TT> clock is guaranteed to be monotonically increasing
      and does not suffer from periodic adjustments.  The timestamps represent
      an amount of time since some arbitrary point in the past.  There is no
      guarantee that these timestamps will be synchronized across physical
      computing nodes, so this option should only be used for tracing a set of PETs
      running on a single physical machine.</td></tr>
<tr><td align="right" valign="top"><TT>MONOTONIC_SYNC</TT></td><td valign="top">&nbsp;The <TT>MONOTONIC_SYNC</TT> clock is similar to the <TT>MONOTONIC</TT> clock
      in that it is guaranteed to be monotonically increasing. In addition, at
      application startup, all PET clocks are synchronized to a common time
      by determining a PET-local offset to be applied to timestamps. Therefore this option
      can be used to compare trace streams across physical nodes.
</td></tr></table>


<P>

<P>

<P>

<H3><A NAME="SECTION060142700000000000000"></A> <A NAME="ex:TraceEx"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">7</SPAN> Tracing a simple ESMF application
</H3>

<P>
This example illustrates how to trace a simple ESMF
   application and print the event stream using Babeltrace.
   The first part of the code is a module representing
   a trivial ESMF Gridded Component.  The second part is a
   main program that creates and executes the component.
<P>
<PRE>
module SimpleComp

  use ESMF
  implicit none

  private
  public SetServices

contains

  subroutine SetServices(gcomp, rc)
      type(ESMF_GridComp)   :: gcomp
      integer, intent(out)  :: rc  

      call ESMF_GridCompSetEntryPoint(gcomp, ESMF_METHOD_INITIALIZE, &amp;
           userRoutine=Init, rc=rc)
      call ESMF_GridCompSetEntryPoint(gcomp, ESMF_METHOD_RUN, &amp;
           userRoutine=Run, rc=rc)
      call ESMF_GridCompSetEntryPoint(gcomp, ESMF_METHOD_FINALIZE, &amp;
           userRoutine=Finalize, rc=rc)
      
      rc = ESMF_SUCCESS
      
    end subroutine SetServices

    subroutine Init(gcomp, istate, estate, clock, rc)
      type(ESMF_GridComp):: gcomp
      type(ESMF_State):: istate, estate
      type(ESMF_Clock):: clock
      integer, intent(out):: rc
      
      print *, "Inside Init"
      
    end subroutine Init

    subroutine Run(gcomp, istate, estate, clock, rc)
      type(ESMF_GridComp):: gcomp
      type(ESMF_State):: istate, estate
      type(ESMF_Clock):: clock
      integer, intent(out):: rc
      
      print *, "Inside Run"
      
    end subroutine Run

    subroutine Finalize(gcomp, istate, estate, clock, rc)
      type(ESMF_GridComp):: gcomp
      type(ESMF_State):: istate, estate
      type(ESMF_Clock):: clock
      integer, intent(out):: rc
      
    print *, "Inside Finalize"
    
  end subroutine Finalize 

end module SimpleComp
</PRE>

<P>
<PRE>
program ESMF_TraceEx
</PRE>

<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
      use SimpleComp, only: SetServices
</PRE>

<P>
<PRE>
      implicit none

      ! Local variables  
      integer :: rc, finalrc, i
      type(ESMF_GridComp)     :: gridcomp
</PRE>

<P>
<PRE>
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, defaultlogfilename="TraceEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! create the component and then execute
      ! initialize, run, and finalize routines
      gridcomp = ESMF_GridCompCreate(name="test", rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompSetServices(gridcomp, userRoutine=SetServices, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompInitialize(gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      do i=1, 5
         call ESMF_GridCompRun(gridcomp, rc=rc)
      enddo
</PRE>

<P>
<PRE>
      call ESMF_GridCompFinalize(gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompDestroy(gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program ESMF_TraceEx
</PRE>

<P>
Assuming the code above is executed on four PETs with
   the environment variable <TT>ESMF_RUNTIME_TRACE</TT> set to
   <TT>ON</TT>, then a folder will be created in the run directory
   called <EM>traceout</EM> containing a <EM>metadata</EM> file and
   four event stream files named <EM>esmf_stream_XXXX</EM>
   where <EM>XXXX</EM> is the PET number.  If Babeltrace is
   available on the system, the list of events can be printed
   by executing the following from the run directory:
   <PRE>
   $ babeltrace ./traceout
</PRE>
   For details about iterating over trace events and performing
   analyses on CTF traces, see the corresponding documentation
   in the tools listed in Section <A HREF="#sec:Tracing">52.1.2</A>.


<P>

<P>

<P>

<H3><A NAME="SECTION060142800000000000000"></A> <A NAME="ex:TraceUserEx"></A>
<BR>
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">8</SPAN> Profiling/Tracing User-defined Code Regions
</H3>

<P>
This example illustrates how to manually instrument code with
   entry and exit points for user-defined code regions. Note that the
   API calls <TT>ESMF_TraceRegionEnter</TT> and <TT>ESMF_TraceRegionExit</TT>
   should always appear in pairs, wrapping a particular section
   of code. The environment variable <TT>ESMF_RUNTIME_TRACE</TT> 
   or <TT>ESMF_RUNTIME_PROFILE</TT> must be set to <TT>ON</TT> to enable these
   regions. If not at least one is set, the calls to
   <TT>ESMF_TraceRegionEnter</TT> and <TT>ESMF_TraceRegionExit</TT>
   will simply return immediately. For this reason, it is safe to
   leave this instrumentation in application code, even when not being profiled.  
<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
</PRE>

<P>
<PRE>
      implicit none

      ! Local variables  
      integer :: rc, finalrc
      integer :: i, j, tmp
</PRE>

<P>
<PRE>
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, defaultlogfilename="TraceUserEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! record entrance into "outer_region"
      call ESMF_TraceRegionEnter("outer_region", rc=rc)

      tmp = 0
      do i=1, 10
         
         ! record entrance into "inner_region_1"
         call ESMF_TraceRegionEnter("inner_region_1", rc=rc)
         ! arbitrary computation
         do j=1,10000
            tmp=tmp+j+i
         enddo
         ! record exit from "inner_region_1"
         call ESMF_TraceRegionExit("inner_region_1", rc=rc)

         tmp = 0
         
         ! record entrance into "inner_region_2"
         call ESMF_TraceRegionEnter("inner_region_2", rc=rc)
         ! arbitrary computation
         do j=1,5000
            tmp=tmp+j+i
         enddo
         ! record exit from "inner_region_2"
         call ESMF_TraceRegionExit("inner_region_2", rc=rc)
      enddo

      ! record exit from "outer_region"
      call ESMF_TraceRegionExit("outer_region", rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_Finalize(rc=rc)
</PRE>

<P>


<H2><A NAME="SECTION060143000000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">3</SPAN> Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limited types of trace events.</B>
  Currently only a few trace event types are available. The tracer may
  be extended in the future to record additional types of events.
</LI>
<LI><B>MPI call profing not available for statically linked executables on Darwin.</B>
  Currently the linker on Darwin systems does not support the wrapping of
  symbols during static linking. In order to access MPI call profiling on Darwin,
  executables should be linked dynamically in combination with the procedure
  described in section <A HREF="#sec:MPIProfiling">52.2.4</A>.
</LI>
</OL>

<P>

<H2><A NAME="SECTION060144000000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">4</SPAN> Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060144100000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_TraceRegionEnter - Trace user-defined region entry event</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_TraceRegionEnter(name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in) :: name
     integer, intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Record an event in the trace for this PET indicating entry
     into a user-defined region with the given name.  This call
     must be paired with a call to <TT>ESMF_TraceRegionExit()</TT>
     with a matching <TT>name</TT> parameter.  User-defined regions may be
     nested.
     If tracing is disabled on the calling PET or for the application
     as a whole, no event will be recorded and
     the call will return immediately.

<P>
The arguments are:
   <DL>
<DT><STRONG>name</STRONG></DT>
<DD>A user-defined name for the region of code being entered
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>     

<P>

<P>

<H3><A NAME="SECTION060144200000000000000">
<SPAN CLASS="arabic">52</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_TraceRegionExit - Trace user-defined region exit event</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_TraceRegionExit(name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in) :: name
     integer, intent(out), optional  :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Record an event in the trace for this PET indicating exit
     from a user-defined region with the given name.  This call
     must appear after a call to <TT>ESMF_TraceRegionEnter()</TT>
     with a matching <TT>name</TT> parameter.
     If tracing is disabled on the calling PET or for the application
     as a whole, no event will be recorded and
     the call will return immediately.

<P>
The arguments are:
   <DL>
<DT><STRONG>name</STRONG></DT>
<DD>A user-defined name for the region of code being exited
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>


<H1><A NAME="SECTION060150000000000000000">
<SPAN CLASS="arabic">53</SPAN> Fortran I/O and System Utilities</A>
</H1>

<H2><A NAME="SECTION060151000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">1</SPAN> Description</A>
</H2>

<P>
<A NAME="sec:IOUtil"></A>
<P>
The ESMF Fortran I/O and System utilities provide portable methods to
access capabilities which are often implemented in different
ways amongst different environments.  These utility methods are
divided into three groups: command line access, Fortran I/O, and
sorting.

<P>
Command line arguments may be accessed using three methods:
<TT>ESMF_UtilGetArg()</TT> returns a given command line argument,
<TT>ESMF_UtilGetArgC()</TT> returns a count of the number of command line
arguments available.  Finally, the <TT>ESMF_UtilGetArgIndex()</TT> method
returns the index of a desired argument value, given its keyword name.

<P>
Two I/O methods are implemented: <TT>ESMF_IOUnitGet()</TT>,
to obtain an unopened Fortran unit number within the range of unit numbers that
ESMF is allowed to use, and <TT>ESMF_IOUnitFlush()</TT> to flush the
I/O buffer associated with a specific Fortran unit.

<P>
Finally, the <TT>ESMF_UtilSort()</TT> method sorts integer, floating point,
and character string data types in either ascending or descending order.


<H2><A NAME="SECTION060152000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN> Use and Examples</A>
</H2>

<P>

<H3><A NAME="SECTION060152100000000000000"></A> <A NAME="fio:unitnumbers"></A>
<BR>
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Fortran unit number management
</H3>
The <TT>ESMF_UtilIOUnitGet()</TT> method is provided so that applications
using ESMF can remain free of unit number conflicts -- both when combined
with other third party code, or with ESMF itself.  This call is typically
used just prior to an <TT>OPEN</TT> statement:

<P>
<PRE>
  call ESMF_UtilIOUnitGet (unit=grid_unit, rc=rc)
  open (unit=grid_unit, file='grid_data.dat', status='old', action='read')
</PRE>

<P>
By default, unit numbers between 50 and 99 are scanned to find an unopened
unit number.

<P>
Internally, ESMF also uses <TT>ESMF_UtilIOUnitGet()</TT> when it needs to open
Fortran unit numbers for file I/O.  By using the same API for both user and
ESMF code, unit number collisions can be avoided.

<P>
When integrating ESMF into an application where there are conflicts with
other uses of the same unit number range, such as when hard-coded unit number
values are used, an alternative unit number range can be specified.
The <TT>ESMF_Initialize()</TT> optional arguments <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT>
may be set as needed.  Note that <TT>IOUnitUpper</TT> must be set to a value higher than
<TT>IOUnitLower</TT>, and that both must be non-negative.  Otherwise <TT>ESMF_Initialize</TT>
will return a return code of <TT>ESMF_FAILURE</TT>.  ESMF itself does not typically need more
than about five units for internal use.

<P>
<PRE>
  call ESMF_Initialize (..., IOUnitLower=120, IOUnitUpper=140)
</PRE>

<P>
All current Fortran environments have preconnected unit numbers, such as
units 5 and 6 for standard input and output, in the single digit range.
So it is recommended that the unit number range is chosen to begin at unit 10
or higher to avoid these preconnected units.

<P>

<H3><A NAME="SECTION060152200000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Flushing output</A>
</H3>

<P>
Fortran run-time libraries generally use buffering techniques to improve I/O
performance.  However output buffering can be problematic when output is needed,
but is &ldquo;trapped&rdquo; in the buffer because it is not full.
This is a common occurrance when debugging a program, and inserting <TT>WRITE</TT> statements
to track down the bad area of code.  If the program crashes before the output
buffer has been flushed, the desired debugging output may never be seen -- giving
a misleading indication of where the problem occurred.  It would be desirable
to ensure that the output buffer is flushed at predictable
points in the program in order to get the needed results.
Likewise, in parallel code, predictable flushing of output buffers is a common
requirement, often in conjunction with <TT>ESMF_VMBarrier()</TT> calls.  

<P>
The <TT>ESMF_UtilIOUnitFlush()</TT> API is provided to flush a unit as desired.  Here is
an example of code which prints debug values, and serializes the output to a
terminal in PET order:

<P>
<PRE>
  type(ESMF_VM) :: vm

  integer :: tty_unit
  integer :: me, npets

  call ESMF_Initialize (vm=vm, rc=rc)
  call ESMF_VMGet (vm, localPet=me, petCount=npes)

  call ESMF_UtilIOUnitGet (unit=tty_unit)
  open (unit=tty_unit, file='/dev/tty', status='old', action='write')
  ...
  call ESMF_VMBarrier (vm=vm)
  do, i=0, npets-1
    if (i == me) then
      write (tty_unit, *) 'PET: ', i, ', values are: ', a, b, c
      call ESMF_UtilIOUnitFlush (unit=tty_unit)
    end if
    call ESMF_VMBarrier (vm=vm)
  end do
</PRE>

<H2><A NAME="SECTION060153000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN> Design and Implementation Notes</A>
</H2>

<P>

<H3><A NAME="SECTION060153100000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> Fortran unit number management</A>
</H3>

<P>
When ESMF needs to open a Fortran I/O unit, it calls <TT>ESMF_IOUnitGet()</TT> to find
an unopened unit number.  As delivered, the range of unit numbers that are
searched are between <TT>ESMF_LOG_FORTRAN_UNIT_NUMBER</TT> (normally set to
50), and <TT>ESMF_LOG_UPPER</TT> (normally set to 99.)
Unopened unit numbers are found by using the Fortran <TT>INQUIRE</TT> statement.

<P>
When integrating ESMF into an application where there are conflicts with
other uses of the same unit number range, an alternative range can be specified
in the <TT>ESMF_Initialize()</TT> call by setting the <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT>
arguments as needed.  <TT>ESMF_IOUnitGet()</TT> will then search the alternate range
of unit numbers.  Note that <TT>IOUnitUpper</TT> must be set to a value higher than
<TT>IOUnitLower</TT>, and that both must be non-negative.  Otherwise <TT>ESMF_Initialize</TT>
will return a return code of <TT>ESMF_FAILURE</TT>.

<P>
Fortran unit numbers are not standardized in the Fortran 90 Standard.  The standard
only requires that they be non-negative integers.  But other than that, it is
up to the compiler writers and application developers to provide and
use units which work with the particular implementation.  For example,
units 5 and 6 are a defacto standard for &ldquo;standard input&rdquo; and
&ldquo;standard output&rdquo; -- even though this is not specified in the actual Fortran
standard.  The Fortran standard also does not specify which unit numbers can
be used, nor does it specify how many can be open simultaneously.

<P>
Since all current compilers have preconnected unit numbers, and these are
typically found on units lower than 10, it is recommended that applications
use unit numbers 10 and higher.

<P>

<H3><A NAME="SECTION060153200000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Flushing output</A>
</H3>

<P>
When ESMF needs to flush a Fortran unit, the <TT>ESMF_IOUnitFlush()</TT> API is used
to centralize the file flushing capability, because Fortran has not historically
had a standard mechanism for flushing output buffers.  Most compilers run-time libraries
support various library extensions to provide this functionality -- though,
being non-standard, the spelling and number of arguments vary between implementations.
Fortran 2003 also provides for a <TT>FLUSH</TT> statement which is built into the
language.  When possible, <TT>ESMF_IOUnitFlush()</TT> uses the F2003 <TT>FLUSH</TT> statement.
With older compilers, the appropriate library call is made.

<P>

<H3><A NAME="SECTION060153300000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">3</SPAN> Sorting algorithms</A>
</H3>

<P>
The <TT>ESMF_UtilSort()</TT> algorithms are the same as those in the <TT>LAPACK</TT>
sorting procedures <TT>SLASRT()</TT> and <TT>DLASRT()</TT>.  Two algorithms are used.
For small sorts, arrays with 20 or fewer elements, a simple Insertion sort is
used.  For larger sorts, a Quicksort algorithm is used.

<P>
Compared to the original <TT>LAPACK</TT> code, a full Fortran 90 style
interface is supported for ease of use and enhanced compile time checking.
Additional support is also provided for integer and character string data
types.

<H2><A NAME="SECTION060154000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN> Utility API</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060154100000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> ESMF_UtilGetArg - Return a command line argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArg(argindex, argvalue, arglength, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,      intent(in)            :: argindex
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*), intent(out), optional :: argvalue
     integer,      intent(out), optional :: arglength
     integer,      intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method returns a copy of a command line argument specified
   when the process was started.  This argument is the same as an
   equivalent C++ program would find in the argv array.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>argindex</STRONG></DT>
<DD>A non-negative index into the command line argument <TT>argv</TT> array.
   If argindex is negative or greater than the number of user-specified
   arguments, <TT>ESMF_RC_ARG_VALUE</TT> is returned in the <TT>rc</TT> argument.
   
</DD>
<DT><STRONG>[argvalue]</STRONG></DT>
<DD>Returns a copy of the desired command line argument.  If the provided
   character string is longer than the command line argument, the string
   will be blank padded.  If the string is too short, truncation will
   occur and <TT>ESMF_RC_ARG_SIZE</TT> is returned in the <TT>rc</TT> argument.
   
</DD>
<DT><STRONG>[arglength]</STRONG></DT>
<DD>Returns the length of the desired command line argument in characters.
   The length result does not depend on the length of the <TT>value</TT>
   string.  It may be used to query the length of the argument.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060154200000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">2</SPAN> ESMF_UtilGetArgC - Return number of command line arguments</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArgC(count, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(out)           :: count
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method returns the number of command line arguments specified
   when the process was started.

<P>
The number of arguments returned does not include the name of the
   command itself - which is typically returned as argument zero.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>count</STRONG></DT>
<DD>Count of command line arguments.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060154300000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">3</SPAN> ESMF_UtilGetArgIndex - Return the index of a command line argument</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArgIndex(argvalue, argindex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*), intent(in)            :: argvalue
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,      intent(out), optional :: argindex
     integer,      intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
This method searches for, and returns the index of a desired command
   line argument.  An example might be to find a specific keyword
   (e.g., -esmf_path) so that its associated value argument could be
   obtained by adding 1 to the argindex and calling <TT>ESMF_UtilGetArg()</TT>.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>argvalue</STRONG></DT>
<DD>A character string which will be searched for in the command line
   argument list.
   
</DD>
<DT><STRONG>[argindex]</STRONG></DT>
<DD>If the <TT>value</TT> string is found, the position will be returned
   as a non-negative integer.  If the string is not found, a negative
   value will be returned.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060154400000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">4</SPAN> ESMF_UtilIOGetCWD - Get the current directory</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_UtilIOGetCWD (pathName, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>     character(*), intent(out)           :: pathName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to get the current directory from the file
     system.

<P>
The arguments are:
       <DL>
<DT><STRONG>pathName</STRONG></DT>
<DD>Name of the current working directory.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060154500000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">5</SPAN> ESMF_UtilIOMkDir - Create a directory in the file system</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_UtilIOMkDir (pathName,  &amp;
        mode, relaxedFlag,  &amp;
        rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>      character(*), intent(in)            :: pathName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,      intent(in),  optional :: mode
      logical,      intent(in),  optional :: relaxedFlag
      integer,      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to create a directory in the file system.

<P>
The arguments are:
       <DL>
<DT><STRONG>pathName</STRONG></DT>
<DD>Name of the directory to be created.
       
</DD>
<DT><STRONG>[mode]</STRONG></DT>
<DD>File permission mode.  Typically an octal constant is used as a value, for example:
         <TT>mode=o'755'</TT>.  If not specified on POSIX-compliant systems, the default
         is <TT>o'755'</TT> - corresponding to owner read/write/execute,
         group read/execute, and world read/execute.  On native Windows, this argument is
         ignored and default security settings are used.
       
</DD>
<DT><STRONG>[relaxedFlag]</STRONG></DT>
<DD>When set to <TT>.true.</TT>, if the directory already exists, <TT>rc</TT>
         will be set to <TT>ESMF_SUCCESS</TT> instead of an error.
         If not specified, the default is <TT>.false.</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060154600000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">6</SPAN> ESMF_UtilIORmDir - Remove a directory from the file system</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>    subroutine ESMF_UtilIORmDir (pathName,  &amp;
        relaxedFlag, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>      character(*), intent(in)            :: pathName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      logical,      intent(in),  optional :: relaxedFlag
      integer,      intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to remove a directory from the file
     system.  Note that the directory must be empty in order to be successfully
     removed.

<P>
The arguments are:
       <DL>
<DT><STRONG>pathName</STRONG></DT>
<DD>Name of the directory to be removed.
       
</DD>
<DT><STRONG>[relaxedFlag]</STRONG></DT>
<DD>If set to <TT>.true.</TT>, and if the specified directory does not exist,
         the error is ignored and <TT>rc</TT> will be set to <TT>ESMF_SUCCESS</TT>.
         If not specified, the default is <TT>.false.</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060154700000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">7</SPAN> ESMF_UtilString2Double - Convert a string to floating point real</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_UtilString2Double(string, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     real(ESMF_KIND_R8) :: ESMF_UtilString2Double
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in)            :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the numerical real value represented by the <TT>string</TT>.

<P>
Leading and trailing blanks in <TT>string</TT> are ignored when directly
     converting into integers.

<P>
This procedure may fail when used in an expression in a <TT>write</TT> statement
     with some older, pre-Fortran 2003, compiler environments that do not support
     re-entrant I/O calls.

<P>
The arguments are:
     <DL>
<DT><STRONG>string</STRONG></DT>
<DD>The string to be converted
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060154800000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">8</SPAN> ESMF_UtilString2Int - Convert a string to an integer</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_UtilString2Int(string,  &amp;
       specialStringList, specialValueList, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     integer :: ESMF_UtilString2Int
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in)            :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*), intent(in),  optional :: specialStringList(:)
     integer,          intent(in),  optional :: specialValueList(:)
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the numerical integer value represented by the <TT>string</TT>.
     If <TT>string</TT> matches a string in the optional <TT>specialStringList</TT>, the
     corresponding special value will be returned instead.

<P>
If special strings are to be taken into account, both 
     <TT>specialStringList</TT> and <TT>specialValueList</TT> arguments must be
     present and of same size.

<P>
An error is returned, and return value set to 0, if <TT>string</TT> is not
     found in <TT>specialStringList</TT>, and does not convert into an integer
     value.

<P>
Leading and trailing blanks in <TT>string</TT> are ignored when directly
     converting into integers.

<P>
This procedure may fail when used in an expression in a <TT>write</TT> statement
     with some older, pre-Fortran 2003, compiler environments that do not support
     re-entrant I/O calls.

<P>
The arguments are:
     <DL>
<DT><STRONG>string</STRONG></DT>
<DD>The string to be converted
     
</DD>
<DT><STRONG>[specialStringList]</STRONG></DT>
<DD>List of special strings.
     
</DD>
<DT><STRONG>[specialValueList]</STRONG></DT>
<DD>List of values associated with special strings.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060154900000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">9</SPAN> ESMF_UtilString2Real - Convert a string to floating point real</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   function ESMF_UtilString2Real(string, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     real :: ESMF_UtilString2Real
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), intent(in)            :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Return the numerical real value represented by the <TT>string</TT>.

<P>
Leading and trailing blanks in <TT>string</TT> are ignored when directly
     converting into integers.

<P>
This procedure may fail when used in an expression in a <TT>write</TT> statement
     with some older, pre-Fortran 2003, compiler environments that do not support
     re-entrant I/O calls.

<P>
The arguments are:
     <DL>
<DT><STRONG>string</STRONG></DT>
<DD>The string to be converted
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601541000000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">10</SPAN> ESMF_UtilStringInt2String - convert integer to character string</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     function ESMF_UtilStringInt2String (i, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       integer, intent(in) :: i
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>       character(int2str_len (i)) :: ESMF_UtilStringInt2String
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Converts given an integer to string representation.  The returned string is
     sized such that it does not contain leading or trailing blanks.

<P>
This procedure may fail when used in an expression in a <TT>write</TT> statement
     with some older, pre-Fortran 2003, compiler environments that do not support
     re-entrant I/O calls.

<P>
The arguments are:
       <DL>
<DT><STRONG>i</STRONG></DT>
<DD>An integer.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601541100000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">11</SPAN> ESMF_UtilStringLowerCase - convert string to lowercase</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>     function ESMF_UtilStringLowerCase(string, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*), intent(in) :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>       character(len (string)) :: ESMF_UtilStringLowerCase
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Converts given string to lowercase.

<P>
The arguments are:
       <DL>
<DT><STRONG>string</STRONG></DT>
<DD>A character string.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601541200000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">12</SPAN> ESMF_UtilStringUpperCase - convert string to uppercase</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>       function ESMF_UtilStringUpperCase(string, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*), intent(in) :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional  :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>       character(len (string)) :: ESMF_UtilStringUpperCase
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Converts given string to uppercase.

<P>
The arguments are:
       <DL>
<DT><STRONG>string</STRONG></DT>
<DD>A character string.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>


<P>

<P>

<P>

<P>

<H3><A NAME="SECTION0601541300000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">13</SPAN> ESMF_UtilIOUnitFlush - Flush output on a unit number</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_UtilIOUnitFlush(unit, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>     integer, intent(in)            :: unit
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to force output on a specific
     Fortran unit number.

<P>
The arguments are:
       <DL>
<DT><STRONG>unit</STRONG></DT>
<DD>A Fortran I/O unit number.  If the unit is not connected to a file,
         no flushing occurs.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION0601541400000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">14</SPAN> ESMF_UtilIOUnitGet - Scan for a free I/O unit number</A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_UtilIOUnitGet(unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(out)           :: unit
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF starting with 5.2.0r, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Scan for, and return, a free Fortran I/O unit number.
     By default, the range of unit numbers returned is between 50 and 99
     (parameters <TT>ESMF_LOG_FORTRAN_UNIT_NUMBER</TT> and <TT>ESMF_LOG_UPPER</TT>
     respectively.) When integrating ESMF into an application where these values
     conflict with other usages, the range of values may be moved by setting the
     optional <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT> arguments in the initial
     <TT>ESMF_Initialize()</TT> call with values in a safe, alternate, range.

<P>
The Fortran unit number which is returned is not reserved in any way.
     Successive calls without intervening <TT>OPEN</TT> or <TT>CLOSE</TT> statements
     (or other means of connecting to units), might not return a unique unit
     number.  It is recommended that an <TT>OPEN</TT> statement immediately follow
     the call to <TT>ESMF_IOUnitGet()</TT> to activate the unit.

<P>
The arguments are:
       <DL>
<DT><STRONG>unit</STRONG></DT>
<DD>A Fortran I/O unit number.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>


<P>

<P>

<P>

<H3><A NAME="SECTION0601541500000000000000">
<SPAN CLASS="arabic">53</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">15</SPAN> ESMF_UtilSort - Sort data </A>
</H3>

<P>

<P><P>
<BR>
<I CLASS="sans">INTERFACE:</I>
<PRE>   subroutine ESMF_UtilSort (list, direction, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;list&gt;, see below for supported values 
   type(ESMF_SortFlag), intent(in) :: direction 
   integer, intent(out), optional :: rc
</PRE>
<I CLASS="sans">DESCRIPTION:
<BR></I>

<P>
Supported values for &lt;list&gt; are: 
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(inout) :: list(:) 
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(inout) :: list(:) 
   
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), intent(inout) :: list(:) 
   
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), intent(inout) :: list(:) 
   
</DD>
<DT></DT>
<DD>character(len=*), intent(inout) :: list(:) 
   
</DD>
</DL>

<P>
Use Quick Sort, reverting to Insertion sort on lists of 
   size &lt;= 20. 

<P>
This is an ESMFized version of SLASRT from LAPACK version 3.1. 
   Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd. 
   November 2006 

<P>
The arguments are: 
   <DL>
<DT><STRONG>list</STRONG></DT>
<DD>Array of data to be sorted. The original data is overwritten by the 
   sorted data. 
   
</DD>
<DT><STRONG>direction</STRONG></DT>
<DD>Direction of sorting. Legal values are <TT>ESMF_SORTFLAG_ASCENDING</TT> 
   and <TT>ESMF_SORTFLAG_DESCENDING</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the sorting is successful. 
   
</DD>
</DL> 

<P>


<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A NAME="tex2html2969"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2965"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2959"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2967"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2970"
  HREF="node7.html">6 References</A>
<B> Up:</B> <A NAME="tex2html2966"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html2960"
  HREF="node5.html">4 Infrastructure: Fields and</A>
 &nbsp; <B>  <A NAME="tex2html2968"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@ucar.edu>esmf_support@ucar.edu</A>
</ADDRESS>
</BODY>
</HTML>
