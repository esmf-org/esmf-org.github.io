<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>3 Superstructure</TITLE>
<META NAME="description" CONTENT="3 Superstructure">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html1603"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1599"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1593"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1601"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1604"
  HREF="node5.html">4 Infrastructure: Fields and</A>
<B> Up:</B> <A NAME="tex2html1600"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1594"
  HREF="node3.html">2 Applications</A>
 &nbsp <B>  <A NAME="tex2html1602"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html1605"
  HREF="node4.html#SECTION04010000000000000000">13 Overview of Superstructure</A>
<UL>
<LI><A NAME="tex2html1606"
  HREF="node4.html#SECTION04011000000000000000">13.1 Superstructure Classes</A>
<LI><A NAME="tex2html1607"
  HREF="node4.html#SECTION04012000000000000000">13.2 Hierarchical Creation of Components</A>
<LI><A NAME="tex2html1608"
  HREF="node4.html#SECTION04013000000000000000">13.3 Sequential and Concurrent Execution of Components</A>
<LI><A NAME="tex2html1609"
  HREF="node4.html#SECTION04014000000000000000">13.4 Intra-Component Communication</A>
<LI><A NAME="tex2html1610"
  HREF="node4.html#SECTION04015000000000000000">13.5 Data Distribution and Scoping in Components</A>
<LI><A NAME="tex2html1611"
  HREF="node4.html#SECTION04016000000000000000">13.6 Performance</A>
<LI><A NAME="tex2html1612"
  HREF="node4.html#SECTION04017000000000000000">13.7 Object Model</A>
</UL>
<LI><A NAME="tex2html1613"
  HREF="node4.html#SECTION04020000000000000000">14 Application Driver and Required ESMF Methods</A>
<UL>
<LI><A NAME="tex2html1614"
  HREF="node4.html#SECTION04021000000000000000">14.1 Description</A>
<LI><A NAME="tex2html1615"
  HREF="node4.html#SECTION04022000000000000000">14.2 Constants</A>
<UL>
<LI><A NAME="tex2html1616"
  HREF="node4.html#SECTION04022100000000000000">14.2.1 ESMF_END</A>
</UL>
<LI><A NAME="tex2html1617"
  HREF="node4.html#SECTION04023000000000000000">14.3 Use and Examples</A>
<LI><A NAME="tex2html1618"
  HREF="node4.html#SECTION04024000000000000000">14.4 Required ESMF Methods</A>
<UL>
<LI><A NAME="tex2html1619"
  HREF="node4.html#SECTION04024100000000000000">14.4.1 ESMF_Initialize</A>
<LI><A NAME="tex2html1620"
  HREF="node4.html#SECTION04024200000000000000">14.4.2 ESMF_Finalize</A>
<LI><A NAME="tex2html1621"
  HREF="node4.html#SECTION04024300000000000000">14.4.3 User-code <TT>SetServices</TT> method</A>
<LI><A NAME="tex2html1622"
  HREF="node4.html#SECTION04024400000000000000">14.4.4 User-code <TT>Initialize</TT>, <TT>Run</TT>, and <TT>Finalize</TT> methods</A>
<LI><A NAME="tex2html1623"
  HREF="node4.html#SECTION04024500000000000000">14.4.5 User-code <TT>SetVM</TT> method</A>
</UL>
</UL>
<LI><A NAME="tex2html1624"
  HREF="node4.html#SECTION04030000000000000000">15 GridComp Class</A>
<UL>
<LI><A NAME="tex2html1625"
  HREF="node4.html#SECTION04031000000000000000">15.1 Description</A>
<LI><A NAME="tex2html1626"
  HREF="node4.html#SECTION04032000000000000000">15.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1627"
  HREF="node4.html#SECTION04032100000000000000">15.2.1 Implement a user-code <TT>SetServices</TT> routine</A>
<LI><A NAME="tex2html1628"
  HREF="node4.html#SECTION04032200000000000000">15.2.2 Implement a user-code <TT>Initialize</TT> routine</A>
<LI><A NAME="tex2html1629"
  HREF="node4.html#SECTION04032300000000000000">15.2.3 Implement a user-code <TT>Run</TT> routine</A>
<LI><A NAME="tex2html1630"
  HREF="node4.html#SECTION04032400000000000000">15.2.4 Implement a user-code <TT>Finalize</TT> routine</A>
<LI><A NAME="tex2html1631"
  HREF="node4.html#SECTION04032500000000000000">15.2.5 Implement a user-code <TT>SetVM</TT> routine</A>
<LI><A NAME="tex2html1632"
  HREF="node4.html#SECTION04032600000000000000">15.2.6 Set and Get the Internal State</A>
</UL>
<LI><A NAME="tex2html1633"
  HREF="node4.html#SECTION04033000000000000000">15.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1634"
  HREF="node4.html#SECTION04034000000000000000">15.4 Class API</A>
<UL>
<LI><A NAME="tex2html1635"
  HREF="node4.html#SECTION04034100000000000000">15.4.1 ESMF_GridCompAssignment(=)</A>
<LI><A NAME="tex2html1636"
  HREF="node4.html#SECTION04034200000000000000">15.4.2 ESMF_GridCompOperator(==)</A>
<LI><A NAME="tex2html1637"
  HREF="node4.html#SECTION04034300000000000000">15.4.3 ESMF_GridCompOperator(/=)</A>
<LI><A NAME="tex2html1638"
  HREF="node4.html#SECTION04034400000000000000">15.4.4 ESMF_GridCompCreate</A>
<LI><A NAME="tex2html1639"
  HREF="node4.html#SECTION04034500000000000000">15.4.5 ESMF_GridCompDestroy</A>
<LI><A NAME="tex2html1640"
  HREF="node4.html#SECTION04034600000000000000">15.4.6 ESMF_GridCompFinalize</A>
<LI><A NAME="tex2html1641"
  HREF="node4.html#SECTION04034700000000000000">15.4.7 ESMF_GridCompGet</A>
<LI><A NAME="tex2html1642"
  HREF="node4.html#SECTION04034800000000000000">15.4.8 ESMF_GridCompGetInternalState</A>
<LI><A NAME="tex2html1643"
  HREF="node4.html#SECTION04034900000000000000">15.4.9 ESMF_GridCompInitialize</A>
<LI><A NAME="tex2html1644"
  HREF="node4.html#SECTION040341000000000000000">15.4.10 ESMF_GridCompIsPetLocal</A>
<LI><A NAME="tex2html1645"
  HREF="node4.html#SECTION040341100000000000000">15.4.11 ESMF_GridCompPrint</A>
<LI><A NAME="tex2html1646"
  HREF="node4.html#SECTION040341200000000000000">15.4.12 ESMF_GridCompReadRestart</A>
<LI><A NAME="tex2html1647"
  HREF="node4.html#SECTION040341300000000000000">15.4.13 ESMF_GridCompRun</A>
<LI><A NAME="tex2html1648"
  HREF="node4.html#SECTION040341400000000000000">15.4.14 ESMF_GridCompSet</A>
<LI><A NAME="tex2html1649"
  HREF="node4.html#SECTION040341500000000000000">15.4.15 ESMF_GridCompSetEntryPoint</A>
<LI><A NAME="tex2html1650"
  HREF="node4.html#SECTION040341600000000000000">15.4.16 ESMF_GridCompSetInternalState</A>
<LI><A NAME="tex2html1651"
  HREF="node4.html#SECTION040341700000000000000">15.4.17 ESMF_GridCompSetServices</A>
<LI><A NAME="tex2html1652"
  HREF="node4.html#SECTION040341800000000000000">15.4.18 ESMF_GridCompSetServices</A>
<LI><A NAME="tex2html1653"
  HREF="node4.html#SECTION040341900000000000000">15.4.19 ESMF_GridCompSetVM</A>
<LI><A NAME="tex2html1654"
  HREF="node4.html#SECTION040342000000000000000">15.4.20 ESMF_GridCompSetVM</A>
<LI><A NAME="tex2html1655"
  HREF="node4.html#SECTION040342100000000000000">15.4.21 ESMF_GridCompSetVMMaxPEs</A>
<LI><A NAME="tex2html1656"
  HREF="node4.html#SECTION040342200000000000000">15.4.22 ESMF_GridCompSetVMMaxThreads</A>
<LI><A NAME="tex2html1657"
  HREF="node4.html#SECTION040342300000000000000">15.4.23 ESMF_GridCompSetVMMinThreads</A>
<LI><A NAME="tex2html1658"
  HREF="node4.html#SECTION040342400000000000000">15.4.24 ESMF_GridCompValidate</A>
<LI><A NAME="tex2html1659"
  HREF="node4.html#SECTION040342500000000000000">15.4.25 ESMF_GridCompWait</A>
<LI><A NAME="tex2html1660"
  HREF="node4.html#SECTION040342600000000000000">15.4.26 ESMF_GridCompWriteRestart</A>
</UL>
</UL>
<LI><A NAME="tex2html1661"
  HREF="node4.html#SECTION04040000000000000000">16 CplComp Class</A>
<UL>
<LI><A NAME="tex2html1662"
  HREF="node4.html#SECTION04041000000000000000">16.1 Description</A>
<LI><A NAME="tex2html1663"
  HREF="node4.html#SECTION04042000000000000000">16.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1664"
  HREF="node4.html#SECTION04042100000000000000">16.2.1 Implement a user-code <TT>SetServices</TT> routine</A>
<LI><A NAME="tex2html1665"
  HREF="node4.html#SECTION04042200000000000000">16.2.2 Implement a user-code <TT>Initialize</TT> routine</A>
<LI><A NAME="tex2html1666"
  HREF="node4.html#SECTION04042300000000000000">16.2.3 Implement a user-code <TT>Run</TT> routine</A>
<LI><A NAME="tex2html1667"
  HREF="node4.html#SECTION04042400000000000000">16.2.4 Implement a user-code <TT>Finalize</TT> routine</A>
<LI><A NAME="tex2html1668"
  HREF="node4.html#SECTION04042500000000000000">16.2.5 Implement a user-code <TT>SetVM</TT> routine</A>
</UL>
<LI><A NAME="tex2html1669"
  HREF="node4.html#SECTION04043000000000000000">16.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1670"
  HREF="node4.html#SECTION04044000000000000000">16.4 Class API</A>
<UL>
<LI><A NAME="tex2html1671"
  HREF="node4.html#SECTION04044100000000000000">16.4.1 ESMF_CplCompAssignment(=)</A>
<LI><A NAME="tex2html1672"
  HREF="node4.html#SECTION04044200000000000000">16.4.2 ESMF_CplCompOperator(==)</A>
<LI><A NAME="tex2html1673"
  HREF="node4.html#SECTION04044300000000000000">16.4.3 ESMF_CplCompOperator(/=)</A>
<LI><A NAME="tex2html1674"
  HREF="node4.html#SECTION04044400000000000000">16.4.4 ESMF_CplCompCreate</A>
<LI><A NAME="tex2html1675"
  HREF="node4.html#SECTION04044500000000000000">16.4.5 ESMF_CplCompDestroy</A>
<LI><A NAME="tex2html1676"
  HREF="node4.html#SECTION04044600000000000000">16.4.6 ESMF_CplCompFinalize</A>
<LI><A NAME="tex2html1677"
  HREF="node4.html#SECTION04044700000000000000">16.4.7 ESMF_CplCompGet</A>
<LI><A NAME="tex2html1678"
  HREF="node4.html#SECTION04044800000000000000">16.4.8 ESMF_CplCompGetInternalState</A>
<LI><A NAME="tex2html1679"
  HREF="node4.html#SECTION04044900000000000000">16.4.9 ESMF_CplCompInitialize</A>
<LI><A NAME="tex2html1680"
  HREF="node4.html#SECTION040441000000000000000">16.4.10 ESMF_CplCompIsPetLocal</A>
<LI><A NAME="tex2html1681"
  HREF="node4.html#SECTION040441100000000000000">16.4.11 ESMF_CplCompPrint</A>
<LI><A NAME="tex2html1682"
  HREF="node4.html#SECTION040441200000000000000">16.4.12 ESMF_CplCompReadRestart</A>
<LI><A NAME="tex2html1683"
  HREF="node4.html#SECTION040441300000000000000">16.4.13 ESMF_CplCompRun</A>
<LI><A NAME="tex2html1684"
  HREF="node4.html#SECTION040441400000000000000">16.4.14 ESMF_CplCompSet</A>
<LI><A NAME="tex2html1685"
  HREF="node4.html#SECTION040441500000000000000">16.4.15 ESMF_CplCompSetEntryPoint</A>
<LI><A NAME="tex2html1686"
  HREF="node4.html#SECTION040441600000000000000">16.4.16 ESMF_CplCompSetInternalState</A>
<LI><A NAME="tex2html1687"
  HREF="node4.html#SECTION040441700000000000000">16.4.17 ESMF_CplCompSetServices</A>
<LI><A NAME="tex2html1688"
  HREF="node4.html#SECTION040441800000000000000">16.4.18 ESMF_CplCompSetServices</A>
<LI><A NAME="tex2html1689"
  HREF="node4.html#SECTION040441900000000000000">16.4.19 ESMF_CplCompSetVM</A>
<LI><A NAME="tex2html1690"
  HREF="node4.html#SECTION040442000000000000000">16.4.20 ESMF_CplCompSetVM</A>
<LI><A NAME="tex2html1691"
  HREF="node4.html#SECTION040442100000000000000">16.4.21 ESMF_CplCompSetVMMaxPEs</A>
<LI><A NAME="tex2html1692"
  HREF="node4.html#SECTION040442200000000000000">16.4.22 ESMF_CplCompSetVMMaxThreads</A>
<LI><A NAME="tex2html1693"
  HREF="node4.html#SECTION040442300000000000000">16.4.23 ESMF_CplCompSetVMMinThreads</A>
<LI><A NAME="tex2html1694"
  HREF="node4.html#SECTION040442400000000000000">16.4.24 ESMF_CplCompValidate</A>
<LI><A NAME="tex2html1695"
  HREF="node4.html#SECTION040442500000000000000">16.4.25 ESMF_CplCompWait</A>
<LI><A NAME="tex2html1696"
  HREF="node4.html#SECTION040442600000000000000">16.4.26 ESMF_CplCompWriteRestart</A>
</UL>
</UL>
<LI><A NAME="tex2html1697"
  HREF="node4.html#SECTION04050000000000000000">17 State Class</A>
<UL>
<LI><A NAME="tex2html1698"
  HREF="node4.html#SECTION04051000000000000000">17.1 Description</A>
<LI><A NAME="tex2html1699"
  HREF="node4.html#SECTION04052000000000000000">17.2 Constants</A>
<UL>
<LI><A NAME="tex2html1700"
  HREF="node4.html#SECTION04052100000000000000">17.2.1 ESMF_STATEINTENT</A>
<LI><A NAME="tex2html1701"
  HREF="node4.html#SECTION04052200000000000000">17.2.2 ESMF_STATEITEM</A>
</UL>
<LI><A NAME="tex2html1702"
  HREF="node4.html#SECTION04053000000000000000">17.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1703"
  HREF="node4.html#SECTION04053100000000000000">17.3.1 State create and destroy</A>
<LI><A NAME="tex2html1704"
  HREF="node4.html#SECTION04053200000000000000">17.3.2 Add items to a State</A>
<LI><A NAME="tex2html1705"
  HREF="node4.html#SECTION04053300000000000000">17.3.3 Add placeholders to a State</A>
<LI><A NAME="tex2html1706"
  HREF="node4.html#SECTION04053400000000000000">17.3.4 Mark an item <TT>NEEDED</TT></A>
<LI><A NAME="tex2html1707"
  HREF="node4.html#SECTION04053500000000000000">17.3.5 Create a <TT>NEEDED</TT> item</A>
<LI><A NAME="tex2html1708"
  HREF="node4.html#SECTION04053600000000000000">17.3.6 <TT>ESMF_StateReconcile()</TT> usage</A>
<LI><A NAME="tex2html1709"
  HREF="node4.html#SECTION04053700000000000000">17.3.7 Read Arrays from a netCDF file and add to a State</A>
<LI><A NAME="tex2html1710"
  HREF="node4.html#SECTION04053800000000000000">17.3.8 Print Array data from a State</A>
<LI><A NAME="tex2html1711"
  HREF="node4.html#SECTION04053900000000000000">17.3.9 Write Array data within a State to a netCDF file</A>
</UL>
<LI><A NAME="tex2html1712"
  HREF="node4.html#SECTION04054000000000000000">17.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html1713"
  HREF="node4.html#SECTION04055000000000000000">17.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html1714"
  HREF="node4.html#SECTION04056000000000000000">17.6 Object Model</A>
<LI><A NAME="tex2html1715"
  HREF="node4.html#SECTION04057000000000000000">17.7 Class API</A>
<UL>
<LI><A NAME="tex2html1716"
  HREF="node4.html#SECTION04057100000000000000">17.7.1 ESMF_StateAssignment(=)</A>
<LI><A NAME="tex2html1717"
  HREF="node4.html#SECTION04057200000000000000">17.7.2 ESMF_StateOperator(==)</A>
<LI><A NAME="tex2html1718"
  HREF="node4.html#SECTION04057300000000000000">17.7.3 ESMF_StateOperator(/=)</A>
<LI><A NAME="tex2html1719"
  HREF="node4.html#SECTION04057400000000000000">17.7.4 ESMF_StateAdd</A>
<LI><A NAME="tex2html1720"
  HREF="node4.html#SECTION04057500000000000000">17.7.5 ESMF_StateAddReplace</A>
<LI><A NAME="tex2html1721"
  HREF="node4.html#SECTION04057600000000000000">17.7.6 ESMF_StateCreate</A>
<LI><A NAME="tex2html1722"
  HREF="node4.html#SECTION04057700000000000000">17.7.7 ESMF_StateDestroy</A>
<LI><A NAME="tex2html1723"
  HREF="node4.html#SECTION04057800000000000000">17.7.8 ESMF_StateGet</A>
<LI><A NAME="tex2html1724"
  HREF="node4.html#SECTION04057900000000000000">17.7.9 ESMF_StateGet</A>
<LI><A NAME="tex2html1725"
  HREF="node4.html#SECTION040571000000000000000">17.7.10 ESMF_StateGet</A>
<LI><A NAME="tex2html1726"
  HREF="node4.html#SECTION040571100000000000000">17.7.11 ESMF_StatePrint</A>
<LI><A NAME="tex2html1727"
  HREF="node4.html#SECTION040571200000000000000">17.7.12 ESMF_StateRead</A>
<LI><A NAME="tex2html1728"
  HREF="node4.html#SECTION040571300000000000000">17.7.13 ESMF_StateReconcile</A>
<LI><A NAME="tex2html1729"
  HREF="node4.html#SECTION040571400000000000000">17.7.14 ESMF_StateRemove</A>
<LI><A NAME="tex2html1730"
  HREF="node4.html#SECTION040571500000000000000">17.7.15 ESMF_StateReplace</A>
<LI><A NAME="tex2html1731"
  HREF="node4.html#SECTION040571600000000000000">17.7.16 ESMF_StateValidate</A>
<LI><A NAME="tex2html1732"
  HREF="node4.html#SECTION040571700000000000000">17.7.17 ESMF_StateWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html1733"
  HREF="node4.html#SECTION04060000000000000000">18 Attachable Methods</A>
<UL>
<LI><A NAME="tex2html1734"
  HREF="node4.html#SECTION04061000000000000000">18.1 Description</A>
<LI><A NAME="tex2html1735"
  HREF="node4.html#SECTION04062000000000000000">18.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1736"
  HREF="node4.html#SECTION04062100000000000000">18.2.1 Producer Component attaches user defined method</A>
<LI><A NAME="tex2html1737"
  HREF="node4.html#SECTION04062200000000000000">18.2.2 Producer Component implements user defined method</A>
<LI><A NAME="tex2html1738"
  HREF="node4.html#SECTION04062300000000000000">18.2.3 Consumer Component executes user defined method</A>
</UL>
<LI><A NAME="tex2html1739"
  HREF="node4.html#SECTION04063000000000000000">18.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1740"
  HREF="node4.html#SECTION04064000000000000000">18.4 Class API</A>
<UL>
<LI><A NAME="tex2html1741"
  HREF="node4.html#SECTION04064100000000000000">18.4.1 ESMF_MethodAdd</A>
<LI><A NAME="tex2html1742"
  HREF="node4.html#SECTION04064200000000000000">18.4.2 ESMF_MethodAdd</A>
<LI><A NAME="tex2html1743"
  HREF="node4.html#SECTION04064300000000000000">18.4.3 ESMF_MethodExecute</A>
<LI><A NAME="tex2html1744"
  HREF="node4.html#SECTION04064400000000000000">18.4.4 ESMF_MethodRemove</A>
<LI><A NAME="tex2html1745"
  HREF="node4.html#SECTION04064500000000000000">18.4.5 ESMF_MethodAdd</A>
<LI><A NAME="tex2html1746"
  HREF="node4.html#SECTION04064600000000000000">18.4.6 ESMF_MethodAdd</A>
<LI><A NAME="tex2html1747"
  HREF="node4.html#SECTION04064700000000000000">18.4.7 ESMF_MethodAdd</A>
<LI><A NAME="tex2html1748"
  HREF="node4.html#SECTION04064800000000000000">18.4.8 ESMF_MethodAdd</A>
<LI><A NAME="tex2html1749"
  HREF="node4.html#SECTION04064900000000000000">18.4.9 ESMF_MethodExecute</A>
<LI><A NAME="tex2html1750"
  HREF="node4.html#SECTION040641000000000000000">18.4.10 ESMF_MethodExecute</A>
<LI><A NAME="tex2html1751"
  HREF="node4.html#SECTION040641100000000000000">18.4.11 ESMF_MethodRemove</A>
<LI><A NAME="tex2html1752"
  HREF="node4.html#SECTION040641200000000000000">18.4.12 ESMF_MethodRemove</A>
</UL>
</UL>
<LI><A NAME="tex2html1753"
  HREF="node4.html#SECTION04070000000000000000">19 Web Services</A>
<UL>
<LI><A NAME="tex2html1754"
  HREF="node4.html#SECTION04071000000000000000">19.1 Description</A>
<UL>
<LI><A NAME="tex2html1755"
  HREF="node4.html#SECTION04071100000000000000">19.1.1 Creating a Service around a Component</A>
<LI><A NAME="tex2html1756"
  HREF="node4.html#SECTION04071200000000000000">19.1.2 Code Modifications</A>
<LI><A NAME="tex2html1757"
  HREF="node4.html#SECTION04071300000000000000">19.1.3 Accessing the Service</A>
<LI><A NAME="tex2html1758"
  HREF="node4.html#SECTION04071400000000000000">19.1.4 Client Application via C++ API</A>
<LI><A NAME="tex2html1759"
  HREF="node4.html#SECTION04071500000000000000">19.1.5 Process Controller</A>
<LI><A NAME="tex2html1760"
  HREF="node4.html#SECTION04071600000000000000">19.1.6 Tomcat/Axis2</A>
</UL>
<LI><A NAME="tex2html1761"
  HREF="node4.html#SECTION04072000000000000000">19.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1762"
  HREF="node4.html#SECTION04072100000000000000">19.2.1 Making a Component available through WebServices</A>
</UL>
<LI><A NAME="tex2html1763"
  HREF="node4.html#SECTION04073000000000000000">19.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1764"
  HREF="node4.html#SECTION04074000000000000000">19.4 Class API</A>
<UL>
<LI><A NAME="tex2html1765"
  HREF="node4.html#SECTION04074100000000000000">19.4.1 ESMF_WebServicesLoop</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION04000000000000000000">
3 Superstructure</A>
</H1>

<P>
<A NAME="part:Superstructure"></A>
<P>

<P>

<P>

<H1><A NAME="SECTION04010000000000000000">
13 Overview of Superstructure</A>
</H1>

<P>
ESMF superstructure classes define an architecture for assembling
Earth system applications from modeling <B>components</B>.  A component
may be defined in terms of the physical domain that it represents,
such as an atmosphere or sea ice model.  It may also be defined in terms
of a computational function, such as a data assimilation system.
Earth system research often requires that such components be <B>coupled</B> 
together to create an application.  By coupling we mean the data 
transformations and, on parallel computing systems, data transfers, 
that are necessary to allow data from one component to be utilized by 
another.  ESMF offers regridding methods and other tools to simplify 
the organization and execution of inter-component data exchanges.  

<P>
In addition to components defined at the level of major physical 
domains and computational functions, components may be defined that 
represent smaller computational functions within larger components, 
such as the transformation of data between the physics and dynamics 
in a spectral atmosphere model, 
or the creation of nested higher resolution regions 
within a coarser grid.  The objective is to couple components at varying 
scales both flexibly and efficiently.  ESMF encourages a hierachical
application structure, in which large components branch into 
smaller sub-components (see Figure <A HREF="node4.html#fig:GEOS5">2</A>).  ESMF also makes 
it easier for the same component to be used in multiple contexts 
without changes to its source code.

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Modular, component-based architecture.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchical assembly of components into applications.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Use of components in multiple contexts without modification.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Sequential or concurrent component execution.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Single program, multiple datastream (SPMD) applications for 
maximum portability and reconfigurability.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multiple program, multiple datastream (MPMD) option for 
flexibility.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION04011000000000000000">
13.1 Superstructure Classes</A>
</H2>

<P>
There are a small number of classes in the ESMF superstructure:

<P>

<UL>
<LI><B>Component</B>  An ESMF component has two parts, one that is 
supplied by ESMF and one that is supplied by the user.  The
part that is supplied by the framework is an ESMF derived type that
is either a Gridded Component (<B>GridComp</B>) or a Coupler 
Component (<B>CplComp</B>).  A Gridded Component typically represents
a physical domain in which data is associated with one or more 
grids - for example, a sea ice model.  A Coupler Component 
arranges and executes data transformations and transfers between
one or more Gridded Components. Gridded Components and Coupler 
Components have standard methods, which include initialize, run,
and finalize.  These methods can be multi-phase.

<P>
The second part of an ESMF Component is user code, such as a
model or data assimilation system.  Users set entry points 
within their code so that it is callable by the framework.  
In practice, setting entry points means that within user code 
there are calls to ESMF methods that associate the name of a 
Fortran subroutine with a corresponding standard ESMF operation.  
For example, a user-written initialization routine called 
<TT>myOceanInit</TT> might be associated with the standard 
initialize routine of an ESMF Gridded Component named ``myOcean'' 
that represents an ocean model.

<P>
</LI>
<LI><B>State</B>  ESMF Components exchange information with other 
Components only through States.  A State is an ESMF derived
type that can contain Fields, FieldBundles, Arrays, ArrayBundles,
and other States.  A Component is associated with two States, an 
<B>Import State</B> and an <B>Export State</B>.  Its Import State 
holds the data that it receives from other Components.  
Its Export State contains data that it makes available to 
other Components. 

<P>
</LI>
</UL>

<P>
An ESMF coupled application typically involves a parent Gridded Component, 
two or more child Gridded Components and one or more Coupler 
Components. 

<P>
The parent Gridded Component is responsible for creating the child 
Gridded Components that are exchanging data, for creating the Coupler, 
for creating the necessary Import and Export States, and for 
setting up the desired sequencing.  The application's ``main'' routine
calls the parent Gridded Component's initialize, run, and finalize 
methods in order to execute the application.  For each of these
standard methods, the parent Gridded Component in turn calls the 
corresponding methods in the child Gridded Components and the 
Coupler Component.  For example, consider a simple coupled 
ocean/atmosphere simulation.  When the initialize method of the 
parent Gridded Component is called by the application, it in turn 
calls the initialize methods of its child atmosphere and ocean 
Gridded Components, and the initialize method of an 
ocean-to-atmosphere Coupler Component.  Figure <A HREF="node4.html#fig:appunit">3</A>
shows this schematically.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:GEOS5"></A><A NAME="1900"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
ESMF enables applications such as the atmospheric general
circulation model GEOS-5 to be structured hierarchically, and 
reconfigured and extended easily.  Each box in this diagram is an
ESMF Gridded Component.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{ESMF_GEOS5}}$
 -->
<IMG
 WIDTH="726" HEIGHT="439" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="\scalebox{0.9}{\includegraphics{ESMF_GEOS5}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION04012000000000000000"></A>
<A NAME="sec:hierarchy"></A>
<BR>
13.2 Hierarchical Creation of Components
</H2>

<P>
Components are allocated computational resources in the form of
<B>Persistent Execution Threads</B>, or <B>PET</B>s.  A list of a Component's
PETs is contained in a structure called a <B>Virtual Machine</B>,
or <B>VM</B>.  The VM also contains information about the topology and
characteristics of the underlying computer.
Components are created hierarchically, with parent Components creating
child Components and allocating some or all of their PETs to each one.
By default ESMF creates a new VM for each child Component, which 
allows Components to tailor their VM resources to match their needs.
In some cases a child may want to share its parent's VM - ESMF
supports this too.

<P>
A Gridded Component may exist across all the PETs in an application. 
A Gridded Component may also reside on a subset of PETs in an
application.  These PETs may wholly coincide with, be wholly contained
within, or wholly contain another Component.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:appunit"></A><A NAME="1914"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 3:</STRONG>
A call to a standard ESMF initialize (run, finalize) method
by a parent component triggers calls to initialize (run, finalize)
all of its child components.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_appunit}}$
 -->
<IMG
 WIDTH="749" HEIGHT="547" ALIGN="BOTTOM" BORDER="0"
 SRC="img3.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_appunit}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION04013000000000000000"></A>
<A NAME="sec:concurrency"></A>
<BR>
13.3 Sequential and Concurrent Execution of Components
</H2>

<P>
When a set of Gridded Components and a Coupler runs in sequence
on the same set of PETs the application is executing in a <B>sequential</B>
mode. When Gridded Components are created and run on mutually exclusive
sets of PETs, and are coupled by a Coupler Component that extends over
the union of these sets, the mode of execution is <B>concurrent</B>.

<P>
Figure <A HREF="node4.html#fig:serial">4</A> illustrates a typical configuration for 
a simple coupled sequential
application, and Figure <A HREF="node4.html#fig:concurrent">5</A> shows a possible 
configuration for the same application running in a concurrent mode.

<P>
Parent Components can select if and when to wait for concurrently
executing child Components, synchronizing only when required.

<P>
It is possible for ESMF applications to contain some Component sets
that are executing sequentially and others that are executing concurrently.
We might have, for example, atmosphere and land Components created
on the same subset of PETs, ocean and sea ice Components created on
the remainder of PETs, and a Coupler created across all the PETs in
the application.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:serial"></A><A NAME="1928"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 4:</STRONG>
Schematic of the run method of a coupled application, with an
``Atmosphere'' and an ``Ocean'' Gridded Component running sequentially with 
an ``Atm-Ocean Coupler.''  The top-level ``Hurricane Model'' 
Gridded Component contains the sequencing information and time 
advancement loop.  The application driver, Coupler, and all Gridded Components 
are distributed over nine PETs.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_serial}}$
 -->
<IMG
 WIDTH="621" HEIGHT="704" ALIGN="BOTTOM" BORDER="0"
 SRC="img4.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_serial}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:concurrent"></A><A NAME="1936"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5:</STRONG>
Schematic of the run method of a coupled application, with an
``Atmosphere'' and an ``Ocean'' Gridded Component running concurrently with 
an ``Atm-Ocean Coupler.''  The top-level ``Hurricane Model'' 
Gridded Component contains the sequencing information and time 
advancement loop.  The application driver, Coupler, and top-level ``Hurricane
Model'' Gridded Component are distributed over nine PETs.  The
``Atmosphere'' Gridded Component is distributed over three PETs and
the ``Ocean'' Gridded Component is distributed over six PETs.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_concurrent}}$
 -->
<IMG
 WIDTH="621" HEIGHT="603" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_concurrent}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION04014000000000000000"></A>
<A NAME="sec:localcomm"></A>
<BR>
13.4 Intra-Component Communication
</H2>

<P>
All data transfers within an ESMF application occur <I>within</I> a
component.  For example, a Gridded Component may contain halo updates.
Another example is that a Coupler Component may redistribute
data between two Gridded Components.  As a result,
the architecture of ESMF does not depend on any particular data
communication mechanism, and new communication schemes can be
introduced without affecting the overall structure of the application.

<P>
Since all data communication happens within a component, a Coupler
Component must be created on the union of the PETs of all
the Gridded Components that it couples.  

<P>

<H2><A NAME="SECTION04015000000000000000"></A>
<A NAME="sec:scoping"></A>
<BR>
13.5 Data Distribution and Scoping in Components
</H2>

<P>
The scope of distributed objects is the VM of the currently 
executing Component.  For this reason, all
PETs in the current VM must make the same distributed object
creation calls.   When a Coupler Component running on a superset
of a Gridded Component's PETs needs to make communication calls
involving objects created by the Gridded Component,
an ESMF-supplied function called <TT>ESMF_StateReconcile()</TT> creates proxy
objects for those PETs that had no previous information about the
distributed objects.  Proxy objects contain no local data but
can be used in communication calls (such as regrid or redistribute)
to describe the remote source for data being moved to the current PET,
or to describe the remote destination for data being moved from the local PET.
Figure <A HREF="node4.html#fig:reconcile">6</A> is a simple schematic that shows the 
sequence of events in a reconcile call.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:reconcile"></A><A NAME="1972"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 6:</STRONG>
An <TT>ESMF_StateReconcile()</TT> call creates proxy 
objects for use in subsequent communication calls.  The reconcile 
call would normally be made during Coupler initialization.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_reconcile}}$
 -->
<IMG
 WIDTH="633" HEIGHT="662" ALIGN="BOTTOM" BORDER="0"
 SRC="img6.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_reconcile}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H2><A NAME="SECTION04016000000000000000"></A>
<A NAME="sec:performance"></A>
<BR>
13.6 Performance
</H2>

<P>
The ESMF design enables the user to configure ESMF
applications so that data is transferred directly from one component 
to another, without requiring that it be copied or sent to a different data
buffer as an interim step.  This is likely to be the most efficient way 
of performing inter-component coupling.  However, if desired, an 
application can also be configured so that data from a source component 
is sent to a distinct set of Coupler Component PETs for processing 
before being sent to its destination.

<P>
The ability to overlap computation with communication is essential for
performance.  When running with ESMF the user can initiate data 
sends during Gridded Component execution, as soon as the data is ready.
Computations can then proceed simultaneously with the data transfer.

<P>

<H2><A NAME="SECTION04017000000000000000">
13.7 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the relationships among
ESMF superstructure classes.  See Appendix A, <I>A Brief Introduction 
to UML</I>, for a translation table that lists the symbols in the diagram 
and their meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="692" HEIGHT="224" ALIGN="BOTTOM" BORDER="0"
 SRC="img7.png"
 ALT="\includegraphics[]{Comp_obj}">   

</DIV>

<P>

<P>

<P>

<H1><A NAME="SECTION04020000000000000000">
14 Application Driver and Required ESMF Methods</A>
</H1>

<P>

<H2><A NAME="SECTION04021000000000000000">
14.1 Description</A>
</H2>

<P>
Every ESMF application needs a driver code. Typically the driver layer is
implemented as the "main" of the application, although this is not strictly an
ESMF requirement. For most ESMF applications the task of the application driver
will be very generic: Initialize ESMF, create a top level Component and call its
Intialize, Run and Finalize methods, before destroying the top level Component
again and calling ESMF Finalize.

<P>
ESMF provides a number of different application driver templates in the
<TT>$ESMF_DIR/src/Superstructure/AppDriver</TT> directory. An appropriate one 
can be chosen depending on how the application is to be structured:

<P>
<DL>
<DT><STRONG>Sequential vs. Concurrent Execution</STRONG></DT>
<DD><P>
In a sequential execution model every Component executes
on all PETs, with each Component completing execution before
the next Component begins.  This has the appeal of 
simplicity of data consumption and production: when a Gridded 
Component starts all required data is available for use, and when 
a Gridded Component finishes all data produced is ready for consumption 
by the next Gridded Component.  This approach also has
the possibility of less data movement if the grid and
data decomposition is done such that each processor's memory contains
the data needed by the next Component.

<P>
In a concurrent execution model subgroups of PETs run
Gridded Components and multiple Gridded Components are active at the 
same time.  Data exchange must be coordinated between Gridded 
Components so that data deadlock does not occur.  This strategy 
has the advantage of allowing coupling to other Gridded Components 
at any time during the computational process, including not 
having to return to the calling level of code before making 
data available.  

<P>
</DD>
<DT><STRONG>Pairwise vs. Hub and Spoke</STRONG></DT>
<DD><P>
Coupler Components are responsible for taking data from one
Gridded Component and putting it into the form expected by another 
Gridded Component.  This might include regridding, change of units, 
averaging, or binning.

<P>
Coupler Components can be written for <I>pairwise</I> data exchange: 
the Coupler Component takes data from a single Component and transforms 
it for use by another single Gridded Component.  This simplifies the 
structure of the Coupler Component code.

<P>
Couplers can also be written using a <I>hub and spoke</I> model where a
single Coupler accepts data from all other Components, can do data
merging or splitting, and formats data for all other Components.

<P>
Multiple Couplers, using either of the above two models or some mixture of
these approaches, are also possible.

<P>
</DD>
<DT><STRONG>Implementation Language</STRONG></DT>
<DD><P>
The ESMF framework currently has Fortran interfaces for all public functions. 
Some functions also have C interfaces, and the number of these is expected to 
increase over time. 

<P>
</DD>
<DT><STRONG>Number of Executables</STRONG></DT>
<DD><P>
The simplest way to run an application
is to run the same executable program on all PETs.  Different Components
can still be run on mutually exclusive PETs by using branching
(e.g., if this is PET 1, 2, or 3, run Component A, if it is
PET 4, 5, or 6 run Component B).  This is a <B>SPMD</B> model, 
Single Program Multiple Data.  

<P>
The alternative is to start a different executable program on different
PETs.  This is a <B>MPMD</B> model, Multiple Program Multiple Data.
There are complications with many job control systems on multiprocessor
machines in getting the different executables started, and getting
inter-process communcations established.  ESMF currently has some
support for MPMD: different Components can run as separate executables,
but the Coupler that transfers data between the Components must still
run on the union of their PETs. This means that the Coupler Component
must be linked into all of the executables.

<P>
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION04022000000000000000">
14.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION04022100000000000000"></A>
<A NAME="const:endflag"></A>
<BR>
14.2.1 ESMF_END
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
The <TT>ESMF_End_Flag</TT> determines how an ESMF application is shut down.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_End_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_END_ABORT</STRONG></DT>
<DD>Global abort of the ESMF application. There is no guarantee 
         that all PETs will shut down cleanly during an abort. However, all
         attempts are made to prevent the application from hanging and the
         LogErr of at least one PET will be completely flushed during the abort.
         This option should only be used if a condition is detected that
         prevents normal continuation or termination of the application.
         Typical conditions that warrant the use of <TT>ESMF_END_ABORT</TT> are those
         that occur on a per PET basis where other PETs may be blocked in 
         communication calls, unable to reach the normal termination point.
   
</DD>
<DT><STRONG>ESMF_END_NORMAL</STRONG></DT>
<DD>Normal termination of the ESMF application. Wait for all PETs of the
         global VM to reach 
	<TT>ESMF_Finalize()</TT> before termination. This is
         the clean way of terminating an application. <TT>MPI_Finalize()</TT> will
         be called in case of MPI applications.

</DD>
<DT><STRONG>ESMF_END_KEEPMPI</STRONG></DT>
<DD>Same as <TT>ESMF_END_NORMAL</TT> but <TT>MPI_Finalize()</TT> will <EM>not</EM>
         be called. It is the user code's responsibility to shut down MPI
         cleanly if necessary.
</DD>
</DL>

<P>

<H2><A NAME="SECTION04023000000000000000">
14.3 Use and Examples</A>
</H2>

<P>
ESMF encourages application organization in which there is a single 
top-level Gridded Component.  This provides a simple, clear sequence
of operations at the highest level, and also enables the entire 
application to be treated as a sub-Component of another, larger 
application if desired.  When a simple application is organized in this fashion 
the standard AppDriver can probably be used without much modification.  

<P>
Examples of program organization using the AppDriver can be found in the 
<TT>src/Superstructure/AppDriver</TT> directory.  A set of subdirectories 
within the AppDriver directory follows the naming convention:

<PRE>
&lt;seq|concur&gt;_&lt;pairwise|hub&gt;_&lt;f|c&gt;driver_&lt;spmd|mpmd&gt;
</PRE>

<P>
The example that is currently implemented is
<TT>seq_pairwise_fdriver_spmd</TT>, which
has sequential component execution, a pairwise coupler, a main program
in Fortran, and all processors launching the same executable.
It is also copied automatically into a top-level 
<TT>quick_start</TT> directory at compilation time.  

<P>
The user can copy the AppDriver files into
their own local directory. Some of the files can be used unchanged.
Others are template files which have the rough outline of the code but
need additional application-specific code added in order to perform a
meaningful function.  The <TT>README</TT> file in the AppDriver 
subdirectory or <TT>quick_start</TT> directory contains instructions about 
which files to change.

<P>
Examples of concurrent component execution can be found in the
system tests that are bundled with the ESMF distribution.

<P>

<P>

<P>

<P>
<PRE>
 
  ---------------------------------------------------------------------------
  ---------------------------------------------------------------------------
   EXAMPLE:  This is an AppDriver.F90 file for a sequential ESMF application.
  ---------------------------------------------------------------------------
  ---------------------------------------------------------------------------
  
    The ChangeMe.F90 file that's included below contains a number of 
    definitions that are used by the AppDriver, such as the name of the 
    application's main configuration file and the name of the application's 
    SetServices routine.  This file is in the same directory as the 
    AppDriver.F90 file.
  ---------------------------------------------------------------------------
 
 #include "ChangeMe.F90"
 
     program ESMF_AppDriver
 #define ESMF_METHOD "program ESMF_AppDriver"
 
 #include "ESMF.h"
 
     ! ESMF module, defines all ESMF data types and procedures
     use ESMF
     
     ! Gridded Component registration routines.  Defined in "ChangeMe.F90"
     use USER_APP_Mod, only : SetServices =&gt; USER_APP_SetServices
 
     implicit none
     
  ---------------------------------------------------------------------------
    Define local variables
  ---------------------------------------------------------------------------
 
     ! Components and States
     type(ESMF_GridComp) :: compGridded
     type(ESMF_State) :: defaultstate
 
     ! Configuration information
     type(ESMF_Config) :: config
 
     ! A common Grid
     type(ESMF_Grid) :: grid
 
     ! A Clock, a Calendar, and timesteps
     type(ESMF_Clock) :: clock
     type(ESMF_TimeInterval) :: timeStep
     type(ESMF_Time) :: startTime
     type(ESMF_Time) :: stopTime
 
     ! Variables related to the Grid
     integer :: i_max, j_max
 
     ! Return codes for error checks
     integer :: rc, localrc
         
  ---------------------------------------------------------------------------
    Initialize ESMF.  Note that an output Log is created by default.
  ---------------------------------------------------------------------------
 
     call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
     call ESMF_LogWrite("ESMF AppDriver start", ESMF_LOGMSG_INFO)
 
  ---------------------------------------------------------------------------
    Create and load a configuration file.
    The USER_CONFIG_FILE is set to sample.rc in the ChangeMe.F90 file.
    The sample.rc file is also included in the directory with the 
    AppDriver.F90 file.
  ---------------------------------------------------------------------------
     
     config = ESMF_ConfigCreate(rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
     call ESMF_ConfigLoadFile(config, USER_CONFIG_FILE, rc = localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ---------------------------------------------------------------------------
    Get configuration information.
  
    A configuration file like sample.rc might include:
    - size and coordinate information needed to create the default Grid.
    - the default start time, stop time, and running intervals
      for the main time loop.
  ---------------------------------------------------------------------------
 
     call ESMF_ConfigGetAttribute(config, i_max, label='I Counts:', &amp;
       default=10, rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
     call ESMF_ConfigGetAttribute(config, j_max, label='J Counts:', &amp;
       default=40, rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ---------------------------------------------------------------------------
    Create the top Gridded Component.
  ---------------------------------------------------------------------------
 
     compGridded = ESMF_GridCompCreate(name="ESMF Gridded Component", &amp;
 	rc=localrc)
     if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
     call ESMF_LogWrite("Component Create finished", ESMF_LOGMSG_INFO)
 
  ----------------------------------------------------------------------------
    Register the set services method for the top Gridded Component.
  ----------------------------------------------------------------------------
 
     call ESMF_GridCompSetServices(compGridded, SetServices, rc=rc)
     if (ESMF_LogFoundError(rc, msg="Registration failed", rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Create and initialize a Clock.
  ----------------------------------------------------------------------------
 
       call ESMF_TimeIntervalSet(timeStep, s=2, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_TimeSet(startTime, yy=2004, mm=9, dd=25, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_TimeSet(stopTime, yy=2004, mm=9, dd=26, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       clock = ESMF_ClockCreate(timeStep, startTime, stopTime=stopTime, &amp;
                 name="Application Clock", rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Create and initialize a Grid.
  
    The default lower indices for the Grid are (/1,1/).
    The upper indices for the Grid are read in from the sample.rc file,
    where they are set to (/10,40/).  This means a Grid will be
    created with 10 grid cells in the x direction and 40 grid cells in the
    y direction.  The Grid section in the Reference Manual shows how to set
    coordinates.
  ----------------------------------------------------------------------------
 
       grid = ESMF_GridCreateNoPeriDim(maxIndex=(/i_max, j_max/), &amp;
                              name="source grid", rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       ! Attach the grid to the Component
       call ESMF_GridCompSet(compGridded, grid=grid, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Create and initialize a State to use for both import and export.
    In a real code, separate import and export States would normally be
    created.
  ----------------------------------------------------------------------------
 
       defaultstate = ESMF_StateCreate(name="Default State", rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
             ESMF_CONTEXT, rcToReturn=rc)) &amp;
             call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
      
  ----------------------------------------------------------------------------
    Call the initialize, run, and finalize methods of the top component.
    When the initialize method of the top component is called, it will in
    turn call the initialize methods of all its child components, they
    will initialize their children, and so on.  The same is true of the
    run and finalize methods.
  ----------------------------------------------------------------------------
  
       call ESMF_GridCompInitialize(compGridded, importState=defaultstate, &amp;
         exportState=defaultstate, clock=clock, rc=localrc)
       if (ESMF_LogFoundError(rc, msg="Initialize failed", rcToReturn=rc)) &amp;
           call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  
       call ESMF_GridCompRun(compGridded, importState=defaultstate, &amp;
         exportState=defaultstate, clock=clock, rc=localrc)
       if (ESMF_LogFoundError(rc, msg="Run failed", rcToReturn=rc)) &amp;
           call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_GridCompFinalize(compGridded, importState=defaultstate, &amp;
         exportState=defaultstate, clock=clock, rc=localrc)
       if (ESMF_LogFoundError(rc, msg="Finalize failed", rcToReturn=rc)) &amp;
           call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
  
  
  ----------------------------------------------------------------------------
    Destroy objects.
  ----------------------------------------------------------------------------
 
       call ESMF_ClockDestroy(clock, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_StateDestroy(defaultstate, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
       call ESMF_GridCompDestroy(compGridded, rc=localrc)
       if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &amp;
         ESMF_CONTEXT, rcToReturn=rc)) &amp;
         call ESMF_Finalize(rc=localrc, endflag=ESMF_END_ABORT)
 
  ----------------------------------------------------------------------------
    Finalize and clean up.
  ----------------------------------------------------------------------------
 
     call ESMF_Finalize()
 
     end program ESMF_AppDriver
</PRE>    

<P>

<H2><A NAME="SECTION04024000000000000000">
14.4 Required ESMF Methods</A>
</H2>

<P>
There are a few methods that every ESMF application must contain. First,
<TT>ESMF_Initialize()</TT> and <TT>ESMF_Finalize()</TT> are in complete analogy 
to <TT>MPI_Init()</TT> and <TT>MPI_Finalize()</TT> known from MPI. All ESMF
programs, serial or parallel, must initialize the ESMF system at the beginning,
and finalize it at the end of execution. The behavior of calling any
ESMF method before <TT>ESMF_Initialize()</TT>, or after <TT>ESMF_Finalize()</TT>
is undefined.

<P>
Second, every ESMF Component that is accessed by an ESMF application requires
that its set services routine is called through
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>. The Component must implement
one public entry point, its set services routine, that can be called
through the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT> library routine. The
Component set services routine is responsible for setting entry points
for the standard ESMF Component methods Initialize, Run, and Finalize.

<P>
Finally, the Component library call <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> can
optionally be issues <EM>before</EM> calling
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>. Similar to 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, the 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT>
call requires a public entry point into the Component. It allows the Component
to adjust certain aspects of its execution environment, i.e. its own VM, before
it is started up.

<P>
The following sections discuss the above mentioned aspects in more detail.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04024100000000000000">
14.4.1 ESMF_Initialize - Initialize ESMF</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_Initialize(defaultConfigFileName, defaultCalKind, &amp;
         defaultLogFileName, logkindflag, mpiCommunicator,  &amp;
         ioUnitLBound, ioUnitUBound, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),        intent(in),  optional :: defaultConfigFileName
       type(ESMF_CalKind_Flag), intent(in),  optional :: defaultCalKind
       character(len=*),        intent(in),  optional :: defaultLogFileName
       type(ESMF_LogKind_Flag), intent(in),  optional :: logkindflag
       integer,                 intent(in),  optional :: mpiCommunicator
       integer,                 intent(in),  optional :: ioUnitLBound
       integer,                 intent(in),  optional :: ioUnitUBound
       type(ESMF_VM),           intent(out), optional :: vm
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method must be called once on each PET before
       any other ESMF methods are used.  The method contains a
       barrier before returning, ensuring that all processes
       made it successfully through initialization.

<P>
Typically <TT>ESMF_Initialize()</TT> will call <TT>MPI_Init()</TT> 
       internally unless MPI has been initialized by the user code before
       initializing the framework. If the MPI initialization is left to
       <TT>ESMF_Initialize()</TT> it inherits all of the MPI implementation 
       dependent limitations of what may or may not be done before 
       <TT>MPI_Init()</TT>. For instance, it is unsafe for some MPI
       implementations, such as MPICH, to do IO before the MPI environment
       is initialized. Please consult the documentation of your MPI
       implementation for details.

<P>
Note that when using MPICH as the MPI library, ESMF needs to use
       the application command line arguments for <TT>MPI_Init()</TT>. However,
       ESMF acquires these arguments internally and the user does not need
       to worry about providing them. Also, note that ESMF does not alter
       the command line arguments, so that if the user obtains them they will
       be as specified on the command line (including those which MPICH would
       normally strip out). 

<P>
By default, <TT>ESMF_Initialize()</TT> will open multiple error log files,
       one per processor.  This is very useful for debugging purpose.  However,
       when running the application on a large number of processors, opening a
       large number of log files and writing log messages from all the processors
       could become a performance bottleneck.  Therefore, it is recommended
       to turn the Error Log feature off in these situations by setting
       <TT>logkindflag</TT> to ESMF_LOGKIND_NONE.

<P>
When integrating ESMF with applications where Fortran unit number conflicts
       exist, the optional <TT>ioUnitLBound</TT> and <TT>ioUnitUBound</TT> arguments may be
       used to specify an alternate unit number range.  See section <A HREF="node6.html#fio:unitnumbers">46.2.1</A>
       for more information on how ESMF uses Fortran unit numbers.

<P>
Before exiting the application the user must call <TT>ESMF_Finalize()</TT>
       to release resources and clean up ESMF gracefully.

<P>
The arguments are:
       <DL>
<DT><STRONG>[defaultConfigFilename]</STRONG></DT>
<DD>Name of the default configuration file for the entire application.
       
</DD>
<DT><STRONG>[defaultCalKind]</STRONG></DT>
<DD>Sets the default calendar to be used by ESMF Time Manager.
             See section <A HREF="node6.html#const:calkindflag">37.2.1</A> for a list of valid options.
             If not specified, defaults to <TT>ESMF_CALKIND_NOCALENDAR</TT>.
       
</DD>
<DT><STRONG>[defaultLogFileName]</STRONG></DT>
<DD>Name of the default log file for warning and error messages.
             If not specified, defaults to <TT>ESMF_ErrorLog</TT>.
       
</DD>
<DT><STRONG>[logkindflag]</STRONG></DT>
<DD>Sets the default Log Type to be used by ESMF Log Manager.
             See section <A HREF="node6.html#const:logkindflag">43.2.2</A> for a list of valid options.
             If not specified, defaults to <TT>ESMF_LOGKIND_MULTI</TT>.
       
</DD>
<DT><STRONG>[mpiCommunicator]</STRONG></DT>
<DD>MPI communicator defining the group of processes on which the
             ESMF application is running.
             If not specified, defaults to <TT>MPI_COMM_WORLD</TT>.
       
</DD>
<DT><STRONG>[ioUnitLBound]</STRONG></DT>
<DD>Lower bound for Fortran unit numbers used within the ESMF library.
             Fortran units are primarily used for log files.  Legal unit numbers
             are positive integers.  A value higher than 10 is recommended
             in order to avoid the compiler-specific
             reservations which are typically found on the first few units.
             If not specified, defaults to <TT>ESMF_LOG_FORT_UNIT_NUMBER</TT>,
             which is distributed with a value of 50.
       
</DD>
<DT><STRONG>[ioUnitUBound]</STRONG></DT>
<DD>Upper bound for Fortran unit numbers used within the ESMF library.
             Must be set to a value at least 5 units higher than <TT>ioUnitLBound</TT>.
             If not specified, defaults to <TT>ESMF_LOG_UPPER</TT>, which is
             distributed with a value of 99.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Returns the global <TT>ESMF_VM</TT> that was created 
             during initialization.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04024200000000000000">
14.4.2 ESMF_Finalize - Clean up and shut down ESMF</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_Finalize(endflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_End_Flag), intent(in), optional  :: endflag
       integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This must be called once on each PET before the application exits
       to allow ESMF to flush buffers, close open connections, and 
       release internal resources cleanly. The optional argument 
       <TT>endflag</TT> may be used to indicate the mode of termination.  
       Note that this call must be issued only once per PET with 
       <TT>endflag=ESMF_END_NORMAL</TT>, and that this call may not be followed
       by <TT>ESMF_Initialize()</TT>.  This last restriction means that it is not
       possible to restart ESMF within the same execution.

<P>
The arguments are:
       <DL>
<DT><STRONG>[endflag]</STRONG></DT>
<DD>Specify mode of termination. The default is <TT>ESMF_END_NORMAL</TT>
             which waits for all PETs of the global VM to reach 
             <TT>ESMF_Finalize()</TT> before termination. See section 
             <A HREF="node4.html#const:endflag">14.2.1</A> for a complete list and description of
             valid flags.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04024300000000000000">
14.4.3 User-code <TT>SetServices</TT> method</A>
</H3>

<P>
Many programs call some library routines.  The library
documentation must explain what the routine name is, what arguments 
are required and what are optional, and what the code does.  

<P>
In contrast, all ESMF components must be written to <I>be called</I>
by another part of the program; in effect, an ESMF component takes the 
place of a library.  The interface is prescribed by the framework,
and the component writer must provide specific subroutines which 
have standard argument lists and perform specific operations.
For technical reasons <EM>none</EM> of the arguments in user-provided subroutines
must be declared as <EM>optional</EM>.

<P>
The only <EM>required</EM> public interface of a Component is its
set services method.  This subroutine must have an
externally accessible name (be a public symbol), take a component
as the first argument, and an integer return code as the second. 
Both arguments are required and must <EM>not</EM> be declared as 
<TT>optional</TT>. If an intent is specified in the interface it must be 
<TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
second argument. The subroutine name is not predefined, it is set by the
component writer, but must be provided as part of the component 
documentation.

<P>
The required function that the set services subroutine must provide is to
specify the user-code entry points for the standard ESMF Component methods. To
this end the user-written set services routine calls the

<P>
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetEntryPoint()</TT> method to set each 
Component entry point.

<P>
See sections <A HREF="node4.html#sec:GridSetServ">15.2.1</A> and <A HREF="node4.html#sec:CplSetServ">16.2.1</A> for examples of
how to write a user-code set services routine.

<P>
Note that a component does not call its own set services routine;
the AppDriver or parent component code, which is creating a component, 
will first call <TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT> to create an "empty" 
component, and then must call into <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, 
supplying the user-code set services routine as an argument. The framework
calls into the user-code set services, after the Component's VM has been
started up.

<P>

<H3><A NAME="SECTION04024400000000000000">
14.4.4 User-code <TT>Initialize</TT>, <TT>Run</TT>, and <TT>Finalize</TT> methods</A>
</H3>

<P>
The required standard ESMF Component methods, for which user-code entry
points must be set, are Initialize, Run, and Finalize. Currently optional,
a Component may also set entry points for the WriteRestart and
ReadRestart methods.

<P>
Sections <A HREF="node4.html#sec:GridSetServ">15.2.1</A> and <A HREF="node4.html#sec:CplSetServ">16.2.1</A> provide examples
of how the entry points for Initialize, Run, and Finalize are set during
the user-code set services routine, using the 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetEntryPoint()</TT> library call.

<P>
All standard user-code methods must abide <EM>exactly</EM> to the prescribed
interfaces. <EM>None</EM> of the arguments must be declared as <EM>optional</EM>.

<P>
The names of the Initialize, Run, and Finalize user-code subroutines do
not need to be public; in fact it is far better for them to be private to
lower the chances of public symbol clashes between different components.

<P>
See sections <A HREF="node4.html#sec:GridInitialize">15.2.2</A>, <A HREF="node4.html#sec:GridRun">15.2.3</A>,
<A HREF="node4.html#sec:GridFinalize">15.2.4</A>, and <A HREF="node4.html#sec:CplInitialize">16.2.2</A>, <A HREF="node4.html#sec:CplRun">16.2.3</A>,
<A HREF="node4.html#sec:CplFinalize">16.2.4</A> for examples of how to write entry points for the 
standard ESMF Component methods.

<P>

<H3><A NAME="SECTION04024500000000000000"></A>
<A NAME="sec:AppDriverSetVM"></A>
<BR>
14.4.5 User-code <TT>SetVM</TT> method
</H3>

<P>
When the AppDriver or parent component code calls
<TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT> it has the option to specify a 
<TT>petList</TT> argument. All of the parent PETs contained in this list become
resources of the child component. By default all of the parent PETs are 
provided to the child component.

<P>
Unless the optional <TT>contextflag</TT> argument is used during 
<TT>ESMF_&lt;Grid/Cpl&gt;CompCreate()</TT>, to indicate that the child component will
execute in the same VM as the parent, the child component has the option
to set certain aspects of how the provided resources are to be used when
executing child component methods. The resources provided via the parent PETs
are the associated processing elements (PEs) and virtual address spaces (VASs).

<P>
The optional user-written set vm routine is called from the parent
through the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> library code, and is the only
place where the child component can set aspects of its own VM before it is 
started up. The child component's VM must be running before its set services
routine can be called, and thus the optional <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT>
call must be placed <EM>before</EM> <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>.

<P>
If called by the parent, the user-code set vm routine has the option to
specify how the PETs of the child component share the provided parent PEs.
Further, PETs on the same single system image can be set to run multi-threaded,
within a reduced number of VAS, allowing a component to leverage shared memory
concepts.

<P>
Sections <A HREF="node4.html#sec:GridSetVM">15.2.5</A> and <A HREF="node4.html#sec:CplSetVM">16.2.5</A> provide examples for
simple user-written set vm routines.

<P>

<P>

<H1><A NAME="SECTION04030000000000000000">
15 GridComp Class</A>
</H1>

<P>

<H2><A NAME="SECTION04031000000000000000">
15.1 Description</A>
</H2>

<A NAME="sec:GridComp"></A>

In Earth system modeling, the most natural way to think about an ESMF 
Gridded Component, or <TT>ESMF_GridComp</TT>, is as a piece of code 
representing a particular physical domain, such as an atmospheric 
model or an ocean model.  Gridded Components may also represent individual
processes, such as radiation or chemistry.  It's up to the application
writer to decide how deeply to ``componentize.''

Earth system software components tend to share a number of basic 
features.  Most ingest and produce a variety of physical fields, refer to 
a (possibly noncontiguous) spatial region and a grid that is 
partitioned across a set of computational resources, and require 
a clock for things like stepping a governing set of PDEs forward in time.  
Most can also be divided into distinct initialize, run, and finalize 
computational phases.  These common characteristics are used 
within ESMF to define a Gridded Component data structure that 
is tailored for Earth system modeling and yet is still flexible
enough to represent a variety of domains.

A well designed Gridded Component does not store information 
internally about how it couples to other Gridded Components.  That
allows it to be used in different contexts without changes to source
code.  The idea here is to avoid situations in which slightly
different versions of the same model source are maintained for use in 
different contexts - standalone vs. coupled versions, for example.
Data is passed in and out of Gridded Components using an ESMF State,
this is described in Section&nbsp;<A HREF="node4.html#sec:State">17.1</A>.

An ESMF Gridded Component has two parts, one which is user-written
and another which is part of the framework.  The user-written
part is software that represents a physical domain or performs some
other computational function.  It forms the body of the Gridded 
Component.  It may be a piece of legacy code, or it may be developed 
expressly for use with ESMF.  It must contain routines with
standard ESMF interfaces that can be called to initialize, run, and
finalize the Gridded Component.  These routines can have separate 
callable phases, such as distinct first and second initialization steps.

ESMF provides the Gridded Component derived type, 
<TT>ESMF_GridComp</TT>.  An <TT>ESMF_GridComp</TT> must be created 
for every portion of the application that will be represented 
as a separate component.  For example, in a climate model, there may 
be Gridded Components representing the land, ocean, sea ice, and 
atmosphere.  If the application contains an ensemble of identical 
Gridded Components, every one has its own associated <TT>ESMF_GridComp</TT>.
Each Gridded Component has its own name and is allocated
a set of computational resources, in the form of an ESMF Virtual
Machine, or <TT>VM</TT>.

The user-written part of a Gridded Component is associated with an
<TT>ESMF_GridComp</TT> derived type through a routine called 
<TT>ESMF_SetServices()</TT>.
This is a routine that the user must write, and declare public.
Inside the SetServices routine the user must call  
<TT>ESMF_SetEntryPoint()</TT> methods that associate a standard ESMF 
operation with the name of the corresponding Fortran subroutine 
in their user code.

<P>

<H2><A NAME="SECTION04032000000000000000">
15.2 Use and Examples</A>
</H2>

<P>
A Gridded Component is a computational entity which consumes and produces data. It uses a State object to exchange data between itself and other Components. It uses a Clock object to manage time, and a VM to describe its own and its child components' computational resources.

<P>
This section shows how to create Gridded Components.  For demonstrations
of the use of Gridded Components, see the system tests that are bundled with the ESMF software
distribution.  These can be found in the directory <TT>esmf/src/system_tests</TT>.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04032100000000000000">
15.2.1 Implement a user-code <TT>SetServices</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridSetServ"></A>
<P>
Every <TT>ESMF_GridComp</TT> is required to provide and document
   a public set services routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_GridComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set services routine must call the ESMF method 
   <TT>ESMF_GridCompSetEntryPoint()</TT> to
   register with the framework what user-code subroutines should be called 
   to initialize, run, and finalize the component.  There are
   additional routines which can be registered as well, for checkpoint
   and restart functions.

<P>
Note that the actual subroutines being registered do not have to be
   public to this module; only the set services routine itself must
   be available to be used by other code. 

<P>
<PRE>
    ! Example Gridded Component
    module ESMF_GriddedCompEx
    
    ! ESMF Framework module
    use ESMF
    implicit none
    public GComp_SetServices
    public GComp_SetVM

    contains

    subroutine GComp_SetServices(comp, rc)
      type(ESMF_GridComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional

      ! Set the entry points for standard ESMF Component methods
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_INITIALIZE, &amp;
                                userRoutine=GComp_Init, rc=rc)
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_RUN, &amp;
                                userRoutine=GComp_Run, rc=rc)
      call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_FINALIZE, &amp;
                                userRoutine=GComp_Final, rc=rc)

      rc = ESMF_SUCCESS

    end subroutine
</PRE>

<P>

<P>

<H3><A NAME="SECTION04032200000000000000">
15.2.2 Implement a user-code <TT>Initialize</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridInitialize"></A>
<P>
When a higher level component is ready to begin using an 
   <TT>ESMF_GridComp</TT>, it will call its initialize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
At initialization time the component can allocate data space, open
   data files, set up initial conditions; anything it needs to do to
   prepare to run.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine GComp_Init(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Init starting"

      ! This is where the model specific setup code goes.  
 
      ! If the initial Export state needs to be filled, do it here.
      !call ESMF_StateAdd(exportState, field, rc)
      !call ESMF_StateAdd(exportState, bundle, rc)
      print *, "Gridded Comp Init returning"
   
      rc = ESMF_SUCCESS

    end subroutine GComp_Init
</PRE>

<P>

<P>

<H3><A NAME="SECTION04032300000000000000">
15.2.3 Implement a user-code <TT>Run</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridRun"></A>
<P>
During the execution loop, the run routine may be called many times.
   Each time it should read data from the <TT>importState</TT>, use the
   <TT>clock</TT> to determine what the current time is in the calling
   component, compute new values or process the data,
   and produce any output and place it in the <TT>exportState</TT>. 

<P>
When a higher level component is ready to use the <TT>ESMF_GridComp</TT>
   it will call its run routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
It is expected that this is where the bulk of the model computation
   or data analysis will occur.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine GComp_Run(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Run starting"
      ! call ESMF_StateGet(), etc to get fields, bundles, arrays
      !  from import state.

      ! This is where the model specific computation goes.

      ! Fill export state here using ESMF_StateAdd(), etc

      print *, "Gridded Comp Run returning"

      rc = ESMF_SUCCESS

    end subroutine GComp_Run
</PRE>

<P>

<P>

<H3><A NAME="SECTION04032400000000000000">
15.2.4 Implement a user-code <TT>Finalize</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridFinalize"></A>
<P>
At the end of application execution, each <TT>ESMF_GridComp</TT> should
   deallocate data space, close open files, and flush final results.
   These functions should be placed in a finalize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned.

<P>
<PRE>
    subroutine GComp_Final(comp, importState, exportState, clock, rc)
      type(ESMF_GridComp)   :: comp                   ! must not be optional
      type(ESMF_State)      :: importState            ! must not be optional
      type(ESMF_State)      :: exportState            ! must not be optional
      type(ESMF_Clock)      :: clock                  ! must not be optional
      integer, intent(out)  :: rc                     ! must not be optional

      print *, "Gridded Comp Final starting"
    
      ! Add whatever code here needed

      print *, "Gridded Comp Final returning"
   
      rc = ESMF_SUCCESS

    end subroutine GComp_Final
</PRE>

<P>

<P>

<H3><A NAME="SECTION04032500000000000000">
15.2.5 Implement a user-code <TT>SetVM</TT> routine</A>
</H3>

<P>
<A NAME="sec:GridSetVM"></A>
<P>
Every <TT>ESMF_GridComp</TT> can optionally provide and document
   a public set vm routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_GridComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set vm routine is the only place where the child component can
   use the <TT>ESMF_GridCompSetVMMaxPEs()</TT>, or
   <TT>ESMF_GridCompSetVMMaxThreads()</TT>, or 
   <TT>ESMF_GridCompSetVMMinThreads()</TT> call to modify aspects of its own VM.

<P>
A component's VM is started up right before its set services routine is
   entered. <TT>ESMF_GridCompSetVM()</TT> is executing in the parent VM, and must
   be called <EM>before</EM> <TT>ESMF_GridCompSetServices()</TT>. 

<P>
<PRE>
    subroutine GComp_SetVM(comp, rc)
      type(ESMF_GridComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional
      
      type(ESMF_VM) :: vm
      logical :: pthreadsEnabled
      
      ! Test for Pthread support, all SetVM calls require it
      call ESMF_VMGetGlobal(vm, rc=rc)
      call ESMF_VMGet(vm, pthreadsEnabledFlag=pthreadsEnabled, rc=rc)

      if (pthreadsEnabled) then
        ! run PETs single-threaded
        call ESMF_GridCompSetVMMinThreads(comp, rc=rc)
      endif

      rc = ESMF_SUCCESS

    end subroutine

    end module ESMF_GriddedCompEx
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04032600000000000000">
15.2.6 Set and Get the Internal State</A>
</H3>  

<P>
ESMF provides the concept of an Internal State that is associated with
     a Component. Through the Internal State API a user can attach a private
     data block to a Component, and later retrieve a pointer to this memory
     allocation. Setting and getting of Internal State information are
     supported from anywhere in the Component's SetServices, Initialize, Run,
     or Finalize code.

<P>
The code below demonstrates the basic Internal State API
     of <TT>ESMF_&lt;Grid|Cpl&gt;SetInternalState()</TT> and
     <TT>ESMF_&lt;Grid|Cpl&gt;GetInternalState()</TT>. Notice that an extra level of
     indirection to the user data is necessary!

<P>
<PRE>
  ! ESMF Framework module
  use ESMF
  implicit none
  
  type(ESMF_GridComp) :: comp
  integer :: rc, finalrc

  ! Internal State Variables
  type testData
  sequence
    integer :: testValue
    real    :: testScaling
  end type

  type dataWrapper
  sequence
    type(testData), pointer :: p
  end type

  type(dataWrapper) :: wrap1, wrap2
  type(testData), target :: data
  type(testData), pointer :: datap  ! extra level of indirection

  finalrc = ESMF_SUCCESS
!-------------------------------------------------------------------------
        
  call ESMF_Initialize(defaultlogfilename="InternalStateEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

!-------------------------------------------------------------------------

  !  Creation of a Component
  comp = ESMF_GridCompCreate(name="test", rc=rc)  
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

!-------------------------------------------------------------------------
! This could be called, for example, during a Component's initialize phase.

    ! Initialize private data block
  data%testValue = 4567
  data%testScaling = 0.5

  ! Set Internal State
  wrap1%p =&gt; data
  call ESMF_GridCompSetInternalState(comp, wrap1, rc)
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

!-------------------------------------------------------------------------
! This could be called, for example, during a Component's run phase.

  ! Get Internal State
  call ESMF_GridCompGetInternalState(comp, wrap2, rc)
  if (rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE 

  ! Access private data block and verify data
  datap =&gt; wrap2%p 
  if ((datap%testValue .ne. 4567) .or. (datap%testScaling .ne. 0.5)) then
    print *, "did not get same values back"
    finalrc = ESMF_FAILURE
  else
    print *, "got same values back from GetInternalState as original"
  endif
</PRE>

<P>

<P>

<P>

<P>
When working with ESMF Internal States it is important to consider the
     applying scoping rules. The user must ensure that the private data block,
     that is being referenced, persists for the entire access period. This is
     not an issue in the previous example, where the private data block was
     defined on the scope of the main program. However, the Internal State 
     construct is often useful inside of Component modules to hold Component
     specific data between calls. One option to ensure persisting private data
     blocks is to use the Fortran SAVE attribute either on local or module
     variables. A second option, illustrated in the following example, is to 
     use Fortran pointers and user controlled memory management via allocate()
     and deallocate() calls.

<P>
One situation where the Internal State is useful is in the
     creation of ensembles of the same Component. In this case it can 
     be tricky to distinguish which data, held in saved module variables, 
     belongs to which ensemble member - especially if the ensemble members
     are executing on the same set of PETs. The Internal State solves this
     problem by providing a handle to instance specific data allocations.

<P>
<PRE>
module user_mod

  use ESMF

  implicit none
  
  ! module variables
  private

  ! Internal State Variables
  type testData
  sequence
    integer       :: testValue        ! scalar data
    real          :: testScaling      ! scalar data
    real, pointer :: testArray(:)     ! array data
  end type

  type dataWrapper
  sequence
    type(testData), pointer :: p
  end type
</PRE>

<P>
<PRE>
  contains !--------------------------------------------------------------------
</PRE>

<P>
<PRE>
  subroutine mygcomp_init(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data
    integer :: i

    rc = ESMF_SUCCESS
    
    ! Allocate private data block
    allocate(data)

    ! Initialize private data block
    data%testValue = 4567         ! initialize scalar data
    data%testScaling = 0.5        ! initialize scalar data
    allocate(data%testArray(10))  ! allocate array data
    
    do i=1, 10
      data%testArray(i) = real(i) ! initialize array data
    enddo
    
    ! In a real ensemble application the initial data would be set to 
    ! something unique for this ensemble member. This could be 
    ! accomplished for example by reading a member specific config file 
    ! that was specified by the driver code. Alternatively, Attributes, 
    ! set by the driver, could be used to label the Component instances 
    ! as specific ensemble members.
    
    ! Set Internal State
    wrap%p =&gt; data
    call ESMF_GridCompSetInternalState(gcomp, wrap, rc)

  end subroutine !--------------------------------------------------------------
  
  subroutine mygcomp_run(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data
    logical :: match = .true.
    integer :: i
    
    rc = ESMF_SUCCESS

    ! Get Internal State
    call ESMF_GridCompGetInternalState(gcomp, wrap, rc)
    if (rc/=ESMF_SUCCESS) return

    ! Access private data block and verify data
    data =&gt; wrap%p 
    if (data%testValue .ne. 4567) match = .false.   ! test scalar data
    if (data%testScaling .ne. 0.5) match = .false.  ! test scalar data
    do i=1, 10
      if (data%testArray(i) .ne. real(i)) match = .false. ! test array data
    enddo
    
    if (match) then
      print *, "got same values back from GetInternalState as original"
    else
      print *, "did not get same values back"
      rc = ESMF_FAILURE
    endif
    
  end subroutine !--------------------------------------------------------------

  subroutine mygcomp_final(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: istate, estate
    type(ESMF_Clock):: clock
    integer, intent(out):: rc

    ! Local variables
    type(dataWrapper) :: wrap
    type(testData), pointer :: data

    rc = ESMF_SUCCESS
    
    ! Get Internal State
    call ESMF_GridCompGetInternalState(gcomp, wrap, rc)
    if (rc/=ESMF_SUCCESS) return
    
    ! Deallocate private data block
    data =&gt; wrap%p 
    deallocate(data%testArray)  ! deallocate array data
    deallocate(data)
    
  end subroutine !--------------------------------------------------------------


end module
</PRE>

<P>

<P>

<H2><A NAME="SECTION04033000000000000000">
15.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No optional arguments.</B> User-written routines called by SetServices,
and registered for Initialize, Run and Finalize, <EM>must not</EM> declare any
of the arguments as optional.

<P>
</LI>
<LI><B>Namespace isolation.</B>
If possible, Gridded Components should attempt to make 
all data private, so public names do not interfere with data 
in other components.

<P>
</LI>
<LI><B>Single execution mode.</B>
It is not expected that a single Gridded Component be able 
to function in both sequential and concurrent modes, although 
Gridded Components of different types can be nested. For example,
a concurrently called Gridded Component can contain several nested 
sequential Gridded Components. 

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION04034000000000000000">
15.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04034100000000000000">
15.4.1 ESMF_GridCompAssignment(=) - GridComp assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     gridcomp1 = gridcomp2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp) :: gridcomp1
     type(ESMF_GridComp) :: gridcomp2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign gridcomp1 as an alias to the same ESMF GridComp object in memory
     as gridcomp2. If gridcomp2 is invalid, then gridcomp1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>gridcomp1</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>gridcomp2</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034200000000000000">
15.4.2 ESMF_GridCompOperator(==) - GridComp equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (gridcomp1 == gridcomp2) then ... endif
               OR
     result = (gridcomp1 == gridcomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in) :: gridcomp1
     type(ESMF_GridComp), intent(in) :: gridcomp2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether gridcomp1 and gridcomp2 are valid aliases to the same ESMF
     GridComp object in memory. For a more general comparison of two ESMF GridComps,
     going beyond the simple alias test, the ESMF_GridCompMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>gridcomp1</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>gridcomp2</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034300000000000000">
15.4.3 ESMF_GridCompOperator(/=) - GridComp not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (gridcomp1 /= gridcomp2) then ... endif
               OR
     result = (gridcomp1 /= gridcomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in) :: gridcomp1
     type(ESMF_GridComp), intent(in) :: gridcomp2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether gridcomp1 and gridcomp2 are <I>not</I> valid aliases to the
     same ESMF GridComp object in memory. For a more general comparison of two ESMF
     GridComps, going beyond the simple alias test, the ESMF_GridCompMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>gridcomp1</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>gridcomp2</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034400000000000000">
15.4.4 ESMF_GridCompCreate - Create a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_GridCompCreate(grid, &amp;
     config, configFile, clock, petList, contextflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_GridComp) :: ESMF_GridCompCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Grid),         intent(in),    optional :: grid
     type(ESMF_Config),       intent(in),    optional :: config
     character(len=*),        intent(in),    optional :: configFile
     type(ESMF_Clock),        intent(in),    optional :: clock
     integer,                 intent(in),    optional :: petList(:)
     type(ESMF_Context_Flag), intent(in),    optional :: contextflag
     character(len=*),        intent(in),    optional :: name
     integer,                 intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This interface creates an <TT>ESMF_GridComp</TT> object. By default, a
   separate VM context will be created for each component.  This implies
   creating a new MPI communicator and allocating additional memory to
   manage the VM resources. When running on a large number of processors,
   creating a separate VM for each component could be both time and memory
   inefficient.  If the application is sequential, i.e., each component is
   running on all the PETs of the global VM, it will be more efficient to use
   the global VM instead of creating a new one.  This can be done by setting
   <TT>contextflag</TT> to ESMF_CONTEXT_PARENT_VM.

<P>
The return value is the new <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Default <TT>ESMF_Grid</TT> associated with this <TT>gridcomp</TT>. Note that
     it is perfectly ok to not pass a Grid in for this argument. This argument is 
     simply a convenience for the user to allow them to associate a Grid
     with a component for their later use. The grid isn't actually used
     in the component code. 
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>An already-created <TT>ESMF_Config</TT> configuration object
     from which the new component
     can read in namelist-type information to set parameters for this run.
     If both are specified, this object takes priority over <TT>configFile</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>The filename of an <TT>ESMF_Config</TT> format file.  
     If specified, this file is opened an <TT>ESMF_Config</TT> configuration
     object is created for the file, and attached to the new component.  
     The user can call <TT>ESMF_GridCompGet()</TT> to get and use the object.
     If both are specified, the <TT>config</TT> object takes priority
     over this one.

</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Component-specific <TT>ESMF_Clock</TT>.  This clock is available to be
     queried and updated by the new <TT>ESMF_GridComp</TT> as it chooses.
     This should
     not be the parent component clock, which should be maintained and passed
     down to the initialize/run/finalize routines separately.

</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List of parent <TT>PET</TT>s given to the created child component by the
     parent component. If <TT>petList</TT> is not specified all of the
     parent <TT>PET</TT>s will be given to the child component. The order of
     PETs in <TT>petList</TT> determines how the child local PETs refer back to
     the parent PETs.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Specify the component's VM context. The default context is
     <TT>ESMF_CONTEXT_OWN_VM</TT>. See section <A HREF="node2.html#const:contextflag">9.9</A> for a
     complete list of valid flags.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the newly-created <TT>ESMF_GridComp</TT>.  This name can be altered
     from within the <TT>ESMF_GridComp</TT> code once the initialization routine
     is called.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034500000000000000">
15.4.5 ESMF_GridCompDestroy - Release resources associated with a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompDestroy(gridcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)          :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_GridComp</TT>, releasing the resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Release all resources associated with this <TT>ESMF_GridComp</TT>
     and mark the object as invalid.  It is an error to pass this
     object into any other routines after being destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034600000000000000">
15.4.6 ESMF_GridCompFinalize - Call the GridComp's finalize routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompFinalize(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user-supplied finalization routine for 
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to call finalize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accommodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default
     is 1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034700000000000000">
15.4.7 ESMF_GridCompGet - Get GridComp information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompGet(gridcomp, gridIsPresent, grid, &amp;
     importStateIsPresent, importState, exportStateIsPresent, exportState, &amp;
     configIsPresent, config, configFileIsPresent, configFile, &amp;
     clockIsPresent, clock, localPet, petCount, contextflag, &amp;
     currentMethod, currentPhase, comptype, vmIsPresent, vm, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),      intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                  intent(out), optional :: gridIsPresent
     type(ESMF_Grid),          intent(out), optional :: grid
     logical,                  intent(out), optional :: importStateIsPresent
     type(ESMF_State),         intent(out), optional :: importState
     logical,                  intent(out), optional :: exportStateIsPresent
     type(ESMF_State),         intent(out), optional :: exportState    
     logical,                  intent(out), optional :: configIsPresent
     type(ESMF_Config),        intent(out), optional :: config
     logical,                  intent(out), optional :: configFileIsPresent
     character(len=*),         intent(out), optional :: configFile
     logical,                  intent(out), optional :: clockIsPresent
     type(ESMF_Clock),         intent(out), optional :: clock
     integer,                  intent(out), optional :: localPet
     integer,                  intent(out), optional :: petCount
     type(ESMF_Context_Flag),  intent(out), optional :: contextflag
     type(ESMF_Method_Flag),   intent(out), optional :: currentMethod
     integer,                  intent(out), optional :: currentPhase
     type(ESMF_CompType_Flag), intent(out), optional :: comptype
     logical,                  intent(out), optional :: vmIsPresent
     type(ESMF_VM),            intent(out), optional :: vm
     character(len=*),         intent(out), optional :: name
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get information about an <TT>ESMF_GridComp</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object being queried.
   
</DD>
<DT><STRONG>[gridIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>grid</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Return the associated Grid.
     It is an error to query for the Grid if none is associated with
     the GridComp. If unsure, get <TT>gridIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[importStateIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>importState</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD>Return the associated import State.
     It is an error to query for the import State if none is associated with
     the GridComp. If unsure, get <TT>importStateIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[exportStateIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>exportState</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD>Return the associated export State.
     It is an error to query for the export State if none is associated with
     the GridComp. If unsure, get <TT>exportStateIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[configIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>config</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Return the associated Config.
     It is an error to query for the Config if none is associated with
     the GridComp. If unsure, get <TT>configIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[configFileIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>configFile</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Return the associated configuration filename.
     It is an error to query for the configuration filename if none is associated with
     the GridComp. If unsure, get <TT>configFileIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[clockIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>clock</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Return the associated Clock.
     It is an error to query for the Clock if none is associated with
     the GridComp. If unsure, get <TT>clockIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[localPet]</STRONG></DT>
<DD>Return the local PET id within the <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>[petCount]</STRONG></DT>
<DD>Return the number of PETs in the the <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Return the <TT>ESMF_Context_Flag</TT> for this <TT>ESMF_GridComp</TT>.
     See section <A HREF="node2.html#const:contextflag">9.9</A> for a complete list of valid flags.
   
</DD>
<DT><STRONG>[currentMethod]</STRONG></DT>
<DD>Return the current <TT>ESMF_Method_Flag</TT> of the <TT>ESMF_GridComp</TT>
     execution. See section <A HREF="node2.html#const:method">9.31</A>  for a complete list of valid
     options.
   
</DD>
<DT><STRONG>[currentPhase]</STRONG></DT>
<DD>Return the current <TT>phase</TT> of the <TT>ESMF_GridComp</TT> execution.
   
</DD>
<DT><STRONG>[comptype]</STRONG></DT>
<DD>Return the Component type: <TT>ESMF_COMPTYPE_GRID</TT> or 
     <TT>ESMF_COMPTYPE_CPL</TT>.
   
</DD>
<DT><STRONG>[vmIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>vm</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Return the associated VM.
     It is an error to query for the VM if none is associated with
     the GridComp. If unsure, get <TT>vmIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Return the name of the <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034800000000000000">
15.4.8 ESMF_GridCompGetInternalState - Get private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompGetInternalState(gridcomp, wrappedDataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)             :: gridcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_GridComp</TT> at any time after 
   <TT>ESMF_GridCompSetInternalState</TT> has been called.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by this call.
   When running multiple instantiations of an <TT>ESMF_GridComp</TT>, 
   for example during ensemble runs, 
   it may be simpler to maintain private data specific to 
   each run with private data blocks.  A corresponding 
   <TT>ESMF_GridCompSetInternalState</TT> call sets the data pointer to 
   this block, and this call retrieves the data pointer.
   Note that the <TT>wrappedDataPointer</TT> argument needs to be a derived type
   which contains only a pointer of the type of the data block defined
   by the user.  When making this call the pointer needs to be unassociated.
   When the call returns, the pointer will now reference the original
   data block which was set during the previous call to
   <TT>ESMF_GridCompSetInternalState</TT>.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_GridCompSetInternalState</TT> will be accessible.

<P>
CAUTION: This method does not have an explicit Fortran interface. Do not 
   specify argument keywords when calling this method!

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>wrappedDataPointer</STRONG></DT>
<DD>A derived type (wrapper), containing only an unassociated pointer 
     to the private data block.
     The framework will fill in the pointer. When this call returns, the
     pointer is set to the same address set during the last
     <TT>ESMF_GridCompSetInternalState</TT> call.
     This level of indirection is needed to reliably set and retrieve 
     the data block no matter which architecture or compiler is used.  
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04034900000000000000">
15.4.9 ESMF_GridCompInitialize - Call the GridComp's initialize routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompInitialize(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user initialization routine for 
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call initialize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.
     Single-phase routines require only one invocation to complete
     their work.
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341000000000000000">
15.4.10 ESMF_GridCompIsPetLocal - Inquire if this GridComp is to execute on the calling PET</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_GridCompIsPetLocal(gridcomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_GridCompIsPetLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Inquire if this <TT>ESMF_GridComp</TT> object is to execute on the calling PET.

<P>
The return value is <TT>.true.</TT> if the component is to execute on the 
   calling PET, <TT>.false.</TT> otherwise.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341100000000000000">
15.4.11 ESMF_GridCompPrint - Print GridComp information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompPrint(gridcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about an <TT>ESMF_GridComp</TT> to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to print.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341200000000000000">
15.4.12 ESMF_GridCompReadRestart - Call the GridComp's read restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompReadRestart(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user read restart routine for 
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341300000000000000">
15.4.13 ESMF_GridCompRun - Call the GridComp's run routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompRun(gridcomp, &amp;
     importState, exportState,&amp;
     clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user run routine for 
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341400000000000000">
15.4.14 ESMF_GridCompSet - Set or reset information about the GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSet(gridcomp, grid, config, &amp;
     configFile, clock, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Grid),     intent(in),  optional :: grid
     type(ESMF_Config),   intent(in),  optional :: config
     character(len=*),    intent(in),  optional :: configFile
     type(ESMF_Clock),    intent(in),  optional :: clock
     character(len=*),    intent(in),  optional :: name
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets or resets information about an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to change.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>Set the <TT>ESMF_Grid</TT> associated with the <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Set the configuration information for the <TT>ESMF_GridComp</TT> from
     this already created <TT>ESMF_Config</TT> object.   
     If specified, takes priority over <TT>configFile</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Set the configuration filename for this <TT>ESMF_GridComp</TT>.
     An <TT>ESMF_Config</TT> object will be created for this file
     and attached to the <TT>ESMF_GridComp</TT>.  Superceeded by <TT>config</TT>
     if both are specified.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Set the private clock for this <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Set the name of the <TT>ESMF_GridComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341500000000000000">
15.4.15 ESMF_GridCompSetEntryPoint - Set user routine as entry point for standard GridComp method</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompSetEntryPoint(gridcomp, methodflag, &amp;
     userRoutine, phase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(inout)         :: gridcomp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: phase
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Registers a user-supplied <TT>userRoutine</TT> as the entry point for one of the
   predefined Component <TT>methodflag</TT>s. After this call the <TT>userRoutine</TT>
   becomes accessible via the standard Component method API.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>methodflag</STRONG></DT>
<DD>One of a set of predefined Component methods - e.g.
     <TT>ESMF_METHOD_INITIALIZE</TT>, <TT>ESMF_METHOD_RUN</TT>, 
     <TT>ESMF_METHOD_FINALIZE</TT>. See section <A HREF="node2.html#const:method">9.31</A> 
     for a complete list of valid method options.

</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated for this Component 
     <TT>method</TT>. The subroutine must be either a module scope procedure,
     or an external procedure that has a matching interface block specified
     for it. It must not be an internal procedure which is contained
     within another procedure. Argument types, intent and order must match
     the interface signature, and must not have the <TT>optional</TT> attribute.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>The <TT>phase</TT> number for multi-phase methods. For single phase 
     methods the <TT>phase</TT> argument can be omitted. The default setting
     is 1.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341600000000000000">
15.4.16 ESMF_GridCompSetInternalState - Set private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetInternalState(gridcomp, wrappedDataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)             :: gridcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_GridComp</TT> at any time, but 
   expected to be
   most useful when called during the registration process, or initialization.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by subsequent calls.
   When running multiple instantiations of an <TT>ESMF_GridComp</TT>, 
   for example during
   ensemble runs, it may be simpler to maintain private data specific to 
   each run with private data blocks.  A corresponding 
   <TT>ESMF_GridCompGetInternalState</TT> call retrieves the data pointer.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_GridCompSetInternalState</TT> will be accessible.

<P>
CAUTION: This method does not have an explicit Fortran interface. Do not 
   specify argument keywords when calling this method!

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>An <TT>ESMF_GridComp</TT> object.
   
</DD>
<DT><STRONG>wrappedDataPointer</STRONG></DT>
<DD>A pointer to the private data block, wrapped in a derived type which
     contains only a pointer to the block.  This level of indirection is
     needed to reliably set and retrieve the data block no matter which
     architecture or compiler is used.  
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341700000000000000">
15.4.17 ESMF_GridCompSetServices - Call user routine to register GridComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompSetServices(gridcomp, &amp;
     userRoutine, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     interface
       subroutine userRoutine(gridcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call into user provided <TT>userRoutine</TT> which is responsible for
   setting Component's Initialize(), Run(), and Finalize() services.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The Component writer must supply a subroutine with the exact interface 
     shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must match.
     The subroutine must be either a module scope procedure, or an external
     procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls
     to <TT>ESMF_GridCompSetEntryPoint()</TT> to preset callback routines for
     standard Component Initialize(), Run(), and Finalize() methods.

</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341800000000000000">
15.4.18 ESMF_GridCompSetServices - Call user routine, located in shared object, to register GridComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCompSetServices()
   recursive subroutine ESMF_GridCompSetServicesShObj(gridcomp, userRoutine, &amp;
     sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call into user provided routine which is responsible for setting
   Component's Initialize(), Run(), and Finalize() services. The named
   <TT>userRoutine</TT> must exist in the shared object file specified in the
   <TT>sharedObj</TT> argument. All of the platform specific details about 
   dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface 
     shown for <TT>userRoutine</TT> below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     The subroutine must be either a module scope procedure, or an external
     procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface
     	subroutine userRoutine(gridcomp, rc)
     	  type(ESMF_GridComp)  :: gridcomp   ! must not be optional
     	  integer, intent(out) :: rc	     ! must not be optional
     	end subroutine
       end interface
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls
     to <TT>ESMF_GridCompSetEntryPoint()</TT> to preset callback routines for
     standard Component Initialize(), Run(), and Finalize() methods.

</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040341900000000000000">
15.4.19 ESMF_GridCompSetVM - Call user routine to set GridComp VM properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompSetVM(gridcomp, userRoutine, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     interface
       subroutine userRoutine(gridcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's VM properties.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The Component writer must supply a subroutine with the exact interface 
     shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must match.
     The subroutine must be either a module scope procedure, or an external
     procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.

<P>
The subroutine, when called by the framework, is expected to use any of the
     <TT>ESMF_GridCompSetVMxxx()</TT> methods to set the properties of the VM
     associated with the Gridded Component.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342000000000000000">
15.4.20 ESMF_GridCompSetVM - Call user routine, located in shared object, to set GridComp VM properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCompSetVM()
   recursive subroutine ESMF_GridCompSetVMShObj(gridcomp, userRoutine, &amp;
     sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's VM properties. The named <TT>userRoutine</TT> must exist
   in the shared object file specified in the <TT>sharedObj</TT> argument. All of
   the platform specific details about dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD>Gridded Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface 
     shown for <TT>userRoutine</TT> below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     The subroutine must be either a module scope procedure, or an external
     procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface
     	subroutine userRoutine(gridcomp, rc)
     	  type(ESMF_GridComp)  :: gridcomp    ! must not be optional
     	  integer, intent(out) :: rc	      ! must not be optional
     	end subroutine
       end interface
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The subroutine, when called by the framework, is expected to use any of the
     <TT>ESMF_GridCompSetVMxxx()</TT> methods to set the properties of the VM
     associated with the Gridded Component.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342100000000000000">
15.4.21 ESMF_GridCompSetVMMaxPEs - Associate PEs with PETs in GridComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMaxPEs(gridcomp, &amp;
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Attempts to associate up to <TT>maxPeCountPerPet</TT> PEs with each PET. Only
     PEs that are located on the same single system image (SSI) can be associated
     with the same PET. Within this constraint the call tries to get as close as
     possible to the number specified by <TT>maxPeCountPerPet</TT>.

<P>
The other constraint to this call is that the number of PEs is preserved.
     This means that the child Component in the end is associated with as many
     PEs as the parent Component provided to the child. The number of child PETs 
     however is adjusted according to the above rule.

<P>
The typical use of <TT>ESMF_GridCompSetVMMaxPEs()</TT> is to allocate
     multiple PEs per PET in a Component for user-level threading, e.g. OpenMP.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPeCountPerPet]</STRONG></DT>
<DD>Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342200000000000000">
15.4.22 ESMF_GridCompSetVMMaxThreads - Set multi-threaded PETs in GridComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMaxThreads(gridcomp, &amp;
     maxPetCountPerVas, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPetCountPerVas
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Attempts to provide <TT>maxPetCountPerVas</TT> threaded PETs in each 
     virtual address space (VAS). Only as many threaded PETs as there are PEs
     located on the single system image (SSI) can be associated with the VAS. 
     Within this constraint the call tries to get as close as possible to the 
     number specified by <TT>maxPetCountPerVas</TT>.

<P>
The other constraint to this call is that the number of PETs is preserved.
     This means that the child Component in the end is associated with as many
     PETs as the parent Component provided to the child. The threading level of
     the child PETs however is adjusted according to the above rule.

<P>
The typical use of <TT>ESMF_GridCompSetVMMaxThreads()</TT> is to run a 
     Component multi-threaded with groups of PETs executing within a common
     virtual address space.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPetCountPerVas]</STRONG></DT>
<DD>Maximum number of threaded PETs in each virtual address space (VAS). 
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342300000000000000">
15.4.23 ESMF_GridCompSetVMMinThreads - Set a reduced threading level in GridComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompSetVMMinThreads(gridcomp, &amp;
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_GridComp</TT>.
     Reduces the number of threaded PETs in each VAS. The <TT>max</TT> argument
     may be specified to limit the maximum number of PEs that a single PET 
     can be associated with.

<P>
Several constraints apply: 1) the number of PEs cannot change, 2) PEs
     cannot migrate between single system images (SSIs), 3) the number of PETs
     cannot increase, only decrease, 4) PETs cannot migrate between virtual
     address spaces (VASs), nor can VASs migrate between SSIs.

<P>
The typical use of <TT>ESMF_GridCompSetVMMinThreads()</TT> is to run a 
     Component across a set of single-threaded PETs.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPeCountPerPet]</STRONG></DT>
<DD>Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342400000000000000">
15.4.24 ESMF_GridCompValidate - Check validity of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompValidate(gridcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Currently all this method does is to check that the <TT>gridcomp</TT>
   was created.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to validate.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342500000000000000">
15.4.25 ESMF_GridCompWait - Wait for a GridComp to return</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridCompWait(gridcomp, syncflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)         :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Sync_Flag), intent(in),  optional :: syncflag
     integer,              intent(out), optional :: userRc
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
When executing asychronously, wait for an <TT>ESMF_GridComp</TT> to return.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to wait for.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040342600000000000000">
15.4.26 ESMF_GridCompWriteRestart - Call the GridComp's write restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_GridCompWriteRestart(gridcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),  intent(inout)           :: gridcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user write restart routine for 
   an <TT>ESMF_GridComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gridcomp</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H1><A NAME="SECTION04040000000000000000">
16 CplComp Class</A>
</H1>

<P>

<H2><A NAME="SECTION04041000000000000000">
16.1 Description</A>
</H2>

<P>
<A NAME="sec:CplComp"></A>
<P>
In a large, multi-component application such as a weather 
forecasting or climate prediction system running within ESMF, 
physical domains and major system functions are represented 
as Gridded Components 
(see Section <A HREF="node4.html#sec:GridComp">15.1</A>).  A Coupler Component, or 
<TT>ESMF_CplComp</TT>, arranges and executes the data 
transformations between the Gridded Components.  Ideally, 
Coupler Components should contain all the information 
about inter-component communication for an application.
This enables the Gridded Components in the application to be 
used in multiple contexts; that is, used in different coupled 
configurations without changes to their source code. 
For example, the same atmosphere might in one case be coupled 
to an ocean in a hurricane prediction model, and to a 
data assimilation system for numerical weather prediction in
another.  A single Coupler Component can couple 
two or more Gridded Components.

<P>
Like Gridded Components, Coupler Components have two parts, one
that is provided by the user and another that is part of the 
framework.  The user-written portion of the software is the coupling
code necessary for a particular exchange between Gridded Components.  
This portion of the Coupler Component code must be divided into 
separately callable initialize, run, and finalize methods.  The 
interfaces for these methods are prescribed by ESMF.

<P>
The term ``user-written'' is somewhat misleading here, since within 
a Coupler Component the user can leverage ESMF infrastructure 
software for regridding, redistribution, lower-level communications, 
calendar management, and other functions.  However, ESMF is unlikely 
to offer all the software necessary to customize a data transfer
between Gridded Components.  For instance, ESMF does not currently 
offer tools for unit tranformations or time averaging operations, 
so users must manage those operations themselves.

<P>
The second part of a Coupler Component is the <TT>ESMF_CplComp</TT>
derived type within ESMF.  The user must create one of these types
to represent a specific coupling function, such as the regular
transfer of data between a data assimilation system and an 
atmospheric model.  <A NAME="tex2html16"
  HREF="footnode.html#foot5168"><SUP>2</SUP></A>
<P>
The user-written part of a Coupler Component is associated with an
<TT>ESMF_CplComp</TT> derived type through a routine called 
<TT>ESMF_SetServices()</TT>.
This is a routine that the user must write and declare public.
Inside the <TT>ESMF_SetServices()</TT> routine the user must call 
<TT>ESMF_SetEntryPoint()</TT> methods that associate a standard ESMF 
operation with the name of the corresponding Fortran subroutine in 
their user code.  For example, a user routine called ``couplerInit''
might be associated with the standard initialize routine in a 
Coupler Component.

<P>

<H2><A NAME="SECTION04042000000000000000">
16.2 Use and Examples</A>
</H2>

<P>
A Coupler Component manages the transformation of data between Components.
It contains a list of State objects and the operations needed to
make them compatible, including such things as regridding and unit conversion.
Coupler Components are user-written, following prescribed ESMF interfaces
and, wherever desired, using ESMF infrastructure tools.

<P>

<P>

<P>

<H3><A NAME="SECTION04042100000000000000">
16.2.1 Implement a user-code <TT>SetServices</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplSetServ"></A>
<P>
Every <TT>ESMF_CplComp</TT> is required to provide and document
   a public set services routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an 
   <TT>ESMF_CplComp</TT> as the first argument, and 
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set services routine must call the ESMF method 
   <TT>ESMF_CplCompSetEntryPoint()</TT> to
   register with the framework what user-code subroutines should be called
   to initialize, run, and finalize the component.  There are
   additional routines which can be registered as well, for checkpoint
   and restart functions.

<P>
Note that the actual subroutines being registered do not have to be
   public to this module; only the set services routine itself must
   be available to be used by other code. 

<P>
<PRE>
    ! Example Coupler Component
    module ESMF_CouplerEx
    
    ! ESMF Framework module
    use ESMF
    implicit none
    public CPL_SetServices

    contains

    subroutine CPL_SetServices(comp, rc)
      type(ESMF_CplComp)    :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional

      ! Set the entry points for standard ESMF Component methods
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_INITIALIZE, &amp;
                          userRoutine=CPL_Init, rc=rc)
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_RUN, &amp;
                          userRoutine=CPL_Run, rc=rc)
      call ESMF_CplCompSetEntryPoint(comp, ESMF_METHOD_FINALIZE, &amp;
                          userRoutine=CPL_Final, rc=rc)

      rc = ESMF_SUCCESS
    end subroutine
</PRE>

<P>

<P>

<H3><A NAME="SECTION04042200000000000000">
16.2.2 Implement a user-code <TT>Initialize</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplInitialize"></A>
<P>
When a higher level component is ready to begin using an 
   <TT>ESMF_CplComp</TT>, it will call its initialize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
At initialization time the component can allocate data space, open
   data files, set up initial conditions; anything it needs to do to
   prepare to run.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine CPL_Init(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp               ! must not be optional
      type(ESMF_State)      :: importState        ! must not be optional
      type(ESMF_State)      :: exportState        ! must not be optional
      type(ESMF_Clock)      :: clock              ! must not be optional
      integer, intent(out)  :: rc                 ! must not be optional

      print *, "Coupler Init starting"
    
      ! Add whatever code here needed
      ! Precompute any needed values, fill in any inital values
      !  needed in Import States

      rc = ESMF_SUCCESS

      print *, "Coupler Init returning"
   
    end subroutine CPL_Init
</PRE>

<P>

<P>

<H3><A NAME="SECTION04042300000000000000">
16.2.3 Implement a user-code <TT>Run</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplRun"></A>
<P>
During the execution loop, the run routine may be called many times.
   Each time it should read data from the <TT>importState</TT>, use the
   <TT>clock</TT> to determine what the current time is in the calling
   component, compute new values or process the data, 
   and produce any output and place it in the <TT>exportState</TT>.

<P>
When a higher level component is ready to use the <TT>ESMF_CplComp</TT>
   it will call its run routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
It is expected that this is where the bulk of the model computation
   or data analysis will occur.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned. 

<P>
<PRE>
    subroutine CPL_Run(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp              ! must not be optional
      type(ESMF_State)      :: importState       ! must not be optional
      type(ESMF_State)      :: exportState       ! must not be optional
      type(ESMF_Clock)      :: clock             ! must not be optional
      integer, intent(out)  :: rc                ! must not be optional

      print *, "Coupler Run starting"

      ! Add whatever code needed here to transform Export state data
      !  into Import states for the next timestep.  

      rc = ESMF_SUCCESS

      print *, "Coupler Run returning"

    end subroutine CPL_Run
</PRE>

<P>

<P>

<H3><A NAME="SECTION04042400000000000000">
16.2.4 Implement a user-code <TT>Finalize</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplFinalize"></A>
<P>
At the end of application execution, each <TT>ESMF_CplComp</TT> should
   deallocate data space, close open files, and flush final results.
   These functions should be placed in a finalize routine.

<P>
The component writer must supply a subroutine with the exact interface 
   shown below. Arguments must not be declared as optional, and the types and
   order must match.

<P>
The <TT>rc</TT> return code should be set if an error occurs, otherwise
   the value <TT>ESMF_SUCCESS</TT> should be returned.

<P>
<PRE>
    subroutine CPL_Final(comp, importState, exportState, clock, rc)
      type(ESMF_CplComp)    :: comp                ! must not be optional
      type(ESMF_State)      :: importState         ! must not be optional
      type(ESMF_State)      :: exportState         ! must not be optional
      type(ESMF_Clock)      :: clock               ! must not be optional
      integer, intent(out)  :: rc                  ! must not be optional

      print *, "Coupler Final starting"
    
      ! Add whatever code needed here to compute final values and
      !  finish the computation.

      rc = ESMF_SUCCESS

      print *, "Coupler Final returning"
   
    end subroutine CPL_Final
</PRE>

<P>

<P>

<H3><A NAME="SECTION04042500000000000000">
16.2.5 Implement a user-code <TT>SetVM</TT> routine</A>
</H3>

<P>
<A NAME="sec:CplSetVM"></A>
<P>
Every <TT>ESMF_CplComp</TT> can optionally provide and document
   a public set vm routine.  It can have any name, but must
   follow the declaration below: a subroutine which takes an
   <TT>ESMF_CplComp</TT> as the first argument, and
   an integer return code as the second.
   Both arguments are required and must <EM>not</EM> be declared as 
   <TT>optional</TT>. If an intent is specified in the interface it must be 
   <TT>intent(inout)</TT> for the first and <TT>intent(out)</TT> for the 
   second argument.

<P>
The set vm routine is the only place where the child component can
   use the <TT>ESMF_CplCompSetVMMaxPEs()</TT>, or
   <TT>ESMF_CplCompSetVMMaxThreads()</TT>, or 
   <TT>ESMF_CplCompSetVMMinThreads()</TT> call to modify aspects of its own VM.

<P>
A component's VM is started up right before its set services routine is
   entered. <TT>ESMF_CplCompSetVM()</TT> is executing in the parent VM, and must
   be called <EM>before</EM> <TT>ESMF_CplCompSetServices()</TT>. 

<P>
<PRE>
    subroutine GComp_SetVM(comp, rc)
      type(ESMF_CplComp)   :: comp   ! must not be optional
      integer, intent(out)  :: rc     ! must not be optional
      
      type(ESMF_VM) :: vm
      logical :: pthreadsEnabled
      
      ! Test for Pthread support, all SetVM calls require it
      call ESMF_VMGetGlobal(vm, rc=rc)
      call ESMF_VMGet(vm, pthreadsEnabledFlag=pthreadsEnabled, rc=rc)

      if (pthreadsEnabled) then
        ! run PETs single-threaded
        call ESMF_CplCompSetVMMinThreads(comp, rc=rc)
      endif

      rc = ESMF_SUCCESS

    end subroutine

    end module ESMF_CouplerEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION04043000000000000000">
16.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No optional arguments.</B> User-written routines called by SetServices,
and registered for Initialize, Run and Finalize, <EM>must not</EM> declare any
of the arguments as optional.

<P>
</LI>
<LI><B>No Transforms.</B>  Components must exchange data through 
<TT>ESMF_State</TT> objects.  The input data are available at the time 
the component code is called, and data to be returned to another 
component are available when that code returns.  

<P>
</LI>
<LI><B>No automatic unit conversions.</B>  The ESMF framework does not 
currently contain tools for performing unit conversions, operations that 
are fairly standard within Coupler Components.

<P>
</LI>
<LI><B>No accumulator.</B>  The ESMF does not have an accumulator tool, to
perform time averaging of fields for coupling.  This is likely to be developed
in the near term.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION04044000000000000000">
16.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04044100000000000000">
16.4.1 ESMF_CplCompAssignment(=) - CplComp assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     cplcomp1 = cplcomp2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp) :: cplcomp1
     type(ESMF_CplComp) :: cplcomp2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign cplcomp1 as an alias to the same ESMF CplComp object in memory
     as cplcomp2. If cplcomp2 is invalid, then cplcomp1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>cplcomp1</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>cplcomp2</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044200000000000000">
16.4.2 ESMF_CplCompOperator(==) - CplComp equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (cplcomp1 == cplcomp2) then ... endif
               OR
     result = (cplcomp1 == cplcomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in) :: cplcomp1
     type(ESMF_CplComp), intent(in) :: cplcomp2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether cplcomp1 and cplcomp2 are valid aliases to the same ESMF
     CplComp object in memory. For a more general comparison of two ESMF CplComps,
     going beyond the simple alias test, the ESMF_CplCompMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>cplcomp1</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>cplcomp2</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044300000000000000">
16.4.3 ESMF_CplCompOperator(/=) - CplComp not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (cplcomp1 /= cplcomp2) then ... endif
               OR
     result = (cplcomp1 /= cplcomp2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in) :: cplcomp1
     type(ESMF_CplComp), intent(in) :: cplcomp2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether cplcomp1 and cplcomp2 are <I>not</I> valid aliases to the
     same ESMF CplComp object in memory. For a more general comparison of two ESMF
     CplComps, going beyond the simple alias test, the ESMF_CplCompMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>cplcomp1</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>cplcomp2</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044400000000000000">
16.4.4 ESMF_CplCompCreate - Create a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_CplCompCreate(config, configFile, &amp;
     clock, petList, contextflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_CplComp) :: ESMF_CplCompCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Config),       intent(in),  optional :: config
     character(len=*),        intent(in),  optional :: configFile
     type(ESMF_Clock),        intent(in),  optional :: clock
     integer,                 intent(in),  optional :: petList(:)
     type(ESMF_Context_Flag), intent(in),  optional :: contextflag
     character(len=*),        intent(in),  optional :: name
     integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
This interface creates an <TT>ESMF_CplComp</TT> object. By default, a
   separate VM context will be created for each component.  This implies
   creating a new MPI communicator and allocating additional memory to
   manage the VM resources. When running on a large number of processors,
   creating a separate VM for each component could be both time and memory
   inefficient.  If the application is sequential, i.e., each component is
   running on all the PETs of the global VM, it will be more efficient to use
   the global VM instead of creating a new one.  This can be done by setting
   <TT>contextflag</TT> to ESMF_CONTEXT_PARENT_VM.

<P>
The return value is the new <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[config]</STRONG></DT>
<DD>An already-created <TT>ESMF_Config</TT> configuration object 
     from which the new component
     can read in namelist-type information to set parameters for this run.
     If both are specified, this object takes priority over <TT>configFile</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>The filename of an <TT>ESMF_Config</TT> format file.  
     If specified, this file is opened, an <TT>ESMF_Config</TT> configuration
     object is created for the file, and attached to the new component.  
     The user can call <TT>ESMF_CplCompGet()</TT> to get and use the object.
     If both are specified, the <TT>config</TT> object takes priority 
     over this one.

</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Component-specific <TT>ESMF_Clock</TT>.  This clock is available to be
     queried and updated by the new <TT>ESMF_CplComp</TT> as it chooses.  
     This should
     not be the parent component clock, which should be maintained and passed
     down to the initialize/run/finalize routines separately.

</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List of parent <TT>PET</TT>s given to the created child component by the
     parent component. If <TT>petList</TT> is not specified all of the
     parent <TT>PET</TT>s will be given to the child component. The order of
     PETs in <TT>petList</TT> determines how the child local PETs refer back to
     the parent PETs.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Specify the component's VM context. The default context is
     <TT>ESMF_CONTEXT_OWN_VM</TT>. See section <A HREF="node2.html#const:contextflag">9.9</A> for a
     complete list of valid flags.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the newly-created <TT>ESMF_CplComp</TT>.  This name can be altered 
     from within the <TT>ESMF_CplComp</TT> code once the initialization routine
     is called.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044500000000000000">
16.4.5 ESMF_CplCompDestroy - Release resources associated with a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompDestroy(cplcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)          :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_CplComp</TT>, releasing the resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Release all resources associated with this <TT>ESMF_CplComp</TT>
     and mark the object as invalid.  It is an error to pass this
     object into any other routines after being destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044600000000000000">
16.4.6 ESMF_CplCompFinalize - Call the CplComp's finalize routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompFinalize(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user-supplied finalization routine for 
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are: 
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to call finalize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.  
     Single-phase routines require only one invocation to complete
     their work.  
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase 
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044700000000000000">
16.4.7 ESMF_CplCompGet - Get CplComp information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompGet(cplcomp, configIsPresent, config, &amp;
     configFileIsPresent, configFile, clockIsPresent, clock, localPet, &amp;
     petCount, contextflag, currentMethod, currentPhase, vmIsPresent, &amp;
     vm, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),      intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                 intent(out), optional :: configIsPresent
     type(ESMF_Config),       intent(out), optional :: config
     logical,                 intent(out), optional :: configFileIsPresent
     character(len=*),        intent(out), optional :: configFile
     logical,                 intent(out), optional :: clockIsPresent
     type(ESMF_Clock),        intent(out), optional :: clock
     integer,                 intent(out), optional :: localPet
     integer,                 intent(out), optional :: petCount
     type(ESMF_Context_Flag), intent(out), optional :: contextflag
     type(ESMF_Method_Flag),  intent(out), optional :: currentMethod
     integer,                 intent(out), optional :: currentPhase
     logical,                 intent(out), optional :: vmIsPresent
     type(ESMF_VM),           intent(out), optional :: vm
     character(len=*),        intent(out), optional :: name
     integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get information about an <TT>ESMF_CplComp</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object being queried.
   
</DD>
<DT><STRONG>[configIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>config</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Return the associated Config.
     It is an error to query for the Config if none is associated with
     the CplComp. If unsure, get <TT>configIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[configFileIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>configFile</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Return the associated configuration filename.
     It is an error to query for the configuration filename if none is associated with
     the CplComp. If unsure, get <TT>configFileIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[clockIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>clock</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Return the associated Clock.
     It is an error to query for the Clock if none is associated with
     the CplComp. If unsure, get <TT>clockIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[localPet]</STRONG></DT>
<DD>Return the local PET id within the <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>[petCount]</STRONG></DT>
<DD>Return the number of PETs in the the <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>[contextflag]</STRONG></DT>
<DD>Return the <TT>ESMF_Context_Flag</TT> for this <TT>ESMF_CplComp</TT>.
     See section <A HREF="node2.html#const:contextflag">9.9</A> for a complete list of valid flags.
   
</DD>
<DT><STRONG>[currentMethod]</STRONG></DT>
<DD>Return the current <TT>ESMF_Method_Flag</TT> of the <TT>ESMF_CplComp</TT> execution.
     See section <A HREF="node2.html#const:method">9.31</A>  for a complete list of valid options.
   
</DD>
<DT><STRONG>[currentPhase]</STRONG></DT>
<DD>Return the current <TT>phase</TT> of the <TT>ESMF_CplComp</TT> execution.
   
</DD>
<DT><STRONG>[vmIsPresent]</STRONG></DT>
<DD><TT>.true.</TT> if <TT>vm</TT> was set in GridComp object,
     <TT>.false.</TT> otherwise.
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Return the associated VM.
     It is an error to query for the VM if none is associated with
     the CplComp. If unsure, get <TT>vmIsPresent</TT> first to determine
     the status.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Return the name of the <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044800000000000000">
16.4.8 ESMF_CplCompGetInternalState - Get private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompGetInternalState(cplcomp, wrappedDataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)              :: cplcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_CplComp</TT> at any time after 
   <TT>ESMF_CplCompSetInternalState</TT> has been called.
   Since init, run, and finalize must be separate subroutines, data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by this call.
   When running multiple instantiations of an <TT>ESMF_CplComp</TT>, 
   for example during ensemble runs, 
   it may be simpler to maintain private data specific to 
   each run with private data blocks.  A corresponding 
   <TT>ESMF_CplCompSetInternalState</TT> call sets the data pointer to 
   this block, and this call retrieves the data pointer.   
   Note that the <TT>wrappedDataPointer</TT> argument needs to be a derived type
   which contains only a pointer of the type of the data block defined
   by the user.  When making this call the pointer needs to be unassociated.
   When the call returns, the pointer will now reference the original
   data block which was set during the previous call to
   <TT>ESMF_CplCompSetInternalState</TT>.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_CplCompSetInternalState</TT> will be accessible.

<P>
CAUTION: This method does not have an explicit Fortran interface. Do not 
   specify argument keywords when calling this method!

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>wrappedDataPointer</STRONG></DT>
<DD>A derived type (wrapper), containing only an unassociated pointer 
     to the private data block.
     The framework will fill in the pointer. When this call returns, the
     pointer is set to the same address set during the last
     <TT>ESMF_CplCompSetInternalState</TT> call.
     This level of indirection is needed to reliably set and retrieve 
     the data block no matter which architecture or compiler is used.  
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04044900000000000000">
16.4.9 ESMF_CplCompInitialize - Call the CplComp's initialize routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompInitialize(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user initialization routine for 
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are: 
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call initialize routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.  
     Single-phase routines require only one invocation to complete
     their work.  
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase 
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441000000000000000">
16.4.10 ESMF_CplCompIsPetLocal - Inquire if this CplComp is to execute on the calling PET</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_CplCompIsPetLocal(cplcomp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: ESMF_CplCompIsPetLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Inquire if this <TT>ESMF_CplComp</TT> object is to execute on the calling PET.

<P>
The return value is <TT>.true.</TT> if the component is to execute on the 
   calling PET, <TT>.false.</TT> otherwise.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> queried.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441100000000000000">
16.4.11 ESMF_CplCompPrint - Print CplComp information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompPrint(cplcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about an <TT>ESMF_CplComp</TT> to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to print.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441200000000000000">
16.4.12 ESMF_CplCompReadRestart - Call the CplComp's read restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompReadRestart(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user read restart routine for 
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441300000000000000">
16.4.13 ESMF_CplCompRun - Call the CplComp's run routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompRun(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user run routine for 
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are: 
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data for coupling. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.  
     Single-phase routines require only one invocation to complete
     their work.  
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase 
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441400000000000000">
16.4.14 ESMF_CplCompSet - Set or reset information about the CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSet(cplcomp, config, configFile, &amp;
     clock, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Config),  intent(in),  optional :: config
     character(len=*),   intent(in),  optional :: configFile
     type(ESMF_Clock),   intent(in),  optional :: clock
     character(len=*),   intent(in),  optional :: name
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets or resets information about an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to change.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Set the name of the <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[config]</STRONG></DT>
<DD>Set the configuration information for the <TT>ESMF_CplComp</TT> from
     this already created <TT>ESMF_Config</TT> object.   
     If specified, takes priority over <TT>configFile</TT>.
   
</DD>
<DT><STRONG>[configFile]</STRONG></DT>
<DD>Set the configuration filename for this <TT>ESMF_CplComp</TT>.
     An <TT>ESMF_Config</TT> object will be created for this file
     and attached to the <TT>ESMF_CplComp</TT>.  Superceeded by <TT>config</TT>
     if both are specified.
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Set the private clock for this <TT>ESMF_CplComp</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441500000000000000">
16.4.15 ESMF_CplCompSetEntryPoint - Set user routine as entry point for standard Component method</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompSetEntryPoint(cplcomp, methodflag, &amp;
     userRoutine, phase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(inout)         :: cplcomp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     interface
       subroutine userRoutine(cplcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: phase
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Registers a user-supplied <TT>userRoutine</TT> as the entry point for one of the
   predefined Component <TT>methodflag</TT>s. After this call the <TT>userRoutine</TT>
   becomes accessible via the standard Component method API.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>methodflag</STRONG></DT>
<DD>One of a set of predefined Component methods - e.g.
     <TT>ESMF_METHOD_INITIALIZE</TT>, <TT>ESMF_METHOD_RUN</TT>, 
     <TT>ESMF_METHOD_FINALIZE</TT>. See section <A HREF="node2.html#const:method">9.31</A> 
     for a complete list of valid method options.

</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated for this <TT>methodflag</TT>.
     The Component writer must supply a subroutine with the exact interface 
     shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must match.
     The subroutine must be either a module scope procedure, or an external
     procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>The <TT>phase</TT> number for multi-phase methods. For single phase 
     methods the <TT>phase</TT> argument can be omitted. The default setting
     is 1.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441600000000000000">
16.4.16 ESMF_CplCompSetInternalState - Set private data block pointer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetInternalState(cplcomp, wrappedDataPointer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)              :: cplcomp
     type(wrapper)                   :: wrappedDataPointer
     integer,            intent(out) :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Available to be called by an <TT>ESMF_CplComp</TT> at any time, but 
   expected to be
   most useful when called during the registration process, or initialization.
   Since init, run, and finalize must be separate subroutines data that
   they need to share in common can either be module global data, or can
   be allocated in a private data block and the address of that block
   can be registered with the framework and retrieved by subsequent calls.
   When running multiple instantiations of an <TT>ESMF_CplComp</TT>, 
   for example during
   ensemble runs, it may be simpler to maintain private data specific to 
   each run with private data blocks.  A corresponding 
   <TT>ESMF_CplCompGetInternalState</TT> call retrieves the data pointer.

<P>
Only the <EM>last</EM> data block set via
   <TT>ESMF_CplCompSetInternalState</TT> will be accessible.

<P>
CAUTION: This method does not have an explicit Fortran interface. Do not 
   specify argument keywords when calling this method!

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>An <TT>ESMF_CplComp</TT> object.
   
</DD>
<DT><STRONG>wrappedDataPointer</STRONG></DT>
<DD>A pointer to the private data block, wrapped in a derived type which
     contains only a pointer to the block.  This level of indirection is
     needed to reliably set and retrieve the data block no matter which
     architecture or compiler is used.  
   
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     Note: unlike most other ESMF routines, this argument is not optional
     because of implementation considerations.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441700000000000000">
16.4.17 ESMF_CplCompSetServices - Call user routine to register CplComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompSetServices(cplcomp, userRoutine, &amp;
      userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: userRc
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's Initialize(), Run(), and Finalize() services.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The Component writer must supply a subroutine with the exact interface 
    shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
    must not be declared as optional, and the types, intent and order must match.
    The subroutine must be either a module scope procedure, or an external
    procedure that has a matching interface block specified for it.
    It must not be an internal procedure which is contained
    within another procedure.

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive calls to
    <TT>ESMF_CplCompSetEntryPoint()</TT> to preset callback routines for standard
    Component Initialize(), Run(), and Finalize() methods.

</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441800000000000000">
16.4.18 ESMF_CplCompSetServices - Call user routine, located in shared object, to register CplComp methods</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_CplCompSetServices()
   recursive subroutine ESMF_CplCompSetServicesShObj(cplcomp, userRoutine, &amp;
     sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call into user provided routine which is responsible for setting
   Component's Initialize(), Run(), and Finalize() services. The named
   <TT>userRoutine</TT> must exist in the shared object file specified in the
   <TT>sharedObj</TT> argument. All of the platform specific details about 
   dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface 
     shown for <TT>userRoutine</TT> below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     The subroutine must be either a module scope procedure, or an external
     procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface
     	subroutine userRoutine(cplcomp, rc)
     	  type(ESMF_CplComp)   :: cplcomp    ! must not be optional
     	  integer, intent(out) :: rc	     ! must not be optional
     	end subroutine
       end interface
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The <TT>userRoutine</TT>, when called by the framework, must make successive
     calls to <TT>ESMF_CplCompSetEntryPoint()</TT> to preset callback routines for
     standard Component Initialize(), Run(), and Finalize() methods.

</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040441900000000000000">
16.4.19 ESMF_CplCompSetVM - Call user routine to set CplComp VM properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompSetVM(cplcomp, userRoutine, &amp;
     userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: cplcomp
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: userRc
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's VM properties. 

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The Component writer must supply a subroutine with the exact interface 
     shown above for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must match.
     The subroutine must be either a module scope procedure, or an external
     procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.

<P>
The subroutine, when called by the framework, is expected to use any of the
     <TT>ESMF_CplCompSetVMxxx()</TT> methods to set the properties of the VM
     associated with the Coupler Component.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442000000000000000">
16.4.20 ESMF_CplCompSetVM - Set CplComp VM properties in routine located in shared object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_CplCompSetVM()
   recursive subroutine ESMF_CplCompSetVMShObj(cplcomp, userRoutine, &amp;
     sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
     character(len=*),    intent(in)            :: userRoutine
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(out), optional :: userRc
     integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Optionally call into user provided <TT>userRoutine</TT> which is responsible for
   for setting Component's VM properties. The named <TT>userRoutine</TT> must exist
   in the shared object file specified in the <TT>sharedObj</TT> argument. All of
   the platform specific details about dynamic linking and loading apply.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>Coupler Component.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Routine to be called, specified as a character string.
     The Component writer must supply a subroutine with the exact interface 
     shown for <TT>userRoutine</TT> below. Arguments must not be declared
     as optional, and the types, intent and order must match.
     The subroutine must be either a module scope procedure, or an external
     procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface
     	subroutine userRoutine(cplcomp, rc)
     	  type(ESMF_CplComp)   :: cplcomp     ! must not be optional
     	  integer, intent(out) :: rc	      ! must not be optional
     	end subroutine
       end interface
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The subroutine, when called by the framework, is expected to use any of the
     <TT>ESMF_CplCompSetVMxxx()</TT> methods to set the properties of the VM
     associated with the Coupler Component.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the 
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442100000000000000">
16.4.21 ESMF_CplCompSetVMMaxPEs - Associate PEs with PETs in CplComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMaxPEs(cplcomp, &amp;
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Attempts to associate up to <TT>maxPeCountPerPet</TT> PEs with each PET. Only
     PEs that are located on the same single system image (SSI) can be associated
     with the same PET. Within this constraint the call tries to get as close as
     possible to the number specified by <TT>maxPeCountPerPet</TT>.

<P>
The other constraint to this call is that the number of PEs is preserved.
     This means that the child Component in the end is associated with as many
     PEs as the parent Component provided to the child. The number of child PETs 
     however is adjusted according to the above rule.

<P>
The typical use of <TT>ESMF_CplCompSetVMMaxPEs()</TT> is to allocate
     multiple PEs per PET in a Component for user-level threading, e.g. OpenMP.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPeCountPerPet]</STRONG></DT>
<DD>Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442200000000000000">
16.4.22 ESMF_CplCompSetVMMaxThreads - Set multi-threaded PETs in CplComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMaxThreads(cplcomp, &amp;
     maxPetCountPerVas, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPetCountPerVas
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Attempts to provide <TT>maxPetCountPerVas</TT> threaded PETs in each 
     virtual address space (VAS). Only as many threaded PETs as there are PEs
     located on the single system image (SSI) can be associated with the VAS. 
     Within this constraint the call tries to get as close as possible to the 
     number specified by <TT>maxPetCountPerVas</TT>.

<P>
The other constraint to this call is that the number of PETs is preserved.
     This means that the child Component in the end is associated with as many
     PETs as the parent Component provided to the child. The threading level of
     the child PETs however is adjusted according to the above rule.

<P>
The typical use of <TT>ESMF_GridCompSetVMMaxThreads()</TT> is to run a 
     Component multi-threaded with groups of PETs executing within a common
     virtual address space.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPetCountPerVas]</STRONG></DT>
<DD>Maximum number of threaded PETs in each virtual address space (VAS). 
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442300000000000000">
16.4.23 ESMF_CplCompSetVMMinThreads - Set a reduced threading level in GridComp VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompSetVMMinThreads(cplcomp, &amp;
     maxPeCountPerPet, prefIntraProcess, prefIntraSsi, prefInterSsi, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: maxPeCountPerPet
     integer,             intent(in),  optional :: prefIntraProcess
     integer,             intent(in),  optional :: prefIntraSsi
     integer,             intent(in),  optional :: prefInterSsi
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set characteristics of the <TT>ESMF_VM</TT> for this <TT>ESMF_CplComp</TT>.
     Reduces the number of threaded PETs in each VAS. The <TT>max</TT> argument
     may be specified to limit the maximum number of PEs that a single PET 
     can be associated with.

<P>
Several constraints apply: 1) the number of PEs cannot change, 2) PEs
     cannot migrate between single system images (SSIs), 3) the number of PETs
     cannot increase, only decrease, 4) PETs cannot migrate between virtual
     address spaces (VASs), nor can VASs migrate between SSIs.

<P>
The typical use of <TT>ESMF_GridCompSetVMMinThreads()</TT> is to run a 
     Component across a set of single-threaded PETs.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to set the <TT>ESMF_VM</TT> for.
   
</DD>
<DT><STRONG>[maxPeCountPerPet]</STRONG></DT>
<DD>Maximum number of PEs on each PET.
     Default for each SSI is the local number of PEs.
   
</DD>
<DT><STRONG>[prefIntraProcess]</STRONG></DT>
<DD>Communication preference within a single process.
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefIntraSsi]</STRONG></DT>
<DD>Communication preference within a single system image (SSI).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[prefInterSsi]</STRONG></DT>
<DD>Communication preference between different single system images (SSIs).
     <EM>Currently options not documented. Use default.</EM>
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442400000000000000">
16.4.24 ESMF_CplCompValidate - Ensure the CplComp is internally consistent</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompValidate(cplcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Currently all this method does is to check that the <TT>cplcomp</TT>
   was created.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to validate.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442500000000000000">
16.4.25 ESMF_CplCompWait - Wait for a CplComp to return</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_CplCompWait(cplcomp, syncflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)         :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Sync_Flag), intent(in),  optional :: syncflag
     integer,              intent(out), optional :: userRc
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
When executing asychronously, wait for an <TT>ESMF_CplComp</TT> to return.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to wait for.
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040442600000000000000">
16.4.26 ESMF_CplCompWriteRestart - Call the CplComp's write restart routine</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_CplCompWriteRestart(cplcomp, &amp;
     importState, exportState, clock, syncflag, phase, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),   intent(inout)           :: cplcomp
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_State),     intent(inout), optional :: importState
     type(ESMF_State),     intent(inout), optional :: exportState
     type(ESMF_Clock),     intent(inout), optional :: clock
     type(ESMF_Sync_Flag), intent(in),    optional :: syncflag
     integer,              intent(in),    optional :: phase
     integer,              intent(out),   optional :: userRc
     integer,              intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the associated user write restart routine for 
   an <TT>ESMF_CplComp</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD><TT>ESMF_CplComp</TT> to call run routine for.
   
</DD>
<DT><STRONG>[importState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing import data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     importState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[exportState]</STRONG></DT>
<DD><TT>ESMF_State</TT> containing export data. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     exportState argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>External <TT>ESMF_Clock</TT> for passing in time information.  
     This is generally the parent component's clock, and will be treated
     as read-only by the child component.  The child component can maintain
     a private clock for its own internal time computations. If not present, a dummy
     argument will be passed to the user-supplied routine.  The 
     clock argument in the user code cannot be optional. 
   
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Blocking behavior of this method call. See section <A HREF="node2.html#const:sync">9.44</A> 
     for a list of valid blocking options. Default option is
     <TT>ESMF_SYNC_VASBLOCKING</TT> which blocks PETs and their spawned off threads 
     across each VAS but does not synchronize PETs that run in different VASs.
   
</DD>
<DT><STRONG>[phase]</STRONG></DT>
<DD>Component providers must document whether their each of their
     routines are <EM>single-phase</EM> or <EM>multi-phase</EM>.    
     Single-phase routines require only one invocation to complete
     their work.    
     Multi-phase routines provide multiple subroutines to accomplish
     the work, accomodating components which must complete part of their
     work, return to the caller and allow other processing to occur,
     and then continue the original operation.
     For multiple-phase child components, this is the integer phase  
     number to be invoked.
     For single-phase child components this argument is optional. The default is
     1.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by <TT>userRoutine</TT> before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION04050000000000000000">
17 State Class</A>
</H1>

<P>

<H2><A NAME="SECTION04051000000000000000">
17.1 Description</A>
</H2>

<P>
<A NAME="sec:State"></A>
<P>
A State contains the data and metadata to be transferred between 
ESMF Components.  It is an important class, because it defines a 
standard for how data is represented in data transfers between Earth
science components.  The 
State construct is a rational compromise between a fully prescribed 
interface - one that would dictate what specific fields should be 
transferred between components - and an interface in which data structures
are completely ad hoc.

<P>
There are two types of States, import and export.
An import State contains data that is necessary for a Gridded Component
or Coupler Component to execute, and an export State contains the data
that a Gridded Component or Coupler Component can make available.

<P>
States can contain Arrays, ArrayBundles, Fields, FieldBundles, 
and other States.  They cannot directly contain native language arrays
(i.e. Fortran or C style arrays).  Objects in a State must span
the VM on which they are running.  For sequentially executing components
which run on the same set of PETs this happens by calling the object
create methods on each PET, creating the object in unison.   For
concurrently executing components which are running on subsets of PETs,
an additional method, called <TT>ESMF_StateReconcile()</TT>, is provided by
ESMF to broadcast information
about objects which were created in sub-components.

<P>
State methods include creation and deletion, adding and retrieving 
data items, adding and retrieving attributes, and performing queries.  

<P>

<P>

<H2><A NAME="SECTION04052000000000000000">
17.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION04052100000000000000"></A>
<A NAME="const:stateintent"></A>
<BR>
17.2.1 ESMF_STATEINTENT
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies whether a <TT>ESMF_State</TT> contains data to be imported
into a component or exported from a component.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_StateIntent_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_STATEINTENT_IMPORT</STRONG></DT>
<DD>Contains data to be imported into a component.
   
</DD>
<DT><STRONG>ESMF_STATEINTENT_EXPORT</STRONG></DT>
<DD>Contains data to be exported out of a component.
   
</DD>
<DT><STRONG>ESMF_STATEINTENT_UNSPECIFIED</STRONG></DT>
<DD>The intent has not been specified.
</DD>
</DL>

<P>

<H3><A NAME="SECTION04052200000000000000"></A>
<A NAME="const:stateitem"></A>
<BR>
17.2.2 ESMF_STATEITEM
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies the type of object being added to or retrieved from an
ESMF_State.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_StateItem_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_STATEITEM_ARRAY</STRONG></DT>
<DD>Refers to an <TT>ESMF_Array</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_ARRAYBUNDLE</STRONG></DT>
<DD>Refers to an <TT>ESMF_Array</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_FIELD</STRONG></DT>
<DD>Refers to a <TT>ESMF_Field</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_FIELDBUNDLE</STRONG></DT>
<DD>Refers to a <TT>ESMF_FieldBundle</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_ROUTEHANDLE</STRONG></DT>
<DD>Refers to a <TT>ESMF_RouteHandle</TT> within an <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>ESMF_STATEITEM_STATE</STRONG></DT>
<DD>Refers to a <TT>ESMF_State</TT> within an <TT>ESMF_State</TT>.
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION04053000000000000000">
17.3 Use and Examples</A>
</H2>

<P>
A Gridded Component generally has one associated import 
State and one export State.  Generally the States 
associated with a Gridded Component will be created by 
the Gridded Component's parent component.
In many cases, the States will be created containing 
no data.  Both the empty States and the
newly created Gridded Component are passed
by the parent component into the Gridded Component's initialize 
method.  This is where the States get prepared for use 
and the import State is first filled with data.

<P>
States can be filled with data items that do not yet 
have data allocated.  Fields, FieldBundles, Arrays, and ArrayBundles each have 
methods that support their creation without actual data 
allocation - the Grid and Attributes are set up but no
Fortran array of data values is allocated.  In this approach, 
when a State is passed into its associated Gridded Component's 
initialize method, the incomplete Arrays, Fields, FieldBundles,
and ArrayBundles within the State can allocate or reference data 
inside the initialize method.

<P>
States are passed through the interfaces of the Gridded 
and Coupler Components' run methods in order to carry data 
between the components.  While we expect
a Gridded Component's import State to be filled with data 
during initialization, its export State will typically be
filled over the course of its run method.  At the end of
a Gridded Component's run method, the filled export State 
is passed out through the argument list into a Coupler 
Component's run method.  We recommend the convention that 
it enters the Coupler Component as the Coupler Component's
import State.  Here is it transformed into a form
that another Gridded Component requires, and passed out
of the Coupler Component as its export State.  It can then
be passed into the run method of a recipient Gridded Component
as that component's import State.

<P>
While the above sounds complicated, the rule is simple:
a State going into a component is an import State, and a 
State leaving a component is an export State.

<P>
Objects inside States are normally created in <TT>unison</TT> where
each PET executing a component makes the same object create call.
If the object contains data, like a Field, each PET may have a
different local chunk of the entire dataset but each Field has
the same name and is logically one part of a single distributed 
object.   As States are passed between components, if any object
in a State was not created in unison on all the current PETs 
then some PETs have no object to pass into a
communication method (e.g. regrid or data redistribution).
The <TT>ESMF_StateReconcile()</TT> method must be called to broadcast 
information about these objects to all PETs in a component;
after which all PETs have a single uniform view of all objects and metadata.  

<P>
If components are running in sequential mode on all available PETs
and States are being passed between them there is no need to call 
<TT>ESMF_StateReconcile</TT> since all PETs have a uniform view of the objects.
However, if components are running on a subset of the PETs, as is
usually the case when running in concurrent mode, then when States
are passed into components which contain a superset of those PETs,
for example, a Coupler Component, all PETs must call <TT>ESMF_StateReconcile</TT>
on the States before using them in any ESMF communication methods.
The reconciliation process broadcasts information about objects
which exist only on a subset of the PETs.  On PETs missing those
objects it creates a <I>proxy</I> object which contains any
qualities of the original object plus enough information for it
to be a data source or destination for a regrid or data redistribution
operation.  There is an option to turn off metadata reconciliation in the 
<TT>ESMF_StateReconcile</TT> call.

<P>

<H3><A NAME="SECTION04053100000000000000">
17.3.1 State create and destroy</A>
</H3>

<P>
States can be created and destroyed at any time during
application execution.  The <TT>ESMF_StateCreate()</TT> routine
can take many different combinations of optional arguments.  Refer
to the API description for all possible methods of creating a State.
An empty State can be created by providing only a name and type for
the intended State:

<P>
<TT>state = ESMF_StateCreate(name, stateintent=ESMF_STATEINTENT_IMPORT, rc=rc)</TT>

<P>
When finished with an <TT>ESMF_State</TT>, the <TT>ESMF_StateDestroy</TT> method
removes it.  However, the objects inside the <TT>ESMF_State</TT>
created externally should be destroyed separately,
since objects can be added to more than one <TT>ESMF_State</TT>.

<P>

<P>

<P>

<H3><A NAME="SECTION04053200000000000000">
17.3.2 Add items to a State</A>
</H3>

<P>
Creation of an empty <TT>ESMF_State</TT>, and adding an <TT>ESMF_FieldBundle</TT>
    to it.  Note that the <TT>ESMF_FieldBundle</TT> does not get destroyed when
    the <TT>ESMF_State</TT> is destroyed; the <TT>ESMF_State</TT> only contains
    a reference to the objects it contains.  It also does not make a copy;
    the original objects can be updated and code accessing them by using
    the <TT>ESMF_State</TT> will see the updated version. 

<P>
<PRE>
    statename = "Ocean"
    state2 = ESMF_StateCreate(name=statename,  &amp;
                              stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
</PRE>

<P>
<PRE>
    bundlename = "Temperature"
    bundle1 = ESMF_FieldBundleCreate(name=bundlename, rc=rc)
    print *, "FieldBundle Create returned", rc
</PRE>

<P>
<PRE>
    call ESMF_StateAdd(state2, (/bundle1/), rc=rc)
    print *, "StateAdd returned", rc
</PRE>

<P>
<PRE>
    call ESMF_StateDestroy(state2, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleDestroy(bundle1, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04053300000000000000">
17.3.3 Add placeholders to a State</A>
</H3>

<P>
If a component could potentially produce a large number of optional
   items, one strategy is to add the names only of those objects to the
   <TT>ESMF_State</TT>.  Other components can call framework routines to
   set the <TT>ESMF_NEEDED</TT> flag to indicate they require that data.
   The original component can query this flag and then produce only the
   data that is required by another component. 

<P>
<PRE>
    statename = "Ocean"
    state3 = ESMF_StateCreate(name=statename,  &amp;
                              stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
</PRE>

<P>
<PRE>
    dataname = "Downward wind:needed"
    call ESMF_AttributeSet (state3, dataname, .false., rc=rc)
</PRE>

<P>
<PRE>
    dataname = "Humidity:needed"
    call ESMF_AttributeSet (state3, dataname, .false., rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04053400000000000000">
17.3.4 Mark an item <TT>NEEDED</TT></A>
</H3>

<P>
How to set the <TT>NEEDED</TT> state of an item. 

<P>
<PRE>
    dataname = "Downward wind:needed"
    call ESMF_AttributeSet (state3, name=dataname, value=.true., rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION04053500000000000000">
17.3.5 Create a <TT>NEEDED</TT> item</A>
</H3>

<P>
Query an item for the <TT>NEEDED</TT> status, and creating an item on demand.
   Similar flags exist for "Ready", "Valid", and "Required for Restart",
   to mark each data item as ready, having been validated, or needed if the
   application is to be checkpointed and restarted.  The flags are supported
   to help coordinate the data exchange between components. 

<P>
<PRE>
    dataname = "Downward wind:needed"
    call ESMF_AttributeGet (state3, dataname, valueList=neededFlag, rc=rc)
</PRE>

<P>
<PRE>
    if (rc == ESMF_SUCCESS .and. neededFlag(1)) then
        bundlename = dataname
        bundle2 = ESMF_FieldBundleCreate(name=bundlename, rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_StateAdd(state3, (/bundle2/), rc=rc)
</PRE>

<P>
<PRE>
    else
        print *, "Data not marked as needed", trim(dataname)
    endif
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04053600000000000000">
17.3.6 <TT>ESMF_StateReconcile()</TT> usage</A>
</H3>

<P>
The set services routines are used to tell ESMF which routine
   hold the user code for the initialize, run, and finalize
   blocks of user level Components.
   These are the separate subroutines called by the code below. 

<P>
<PRE>
! Initialize routine which creates "field1" on PETs 0 and 1
subroutine comp1_init(gcomp, istate, ostate, clock, rc)
    type(ESMF_GridComp)  :: gcomp
    type(ESMF_State)     :: istate, ostate
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    type(ESMF_Field) :: field1
    integer :: localrc

    print *, "i am comp1_init"

    field1 = ESMF_FieldEmptyCreate(name="Comp1 Field", rc=localrc)
  
    call ESMF_StateAdd(istate, (/field1/), rc=localrc)
    
    rc = localrc

end subroutine comp1_init

! Initialize routine which creates "field2" on PETs 2 and 3
subroutine comp2_init(gcomp, istate, ostate, clock, rc)
    type(ESMF_GridComp)  :: gcomp
    type(ESMF_State)     :: istate, ostate
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    type(ESMF_Field) :: field2
    integer :: localrc

    print *, "i am comp2_init"

    field2 = ESMF_FieldEmptyCreate(name="Comp2 Field", rc=localrc)
    
    call ESMF_StateAdd(istate, (/field2/), rc=localrc)

    rc = localrc

end subroutine comp2_init

subroutine comp_dummy(gcomp, rc)
   type(ESMF_GridComp)  :: gcomp
   integer, intent(out) :: rc

   rc = ESMF_SUCCESS
end subroutine comp_dummy
</PRE>

<P>
<PRE>
! !PROGRAM: ESMF_StateReconcileEx - State reconciliation
!
! !DESCRIPTION:
!
! This program shows examples of using the State Reconcile function
!-----------------------------------------------------------------------------

    ! ESMF Framework module
    use ESMF
    use ESMF_StateReconcileEx_Mod
    implicit none

    ! Local variables
    integer :: rc, petCount
    type(ESMF_State) :: state1
    type(ESMF_GridComp) :: comp1, comp2
    type(ESMF_VM) :: vm
    character(len=ESMF_MAXSTR) :: comp1name, comp2name, statename
</PRE>

<P>
A Component can be created which will run only on a subset of the
    current PET list. 

<P>
<PRE>
    ! Get the global VM for this job.
    call ESMF_VMGetGlobal(vm=vm, rc=rc)

    comp1name = "Atmosphere"
    comp1 = ESMF_GridCompCreate(name=comp1name, petList=(/ 0, 1 /), rc=rc)
    print *, "GridComp Create returned, name = ", trim(comp1name)

    comp2name = "Ocean"
    comp2 = ESMF_GridCompCreate(name=comp2name, petList=(/ 2, 3 /), rc=rc)
    print *, "GridComp Create returned, name = ", trim(comp2name)

    statename = "Ocn2Atm"
    state1 = ESMF_StateCreate(name=statename, rc=rc)
</PRE>

<P>
Here we register the subroutines which should be called for initialization.
    Then we call ESMF_GridCompInitialize() on all PETs, but the code runs
    only on the PETs given in the petList when the Component was created.

<P>
Because this example is so short, we call the entry point code
    directly instead of the normal procedure of nesting it in a separate
    SetServices() subroutine.  

<P>
<PRE>
    ! This is where the VM for each component is initialized.
    ! Normally you would call SetEntryPoint inside set services,
    ! but to make this example very short, they are called inline below.
    ! This is o.k. because the SetServices routine must execute from within
    ! the parent component VM.
    call ESMF_GridCompSetVM(comp1, comp_dummy, rc=rc)
    call ESMF_GridCompSetVM(comp2, comp_dummy, rc=rc)
    call ESMF_GridCompSetServices(comp1, comp_dummy, rc=rc)
    call ESMF_GridCompSetServices(comp2, comp_dummy, rc=rc)

    print *, "ready to set entry point 1"
    call ESMF_GridCompSetEntryPoint(comp1, ESMF_METHOD_INITIALIZE, &amp;
         comp1_init, rc=rc)

    print *, "ready to set entry point 2"
    call ESMF_GridCompSetEntryPoint(comp2, ESMF_METHOD_INITIALIZE, &amp;
         comp2_init, rc=rc)


    print *, "ready to call init for comp 1"
    call ESMF_GridCompInitialize(comp1, exportState=state1, rc=rc)
    print *, "ready to call init for comp 2"
    call ESMF_GridCompInitialize(comp2, exportState=state1, rc=rc)
</PRE>

<P>
Now we have <TT>state1</TT> containing <TT>field1</TT> on PETs 0 and 1, and
   <TT>state1</TT> containing <TT>field2</TT> on PETs 2 and 3.  For the code
   to have a rational view of the data, we call <TT>ESMF_StateReconcile</TT>
   which determines which objects are missing from any PET, and communicates
   information about the object.  There is the option of turning metadata
   reconciliation on or off with the optional parameter shown in the call 
   below.  The default behavior is for metadata reconciliation to be off.
   After the call to reconcile, all
   <TT>ESMF_State</TT> objects now have a consistent view of the data. 

<P>
<PRE>
    print *, "State before calling StateReconcile()"
    call ESMF_StatePrint(state1, rc=rc)

    call ESMF_StateReconcile(state1, vm=vm,  &amp;
                             attreconflag=ESMF_ATTRECONCILE_OFF, rc=rc)

    print *, "State after calling StateReconcile()"
    call ESMF_StatePrint(state1, rc=rc)
</PRE>

<P>
<PRE>
end program ESMF_StateReconcileEx
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04053700000000000000"></A>
   <A NAME="example:StateRdWr"></A>
<BR>
17.3.7 Read Arrays from a netCDF file and add to a State
</H3>
   This program shows an example of reading and writing Arrays from a State
   from/to a NetCDF file. 

<P>
<PRE>
    ! ESMF Framework module
    use ESMF
    implicit none

    ! Local variables
    type(ESMF_State) :: state
    type(ESMF_Array) :: latArray, lonArray, timeArray, humidArray, &amp;
                        tempArray, pArray, rhArray
    type(ESMF_VM) :: vm
    integer :: localPet, rc
</PRE>

<P>
The following line of code will read all Array data contained in a NetCDF
    file, place them in <TT>ESMF_Arrays</TT> and add them to an <TT>ESMF_State</TT>.
    Only PET 0 reads the file; the States in the other PETs remain empty.
    Currently, the data is not decomposed or distributed; each PET
    has only 1 DE and only PET 0 contains data after reading the file.
    Future versions of ESMF will support data decomposition and distribution
    upon reading a file.

<P>
Note that the third party NetCDF library must be installed.  For more
    details, see the "ESMF Users Guide", 
    "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
    the website http://www.unidata.ucar.edu/software/netcdf. 

<P>
<PRE>
    ! Read the NetCDF data file into Array objects in the State on PET 0
    call ESMF_StateRead(state, "io_netcdf_testdata.nc", rc=rc)

    ! If the NetCDF library is not present (on PET 0), cleanup and exit 
    if (rc == ESMF_RC_LIB_NOT_PRESENT) then
      call ESMF_StateDestroy(state, rc=rc)
      goto 10
    endif
</PRE>

<P>
Only reading data into <TT>ESMF_Arrays</TT> is supported at this time;
    <TT>ESMF_ArrayBundles</TT>, <TT>ESMF_Fields</TT>, and <TT>ESMF_FieldBundles</TT>
    will be supported in future releases of ESMF. 

<P>

<H3><A NAME="SECTION04053800000000000000">
17.3.8 Print Array data from a State</A>
</H3>

<P>
To see that the State now contains the same data as in the file, the
    following shows how to print out what Arrays are contained within the
    State and to print the data contained within each Array.  The NetCDF utility
    "ncdump" can be used to view the contents of the NetCDF file.
    In this example, only PET 0 will contain data. 

<P>
<PRE>
    if (localPet == 0) then
      ! Print the names and attributes of Array objects contained in the State
      call ESMF_StatePrint(state, rc=rc)

      ! Get each Array by name from the State
      call ESMF_StateGet(state, "lat",  latArray,   rc=rc)
      call ESMF_StateGet(state, "lon",  lonArray,   rc=rc)
      call ESMF_StateGet(state, "time", timeArray,  rc=rc)
      call ESMF_StateGet(state, "Q",    humidArray, rc=rc)
      call ESMF_StateGet(state, "TEMP", tempArray,  rc=rc)
      call ESMF_StateGet(state, "p",    pArray,     rc=rc)
      call ESMF_StateGet(state, "rh",   rhArray,    rc=rc)

      ! Print out the Array data
      call ESMF_ArrayPrint(latArray,   rc=rc)
      call ESMF_ArrayPrint(lonArray,   rc=rc)
      call ESMF_ArrayPrint(timeArray,  rc=rc)
      call ESMF_ArrayPrint(humidArray, rc=rc)
      call ESMF_ArrayPrint(tempArray,  rc=rc)
      call ESMF_ArrayPrint(pArray,     rc=rc)
      call ESMF_ArrayPrint(rhArray,    rc=rc)
    endif
</PRE>

<P>
Note that the Arrays "lat", "lon", and "time" hold spatial and temporal
    coordinate data for the dimensions latitude, longitude and time,
    respectively.  These will be used in future releases of ESMF to create
    <TT>ESMF_Grids</TT>. 

<P>

<H3><A NAME="SECTION04053900000000000000">
17.3.9 Write Array data within a State to a netCDF file</A>
</H3>

<P>
All the Array data within the State on PET 0 can be written out to a NetCDF
    file as follows: 

<P>
<PRE>
    ! Write Arrays within the State on PET 0 to a NetCDF file
    call ESMF_StateWrite(state, "io_netcdf_testdata_out.nc", rc=rc)
</PRE>

<P>
Currently writing is limited to PET 0; future versions of ESMF will allow
    parallel writing, as well as parallel reading.

<P>

<H2><A NAME="SECTION04054000000000000000">
17.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>No synchronization of object ids at object create time.</B>
Object IDs are using during the reconcile process to identify objects
which are unknown to some subset of the PETs in the currently running VM.
Object IDs are assigned in sequential order at object create time.

<P>
One important request by the user community during the ESMF object design was
that there be no communication overhead or synchronization when creating
distributed ESMF objects. As a consequence it is required to create these
objects in <B>unison</B> across all PETs in order to keep the ESMF object
identifiaction in sync.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION04055000000000000000">
17.5 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>States contain the name of the associated Component, a flag for Import
or Export, and a list of data objects, which can be a combination of
FieldBundles, Fields, and/or Arrays.  The objects must be named and have
the proper attributes so they can be identified by the receiver of
the data.  For example, units and other detailed information
may need to be associated with the data as an Attribute.  

<P>
</LI>
<LI>Data contained in States must be created in unison on each
PET of the current VM.  This allows the creation process to avoid
doing communications since each PET can compute any information
it needs to know about any remote PET (for example, the grid
distribute method can compute the decomposition of the grid on
not only the local PET but also the remote PETs since it knows
each PET is making the identical call).  For all PETs to have a
consistent view of the data this means objects must be given
unique names when created, or all objects must be created in
the same order on all PETs so ESMF can generate consistent
default names for the objects.

<P>
When running components on subsets of the original VM all the
PETs can create consistent objects but then when they are put
into a State and passed to a component with a different VM and
a different set of PETs, a communication call (reconcile) must be 
made to communicate the missing information to the PETs which were 
not involved in the original object creation.  The reconcile call
broadcasts object lists; those PETs which are missing any objects
in the total list can receive enough information to
reconstruct a proxy object which contains all necessary information
about that object, with no local data, on that PET.  These proxy
objects can be queried by ESMF routines to determine the amount
of data and what PETs contain data which is destined to be moved
to the local PET (for receiving data) and conversely, can determine
which other PETs are going to receive data and how much (for
sending data).

<P>
For example, the FieldExcl system test creates 2 Gridded Components
on separate subsets of PETs.  They use the option of mapping
particular, non-monotonic PETs to DEs.  The following figures 
illustrate how the DEs are mapped in each of the Gridded Components
in that test:

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_source"></A><A NAME="7996"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 7:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the source grid created by <TT>user_model1.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_src_grid}}$
 -->
<IMG
 WIDTH="421" HEIGHT="248" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_src_grid}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_destination"></A><A NAME="7998"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 8:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the destination grid created by <TT>user_model2.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_dst_grid}}$
 -->
<IMG
 WIDTH="414" HEIGHT="238" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_dst_grid}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
In the coupler code, all PETs must make the reconcile call before
accessing data in the State.  On PETs which already contain data,
the objects are unchanged.  On PETs which were not involved during
the creation of the FieldBundles or Fields, the reconcile call adds an
object to the State which contains all the same metadata associated
with the object, but creates a slightly different Grid object,
called a Proxy Grid. These PETs contain no local data, so the
Array object is empty, and the DELayout for the Grid is like this:

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_source_cpl"></A><A NAME="8000"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 9:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the source grid after the reconcile call in <TT>user_coupler.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_src_grid_cpl}}$
 -->
<IMG
 WIDTH="624" HEIGHT="289" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_src_grid_cpl}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:excl_destination_cpl"></A><A NAME="8002"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 10:</STRONG>
The mapping of PETs (processors) to DEs (data)
in the destination grid after the reconcile call in <TT>user_coupler.F90</TT>
in the FieldExcl system test.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Excl_dst_grid_cpl}}$
 -->
<IMG
 WIDTH="688" HEIGHT="296" ALIGN="BOTTOM" BORDER="0"
 SRC="img11.png"
 ALT="\scalebox{0.9}{\includegraphics{Excl_dst_grid_cpl}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION04056000000000000000">
17.6 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
State class.  States can contain FieldBundles, Fields, Arrays, or nested
States.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="749" HEIGHT="216" ALIGN="BOTTOM" BORDER="0"
 SRC="img12.png"
 ALT="\includegraphics[]{State_obj}">   

</DIV>

<P>

<H2><A NAME="SECTION04057000000000000000">
17.7 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04057100000000000000">
17.7.1 ESMF_StateAssignment(=) - State assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface assignment(=)
   state1 = state2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State) :: state1
   type(ESMF_State) :: state2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign state1 as an alias to the same ESMF State object in memory
   as state2. If state2 is invalid, then state1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>state1</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>state2</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04057200000000000000">
17.7.2 ESMF_StateOperator(==) - State equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
   if (state1 == state2) then ... endif
   OR
   result = (state1 == state2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(in) :: state1
   type(ESMF_State), intent(in) :: state2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether state1 and state2 are valid aliases to the same ESMF
   State object in memory. For a more general comparison of two ESMF States,
   going beyond the simple alias test, the ESMF_StateMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>state1</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>state2</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04057300000000000000">
17.7.3 ESMF_StateOperator(/=) - State not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
   if (state1 /= state2) then ... endif
   OR
   result = (state1 /= state2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(in) :: state1
   type(ESMF_State), intent(in) :: state2
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether state1 and state2 are <I>not</I> valid aliases to the
   same ESMF State object in memory. For a more general comparison of two ESMF
   States, going beyond the simple alias test, the ESMF_StateMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>state1</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>state2</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04057400000000000000">
17.7.4 ESMF_StateAdd - Add a list of items to a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_StateAdd(state, &lt;itemList&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(inout) :: state
   &lt;itemList&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Add a list of items to a <TT>ESMF_State</TT>. It is an error if any item in
   &lt;itemlist&gt; already matches, by name, an item already contained in <TT>state</TT>.

<P>
Supported values for &lt;itemList&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: arrayList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: fieldList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(in) :: routehandleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: nestedStateList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> to which the &lt;itemList&gt; will be added.
   
</DD>
<DT><STRONG>&lt;itemList&gt;</STRONG></DT>
<DD>The list of items to be added.
   This is a reference only; when
   the <TT>ESMF_State</TT> is destroyed the &lt;itemList&gt; items contained within it will
   not be destroyed. Also, the items in the &lt;itemList&gt; cannot be safely
   destroyed before the <TT>ESMF_State</TT> is destroyed.
   Since &lt;itemList&gt; items can be added to multiple containers, it remains
   the responsibility of the user to manage their
   destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04057500000000000000">
17.7.5 ESMF_StateAddReplace - Add or replace a list of items to a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_StateAddReplace(state, &lt;itemList&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(inout) :: state
   &lt;itemList&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Add or replace a list of items to an <TT>ESMF_State</TT>. If an item in
   &lt;itemlist&gt; does not match any items already present in <TT>state</TT>, it is
   added. Items with names already present in the <TT>state</TT> replace the
   existing item.

<P>
Supported values for &lt;itemList&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: arrayList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: fieldList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(in) :: routehandleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: nestedStateList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> to which the &lt;itemList&gt; will be added or replaced.
   
</DD>
<DT><STRONG>&lt;itemList&gt;</STRONG></DT>
<DD>The list of items to be added or replaced.
   This is a reference only; when
   the <TT>ESMF_State</TT> is destroyed the &lt;itemList&gt; items contained within it will
   not be destroyed. Also, the items in the &lt;itemList&gt; cannot be safely
   destroyed before the <TT>ESMF_State</TT> is destroyed.
   Since &lt;itemList&gt; items can be added to multiple containers, it remains
   the responsibility of the user to manage their
   destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION04057600000000000000">
17.7.6 ESMF_StateCreate - Create a new State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_StateCreate(stateintent, &amp;
                    arrayList, arraybundleList, &amp;
                    fieldList, fieldbundleList, &amp;
                    nestedStateList, &amp;
                    routehandleList, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_State) :: ESMF_StateCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_StateIntent_Flag), intent(in), optional :: stateintent
       type(ESMF_Array), intent(in), optional :: arrayList(:)
       type(ESMF_ArrayBundle), intent(in), optional :: arraybundleList(:)
       type(ESMF_Field), intent(in), optional :: fieldList(:)
       type(ESMF_FieldBundle), intent(in), optional :: fieldbundleList(:)
       type(ESMF_State), intent(in), optional :: nestedStateList(:)
       type(ESMF_RouteHandle), intent(in), optional :: routehandleList(:)
       character(len=*), intent(in), optional :: name
       integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_State</TT>, set default characteristics for
   objects added to it, and optionally add initial objects to it.

<P>
The arguments are:
   <DL>
<DT><STRONG>[stateintent]</STRONG></DT>
<DD>Import or Export <TT>ESMF_State</TT>. Valid values are
   <TT>ESMF_STATEINTENT_IMPORT</TT>, <TT>ESMF_STATEINTENT_EXPORT</TT>,
   or <TT>ESMF_STATEINTENT_UNSPECIFIED</TT> The default
   is <TT>ESMF_STATEINTENT_UNSPECIFIED</TT>.
   
</DD>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_Array</TT>s.
   
</DD>
<DT><STRONG>[arraybundleList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_ArrayBundle</TT>s.
   
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_Field</TT>s.
   
</DD>
<DT><STRONG>[fieldbundleList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_FieldBundle</TT>s.
   
</DD>
<DT><STRONG>[nestedStateList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_State</TT>s to be nested
   inside the outer <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>[routehandleList]</STRONG></DT>
<DD>A list (Fortran array) of <TT>ESMF_RouteHandle</TT>s.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of this <TT>ESMF_State</TT> object. A default name will be generated
   if none is specified.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04057700000000000000">
17.7.7 ESMF_StateDestroy - Release resources for a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       recursive subroutine ESMF_StateDestroy(state, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(inout) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_State</TT>. Actual
   objects added to <TT>ESMF_State</TT>s will not be destroyed, it
   remains the responsibility of the user to destroy these objects in the correct
   context.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>Destroy contents of this <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04057800000000000000">
17.7.8 ESMF_StateGet - Get information about a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_StateGet()
       subroutine ESMF_StateGetInfo(state, &amp;
             itemSearch, nestedFlag, stateintent, &amp;
             itemCount, itemNameList, itemTypeList, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in), optional :: itemSearch
       logical, intent(in), optional :: nestedFlag
       type(ESMF_StateIntent_Flag), intent(out), optional :: stateintent
       integer, intent(out), optional :: itemCount
       character (len=*), intent(out), optional :: itemNameList(:)
       type(ESMF_StateItem_Flag), intent(out), optional :: itemTypeList(:)
       character (len=*), intent(out), optional :: name
       integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the requested information about this <TT>ESMF_State</TT>.
   The optional <TT>itemSearch</TT> argument may specify the name of
   an individual item to search for. When used in conjunction with
   the <TT>nestedFlag</TT>, nested States will also be searched.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> object to be queried.
   
</DD>
<DT><STRONG>[itemSearch]</STRONG></DT>
<DD>Query objects by name in the State. When the <TT>nestedFlag</TT>
   option is set to .true., all nested States will also be searched
   for the specified name.
   
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD>When set to <TT>.false.</TT>, returns information at the current
   State level only (default)
   When set to <TT>.true.</TT>, additionally returns information from
   nested States
   
</DD>
<DT><STRONG>[stateintent]</STRONG></DT>
<DD>Returns the type, e.g., Import or Export, of this <TT>ESMF_State</TT>.
   Possible values are listed in Section&nbsp;<A HREF="node4.html#const:stateintent">17.2.1</A>.
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>Count of items in this <TT>ESMF_State</TT>.
   When the <TT>nestedFlag</TT> option is
   set to <TT>.true.</TT>, the count will include items present in nested
   States. When using <TT>itemSearch</TT>, it will count the number of
   items matching the specified name.
   
</DD>
<DT><STRONG>[itemNameList]</STRONG></DT>
<DD>Array of item names in this <TT>ESMF_State</TT>.
   When the <TT>nestedFlag</TT> option is
   set to <TT>.true.</TT>, the list will include items present in nested
   States. When using <TT>itemSearch</TT>, it will return the names of
   items matching the specified name. <TT>itemNameList</TT> must be at least
   <TT>itemCount</TT> long.
   
</DD>
<DT><STRONG>[itemTypeList]</STRONG></DT>
<DD>Array of possible item object types in this <TT>ESMF_State</TT>.
   When the <TT>nestedFlag</TT> option is
   set to <TT>.true.</TT>, the list will include items present in nested
   States. When using <TT>itemSearch</TT>, it will return the types of
   items matching the specified name. Must be at least <TT>itemCount</TT>
   long. Return values are listed in Section&nbsp;<A HREF="node4.html#const:stateitem">17.2.2</A>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Returns the name of this <TT>ESMF_State</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>
Typically, an <TT>ESMF_StateGet()</TT> information request will be performed
   twice. The first time, the <TT>itemCount</TT> argument will be used to
   query the size of arrays that are needed. Arrays can then be allocated
   to the correct size for <TT>itemNameList</TT> and <TT>itemtypeList</TT>
   as needed. A second call to <TT>ESMF_StateGet()</TT> will then fill in the
   values.

<P>

<P>

<H3><A NAME="SECTION04057900000000000000">
17.7.9 ESMF_StateGet - Retrieve an item from a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_StateGet(state, itemName, &lt;item&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(in) :: state
   character (len=*), intent(in) :: itemName
   &lt;item&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns an &lt;item&gt; from an <TT>ESMF_State</TT> by name.
   If the <TT>ESMF_State</TT> contains the &lt;item&gt; directly, only
   <TT>itemName</TT> is required.

<P>
If the <TT>state</TT> contains nested <TT>ESMF_State</TT>s,
   the <TT>itemName</TT> argument may specify a fully qualified name
   to access the desired item with a single call. This is performed
   using the ``/'' character to separate the names of the intermediate
   State names leading to the desired item. (E.g.,
   <TT>itemName=``state1/state12/item''</TT>).

<P>
Supported values for &lt;item&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(out) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(out) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(out) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(out) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(out) :: routehandle
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(out) :: nestedState
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>State to query for an &lt;item&gt; named <TT>itemName</TT>.
   
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>Name of &lt;item&gt; to be returned. This name may be fully
   qualified in order to access nested State items.
   
</DD>
<DT><STRONG>&lt;item&gt;</STRONG></DT>
<DD>Returned reference to the &lt;item&gt;.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040571000000000000000">
17.7.10 ESMF_StateGet - Get information about an item in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_StateGet()
       subroutine ESMF_StateGetItemInfo(state, itemName, itemType, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
       character (len=*), intent(in) :: itemName
       type(ESMF_StateItem_Flag), intent(out) :: itemType
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the type for the item named
   <TT>name</TT> in this <TT>ESMF_State</TT>. If no item with this name
   exists, the value <TT>ESMF_STATEITEM_NOTFOUND</TT> will be returned
   and the error code will not be set to an error. Thus this routine
   can be used to safely query for the existance of items by name
   whether or not they are expected to be there. The error code will
   be set in case of other errors, for example if the <TT>ESMF_State</TT>
   itself is invalid.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD><TT>ESMF_State</TT> to be queried.
   
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>Name of the item to return information about.
   
</DD>
<DT><STRONG>itemType</STRONG></DT>
<DD>Returned item types for the item with the given name, including
   placeholder names. Options are
   listed in Section&nbsp;<A HREF="node4.html#const:stateitem">17.2.2</A>. If no item with the
   given name is found, <TT>ESMF_STATEITEM_NOTFOUND</TT> will be returned
   and <TT>rc</TT> will <B>not</B> be set to an error.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040571100000000000000">
17.7.11 ESMF_StatePrint - Print State information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StatePrint(state, options, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
       character(len=*), intent(in), optional :: options
       logical, intent(in), optional :: nestedFlag
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>state</TT> to <TT>stdout</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to print.
   
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options:
   " ", or "brief" - print names and types of the objects within the state (default),
   "long" - print additional information, such as proxy flags
   
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD>When set to <TT>.false.</TT>, prints information about the current
   State level only (default),
   When set to <TT>.true.</TT>, additionally prints information from
   nested States
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040571200000000000000">
17.7.12 ESMF_StateRead - Read data items from a file into a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateRead(state, fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(inout) :: state
       character (len=*), intent(in) :: fileName
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Currently limited to read in all Arrays from a netCDF file and add them
   to a State object. Future releases will enable more items of a State
   to be read from a file of various formats.

<P>
Only PET 0 reads the file; the States in other PETs remain empty.
   Currently, the data is not decomposed or distributed; each PET
   has only 1 DE and only PET 0 contains data after reading the file.
   Future versions of ESMF will support data decomposition and distribution
   upon reading a file. See Section&nbsp;<A HREF="node4.html#example:StateRdWr">17.3.7</A> for
   an example.

<P>
Note that the third party NetCDF library must be installed. For more
   details, see the "ESMF Users Guide",
   "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
   the website http:

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to add items read from file. Currently only
   Arrays are supported.
   
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>File to be read.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   Equals <TT>ESMF_RC_LIB_NOT_PRESENT</TT> if the NetCDF library is
   not present.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040571300000000000000">
17.7.13 ESMF_StateReconcile - Reconcile State data across all PETs in a VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateReconcile(state, vm, attreconflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State),            intent(inout)         :: state
       type(ESMF_VM),               intent(in),  optional :: vm
       type(ESMF_AttReconcileFlag), intent(in),  optional :: attreconflag
       integer,                     intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Must be called for any <TT>ESMF_State</TT> which contains ESMF objects
       that have not been created on all the <TT>PET</TT>s of the currently
       running <TT>ESMF_Component</TT>.  
       For example, if a coupler is operating on data
       which was created by another component that ran on only a subset
       of the coupler's <TT>PET</TT>s, the coupler must make this call first
       before operating on any data inside that <TT>ESMF_State</TT>.
       After calling <TT>ESMF_StateReconcile</TT> all <TT>PET</TT>s will have
       a common view of all objects contained in this <TT>ESMF_State</TT>.
       The option to reconcile the metadata associated with the objects
       contained in this <TT>ESMF_State</TT> also exists.  The default behavior
       for this capability is to <I>not</I> reconcile metadata unless told
       otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD><TT>ESMF_State</TT> to reconcile.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD><TT>ESMF_VM</TT> for this <TT>ESMF_Component</TT>.  By default, it set to the current vm.
       
</DD>
<DT><STRONG>[attreconflag]</STRONG></DT>
<DD>Flag to tell if Attribute reconciliation is to be done as well as data reconciliation.
         This flag is documented in section <A HREF="node2.html#const:attreconcile">9.4</A>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040571400000000000000">
17.7.14 ESMF_StateRemove - Remove an item from a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_StateRemove (state, itemName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout) :: state
     character(*), intent(in) :: itemName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Remove an existing reference to an item from a <TT>State</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> within which <TT>itemName</TT> will be replaced.
   
</DD>
<DT><STRONG>itemName</STRONG></DT>
<DD>The name of the item to be removed. This is a reference only.
   The item itself is unchanged.

<P>
If the <TT>state</TT> contains nested <TT>ESMF_State</TT>s,
   the <TT>itemName</TT> argument may specify a fully qualified name
   to remove the desired item with a single call. This is performed
   using the ``/'' character to separate the names of the intermediate
   State names leading to the desired item. (E.g.,
   <TT>itemName=``state1/state12/item''</TT>.

<P>
Since items could potentially be referenced by multiple containers,
   it remains the responsibility of the user to manage their
   destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION040571500000000000000">
17.7.15 ESMF_StateReplace - Replace a list of items within a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_StateReplace(state, &lt;itemList&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_State), intent(inout) :: state
   &lt;itemList&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Replace a list of items with a <TT>ESMF_State</TT>. If an item in
   &lt;itemlist&gt; does not match any items already present in <TT>state</TT>, an
   error is returned.

<P>
Supported values for &lt;itemList&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(in) :: arrayList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(in) :: arraybundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(in) :: fieldList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(in) :: fieldbundleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_RouteHandle), intent(in) :: routehandleList(:)
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(in) :: nestedStateList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> within which the &lt;itemList&gt; items will be replaced.
   
</DD>
<DT><STRONG>&lt;itemList&gt;</STRONG></DT>
<DD>The list of items to be replaced.
   This is a reference only; when
   the <TT>ESMF_State</TT> is destroyed the &lt;itemList&gt; contained in it will
   not be destroyed. Also, the items in the &lt;itemList&gt; cannot be safely
   destroyed before the <TT>ESMF_State</TT> is destroyed.
   Since &lt;itemList&gt; items can be added to multiple containers, it remains
   the responsibility of the user to manage their
   destruction when they are no longer in use.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<H3><A NAME="SECTION040571600000000000000">
17.7.16 ESMF_StateValidate - Check validity of a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateValidate(state, nestedFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State), intent(in) :: state
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,          intent(in),  optional :: nestedFlag
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   
<UL>
<LI>This interface is backward compatible with ESMF versions starting at 5.2.0r. If code using this interface compiles with any version of ESMF from 5.2.0r up to the current version, then it will compile with the current version.
   
</LI>
</UL>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>state</TT> is internally consistent.
        Currently this method determines if the <TT>State</TT> is uninitialized 
        or already destroyed.  The method returns an error code if problems 
        are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to validate.
       
</DD>
<DT><STRONG>[nestedFlag]</STRONG></DT>
<DD><TT>.false.</TT> - validates at the current State level only (default)
         <TT>.true.</TT> - recursively validates any nested States
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION040571700000000000000">
17.7.17 ESMF_StateWrite - Write items from a State to file</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StateWrite(state, fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_State),  intent(in)            :: state 
       character (len=*), intent(in)            :: fileName
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Currently limited to write out all Arrays of a State object to a
       netCDF file.  Future releases will enable more item types of a State to
       be written to files of various formats.

<P>
Writing is currently limited to PET 0; future versions of ESMF will allow
       parallel writing, as well as parallel reading.

<P>
See Section&nbsp;<A HREF="node4.html#example:StateRdWr">17.3.7</A> for an example.

<P>
Note that the third party NetCDF library must be installed.  For more
       details, see the "ESMF Users Guide",
       "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
       the website http://www.unidata.ucar.edu/software/netcdf.

<P>
The arguments are:
       <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> from which to write items.  Currently limited to
         Arrays.
       
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>File to be written.  
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
         Equals <TT>ESMF_RC_LIB_NOT_PRESENT</TT> if the NetCDF library is
         not present.
       
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION04060000000000000000">
18 Attachable Methods</A>
</H1>

<P>

<H2><A NAME="SECTION04061000000000000000">
18.1 Description</A>
</H2>

<P>
ESMF allows user methods to be attached to Components and States. Providing
this capability supports a more object oriented way of model design. 

<P>
Attachable methods on Components can be used to implement the concept of
generic Components where the specialization requires attaching methods with
well defined names. This methods are then called by the generic Component 
code.

<P>
Attaching methods to States can be used to supply data operations along with
the data objects inside of a State object. This can be useful where a producer
Component not only supplies a data set, but also the associated processing
functionality. This can be more efficient than providing all of the possible
sets of derived data.

<P>

<H2><A NAME="SECTION04062000000000000000">
18.2 Use and Examples</A>
</H2>

<P>
The following examples demonstrate how a producer Component attaches a
user defined method to a State, and how it implements the method. The attached
method is then executed by the consumer Component.

<P>

<P>

<P>

<H3><A NAME="SECTION04062100000000000000">
18.2.1 Producer Component attaches user defined method</A>
</H3>

<P>
The producer Component attaches a user defined method to <TT>exportState</TT>
    during the Component's initialize method. The user defined method is
    attached with label <TT>finalCalculation</TT> by which it will become
    accessible to the consumer Component. 

<P>
<PRE>
  subroutine init(gcomp, importState, exportState, clock, rc)
    ! arguments
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: importState, exportState
    type(ESMF_Clock):: clock
    integer, intent(out):: rc
    
    call ESMF_MethodAdd(exportState, label="finalCalculation", &amp;
      userRoutine=finalCalc, rc=rc)

    rc = 0
  end subroutine !--------------------------------------------------------------
</PRE>

<P>

<H3><A NAME="SECTION04062200000000000000">
18.2.2 Producer Component implements user defined method</A>
</H3>

<P>
The producer Component implements the attached, user defined method
    <TT>finalCalc</TT>. Strict interface rules apply for the user defined
    method. 

<P>
<PRE>
  subroutine finalCalc(state, rc)
    ! arguments
    type(ESMF_State):: state
    integer, intent(out):: rc

    ! access data objects in state and perform calculation
    
    print *, "dummy output from attached method "

    rc = 0
  end subroutine !--------------------------------------------------------------
</PRE>

<P>

<H3><A NAME="SECTION04062300000000000000">
18.2.3 Consumer Component executes user defined method</A>
</H3>

<P>
The consumer Component executes the user defined method on the
    <TT>importState</TT>.

<P>
<PRE>
  subroutine init(gcomp, importState, exportState, clock, rc)
    ! arguments
    type(ESMF_GridComp):: gcomp
    type(ESMF_State):: importState, exportState
    type(ESMF_Clock):: clock
    integer, intent(out):: rc
    
    integer:: userRc
    
    call ESMF_MethodExecute(importState, label="finalCalculation", &amp;
      userRc=userRc, rc=rc)

    rc = 0
  end subroutine !--------------------------------------------------------------
</PRE>

<P>

<P>

<H2><A NAME="SECTION04063000000000000000">
18.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Not reconciled.</B>
Attachable Methods are PET-local settings on an object. Currently Attachable
Methods cannot be reconciled (i.e. ignored during <TT>ESMF_StateReconcile()</TT>).
</LI>
<LI><B>No copy nor move.</B>
Currently Attachable Methods cannot be copied or moved between objects.
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION04064000000000000000">
18.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION04064100000000000000">
18.4.1 ESMF_MethodAdd - Attach user method to State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodStateAdd(state, label, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     interface
       subroutine userRoutine(state, rc)
         use ESMF_StateMod
         implicit none
         type(ESMF_State)            :: state        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.  The subroutine must be either a module scope procedure, or an
     external procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04064200000000000000">
18.4.2 ESMF_MethodAdd - Attach user method, located in shared object, to State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodStateAddShObj(state, label, userRoutine, &amp;
 		sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodStateAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.  The subroutine must be either a module scope procedure, or an
     external procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04064300000000000000">
18.4.3 ESMF_MethodExecute - Execute user method attached to State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodExecute()
   subroutine ESMF_MethodStateExecute(state, label, existflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[existflag]</STRONG></DT>
<DD>Returned <TT>.true.</TT> indicates that the method specified by <TT>label</TT>
     exists and was executed. A return value of <TT>.false.</TT> indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if <TT>existflag</TT> was not specified, the latter condition will lead
     to <TT>rc</TT> not equal <TT>ESMF_SUCCESS</TT> being returned. However, if
     <TT>existflag</TT> was specified, a method not existing is not an error
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by attached method before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04064400000000000000">
18.4.4 ESMF_MethodRemove - Remove user method attached to State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodStateRemove(state, label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                        :: state
     character(len=*), intent(in)            :: label
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Remove attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04064500000000000000">
18.4.5 ESMF_MethodAdd - Attach user method to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodGridCompAdd(gcomp, label, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     interface
       subroutine userRoutine(gcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_GridComp)         :: gcomp        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.  The subroutine must be either a module scope procedure, or an
     external procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04064600000000000000">
18.4.6 ESMF_MethodAdd - Attach user method, located in shared object, to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodGridCompAddShObj(gcomp, label, userRoutine, &amp;
 	sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodGridCompAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.  The subroutine must be either a module scope procedure, or an
     external procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04064700000000000000">
18.4.7 ESMF_MethodAdd - Attach user method to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodCplCompAdd(cplcomp, label, userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     interface
       subroutine userRoutine(cplcomp, rc)
         use ESMF_CompMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>The user-supplied subroutine to be associated with the <TT>label</TT>.

<P>
The subroutine must have the exact interface shown above
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.  The subroutine must be either a module scope procedure, or an
     external procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04064800000000000000">
18.4.8 ESMF_MethodAdd - Attach user method, located in shared object, to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodAdd()
   subroutine ESMF_MethodCplCompAddShObj(cplcomp, label, userRoutine, &amp;
 		sharedObj, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     character(len=*), intent(in)            :: userRoutine
     character(len=*), intent(in),  optional :: sharedObj
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach <TT>userRoutine</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>userRoutine</STRONG></DT>
<DD>Name of user-supplied subroutine to be associated with the <TT>label</TT>,
     specified as a character string.

<P>
The subroutine must have the exact interface shown in <TT>ESMF_MethodCplCompAdd</TT>
     for the <TT>userRoutine</TT> argument. Arguments in <TT>userRoutine</TT>
     must not be declared as optional, and the types, intent and order must
     match.  The subroutine must be either a module scope procedure, or an
     external procedure that has a matching interface block specified for it.
     It must not be an internal procedure which is contained
     within another procedure.
   
</DD>
<DT><STRONG>[sharedObj]</STRONG></DT>
<DD>Name of shared object that contains <TT>userRoutine</TT>. If the
     <TT>sharedObj</TT> argument is not provided the executable itself will be
     searched for <TT>userRoutine</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION04064900000000000000">
18.4.9 ESMF_MethodExecute - Execute user method attached to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodExecute()
   subroutine ESMF_MethodGridCompExecute(gcomp, label, existflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[existflag]</STRONG></DT>
<DD>Returned <TT>.true.</TT> indicates that the method specified by <TT>label</TT>
     exists and was executed. A return value of <TT>.false.</TT> indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if <TT>existflag</TT> was not specified, the latter condition will lead
     to <TT>rc</TT> not equal <TT>ESMF_SUCCESS</TT> being returned. However, if
     <TT>existflag</TT> was specified, a method not existing is not an error
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by attached method before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040641000000000000000">
18.4.10 ESMF_MethodExecute - Execute user method attached to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodExecute()
   subroutine ESMF_MethodCplCompExecute(cplcomp, label, existflag, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     logical,          intent(out), optional :: existflag
     integer,          intent(out), optional :: userRc
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Execute attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[existflag]</STRONG></DT>
<DD>Returned <TT>.true.</TT> indicates that the method specified by <TT>label</TT>
     exists and was executed. A return value of <TT>.false.</TT> indicates that
     the method does not exist and consequently was not executed. By default,
     i.e. if <TT>existflag</TT> was not specified, the latter condition will lead
     to <TT>rc</TT> not equal <TT>ESMF_SUCCESS</TT> being returned. However, if
     <TT>existflag</TT> was specified, a method not existing is not an error
     condition.
   
</DD>
<DT><STRONG>[userRc]</STRONG></DT>
<DD>Return code set by attached method before returning.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040641100000000000000">
18.4.11 ESMF_MethodRemove - Remove user method attached to GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodGridCompRemove(gcomp, label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: gcomp
     character(len=*), intent(in)            :: label
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Remove attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION040641200000000000000">
18.4.12 ESMF_MethodRemove - Remove user method attached to CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MethodRemove()
   subroutine ESMF_MethodCplCompRemove(cplcomp, label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: cplcomp
     character(len=*), intent(in)            :: label
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Remove attached method.

<P>
The arguments are:
   <DL>
<DT><STRONG>cplcomp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> to attach to.
   
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Label of method.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION04070000000000000000">
19 Web Services</A>
</H1>

<P>

<H2><A NAME="SECTION04071000000000000000">
19.1 Description</A>
</H2>

<P>
The goal of the ESMF Web Services is to provide the tools to allow ESMF Users to make 
their Components available via a web service.  The first step is to make the Component 
a service, and then make it accessible via the Web.  

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:webservices_fig"></A><A NAME="10227"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 11:</STRONG>
The diagram describes the ESMF Web Services software architecture. The architecture
defines a multi-tiered set of applications that provide a flexible approach for accessing
model components.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.5}{\includegraphics{webservices}}$
 -->
<IMG
 WIDTH="490" HEIGHT="445" ALIGN="BOTTOM" BORDER="0"
 SRC="img13.png"
 ALT="\scalebox{0.5}{\includegraphics{webservices}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
At the heart of this architecture is the Component Service; this is the 
application that does the model work.  The ESMF Web Services part provides a way to make 
the model accessible via a network API (Application Programming Interface). ESMF provides 
the tools to turn a model component into a service as well as the tools to access the 
service from the network. 

<P>
The Process Controller is a stand-alone application that provides a control mechanism between 
the end user and the Component Service.  The Process Controller is responsible for managing 
client information as well as restricting client access to a Component Service.  
(The role of the Process Controller is expected to expand in the future.)

<P>
The tomcat/axis2 application provides the access via the Web using standard SOAP 
protocols. Part of this application includes the SOAP interface definition 
(using a WSDL file) as well as some java code that provides the access to the Process 
Controller application.

<P>
Finally, the Registrar maintains a list of Component Services that are currently 
available;  Component Services register themselves with the Registrar when they 
startup, and unregister themselves when they shutdown.  The list of available services 
is maintained in an XML file and is accessible from the Registrar using its network API.

<P>

<H3><A NAME="SECTION04071100000000000000">
19.1.1 Creating a Service around a Component</A>
</H3>

<H3><A NAME="SECTION04071200000000000000">
19.1.2 Code Modifications</A>
</H3>
One of the goals in providing the tools to make Components into services was to make 
the process as simple and easy as possible.  Any model component that has been 
implemented using the ESMF Component Framework can easily be turned into a 
Component Services with just a minor change to the Application 
driver code.  (For details on the ESMF Framework, see the ESMF Developers Documentation.)

<P>
The primary function in ESMF Web Services is the ESMF_WebServicesLoop routine.  This 
function registers the Component Service with the Registrar and then sets up a 
network socket service that listens for requests from a client.  It starts a loop 
that waits for incoming requests and manages the routing of these requests to 
all PETs.  It is also responsible for making sure the appropriate ESMF 
routine (ESMF_Initialize, ESMF_Run or ESMF_Finalize) is called based on the incoming 
request. When the client has completed its interaction with the Component Service, 
the loop will be terminated and it will unregister the Component Service from the Registrar. 

<P>
To make all of this happen, the Application Driver just needs to replace its calls to 
ESMF_Initialize, ESMF_Run, and ESMF_Finalize with a single call to ESMF_WebServicesLoop. 

<P>
<PRE>
	use ESMF_WebServMod
	....

	call ESMF_WebServicesLoop(gridComponent, portNumber, returnCode)
</PRE>

<P>
That's all there is to turning an ESMF Component into a network-accessible 
ESMF Component Service.  For a detailed example of an ESMF Component turned into 
an ESMF Component Service, see the Examples in the Web Services section of the 
Developer' Guide.

<P>

<H3><A NAME="SECTION04071300000000000000">
19.1.3 Accessing the Service</A>
</H3>
Now that the Component is available as a service, it can be accessed remotely by any client 
that can communicate via TCP sockets.  The ESMF library, in addition to providing the 
service tools, also provides the classes to create C++ clients to access the Component 
Service via the socket interface.

<P>
However, the goal of ESMF Web Services is to make an ESMF Component accessible through 
a standard web service, which is accomplished through the Process Controller and the 
Tomcat/Axis2 applications

<P>

<H3><A NAME="SECTION04071400000000000000">
19.1.4 Client Application via C++ API</A>
</H3>

<P>
Interfacing to a Component service is fairly simple using the ESMF library.  The following 
code is a simple example of how to interface to a Component Service in C++ and request 
the initialize operation (the entire sample client can be found in the Web Services examples 
section of the ESMF Distribution):

<P>
<PRE>
	#include "ESMCI_WebServCompSvrClient.h"

	int  main(int  argc, char*  argv[])
	{
   	    int    portNum = 27060;
      	    int    clientId = 101;
   	    int    rc = ESMF_SUCCESS;

   	    ESMCI::ESMCI_WebServCompSvrClient   
                         client("localhost", portNum, clientId);

   	    rc = client.init();
   	    printf("Initialize return code: %d\n", rc);
	}
</PRE>

<P>
To see a complete description of the NetEsmfClient class, refer to the netesmf library 
section of the Web Services Reference Manual.

<P>

<H3><A NAME="SECTION04071500000000000000">
19.1.5 Process Controller</A>
</H3>

<P>
The Process Controller is basically just a instance of a C++ client application. It manages 
client access to the Component Service (only 1 client can access the service at a time), 
and will eventually be responsible for starting up and shutting down instances of 
Component Services (planned for a future release). The Process Controller application is 
built with the ESMF library and is included in the apps section of the distribution.

<P>

<H3><A NAME="SECTION04071600000000000000">
19.1.6 Tomcat/Axis2</A>
</H3>

<P>
The Tomcat/Axis2 "application" is essentially the Apache Tomcat server using 
the Apache Axis2 servlet to  implement web services using SOAP protocols. The web 
interface is defined by a WSDL file, and its implementation is handled by the Component 
Connector java code.  Tomcat and Axis2 are both open source projects that should be 
downloaded from the Apache web site, but the WSDL file, the Component Connector java 
code, and all required software for supporting the interface can be found next to the 
ESMF distribution in the web_services_server directory. This code is not included with 
the ESMF distribution because they can be distributed and installed independent of each other.

<P>

<H2><A NAME="SECTION04072000000000000000">
19.2 Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to use WebServices. ....

<P>

<P>

<P>

<H3><A NAME="SECTION04072100000000000000">
19.2.1 Making a Component available through WebServices</A>
</H3>

<P>
In this example a standard ESMF Component is made available through
    the WebServices interface. 

<P>
The first step is to make sure your callback routines for initialize, run
    and finalize are setup.  This is done by creating a register routine that
    sets the entry points for each of these callbacks.  In this example, we've
    packaged it all up into a separate module.   

<P>
<PRE>
module ESMF_WebServUserModel

  ! ESMF Framework module
  use ESMF

  implicit none

  public ESMF_WebServUserModelRegister

  contains

  !-------------------------------------------------------------------------
  !  The Registration routine
  !  
  subroutine ESMF_WebServUserModelRegister(comp, rc)
    type(ESMF_GridComp)  :: comp
    integer, intent(out) :: rc

    ! Initialize return code
    rc = ESMF_SUCCESS

    print *, "User Comp1 Register starting"

    ! Register the callback routines.

    call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_INITIALIZE, &amp;
                                    userRoutine=user_init, rc=rc)
    if (rc/=ESMF_SUCCESS) return ! bail out

    call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_RUN, &amp;
                                    userRoutine=user_run, rc=rc)
    if (rc/=ESMF_SUCCESS) return ! bail out

    call ESMF_GridCompSetEntryPoint(comp, ESMF_METHOD_FINALIZE, &amp;
                                    userRoutine=user_final, rc=rc)
    if (rc/=ESMF_SUCCESS) return ! bail out

    print *, "Registered Initialize, Run, and Finalize routines"
    print *, "User Comp1 Register returning"

  end subroutine

  !-------------------------------------------------------------------------
  !  The Initialization routine
  !  
  subroutine user_init(comp, importState, exportState, clock, rc)
    type(ESMF_GridComp)  :: comp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    ! Initialize return code
    rc = ESMF_SUCCESS

    print *, "User Comp1 Init"

  end subroutine user_init

  !-------------------------------------------------------------------------
  !  The Run routine
  !  
  subroutine user_run(comp, importState, exportState, clock, rc)
    type(ESMF_GridComp)  :: comp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    ! Initialize return code
    rc = ESMF_SUCCESS

    print *, "User Comp1 Run"

  end subroutine user_run

  !-------------------------------------------------------------------------
  !  The Finalization routine
  !  
  subroutine user_final(comp, importState, exportState, clock, rc)
    type(ESMF_GridComp)  :: comp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: clock
    integer, intent(out) :: rc

    ! Initialize return code
    rc = ESMF_SUCCESS

    print *, "User Comp1 Final"

  end subroutine user_final

end module ESMF_WebServUserModel
</PRE>

<P>
The actual driver code then becomes very simple; ESMF is initialized,
    the component is created, the callback functions for the component are
    registered, and the Web Service loop is started. 

<P>
<PRE>
program WebServicesEx
  ! ESMF Framework module
  use ESMF
  use ESMF_WebServMod
  use ESMF_WebServUserModel

  implicit none

  ! Local variables
  type(ESMF_GridComp) :: comp1     !! Grid Component
  integer             :: rc        !! Return Code
  integer             :: finalrc   !! Final return code
  integer             :: portNum   !! The port number for the listening socket
</PRE>

<P>
The port number specifies the id of the port on the local machine on which
    a listening socket will be created.  This socket is used by the service to
    wait for and receive requests from the client.  Check with your system
    administrator to determine an appropriate port to use for your service. 

<P>
<PRE>
  finalrc = ESMF_SUCCESS

  call ESMF_Initialize(defaultlogfilename="WebServicesEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
  ! create the grid component 
  comp1 = ESMF_GridCompCreate(name="My Component", rc=rc)
</PRE>

<P>
<PRE>
  ! Set up the register routine 
  call ESMF_GridCompSetServices(comp1, &amp;
          userRoutine=ESMF_WebServUserModelRegister, rc=rc)
</PRE>

<P>
<PRE>
  portNum = 27060

  ! Call the Web Services Loop and wait for requests to come in
  !call ESMF_WebServicesLoop(comp1, portNum, rc=rc)
</PRE>

<P>
The call to ESMF_WebServicesLoop will setup the listening socket for your
    service and will wait for requests from a client.  As requests are received,
    the Web Services software will process the requests and then return to the
    loop to continue to wait. 

<P>
The 3 main requests processed are INIT, RUN, and FINAL.  These requests 
    will then call the appropriate callback routine as specified in your 
    register routine (as specified in the ESMF_GridCompSetServices call).
    In this example, when the INIT request is received, the user_init routine
    found in the ESMF_WebServUserModel module is called. 

<P>
One other request is also processed by the Component Service, and that is
    the EXIT request.  When this request is received, the Web Services loop
    is terminated and the remainder of the code after the ESMF_WebServicesLoop
    call is executed. 

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program WebServicesEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION04073000000000000000">
19.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Manual Control of Process.</B>
Currently, the Component Service must be manually started and stopped.  Future plans include having the Process Controller be responsible for controlling the Component Service processes.
</LI>
<LI><B>Data Streaming.</B>
While data can be streamed from the web server to the client, it is not yet getting the data directly from the Component Service.  Instead, the Component Service exports the data to a file which the Process Controller can read and return across the network interface.  The data streaming capabilities will be a major component of future improvements to the Web Services architecture.
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION04074000000000000000">
19.4 Class API</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION04074100000000000000">
19.4.1 ESMF_WebServicesLoop </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_WebServicesLoop(comp, portNum, clientId, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                                 :: comp
     integer,                    intent(inout), optional :: portNum
     character(len=ESMF_MAXSTR), intent(in),    optional :: clientId
     integer,                    intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Encapsulates all of the functionality necessary to setup a component as
     a component service.  If this is the root PET, it registers the 
     component service and then enters into a loop that waits for requests on 
     a socket.  The loop continues until an "exit" request is received, at 
     which point it exits the loop and unregisters the service.  If this is
     any PET other than the root PET, it sets up a process block that waits
     for instructions from the root PET.  Instructions will come as requests
     are received from the socket.

<P>
The arguments are:
   <DL>
<DT><STRONG>[comp]</STRONG></DT>
<DD><TT>ESMF_GridComp</TT> object that represents the Grid Component for which
     routine is run.
   
</DD>
<DT><STRONG>[portNum]</STRONG></DT>
<DD>Number of the port on which the component service is listening.
   
</DD>
<DT><STRONG>[clientId]</STRONG></DT>
<DD>Identifer of the client responsible for this component service.  If a
     Process Controller application manages this component service, then the
     clientId is provided to the component service application in the command
     line.  Otherwise, the clientId is not necessary.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html1603"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1599"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1593"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1601"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1604"
  HREF="node5.html">4 Infrastructure: Fields and</A>
<B> Up:</B> <A NAME="tex2html1600"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1594"
  HREF="node3.html">2 Applications</A>
 &nbsp <B>  <A NAME="tex2html1602"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
