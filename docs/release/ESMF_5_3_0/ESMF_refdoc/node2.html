<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>1 ESMF Overview</TITLE>
<META NAME="description" CONTENT="1 ESMF Overview">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node3.html">
<LINK REL="previous" HREF="node1.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node3.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html1561"
  HREF="node3.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1557"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1551"
  HREF="node1.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1559"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1562"
  HREF="node3.html">2 Applications</A>
<B> Up:</B> <A NAME="tex2html1558"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1552"
  HREF="node1.html">Contents</A>
 &nbsp <B>  <A NAME="tex2html1560"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html1563"
  HREF="node2.html#SECTION02010000000000000000">1 What is the Earth System Modeling Framework?</A>
<LI><A NAME="tex2html1564"
  HREF="node2.html#SECTION02020000000000000000">2 The ESMF Reference Manual for Fortran</A>
<LI><A NAME="tex2html1565"
  HREF="node2.html#SECTION02030000000000000000">3 How to Contact User Support and Find Additional Information</A>
<LI><A NAME="tex2html1566"
  HREF="node2.html#SECTION02040000000000000000">4 How to Submit Comments, Bug Reports, and Feature Requests</A>
<LI><A NAME="tex2html1567"
  HREF="node2.html#SECTION02050000000000000000">5 Conventions</A>
<UL>
<LI><A NAME="tex2html1568"
  HREF="node2.html#SECTION02051000000000000000">5.1 Typeface and Diagram Conventions</A>
<LI><A NAME="tex2html1569"
  HREF="node2.html#SECTION02052000000000000000">5.2 Method Name and Argument Conventions</A>
</UL>
<LI><A NAME="tex2html1570"
  HREF="node2.html#SECTION02060000000000000000">6 The ESMF Application Programming Interface</A>
<UL>
<LI><A NAME="tex2html1571"
  HREF="node2.html#SECTION02061000000000000000">6.1 Standard Methods and Interface Rules</A>
<LI><A NAME="tex2html1572"
  HREF="node2.html#SECTION02062000000000000000">6.2 Deep and Shallow Classes</A>
<LI><A NAME="tex2html1573"
  HREF="node2.html#SECTION02063000000000000000">6.3 Special Methods</A>
<LI><A NAME="tex2html1574"
  HREF="node2.html#SECTION02064000000000000000">6.4 The ESMF Data Hierarchy</A>
<LI><A NAME="tex2html1575"
  HREF="node2.html#SECTION02065000000000000000">6.5 ESMF Spatial Classes</A>
<LI><A NAME="tex2html1576"
  HREF="node2.html#SECTION02066000000000000000">6.6 ESMF Maps</A>
<LI><A NAME="tex2html1577"
  HREF="node2.html#SECTION02067000000000000000">6.7 ESMF Specification Classes</A>
<LI><A NAME="tex2html1578"
  HREF="node2.html#SECTION02068000000000000000">6.8 ESMF Utility Classes</A>
</UL>
<LI><A NAME="tex2html1579"
  HREF="node2.html#SECTION02070000000000000000">7 Overall Rules and Behavior</A>
<UL>
<LI><A NAME="tex2html1580"
  HREF="node2.html#SECTION02071000000000000000">7.1 Local and Global Views and Associated Conventions</A>
<LI><A NAME="tex2html1581"
  HREF="node2.html#SECTION02072000000000000000">7.2 Allocation Rules</A>
<LI><A NAME="tex2html1582"
  HREF="node2.html#SECTION02073000000000000000">7.3 Assignment, Equality, Copying and Comparing Objects</A>
<LI><A NAME="tex2html1583"
  HREF="node2.html#SECTION02074000000000000000">7.4 Attributes</A>
</UL>
<LI><A NAME="tex2html1584"
  HREF="node2.html#SECTION02080000000000000000">8 Integrating ESMF into Applications</A>
<UL>
<LI><A NAME="tex2html1585"
  HREF="node2.html#SECTION02081000000000000000">8.1 Using the ESMF Superstructure</A>
</UL>
<LI><A NAME="tex2html1586"
  HREF="node2.html#SECTION02090000000000000000">9 Master List of Constants</A>
<UL>
<LI><A NAME="tex2html1587"
  HREF="node2.html#SECTION02091000000000000000">9.1 ESMF_ALARMLIST</A>
<LI><A NAME="tex2html1588"
  HREF="node2.html#SECTION02092000000000000000">9.2 ESMF_DIM_ARB</A>
<LI><A NAME="tex2html1589"
  HREF="node2.html#SECTION02093000000000000000">9.3 ESMF_ATTGETCOUNT</A>
<LI><A NAME="tex2html1590"
  HREF="node2.html#SECTION02094000000000000000">9.4 ESMF_ATTRECONCILE</A>
<LI><A NAME="tex2html1591"
  HREF="node2.html#SECTION02095000000000000000">9.5 ESMF_ATTTREE</A>
<LI><A NAME="tex2html1592"
  HREF="node2.html#SECTION02096000000000000000">9.6 ESMF_ATTWRITE</A>
<LI><A NAME="tex2html1593"
  HREF="node2.html#SECTION02097000000000000000">9.7 ESMF_CALKIND</A>
<LI><A NAME="tex2html1594"
  HREF="node2.html#SECTION02098000000000000000">9.8 ESMF_COMPTYPE</A>
<LI><A NAME="tex2html1595"
  HREF="node2.html#SECTION02099000000000000000">9.9 ESMF_CONTEXT</A>
<LI><A NAME="tex2html1596"
  HREF="node2.html#SECTION020910000000000000000">9.10 ESMF_COORDSYS</A>
<LI><A NAME="tex2html1597"
  HREF="node2.html#SECTION020911000000000000000">9.11 ESMF_COPY</A>
<LI><A NAME="tex2html1598"
  HREF="node2.html#SECTION020912000000000000000">9.12 ESMF_DATACOPY</A>
<LI><A NAME="tex2html1599"
  HREF="node2.html#SECTION020913000000000000000">9.13 ESMF_DECOMP</A>
<LI><A NAME="tex2html1600"
  HREF="node2.html#SECTION020914000000000000000">9.14 ESMF_DIRECTION</A>
<LI><A NAME="tex2html1601"
  HREF="node2.html#SECTION020915000000000000000">9.15 ESMF_DISTGRIDMATCH</A>
<LI><A NAME="tex2html1602"
  HREF="node2.html#SECTION020916000000000000000">9.16 ESMF_END</A>
<LI><A NAME="tex2html1603"
  HREF="node2.html#SECTION020917000000000000000">9.17 ESMF_FIELDSTATUS</A>
<LI><A NAME="tex2html1604"
  HREF="node2.html#SECTION020918000000000000000">9.18 ESMF_FILEFORMAT</A>
<LI><A NAME="tex2html1605"
  HREF="node2.html#SECTION020919000000000000000">9.19 ESMF_GEOMTYPE</A>
<LI><A NAME="tex2html1606"
  HREF="node2.html#SECTION020920000000000000000">9.20 ESMF_GRIDCONN</A>
<LI><A NAME="tex2html1607"
  HREF="node2.html#SECTION020921000000000000000">9.21 ESMF_GRIDITEM</A>
<LI><A NAME="tex2html1608"
  HREF="node2.html#SECTION020922000000000000000">9.22 ESMF_GRIDMATCH</A>
<LI><A NAME="tex2html1609"
  HREF="node2.html#SECTION020923000000000000000">9.23 ESMF_GRIDSTATUS</A>
<LI><A NAME="tex2html1610"
  HREF="node2.html#SECTION020924000000000000000">9.24 ESMF_INDEX</A>
<LI><A NAME="tex2html1611"
  HREF="node2.html#SECTION020925000000000000000">9.25 ESMF_IOFMT</A>
<LI><A NAME="tex2html1612"
  HREF="node2.html#SECTION020926000000000000000">9.26 ESMF_KIND</A>
<LI><A NAME="tex2html1613"
  HREF="node2.html#SECTION020927000000000000000">9.27 ESMF_LOGERR</A>
<LI><A NAME="tex2html1614"
  HREF="node2.html#SECTION020928000000000000000">9.28 ESMF_LOGKIND</A>
<LI><A NAME="tex2html1615"
  HREF="node2.html#SECTION020929000000000000000">9.29 ESMF_LOGMSG</A>
<LI><A NAME="tex2html1616"
  HREF="node2.html#SECTION020930000000000000000">9.30 ESMF_MESHELEMTYPE</A>
<LI><A NAME="tex2html1617"
  HREF="node2.html#SECTION020931000000000000000">9.31 ESMF_METHOD</A>
<LI><A NAME="tex2html1618"
  HREF="node2.html#SECTION020932000000000000000">9.32 ESMF_PIN</A>
<LI><A NAME="tex2html1619"
  HREF="node2.html#SECTION020933000000000000000">9.33 ESMF_POLEMETHOD</A>
<LI><A NAME="tex2html1620"
  HREF="node2.html#SECTION020934000000000000000">9.34 ESMF_POLEKIND</A>
<LI><A NAME="tex2html1621"
  HREF="node2.html#SECTION020935000000000000000">9.35 ESMF_REDUCE</A>
<LI><A NAME="tex2html1622"
  HREF="node2.html#SECTION020936000000000000000">9.36 ESMF_REGION</A>
<LI><A NAME="tex2html1623"
  HREF="node2.html#SECTION020937000000000000000">9.37 ESMF_REGRIDMETHOD</A>
<LI><A NAME="tex2html1624"
  HREF="node2.html#SECTION020938000000000000000">9.38 ESMF_ROUTESYNC</A>
<LI><A NAME="tex2html1625"
  HREF="node2.html#SECTION020939000000000000000">9.39 ESMF_SERVICEREPLY</A>
<LI><A NAME="tex2html1626"
  HREF="node2.html#SECTION020940000000000000000">9.40 ESMF_STAGGERLOC</A>
<LI><A NAME="tex2html1627"
  HREF="node2.html#SECTION020941000000000000000">9.41 ESMF_STARTREGION</A>
<LI><A NAME="tex2html1628"
  HREF="node2.html#SECTION020942000000000000000">9.42 ESMF_STATEINTENT</A>
<LI><A NAME="tex2html1629"
  HREF="node2.html#SECTION020943000000000000000">9.43 ESMF_STATEITEM</A>
<LI><A NAME="tex2html1630"
  HREF="node2.html#SECTION020944000000000000000">9.44 ESMF_SYNC</A>
<LI><A NAME="tex2html1631"
  HREF="node2.html#SECTION020945000000000000000">9.45 ESMF_TYPEKIND</A>
<LI><A NAME="tex2html1632"
  HREF="node2.html#SECTION020946000000000000000">9.46 ESMF_UNMAPPEDACTION</A>
<LI><A NAME="tex2html1633"
  HREF="node2.html#SECTION020947000000000000000">9.47 ESMF_VERSION</A>
<LI><A NAME="tex2html1634"
  HREF="node2.html#SECTION020948000000000000000">9.48 ESMF_XGRIDSIDE</A>
</UL>
<LI><A NAME="tex2html1635"
  HREF="node2.html#SECTION020100000000000000000">10 Overall Design and Implementation Notes</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION02000000000000000000">
1 ESMF Overview</A>
</H1>

<P>
<A NAME="part:ESMFOverview"></A>
<P>


<P>

<H1><A NAME="SECTION02010000000000000000">
1 What is the Earth System Modeling Framework?</A>
</H1>

<P>
The Earth System Modeling Framework (ESMF) is a suite of software
tools for developing high-performance, multi-component Earth science
modeling applications.  Such applications may include a few or dozens
of components representing atmospheric, oceanic, terrestrial, or
other physical domains, and their constituent processes (dynamical, chemical,
biological, etc.).  Often these components are developed by different
groups independently, and must be ``coupled'' together using software
that transfers and transforms data among the components in order to form
functional simulations.

<P>
ESMF supports the development of these complex applications in a number
of ways.  It introduces a set of simple, consistent component interfaces
that apply to all types of components, including couplers themselves.  These
interfaces expose in an obvious way the inputs and outputs of each component.
It offers a variety of data structures for transferring data between components, 
and libraries for regridding, time advancement, and other common modeling
functions.  Finally, it provides a growing set of tools for using metadata
to describe components and their input and output fields.  This capability
is important because components that are self-describing
can be integrated more easily into automated workflows, model and dataset
distribution and analysis portals, and other emerging ``semantically enabled''
computational environments.

<P>
ESMF is not a single Earth system model into which all components
must fit, and its distribution doesn't contain any scientific code.
Rather it provides a way of structuring components so that they can be used 
in many different user-written applications and contexts with minimal code
modification, and so they can be coupled together in new configurations
with relative ease.  The idea is to create many components across a
broad community, and so to encourage new collaborations and combinations.

<P>
ESMF offers the flexibility needed by this diverse user base.  It is tested
nightly on more than two dozen platform/compiler combinations; can be
run on one processor or thousands; supports shared and distributed memory
programming models and a hybrid model; can run components
sequentially (on all the same processors) or concurrently (on mutually
exclusive processors); and supports single executable or multiple
executable modes.

<P>
ESMF's generality and breadth of function can make it daunting for the
novice user.  To help users navigate the software, we try to apply
consistent names and behavior throughout and to provide many examples.
The large-scale structure of the software is straightforward.
The utilities and data structures for building modeling components 
are called the ESMF <I>infrastructure</I>.  The coupling interfaces and
drivers are called the <I>superstructure</I>.  User code sits between
these two layers, making calls to the infrastructure
libraries underneath and being scheduled and synchronized by the 
superstructure above.  The configuration resembles a sandwich, as
shown in Figure&nbsp;<A HREF="node2.html#fig:TheESMFwich">1</A>.

<P>
ESMF users may choose to extensively rewrite their codes
to take advantage of the ESMF infrastructure, or they may decide to
simply wrap their components in the ESMF superstructure in order to
utilize framework coupling services.  Either way, we encourage users
to contact our 
<A NAME="tex2html1"
  HREF="mailto:esmf_support@list.woc.noaa.gov">support team</A>
if questions arise about how to best
use the software, or how to structure their application.  ESMF is
more than software;  it's a group of people dedicated to realizing
the vision of a collaborative model development community that spans
insitutional and national bounds.

<P>

<H1><A NAME="SECTION02020000000000000000">
2 The ESMF Reference Manual for Fortran</A>
</H1>

<P>
ESMF has a complete set of Fortran interfaces and
some C interfaces.  This <I>ESMF Reference Manual</I> is a listing of 
ESMF interfaces for Fortran.<A NAME="tex2html2"
  HREF="footnode.html#foot264"><SUP>1</SUP></A>  

<P>
Interfaces are grouped by class.  A class is comprised of the data and
methods for a specific concept like a physical field.  Superstructure classes 
are listed first in this <I>Manual</I>, followed by infrastructure 
classes.

<P>
The major classes in the ESMF superstructure are Components, which 
usually represent
large pieces of functionality such as atmosphere and ocean models,
and States, which are the data structures
used to transfer data between Components.  There are both data
structures and utilities in the ESMF 
infrastructure. Data structures include multi-dimensional Arrays, Fields
that are comprised of an Array and a Grid, and collections of Arrays
and Fields called ArrayBundles and FieldBundles, respectively.
There are utility libraries for data decomposition and communications,
time management, logging and error handling, and application configuration.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:TheESMFwich"></A><A NAME="275"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 1:</STRONG>
Schematic of the ESMF ``sandwich'' architecture.
The framework consists of two parts, an upper level
<B>superstructure</B> layer and a lower level <B>infrastructure</B> layer.
User code is sandwiched between these two layers.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{ESMF_sandwich}}$
 -->
<IMG
 WIDTH="604" HEIGHT="331" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="\scalebox{1.0}{\includegraphics{ESMF_sandwich}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>

<H1><A NAME="SECTION02030000000000000000"></A>
<A NAME="sec:Support"></A>
<BR>
3 How to Contact User Support and Find Additional Information
</H1>
The ESMF team can answer questions about the interfaces presented in this 
document.  For user support, please contact 
<A NAME="tex2html4"
  HREF="mailto:esmf_support@list.woc.noaa.gov">esmf_support@list.woc.noaa.gov</A>.  

<P>
The website, <A NAME="tex2html5"
  HREF="http://www.earthsystemmodeling.org">http://www.earthsystemmodeling.org</A>, provide more information of the ESMF project as a whole.
The website includes release notes and known bugs for each version of the
framework, supported platforms, project history, values, and metrics, related projects,
the ESMF management structure, and more.  The <A NAME="tex2html6"
  HREF="http://www.earthsystemmodeling.org/esmf_releases/public/last/ESMF_usrdoc/"><I>ESMF User's Guide</I></A>
contains build and installation instructions, an overview of the ESMF system and a description of 
how its classes interrelate (this version of the document corresponds to the last public version of the framework).  Also available on the ESMF website is the 
<A NAME="tex2html7"
  HREF="http://www.earthsystemmodeling.org/documents/dev_guide/"><I>ESMF Developer's Guide</I></A>
that details ESMF procedures and conventions.  

<P>

<H1><A NAME="SECTION02040000000000000000"></A>
<A NAME="sec:Submission"></A>
<BR>
4 How to Submit Comments, Bug Reports, and Feature Requests
</H1>

We welcome input on any aspect of the ESMF project.  Send
questions and comments to 
<A NAME="tex2html8"
  HREF="mailto:esmf_support@list.woc.noaa.gov">esmf_support@list.woc.noaa.gov</A>.

<P>

<P>

<H1><A NAME="SECTION02050000000000000000"></A>
<A NAME="sec:conventions"></A>
<BR>
5 Conventions
</H1>

<P>

<H2><A NAME="SECTION02051000000000000000">
5.1 Typeface and Diagram Conventions</A>
</H2>

<P>

<P>
The following conventions for fonts and capitalization are used
in this and other ESMF documents. <BR>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT"><B>Style</B></TD>
<TD ALIGN="LEFT"><B>Meaning</B></TD>
<TD ALIGN="LEFT"><B>Example</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><I>italics</I></TD>
<TD ALIGN="LEFT">documents</TD>
<TD ALIGN="LEFT"><I>ESMF Reference Manual</I></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>courier</TT></TD>
<TD ALIGN="LEFT">code fragments</TD>
<TD ALIGN="LEFT"><TT>ESMF_TRUE</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><TT>courier()</TT></TD>
<TD ALIGN="LEFT">ESMF method name</TD>
<TD ALIGN="LEFT"><TT>ESMF_FieldGet()</TT></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>boldface</B></TD>
<TD ALIGN="LEFT">first definitions</TD>
<TD ALIGN="LEFT">An <B>address space</B> is ...</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>boldface</B></TD>
<TD ALIGN="LEFT">web links and tabs</TD>
<TD ALIGN="LEFT"><B>Developers</B> tab on the website</TD>
</TR>
<TR><TD ALIGN="LEFT">Capitals</TD>
<TD ALIGN="LEFT">ESMF class name</TD>
<TD ALIGN="LEFT">DataMap</TD>
</TR>
</TABLE> 

<P>
ESMF class names frequently coincide with words commonly
used within the Earth system domain (field, grid, component, array, 
etc.)  The convention we adopt in this manual is that if a word is 
used in the context of an ESMF class name it is capitalized, and 
if the word is used in a more general context it remains in lower 
case.  We would write, for example, that an ESMF Field class 
represents a physical field.  

<P>
Diagrams are drawn using the Unified Modeling Language (UML).  UML 
is a visual tool that can illustrate the structure of 
classes, define relationships between classes, and describe sequences
of actions.  A reader interested in more detail can refer to a 
text such as <I>The Unified Modeling Language Reference Manual.</I>
 [<A
 HREF="node8.html#uml">21</A>]

<P>

<H2><A NAME="SECTION02052000000000000000">
5.2 Method Name and Argument Conventions</A>
</H2>

<P>
Method names begin with <TT>ESMF_</TT>, followed by the class name, 
followed by the name of the operation being performed.  Each new 
word is capitalized.  Although Fortran interfaces are not case-sensitive,
we use case to help parse multi-word names.  

<P>
For method arguments that are multi-word, the first word is lower
case and subsequent words begin with upper case.  ESMF class 
names (including typed flags) are an exception.  When multi-word 
class names appear in argument lists, all letters after the first 
are lower case.  The first letter is lower case if the class is the
first word in the argument and upper case otherwise.  For 
example, in an argument list the DELayout class name may appear 
as <TT>delayout</TT> or <TT>srcDelayout</TT>.

<P>
Most Fortran calls in the ESMF are subroutines, with 
any returned values passed through the interface.  For the sake of 
convenience, some ESMF calls are written as functions.

<P>
A typical ESMF call looks like this:

<P>
<PRE>
call ESMF_&lt;ClassName&gt;&lt;Operation&gt;(classname, firstArgument, 
           secondArgument, ..., rc)
</PRE>

<P>
where <BR>
<TT>&lt;ClassName&gt;</TT> is the class name, <BR>
<TT>&lt;Operation&gt;</TT> is the name of the action to be performed, <BR>
<TT>classname</TT> is a variable of the derived type associated 
with the class, <BR>
the <TT>arg*</TT> arguments are whatever other variables are required 
for the operation, <BR>
and <TT>rc</TT> is a return code. <BR>

<P>


<P>

<H1><A NAME="SECTION02060000000000000000">
6 The ESMF Application Programming Interface</A>
</H1>

<P>
The ESMF Application Programming Interface (API) is based on the
object-oriented programming concept of a <B>class</B>.  A class is a 
software construct that is used for grouping a set of related variables 
together with the subroutines and functions that operate on them.  We 
use classes in ESMF because they help to organize the code, and often 
make it easier to maintain and understand.  A particular instance
of a class is called an <B>object</B>.  For example, Field is an 
ESMF class.  An actual Field called <TT>temperature</TT> is an object. 
That is about as far as we will go into software engineering
terminology.  

<P>
The Fortran interface is implemented so that the variables associated
with a class are stored in a derived type.  For example, an 
<TT>ESMF_Field</TT> derived type stores the data array, grid 
information, and metadata associated with a physical field.
The derived type for each class is stored in a Fortran module, and 
the operations associated with each class are defined as module
procedures.  We use the Fortran features of generic functions and
optional arguments extensively to simplify our interfaces.

<P>
The modules for ESMF are bundled together and can be accessed with a 
single <TT>USE</TT> statement, <TT>USE ESMF</TT>.

<P>

<H2><A NAME="SECTION02061000000000000000">
6.1 Standard Methods and Interface Rules</A>
</H2>

<P>
ESMF defines a set of standard methods and interface rules that
hold across the entire API.  These are: 

<P>

<UL>
<LI><TT>ESMF_&lt;Class&gt;Create()</TT> and <TT>ESMF_&lt;Class&gt;Destroy()</TT>, for
creating and destroying objects of ESMF classes that require internal memory
management (- called ESMF deep classes). The <TT>ESMF_&lt;Class&gt;Create()</TT> method
allocates memory for the object itself and for internal variables, and
initializes variables where appropriate.  It is always written as a Fortran
function that returns a derived type instance of the class, i.e. an object.

<P>
</LI>
<LI><TT>ESMF_&lt;Class&gt;Set()</TT> and <TT>ESMF_&lt;Class&gt;Get()</TT>, for setting and 
retrieving a particular item or flag.  In general, these methods are overloaded
for all cases where the item can be manipulated as a name/value pair.  If
identifying the item requires more than a name, or if the class is of
sufficient complexity that overloading in this way would result in an
overwhelming number of options, we define specific
<TT>ESMF_&lt;Class&gt;Set&lt;Something&gt;()</TT> and <TT>ESMF_&lt;Class&gt;Get&lt;Something&gt;()</TT>
interfaces.

<P>

</LI>
<LI><TT>ESMF_&lt;Class&gt;Add()</TT>, <TT>ESMF_&lt;Class&gt;AddReplace()</TT>,
<TT>ESMF_&lt;Class&gt;Remove()</TT>, and <TT>ESMF_&lt;Class&gt;Replace()</TT>, for manipulating
objects of ESMF container classes - such as <TT>ESMF_State</TT> and
<TT>ESMF_FieldBundle</TT>. For example, the <TT>ESMF_FieldBundleAdd()</TT>
method adds another Field to an existing FieldBundle object.

<P>
</LI>
<LI><TT>ESMF_&lt;Class&gt;Print()</TT>, for printing the contents of an object to 
standard out.  This method is mainly intended for debugging.

<P>
</LI>
<LI><TT>ESMF_&lt;Class&gt;ReadRestart()</TT> and <TT>ESMF_&lt;Class&gt;WriteRestart()</TT>, 
for saving the contents of a class and restoring it exactly.  Read
and write restart methods have not yet been implemented for most
ESMF classes, so where necessary the user needs to write restart 
values themselves.

<P>
</LI>
<LI><TT>ESMF_&lt;Class&gt;Validate()</TT>, for determining whether a class is 
internally consistent.  For example, <TT>ESMF_FieldValidate()</TT> validates
the internal consistency of a Field object.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION02062000000000000000"></A>
<A NAME="sec:deepshallow"></A>
<BR>
6.2 Deep and Shallow Classes
</H2>

<P>
The ESMF contains two types of classes.

<P>
<B>Deep</B> classes require
<TT>ESMF_&lt;Class&gt;Create()</TT> and <TT>ESMF_&lt;Class&gt;Destroy()</TT> calls.
They involve memory allocation take significant time to set up (involving
memory management) and should not be created in a time-critical portion of code.
Deep objects persist even after the method in which they were created has
returned. Most classes in ESMF, including GridComp, CplComp, State, Fields, FieldBundles, Arrays, ArrayBundles, Grids, and Clocks, fall into this category.

<P>
<TT>Shallow</TT> classes do not possess <TT>ESMF_&lt;Class&gt;Create()</TT>
and <TT>ESMF_&lt;Class&gt;Destroy()</TT> calls.  They are simply declared
and their values set using an <TT>ESMF_&lt;Class&gt;Set()</TT> call.  
Examples of shallow classes are Time, TimeInterval, and ArraySpec.  Shallow classes do not take long to set up and can be declared and set within
a time-critical code segment.  Shallow objects stop existing when
the method in which they were declared has returned.  

<P>
An exception to this is when a shallow object, such as a Time, 
is stored in a deep object such as a Clock.  The Clock then
carries a copy of the Time in persistent memory.  The Time is
deallocated with the <TT>ESMF_ClockDestroy()</TT> call.

<P>
See Section <A HREF="node2.html#sec:overallimpl">10</A>, Overall Design and Implementation 
Notes, for a brief discussion of deep and shallow classes from 
an implementation perspective.  For an in-depth look at the design 
and inter-language issues related to deep and shallow classes,
see the <A NAME="tex2html9"
  HREF="http://www.earthsystemmodeling.org/documents/IMPL_repdoc/"><I>ESMF Implementation Report</I></A>.

<P>

<H2><A NAME="SECTION02063000000000000000">
6.3 Special Methods</A>
</H2>

<P>
The following are special methods which, in one case,
are required by any application using ESMF, and in the 
other case must be called by any application that is using 
ESMF Components.

<P>

<UL>
<LI><TT>ESMF_Initialize()</TT> and <TT>ESMF_Finalize()</TT> are required 
methods that must bracket the use of ESMF within an application.  
They manage the resources required to run ESMF and shut it down
gracefully.  ESMF does not support restarts in the same executable, i.e.
<TT>ESMF_Initialize()</TT> should not be called after <TT>ESMF_Finalize()</TT>.
</LI>
<LI><TT>ESMF_&lt;Type&gt;CompInitialize()</TT>, <TT>ESMF_&lt;Type&gt;CompRun()</TT>, and <TT>ESMF_&lt;Type&gt;CompFinalize()</TT> are component methods that are used at the 
highest level within ESMF.  <TT>&lt;Type&gt;</TT> may be <TT>&lt;Grid&gt;</TT>, for 
Gridded Components such as oceans or atmospheres, or
<TT>&lt;Cpl&gt;</TT>, for Coupler Components that are used to connect 
them.  The content of these methods is not part of the ESMF.  
Instead the methods call into associated subroutines within 
user code.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION02064000000000000000">
6.4 The ESMF Data Hierarchy</A>
</H2>

<P>
The ESMF API is organized around an hierarchy of classes that 
contain model data.  The operations that are performed
on model data, such as regridding, redistribution, and halo 
updates, are methods of these classes.  

<P>
The main data classes in ESMF, in order of increasing complexity, are:

<UL>
<LI><B>Array</B> An ESMF Array is a distributed, multi-dimensional 
array that can carry information such as its type, kind, rank, and 
associated halo widths.  It contains a reference to a native Fortran array.
</LI>
<LI><B>ArrayBundle</B>  An ArrayBundle is a collection of Arrays, not
necessarily distributed in the same manner.  It is useful for performing
collective data operations and communications. 
</LI>
<LI><B>Field</B>  A Field represents a physical scalar or vector field.
It contains a reference to an Array along with grid information and metadata.
</LI>
<LI><B>FieldBundle</B>  A FieldBundle is a collection of Fields discretized 
on the same grid.  The staggering of data points may be different for 
different Fields within a FieldBundle.  Like the ArrayBundle, it is
useful for performing collective data operations and
communications.
</LI>
<LI><B>State</B>  A State represents the collection of data that a 
Component either requires to run (an Import State) or can make 
available to other Components (an Export State).
States may contain references to Arrays, ArrayBundles, Fields,
FieldBundles, or other States. 
</LI>
<LI><B>Component</B>  A Component is a piece of software 
with a distinct function.  ESMF currently recognizes two types 
of Components.  Components that represent a physical domain 
or process, such 
as an atmospheric model, are called Gridded Components since they are 
usually discretized on an underlying grid.  The Components 
responsible for regridding and transferring data between Gridded 
Components are called Coupler Components.  Each Component
is associated with an Import and an Export State.  Components
can be nested so that simpler Components are contained within more
complex ones.

<P>
</LI>
</UL>

<P>
Underlying these data classes are native language arrays.  ESMF allows 
you to reference an existing Fortran array to an ESMF Array or 
Field so that ESMF data classes can be readily 
introduced into existing code.  You can perform communication operations 
directly on Fortran arrays through the VM class, which serves 
as a unifying wrapper for distributed and shared memory communication 
libraries.

<P>

<H2><A NAME="SECTION02065000000000000000"></A>
<A NAME="sec:spatialclasses"></A>
<BR>
6.5 ESMF Spatial Classes
</H2>

<P>
Like the hierarchy of model data classes, ranging from the 
simple to the complex, ESMF is organized around an hierarchy of 
classes that represent different spaces associated with a computation.
Each of these spaces can be manipulated, in order to give
the user control over how a computation is executed.  For Earth system
models, this hierarchy starts with the address space associated
with the computer and extends to the physical region described by
the application.   The main spatial classes in ESMF, from
those closest to the machine to those closest to the application, are:

<P>

<UL>
<LI>The <B>Virtual Machine</B>, or <B>VM</B> The ESMF VM is an 
abstraction of a parallel computing environment that encompasses 
both shared and distributed memory, single and multi-core systems.
Its primary purpose is resource allocation and management. Each Component
runs in its own VM, using the resources it defines. The elements of a VM
are <B>Persistent Execution Threads</B>, or <B>PETs</B>, that are
executing in <B>Virtual Address Spaces</B>, or <B>VASs</B>. A simple
case is one in which every PET is associated with a single MPI process.
In this case every PET is executing in its own private VAS. If Components
are nested, the parent component allocates a subset of its PETs to its
children. The children have some flexibility, subject to the constraints of
the computing environment, to decide how they want to use the
resources associated with the PETs they've received.

<P>
</LI>
<LI><B>DELayout</B>  A DELayout represents a data decomposition
(we also refer to this as a distribution).  Its
basic elements are <B>Decomposition Elements</B>, or <B>DEs</B>.  
A DELayout associates a set of DEs with the PETs in a VM.  DEs are not
necessarily one-to-one with PETs.  For cache blocking,
or user-managed multi-threading, more DEs than PETs may be defined.
Fewer DEs than PETs may also be defined if an application requires it.

<P>
</LI>
<LI><B>DistGrid</B>  A DistGrid represents the index space
associated with a grid.  It is a useful abstraction because
often a full specification of grid coordinates is not necessary
to define data communication patterns.  The DistGrid contains
information about the sequence and connectivity of data points,
which is sufficient information for many operations.  Arrays
are defined on DistGrids.

<P>
</LI>
<LI><B>Array</B> An Array defines how the index space described
in the DistGrid is associated with the VAS of each PET. This association
considers the type, kind and rank of the indexed data. Fields are
defined on Arrays.

<P>
</LI>
<LI><B>Grid</B>  A Grid is an abstraction of a physical space.  
It associates a coordinate system, a set of coordinates, and 
a topology to a collection of grid cells.  Grids in ESMF are
comprised of DistGrids plus additional coordinate information. 

<P>
</LI>
<LI><B>Field</B>  A Field may contain more dimensions than the 
Grid that it is discretized on.  For example, for convenience 
during integration, a user may want to define a single Field object 
that holds snapshots of data at multiple times.  Fields also 
keep track of the stagger location of a Field data point within its 
associated Grid cell.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION02066000000000000000">
6.6 ESMF Maps</A>
</H2>

<P>
In order to define how the index spaces of the spatial classes relate
to each other, we require either implicit rules (in which case the
relationship between spaces is defined by default), or special Map arrays
that allow the user to specify the desired association.  The form of the 
specification is usually that the position of the array element carries
information about the first object, and the value of the array element carries
information about the second object.  ESMF includes a <TT>distGridToArrayMap</TT>,
a <TT>gridToFieldMap</TT>, a <TT>distGridToGridMap</TT>, and others.

<P>

<H2><A NAME="SECTION02067000000000000000">
6.7 ESMF Specification Classes</A>
</H2>

<P>
It can be useful to make small packets
of descriptive parameters.  ESMF has one of these:

<UL>
<LI><B>ArraySpec</B>, for storing the specifics, such as type/kind/rank,
of an array.
</LI>
</UL>

<P>

<H2><A NAME="SECTION02068000000000000000">
6.8 ESMF Utility Classes</A>
</H2>

<P>
There are a number of utilities in ESMF that can be used independently.
These are:

<UL>
<LI><B>Attributes</B>, for storing metadata about Fields,
FieldBundles, States, and other classes.
</LI>
<LI><B>TimeMgr</B>, for calendar, time, clock and alarm functions.
</LI>
<LI><B>LogErr</B>, for logging and error handling.
</LI>
<LI><B>Config</B>, for creating resource files that can replace namelists
as a consistent way of setting configuration parameters.
</LI>
</UL>

<P>

<H1><A NAME="SECTION02070000000000000000">
7 Overall Rules and Behavior</A>
</H1>

<P>

<H2><A NAME="SECTION02071000000000000000">
7.1 Local and Global Views and Associated Conventions</A>
</H2>

<P>
ESMF data objects such as Fields are distributed over
DEs, with each DE getting a portion of the data.  Depending
on the task, a local or global view of the object may be
preferable.  In a local view, data indices start with the first
element on the DE and end with the last element on the same DE.
In a global view, there is an assumed or specified order to
the set of DEs over which the object is distributed.  Data
indices start with the first element on the first DE, and
continue across all the elements in the sequence of DEs.
The last data index represents the number of elements in the
entire object.  The DistGrid provides the mapping between
local and global data indices.

<P>
The convention in ESMF is that entities with a global view
have no prefix.  Entities with a DE-local (and in some cases,
PET-local) view have the prefix ``local.''

<P>
Just as data is distributed over DEs, DEs themselves can be
distributed over PETs.  This is an advanced feature for users
who would like to create multiple local chunks of data, for
algorithmic or performance reasons.
Local DEs are those DEs that are located on the local PET.
Local DE labeling always starts at 0 and goes to localDeCount-1,
where localDeCount is the number of DEs on the local PET.
Global DE numbers also start at 0 and go to deCount-1.
The DELayout class provides the mapping between local
and global DE numbers. 

<P>

<H2><A NAME="SECTION02072000000000000000">
7.2 Allocation Rules</A>
</H2>

<P>
The basic rule of allocation and deallocation for the ESMF is:
whoever allocates it is responsible for deallocating it.

<P>
ESMF methods that allocate their own space for data will
deallocate that space when the object is destroyed. 
Methods which accept a user-allocated buffer, for example
<TT>ESMF_FieldCreate()</TT> with the <TT>ESMF_DATACOPY_REFERENCE</TT> flag,
will not deallocate that buffer at the time the object is
destroyed.  The user must deallocate the buffer
when all use of it is complete.

<P>
Classes such as Fields, FieldBundles, and States may have Arrays, 
Fields, Grids and FieldBundles created externally and associated with
them.  These associated items are not destroyed along with the rest  
of the data object since it is possible for the items to be added 
to more than one data object at a time (e.g. the same Grid could 
be part of many Fields).  It is the user's responsibility to delete 
these items when the last use of them is done.

<P>

<H2><A NAME="SECTION02073000000000000000">
7.3 Assignment, Equality, Copying and Comparing Objects</A>
</H2>

<P>
The equal sign assignment has not been overloaded in ESMF, thus resulting in
the standard Fortran behavior. This behavior has been documented as the first
entry in the API documentation section for each ESMF class. For deep ESMF
objects the assignment results in setting an alias the the same ESMF object
in memory. For shallow ESMF objects the assignment is essentially a equivalent
to a copy of the object. For deep classes the equality operators have been
overloaded to test for the alias condition as a counter part to the assignment
behavior. This and the not equal operator are documented following the
assignemnt in the class API documentation sections. 

<P>
Deep object copies are implemented as a special variant of the
<TT>ESMF_&lt;Class&gt;Create()</TT> methods. It takes an existing deep object as
on of the required arguments. At this point not all deep classes have
<TT>ESMF_&lt;Class&gt;Create()</TT> methods that allow object copy.

<P>
Due to the complexity of deep classes there are many aspects when comparing two
objects of the same class. ESMF provide <TT>ESMF_&lt;Class&gt;Match()</TT> methods,
which are functions that return a class specific match flag. At this point not
all deep classes have <TT>ESMF_&lt;Class&gt;Match()</TT> methods that allow deep object
comparison.

<P>

<H2><A NAME="SECTION02074000000000000000">
7.4 Attributes</A>
</H2>

<P>
Attributes are (name, value) pairs, where
the name is a character string and the value can be either a single
value or list of <TT>integer</TT>, <TT>real</TT>, <TT>double precision</TT>,
<TT>logical</TT>, or <TT>character</TT> values.
Attributes can be associated with Fields, FieldBundles, and States. 
Mixed types are not allowed in a single attribute, and all attribute
names must be unique within a single object.    Attributes are set
by name, and can be retrieved either directly by name or by querying
for a count of attributes and retrieving names and values
by index number.

<P>

<H1><A NAME="SECTION02080000000000000000">
8 Integrating ESMF into Applications</A>
</H1>

<P>
Depending on the requirements of the application, the user may 
want to begin integrating ESMF in either a top-down or bottom-up 
manner.  In the top-down approach, tools at the superstructure 
level are used to help reorganize and structure the interactions
among large-scale components in the application.  It is appropriate
when interoperability is a primary concern; for example, when 
several different versions or implementations of components are going 
to be swapped in, or a particular component is going to be used 
in multiple contexts.  Another reason for deciding on a top-down 
approach is that the application contains legacy code that for 
some reason (e.g., intertwined functions, very large,
highly performance-tuned, resource limitations) there is little 
motivation to fully restructure.  The superstructure can usually be 
incorporated into such applications in a way that is non-intrusive.

<P>
In the bottom-up approach, the user selects desired utilities 
(data communications, calendar management, performance profiling,
logging and error handling, etc.) from the ESMF infrastructure 
and either writes new code using them, introduces them into 
existing code, or replaces the functionality in existing code 
with them.  This makes sense when maximizing code reuse and 
minimizing maintenance costs is a goal.  There may be a specific
need for functionality or the component writer may be starting
from scratch.  The calendar management utility is a popular
place to start.

<P>

<H2><A NAME="SECTION02081000000000000000">
8.1 Using the ESMF Superstructure</A>
</H2>

<P>
The following is a typical set of steps involved in adopting
the ESMF superstructure.  The first two tasks, which occur 
before an ESMF call is ever made, have the potential to be 
the most difficult and time-consuming.  They are the work 
of splitting an application into components and ensuring that
each component has well-defined stages of execution.  ESMF
aside, this sort of code structure helps to promote application
clarity and maintainability, and the effort put into it is likely
to be a good investment.

<P>

<OL>
<LI>Decide how to organize the application as discrete Gridded 
and Coupler Components.  This might involve reorganizing code
so that individual components are cleanly separated and their 
interactions consist of a minimal number of data exchanges.

<P>
</LI>
<LI>Divide the code for each component into initialize, run, and
finalize methods.  These methods can be multi-phase, e.g., 
<TT>init_1, init_2</TT>.

<P>
</LI>
<LI>Pack any data that will be transferred between components
into ESMF Import and Export State data structures.  This is done
by first wrapping model data in either ESMF Arrays or Fields.
Arrays are simpler to create and use than Fields, but carry less
information and have a more limited range of operations.
These Arrays and Fields are then added to Import and
Export States.  They may be packed into ArrayBundles or
FieldBundles first, for more efficient communications.
Metadata describing the model data can also be added.
At the end of this step, the data to be transferred between
components will be in a compact and largely self-describing
form.

<P>
</LI>
<LI>Pack time information into ESMF time management data 
structures.

<P>
</LI>
<LI>Using code templates provided in the ESMF distribution, create
ESMF Gridded and Coupler Components to represent each component
in the user code.

<P>
</LI>
<LI>Write a set services routine that sets ESMF entry 
points for each user component's initialize, run, and finalize 
methods.

<P>
</LI>
<LI>Run the application using an ESMF Application Driver.

<P>
</LI>
</OL> 

<P>

<P>

<P>

<H1><A NAME="SECTION02090000000000000000">
9 Master List of Constants</A>
</H1>

<P>

<H2><A NAME="SECTION02091000000000000000">
9.1 ESMF_ALARMLIST</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:alarmlist">42.2.1</A>.

<P>

<H2><A NAME="SECTION02092000000000000000"></A>
<A NAME="const:arbdim"></A>
<BR>
9.2 ESMF_DIM_ARB
</H2>

<P>
<I>DESCRIPTION:
<BR></I>
An integer named constant which is used to indicate that a particular dimension is arbitrarily distributed.

<P>

<H2><A NAME="SECTION02093000000000000000">
9.3 ESMF_ATTGETCOUNT</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:attgetcount">36.6.1</A>.

<P>

<H2><A NAME="SECTION02094000000000000000"></A>
<A NAME="const:attreconcile"></A>
<BR>
9.4 ESMF_ATTRECONCILE
</H2>
<I>DESCRIPTION:
<BR></I>
Indicate whether or not to handle metadata (Attributes) in <TT>ESMF_StateReconcile()</TT>.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AttReconcileFlag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ATTRECONCILE_ON</STRONG></DT>
<DD>Attribute reconciliation will be turned on.
	
</DD>
<DT><STRONG>ESMF_ATTRECONCILE_OFF</STRONG></DT>
<DD>Attribute reconciliation will be turned off.
</DD>
</DL>

<P>

<H2><A NAME="SECTION02095000000000000000">
9.5 ESMF_ATTTREE</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:atttree">36.6.2</A>.

<P>

<H2><A NAME="SECTION02096000000000000000">
9.6 ESMF_ATTWRITE</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:attwrite">36.6.3</A>.

<P>

<H2><A NAME="SECTION02097000000000000000">
9.7 ESMF_CALKIND</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:calkindflag">38.2.1</A>.

<P>

<H2><A NAME="SECTION02098000000000000000"></A>
<A NAME="const:comptype"></A>
<BR>
9.8 ESMF_COMPTYPE
</H2>
<I>DESCRIPTION:
<BR></I>
Indicate the type of a Component.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_CompType_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_COMPTYPE_GRID</STRONG></DT>
<DD>A <TT>ESMF_GridComp</TT> object. 
	
</DD>
<DT><STRONG>ESMF_COMPTYPE_CPL</STRONG></DT>
<DD>A <TT>ESMF_CplComp</TT> objects.
</DD>
</DL>

<P>

<H2><A NAME="SECTION02099000000000000000"></A>
<A NAME="const:contextflag"></A>
<BR>
9.9 ESMF_CONTEXT
</H2>
<I>DESCRIPTION:
<BR></I>  
Indicates the type of VM context in which a Component will be executing its
standard methods.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Context_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_CONTEXT_OWN_VM</STRONG></DT>
<DD>The component is running in its own, separate VM context. Resources
         are inherited from the parent but can be arranged to fit the
         component's requirements.
</DD>
<DT><STRONG>ESMF_CONTEXT_PARENT_VM</STRONG></DT>
<DD>The component uses the parent's VM for resource management. Compared
         to components that use their own VM context components that run in the
         parent's VM context are more light-weight with respect to the overhead
         of calling into their initialize, run and finalize methods.
         Furthermore, VM-specific properties remain unchanged when going from
         the parent component to the child component. These properties include
         the MPI communicator, the number of PETs, the PET labeling, 
         communication attributes, threading-level.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020910000000000000000">
9.10 ESMF_COORDSYS</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:coordsys">28.2.1</A>.

<P>

<H2><A NAME="SECTION020911000000000000000"></A>
<A NAME="const:copy"></A>
<BR>
9.11 ESMF_COPY
</H2>
<I>DESCRIPTION:
<BR></I>
Indicates which type of copy behavior is used when copying ESMF objects.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Copy_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_COPY_ALIAS</STRONG></DT>
<DD>The destination of the copy becomes an alias of the source object.
	
</DD>
<DT><STRONG>ESMF_COPY_REFERENCE</STRONG></DT>
<DD>All local data of the object is coped by value, and pointer valued data is referenced.
	
</DD>
<DT><STRONG>ESMF_COPY_VALUE</STRONG></DT>
<DD>All data and pointers are copied to the destination object, nothing is referenced.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020912000000000000000"></A>
<A NAME="const:datacopyflag"></A>
<BR>
9.12 ESMF_DATACOPY
</H2>
<I>DESCRIPTION:
<BR></I>
Indicates whether to reference a data item or make a copy of it.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_DataCopy_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DATACOPY_VALUE</STRONG></DT>
<DD>Copy the data item to another buffer.
</DD>
<DT><STRONG>ESMF_DATACOPY_REFERENCE</STRONG></DT>
<DD>Reference the data item.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020913000000000000000"></A>
<A NAME="const:decompflag"></A>
<BR>
9.13 ESMF_DECOMP
</H2>
<I>DESCRIPTION:
<BR></I>
Indicates how DistGrid elements are decomposed over DEs.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Decomp_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DECOMP_BALANCED</STRONG></DT>
<DD>Decompose elements as balanced as possible across DEs. The maximum 
      difference in number of elements per DE is 1, with the extra elements on
      the lower DEs.
</DD>
<DT><STRONG>ESMF_DECOMP_CYCLIC</STRONG></DT>
<DD>Decompose elements cyclically across DEs.
</DD>
<DT><STRONG>ESMF_DECOMP_DEFAULT</STRONG></DT>
<DD>Use default decomposition behavior. Currently equal to 
      <TT>ESMF_DECOMP_BALANCED</TT>.
</DD>
<DT><STRONG>ESMF_DECOMP_RESTFIRST</STRONG></DT>
<DD>Divide elements over DEs. Assign the rest of this division to the first
      DE.
</DD>
<DT><STRONG>ESMF_DECOMP_RESTLAST</STRONG></DT>
<DD>Divide elements over DEs. Assign the rest of this division to the last DE.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020914000000000000000">
9.14 ESMF_DIRECTION</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:direction">41.2.1</A>.

<P>

<H2><A NAME="SECTION020915000000000000000">
9.15 ESMF_DISTGRIDMATCH</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:distgridmatch">32.2.1</A>.

<P>

<H2><A NAME="SECTION020916000000000000000">
9.16 ESMF_END</A>
</H2>

<P>
This flag is documented in section <A HREF="node4.html#const:endflag">14.2.1</A>.

<P>

<H2><A NAME="SECTION020917000000000000000">
9.17 ESMF_FIELDSTATUS</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:fieldstatus">23.2.1</A>.

<P>

<H2><A NAME="SECTION020918000000000000000">
9.18 ESMF_FILEFORMAT</A>
</H2>
This flag is documented in section <A HREF="#const:fileformat"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A>.

<P>

<H2><A NAME="SECTION020919000000000000000"></A>
<A NAME="const:geomtype"></A>
<BR>
9.19 ESMF_GEOMTYPE
</H2>

<P>
<I>DESCRIPTION:
<BR></I>
Different types of geometries upon which an ESMF Field or ESMF Fieldbundle may
be built. 

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GeomType_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GEOMTYPE_GRID</STRONG></DT>
<DD>An ESMF_Grid, a structured grid composed of one or more logically rectangular tiles
</DD>
<DT><STRONG>ESMF_GEOMTYPE_MESH</STRONG></DT>
<DD>An ESMF_Mesh, an unstructured grid
</DD>
<DT><STRONG>ESMF_GEOMTYPE_XGRID</STRONG></DT>
<DD>An ESMF_XGrid, an exchange grid
</DD>
<DT><STRONG>ESMF_TYPEKIND_LOCSTREAM</STRONG></DT>
<DD>An ESMF_LocStream, a disconnected series of points with associated key values
</DD>
</DL>

<P>

<H2><A NAME="SECTION020920000000000000000">
9.20 ESMF_GRIDCONN</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:gridconn">28.2.2</A>.

<P>

<H2><A NAME="SECTION020921000000000000000">
9.21 ESMF_GRIDITEM</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:griditem">28.2.3</A>.

<P>

<H2><A NAME="SECTION020922000000000000000">
9.22 ESMF_GRIDMATCH</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:gridmatch">28.2.4</A>.

<P>

<H2><A NAME="SECTION020923000000000000000">
9.23 ESMF_GRIDSTATUS</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:gridstatus">28.2.5</A>.

<P>

<H2><A NAME="SECTION020924000000000000000"></A>
<A NAME="const:indexflag"></A>
<BR>
9.24 ESMF_INDEX
</H2>
<I>DESCRIPTION:
<BR></I>
Indicates whether index is local (per DE) or global (per object).

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Index_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_INDEX_DELOCAL</STRONG></DT>
<DD>Indicates that DE-local index space starts at lower bound 1 for each DE.
</DD>
<DT><STRONG>ESMF_INDEX_GLOBAL</STRONG></DT>
<DD>Indicates that global indices are used. This means that DE-local index
      space starts at the global lower bound for each DE.
</DD>
<DT><STRONG>ESMF_INDEX_USER</STRONG></DT>
<DD>Indicates that the DE-local index bounds are explicitly set by the user.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020925000000000000000"></A>
<A NAME="opt:iofmtflag"></A>
<BR>
9.25 ESMF_IOFMT
</H2>
<I>DESCRIPTION:
<BR></I>
Indicates IO format options that are currently supported.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_IOFmtFlag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_IOFMT_BIN</STRONG></DT>
<DD>Binary format.
</DD>
<DT><STRONG>ESMF_IOFMT_NETCDF</STRONG></DT>
<DD>NETCDF and PNETCDF format.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020926000000000000000"></A>
<A NAME="const:kind"></A>
<BR>
9.26 ESMF_KIND
</H2>

<P>
<I>DESCRIPTION:
<BR></I>
Named constants to be used as <EM>kind-parameter</EM> in Fortran variable
declarations. For example:
<PRE>
  integer(ESMF_KIND_I4)       :: integerVariable
  integer(kind=ESMF_KIND_I4)  :: integerVariable
  real(ESMF_KIND_R4)          :: realVariable
  real(kind=ESMF_KIND_R4)     :: realVariable
</PRE>
The Fortran standard does not mandate what numeric values correspond to
actual number of bytes allocated for the various kinds. The following constants
are defined by ESMF to be correct across the supported Fortran compilers.
Note that not all compilers support every kind listed below; in particular
1 and 2 byte integers can be problematic.

<P>
The type of these named constants is:

<P>
<TT>integer</TT>

<P>
The named constants are:
<DL>
<DT><STRONG>ESMF_KIND_I1</STRONG></DT>
<DD>Kind-parameter for 1 byte integer.
</DD>
<DT><STRONG>ESMF_KIND_I2</STRONG></DT>
<DD>Kind-parameter for 2 byte integer.
</DD>
<DT><STRONG>ESMF_KIND_I4</STRONG></DT>
<DD>Kind-parameter for 4 byte integer.
</DD>
<DT><STRONG>ESMF_KIND_I8</STRONG></DT>
<DD>Kind-parameter for 8 byte integer.
</DD>
<DT><STRONG>ESMF_KIND_R4</STRONG></DT>
<DD>Kind-parameter for 4 byte real.
</DD>
<DT><STRONG>ESMF_KIND_R8</STRONG></DT>
<DD>Kind-parameter for 8 byte real.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020927000000000000000">
9.27 ESMF_LOGERR</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:logerr">44.2.1</A>.

<P>

<H2><A NAME="SECTION020928000000000000000">
9.28 ESMF_LOGKIND</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:logkindflag">44.2.2</A>.

<P>

<H2><A NAME="SECTION020929000000000000000">
9.29 ESMF_LOGMSG</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:logmsgflag">44.2.3</A>.

<P>

<H2><A NAME="SECTION020930000000000000000">
9.30 ESMF_MESHELEMTYPE</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:meshelemtype">30.2.1</A>.

<P>

<H2><A NAME="SECTION020931000000000000000"></A>
<A NAME="const:method"></A>
<BR>
9.31 ESMF_METHOD
</H2>

<P>
<I>DESCRIPTION:
<BR></I>  
Specify standard ESMF Component method.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Method_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_METHOD_FINALIZE</STRONG></DT>
<DD>Finalize method.
</DD>
<DT><STRONG>ESMF_METHOD_INITIALIZE</STRONG></DT>
<DD>Initialize method.
</DD>
<DT><STRONG>ESMF_METHOD_READRESTART</STRONG></DT>
<DD>ReadRestart method.
</DD>
<DT><STRONG>ESMF_METHOD_RUN</STRONG></DT>
<DD>Run method.
</DD>
<DT><STRONG>ESMF_METHOD_WRITERESTART</STRONG></DT>
<DD>WriteRestart method.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020932000000000000000">
9.32 ESMF_PIN</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:pin_flag">45.2.1</A>.

<P>

<H2><A NAME="SECTION020933000000000000000">
9.33 ESMF_POLEMETHOD</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:polemethod">23.2.2</A>.

<P>

<H2><A NAME="SECTION020934000000000000000">
9.34 ESMF_POLEKIND</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:polekind">28.2.6</A>.

<P>

<H2><A NAME="SECTION020935000000000000000"></A>
<A NAME="const:reduce"></A>
<BR>
9.35 ESMF_REDUCE
</H2>
<I>DESCRIPTION:
<BR></I>
Indicates reduce operation

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Reduce_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_REDUCE_SUM</STRONG></DT>
<DD>Use arithmetic sum to add all data elements.
   
</DD>
<DT><STRONG>ESMF_REDUCE_MIN</STRONG></DT>
<DD>Determine the minimum of all data elements.
   
</DD>
<DT><STRONG>ESMF_REDUCE_MAX</STRONG></DT>
<DD>Determine the maximum of all data elements.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020936000000000000000"></A>
<A NAME="const:region"></A>
<BR>
9.36 ESMF_REGION
</H2>
<I>DESCRIPTION:
<BR></I>
Specifies various regions in the data layout of an Array or Field object.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Region_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_REGION_TOTAL</STRONG></DT>
<DD>Total allocated memory.
</DD>
<DT><STRONG>ESMF_REGION_SELECT</STRONG></DT>
<DD>Region of operation-specific elements.
</DD>
<DT><STRONG>ESMF_REGION_EMPTY</STRONG></DT>
<DD>The empty region contains no elements.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020937000000000000000">
9.37 ESMF_REGRIDMETHOD</A>
</H2>
This flag is documented in section <A HREF="node5.html#opt:regridmethod">23.2.3</A>.

<P>

<H2><A NAME="SECTION020938000000000000000"></A>
<A NAME="const:routesync"></A>
<BR>
9.38 ESMF_ROUTESYNC
</H2>
<I>DESCRIPTION:
<BR></I>  

Switch between blocking and non-blocking execution of RouteHandle based
communication calls. Every RouteHandle based communication method contains
an optional argument <TT>routesyncflag</TT> that is of type <TT>ESMF_RouteSync_Flag</TT>.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_RouteSync_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ROUTESYNC_BLOCKING</STRONG></DT>
<DD>Execute a precomputed communication pattern in blocking mode. This
         mode guarantees that when the method returns all PET-local data
         transfers, both in-bound and out-bound, have finished. 
</DD>
<DT><STRONG>ESMF_ROUTESYNC_NBSTART</STRONG></DT>
<DD>Start executing a precomputed communication pattern in non-blocking
         mode. When a method returns from being called in this mode, it
         guarantees that all PET-local out-bound data has been transferred.
         It is now safe for the user to overwrite out-bound data elements.
         No guarantees are made for in-bound data elements at this stage. It is
         unsafe to access these elements until a call in
         <TT>ESMF_ROUTESYNC_NBTESTFINISH</TT> mode has been issued and has returned
         with <TT>finishedflag</TT> equal to .true., or a call in
         <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> mode has been issued and has returned.
         
</DD>
<DT><STRONG>ESMF_ROUTESYNC_NBTESTFINISH</STRONG></DT>
<DD>Test whether the transfer of data of a precomputed communication
         pattern, started with <TT>ESMF_ROUTESYNC_NBSTART</TT>, has completed.
         Finish up as much as possible and set the <TT>finishedflag</TT> to 
         <TT>.true.</TT> if <EM>all</EM> data operations have completed, or
         <TT>.false.</TT> if there are still outstanding transfers. Only after
         a <TT>finishedflag</TT> equal to <TT>.true.</TT> has been returned is it
         safe to access any of the in-bound data elements.
</DD>
<DT><STRONG>ESMF_ROUTESYNC_NBWAITFINISH</STRONG></DT>
<DD>Wait (i.e. block) until the transfer of data of a precomputed
         communication pattern, started with <TT>ESMF_ROUTESYNC_NBSTART</TT>, has
         completed. Finish up <EM>all</EM> data operations and set the returned 
         <TT>finishedflag</TT> to <TT>.true.</TT>. It is safe to access any of the
         in-bound data elements once the call has returned.
</DD>
<DT><STRONG>ESMF_ROUTESYNC_CANCEL</STRONG></DT>
<DD>Cancel outstanding transfers for a precomputed communication pattern.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020939000000000000000">
9.39 ESMF_SERVICEREPLY</A>
</H2>
This flag is documented in section <A HREF="node6.html#const:servicereply_flag">45.2.2</A>.

<P>

<H2><A NAME="SECTION020940000000000000000">
9.40 ESMF_STAGGERLOC</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:staggerloc">28.2.7</A>.

<P>

<H2><A NAME="SECTION020941000000000000000"></A>
<A NAME="const:startregion"></A>
<BR>
9.41 ESMF_STARTREGION
</H2>
<I>DESCRIPTION:
<BR></I>
Specifies the start of the effective halo region of an Array or Field object.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_StartRegion_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_STARTREGION_EXCLUSIVE</STRONG></DT>
<DD>Region of elements that are exclusively owned by the local DE.
</DD>
<DT><STRONG>ESMF_STARTREGION_COMPUTATIONAL</STRONG></DT>
<DD>User defined region, greater or equal to the exclusive region.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020942000000000000000">
9.42 ESMF_STATEINTENT</A>
</H2>
This flag is documented in section <A HREF="node4.html#const:stateintent">18.2.1</A>.

<P>

<H2><A NAME="SECTION020943000000000000000">
9.43 ESMF_STATEITEM</A>
</H2>
This flag is documented in section <A HREF="node4.html#const:stateitem">18.2.2</A>.

<P>

<H2><A NAME="SECTION020944000000000000000"></A>
<A NAME="const:sync"></A>
<BR>
9.44 ESMF_SYNC
</H2>
<I>DESCRIPTION:
<BR></I>  
Indicates method blocking behavior and PET synchronization for VM communication
methods, as well as for standard Component methods, such as Initialize(), Run() 
and Finalize().

<P>
For VM communication calls the <TT>ESMF_SYNC_BLOCKING</TT> and <TT>ESMF_SYNC_NONBLOCKING</TT>
modes provide behavior that is practically identical to the blocking and
non-blocking communication calls familiar from MPI.

<P>
The details of how the blocking mode setting affects Component methods are
more complex. This is a consequence of the fact that ESMF Components can be
executed in threaded or non-threaded mode. However, in the default,
non-threaded case, where an ESMF application runs as a pure MPI or mpiuni
program, most of the complexity is removed.

<P>
See the <B>VM</B> item in <A HREF="node2.html#sec:spatialclasses">6.5</A> for an
explanation of the PET and VAS concepts used in the following
descriptions.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Sync_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_SYNC_BLOCKING</STRONG></DT>
<DD><EM>Communication calls:</EM> The called method will block until all
         (PET-)local operations are complete. After the return of a blocking
         communication method it is safe to modify or use all participating
         local data.

<P>
<EM>Component calls:</EM> The called method will block until all PETs of
         the VM have completed the operation.

<P>
For a non-threaded, pure MPI
         component the behavior is identical to calling a barrier before 
         returning from the method. Generally this kind of rigid 
         synchronization is not the desirable mode of operation for an MPI
         application, but may be useful for application debugging.
         In the opposite case, where all PETs of the component are running as
         threads in shared memory, i.e. in a single VAS, strict synchronization
         of all PETs is required to prevent race conditions.

<P>
</DD>
<DT><STRONG>ESMF_SYNC_VASBLOCKING</STRONG></DT>
<DD><EM>Communication calls:</EM> Not available for communication calls.

<P>
<EM>Component calls:</EM> The called method will block each PET until
         all operations in the PET-local VAS have completed. 

<P>
This mode is a combination of <TT>ESMF_SYNC_BLOCKING</TT> and
         <TT>ESMF_SYNC_NONBLOCKING</TT> modes. It provides a default setting 
         that leads to the typically desirable behavior for pure MPI 
         components as well as those that share address spaces between PETs.

<P>
For a non-threaded, pure MPI component each PET returns
         independent of the other PETs. This is generally the expected 
         behavior in the pure MPI case where calling into a component method is
         practically identical to a subroutine call without extra 
         synchronization between the processes.

<P>
In the case where some PETs of the component are running as
         threads in shared memory <TT>ESMF_SYNC_VASBLOCKING</TT> becomes identical
         to <TT>ESMF_SYNC_BLOCKING</TT> within thread groups, to prevent race
         conditions, while there is no synchronization between the thread
         groups.

<P>
</DD>
<DT><STRONG>ESMF_SYNC_NONBLOCKING</STRONG></DT>
<DD><EM>Communication calls:</EM> The called method will not block but 
         returns immediately after initiating the requested operation. It is
         unsafe to modify or use participating local data before all local
         operations have completed. Use the <TT>ESMF_VMCommWait()</TT> or
         <TT>ESMF_VMCommQueueWait()</TT> method to block the local PET until
         local data access is safe again. 

<P>
<EM>Component calls:</EM> The behavior of this mode is fundamentally
         different for threaded and non-threaded components,
         independent on whether the components use shared memory or not.
         The <TT>ESMF_SYNC_NONBLOCKING</TT> mode is the most complex mode for
         calling component methods and should only be used if the extra
         control, described below, is absolutely necessary.

<P>
For non-threaded components (the ESMF default)
         calling a component method with <TT>ESMF_SYNC_NONBLOCKING</TT>
         is identical to calling it with <TT>ESMF_SYNC_VASBLOCKING</TT>. However,
         different than for <TT>ESMF_SYNC_VASBLOCKING</TT>, a call to
         <TT>ESMF_GridCompWait()</TT> or <TT>ESMF_CplCompWait()</TT> is
         required in order to deallocate memory internally allocated for the
         <TT>ESMF_SYNC_NONBLOCKING</TT> mode.

<P>
For threaded components the calling PETs
         of the parent component will not be blocked and return immediately
         after initiating the requested child component method. In this
         scenario parent and child components will run concurrently in
         identical VASs. This is the most complex mode of operation.
         It is unsafe to modify or use VAS local data that
         may be accessed by concurrently running components until the child
         component method has completed. Use the appropriate
         <TT>ESMF_GridCompWait()</TT> or <TT>ESMF_CplCompWait()</TT> method to
         block the local parent PET until the child component method has
         completed in the local VAS.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020945000000000000000"></A>
<A NAME="const:typekind"></A>
<BR>
9.45 ESMF_TYPEKIND
</H2>

<P>
<I>DESCRIPTION:
<BR></I>
Named constants used to indicate type and kind combinations supported by the
overloaded ESMF interfaces. The corresponding Fortran kind-parameter constants
are described in section <A HREF="node2.html#const:kind">9.26</A>.

<P>
The type of these named constants is:

<P>
<TT>type(ESMF_TypeKind_Flag)</TT>

<P>
The named constants are:
<DL>
<DT><STRONG>ESMF_TYPEKIND_I1</STRONG></DT>
<DD>Indicates 1 byte integer.
</DD>
<DT><STRONG>ESMF_TYPEKIND_I2</STRONG></DT>
<DD>Indicates 2 byte integer.
</DD>
<DT><STRONG>ESMF_TYPEKIND_I4</STRONG></DT>
<DD>Indicates 4 byte integer.
</DD>
<DT><STRONG>ESMF_TYPEKIND_I8</STRONG></DT>
<DD>Indicates 8 byte integer.
</DD>
<DT><STRONG>ESMF_TYPEKIND_R4</STRONG></DT>
<DD>Indicates 4 byte real.
</DD>
<DT><STRONG>ESMF_TYPEKIND_R8</STRONG></DT>
<DD>Indicates 8 byte real.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020946000000000000000"></A>
<A NAME="const:unmappedaction"></A>
<BR>
9.46 ESMF_UNMAPPEDACTION
</H2>
<I>DESCRIPTION:
<BR></I>
Indicates what action to take with respect to unmapped destination points
and the entries of the sparse matrix that correspond to these points.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_UnmappedAction_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_UNMAPPEDACTION_ERROR</STRONG></DT>
<DD>An error is issued when there exist destination points in a regridding
	operation that are not mapped by corresponding source points.
	
</DD>
<DT><STRONG>ESMF_UNMAPPEDACTION_IGNORE</STRONG></DT>
<DD>Destination points which do not have corresponding source points are 
	ignored and zeros are used for the entries of the sparse matrix
	that is generated.
</DD>
</DL>

<P>

<H2><A NAME="SECTION020947000000000000000"></A>
<A NAME="const:version"></A>
<BR>
9.47 ESMF_VERSION
</H2>

<P>
<I>DESCRIPTION:
<BR></I>
The following named constants define the precise version of ESMF in use.

<P>
<DL>
<DT><STRONG>ESMF_VERSION_BETASNAPSHOT</STRONG></DT>
<DD>Constant of type <TT>logical</TT> indicating beta snapshot phase
      (<TT>.true.</TT> for any version during the pre-release development phase,
      <TT>.false.</TT> for any released version of the software).
</DD>
<DT><STRONG>ESMF_VERSION_MAJOR</STRONG></DT>
<DD>Constant of type <TT>integer</TT> indicating the major version number
      (e.g. 5 for v5.2.0r).
</DD>
<DT><STRONG>ESMF_VERSION_MINOR</STRONG></DT>
<DD>Constant of type <TT>integer</TT> indicating the minor version number
      (e.g. 2 for v5.2.0r).
</DD>
<DT><STRONG>ESMF_VERSION_PATCHLEVEL</STRONG></DT>
<DD>Constant of type <TT>integer</TT> indicating the patch level of a specific
      revision (e.g. 0 for v5.2.0r, or 1 for v5.2.0rp1).
</DD>
<DT><STRONG>ESMF_VERSION_PUBLIC</STRONG></DT>
<DD>Constant of type <TT>logical</TT> indicating public vs. internal release
      status (e.g. <TT>.true.</TT> for v5.2.0r, or <TT>.false.</TT> for v5.2.0).
</DD>
<DT><STRONG>ESMF_VERSION_REVISION</STRONG></DT>
<DD>Constant of type <TT>integer</TT> indicating the revision number
      (e.g. 0 for v5.2.0r).
</DD>
<DT><STRONG>ESMF_VERSION_STRING</STRONG></DT>
<DD>Constant of type <TT>character</TT> holding the exact release version string
      (e.g. "5.2.0r").
</DD>
</DL>

<P>

<H2><A NAME="SECTION020948000000000000000">
9.48 ESMF_XGRIDSIDE</A>
</H2>
This flag is documented in section <A HREF="node5.html#const:xgridside">31.2.1</A>.

<P>

<P>

<H1><A NAME="SECTION020100000000000000000"></A>
<A NAME="sec:overallimpl"></A>
<BR>
10 Overall Design and Implementation Notes
</H1>

<P>

<OL>
<LI><B>Deep and shallow classes.</B>  The deep and shallow classes 
described in Section <A HREF="node2.html#sec:deepshallow">6.2</A> differ in how and where they
are allocated within a multi-language implementation environment.  We
distinguish between the implementation language, which is the language
a method is written in, and the calling language, which is the language
that the user application is written in.  Deep classes are allocated 
off the process heap by the implementation language.  Shallow classes
are allocated off the stack by the calling language.  

<P>
</LI>
<LI><B>Base class.</B> All ESMF classes are built upon a Base class,
which holds a small set of system-wide capabilities.  

<P>
</LI>
</OL>

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html1561"
  HREF="node3.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1557"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1551"
  HREF="node1.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1559"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1562"
  HREF="node3.html">2 Applications</A>
<B> Up:</B> <A NAME="tex2html1558"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1552"
  HREF="node1.html">Contents</A>
 &nbsp <B>  <A NAME="tex2html1560"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
