<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>3 API</TITLE>
<META NAME="description" CONTENT="3 API">
<META NAME="keywords" CONTENT="NUOPC_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="NUOPC_refdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="NUOPC_refdoc.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html344"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html340"
  HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html334"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html342"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html345"
  HREF="node5.html">4 Standardized Component Dependencies</A>
<B> Up:</B> <A NAME="tex2html341"
  HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A NAME="tex2html335"
  HREF="node3.html">2 Design and Implementation</A>
 &nbsp; <B>  <A NAME="tex2html343"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html346"
  HREF="node4.html#SECTION00041000000000000000">3.1 Generic Component: NUOPC_Driver</A>
<UL>
<LI><A NAME="tex2html347"
  HREF="node4.html#SECTION00041100000000000000">3.1.1 NUOPC_DriverAddComp</A>
<LI><A NAME="tex2html348"
  HREF="node4.html#SECTION00041200000000000000">3.1.2 NUOPC_DriverAddComp</A>
<LI><A NAME="tex2html349"
  HREF="node4.html#SECTION00041300000000000000">3.1.3 NUOPC_DriverAddComp</A>
<LI><A NAME="tex2html350"
  HREF="node4.html#SECTION00041400000000000000">3.1.4 NUOPC_DriverAddRunElement</A>
<LI><A NAME="tex2html351"
  HREF="node4.html#SECTION00041500000000000000">3.1.5 NUOPC_DriverAddRunElement</A>
<LI><A NAME="tex2html352"
  HREF="node4.html#SECTION00041600000000000000">3.1.6 NUOPC_DriverAddRunElement</A>
<LI><A NAME="tex2html353"
  HREF="node4.html#SECTION00041700000000000000">3.1.7 NUOPC_DriverEgestRunSequence</A>
<LI><A NAME="tex2html354"
  HREF="node4.html#SECTION00041800000000000000">3.1.8 NUOPC_DriverGetComp</A>
<LI><A NAME="tex2html355"
  HREF="node4.html#SECTION00041900000000000000">3.1.9 NUOPC_DriverIngestRunSequence</A>
<LI><A NAME="tex2html356"
  HREF="node4.html#SECTION000411000000000000000">3.1.10 NUOPC_DriverGetComp</A>
<LI><A NAME="tex2html357"
  HREF="node4.html#SECTION000411100000000000000">3.1.11 NUOPC_DriverGetComp</A>
<LI><A NAME="tex2html358"
  HREF="node4.html#SECTION000411200000000000000">3.1.12 NUOPC_DriverGetComp</A>
<LI><A NAME="tex2html359"
  HREF="node4.html#SECTION000411300000000000000">3.1.13 NUOPC_DriverNewRunSequence</A>
<LI><A NAME="tex2html360"
  HREF="node4.html#SECTION000411400000000000000">3.1.14 NUOPC_DriverPrint</A>
<LI><A NAME="tex2html361"
  HREF="node4.html#SECTION000411500000000000000">3.1.15 NUOPC_DriverSetRunSequence</A>
</UL>
<BR>
<LI><A NAME="tex2html362"
  HREF="node4.html#SECTION00042000000000000000">3.2 Generic Component: NUOPC_ModelBase</A>
<LI><A NAME="tex2html363"
  HREF="node4.html#SECTION00043000000000000000">3.3 Generic Component: NUOPC_Model</A>
<UL>
<LI><A NAME="tex2html364"
  HREF="node4.html#SECTION00043100000000000000">3.3.1 NUOPC_ModelGet</A>
</UL>
<BR>
<LI><A NAME="tex2html365"
  HREF="node4.html#SECTION00044000000000000000">3.4 Generic Component: NUOPC_Mediator</A>
<UL>
<LI><A NAME="tex2html366"
  HREF="node4.html#SECTION00044100000000000000">3.4.1 NUOPC_MediatorGet</A>
</UL>
<BR>
<LI><A NAME="tex2html367"
  HREF="node4.html#SECTION00045000000000000000">3.5 Generic Component: NUOPC_Connector</A>
<UL>
<LI><A NAME="tex2html368"
  HREF="node4.html#SECTION00045100000000000000">3.5.1 NUOPC_ConnectorGet</A>
<LI><A NAME="tex2html369"
  HREF="node4.html#SECTION00045200000000000000">3.5.2 NUOPC_ConnectorSet</A>
</UL>
<BR>
<LI><A NAME="tex2html370"
  HREF="node4.html#SECTION00046000000000000000">3.6 General Generic Component Methods</A>
<UL>
<LI><A NAME="tex2html371"
  HREF="node4.html#SECTION00046100000000000000">3.6.1 NUOPC_CompAreServicesSet</A>
<LI><A NAME="tex2html372"
  HREF="node4.html#SECTION00046200000000000000">3.6.2 NUOPC_CompAreServicesSet</A>
<LI><A NAME="tex2html373"
  HREF="node4.html#SECTION00046300000000000000">3.6.3 NUOPC_CompAttributeAdd</A>
<LI><A NAME="tex2html374"
  HREF="node4.html#SECTION00046400000000000000">3.6.4 NUOPC_CompAttributeAdd</A>
<LI><A NAME="tex2html375"
  HREF="node4.html#SECTION00046500000000000000">3.6.5 NUOPC_CompAttributeEgest</A>
<LI><A NAME="tex2html376"
  HREF="node4.html#SECTION00046600000000000000">3.6.6 NUOPC_CompAttributeEgest</A>
<LI><A NAME="tex2html377"
  HREF="node4.html#SECTION00046700000000000000">3.6.7 NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html378"
  HREF="node4.html#SECTION00046800000000000000">3.6.8 NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html379"
  HREF="node4.html#SECTION00046900000000000000">3.6.9 NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html380"
  HREF="node4.html#SECTION000461000000000000000">3.6.10 NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html381"
  HREF="node4.html#SECTION000461100000000000000">3.6.11 NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html382"
  HREF="node4.html#SECTION000461200000000000000">3.6.12 NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html383"
  HREF="node4.html#SECTION000461300000000000000">3.6.13 NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html384"
  HREF="node4.html#SECTION000461400000000000000">3.6.14 NUOPC_CompAttributeGet</A>
<LI><A NAME="tex2html385"
  HREF="node4.html#SECTION000461500000000000000">3.6.15 NUOPC_CompAttributeIngest</A>
<LI><A NAME="tex2html386"
  HREF="node4.html#SECTION000461600000000000000">3.6.16 NUOPC_CompAttributeIngest</A>
<LI><A NAME="tex2html387"
  HREF="node4.html#SECTION000461700000000000000">3.6.17 NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html388"
  HREF="node4.html#SECTION000461800000000000000">3.6.18 NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html389"
  HREF="node4.html#SECTION000461900000000000000">3.6.19 NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html390"
  HREF="node4.html#SECTION000462000000000000000">3.6.20 NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html391"
  HREF="node4.html#SECTION000462100000000000000">3.6.21 NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html392"
  HREF="node4.html#SECTION000462200000000000000">3.6.22 NUOPC_CompAttributeSet</A>
<LI><A NAME="tex2html393"
  HREF="node4.html#SECTION000462300000000000000">3.6.23 NUOPC_CompCheckSetClock</A>
<LI><A NAME="tex2html394"
  HREF="node4.html#SECTION000462400000000000000">3.6.24 NUOPC_CompDerive</A>
<LI><A NAME="tex2html395"
  HREF="node4.html#SECTION000462500000000000000">3.6.25 NUOPC_CompDerive</A>
<LI><A NAME="tex2html396"
  HREF="node4.html#SECTION000462600000000000000">3.6.26 NUOPC_CompFilterPhaseMap</A>
<LI><A NAME="tex2html397"
  HREF="node4.html#SECTION000462700000000000000">3.6.27 NUOPC_CompFilterPhaseMap</A>
<LI><A NAME="tex2html398"
  HREF="node4.html#SECTION000462800000000000000">3.6.28 NUOPC_CompSearchPhaseMap</A>
<LI><A NAME="tex2html399"
  HREF="node4.html#SECTION000462900000000000000">3.6.29 NUOPC_CompSearchPhaseMap</A>
<LI><A NAME="tex2html400"
  HREF="node4.html#SECTION000463000000000000000">3.6.30 NUOPC_CompSetClock</A>
<LI><A NAME="tex2html401"
  HREF="node4.html#SECTION000463100000000000000">3.6.31 NUOPC_CompSetEntryPoint</A>
<LI><A NAME="tex2html402"
  HREF="node4.html#SECTION000463200000000000000">3.6.32 NUOPC_CompSetEntryPoint</A>
<LI><A NAME="tex2html403"
  HREF="node4.html#SECTION000463300000000000000">3.6.33 NUOPC_CompSetInternalEntryPoint</A>
<LI><A NAME="tex2html404"
  HREF="node4.html#SECTION000463400000000000000">3.6.34 NUOPC_CompSetServices</A>
<LI><A NAME="tex2html405"
  HREF="node4.html#SECTION000463500000000000000">3.6.35 NUOPC_CompSpecialize</A>
<LI><A NAME="tex2html406"
  HREF="node4.html#SECTION000463600000000000000">3.6.36 NUOPC_CompSpecialize</A>
</UL>
<BR>
<LI><A NAME="tex2html407"
  HREF="node4.html#SECTION00047000000000000000">3.7 Field Dictionary Methods</A>
<UL>
<LI><A NAME="tex2html408"
  HREF="node4.html#SECTION00047100000000000000">3.7.1 NUOPC_FieldDictionaryAddEntry</A>
<LI><A NAME="tex2html409"
  HREF="node4.html#SECTION00047200000000000000">3.7.2 NUOPC_FieldDictionaryEgest</A>
<LI><A NAME="tex2html410"
  HREF="node4.html#SECTION00047300000000000000">3.7.3 NUOPC_FieldDictionaryGetEntry</A>
<LI><A NAME="tex2html411"
  HREF="node4.html#SECTION00047400000000000000">3.7.4 NUOPC_FieldDictionaryHasEntry</A>
<LI><A NAME="tex2html412"
  HREF="node4.html#SECTION00047500000000000000">3.7.5 NUOPC_FieldDictionaryMatchSyno</A>
<LI><A NAME="tex2html413"
  HREF="node4.html#SECTION00047600000000000000">3.7.6 NUOPC_FieldDictionarySetSyno</A>
<LI><A NAME="tex2html414"
  HREF="node4.html#SECTION00047700000000000000">3.7.7 NUOPC_FieldDictionarySetup</A>
</UL>
<BR>
<LI><A NAME="tex2html415"
  HREF="node4.html#SECTION00048000000000000000">3.8 Free Format Methods</A>
<UL>
<LI><A NAME="tex2html416"
  HREF="node4.html#SECTION00048100000000000000">3.8.1 NUOPC_FreeFormatAdd</A>
<LI><A NAME="tex2html417"
  HREF="node4.html#SECTION00048200000000000000">3.8.2 NUOPC_FreeFormatCreate</A>
<LI><A NAME="tex2html418"
  HREF="node4.html#SECTION00048300000000000000">3.8.3 NUOPC_FreeFormatCreate</A>
<LI><A NAME="tex2html419"
  HREF="node4.html#SECTION00048400000000000000">3.8.4 NUOPC_FreeFormatDestroy</A>
<LI><A NAME="tex2html420"
  HREF="node4.html#SECTION00048500000000000000">3.8.5 NUOPC_FreeFormatGet</A>
<LI><A NAME="tex2html421"
  HREF="node4.html#SECTION00048600000000000000">3.8.6 NUOPC_FreeFormatGetLine</A>
<LI><A NAME="tex2html422"
  HREF="node4.html#SECTION00048700000000000000">3.8.7 NUOPC_FreeFormatLog</A>
<LI><A NAME="tex2html423"
  HREF="node4.html#SECTION00048800000000000000">3.8.8 NUOPC_FreeFormatPrint</A>
</UL>
<BR>
<LI><A NAME="tex2html424"
  HREF="node4.html#SECTION00049000000000000000">3.9 Utility Routines</A>
<UL>
<LI><A NAME="tex2html425"
  HREF="node4.html#SECTION00049100000000000000">3.9.1 NUOPC_AddNamespace</A>
<LI><A NAME="tex2html426"
  HREF="node4.html#SECTION00049200000000000000">3.9.2 NUOPC_Advertise</A>
<LI><A NAME="tex2html427"
  HREF="node4.html#SECTION00049300000000000000">3.9.3 NUOPC_Advertise</A>
<LI><A NAME="tex2html428"
  HREF="node4.html#SECTION00049400000000000000">3.9.4 NUOPC_AdjustClock</A>
<LI><A NAME="tex2html429"
  HREF="node4.html#SECTION00049500000000000000">3.9.5 NUOPC_CheckSetClock</A>
<LI><A NAME="tex2html430"
  HREF="node4.html#SECTION00049600000000000000">3.9.6 NUOPC_GetAttribute</A>
<LI><A NAME="tex2html431"
  HREF="node4.html#SECTION00049700000000000000">3.9.7 NUOPC_GetAttribute</A>
<LI><A NAME="tex2html432"
  HREF="node4.html#SECTION00049800000000000000">3.9.8 NUOPC_GetAttribute</A>
<LI><A NAME="tex2html433"
  HREF="node4.html#SECTION00049900000000000000">3.9.9 NUOPC_GetStateMemberLists</A>
<LI><A NAME="tex2html434"
  HREF="node4.html#SECTION000491000000000000000">3.9.10 NUOPC_IsAtTime</A>
<LI><A NAME="tex2html435"
  HREF="node4.html#SECTION000491100000000000000">3.9.11 NUOPC_IsAtTime</A>
<LI><A NAME="tex2html436"
  HREF="node4.html#SECTION000491200000000000000">3.9.12 NUOPC_IsConnected</A>
<LI><A NAME="tex2html437"
  HREF="node4.html#SECTION000491300000000000000">3.9.13 NUOPC_IsConnected</A>
<LI><A NAME="tex2html438"
  HREF="node4.html#SECTION000491400000000000000">3.9.14 NUOPC_IsUpdated</A>
<LI><A NAME="tex2html439"
  HREF="node4.html#SECTION000491500000000000000">3.9.15 NUOPC_IsUpdated</A>
<LI><A NAME="tex2html440"
  HREF="node4.html#SECTION000491600000000000000">3.9.16 NUOPC_NoOp</A>
<LI><A NAME="tex2html441"
  HREF="node4.html#SECTION000491700000000000000">3.9.17 NUOPC_Realize</A>
<LI><A NAME="tex2html442"
  HREF="node4.html#SECTION000491800000000000000">3.9.18 NUOPC_Realize</A>
<LI><A NAME="tex2html443"
  HREF="node4.html#SECTION000491900000000000000">3.9.19 NUOPC_SetAttribute</A>
<LI><A NAME="tex2html444"
  HREF="node4.html#SECTION000492000000000000000">3.9.20 NUOPC_SetAttribute</A>
</UL>
<BR>
<LI><A NAME="tex2html445"
  HREF="node4.html#SECTION000410000000000000000">3.10 Auxiliary Routines</A>
<UL>
<LI><A NAME="tex2html446"
  HREF="node4.html#SECTION000410100000000000000">3.10.1 NUOPC_Write</A>
<LI><A NAME="tex2html447"
  HREF="node4.html#SECTION000410200000000000000">3.10.2 NUOPC_Write</A>
<LI><A NAME="tex2html448"
  HREF="node4.html#SECTION000410300000000000000">3.10.3 NUOPC_Write</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00040000000000000000">
3 API</A>
</H1>

<P>

<H2><A NAME="SECTION00041000000000000000">
3.1 Generic Component: NUOPC_Driver</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_Driver
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Component that drives Model, Mediator, and Connector components. For every Driver time step the same run sequence, i.e. sequence of Model, Mediator, and Connector <TT>Run</TT> methods is called. The run sequence is fully customizable. The default run sequence implements explicit time stepping.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  ESMF_GridComp
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine SetServices(driver, rc)
    type(ESMF_GridComp)   :: driver
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4.2</A> for a precise definition). The default implementation sets the following mapping:
    
<UL>
<LI>IPDv00p1 = 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>IPDv00p1 (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Allocate and initialize internal data structures.
</LI>
<LI>If the internal clock is not yet set, set the default internal clock to be a copy of the incoming clock, but only if the incoming clock is valid.
</LI>
<LI><I>Required specialization</I> to set component services: <TT>label_SetModelServices</TT>.
  
<UL>
<LI>Call <TT>NUOPC_DriverAddComp()</TT> for all Model, Mediator, and Connector components to be added.
</LI>
<LI>Optionally replace the default clock. 
  
</LI>
</UL>
</LI>
<LI><I>Optional specialization</I> to set run sequence: <TT>label_SetRunSequence</TT>.

<P>
</LI>
<LI>Execute Initialize phase=0 for all Model, Mediator, and Connector components. This is the method where each component is required to initialize its <TT>InitializePhaseMap</TT> Attribute.
</LI>
<LI><I>Optional specialization</I> to analyze and modify the <TT>InitializePhaseMap</TT> Attribute of the child components before the Driver uses it: <TT>label_ModifyInitializePhaseMap</TT>.
</LI>
<LI>Drive the initialize sequence for the child components, compatible with up to IPDv04, as documented in section <A HREF="node3.html#IPD">2.4.2</A>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>If the incoming clock is valid, set the internal stop time to one time step interval on the incoming clock.
</LI>
<LI>Drive the time stepping loop, from current time to stop time, incrementing by time step.
  
<UL>
<LI>For each time step iteration the Model and Connector components Run() methods are being called according to the run sequence.
  
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Execute the Finalize() methods of all Connector components in order.
</LI>
<LI>Execute the Finalize() methods of all Model components in order.
</LI>
<LI><I>Optional specialization</I> to finalize custom parts of the component: <TT>label_Finalize</TT>.
</LI>
<LI>Destroy all Model components and their import and export states.
</LI>
<LI>Destroy all Connector components.
</LI>
<LI>Internal clean-up.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00041100000000000000">
3.1.1 NUOPC_DriverAddComp - Add a GridComp child to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   subroutine NUOPC_DriverAddGridComp(driver, compLabel, &amp;
     compSetServicesRoutine, petList, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     interface
       subroutine compSetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(in),  optional :: petList(:)
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create and add a GridComp (i.e. Model, Mediator, or Driver) as a child 
   component to a Driver. The component is created on the provided <TT>petList</TT>,
   or by default across all of the Driver PETs.

<P>
The specified <TT>SetServices()</TT> routine is called back immediately after the
   new child component has been created internally. Very little around the
   component is set up at that time (e.g. component attributes are not 
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component - typically by deriving 
   from a generic component followed by the appropriate specilizations.

<P>
The <TT>compLabel</TT> must uniquely identify the child component within the
   context of the Driver component.

<P>
If the <TT>comp</TT> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A NAME="SECTION00041200000000000000">
3.1.2 NUOPC_DriverAddComp - Add a GridComp child from shared object to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   subroutine NUOPC_DriverAddGridCompSO(driver, compLabel, &amp;
     sharedObj, petList, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     character(len=*),    intent(in),  optional :: sharedObj
     integer,             intent(in),  optional :: petList(:)
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create and add a GridComp (i.e. Model, Mediator, or Driver) as a child 
   component to a Driver. The component is created on the provided <TT>petList</TT>,
   or by default across all of the Driver PETs. 

<P>
The <TT>SetServices()</TT> routine in the <TT>sharedObj</TT> is called back
   immediately after the
   new child component has been created internally. Very little around the
   component is set up at that time (e.g. component attributes are not 
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component - typically by deriving 
   from a generic component followed by the appropriate specilizations.

<P>
The <TT>compLabel</TT> must uniquely identify the child component within the
   context of the Driver component.

<P>
If the <TT>comp</TT> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A NAME="SECTION00041300000000000000">
3.1.3 NUOPC_DriverAddComp - Add a CplComp child to a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddComp()
   subroutine NUOPC_DriverAddCplComp(driver, srcCompLabel, dstCompLabel, &amp;
     compSetServicesRoutine, petList, comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
     interface
       subroutine compSetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer, target,     intent(in),  optional :: petList(:)
     type(ESMF_CplComp),  intent(out), optional :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create and add a CplComp (i.e. Connector) as a child component to a Driver.
   The component is created on the provided <TT>petList</TT>, or by default across 
   the union of PETs of the components indicated by <TT>srcCompLabel</TT>
   and <TT>dstCompLabel</TT>.

<P>
The specified <TT>SetServices()</TT> routine is called back immediately after the
   new child component has been created internally. Very little around the
   component is set up at that time (e.g. component attributes are not 
   available). The routine should therefore be very light weight, with the sole
   purpose of setting the entry points of the component - typically by deriving 
   from a generic component followed by the appropriate specilizations.

<P>
The <TT>compLabel</TT> must uniquely identify the child component within the 
   context of the Driver component.

<P>
If the <TT>comp</TT> argument is specified, it will reference the newly created
   component on return. 

<P>

<P>

<H3><A NAME="SECTION00041400000000000000">
3.1.4 NUOPC_DriverAddRunElement - Add RunElement for Model, Mediator, or Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   subroutine NUOPC_DriverAddRunElementMPL(driver, slot, compLabel, &amp;
     phaseLabel, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     character(len=*),    intent(in)            :: compLabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: phaseLabel
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add an element associated with a Model, Mediator, or Driver component to the
   run sequence of the Driver. The component must have been added to the Driver,
   and associated with <TT>compLabel</TT> prior to this call.

<P>
If <TT>phaseLabel</TT> was not specified, the first entry in the
   <TT>RunPhaseMap</TT> attribute of the referenced component will be used to 
   determine the run phase of the added element.

<P>
By default an error is returned if no component is associated with the 
   specified <TT>compLabel</TT>. This error can be suppressed by setting
   <TT>relaxedflag=.true.</TT>, and no entry will be added to the run sequence.

<P>
The <TT>slot</TT> number identifies the run sequence time slot in case multiple
   sequences are available. Slots start counting from 1. 

<P>

<P>

<H3><A NAME="SECTION00041500000000000000">
3.1.5 NUOPC_DriverAddRunElement - Add RunElement for Connector</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   subroutine NUOPC_DriverAddRunElementCPL(driver, slot, srcCompLabel, &amp;
     dstCompLabel, phaseLabel, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(len=*),    intent(in),  optional :: phaseLabel
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add an element associated with a Connector component to the
   run sequence of the Driver. The component must have been added to the Driver,
   and associated with <TT>srcCompLabel</TT> and <TT>dstCompLabel</TT> prior to this
   call.

<P>
If <TT>phaseLabel</TT> was not specified, the first entry in the
   <TT>RunPhaseMap</TT> attribute of the referenced component will be used to 
   determine the run phase of the added element.

<P>
By default an error is returned if no component is associated with the 
   specified <TT>compLabel</TT>. This error can be suppressed by setting
   <TT>relaxedflag=.true.</TT>, and no entry will be added to the run sequence.

<P>
The <TT>slot</TT> number identifies the run sequence time slot in case multiple
   sequences are available. Slots start counting from 1. 

<P>

<P>

<H3><A NAME="SECTION00041600000000000000">
3.1.6 NUOPC_DriverAddRunElement - Add RunElement that links to another slot</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverAddRunElement()
   subroutine NUOPC_DriverAddRunElementL(driver, slot, linkSlot, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     integer,             intent(in)            :: linkSlot
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add an element to the run sequence of the Driver that links to the time slot
   indicated by <TT>linkSlot</TT>. 

<P>

<P>

<H3><A NAME="SECTION00041700000000000000">
3.1.7 NUOPC_DriverEgestRunSequence - Egest the run sequence as FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_DriverEgestRunSequence(driver, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: driver
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Egest the run sequence stored in the driver as a FreeFormat object. It is the
   caller's responsibility to destroy the created freeFormat object. 

<P>

<P>

<H3><A NAME="SECTION00041800000000000000">
3.1.8 NUOPC_DriverGetComp - Get a GridComp child from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   subroutine NUOPC_DriverGetGridComp(driver, compLabel, comp, petList, &amp;
     relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: compLabel
     type(ESMF_GridComp), intent(out), optional :: comp
     integer,             pointer,     optional :: petList(:)
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query the Driver for a GridComp (i.e. Model, Mediator, or Driver) child 
   component that was added under <TT>compLabel</TT>.

<P>
If provided, the <TT>petList</TT> argument will be associated with the petList
   that was used to create the referenced component.

<P>
By default an error is returned if no component is associated with the 
   specified <TT>compLabel</TT>. This error can be suppressed by setting
   <TT>relaxedflag=.true.</TT>, and unassociated arguments will be returned. 

<P>

<P>

<H3><A NAME="SECTION00041900000000000000">
3.1.9 NUOPC_DriverIngestRunSequence - Ingest the run sequence from FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_DriverIngestRunSequence(driver, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: driver
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Ingest the run sequence from a FreeFormat object. 

<P>

<P>

<H3><A NAME="SECTION000411000000000000000">
3.1.10 NUOPC_DriverGetComp - Get a CplComp child from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   subroutine NUOPC_DriverGetCplComp(driver, srcCompLabel, dstCompLabel, &amp;
     comp, petList, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     character(len=*),    intent(in)            :: srcCompLabel
     character(len=*),    intent(in)            :: dstCompLabel
     type(ESMF_CplComp),  intent(out), optional :: comp
     integer,             pointer    , optional :: petList(:)
     logical,             intent(in),  optional :: relaxedflag
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query the Driver for a CplComp (i.e. Connector) child 
   component that was added under <TT>compLabel</TT>.

<P>
If provided, the <TT>petList</TT> argument will be associated with the petList
   that was used to create the referenced component.

<P>
By default an error is returned if no component is associated with the 
   specified <TT>compLabel</TT>. This error can be suppressed by setting
   <TT>relaxedflag=.true.</TT>, and unassociated arguments will be returned. 

<P>

<P>

<H3><A NAME="SECTION000411100000000000000">
3.1.11 NUOPC_DriverGetComp - Get all the GridComp child components from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   subroutine NUOPC_DriverGetAllGridComp(driver, compList, petLists, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     type(ESMF_GridComp), pointer, optional     :: compList(:)
     type(type_petList),  pointer, optional     :: petLists(:)
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get all the GridComp (i.e. Model, Mediator, or Driver) child components from a
   Driver. The incoming <TT>compList</TT> and <TT>petLists</TT> arguments must be 
   unassociated. On return it becomes the responsibility of the caller to 
   deallocate the associated <TT>compList</TT> and <TT>petLists</TT> arguments 

<P>

<P>

<H3><A NAME="SECTION000411200000000000000">
3.1.12 NUOPC_DriverGetComp - Get all the CplComp child components from a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverGetComp()
   subroutine NUOPC_DriverGetAllCplComp(driver, compList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     type(ESMF_CplComp),  pointer               :: compList(:)
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get all the CplComp (i.e. Connector) child components from a
   Driver. The incoming <TT>compList</TT> and <TT>petLists</TT> arguments must be 
   unassociated. On return it becomes the responsibility of the caller to 
   deallocate the associated <TT>compList</TT> and <TT>petLists</TT> arguments 

<P>

<P>

<H3><A NAME="SECTION000411300000000000000">
3.1.13 NUOPC_DriverNewRunSequence - Replace the run sequence in a Driver</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_DriverNewRunSequence(driver, slotCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slotCount
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Replace the current run sequence of the Driver with a new one that has 
   <TT>slotCount</TT> slots. Each slot uses its own clock for time keeping. 

<P>

<P>

<H3><A NAME="SECTION000411400000000000000">
3.1.14 NUOPC_DriverPrint - Print internal Driver information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_DriverPrint(driver, orderflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     logical,             intent(in),  optional :: orderflag
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal Driver information. If <TT>orderflag</TT> is provided and set
   to <TT>.true.</TT>, the output is ordered from lowest to highest PET. Setting 
   this flag makes the method collective. 

<P>

<P>

<H3><A NAME="SECTION000411500000000000000">
3.1.15 NUOPC_DriverSetRunSequence - Set internals of RunSequence slot</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_DriverSetRunSequence()
   subroutine NUOPC_DriverSetRunSequence(driver, slot, clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: driver
     integer,             intent(in)            :: slot
     type(ESMF_Clock),    intent(in)            :: clock
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the <TT>clock</TT> in the run sequence under <TT>slot</TT> of the Driver.


<P>

<H2><A NAME="SECTION00042000000000000000">
3.2 Generic Component: NUOPC_ModelBase</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Partial specialization of a component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called the component steps one timeStep forward on the passed in parent
clock. The component flags incompatibility during <TT>Run</TT> if the current time of the incoming
clock does not match the current time of the internal clock.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  ESMF_GridComp
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine SetServices(modelBase, rc)
    type(ESMF_GridComp)   :: modelBase
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4.2</A> for a precise definition). The default implementation sets the following mapping:
    
<UL>
<LI>IPDv00p1 = 1: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p2 = 2: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p3 = 3: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p4 = 4: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED/</SMALL>P<SMALL>ROVIDED</SMALL>: <TT>label_SetRunClock</TT> to check and set the internal Clock against the incoming Clock.
  
<UL>
<LI><TT>IF</TT> (Phase specific specialization present): Execute the phase specific specialization.
</LI>
<LI><TT>ELSE</TT>: Execute the phase independent specialization. P<SMALL>ROVIDED</SMALL>: By default check that internal Clock and incoming Clock agree on current time and that the time step of the incoming Clock is a multiple of the internal Clock time step. Under these conditions set the internal stop time to one time step interval of the incoming Clock. Otherwise exit with error, flagging an incompatibility.
  
</LI>
</UL>
</LI>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED/</SMALL>P<SMALL>ROVIDED</SMALL>: <TT>label_CheckImport</TT> to check Fields in the import State.
  
<UL>
<LI><TT>IF</TT> (Phase specific specialization is present): Execute the phase specific specialization.
</LI>
<LI><TT>ELSE</TT>: Execute the phase independent specialization. P<SMALL>ROVIDED</SMALL>: By default check that all import Fields are at the current time of the internal Clock.
  
</LI>
</UL>
</LI>
<LI>Time stepping loop: starting at current time, running to stop time of the internal Clock.
  
<UL>
<LI>Timestamp the Fields in the export State according to the current time of the internal Clock.
</LI>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED</SMALL>: <TT>label_Advance</TT> to execute model or mediation code.
</LI>
<LI>Advance the current time of the internal Clock according to the time step of the internal Clock.
  
</LI>
</UL>
</LI>
<LI>S<SMALL>PECIALIZATION </SMALL>O<SMALL>PTIONAL</SMALL>: <TT>label_TimestampExport</TT> to timestamp Fields in the export State.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to finalize custom parts of the component: <TT>label_Finalize</TT>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<H2><A NAME="SECTION00043000000000000000">
3.3 Generic Component: NUOPC_Model</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_Model
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Model component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called the model integrates one timeStep forward on the passed in parent clock. The internal clock is advanced at the end of each <TT>Run</TT> call. The component flags incompatibility during <TT>Run</TT> if the current time of the incoming clock does not match the current time of the internal clock.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine SetServices(model, rc)
    type(ESMF_GridComp)   :: model
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4.2</A> for a precise definition). The default implementation sets the following mapping:
    
<UL>
<LI>IPDv00p1 = 1: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Advertise Fields in import and export States.
      
</LI>
</UL>
</LI>
<LI>IPDv00p2 = 2: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Realize the advertised Fields in import and export States.
      
</LI>
</UL>  
</LI>
<LI>IPDv00p3 = 3: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Check compatibility of the Fields' Connected status.
      
</LI>
</UL>
</LI>
<LI>IPDv00p4 = 4: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Handle Field data initialization. Time stamp the export Fields.
      
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>IPDv00p3, IPDv01p4, IPDv02p4: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>If the model internal clock is found to be not set, then set the model internal clock as a copy of the incoming clock. 
</LI>
<LI><I>Optional specialization</I> to set the internal clock and/or alarms: <TT>label_SetClock</TT>.
</LI>
<LI>Check compatibility, ensuring all advertised import Fields are connected.
  
</LI>
</UL>  
</LI>
<LI>IPDv00p4, IPDv01p5: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to initialize export Fields: <TT>label_DataInitialize</TT>
</LI>
<LI>Time stamp Fields in export State for compatibility checking.
  
</LI>
</UL>    
</LI>
<LI>IPDv02p5: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to initialize export Fields: <TT>label_DataInitialize</TT>
</LI>
<LI>Timestamp Fields in export State for compatibility checking.
</LI>
<LI>Set Component metadata used to resolve initialize data dependencies.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED/</SMALL>P<SMALL>ROVIDED</SMALL>: <TT>label_SetRunClock</TT> to check and set the internal Clock against the incoming Clock.
  
<UL>
<LI><TT>IF</TT> (Phase specific specialization present): Execute the phase specific specialization.
</LI>
<LI><TT>ELSE</TT>: Execute the phase independent specialization. P<SMALL>ROVIDED</SMALL>: By default check that internal Clock and incoming Clock agree on current time and that the time step of the incoming Clock is a multiple of the internal Clock time step. Under these conditions set the internal stop time to one time step interval of the incoming Clock. Otherwise exit with error, flagging an incompatibility.
  
</LI>
</UL>
</LI>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED/</SMALL>P<SMALL>ROVIDED</SMALL>: <TT>label_CheckImport</TT> to check Fields in the import State.
  
<UL>
<LI><TT>IF</TT> (Phase specific specialization is present): Execute the phase specific specialization.
</LI>
<LI><TT>ELSE</TT>: Execute the phase independent specialization. P<SMALL>ROVIDED</SMALL>: By default check that all import Fields are at the current time of the internal Clock.
  
</LI>
</UL>
</LI>
<LI>Time stepping loop: starting at current time, running to stop time of the internal Clock.
  
<UL>
<LI>Timestamp the Fields in the export State according to the current time of the internal Clock.
</LI>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED</SMALL>: <TT>label_Advance</TT> to execute model code.
</LI>
<LI>Advance the current time of the internal Clock according to the time step of the internal Clock.
  
</LI>
</UL>
</LI>
<LI>Timestamp all Fields in the export State according to the current time of the internal Clock, which now is identical to the stop time of the internal Clock.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to finalize custom parts of the component: <TT>label_Finalize</TT>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00043100000000000000">
3.3.1 NUOPC_ModelGet - Get info from a Model</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_ModelGet(model, driverClock, modelClock, &amp;
     importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: model
     type(ESMF_Clock),    intent(out), optional :: driverClock
     type(ESMF_Clock),    intent(out), optional :: modelClock
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access Model information.


<P>

<H2><A NAME="SECTION00044000000000000000">
3.4 Generic Component: NUOPC_Mediator</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_Mediator
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Mediator component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called, the time stamp on the imported Fields must match the current time (on both the incoming and internal clock). Before returning, the Mediator time stamps the exported Fields with the same current time, before advancing the internal clock one timeStep forward.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine SetServices(mediator, rc)
    type(ESMF_GridComp)   :: mediator
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4.2</A> for a precise definition). The default implementation sets the following mapping:
    
<UL>
<LI>IPDv00p1 = 1: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Advertise Fields in import and export States.
      
</LI>
</UL>
</LI>
<LI>IPDv00p2 = 2: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Realize the advertised Fields in import and export States.
      
</LI>
</UL>  
</LI>
<LI>IPDv00p3 = 3: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Check compatibility of the Fields' Connected status.
      
</LI>
</UL>
</LI>
<LI>IPDv00p4 = 4: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Handle Field data initialization. Time stamp the export Fields.
      
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>IPDv00p3, IPDv01p4, IPDv02p4: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Set the Mediator internal clock as a copy of the incoming clock. 
</LI>
<LI>Check compatibility, ensuring all advertised import Fields are connected.
  
</LI>
</UL>  
</LI>
<LI>IPDv00p4, IPDv01p5: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to initialize export Fields: <TT>label_DataInitialize</TT>
</LI>
<LI>Time stamp Fields in import and export States for compatibility checking.
  
</LI>
</UL>    
</LI>
<LI>IPDv02p5: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to initialize export Fields: <TT>label_DataInitialize</TT>
</LI>
<LI>Time stamp Fields in export State for compatibility checking.
</LI>
<LI>Set Component metadata used to resolve initialize data dependencies.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED/</SMALL>P<SMALL>ROVIDED</SMALL>: <TT>label_SetRunClock</TT> to check and set the internal Clock against the incoming Clock.
  
<UL>
<LI><TT>IF</TT> (Phase specific specialization present): Execute the phase specific specialization.
</LI>
<LI><TT>ELSE</TT>: Execute the phase independent specialization. P<SMALL>ROVIDED</SMALL>: By default check that internal Clock and incoming Clock agree on current time and that the time step of the incoming Clock is a multiple of the internal Clock time step. Under these conditions set the internal stop time to one time step interval of the incoming Clock. Otherwise exit with error, flagging an incompatibility.
  
</LI>
</UL>
</LI>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED/</SMALL>P<SMALL>ROVIDED</SMALL>: <TT>label_CheckImport</TT> to check Fields in the import State.
  
<UL>
<LI><TT>IF</TT> (Phase specific specialization is present): Execute the phase specific specialization.
</LI>
<LI><TT>ELSE</TT>: Execute the phase independent specialization. P<SMALL>ROVIDED</SMALL>: By default check that all import Fields are at the current time of the internal Clock.
  
</LI>
</UL>
</LI>
<LI>Time stepping loop: starting at current time, running to stop time of the internal Clock.
  
<UL>
<LI>Timestamp the Fields in the export State according to the current time of the internal Clock.
</LI>
<LI>S<SMALL>PECIALIZATION </SMALL>R<SMALL>EQUIRED</SMALL>: <TT>label_Advance</TT> to execute mediation code.
</LI>
<LI>Advance the current time of the internal Clock according to the time step of the internal Clock.
  
</LI>
</UL>
</LI>
<LI>S<SMALL>PECIALIZATION </SMALL>O<SMALL>PTIONAL</SMALL>: <TT>label_TimestampExport</TT> to timestamp Fields in the export State.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to finalize custom parts of the component: <TT>label_Finalize</TT>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00044100000000000000">
3.4.1 NUOPC_MediatorGet - Get info from a Mediator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_MediatorGet(mediator, driverClock, mediatorClock, &amp;
     importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                        :: mediator
     type(ESMF_Clock),    intent(out), optional :: driverClock
     type(ESMF_Clock),    intent(out), optional :: mediatorClock
     type(ESMF_State),    intent(out), optional :: importState
     type(ESMF_State),    intent(out), optional :: exportState
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access Mediator information.


<P>

<H2><A NAME="SECTION00045000000000000000">
3.5 Generic Component: NUOPC_Connector</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_Connector
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Component that makes a unidirectional connection between model, mediator, and or driver components. During initialization field pairing is performed between the import and export side according to section <A HREF="node3.html#FieldPairing">2.4.3</A>, and paired fields are connected. By default the bilinear regrid method is used during <TT>Run</TT> to transfer data from the connected import Fields to the connected export Fields.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  ESMF_CplComp
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine SetServices(connector, rc)
    type(ESMF_CplComp)    :: connector
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 04 (see section <A HREF="node3.html#IPD">2.4.2</A> for a precise definition). The default implementation sets the following mapping:
    
<UL>
<LI>IPDv04p1a = phase : (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv04p1b = phase : (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv04p2  = phase : (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv04p3  = phase : (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv04p4  = phase : (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv04p5a = phase : (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv04p5b = phase : (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>IPDv01p1, IPDv02p1: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Construct a list of matching Field pairs between import and export State based on the <TT>StandardName</TT> Field metadata. 
</LI>
<LI>Store this list of <TT>StandardName</TT> entries in the <TT>CplList</TT> attribute of the Connector Component metadata.
  
</LI>
</UL>
</LI>
<LI>IPDv01p2, IPDv02p2: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Allocate and initialize the internal state.
</LI>
<LI>Use the <TT>CplList</TT> attribute to construct <TT>srcFields</TT> and <TT>dstFields</TT> FieldBundles in the internal state that hold matched Field pairs.
</LI>
<LI>Set the <TT>Connected</TT> attribute to <TT>true</TT> in the Field metadata for each Field that is added to the <TT>srcFields</TT> and <TT>dstFields</TT> FieldBundles.
  
</LI>
</UL>  
</LI>
<LI>IPDv01p3, IPDv02p3: (NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Use the <TT>CplList</TT> attribute to construct <TT>srcFields</TT> and <TT>dstFields</TT> FieldBundles in the internal state that hold matched Field pairs.
</LI>
<LI>Set the <TT>Connected</TT> attribute to <TT>true</TT> in the Field metadata for each Field that is added to the <TT>srcFields</TT> and <TT>dstFields</TT> FieldBundles.
</LI>
<LI><I>Optional specialization</I> to precompute a Connector operation: <TT>label_ComputeRouteHandle</TT>. Simple custom implementations store the precomputed communication RouteHandle in the <TT>rh</TT> member of the internal state. More complex implementations use the <TT>state</TT> member in the internal state to store auxiliary Fields, FieldBundles, and RouteHandles.
</LI>
<LI>By default (if <TT>label_ComputeRouteHandle</TT> was <EM>not</EM> provided) precompute the Connector RouteHandle as a bilinear Regrid operation between <TT>srcFields</TT> and <TT>dstFields</TT>, with <TT>unmappedaction</TT> set to <TT>ESMF_UNMAPPEDACTION_IGNORE</TT>. The resulting RouteHandle is stored in the <TT>rh</TT> member of the internal state.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to execute a Connector operation: <TT>label_ExecuteRouteHandle</TT>. Simple custom implementations access the <TT>srcFields</TT>, <TT>dstFields</TT>, and <TT>rh</TT> members of the internal state to implement the required data transfers. More complex implementations access the <TT>state</TT> member in the internal state, which holds the auxiliary Fields, FieldBundles, and RouteHandles that potentially were added during the optional <TT>label_ComputeRouteHandle</TT> method during initialize.
</LI>
<LI>By default (if <TT>label_ExecuteRouteHandle</TT> was <EM>not</EM> provided) execute the precomputed Connector RouteHandle between <TT>srcFields</TT> and <TT>dstFields</TT>.
</LI>
<LI>Update the time stamp on the Fields in <TT>dstFields</TT> to match the time stamp on the Fields in <TT>srcFields</TT>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to release the custom Connector operation: <TT>label_ReleaseRouteHandle</TT>; or by default, if <TT>label_ReleaseRouteHandle</TT> was <EM>not</EM> provided, release the default Connector RouteHandle.
</LI>
<LI><I>Optional specialization</I> to finalize custom parts of the component: <TT>label_Finalize</TT>.
</LI>
<LI>Internal clean-up.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00045100000000000000">
3.5.1 NUOPC_ConnectorGet - Get parameters from a Connector</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_ConnectorGet(connector, srcFields, dstFields, rh, state, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: connector
     type(ESMF_FieldBundle), intent(out), optional :: srcFields
     type(ESMF_FieldBundle), intent(out), optional :: dstFields
     type(ESMF_RouteHandle), intent(out), optional :: rh
     type(ESMF_State),       intent(out), optional :: state
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get parameters from the <TT>connector</TT> internal state. 

<P>

<P>

<H3><A NAME="SECTION00045200000000000000">
3.5.2 NUOPC_ConnectorSet - Set parameters in a Connector</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_ConnectorSet(connector, srcFields, dstFields, rh, state, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: connector
     type(ESMF_FieldBundle), intent(in),  optional :: srcFields
     type(ESMF_FieldBundle), intent(in),  optional :: dstFields
     type(ESMF_RouteHandle), intent(in),  optional :: rh
     type(ESMF_State),       intent(in),  optional :: state
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set parameters in the <TT>connector</TT> internal state.


<P>

<P>

<H2><A NAME="SECTION00046000000000000000">
3.6 General Generic Component Methods</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00046100000000000000">
3.6.1 NUOPC_CompAreServicesSet - Check if SetServices was called</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAreServicesSet() 
   function NUOPC_GridCompAreServicesSet(comp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_GridCompAreServicesSet
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if SetServices has been called for <TT>comp</TT>. 
     Otherwise return <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION00046200000000000000">
3.6.2 NUOPC_CompAreServicesSet - Check if SetServices was called</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAreServicesSet() 
   function NUOPC_CplCompAreServicesSet(comp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_CplCompAreServicesSet
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: comp
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if SetServices has been called for <TT>comp</TT>.
     Otherwise return <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION00046300000000000000">
3.6.3 NUOPC_CompAttributeAdd - Add NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeAdd() 
   subroutine NUOPC_GridCompAttributeAdd(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                       :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add Attributes to the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A NAME="SECTION00046400000000000000">
3.6.4 NUOPC_CompAttributeAdd - Add NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeAdd() 
   subroutine NUOPC_CplCompAttributeAdd(comp, attrList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                        :: comp
     character(len=*),   intent(in)            :: attrList(:)
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add Attributes to the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance"). 

<P>

<P>

<H3><A NAME="SECTION00046500000000000000">
3.6.5 NUOPC_CompAttributeEgest - Egest NUOPC GridComp Attributes in FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeEgest() 
   subroutine NUOPC_GridCompAttributeEge(comp, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Egest the Attributes of the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance") as a FreeFormat object.
     It is the caller's responsibility to destroy the created <TT>freeFormat</TT>
     object. 

<P>

<P>

<H3><A NAME="SECTION00046600000000000000">
3.6.6 NUOPC_CompAttributeEgest - Egest NUOPC CplComp Attributes in FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeEgest() 
   subroutine NUOPC_CplCompAttributeEge(comp, freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Egest the Attributes of the highest level of the standard NUOPC AttPack
     hierarchy (convention="NUOPC", purpose="Instance") as a FreeFormat object.
     It is the caller's responsibility to destroy the created <TT>freeFormat</TT>
     object. 

<P>

<P>

<H3><A NAME="SECTION00046700000000000000">
3.6.7 NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGet(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out)           :: value
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access the Attribute <TT>name</TT> inside of <TT>comp</TT> using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION00046800000000000000">
3.6.8 NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGet(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out)           :: value
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access the Attribute <TT>name</TT> inside of <TT>comp</TT> using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION00046900000000000000">
3.6.9 NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetI(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     integer,             intent(out)           :: value
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access the Attribute <TT>name</TT> inside of <TT>comp</TT> using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000461000000000000000">
3.6.10 NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetI(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     character(*),        intent(in)            :: name
     integer,             intent(out)           :: value
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access the Attribute <TT>name</TT> inside of <TT>comp</TT> using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000461100000000000000">
3.6.11 NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetSL(comp, name, valueList, itemCount, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     character(*),        intent(in)            :: name
     character(*),        intent(out), optional :: valueList(:)
     integer,             intent(out), optional :: itemCount
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access the Attribute <TT>name</TT> inside of <TT>comp</TT> using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000461200000000000000">
3.6.12 NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetSL(comp, name, valueList, itemCount, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: comp
     character(*),       intent(in)            :: name
     character(*),       intent(out), optional :: valueList(:)
     integer,            intent(out), optional :: itemCount
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access the Attribute <TT>name</TT> inside of <TT>comp</TT> using the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000461300000000000000">
3.6.13 NUOPC_CompAttributeGet - Get a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_GridCompAttributeGetTK(comp, name, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),      intent(in)            :: comp
     character(*),             intent(in)            :: name
     type(ESMF_TypeKind_Flag), intent(out)           :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query the <TT>typekind</TT> of the Attribute <TT>name</TT> inside of <TT>comp</TT> 
     using the highest level of the standard NUOPC AttPack hierarchy 
     (convention="NUOPC", purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000461400000000000000">
3.6.14 NUOPC_CompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeGet() 
   subroutine NUOPC_CplCompAttributeGetTK(comp, name, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),       intent(in)            :: comp
     character(*),             intent(in)            :: name
     type(ESMF_TypeKind_Flag), intent(out)           :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query the <TT>typekind</TT> of the Attribute <TT>name</TT> inside of <TT>comp</TT> 
     using the highest level of the standard NUOPC AttPack hierarchy 
     (convention="NUOPC", purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000461500000000000000">
3.6.15 NUOPC_CompAttributeIngest - Ingest free format NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_GridCompAttributeIng(comp, freeFormat, addFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),    intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     logical,                intent(in),  optional :: addFlag
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Ingest the Attributes from a FreeFormat object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
If <TT>addFlag</TT> is <TT>.false.</TT> (default), an error will be returned if 
     an attribute is to be ingested that was not previously added to the 
     <TT>comp</TT> object. If <TT>addFlag</TT> is <TT>.true.</TT>, all missing attributes
     will be added by this method automatically as needed. 

<P>

<P>

<H3><A NAME="SECTION000461600000000000000">
3.6.16 NUOPC_CompAttributeIngest - Ingest free format NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeIngest() 
   subroutine NUOPC_CplCompAttributeIng(comp, freeFormat, addFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),     intent(in)            :: comp
     type(NUOPC_FreeFormat), intent(in)            :: freeFormat
     logical,                intent(in),  optional :: addFlag
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Ingest the Attributes from a FreeFormat object onto the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
If <TT>addFlag</TT> is <TT>.false.</TT> (default), an error will be returned if 
     an attribute is to be ingested that was not previously added to the 
     <TT>comp</TT> object. If <TT>addFlag</TT> is <TT>.true.</TT>, all missing attributes
     will be added by this method automatically as needed. 

<P>

<P>

<H3><A NAME="SECTION000461700000000000000">
3.6.17 NUOPC_CompAttributeSet - Set a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetS(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000461800000000000000">
3.6.18 NUOPC_CompAttributeSet - Set a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetS(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000461900000000000000">
3.6.19 NUOPC_CompAttributeSet - Set a NUOPC GridComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetI(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     integer,      intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462000000000000000">
3.6.20 NUOPC_CompAttributeSet - Set a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetI(comp, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     integer,      intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462100000000000000">
3.6.21 NUOPC_CompAttributeSet - Set a NUOPC GridComp List Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_GridCompAttributeSetSL(comp, name, valueList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: valueList(:)
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462200000000000000">
3.6.22 NUOPC_CompAttributeSet - Set a NUOPC CplComp List Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompAttributeSet() 
   subroutine NUOPC_CplCompAttributeSetSL(comp, name, valueList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                    :: comp
     character(*), intent(in)              :: name
     character(*), intent(in)              :: valueList(:)
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>comp</TT> on the highest level
     of the standard NUOPC AttPack hierarchy (convention="NUOPC", 
     purpose="Instance").

<P>
Return with error if the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000462300000000000000">
3.6.23 NUOPC_CompCheckSetClock - Check Clock compatibility and set stopTime</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompCheckSetClock() 
   subroutine NUOPC_GridCompCheckSetClock(comp, externalClock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compare <TT>externalClock</TT> to the internal clock of <TT>comp</TT> to make sure
     they match in their current time. Also ensure that the time step of the 
     external clock is a multiple of the time step of the internal clock. If 
     both conditions are satisfied then set the stop time of the internal clock
     so it is reached in one time step of the external clock. Otherwise leave the
     internal clock unchanged and return with error. The direction of
     the involved clocks is taking into account. 

<P>

<P>

<H3><A NAME="SECTION000462400000000000000">
3.6.24 NUOPC_CompDerive - Derive a GridComp from a generic component</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompDerive() 
   subroutine NUOPC_GridCompDerive(comp, genericSetServicesRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     interface
       subroutine genericSetServicesRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Derive a GridComp (i.e. Model, Mediator, or Driver) from a generic 
     component by calling into the specified <TT>SetServices()</TT> routine of the
     generic component. This is typically the first call in the
     <TT>SetServices()</TT> routine of the specializing component, and is followed
     by <TT>NUOPC_CompSpecialize()</TT> calls. 

<P>

<P>

<H3><A NAME="SECTION000462500000000000000">
3.6.25 NUOPC_CompDerive - Derive a CplComp from a generic component</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompDerive() 
   subroutine NUOPC_CplCompDerive(comp, genericSetServicesRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp),  intent(in)            :: comp
     interface
       subroutine genericSetServicesRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Derive a CplComp (i.e. Connector) from a generic
     component by calling into the specified <TT>SetServices()</TT> routine of the
     generic component. This is typically the first call in the
     <TT>SetServices()</TT> routine of the specializing component, and is followed
     by <TT>NUOPC_CompSpecialize()</TT> calls. 

<P>

<P>

<H3><A NAME="SECTION000462600000000000000">
3.6.26 NUOPC_CompFilterPhaseMap - Filter the Phase Map of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompFilterPhaseMap()
   subroutine NUOPC_GridCompFilterPhaseMap(comp, methodflag, acceptStringList, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in)            :: acceptStringList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Filter all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   that do <EM>not</EM> match any entry in the <TT>acceptStringList</TT>. 

<P>

<P>

<H3><A NAME="SECTION000462700000000000000">
3.6.27 NUOPC_CompFilterPhaseMap - Filter the Phase Map of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompFilterPhaseMap()
   subroutine NUOPC_CplCompFilterPhaseMap(comp, methodflag, acceptStringList, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in)            :: acceptStringList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Filter all PhaseMap entries in a CplComp (i.e. Connector)
   that do <EM>not</EM> match any entry in the <TT>acceptStringList</TT>. 

<P>

<P>

<H3><A NAME="SECTION000462800000000000000">
3.6.28 NUOPC_CompSearchPhaseMap - Search the Phase Map of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSearchPhaseMap()
   subroutine NUOPC_GridCompSearchPhaseMap(comp, methodflag, phaseLabel, &amp;
     phaseIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                           :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in),  optional :: phaseLabel
     integer,                intent(out)           :: phaseIndex
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Search all PhaseMap entries in a GridComp (i.e. Model, Mediator, or Driver)
   to see if <TT>phaseLabel</TT> is found. Return the associated ESMF
   <TT>phaseIndex</TT>, or <TT>-1</TT> if not found. If <TT>phaseLabel</TT> is not
   specified, set <TT>phaseIndex</TT> to the first entry in the PhaseMap, or 
   <TT>-1</TT> if there are no entries. 

<P>

<P>

<H3><A NAME="SECTION000462900000000000000">
3.6.29 NUOPC_CompSearchPhaseMap - Search the Phase Map of a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSearchPhaseMap()
   subroutine NUOPC_CplCompSearchPhaseMap(comp, methodflag, phaseLabel, &amp;
     phaseIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                            :: comp
     type(ESMF_Method_Flag), intent(in)            :: methodflag
     character(len=*),       intent(in),  optional :: phaseLabel
     integer,                intent(out)           :: phaseIndex
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Search all PhaseMap entries in a CplComp (i.e. Connector)
   to see if <TT>phaseLabel</TT> is found. Return the associated ESMF
   <TT>phaseIndex</TT>, or <TT>-1</TT> if not found. If <TT>phaseLabel</TT> is not
   specified, set <TT>phaseIndex</TT> to the first entry in the PhaseMap, or 
   <TT>-1</TT> if there are no entries. 

<P>

<P>

<H3><A NAME="SECTION000463000000000000000">
3.6.30 NUOPC_CompSetClock - Initialize and set the internal Clock of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetClock()
   subroutine NUOPC_GridCompSetClock(comp, externalClock, stabilityTimeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     type(ESMF_TimeInterval), intent(in),  optional :: stabilityTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the component internal clock as a copy of <TT>externalClock</TT>, but
     with a timeStep that is less than or equal to the stabilityTimeStep.
     At the same time ensure that the timeStep of the external clock is
     a multiple of the timeStep of the internal clock. If the stabilityTimeStep
     argument is not provided then the internal clock will simply be set
     as a copy of the external clock. 

<P>

<P>

<H3><A NAME="SECTION000463100000000000000">
3.6.31 NUOPC_CompSetEntryPoint - Set entry point for a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetEntryPoint()
   subroutine NUOPC_GridCompSetEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set an entry point for a GridComp (i.e. Model, Mediator, or Driver). Publish
   the new entry point in the correct <TT>PhaseMap</TT> component attribute. 

<P>

<P>

<H3><A NAME="SECTION000463200000000000000">
3.6.32 NUOPC_CompSetEntryPoint - Set entry point for a CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetEntryPoint()
   subroutine NUOPC_CplCompSetEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(cplcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_CplComp)          :: cplcomp      ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set an entry point for a CplComp (i.e. Connector). Publish
   the new entry point in the correct <TT>PhaseMap</TT> component attribute. 

<P>

<P>

<H3><A NAME="SECTION000463300000000000000">
3.6.33 NUOPC_CompSetInternalEntryPoint - Set internal entry point for a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetInternalEntryPoint()
   subroutine NUOPC_GridCompSetIntEntryPoint(comp, methodflag, phaseLabelList, &amp;
     userRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     type(ESMF_Method_Flag), intent(in)      :: methodflag
     character(len=*),       intent(in)      :: phaseLabelList(:)
     interface
       subroutine userRoutine(gridcomp, importState, exportState, clock, rc)
         use ESMF_CompMod
         use ESMF_StateMod
         use ESMF_ClockMod
         implicit none
         type(ESMF_GridComp)         :: gridcomp     ! must not be optional
         type(ESMF_State)            :: importState  ! must not be optional
         type(ESMF_State)            :: exportState  ! must not be optional
         type(ESMF_Clock)            :: clock        ! must not be optional
         integer, intent(out)        :: rc           ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set an <EM>internal</EM> entry point for a GridComp (i.e. Driver). Only Drivers 
   currently utilize internal entry points. Internal entry points allow user
   specialization on the driver level during initialization and run sequencing. 

<P>

<P>

<H3><A NAME="SECTION000463400000000000000">
3.6.34 NUOPC_CompSetServices - Try to find and call SetServices in a shared object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSetServices()
   recursive subroutine NUOPC_GridCompSetServices(comp, sharedObj, userRc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     character(len=*),        intent(in),  optional :: sharedObj
     integer,                 intent(out), optional :: userRc
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Try to find a routine called "<TT>SetServices</TT>" in the <TT>sharedObj</TT> file
     and execute the routine. An attempt is made to find a routine that
     is close in name to "<TT>SetServices</TT>", allowing for compiler name
     mangling, i.e. upper and lower case, as well as trailing underscores. 

<P>

<P>

<H3><A NAME="SECTION000463500000000000000">
3.6.35 NUOPC_CompSpecialize - Specialize a derived GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSpecialize()
   subroutine NUOPC_GridCompSpecialize(comp, specLabel, specPhaseLabel, &amp;
     specRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                     :: comp
     character(len=*), intent(in)            :: specLabel
     character(len=*), intent(in),  optional :: specPhaseLabel
     interface
       subroutine specRoutine(gridcomp, rc)
         use ESMF
         implicit none
         type(ESMF_GridComp)        :: gridcomp ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Specialize a derived GridComp (i.e. Model, Mediator, or Driver). If
   <TT>specPhaseLabel</TT> is specified, the specialization only applies to
   the associated phase. Otherwise the specialization applies to all phases. 

<P>

<P>

<H3><A NAME="SECTION000463600000000000000">
3.6.36 NUOPC_CompSpecialize - Specialize a derived CplComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_CompSpecialize()
   subroutine NUOPC_CplCompSpecialize(comp, specLabel, specPhaseLabel, &amp;
     specRoutine, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp)                      :: comp
     character(len=*), intent(in)            :: specLabel
     character(len=*), intent(in),  optional :: specPhaseLabel
     interface
       subroutine specRoutine(cplcomp, rc)
         use ESMF
         implicit none
         type(ESMF_CplComp)         :: cplcomp  ! must not be optional
         integer, intent(out)       :: rc       ! must not be optional
       end subroutine
     end interface
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Specialize a derived CplComp (i.e. Connector). If
   <TT>specPhaseLabel</TT> is specified, the specialization only applies to
   the associated phase. Otherwise the specialization applies to all phases.


<P>

<H2><A NAME="SECTION00047000000000000000">
3.7 Field Dictionary Methods</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00047100000000000000">
3.7.1 NUOPC_FieldDictionaryAddEntry - Add an entry to the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionaryAddEntry(standardName, canonicalUnits, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     character(*),                 intent(in)            :: canonicalUnits
     integer,                      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add an entry to the NUOPC Field dictionary. If necessary the dictionary is
     first set up. 

<P>

<P>

<H3><A NAME="SECTION00047200000000000000">
3.7.2 NUOPC_FieldDictionaryEgest - Egest NUOPC Field dictionary into FreeFormat</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionaryEgest(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat), intent(out)           :: freeFormat
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Egest the contents of the NUOPC Field dictionary into a FreeFormat object.
     It is the caller's responsibility to destroy the created <TT>freeFormat</TT>
     object. 

<P>

<P>

<H3><A NAME="SECTION00047300000000000000">
3.7.3 NUOPC_FieldDictionaryGetEntry - Get information about a NUOPC Field dictionary entry</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionaryGetEntry(standardName, canonicalUnits, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     character(*),                 intent(out), optional :: canonicalUnits
     integer,                      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return the canonical units that the NUOPC Field dictionary associates with
     the <TT>standardName</TT>. 

<P>

<P>

<H3><A NAME="SECTION00047400000000000000">
3.7.4 NUOPC_FieldDictionaryHasEntry - Check whether the NUOPC Field dictionary has a specific entry</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_FieldDictionaryHasEntry(standardName, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_FieldDictionaryHasEntry
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     integer,                      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the NUOPC Field dictionary has an entry with the
     specified <TT>standardName</TT>, <TT>.false.</TT> otherwise. 

<P>

<P>

<H3><A NAME="SECTION00047500000000000000">
3.7.5 NUOPC_FieldDictionaryMatchSyno - Check whether the NUOPC Field dictionary considers the standard names synonyms</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_FieldDictionaryMatchSyno(standardName1, standardName2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_FieldDictionaryMatchSyno
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName1
     character(*),                 intent(in)            :: standardName2
     integer,                      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the NUOPC Field dictionary considers
     <TT>standardName1</TT> and <TT>standardName2</TT> synonyms, <TT>.false.</TT> 
     otherwise. An entry with standard name of <TT>standardName1</TT> must
     exist in the field dictionary, or else an error will be returned. 
     However, <TT>standardName2</TT> need not correspond to an existing entry.
     If <TT>standardName2</TT> does not correspond to an existing entry in the 
     field dictionary, the value of .false. will be returned. 

<P>

<P>

<H3><A NAME="SECTION00047600000000000000">
3.7.6 NUOPC_FieldDictionarySetSyno - Set synonyms in the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionarySetSyno(standardNames, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardNames(:)
     integer,                      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set all of the elements of the <TT>standardNames</TT> argument to be considered
     synonyms by the field dictionary. Every element in <TT>standardNames</TT> must
     correspond to the standard name of already existing entries in the field 
     dictionary, or else an error will be returned. 

<P>

<P>

<H3><A NAME="SECTION00047700000000000000">
3.7.7 NUOPC_FieldDictionarySetup - Setup the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionarySetup(rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Setup the NUOPC Field dictionary.


<P>

<H2><A NAME="SECTION00048000000000000000">
3.8 Free Format Methods</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00048100000000000000">
3.8.1 NUOPC_FreeFormatAdd - Add lines to a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatAdd(freeFormat, stringList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(inout) :: freeFormat
     character(len=*),                 intent(in)    :: stringList(:)
     integer,                optional, intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add lines to a FreeFormat object. The capacity of <TT>freeFormat</TT> is 
     increased by at list the size of <TT>stringList</TT>, but potentially more.
     The elements in <TT>stringList</TT> are added to the end of <TT>freeFormat</TT>. 

<P>

<P>

<H3><A NAME="SECTION00048200000000000000">
3.8.2 NUOPC_FreeFormatCreate - Create a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_FreeFormatCreate
   function NUOPC_FreeFormatCreateDefault(stringList, capacity, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(NUOPC_FreeFormat) :: NUOPC_FreeFormatCreateDefault
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*), optional, intent(in)  :: stringList(:)
     integer,          optional, intent(in)  :: capacity
     integer,          optional, intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new FreeFormat object. If <TT>stringList</TT> is provided, then the
     newly created object will hold the provided strings and the count is that 
     of <TT>size(stringList)</TT>. If <TT>capacity</TT> is provided, it is used to set
     the capacity of the newly created FreeFormat object. Providing a
     <TT>capacity</TT> that is smaller than <TT>size(stringList)</TT> triggers an
     error. 

<P>

<P>

<H3><A NAME="SECTION00048300000000000000">
3.8.3 NUOPC_FreeFormatCreate - Create a FreeFormat object from Config</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_FreeFormatCreate
   function NUOPC_FreeFormatCreateRead(config, label, relaxedflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(NUOPC_FreeFormat) :: NUOPC_FreeFormatCreateRead
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config)                            :: config
     character(len=*),      intent(in)            :: label
     logical,               intent(in),  optional :: relaxedflag
     integer,               intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new FreeFormat object from ESMF_Config object. The <TT>config</TT>
     object must exist, and <TT>label</TT> must reference a table attribute 
     within <TT>config</TT>.

<P>
By default an error is returned if <TT>label</TT> is not found in <TT>config</TT>.
   This error can be suppressed by setting <TT>relaxedflag=.true.</TT>, and an 
   empty FreeFormat object will be returned.

<P>

<P>

<H3><A NAME="SECTION00048400000000000000">
3.8.4 NUOPC_FreeFormatDestroy - Destroy a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatDestroy(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(inout) :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy a FreeFormat object. All internal memory is deallocated. 

<P>

<P>

<H3><A NAME="SECTION00048500000000000000">
3.8.5 NUOPC_FreeFormatGet - Get information from a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatGet(freeFormat, lineCount, capacity, stringList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),                       intent(in)  :: freeFormat
     integer,                            optional, intent(out) :: lineCount
     integer,                            optional, intent(out) :: capacity
     character(len=NUOPC_FreeFormatLen), optional, pointer     :: stringList(:)
     integer,                            optional, intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get information from a FreeFormat object. 

<P>

<P>

<H3><A NAME="SECTION00048600000000000000">
3.8.6 NUOPC_FreeFormatGetLine - Get line info from a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatGetLine(freeFormat, line, lineString, tokenCount, &amp;
     tokenList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),                       intent(in)  :: freeFormat
     integer,                                      intent(in)  :: line
     character(len=NUOPC_FreeFormatLen), optional, intent(out) :: lineString
     integer,                            optional, intent(out) :: tokenCount
     character(len=NUOPC_FreeFormatLen), optional, intent(out) :: tokenList(:)
     integer,                            optional, intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get information about a specific line in a FreeFormat object. 

<P>

<P>

<H3><A NAME="SECTION00048700000000000000">
3.8.7 NUOPC_FreeFormatLog - Write a FreeFormat object to the default Log</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatLog(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(in)    :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write a FreeFormat object to the default Log. 

<P>

<P>

<H3><A NAME="SECTION00048800000000000000">
3.8.8 NUOPC_FreeFormatPrint - Print a FreeFormat object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FreeFormatPrint(freeFormat, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_FreeFormat),           intent(in)    :: freeFormat
     integer,                optional, intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print a FreeFormat object.


<P>

<H2><A NAME="SECTION00049000000000000000">
3.9 Utility Routines</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00049100000000000000">
3.9.1 NUOPC_AddNamespace - Add a namespace to a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_AddNamespace(state, namespace, nestedStateName, &amp;
     nestedState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(len=*), intent(in)            :: namespace
     character(len=*), intent(in),  optional :: nestedStateName
     type(ESMF_State), intent(out), optional :: nestedState
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a namespace to <TT>state</TT>. Namespaces are implemented via nested 
     states. This creates a nested state inside of <TT>state</TT>. The nested state
     is returned as <TT>nestedState</TT>. If provided, <TT>nestedStateName</TT> will 
     be used to name the newly created nested state. The default name of the 
     nested state is equal to <TT>namespace</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to which the namespace is added.
     
</DD>
<DT><STRONG>namespace</STRONG></DT>
<DD>The namespace string.
     
</DD>
<DT><STRONG>[nestedStateName]</STRONG></DT>
<DD>Name of the nested state. Defaults to <TT>namespace</TT>.
     
</DD>
<DT><STRONG>[nestedState]</STRONG></DT>
<DD>Optional return of the newly created nested state.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049200000000000000">
3.9.2 NUOPC_Advertise - Advertise a single Field in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_Advertise
   subroutine NUOPC_AdvertiseField(state, StandardName, Units, &amp;
     LongName, ShortName, name, TransferOfferGeomObject, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardName
     character(*),     intent(in),  optional :: Units
     character(*),     intent(in),  optional :: LongName
     character(*),     intent(in),  optional :: ShortName
     character(*),     intent(in),  optional :: name
     character(*),     intent(in),  optional :: TransferOfferGeomObject
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="NUOPC_AdvertiseField"></A>     Advertise a field in a state. This creates an empty field and adds it to
     <TT>state</TT>. The "StandardName", "Units", "LongName", "ShortName", and 
     "TransferOfferGeomObject" attributes of the field are set according to the
     provided input..

<P>
The call checks the provided information against the NUOPC Field Dictionary
     to ensure correctness. Defaults are set according to the NUOPC Field 
     Dictionary.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object through which the field is advertised.
     
</DD>
<DT><STRONG>StandardName</STRONG></DT>
<DD>The "StandardName" attribute of the advertised field. Must be a 
       StandardName found in the  NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[Units]</STRONG></DT>
<DD>The "Units" attribute of the advertised field. Must be convertible to the
       canonical units specified in the NUOPC Field Dictionary for the specified
       StandardName. (Currently this is restricted to be identical to the 
       canonical untis specified in the NUOPC Field Dictionary.)
       If omitted, the default is to use the canonical units associated with
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[LongName]</STRONG></DT>
<DD>The "LongName" attribute of the advertised field. NUOPC does not restrict
       the value of this attribute.
       If omitted, the default is to use the StandardName.
     
</DD>
<DT><STRONG>[ShortName]</STRONG></DT>
<DD>The "ShortName" attribute of the advertised field. NUOPC does not restrict
       the value of this attribute.
       If omitted, the default is to use the StandardName.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The actual name of the advertised field by which it is accessed in the
       state object. NUOPC does not restrict the value of this variable.
       If omitted, the default is to use the value of the ShortName.
     
</DD>
<DT><STRONG>[TransferOfferGeomObject]</STRONG></DT>
<DD>The "TransferOfferGeomObject" attribute of the advertised field. NUOPC 
       controls the vocabulary of this attribute. Valid options are 
       "will provide", "can provide", "cannot provide".
       If omitted, the default is "will provide".
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049300000000000000">
3.9.3 NUOPC_Advertise - Advertise a list of Fields in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_Advertise
   subroutine NUOPC_AdvertiseFields(state, StandardNames, &amp;
     TransferOfferGeomObject, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardNames(:)
     character(*),     intent(in),  optional :: TransferOfferGeomObject
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Advertise a list of fields in a state. This creates a list of empty fields
     and adds it to the <TT>state</TT>. The "StandardName", and 
     "TransferOfferGeomObject" attributes of all the fields are set according to
     the provided input. The "Units", "LongName", and "ShortName" attributes for
     each field are set according to the defaults documented under method 
     <A HREF="#NUOPC_AdvertiseField">3.9.2</A>

<P>
The call checks the provided information against the NUOPC Field Dictionary
     to ensure correctness.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object through which the fields are advertised.
     
</DD>
<DT><STRONG>StandardNames</STRONG></DT>
<DD>A list of "StandardName" attributes of the advertised fields. Must be 
       StandardNames found in the  NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[TransferOfferGeomObject]</STRONG></DT>
<DD>The "TransferOfferGeomObject" attribute associated with the advertised
       fields. This setting applies to all the fields advertised in this call. 
       NUOPC controls the vocabulary of this attribute. Valid options are 
       "will provide", "can provide", "cannot provide".
       If omitted, the default is "will provide".
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049400000000000000">
3.9.4 NUOPC_AdjustClock - Adjust the timestep in a clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_AdjustClock(clock, maxTimestep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock)                               :: clock
     type(ESMF_TimeInterval), intent(in),  optional :: maxTimestep
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Adjust the <TT>clock</TT> to have a potentially smaller timestep. The timestep
     on the incoming <TT>clock</TT> object is compared to the <TT>maxTimestep</TT>, and
     reset to the smaller of the two.

<P>
The arguments are:
     <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The clock to be adjusted.
     
</DD>
<DT><STRONG>[maxTimestep]</STRONG></DT>
<DD>Upper bound of the timestep allowed in <TT>clock</TT>. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049500000000000000">
3.9.5 NUOPC_CheckSetClock - Check a Clock for compatibility and set its values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_CheckSetClock(setClock, checkClock, setStartTimeToCurrent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock),        intent(inout)         :: setClock
     type(ESMF_Clock),        intent(in)            :: checkClock
     logical,                 intent(in),  optional :: setStartTimeToCurrent
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compare <TT>setClock</TT> to <TT>checkClock</TT> to ensure they match in
     their current fime. Further ensure that the timeStep of <TT>checkClock</TT>
     is a multiple of the timeStep of <TT>setClock</TT>. If both conditions are 
     satisfied then the stopTime of the <TT>setClock</TT> is set one 
     <TT>checkClock</TT> timeStep ahead of the current time. The direction of the
     clock is considered.

<P>
By default the startTime of the <TT>setClock</TT> is not modified. However, if
     <TT>setStartTimeToCurrent == .true.</TT> the startTime of <TT>setClock</TT> is set
     to the currentTime of <TT>checkClock</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>setClock</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object to be checked and set.
     
</DD>
<DT><STRONG>checkClock</STRONG></DT>
<DD>The reference clock object.
     
</DD>
<DT><STRONG>[setStartTimeToCurrent]</STRONG></DT>
<DD>If <TT>.true.</TT> then also set the startTime in <TT>setClock</TT> according to
       the startTime in <TT>checkClock</TT>. The default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049600000000000000">
3.9.6 NUOPC_GetAttribute - Get the value of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_GetAttribute
   subroutine NUOPC_GetAttributeFieldVal(field, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     character(*),     intent(in)            :: name
     character(*),     intent(out)           :: value
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>field</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>. Returns with error if
     the attribute is not present or not set.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049700000000000000">
3.9.7 NUOPC_GetAttribute - Get the typekind of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_GetAttribute
   subroutine NUOPC_GetAttributeFieldTK(field, name, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(in)            :: field
     character(*),             intent(in)            :: name
     type(ESMF_TypeKind_Flag), intent(out)           :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query the <TT>typekind</TT> of the attribute <TT>name</TT> inside of <TT>field</TT>
     using the convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>. Returns with 
     error if the attribute is not present or not set.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049800000000000000">
3.9.8 NUOPC_GetAttribute - Get the value of a NUOPC State Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_GetAttribute
   subroutine NUOPC_GetAttributeState(state, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in)            :: name
     character(*),     intent(out)           :: value
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Access the attribute <TT>name</TT> inside of <TT>state</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>. Returns with error if
     the attribute is not present or not set.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be queried.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the queried attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the queried attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049900000000000000">
3.9.9 NUOPC_GetStateMemberLists - Build lists of information of State members</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine NUOPC_GetStateMemberLists(state, StandardNameList, &amp;
     ConnectedList, NamespaceList, itemNameList, fieldList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),       intent(in)            :: state
     character(ESMF_MAXSTR), pointer, optional     :: StandardNameList(:)
     character(ESMF_MAXSTR), pointer, optional     :: ConnectedList(:)
     character(ESMF_MAXSTR), pointer, optional     :: NamespaceList(:)
     character(ESMF_MAXSTR), pointer, optional     :: itemNameList(:)
     type(ESMF_Field),       pointer, optional     :: fieldList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Construct lists containing the StandardNames, field names, and connected 
     status of the fields in <TT>state</TT>. Return this information in the
     list arguments. Recursively parse through nested States.

<P>
All pointer arguments present must enter this method unassociated. On 
     return, the deallocation of an associated pointer becomes the responsibility
     of the caller.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be queried.
     
</DD>
<DT><STRONG>[StandardNameList]</STRONG></DT>
<DD>If present, return a list of the "StandardName" attribute of each member.
     
</DD>
<DT><STRONG>[ConnectedList]</STRONG></DT>
<DD>If present, return a list of the "Connected" attribute of each member.
     
</DD>
<DT><STRONG>[NamespaceList]</STRONG></DT>
<DD>If present, return a list of the namespace of each member.
     
</DD>
<DT><STRONG>[itemNameList]</STRONG></DT>
<DD>If present, return a list of each member name.
     
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>If present, return a list of the member fields.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491000000000000000">
3.9.10 NUOPC_IsAtTime - Check if a Field is at the given Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_IsAtTime
   function NUOPC_IsAtTimeField(field, time, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsAtTimeField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if <TT>field</TT> has a timestamp attribute
     that matches <TT>time</TT>. Otherwise returns <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be checked.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The time to compare against.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491100000000000000">
3.9.11 NUOPC_IsAtTime - Check if Field(s) in a State are at the given Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_IsAtTime
   function NUOPC_IsAtTimeState(state, time, fieldName, count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsAtTimeState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     type(ESMF_Time),  intent(in)            :: time
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the field(s) in <TT>state</TT> have a timestamp 
     attribute that matches <TT>time</TT>. Otherwise return <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be checked.
     
</DD>
<DT><STRONG>time</STRONG></DT>
<DD>The time to compare against.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be checked. If provided, and 
       the state does not contain a field with <TT>fieldName</TT>, return an 
       error in <TT>rc</TT>. If not provided, check <EM>all</EM> the fields contained
       in <TT>state</TT> and return <TT>.true.</TT> if all the fields are at the 
       correct time.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are at time are returned. If 
       <TT>fieldName</TT> is present then <TT>count</TT> cannot be greater than 1.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491200000000000000">
3.9.12 NUOPC_IsConnected - Check if a Field is connected</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_IsConnected
   function NUOPC_IsConnectedField(field, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsConnectedField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the <TT>field</TT> is connected.
     Otherwise return <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be checked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491300000000000000">
3.9.13 NUOPC_IsConnected - Check if Field(s) in a State are connected</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_IsConnected
   function NUOPC_IsConnectedState(state, fieldName, count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsConnectedState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the field(s) in <TT>state</TT> are connected. Otherwise
     return <TT>.false.</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be checked.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be checked. If provided, and 
       the state does not contain a field with <TT>fieldName</TT>, return an 
       error in <TT>rc</TT>. If not provided, check <EM>all</EM> the fields contained
       in <TT>state</TT> and return <TT>.true.</TT> if all the fields are connected.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are connected are returned. If 
       <TT>fieldName</TT> is present then <TT>count</TT> cannot be greater than 1.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491400000000000000">
3.9.14 NUOPC_IsUpdated - Check if a Field is marked as updated</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_IsUpdated
   function NUOPC_IsUpdatedField(field, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsUpdatedField
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the field has its "Updated"
     attribute set to "true". Otherwise return <TT>.false.</TT>. 

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be checked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491500000000000000">
3.9.15 NUOPC_IsUpdated - Check if Field(s) in a State are marked as updated</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_IsUpdated
   function NUOPC_IsUpdatedState(state, fieldName, count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_IsUpdatedState
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in),  optional :: fieldName
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return <TT>.true.</TT> if the field(s) in <TT>state</TT> have the "Updated"
     attribute set to "true". Otherwise return <TT>.false.</TT>. 

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object to be checked.
     
</DD>
<DT><STRONG>[fieldName]</STRONG></DT>
<DD>The name of the field in <TT>state</TT> to be checked. If provided, and 
       the state does not contain a field with <TT>fieldName</TT>, return an 
       error in <TT>rc</TT>. If not provided, check <EM>all</EM> the fields contained
       in <TT>state</TT> and return <TT>.true.</TT> if all the fields are updated.
     
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>If provided, the number of fields that are updated are returned. If 
       <TT>fieldName</TT> is present then <TT>count</TT> cannot be greater than 1.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491600000000000000">
3.9.16 NUOPC_NoOp - No-Operation attachable method for GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_NoOp(gcomp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)   :: gcomp
     integer, intent(out)  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
No-Op method with an interface that matches the
     requirements for a attachable method for ESMF_GridComp objects.

<P>
The arguments are:
     <DL>
<DT><STRONG>gcomp</STRONG></DT>
<DD>The <TT>ESMF_GridComp</TT> object to which this method is attached.
     
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491700000000000000">
3.9.17 NUOPC_Realize - Realize previously advertised Fields inside a State on a single Grid with internal allocation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_Realize
   subroutine NUOPC_RealizeComplete(state, grid, typekind, selection, &amp;
     dataFillScheme, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                                :: state
     type(ESMF_Grid), intent(in)                     :: grid
     type(ESMF_TypeKind_Flag), intent(in),  optional :: typekind
     character(len=*),         intent(in),  optional :: selection
     character(len=*),         intent(in),  optional :: dataFillScheme    
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Realize or remove fields inside of <TT>state</TT> according to <TT>selection</TT>.
     All of the fields that are realized are created internally on the same 
     <TT>grid</TT> object, allocating memory for as many field dimensions as there 
     are grid dimensions.

<P>
The type and kind of the created fields is according to argument 
     <TT>typekind</TT>.

<P>
Realized fields are filled with data according to the <TT>dataFillScheme</TT>
     argument.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object in which the fields are realized.
     
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on which to realize the fields.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on which to realize the fields.
       The typekind of the internally created field(s). The valid options are
       <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
       <TT>ESMF_TYPEKIND_R4</TT>, and <TT>ESMF_TYPEKIND_R8</TT> (default).
     
</DD>
<DT><STRONG>[selection]</STRONG></DT>
<DD>Selection of mode of operation:
       
<UL>
<LI><TT>"realize_all"</TT> (default)
</LI>
<LI><TT>"realize_connected_remove_others"</TT>
       
</LI>
</UL>
     
</DD>
<DT><STRONG>[dataFillScheme]</STRONG></DT>
<DD>Realized fields will be filled according to the selected fill
       scheme. See <A HREF="#NUOPC_FillField"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for fill schemes. Default is to leave
       the data in realized fields uninitialized.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491800000000000000">
3.9.18 NUOPC_Realize - Realize a previously advertised Field in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_Realize
   subroutine NUOPC_RealizeField(state, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Realize a previously advertised field in <TT>state</TT> by replacing the
     advertised field with <TT>field</TT> of the same name.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object in which the fields are realized.
     
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>The new field to put in place of the previously advertised (empty) field.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491900000000000000">
3.9.19 NUOPC_SetAttribute - Set the value of a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_SetAttribute
   subroutine NUOPC_SetAttributeField(field, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field)                      :: field
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the attribute <TT>name</TT> inside of <TT>field</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on which to set the attribute.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the set attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the set attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492000000000000000">
3.9.20 NUOPC_SetAttribute - Set the value of a NUOPC State Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_SetAttribute
   subroutine NUOPC_SetAttributeState(state, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State)                      :: state
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the attribute <TT>name</TT> inside of <TT>state</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>Instance</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object on which to set the attribute.
     
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the set attribute.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>The value of the set attribute.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<P>

<H2><A NAME="SECTION000410000000000000000">
3.10 Auxiliary Routines</A>
</H2>
Auxiliary routines are provided with the NUOPC Layer as a convenience to the
user. Typically more work is needed on these methods before considering them
NUOPC core functionality.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION000410100000000000000">
3.10.1 NUOPC_Write - Write a distributed factorList to file</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_Write
   subroutine NUOPC_FactorsWrite(factorList, fileName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), pointer               :: factorList(:)
     character(*),       intent(in)            :: fileName
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write the destributed <TT>factorList</TT> to file. Each PET calls with its 
     local list of factors. The call then writes the distributed factors into
     a single file. The order of the factors in the file is first by PET, and 
     within each PET the PET-local order is preserved. Changing the number of 
     PETs for the same regrid operation will likely change the order of factors
     across PETs, and therefore files written will differ.

<P>
The arguments are:
     <DL>
<DT><STRONG>factorList</STRONG></DT>
<DD>The distributed factor list.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file to be written to.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000410200000000000000">
3.10.2 NUOPC_Write - Write Field data to file</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_Write
   subroutine NUOPC_FieldWrite(field, fileName, overwrite, status, timeslice, &amp;
     iofmt, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),           intent(in)            :: field
     character(*),               intent(in)            :: fileName
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     type(ESMF_IOFmt_Flag),      intent(in),  optional :: iofmt
     logical,                    intent(in),  optional :: relaxedflag
     integer,                    intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write the data in <TT>field</TT> to <TT>file</TT> under the field's "StandardName" 
     attribute if supported by the <TT>iofmt</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object whose data is to be written.
     
</DD>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the file to write to.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Field data may
        <EM>not</EM> be overwritten. If .true., the
        data corresponding to each field's name will be
        be overwritten. If the <TT>timeslice</TT> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
     
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Valid options are <TT>ESMF_FILESTATUS_NEW</TT>, 
        <TT>ESMF_FILESTATUS_OLD</TT>, <TT>ESMF_FILESTATUS_REPLACE</TT>, and
        <TT>ESMF_FILESTATUS_UNKNOWN</TT> (default).
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Time slice counter. Must be positive. The behavior of this
       option may depend on the setting of the <TT>overwrite</TT> flag:
       <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
       less than the maximum time already in the file, the write will fail.
       
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
       
</DD>
</DL>
       By default, i.e. by omitting the <TT>timeslice</TT> argument, no
       provisions for time slicing are made in the output file,
       however, if the file already contains a time axis for the variable,
       a timeslice one greater than the maximum will be written.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format.  Valid options are  <TT>ESMF_IOFMT_BIN</TT> and 
      <TT>ESMF_IOFMT_NETCDF</TT>. If not present, file names with a <TT>.bin</TT> 
      extension will use <TT>ESMF_IOFMT_BIN</TT>, and file names with a <TT>.nc</TT>
      extension will use <TT>ESMF_IOFMT_NETCDF</TT>.  Other files default to
      <TT>ESMF_IOFMT_NETCDF</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <TT>.true.</TT>, then no error is returned even if the call cannot write
       the file due to library limitations. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000410300000000000000">
3.10.3 NUOPC_Write - Write the Fields within a State to NetCDF files</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_Write
   subroutine NUOPC_StateWrite(state, fieldNameList, fileNamePrefix, overwrite, &amp;
     status, timeslice, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),           intent(in)            :: state
     character(len=*),           intent(in),  optional :: fieldNameList(:)
     character(len=*),           intent(in),  optional :: fileNamePrefix
     logical,                    intent(in),  optional :: overwrite
     type(ESMF_FileStatus_Flag), intent(in),  optional :: status
     integer,                    intent(in),  optional :: timeslice
     logical,                    intent(in),  optional :: relaxedflag
     integer,                    intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write the data of the fields within a <TT>state</TT> to NetCDF files. Each 
     field is written to an individual file using the "StandardName" attribute
     as NetCDF attribute.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object containing the fields.
     
</DD>
<DT><STRONG>[fieldNameList]</STRONG></DT>
<DD>List of names of the fields to be written. By default write all the fields
       in <TT>state</TT>.
     
</DD>
<DT><STRONG>[fileNamePrefix]</STRONG></DT>
<DD>File name prefix, common to all the files written.
     
</DD>
<DT><STRONG>[overwrite]</STRONG></DT>
<DD>A logical flag, the default is .false., i.e., existing Field data may
        <EM>not</EM> be overwritten. If .true., the
        data corresponding to each field's name will be
        be overwritten. If the <TT>timeslice</TT> option is given, only data for
        the given timeslice may be overwritten.
        Note that it is always an error to attempt to overwrite a NetCDF
        variable with data which has a different shape.
     
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The file status. Valid options are <TT>ESMF_FILESTATUS_NEW</TT>, 
        <TT>ESMF_FILESTATUS_OLD</TT>, <TT>ESMF_FILESTATUS_REPLACE</TT>, and
        <TT>ESMF_FILESTATUS_UNKNOWN</TT> (default).
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Time slice counter. Must be positive. The behavior of this
       option may depend on the setting of the <TT>overwrite</TT> flag:
       <DL>
<DT><STRONG><TT>overwrite = .false.</TT>:</STRONG></DT>
<DD> If the timeslice value is
       less than the maximum time already in the file, the write will fail.
       
</DD>
<DT><STRONG><TT>overwrite = .true.</TT>:</STRONG></DT>
<DD> Any positive timeslice value is valid.
       
</DD>
</DL>
       By default, i.e. by omitting the <TT>timeslice</TT> argument, no
       provisions for time slicing are made in the output file,
       however, if the file already contains a time axis for the variable,
       a timeslice one greater than the maximum will be written.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>If <TT>.true.</TT>, then no error is returned even if the call cannot write
       the file due to library limitations. Default is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>


<P>

<P>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html344"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html340"
  HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html334"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html342"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html345"
  HREF="node5.html">4 Standardized Component Dependencies</A>
<B> Up:</B> <A NAME="tex2html341"
  HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A NAME="tex2html335"
  HREF="node3.html">2 Design and Implementation</A>
 &nbsp; <B>  <A NAME="tex2html343"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
