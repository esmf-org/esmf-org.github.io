<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>5 Infrastructure: Utilities</TITLE>
<META NAME="description" CONTENT="5 Infrastructure: Utilities">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node7.html">
<LINK REL="previous" HREF="node5.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node7.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html2287"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2283"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2277"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2285"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2288"
  HREF="node7.html">6 References</A>
<B> Up:</B> <A NAME="tex2html2284"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html2278"
  HREF="node5.html">4 Infrastructure: Fields and</A>
 &nbsp <B>  <A NAME="tex2html2286"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html2289"
  HREF="node6.html#SECTION06010000000000000000">34 Overview of Infrastructure Utility Classes</A>
<LI><A NAME="tex2html2290"
  HREF="node6.html#SECTION06020000000000000000">35 Attribute Class</A>
<UL>
<LI><A NAME="tex2html2291"
  HREF="node6.html#SECTION06021000000000000000">35.1 Description</A>
<UL>
<LI><A NAME="tex2html2292"
  HREF="node6.html#SECTION06021100000000000000">35.1.1 The ESMF approach to Attributes</A>
<LI><A NAME="tex2html2293"
  HREF="node6.html#SECTION06021200000000000000">35.1.2 Attribute hierarchies</A>
</UL>
<LI><A NAME="tex2html2294"
  HREF="node6.html#SECTION06022000000000000000">35.2 Attribute Packages</A>
<UL>
<LI><A NAME="tex2html2295"
  HREF="node6.html#SECTION06022100000000000000">35.2.1 Component Attribute packages</A>
<LI><A NAME="tex2html2296"
  HREF="node6.html#SECTION06022200000000000000">35.2.2 State Attribute packages</A>
<LI><A NAME="tex2html2297"
  HREF="node6.html#SECTION06022300000000000000">35.2.3 Field Attribute packages</A>
<LI><A NAME="tex2html2298"
  HREF="node6.html#SECTION06022400000000000000">35.2.4 Array Attribute packages</A>
<LI><A NAME="tex2html2299"
  HREF="node6.html#SECTION06022500000000000000">35.2.5 Grid Attribute packages</A>
<LI><A NAME="tex2html2300"
  HREF="node6.html#SECTION06022600000000000000">35.2.6 Table of available Attributes</A>
<LI><A NAME="tex2html2301"
  HREF="node6.html#SECTION06022700000000000000">35.2.7 Custom Attribute packages</A>
</UL>
<LI><A NAME="tex2html2302"
  HREF="node6.html#SECTION06023000000000000000">35.3 Attribute Packages Nesting</A>
<LI><A NAME="tex2html2303"
  HREF="node6.html#SECTION06024000000000000000">35.4 Export Formats</A>
<UL>
<LI><A NAME="tex2html2304"
  HREF="node6.html#SECTION06024100000000000000">35.4.1 Tab-delimited ASCII</A>
<LI><A NAME="tex2html2305"
  HREF="node6.html#SECTION06024200000000000000">35.4.2 Simple XML</A>
<LI><A NAME="tex2html2306"
  HREF="node6.html#SECTION06024300000000000000">35.4.3 CIM XML</A>
</UL>
<LI><A NAME="tex2html2307"
  HREF="node6.html#SECTION06025000000000000000">35.5 Constants</A>
<UL>
<LI><A NAME="tex2html2308"
  HREF="node6.html#SECTION06025100000000000000">35.5.1 ESMF_ATTGETCOUNT</A>
<LI><A NAME="tex2html2309"
  HREF="node6.html#SECTION06025200000000000000">35.5.2 ESMF_ATTTREE</A>
<LI><A NAME="tex2html2310"
  HREF="node6.html#SECTION06025300000000000000">35.5.3 ESMF_ATTWRITE</A>
</UL>
<LI><A NAME="tex2html2311"
  HREF="node6.html#SECTION06026000000000000000">35.6 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2312"
  HREF="node6.html#SECTION06026100000000000000">35.6.1 Basic Attribute usage</A>
<LI><A NAME="tex2html2313"
  HREF="node6.html#SECTION06026200000000000000">35.6.2 Attribute packages</A>
<LI><A NAME="tex2html2314"
  HREF="node6.html#SECTION06026300000000000000">35.6.3 Custom Attribute package</A>
<LI><A NAME="tex2html2315"
  HREF="node6.html#SECTION06026400000000000000">35.6.4 Updating Attributes in a distributed environment</A>
<LI><A NAME="tex2html2316"
  HREF="node6.html#SECTION06026500000000000000">35.6.5 CIM Attribute packages</A>
<LI><A NAME="tex2html2317"
  HREF="node6.html#SECTION06026600000000000000">35.6.6 Read an XML file-based ESG Attribute package for a Gridded Component</A>
<LI><A NAME="tex2html2318"
  HREF="node6.html#SECTION06026700000000000000">35.6.7 Read an XML file-based CF Attribute package for a Field</A>
<LI><A NAME="tex2html2319"
  HREF="node6.html#SECTION06026800000000000000">35.6.8 Read an XML file-based GridSpec Attribute package for a Grid</A>
<LI><A NAME="tex2html2320"
  HREF="node6.html#SECTION06026900000000000000">35.6.9 Read and validate an XML file-based set of user-defined Attributes for a Coupler Component</A>
</UL>
<LI><A NAME="tex2html2321"
  HREF="node6.html#SECTION06027000000000000000">35.7 Restrictions and Future Work</A>
<UL>
<LI><A NAME="tex2html2322"
  HREF="node6.html#SECTION06027100000000000000">35.7.1 Attributes</A>
<LI><A NAME="tex2html2323"
  HREF="node6.html#SECTION06027200000000000000">35.7.2 Attribute packages</A>
<LI><A NAME="tex2html2324"
  HREF="node6.html#SECTION06027300000000000000">35.7.3 Attribute hierarchies</A>
<LI><A NAME="tex2html2325"
  HREF="node6.html#SECTION06027400000000000000">35.7.4 Attribute import and export</A>
</UL>
<LI><A NAME="tex2html2326"
  HREF="node6.html#SECTION06028000000000000000">35.8 Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html2327"
  HREF="node6.html#SECTION06028100000000000000">35.8.1 Attribute memory deallocation</A>
<LI><A NAME="tex2html2328"
  HREF="node6.html#SECTION06028200000000000000">35.8.2 Using <TT>ESMF_AttributeGet()</TT> to retrieve Attribute lists</A>
<LI><A NAME="tex2html2329"
  HREF="node6.html#SECTION06028300000000000000">35.8.3 Using Attribute package nesting capabilites</A>
<LI><A NAME="tex2html2330"
  HREF="node6.html#SECTION06028400000000000000">35.8.4 Attributes in a distributed environment</A>
<LI><A NAME="tex2html2331"
  HREF="node6.html#SECTION06028500000000000000">35.8.5 Writing Attribute packages to file</A>
<LI><A NAME="tex2html2332"
  HREF="node6.html#SECTION06028600000000000000">35.8.6 Copying Attribute hierarchies</A>
<LI><A NAME="tex2html2333"
  HREF="node6.html#SECTION06028700000000000000">35.8.7 Reading and writing Attributes from XML files</A>
</UL>
<LI><A NAME="tex2html2334"
  HREF="node6.html#SECTION06029000000000000000">35.9 Object Model</A>
<LI><A NAME="tex2html2335"
  HREF="node6.html#SECTION060210000000000000000">35.10 Class API</A>
<UL>
<LI><A NAME="tex2html2336"
  HREF="node6.html#SECTION060210100000000000000">35.10.1 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2337"
  HREF="node6.html#SECTION060210200000000000000">35.10.2 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2338"
  HREF="node6.html#SECTION060210300000000000000">35.10.3 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2339"
  HREF="node6.html#SECTION060210400000000000000">35.10.4 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2340"
  HREF="node6.html#SECTION060210500000000000000">35.10.5 ESMF_AttributeAdd</A>
<LI><A NAME="tex2html2341"
  HREF="node6.html#SECTION060210600000000000000">35.10.6 ESMF_AttributeCopy</A>
<LI><A NAME="tex2html2342"
  HREF="node6.html#SECTION060210700000000000000">35.10.7 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2343"
  HREF="node6.html#SECTION060210800000000000000">35.10.8 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2344"
  HREF="node6.html#SECTION060210900000000000000">35.10.9 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2345"
  HREF="node6.html#SECTION0602101000000000000000">35.10.10 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2346"
  HREF="node6.html#SECTION0602101100000000000000">35.10.11 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2347"
  HREF="node6.html#SECTION0602101200000000000000">35.10.12 ESMF_AttributeGet</A>
<LI><A NAME="tex2html2348"
  HREF="node6.html#SECTION0602101300000000000000">35.10.13 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2349"
  HREF="node6.html#SECTION0602101400000000000000">35.10.14 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2350"
  HREF="node6.html#SECTION0602101500000000000000">35.10.15 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2351"
  HREF="node6.html#SECTION0602101600000000000000">35.10.16 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2352"
  HREF="node6.html#SECTION0602101700000000000000">35.10.17 ESMF_AttributeLink</A>
<LI><A NAME="tex2html2353"
  HREF="node6.html#SECTION0602101800000000000000">35.10.18 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2354"
  HREF="node6.html#SECTION0602101900000000000000">35.10.19 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2355"
  HREF="node6.html#SECTION0602102000000000000000">35.10.20 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2356"
  HREF="node6.html#SECTION0602102100000000000000">35.10.21 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2357"
  HREF="node6.html#SECTION0602102200000000000000">35.10.22 ESMF_AttributeLinkRemove</A>
<LI><A NAME="tex2html2358"
  HREF="node6.html#SECTION0602102300000000000000">35.10.23 ESMF_AttributeRead</A>
<LI><A NAME="tex2html2359"
  HREF="node6.html#SECTION0602102400000000000000">35.10.24 ESMF_AttributeRemove</A>
<LI><A NAME="tex2html2360"
  HREF="node6.html#SECTION0602102500000000000000">35.10.25 ESMF_AttributeSet</A>
<LI><A NAME="tex2html2361"
  HREF="node6.html#SECTION0602102600000000000000">35.10.26 ESMF_AttributeSet</A>
<LI><A NAME="tex2html2362"
  HREF="node6.html#SECTION0602102700000000000000">35.10.27 ESMF_AttributeUpdate</A>
<LI><A NAME="tex2html2363"
  HREF="node6.html#SECTION0602102800000000000000">35.10.28 ESMF_AttributeWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html2364"
  HREF="node6.html#SECTION06030000000000000000">36 Time Manager Utility</A>
<UL>
<LI><A NAME="tex2html2365"
  HREF="node6.html#SECTION06031000000000000000">36.1 Time Manager Classes</A>
<LI><A NAME="tex2html2366"
  HREF="node6.html#SECTION06032000000000000000">36.2 Calendar</A>
<LI><A NAME="tex2html2367"
  HREF="node6.html#SECTION06033000000000000000">36.3 Time Instants and TimeIntervals</A>
<LI><A NAME="tex2html2368"
  HREF="node6.html#SECTION06034000000000000000">36.4 Clocks and Alarms</A>
<LI><A NAME="tex2html2369"
  HREF="node6.html#SECTION06035000000000000000">36.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html2370"
  HREF="node6.html#SECTION06036000000000000000">36.6 Object Model</A>
</UL>
<LI><A NAME="tex2html2371"
  HREF="node6.html#SECTION06040000000000000000">37 Calendar Class</A>
<UL>
<LI><A NAME="tex2html2372"
  HREF="node6.html#SECTION06041000000000000000">37.1 Description</A>
<LI><A NAME="tex2html2373"
  HREF="node6.html#SECTION06042000000000000000">37.2 Constants</A>
<UL>
<LI><A NAME="tex2html2374"
  HREF="node6.html#SECTION06042100000000000000">37.2.1 ESMF_CALKIND</A>
</UL>
<LI><A NAME="tex2html2375"
  HREF="node6.html#SECTION06043000000000000000">37.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2376"
  HREF="node6.html#SECTION06043100000000000000">37.3.1 Calendar creation</A>
<LI><A NAME="tex2html2377"
  HREF="node6.html#SECTION06043200000000000000">37.3.2 Calendar comparison</A>
<LI><A NAME="tex2html2378"
  HREF="node6.html#SECTION06043300000000000000">37.3.3 Time conversion between Calendars</A>
<LI><A NAME="tex2html2379"
  HREF="node6.html#SECTION06043400000000000000">37.3.4 Calendar destruction</A>
</UL>
<LI><A NAME="tex2html2380"
  HREF="node6.html#SECTION06044000000000000000">37.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html2381"
  HREF="node6.html#SECTION06045000000000000000">37.5 Class API</A>
<UL>
<LI><A NAME="tex2html2382"
  HREF="node6.html#SECTION06045100000000000000">37.5.1 ESMF_CalendarAssignment(=)</A>
<LI><A NAME="tex2html2383"
  HREF="node6.html#SECTION06045200000000000000">37.5.2 ESMF_CalendarOperator(==)</A>
<LI><A NAME="tex2html2384"
  HREF="node6.html#SECTION06045300000000000000">37.5.3 ESMF_CalendarOperator(/=)</A>
<LI><A NAME="tex2html2385"
  HREF="node6.html#SECTION06045400000000000000">37.5.4 ESMF_CalendarCreate</A>
<LI><A NAME="tex2html2386"
  HREF="node6.html#SECTION06045500000000000000">37.5.5 ESMF_CalendarCreate</A>
<LI><A NAME="tex2html2387"
  HREF="node6.html#SECTION06045600000000000000">37.5.6 ESMF_CalendarCreate</A>
<LI><A NAME="tex2html2388"
  HREF="node6.html#SECTION06045700000000000000">37.5.7 ESMF_CalendarDestroy</A>
<LI><A NAME="tex2html2389"
  HREF="node6.html#SECTION06045800000000000000">37.5.8 ESMF_CalendarGet</A>
<LI><A NAME="tex2html2390"
  HREF="node6.html#SECTION06045900000000000000">37.5.9 ESMF_CalendarIsLeapYear</A>
<LI><A NAME="tex2html2391"
  HREF="node6.html#SECTION060451000000000000000">37.5.10 ESMF_CalendarPrint</A>
<LI><A NAME="tex2html2392"
  HREF="node6.html#SECTION060451100000000000000">37.5.11 ESMF_CalendarSet</A>
<LI><A NAME="tex2html2393"
  HREF="node6.html#SECTION060451200000000000000">37.5.12 ESMF_CalendarSet</A>
<LI><A NAME="tex2html2394"
  HREF="node6.html#SECTION060451300000000000000">37.5.13 ESMF_CalendarSetDefault</A>
<LI><A NAME="tex2html2395"
  HREF="node6.html#SECTION060451400000000000000">37.5.14 ESMF_CalendarSetDefault</A>
<LI><A NAME="tex2html2396"
  HREF="node6.html#SECTION060451500000000000000">37.5.15 ESMF_CalendarValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2397"
  HREF="node6.html#SECTION06050000000000000000">38 Time Class</A>
<UL>
<LI><A NAME="tex2html2398"
  HREF="node6.html#SECTION06051000000000000000">38.1 Description</A>
<LI><A NAME="tex2html2399"
  HREF="node6.html#SECTION06052000000000000000">38.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2400"
  HREF="node6.html#SECTION06052100000000000000">38.2.1 Time initialization</A>
<LI><A NAME="tex2html2401"
  HREF="node6.html#SECTION06052200000000000000">38.2.2 Time increment</A>
<LI><A NAME="tex2html2402"
  HREF="node6.html#SECTION06052300000000000000">38.2.3 Time comparison</A>
</UL>
<LI><A NAME="tex2html2403"
  HREF="node6.html#SECTION06053000000000000000">38.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html2404"
  HREF="node6.html#SECTION06054000000000000000">38.4 Class API</A>
<UL>
<LI><A NAME="tex2html2405"
  HREF="node6.html#SECTION06054100000000000000">38.4.1 ESMF_TimeAssignment(=)</A>
<LI><A NAME="tex2html2406"
  HREF="node6.html#SECTION06054200000000000000">38.4.2 ESMF_TimeOperator(+)</A>
<LI><A NAME="tex2html2407"
  HREF="node6.html#SECTION06054300000000000000">38.4.3 ESMF_TimeOperator(-)</A>
<LI><A NAME="tex2html2408"
  HREF="node6.html#SECTION06054400000000000000">38.4.4 ESMF_TimeOperator(-)</A>
<LI><A NAME="tex2html2409"
  HREF="node6.html#SECTION06054500000000000000">38.4.5 ESMF_TimeOperator(==)</A>
<LI><A NAME="tex2html2410"
  HREF="node6.html#SECTION06054600000000000000">38.4.6 ESMF_TimeOperator(/=)</A>
<LI><A NAME="tex2html2411"
  HREF="node6.html#SECTION06054700000000000000">38.4.7 ESMF_TimeOperator(&lt;)</A>
<LI><A NAME="tex2html2412"
  HREF="node6.html#SECTION06054800000000000000">38.4.8 ESMF_TimeOperator(&lt;=)</A>
<LI><A NAME="tex2html2413"
  HREF="node6.html#SECTION06054900000000000000">38.4.9 ESMF_TimeOperator(&gt;)</A>
<LI><A NAME="tex2html2414"
  HREF="node6.html#SECTION060541000000000000000">38.4.10 ESMF_TimeOperator(&gt;=)</A>
<LI><A NAME="tex2html2415"
  HREF="node6.html#SECTION060541100000000000000">38.4.11 ESMF_TimeGet</A>
<LI><A NAME="tex2html2416"
  HREF="node6.html#SECTION060541200000000000000">38.4.12 ESMF_TimeIsLeapYear</A>
<LI><A NAME="tex2html2417"
  HREF="node6.html#SECTION060541300000000000000">38.4.13 ESMF_TimeIsSameCalendar</A>
<LI><A NAME="tex2html2418"
  HREF="node6.html#SECTION060541400000000000000">38.4.14 ESMF_TimePrint</A>
<LI><A NAME="tex2html2419"
  HREF="node6.html#SECTION060541500000000000000">38.4.15 ESMF_TimeSet</A>
<LI><A NAME="tex2html2420"
  HREF="node6.html#SECTION060541600000000000000">38.4.16 ESMF_TimeSyncToRealTime</A>
<LI><A NAME="tex2html2421"
  HREF="node6.html#SECTION060541700000000000000">38.4.17 ESMF_TimeValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2422"
  HREF="node6.html#SECTION06060000000000000000">39 TimeInterval Class</A>
<UL>
<LI><A NAME="tex2html2423"
  HREF="node6.html#SECTION06061000000000000000">39.1 Description</A>
<LI><A NAME="tex2html2424"
  HREF="node6.html#SECTION06062000000000000000">39.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2425"
  HREF="node6.html#SECTION06062100000000000000">39.2.1 TimeInterval initialization</A>
<LI><A NAME="tex2html2426"
  HREF="node6.html#SECTION06062200000000000000">39.2.2 TimeInterval conversion</A>
<LI><A NAME="tex2html2427"
  HREF="node6.html#SECTION06062300000000000000">39.2.3 TimeInterval difference</A>
<LI><A NAME="tex2html2428"
  HREF="node6.html#SECTION06062400000000000000">39.2.4 TimeInterval multiplication</A>
<LI><A NAME="tex2html2429"
  HREF="node6.html#SECTION06062500000000000000">39.2.5 TimeInterval comparison</A>
</UL>
<LI><A NAME="tex2html2430"
  HREF="node6.html#SECTION06063000000000000000">39.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html2431"
  HREF="node6.html#SECTION06064000000000000000">39.4 Class API</A>
<UL>
<LI><A NAME="tex2html2432"
  HREF="node6.html#SECTION06064100000000000000">39.4.1 ESMF_TimeIntervalAssignment(=)</A>
<LI><A NAME="tex2html2433"
  HREF="node6.html#SECTION06064200000000000000">39.4.2 ESMF_TimeIntervalOperator(+)</A>
<LI><A NAME="tex2html2434"
  HREF="node6.html#SECTION06064300000000000000">39.4.3 ESMF_TimeIntervalOperator(-)</A>
<LI><A NAME="tex2html2435"
  HREF="node6.html#SECTION06064400000000000000">39.4.4 ESMF_TimeIntervalOperator(-)</A>
<LI><A NAME="tex2html2436"
  HREF="node6.html#SECTION06064500000000000000">39.4.5 ESMF_TimeIntervalOperator(/)</A>
<LI><A NAME="tex2html2437"
  HREF="node6.html#SECTION06064600000000000000">39.4.6 ESMF_TimeIntervalOperator(/)</A>
<LI><A NAME="tex2html2438"
  HREF="node6.html#SECTION06064700000000000000">39.4.7 ESMF_TimeIntervalFunction(MOD)</A>
<LI><A NAME="tex2html2439"
  HREF="node6.html#SECTION06064800000000000000">39.4.8 ESMF_TimeIntervalOperator(*)</A>
<LI><A NAME="tex2html2440"
  HREF="node6.html#SECTION06064900000000000000">39.4.9 ESMF_TimeIntervalOperator(==)</A>
<LI><A NAME="tex2html2441"
  HREF="node6.html#SECTION060641000000000000000">39.4.10 ESMF_TimeIntervalOperator(/=)</A>
<LI><A NAME="tex2html2442"
  HREF="node6.html#SECTION060641100000000000000">39.4.11 ESMF_TimeIntervalOperator(&lt;)</A>
<LI><A NAME="tex2html2443"
  HREF="node6.html#SECTION060641200000000000000">39.4.12 ESMF_TimeIntervalOperator(&lt;=)</A>
<LI><A NAME="tex2html2444"
  HREF="node6.html#SECTION060641300000000000000">39.4.13 ESMF_TimeIntervalOperator(&gt;)</A>
<LI><A NAME="tex2html2445"
  HREF="node6.html#SECTION060641400000000000000">39.4.14 ESMF_TimeIntervalOperator(&gt;=)</A>
<LI><A NAME="tex2html2446"
  HREF="node6.html#SECTION060641500000000000000">39.4.15 ESMF_TimeIntervalAbsValue</A>
<LI><A NAME="tex2html2447"
  HREF="node6.html#SECTION060641600000000000000">39.4.16 ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html2448"
  HREF="node6.html#SECTION060641700000000000000">39.4.17 ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html2449"
  HREF="node6.html#SECTION060641800000000000000">39.4.18 ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html2450"
  HREF="node6.html#SECTION060641900000000000000">39.4.19 ESMF_TimeIntervalGet</A>
<LI><A NAME="tex2html2451"
  HREF="node6.html#SECTION060642000000000000000">39.4.20 ESMF_TimeIntervalNegAbsValue</A>
<LI><A NAME="tex2html2452"
  HREF="node6.html#SECTION060642100000000000000">39.4.21 ESMF_TimeIntervalPrint</A>
<LI><A NAME="tex2html2453"
  HREF="node6.html#SECTION060642200000000000000">39.4.22 ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html2454"
  HREF="node6.html#SECTION060642300000000000000">39.4.23 ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html2455"
  HREF="node6.html#SECTION060642400000000000000">39.4.24 ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html2456"
  HREF="node6.html#SECTION060642500000000000000">39.4.25 ESMF_TimeIntervalSet</A>
<LI><A NAME="tex2html2457"
  HREF="node6.html#SECTION060642600000000000000">39.4.26 ESMF_TimeIntervalValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2458"
  HREF="node6.html#SECTION06070000000000000000">40 Clock Class</A>
<UL>
<LI><A NAME="tex2html2459"
  HREF="node6.html#SECTION06071000000000000000">40.1 Description</A>
<LI><A NAME="tex2html2460"
  HREF="node6.html#SECTION06072000000000000000">40.2 Constants</A>
<UL>
<LI><A NAME="tex2html2461"
  HREF="node6.html#SECTION06072100000000000000">40.2.1 ESMF_DIRECTION</A>
</UL>
<LI><A NAME="tex2html2462"
  HREF="node6.html#SECTION06073000000000000000">40.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2463"
  HREF="node6.html#SECTION06073100000000000000">40.3.1 Clock creation</A>
<LI><A NAME="tex2html2464"
  HREF="node6.html#SECTION06073200000000000000">40.3.2 Clock advance</A>
<LI><A NAME="tex2html2465"
  HREF="node6.html#SECTION06073300000000000000">40.3.3 Clock examination</A>
<LI><A NAME="tex2html2466"
  HREF="node6.html#SECTION06073400000000000000">40.3.4 Clock reversal</A>
<LI><A NAME="tex2html2467"
  HREF="node6.html#SECTION06073500000000000000">40.3.5 Clock destruction</A>
</UL>
<LI><A NAME="tex2html2468"
  HREF="node6.html#SECTION06074000000000000000">40.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html2469"
  HREF="node6.html#SECTION06075000000000000000">40.5 Class API</A>
<UL>
<LI><A NAME="tex2html2470"
  HREF="node6.html#SECTION06075100000000000000">40.5.1 ESMF_ClockAssignment(=)</A>
<LI><A NAME="tex2html2471"
  HREF="node6.html#SECTION06075200000000000000">40.5.2 ESMF_ClockOperator(==)</A>
<LI><A NAME="tex2html2472"
  HREF="node6.html#SECTION06075300000000000000">40.5.3 ESMF_ClockOperator(/=)</A>
<LI><A NAME="tex2html2473"
  HREF="node6.html#SECTION06075400000000000000">40.5.4 ESMF_ClockAdvance</A>
<LI><A NAME="tex2html2474"
  HREF="node6.html#SECTION06075500000000000000">40.5.5 ESMF_ClockCreate</A>
<LI><A NAME="tex2html2475"
  HREF="node6.html#SECTION06075600000000000000">40.5.6 ESMF_ClockCreate</A>
<LI><A NAME="tex2html2476"
  HREF="node6.html#SECTION06075700000000000000">40.5.7 ESMF_ClockDestroy</A>
<LI><A NAME="tex2html2477"
  HREF="node6.html#SECTION06075800000000000000">40.5.8 ESMF_ClockGet</A>
<LI><A NAME="tex2html2478"
  HREF="node6.html#SECTION06075900000000000000">40.5.9 ESMF_ClockGetAlarm</A>
<LI><A NAME="tex2html2479"
  HREF="node6.html#SECTION060751000000000000000">40.5.10 ESMF_ClockGetAlarmList</A>
<LI><A NAME="tex2html2480"
  HREF="node6.html#SECTION060751100000000000000">40.5.11 ESMF_ClockGetNextTime</A>
<LI><A NAME="tex2html2481"
  HREF="node6.html#SECTION060751200000000000000">40.5.12 ESMF_ClockIsDone</A>
<LI><A NAME="tex2html2482"
  HREF="node6.html#SECTION060751300000000000000">40.5.13 ESMF_ClockIsReverse</A>
<LI><A NAME="tex2html2483"
  HREF="node6.html#SECTION060751400000000000000">40.5.14 ESMF_ClockIsStopTime</A>
<LI><A NAME="tex2html2484"
  HREF="node6.html#SECTION060751500000000000000">40.5.15 ESMF_ClockIsStopTimeEnabled</A>
<LI><A NAME="tex2html2485"
  HREF="node6.html#SECTION060751600000000000000">40.5.16 ESMF_ClockPrint</A>
<LI><A NAME="tex2html2486"
  HREF="node6.html#SECTION060751700000000000000">40.5.17 ESMF_ClockSet</A>
<LI><A NAME="tex2html2487"
  HREF="node6.html#SECTION060751800000000000000">40.5.18 ESMF_ClockStopTimeDisable</A>
<LI><A NAME="tex2html2488"
  HREF="node6.html#SECTION060751900000000000000">40.5.19 ESMF_ClockStopTimeEnable</A>
<LI><A NAME="tex2html2489"
  HREF="node6.html#SECTION060752000000000000000">40.5.20 ESMF_ClockSyncToRealTime</A>
<LI><A NAME="tex2html2490"
  HREF="node6.html#SECTION060752100000000000000">40.5.21 ESMF_ClockValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2491"
  HREF="node6.html#SECTION06080000000000000000">41 Alarm Class</A>
<UL>
<LI><A NAME="tex2html2492"
  HREF="node6.html#SECTION06081000000000000000">41.1 Description</A>
<LI><A NAME="tex2html2493"
  HREF="node6.html#SECTION06082000000000000000">41.2 Constants</A>
<UL>
<LI><A NAME="tex2html2494"
  HREF="node6.html#SECTION06082100000000000000">41.2.1 ESMF_ALARMLIST</A>
</UL>
<LI><A NAME="tex2html2495"
  HREF="node6.html#SECTION06083000000000000000">41.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2496"
  HREF="node6.html#SECTION06083100000000000000">41.3.1 Clock initialization</A>
<LI><A NAME="tex2html2497"
  HREF="node6.html#SECTION06083200000000000000">41.3.2 Alarm initialization</A>
<LI><A NAME="tex2html2498"
  HREF="node6.html#SECTION06083300000000000000">41.3.3 Clock advance and Alarm processing</A>
<LI><A NAME="tex2html2499"
  HREF="node6.html#SECTION06083400000000000000">41.3.4 Alarm and Clock destruction</A>
</UL>
<LI><A NAME="tex2html2500"
  HREF="node6.html#SECTION06084000000000000000">41.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html2501"
  HREF="node6.html#SECTION06085000000000000000">41.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html2502"
  HREF="node6.html#SECTION06086000000000000000">41.6 Class API</A>
<UL>
<LI><A NAME="tex2html2503"
  HREF="node6.html#SECTION06086100000000000000">41.6.1 ESMF_AlarmAssignment(=)</A>
<LI><A NAME="tex2html2504"
  HREF="node6.html#SECTION06086200000000000000">41.6.2 ESMF_AlarmOperator(==)</A>
<LI><A NAME="tex2html2505"
  HREF="node6.html#SECTION06086300000000000000">41.6.3 ESMF_AlarmOperator(/=)</A>
<LI><A NAME="tex2html2506"
  HREF="node6.html#SECTION06086400000000000000">41.6.4 ESMF_AlarmCreate</A>
<LI><A NAME="tex2html2507"
  HREF="node6.html#SECTION06086500000000000000">41.6.5 ESMF_AlarmCreate</A>
<LI><A NAME="tex2html2508"
  HREF="node6.html#SECTION06086600000000000000">41.6.6 ESMF_AlarmDestroy</A>
<LI><A NAME="tex2html2509"
  HREF="node6.html#SECTION06086700000000000000">41.6.7 ESMF_AlarmDisable</A>
<LI><A NAME="tex2html2510"
  HREF="node6.html#SECTION06086800000000000000">41.6.8 ESMF_AlarmEnable</A>
<LI><A NAME="tex2html2511"
  HREF="node6.html#SECTION06086900000000000000">41.6.9 ESMF_AlarmGet</A>
<LI><A NAME="tex2html2512"
  HREF="node6.html#SECTION060861000000000000000">41.6.10 ESMF_AlarmIsEnabled</A>
<LI><A NAME="tex2html2513"
  HREF="node6.html#SECTION060861100000000000000">41.6.11 ESMF_AlarmIsRinging</A>
<LI><A NAME="tex2html2514"
  HREF="node6.html#SECTION060861200000000000000">41.6.12 ESMF_AlarmIsSticky</A>
<LI><A NAME="tex2html2515"
  HREF="node6.html#SECTION060861300000000000000">41.6.13 ESMF_AlarmNotSticky</A>
<LI><A NAME="tex2html2516"
  HREF="node6.html#SECTION060861400000000000000">41.6.14 ESMF_AlarmPrint</A>
<LI><A NAME="tex2html2517"
  HREF="node6.html#SECTION060861500000000000000">41.6.15 ESMF_AlarmRingerOff</A>
<LI><A NAME="tex2html2518"
  HREF="node6.html#SECTION060861600000000000000">41.6.16 ESMF_AlarmRingerOn</A>
<LI><A NAME="tex2html2519"
  HREF="node6.html#SECTION060861700000000000000">41.6.17 ESMF_AlarmSet</A>
<LI><A NAME="tex2html2520"
  HREF="node6.html#SECTION060861800000000000000">41.6.18 ESMF_AlarmSticky</A>
<LI><A NAME="tex2html2521"
  HREF="node6.html#SECTION060861900000000000000">41.6.19 ESMF_AlarmValidate</A>
<LI><A NAME="tex2html2522"
  HREF="node6.html#SECTION060862000000000000000">41.6.20 ESMF_AlarmWasPrevRinging</A>
<LI><A NAME="tex2html2523"
  HREF="node6.html#SECTION060862100000000000000">41.6.21 ESMF_AlarmWillRingNext</A>
</UL>
</UL>
<LI><A NAME="tex2html2524"
  HREF="node6.html#SECTION06090000000000000000">42 Config Class</A>
<UL>
<LI><A NAME="tex2html2525"
  HREF="node6.html#SECTION06091000000000000000">42.1 Description</A>
<UL>
<LI><A NAME="tex2html2526"
  HREF="node6.html#SECTION06091100000000000000">42.1.1 Package history</A>
<LI><A NAME="tex2html2527"
  HREF="node6.html#SECTION06091200000000000000">42.1.2 Resource files</A>
</UL>
<LI><A NAME="tex2html2528"
  HREF="node6.html#SECTION06092000000000000000">42.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2529"
  HREF="node6.html#SECTION06092100000000000000">42.2.1 Variable declarations</A>
<LI><A NAME="tex2html2530"
  HREF="node6.html#SECTION06092200000000000000">42.2.2 Creation of a Config</A>
<LI><A NAME="tex2html2531"
  HREF="node6.html#SECTION06092300000000000000">42.2.3 How to retrieve a label with a single value</A>
<LI><A NAME="tex2html2532"
  HREF="node6.html#SECTION06092400000000000000">42.2.4 How to retrieve a label with multiple values</A>
<LI><A NAME="tex2html2533"
  HREF="node6.html#SECTION06092500000000000000">42.2.5 How to retrieve a table</A>
<LI><A NAME="tex2html2534"
  HREF="node6.html#SECTION06092600000000000000">42.2.6 Destruction of a Config</A>
</UL>
<LI><A NAME="tex2html2535"
  HREF="node6.html#SECTION06093000000000000000">42.3 Class API</A>
<UL>
<LI><A NAME="tex2html2536"
  HREF="node6.html#SECTION06093100000000000000">42.3.1 ESMF_ConfigAssignment(=)</A>
<LI><A NAME="tex2html2537"
  HREF="node6.html#SECTION06093200000000000000">42.3.2 ESMF_ConfigCreate</A>
<LI><A NAME="tex2html2538"
  HREF="node6.html#SECTION06093300000000000000">42.3.3 ESMF_ConfigDestroy</A>
<LI><A NAME="tex2html2539"
  HREF="node6.html#SECTION06093400000000000000">42.3.4 ESMF_ConfigFindLabel</A>
<LI><A NAME="tex2html2540"
  HREF="node6.html#SECTION06093500000000000000">42.3.5 ESMF_ConfigGetAttribute</A>
<LI><A NAME="tex2html2541"
  HREF="node6.html#SECTION06093600000000000000">42.3.6 ESMF_ConfigGetAttribute</A>
<LI><A NAME="tex2html2542"
  HREF="node6.html#SECTION06093700000000000000">42.3.7 ESMF_ConfigGetChar</A>
<LI><A NAME="tex2html2543"
  HREF="node6.html#SECTION06093800000000000000">42.3.8 ESMF_ConfigGetDim</A>
<LI><A NAME="tex2html2544"
  HREF="node6.html#SECTION06093900000000000000">42.3.9 ESMF_ConfigGetLen</A>
<LI><A NAME="tex2html2545"
  HREF="node6.html#SECTION060931000000000000000">42.3.10 ESMF_ConfigLoadFile</A>
<LI><A NAME="tex2html2546"
  HREF="node6.html#SECTION060931100000000000000">42.3.11 ESMF_ConfigNextLine</A>
<LI><A NAME="tex2html2547"
  HREF="node6.html#SECTION060931200000000000000">42.3.12 ESMF_ConfigSetAttribute</A>
<LI><A NAME="tex2html2548"
  HREF="node6.html#SECTION060931300000000000000">42.3.13 ESMF_ConfigValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2549"
  HREF="node6.html#SECTION060100000000000000000">43 Log Class</A>
<UL>
<LI><A NAME="tex2html2550"
  HREF="node6.html#SECTION060101000000000000000">43.1 Description</A>
<LI><A NAME="tex2html2551"
  HREF="node6.html#SECTION060102000000000000000">43.2 Constants</A>
<UL>
<LI><A NAME="tex2html2552"
  HREF="node6.html#SECTION060102100000000000000">43.2.1 ESMF_LOGERR</A>
<LI><A NAME="tex2html2553"
  HREF="node6.html#SECTION060102200000000000000">43.2.2 ESMF_LOGKIND</A>
<LI><A NAME="tex2html2554"
  HREF="node6.html#SECTION060102300000000000000">43.2.3 ESMF_LOGMSG</A>
</UL>
<LI><A NAME="tex2html2555"
  HREF="node6.html#SECTION060103000000000000000">43.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2556"
  HREF="node6.html#SECTION060103100000000000000">43.3.1 Default Log</A>
<LI><A NAME="tex2html2557"
  HREF="node6.html#SECTION060103200000000000000">43.3.2 User created Log</A>
<LI><A NAME="tex2html2558"
  HREF="node6.html#SECTION060103300000000000000">43.3.3 Get and Set</A>
</UL>
<LI><A NAME="tex2html2559"
  HREF="node6.html#SECTION060104000000000000000">43.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html2560"
  HREF="node6.html#SECTION060105000000000000000">43.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html2561"
  HREF="node6.html#SECTION060106000000000000000">43.6 Object Model</A>
<LI><A NAME="tex2html2562"
  HREF="node6.html#SECTION060107000000000000000">43.7 Class API</A>
<UL>
<LI><A NAME="tex2html2563"
  HREF="node6.html#SECTION060107100000000000000">43.7.1 ESMF_LogAssignment(=)</A>
<LI><A NAME="tex2html2564"
  HREF="node6.html#SECTION060107200000000000000">43.7.2 ESMF_LogClose</A>
<LI><A NAME="tex2html2565"
  HREF="node6.html#SECTION060107300000000000000">43.7.3 ESMF_LogFlush</A>
<LI><A NAME="tex2html2566"
  HREF="node6.html#SECTION060107400000000000000">43.7.4 ESMF_LogFoundAllocError</A>
<LI><A NAME="tex2html2567"
  HREF="node6.html#SECTION060107500000000000000">43.7.5 ESMF_LogFoundDeallocError</A>
<LI><A NAME="tex2html2568"
  HREF="node6.html#SECTION060107600000000000000">43.7.6 ESMF_LogFoundError</A>
<LI><A NAME="tex2html2569"
  HREF="node6.html#SECTION060107700000000000000">43.7.7 ESMF_LogOpen</A>
<LI><A NAME="tex2html2570"
  HREF="node6.html#SECTION060107800000000000000">43.7.8 ESMF_LogSet</A>
<LI><A NAME="tex2html2571"
  HREF="node6.html#SECTION060107900000000000000">43.7.9 ESMF_LogSetError</A>
<LI><A NAME="tex2html2572"
  HREF="node6.html#SECTION0601071000000000000000">43.7.10 ESMF_LogWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html2573"
  HREF="node6.html#SECTION060110000000000000000">44 DELayout Class</A>
<UL>
<LI><A NAME="tex2html2574"
  HREF="node6.html#SECTION060111000000000000000">44.1 Description</A>
<LI><A NAME="tex2html2575"
  HREF="node6.html#SECTION060112000000000000000">44.2 Constants</A>
<UL>
<LI><A NAME="tex2html2576"
  HREF="node6.html#SECTION060112100000000000000">44.2.1 ESMF_PIN</A>
<LI><A NAME="tex2html2577"
  HREF="node6.html#SECTION060112200000000000000">44.2.2 ESMF_SERVICEREPLY</A>
</UL>
<LI><A NAME="tex2html2578"
  HREF="node6.html#SECTION060113000000000000000">44.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2579"
  HREF="node6.html#SECTION060113100000000000000">44.3.1 Default DELayout</A>
<LI><A NAME="tex2html2580"
  HREF="node6.html#SECTION060113200000000000000">44.3.2 DELayout with specified number of DEs</A>
<LI><A NAME="tex2html2581"
  HREF="node6.html#SECTION060113300000000000000">44.3.3 DELayout with computational and communication weights</A>
<LI><A NAME="tex2html2582"
  HREF="node6.html#SECTION060113400000000000000">44.3.4 DELayout from petMap</A>
<LI><A NAME="tex2html2583"
  HREF="node6.html#SECTION060113500000000000000">44.3.5 DELayout from petMap with multiple DEs per PET</A>
<LI><A NAME="tex2html2584"
  HREF="node6.html#SECTION060113600000000000000">44.3.6 Working with a DELayout - simple 1-to-1 DE to PET mapping</A>
<LI><A NAME="tex2html2585"
  HREF="node6.html#SECTION060113700000000000000">44.3.7 Working with a DELayout - general DE to PET mapping</A>
<LI><A NAME="tex2html2586"
  HREF="node6.html#SECTION060113800000000000000">44.3.8 Work queue dynamic load balancing</A>
</UL>
<LI><A NAME="tex2html2587"
  HREF="node6.html#SECTION060114000000000000000">44.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html2588"
  HREF="node6.html#SECTION060115000000000000000">44.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html2589"
  HREF="node6.html#SECTION060116000000000000000">44.6 Class API</A>
<UL>
<LI><A NAME="tex2html2590"
  HREF="node6.html#SECTION060116100000000000000">44.6.1 ESMF_DELayoutAssignment(=)</A>
<LI><A NAME="tex2html2591"
  HREF="node6.html#SECTION060116200000000000000">44.6.2 ESMF_DELayoutOperator(==)</A>
<LI><A NAME="tex2html2592"
  HREF="node6.html#SECTION060116300000000000000">44.6.3 ESMF_DELayoutOperator(/=)</A>
<LI><A NAME="tex2html2593"
  HREF="node6.html#SECTION060116400000000000000">44.6.4 ESMF_DELayoutCreate</A>
<LI><A NAME="tex2html2594"
  HREF="node6.html#SECTION060116500000000000000">44.6.5 ESMF_DELayoutCreate</A>
<LI><A NAME="tex2html2595"
  HREF="node6.html#SECTION060116600000000000000">44.6.6 ESMF_DELayoutDestroy</A>
<LI><A NAME="tex2html2596"
  HREF="node6.html#SECTION060116700000000000000">44.6.7 ESMF_DELayoutGet</A>
<LI><A NAME="tex2html2597"
  HREF="node6.html#SECTION060116800000000000000">44.6.8 ESMF_DELayoutPrint</A>
<LI><A NAME="tex2html2598"
  HREF="node6.html#SECTION060116900000000000000">44.6.9 ESMF_DELayoutServiceComplete</A>
<LI><A NAME="tex2html2599"
  HREF="node6.html#SECTION0601161000000000000000">44.6.10 ESMF_DELayoutServiceOffer</A>
<LI><A NAME="tex2html2600"
  HREF="node6.html#SECTION0601161100000000000000">44.6.11 ESMF_DELayoutValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2601"
  HREF="node6.html#SECTION060120000000000000000">45 VM Class</A>
<UL>
<LI><A NAME="tex2html2602"
  HREF="node6.html#SECTION060121000000000000000">45.1 Description</A>
<LI><A NAME="tex2html2603"
  HREF="node6.html#SECTION060122000000000000000">45.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2604"
  HREF="node6.html#SECTION060122100000000000000">45.2.1 Global VM</A>
<LI><A NAME="tex2html2605"
  HREF="node6.html#SECTION060122200000000000000">45.2.2 Getting the MPI Communicator from an VM object</A>
<LI><A NAME="tex2html2606"
  HREF="node6.html#SECTION060122300000000000000">45.2.3 Nesting ESMF inside a user MPI application</A>
<LI><A NAME="tex2html2607"
  HREF="node6.html#SECTION060122400000000000000">45.2.4 Nesting ESMF inside a user MPI application on a subset of MPI ranks</A>
<LI><A NAME="tex2html2608"
  HREF="node6.html#SECTION060122500000000000000">45.2.5 Send/Recv</A>
<LI><A NAME="tex2html2609"
  HREF="node6.html#SECTION060122600000000000000">45.2.6 Scatter and Gather</A>
<LI><A NAME="tex2html2610"
  HREF="node6.html#SECTION060122700000000000000">45.2.7 AllReduce and AllFullReduce</A>
<LI><A NAME="tex2html2611"
  HREF="node6.html#SECTION060122800000000000000">45.2.8 VM and Components</A>
</UL>
<LI><A NAME="tex2html2612"
  HREF="node6.html#SECTION060123000000000000000">45.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html2613"
  HREF="node6.html#SECTION060124000000000000000">45.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html2614"
  HREF="node6.html#SECTION060125000000000000000">45.5 Class API</A>
<UL>
<LI><A NAME="tex2html2615"
  HREF="node6.html#SECTION060125100000000000000">45.5.1 ESMF_VMAssignment(=)</A>
<LI><A NAME="tex2html2616"
  HREF="node6.html#SECTION060125200000000000000">45.5.2 ESMF_VMOperator(==)</A>
<LI><A NAME="tex2html2617"
  HREF="node6.html#SECTION060125300000000000000">45.5.3 ESMF_VMOperator(/=)</A>
<LI><A NAME="tex2html2618"
  HREF="node6.html#SECTION060125400000000000000">45.5.4 ESMF_VMAllFullReduce</A>
<LI><A NAME="tex2html2619"
  HREF="node6.html#SECTION060125500000000000000">45.5.5 ESMF_VMAllGather</A>
<LI><A NAME="tex2html2620"
  HREF="node6.html#SECTION060125600000000000000">45.5.6 ESMF_VMAllGatherV</A>
<LI><A NAME="tex2html2621"
  HREF="node6.html#SECTION060125700000000000000">45.5.7 ESMF_VMAllReduce</A>
<LI><A NAME="tex2html2622"
  HREF="node6.html#SECTION060125800000000000000">45.5.8 ESMF_VMAllToAllV</A>
<LI><A NAME="tex2html2623"
  HREF="node6.html#SECTION060125900000000000000">45.5.9 ESMF_VMBarrier</A>
<LI><A NAME="tex2html2624"
  HREF="node6.html#SECTION0601251000000000000000">45.5.10 ESMF_VMBroadcast</A>
<LI><A NAME="tex2html2625"
  HREF="node6.html#SECTION0601251100000000000000">45.5.11 ESMF_VMCommWait</A>
<LI><A NAME="tex2html2626"
  HREF="node6.html#SECTION0601251200000000000000">45.5.12 ESMF_VMCommWaitAll</A>
<LI><A NAME="tex2html2627"
  HREF="node6.html#SECTION0601251300000000000000">45.5.13 ESMF_VMGather</A>
<LI><A NAME="tex2html2628"
  HREF="node6.html#SECTION0601251400000000000000">45.5.14 ESMF_VMGatherV</A>
<LI><A NAME="tex2html2629"
  HREF="node6.html#SECTION0601251500000000000000">45.5.15 ESMF_VMGet</A>
<LI><A NAME="tex2html2630"
  HREF="node6.html#SECTION0601251600000000000000">45.5.16 ESMF_VMGet</A>
<LI><A NAME="tex2html2631"
  HREF="node6.html#SECTION0601251700000000000000">45.5.17 ESMF_VMGetGlobal</A>
<LI><A NAME="tex2html2632"
  HREF="node6.html#SECTION0601251800000000000000">45.5.18 ESMF_VMGetCurrent</A>
<LI><A NAME="tex2html2633"
  HREF="node6.html#SECTION0601251900000000000000">45.5.19 ESMF_VMPrint</A>
<LI><A NAME="tex2html2634"
  HREF="node6.html#SECTION0601252000000000000000">45.5.20 ESMF_VMRecv</A>
<LI><A NAME="tex2html2635"
  HREF="node6.html#SECTION0601252100000000000000">45.5.21 ESMF_VMReduce</A>
<LI><A NAME="tex2html2636"
  HREF="node6.html#SECTION0601252200000000000000">45.5.22 ESMF_VMScatter</A>
<LI><A NAME="tex2html2637"
  HREF="node6.html#SECTION0601252300000000000000">45.5.23 ESMF_VMScatterV</A>
<LI><A NAME="tex2html2638"
  HREF="node6.html#SECTION0601252400000000000000">45.5.24 ESMF_VMSend</A>
<LI><A NAME="tex2html2639"
  HREF="node6.html#SECTION0601252500000000000000">45.5.25 ESMF_VMSendRecv</A>
<LI><A NAME="tex2html2640"
  HREF="node6.html#SECTION0601252600000000000000">45.5.26 ESMF_VMValidate</A>
<LI><A NAME="tex2html2641"
  HREF="node6.html#SECTION0601252700000000000000">45.5.27 ESMF_VMWtime</A>
<LI><A NAME="tex2html2642"
  HREF="node6.html#SECTION0601252800000000000000">45.5.28 ESMF_VMWtimeDelay</A>
<LI><A NAME="tex2html2643"
  HREF="node6.html#SECTION0601252900000000000000">45.5.29 ESMF_VMWtimePrec</A>
</UL>
</UL>
<LI><A NAME="tex2html2644"
  HREF="node6.html#SECTION060130000000000000000">46 Fortran I/O and System Utilities</A>
<UL>
<LI><A NAME="tex2html2645"
  HREF="node6.html#SECTION060131000000000000000">46.1 Description</A>
<LI><A NAME="tex2html2646"
  HREF="node6.html#SECTION060132000000000000000">46.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2647"
  HREF="node6.html#SECTION060132100000000000000">46.2.1 Fortran unit number management</A>
<LI><A NAME="tex2html2648"
  HREF="node6.html#SECTION060132200000000000000">46.2.2 Flushing output</A>
</UL>
<LI><A NAME="tex2html2649"
  HREF="node6.html#SECTION060133000000000000000">46.3 Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html2650"
  HREF="node6.html#SECTION060133100000000000000">46.3.1 Fortran unit number management</A>
<LI><A NAME="tex2html2651"
  HREF="node6.html#SECTION060133200000000000000">46.3.2 Flushing output</A>
</UL>
<LI><A NAME="tex2html2652"
  HREF="node6.html#SECTION060134000000000000000">46.4 Utility API</A>
<UL>
<LI><A NAME="tex2html2653"
  HREF="node6.html#SECTION060134100000000000000">46.4.1 ESMF_UtilGetArg</A>
<LI><A NAME="tex2html2654"
  HREF="node6.html#SECTION060134200000000000000">46.4.2 ESMF_UtilGetArgC</A>
<LI><A NAME="tex2html2655"
  HREF="node6.html#SECTION060134300000000000000">46.4.3 ESMF_UtilGetArgIndex</A>
<LI><A NAME="tex2html2656"
  HREF="node6.html#SECTION060134400000000000000">46.4.4 ESMF_UtilIOUnitFlush</A>
<LI><A NAME="tex2html2657"
  HREF="node6.html#SECTION060134500000000000000">46.4.5 ESMF_UtilIOUnitGet</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION06000000000000000000">
5 Infrastructure:  Utilities</A>
</H1>

<P>

<P>

<P>

<H1><A NAME="SECTION06010000000000000000">
34 Overview of Infrastructure Utility Classes</A>
</H1>

<P>
The ESMF utilities are a set of tools for quickly assembling modeling applications.

<P>
The ESMF Attribute class enables models to be self-describing via metadata, which are instances of Attribute name-value pairs.

<P>
The Time Management Library provides utilities for time and time interval representation and calculation, and higher-level utilities that control model time stepping, via clocks, as well as alarming.

<P>
The ESMF Config class provides configuration management based on NASA DAO's Inpak package, a collection of methods for accessing files containing input parameters stored in an ASCII format.

<P>
The ESMF LogErr class consists of a variety of methods for writing error, warning, and informational messages to log files. A default Log is created during ESMF initialization. Other Logs can be created later in the code by the user.

<P>
The DELayout class provides a layer of abstraction on top of the Virtual Machine (VM) layer. DELayout does this by introducing DEs (Decomposition Elements) as logical resource units. The DELayout object keeps track of the relationship between its DEs and the resources of the associated VM object. A DELayout can be shaped by the user at creation time to best match the computational problem or other design criteria.

<P>
The ESMF VM (Virtual Machine) class is a generic representation of hardware and system software resources. There is exactly one VM object per ESMF Component, providing the execution environment for the Component code. The VM class handles all resource management tasks for the Component class and provides a description of the underlying configuration of the compute resources used by a Component.  In addition to resource description and management, the VM class offers the lowest level of ESMF communication methods.

<P>
The ESMF Fortran I/O utilities provide portable methods to access capabilities which are often implemented in different ways amongst different environments. Currently, two utility methods are implemented: one to find an unopened unit number, and one to flush an I/O buffer.

<P>

<P>

<P>

<H1><A NAME="SECTION06020000000000000000">
35 Attribute Class</A>
</H1>

<P>

<H2><A NAME="SECTION06021000000000000000">
35.1 Description</A>
</H2>

<P>
The ESMF Attribute class is a metadata utility that supports emerging standards 
in a flexible way.  The Attribute class is useful for documenting data 
provenance and encourages models to be more self describing.  Attributes can 
also be used to automate some aspects of model execution and coupling.

<P>
Metadata, which is data about data, is broken down into 
name-value pairs by the Attribute class.  Attributes can be attached at any 
level of the ESMF object hierarchy, and in some cases the Attributes of 
different ESMF objects can be linked together to form 
a corresponding Attribute hierarchy.  Attribute hierarchies are linked up
automatically for the most part, with the exception of links between Components 
and between a Component and a State.  Attribute hierarchies can also be 
unlinked, copied, and moved around as needed.

<P>
ESMF Attribute packages 
are used to aggregate, store, and output model metadata.  They can be 
nested inside each other to make larger organized packages, distributed across 
processors and updated at runtime, and expanded to suit specific needs.  The
ESMF-supplied  
Attribute packages are designed around accepted metadata conventions, such as: 
climate and forecast (CF) [<A
 HREF="node8.html#ref:cf">6</A>], ISO standards [<A
 HREF="node8.html#ref:iso">3</A>], and the METAFOR 
Common Information Model (CIM) [<A
 HREF="node8.html#ref:cim">4</A>].

<P>
Most of the ESMF deep objects can host Attributes, and   
every object that can hold individual Attributes can also hold
Attribute packages.  Attribute hierarchies are supported for a majority of
the Attribute bearing classes.  
More information on the various Attribute 
capabilities, and the classes for which they are supported appear in the
following sections.

<P>
Reading and writing Attribute XML files requires the Xerces C++ library, v3.1.0 
or better.  For more details, see the "ESMF Users Guide", "Building and 
Installing the ESMF, Third Party Libraries, Xerces".

<P>

<H3><A NAME="SECTION06021100000000000000">
35.1.1 The ESMF approach to Attributes</A>
</H3>

<P>
ESMF's approach to Attributes can be summarized as follows:

<P>

<UL>
<LI>Implement community standards where they exist.
</LI>
<LI>Associate Attributes with the ESMF object they describe. Currently, the following ESMF objects can have Attributes:
  
<UL>
<LI>CplComp
</LI>
<LI>GridComp
</LI>
<LI>State
</LI>
<LI>FieldBundle
</LI>
<LI>Field
</LI>
<LI>ArrayBundle
</LI>
<LI>Array
</LI>
<LI>Grid
</LI>
<LI>DistGrid
     
</LI>
</UL>
</LI>
<LI>Establish pre-defined Attribute packages (see Section <A HREF="node6.html#sec:AttPacks">35.2</A>) to make Attribute creation easier for the user.
</LI>
<LI>Allow for user-defined custom Attribute packages (see Section <A HREF="node6.html#sec:CustomAttPacks">35.2.7</A>).
</LI>
<LI>Enable the nesting of Attribute packages (see Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>) including Custom packages.
</LI>
<LI>Enable complex Attribute hierarchies (see Section <A HREF="node6.html#sec:AttHier">35.1.2</A>.
</LI>
<LI>Export Attributes in more than one format (see Section <A HREF="node6.html#sec:AttributeExports">35.4</A>).
</LI>
<LI>Ensure that all Attributes are consistent across the entire virtual machine of the object to which they are attached.
</LI>
</UL>

<P>

<H3><A NAME="SECTION06021200000000000000"></A>
<A NAME="sec:AttHier"></A>
<BR>
35.1.2 Attribute hierarchies
</H3>

<P>
Of the ESMF objects with Attributes, only some can link their Attributes together in an Attribute hierarchy.  These objects are:

<P>

<UL>
<LI>CplComp
</LI>
<LI>GridComp
</LI>
<LI>State
</LI>
<LI>FieldBundle
</LI>
<LI>Field
</LI>
<LI>ArrayBundle
</LI>
<LI>Array
</LI>
</UL>

<P>
Every ESMF deep object is given a <TT>root</TT> Attribute on creation.
These <TT>root</TT> Attributes serve as the attachment point for all metadata that 
is stored on a particular ESMF object, including all Attributes and
Attribute packages.  The <TT>root</TT> Attributes can also be connected together via 
the <TT>ESMF_AttributeLink()</TT> functionality.  This happens automatically in most 
cases, such as when a Field is added to a FieldBundle, and results
in the formation of an Attribute hierarchy which mirrors the structure 
of the underlying object hierarchy.  

<P>
When two Attribute hierarchies are linked together 
the objects are given read-only access to each other's Attributes.
To ensure consistency across a distributed system, 
there can only ever be one set of Attributes associated with each ESMF object.  
This implies that a copy operation on an ESMF object Attribute hierarchy <I>can</I> 
use a value copy for all Attributes which are owned by the object being copied, 
but <I>must</I> use a reference copy for all Attributes which the object can 
access (through links) but does NOT own. See section <A HREF="node6.html#sec:Att:Copy">35.8.6</A> for more
details on this concept.

<P>
The most common use for this hierarchy capability is for linking the Attributes 
of a Field to the FieldBundle which holds it, which is then linked to the 
State that is used to transport all of the data for a Component.  All of 
these links, with the exception of the link between the Component and the 
State, are automatically handled by ESMF. Additionally, the State will 
automatically set a <TT>VariableIntent</TT> Attribute for Field when that Field 
is added to the State.  <TT>VariableIntent</TT> will be set to either 
<TT>Export</TT> or <TT>Import</TT>.

<P>

<H2><A NAME="SECTION06022000000000000000">
35.2 Attribute Packages</A>
</H2>

<P>
<A NAME="sec:AttPacks"></A>
<P>
At this time, all ESMF objects which are enabled to contain Attributes can also contain Attribute packages, which are groupings of individual Attributes.  Every Attribute package is specified by a <B>convention</B> and a <B>purpose</B>, hereafter called <B>specifiers</B>, such as "CF" and "General" (see below).  These specifiers are used to validate ESMF Attribute packages against existing metadata conventions.  The user can choose to use an ESMF pre-defined Attribute package, specify their own Attribute package, or add customized Attributes to any of the ESMF pre-defined Attribute packages. Currently, the creation and setting of Attribute packages is quite involved, but future development with IO will allow for a more automated approach to populating Attribute packages from a file.  This is already possible via <TT>ESMF_AttributeRead()</TT> for the ESMF/ESG/CF Attribute packages supplied by ESMF, as well as for custom individual Attributes not in a package.

<P>
The standard Attribute packages supplied by ESMF exist for the following ESMF objects:

<P>

<UL>
<LI>CplComp
</LI>
<LI>GridComp
</LI>
<LI>State
</LI>
<LI>Field
</LI>
<LI>Array
</LI>
<LI>Grid
</LI>
</UL>

<P>
The packages described in this section are grouped by the ESMF object they apply to. The creation of custom attributes and custom attribute packages is also possible and is discussed in Section <A HREF="node6.html#sec:CustomAttPacks">35.2.7</A>. In some cases it is possible to nest custom packages on top of ESMF packages. Attribute package nesting is described separately in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.

<P>
Some Attributes come with a controlled vocabulary. A controlled vocabulary is a list of options that can be selected as the value of the attribute. The controlled vocabularies listed in this documentation represent those chosen by the community. They are not exhaustive and users may set these Attributes to a different value if they so choose. The primary consequence of doing so is that the resulting output may not be recognized by any of the online tools being developed with respect to this controlled vocabulary.  

<P>

<H3><A NAME="SECTION06022100000000000000"></A>
<A NAME="ComponentAttributePackages"></A>
<BR>
35.2.1 Component Attribute packages
</H3>

<P>
There are many attributes that are used to describe components. There are currently 3 predefined component-level Attribute packages, with sub-packages defined for the 2nd:

<P>

<OL>
<LI>Earth System Grid (ESG) Basic
</LI>
<LI>Common Information Model (CIM) Main
    
<OL>
<LI>Common Information Model (CIM) Platform
</LI>
<LI>International Organization for Standardization (ISO) Responsible Party
</LI>
<LI>International Organization for Standardization (ISO) Citation
    
</LI>
</OL>
</LI>
<LI>Common Information Model (CIM) Component Properties
</LI>
</OL>

<P>
<BR>
<BR>

<P>
<B>1. Earth System Grid (ESG) Basic Attribute Package</B>

<P>

<UL>
<LI>Convention: ESG or ESMF
</LI>
<LI>Purpose: General
</LI>
<LI>Output Options:
    
<UL>
<LI>Simple XML file. This requires the Xerces 3rd party library, see <A HREF="node6.html#Att:Xerces">35.8.7</A>
    
</LI>
</UL> 
</LI>
<LI>Description: This package contains several Attributes used to describe model components within the Earth System Grid (ESG) ontology. 
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Agency</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An administrative unit of government.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>DoD, DOE, DOI, NASA, NOAA, NSF</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Author</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The person who created the content of a book, article, or other source.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>CodingLanguage</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The computer language in which a unit of software is written.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>C, C++, F77, F90, Java</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ComponentLongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of a model, model component, simulation, experiment, or dataset with all acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ComponentShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A version of the component name that contains acronyms.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Discipline</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A subject, theme, category, or general area of interest.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Aerosol, Fisheries, Climate, Carbon Cycle, Hydrology, Land, Ocean, Polar, Sediment, Storm Surge, Turbulence, Weather, Wave, Weather Prediction</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Institution</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An organization associated with a model component, simulation, or dataset.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ModelComponentFramework</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software package or mechanism used to transfer and transform data between model components.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>CCA, ESMF, Flume, FMS, OASIS, SWMF</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>PhysicalDomain</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A description of the geographic range being simulated.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Atmosphere, Earth System, Ice, Lake, Land Ocean, River</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Version</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A specific form or variation of an artifact, i.e. a unit of software or metadata.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>2. Common Information Model (CIM) Main Attribute Package</B>

<P>

<UL>
<LI>Convention: CIM 1.5
</LI>
<LI>Purpose: Model Component Simulation Description
</LI>
<LI>Includes:
    
<UL>
<LI>CIM Platform
</LI>
<LI>ISO Responsible Party (1 or more - user specifiable)
</LI>
<LI>ISO Citation (1 or more - user specifiable)
    
</LI>
</UL>
</LI>
<LI>Output Options: 
    
<UL>
<LI>CIM XML
    
</LI>
</UL>  
</LI>
<LI>Description: The CIM is a formal model of the climate modeling process being developed by the European Union's <A NAME="tex2html45"
  HREF="http://metaforclimate.eu/">METAFOR</A>
project. "It includes descriptions of the experiments being undertaken, the simulations being run in support of these experiments, the software models and tools being used to implement the simulations and the data generated by the software." The CIM divides up the climate modeling process into 6 sections, listed below. The CIM also contains other standards. It is the primary metadata representation for the fifth Climate Model Intercomparison Project (CMIP5). ESMF is currently implementing only a subset of the CIM. The representation is expected to grow. The CIM Main Package contains several standalone properties used to describe components. It also serves as the anchor to which other CIM packages are nested. Presently, these additional CIM packages (described further below) can only be created if the CIM Main Package is created. In the future, these packages will be decoupled, so that users may select subsections of the CIM to create and use. This package nests three of the packages below within it; this is described in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.
    
<UL>
<LI>Shared: Contains those elements that are used in many different packages. 
</LI>
<LI>Quality: Contains elements used to express diverse quality metrics for CIM Metadata or for artifacts that the CIM metadata describes.
</LI>
<LI>Grids: Provides a complete description of the horizontal and vertical discretization of modeling elements. This may refer to grids that output data is mapped onto, software adheres to, as well as activity constraints. 
</LI>
<LI>Activity: Specifies the experimental design including the experimental requirements and description of how simulations conform to these requirements.
</LI>
<LI>Software: Specifies all the modeling software components used within the experiment process. 
</LI>
<LI>Data: Describes the data output from the climate modeling process as well as for input data. 
    
</LI>
</UL>
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Description</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A multi-line description of the component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>LongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A version of the component name with all acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MetadataVersion***</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The version number of the simulation metadata.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ModelType*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short string describing the discipline of a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Advection, Aerosol3D-Sources etc.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PreviousVersion**</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Name of the previous version of a model or model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PreviousVersionDescription**</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short note about the previous version of the model or model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ReleaseDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date a model component was issued.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ShortName*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A version of the component name that contains acronyms.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationDuration</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The length of time a simulation runs.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationEndDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date in simulated time of the end of a model simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationEnsembleID</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The reference name or number of the ensemble to which a simulation belongs.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationLongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of the simulation with any acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationNumberOfProcessingElements</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of PEs used in the simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationProjectName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A campaign, such as a model intercomparison project, that may involve multiple groups and experiments.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationRationale</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The reason for performing a simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of the simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationStartDate*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date in simulated time of the start of a model simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>URL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A URL associated with a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Version</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Version number of the component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
</TABLE>
<BR> * Attribute required to be set to produce valid CIM XML output. 
<BR> ** If PreviousVersionDescription is set, PreviousVersion must also be set, to produce valid CIM XML output. 
<BR> *** If not set, defaults to 1.0

<P>
<BR>
<BR>

<P>
<B>2.1. CIM Platform Attribute Package</B>

<P>

<UL>
<LI>Convention: CIM 1.5
</LI>
<LI>Purpose: Platform Description
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML 
    
</LI>
</UL> 
</LI>
<LI>Description: This package describes the platform a particular simulation is run on. It must be created in conjunction with the CIM Main Package (see above). This package is nested within the CIM Main Package (above); see the description in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>CompilerName**</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The brand of the software that takes source code and turns it into an executable.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Absoft, Default, Intel, Lahey, NAG, Pathscale, PGI, PGIGCC, XLF, XLFGCC</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>CompilerVersion**</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The specific configuration value of the software used to take source code and turn it into executable code.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineCoresPerProcessor</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of sub-divided elements or mini-chips on a computer chip.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineDescription</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short note about the machine.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineInterconnectType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The technology used to associate each node in a supercomputer with every other node.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Cray Interconnect, Fat Tree, Gigabit Ethernet, Infiniband, Mixed, Myrinet, Numalink, Quadrics, SP Switch</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineMaximumProcessors</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The highest number of computer chips on a computer system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineName*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name given to a computer by its system administrators. This is not the brand name of the system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineOperatingSystem</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software that is responsible for the management and coordination of activities and the sharing of resources of a computer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Aix, Darwin, Irix64, Linux, SUNOS, Unicos</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineProcessorType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of computer chip used in a particular computer platform.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Altix, AMD x86-64, Bluegene, G4, G5, Intel EM64T, Intel IA-64, Itanium, NEC, Opteron, Origin3800, Pentium 3, Pentium 4, SP, SPARC, X1, Xeon, XT3-4, ZX6000</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineSystem</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of computer system (e.g. vector, parallel, cluster, etc.).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Beowulf, Parallel, Vector</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>MachineVendor</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The brand name of a computer system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>ACS, Action, Appro International, Bull SA, Cray Inc, Dalco AG Switzerland, Dawning, Dell, Fujitsu, Hitachi, HP, IMB, Intel, Koi Computers, Lenovo, Mac, NEC, NEC SUN, NUDT, PC, Pyramid Computer, Raytheon-Aspen Systems, Self Made, SGI, Sun Microsystems, T-platorms</TD>
</TR>
</TABLE>
<BR>* Attribute required to be set to produce valid CIM XML output. 
<BR>** Both CompilerName and CompilerVersion are required to be set, or else neither one, to produce valid CIM XML output; setting one without the other will produce invalid CIM XML output. 
<BR>
<P>
<BR>
<BR>

<P>
<B>2.2. ISO Responsible Party Attribute Package</B>

<P>

<UL>
<LI>Convention: ISO 19115
</LI>
<LI>Purpose: Responsible Party Description
</LI>
<LI>Output Options: 
    
<UL>
<LI>CIM XML 
    
</LI>
</UL> 
</LI>
<LI>Description: This package is used to describe contacts, authors, institutions, and funding agencies. This package is nested, with one or more user-specifiable instances, within the CIM Main Package(above); see the description in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.
</LI>
<LI>Usage: The Responsible Party package is unique in that the user should first select the type of Responsible Party they wish to define. This is done via the ResponsiblePartyRole attribute within the package. Then the package's main value is set using the Name attribute.  
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Abbreviation</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The abbreviation of an individual or organization associated with a model component or simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>EmailAddress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The email address that others can use to ask questions about a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Name</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of an author, contact, funder, centre, or principal investigator.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>NameType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of entity that Name references.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Individual, Organization, Position</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>PhysicalAddress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The address of the person designated to provide information about a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ResponsiblePartyRole*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A flag to define the role of the Responsible Party.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Author, PI, Contact, Center, Funder</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>URL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A URL of an individual or organization.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
</TABLE>
<BR>* Attribute required to be set, when any other attributes in this package are set, to produce valid CIM XML output. It is valid to set none of the attributes in this package. In that case, no corresponding CIM XML output will appear for that Responsible Party package instance, although there may be other populated instances, which, because they have attributes set, will appear in the output. 
<BR>
<P>
<B>2.3. ISO Citation Attribute Package</B>

<P>

<UL>
<LI>Convention: ISO 19115
</LI>
<LI>Purpose: Citation Description
</LI>
<LI>Output Options: 
    
<UL>
<LI>CIM XML 
    
</LI>
</UL> 
</LI>
<LI>Description: This package is used to describe references. Examples include a URL or a scientific reference.  This package is nested, with one or more user-specifiable instances, within the CIM Main Package (above); see the description in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Date*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date of the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>DOI</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The assigned Digital Object Identifier (DOI) of the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>LongTitle</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The text of the citation or pointer (e.g. URL) that further describes a model component or simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>PresentationForm</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A description of the type of citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>documentDigital, documentHardcopy, imageDigital, imageHardcopy, mapDigital, mapHardcopy, modelDigital, modelHardcopy, profileDigital, profileHardcopy, tableDigital, tableHardcopy, videoDigital, videoHardcopy</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ShortTitle*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An abbreviation for the citation.  This could be the short scientific citation (e.g. Murphy, 2009) or the title of a web page.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>URL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Website associated with the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
</TABLE>
<BR>* Attribute required to be set, when any other attributes in this package are set, to produce valid CIM XML output. It is valid to set none of the attributes in this package. In that case, no corresponding CIM XML output will appear for that Citation package instance, although there may be other populated instances, which, because they have attributes set, will appear in the output. 
<BR>
<P>
<BR>
<BR>

<P>
<B>3. Common Information Model (CIM) Component Properties Package</B>

<P>

<UL>
<LI>Convention: CIM 1.5
</LI>
<LI>Purpose: General Component Properties Description
</LI>
<LI>Output Options: 
    
<UL>
<LI>CIM XML
    
</LI>
</UL>  
</LI>
<LI>Description: This package is used to specify any number of user-defined attributes of a component and have them output in valid CIM XML format.  This differs from a custom attribute package (see Section <A HREF="node6.html#sec:CustomAttPacks">35.2.7</A>) in that this package has a standard convention and purpose, which is used to control the output of the user-defined attributes in standard CIM XML format.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>&lt;User-defined name&gt;</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>&lt;User-defined definition&gt;.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>...</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>...</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022200000000000000"></A>
<A NAME="StateAttributePackages"></A>
<BR>
35.2.2 State Attribute packages
</H3>

<P>
There is currently only 1 predefined State-level Attribute package:

<P>

<OL>
<LI>ESMF Basic
</LI>
</OL>

<P>
<BR>
<BR>
<B>1. ESMF Basic State Attribute Package</B>

<P>

<UL>
<LI>Convention: ESMF
</LI>
<LI>Purpose: General
</LI>
<LI>Output Options:
    
<UL>
<LI>Tab-delimited
</LI>
<LI>Simple XML 
    
</LI>
</UL>
</LI>
<LI>Description: This package is used to define whether an ESMF State object is an Import State or Export State.   
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Intent</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An indication of whether a state is imported into or exported from a particular model component. This refers to coupling, and not history output.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Export,Import</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022300000000000000"></A>
<A NAME="FieldAttributePackages"></A>
<BR>
35.2.3 Field Attribute packages
</H3>

<P>
Several standards exist to describe fields. There are currently 4 predefined Field-level Attribute packages:

<P>

<OL>
<LI>Common Information Model (CIM) Inputs
</LI>
<LI>Earth System Grid General
</LI>
<LI>Climate Forecast (CF) Convention Extended
</LI>
<LI>Climate Forecast (CF) Convention General
</LI>
</OL>

<P>
<BR>
<BR>

<P>
<B>1. Common Information Model (CIM) Inputs</B>

<P>

<UL>
<LI>Convention: CIM 1.5
</LI>
<LI>Purpose: Inputs Description
</LI>
<LI>Includes: 
    
<UL>
<LI>ESG (or ESMF) General
</LI>
<LI>CF Extended
</LI>
<LI>CF General
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>CIM XML 
    
</LI>
</UL>
</LI>
<LI>Description: This package is used to describe a simulation and the input (initial and boundary) conditions used in that simulation. It is also used to describe any ancillary data sets that contain input condition variables. This package should not be used to describe the variables in an unconfigured model component. A pre-defined Attribute package for that case will be implemented in a future release of ESMF.  This package nests the ESG (or ESMF) General, CF Extended, and CF General Field packages (below) within it; this is described in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.  The attribute values within these ESG and CF nested packages currently appear in the Component Properties section of the CIM output file.  A separate Component Properties package may be developed for this purpose in a future ESMF release.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>CouplingPurpose*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The form of the input condition (e.g. initial condition or boundary condition).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Ancillary, Boundary, Initial</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>CouplingSource*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The component the input condition is coming from.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>CouplingTarget*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The component the input condition is going to.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>Description</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A multi-line description of the input.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>Frequency</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The frequency (e.g. 2 months or 5 days) that a field from one component is input to another.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>n Seconds, n Minutes, n Hours, n Days, n Months, n Years, n Decades, n Centuries</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SpatialRegriddingMethod</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Method used to interpolate a field from one grid (source grid) to another (target grid).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Linear, Near-Neighbor, Cubic, Conservative-First-Order, Conservative-Second-Order, Conservative, Non-Conservative</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>SpatialRegriddingDimension</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Dimension of the regridding method.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>1D, 2D, 3D</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>Technique</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software package or mechanism used to transfer and transform data between model components.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>CCSM Flux Coupler, ESMF, Files, FMS, MCT, OASIS3, Shared</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=170><TT>TimeTransformationType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Temporal transformation performed on the input field before or after regridding onto the target grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=85>Exact, None, Time Accumulation, Time Average, Time Interpolation</TD>
</TR>
</TABLE>
<BR>* Attribute required to be set, when any other attributes in this package are set, to produce valid CIM XML output. It is valid to set none of the attributes in this package. In that case, no corresponding CIM XML output will appear for that Inputs package. 
<BR>
<P>
<BR>
<BR>

<P>
<B>2. Earth System Grid (ESG) Field</B>

<P>

<UL>
<LI>Convention: ESG or ESMF
</LI>
<LI>Purpose : General
</LI>
<LI>Includes: 
    
<UL>
<LI>CF Extended
</LI>
<LI>CF General
    
</LI>
</UL>
</LI>
<LI>Output Options: 
    
<UL>
<LI>Tab-delimited
</LI>
<LI>Simple XML
</LI>
<LI>CIM XML (when part of the CIM Inputs package)
    
</LI>
</UL>
</LI>
<LI>Description: ESG has the ability to list variables as either import or export variables. This should not be confused with the ESMF State Attribute Package, which has similiar attributes. This attribute is assigned to individual variables.   This package nests the CF Extended and CF General packages (below) within it; this is described in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Intent</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An indication of whether a variable is exported or imported. This refers to coupling and not history output.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Export,Import</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>3. Climate Forecast (CF) Convention Extended</B>

<P>

<UL>
<LI>Convention: CF
</LI>
<LI>Purpose: Extended
</LI>
<LI>Includes: 
    
<UL>
<LI>CF General
    
</LI>
</UL>
</LI>
<LI>Output Options: 
    
<UL>
<LI>Tab-delimited
</LI>
<LI>Simple XML
</LI>
<LI>CIM XML (when part of the CIM Inputs package)
    
</LI>
</UL> 
</LI>
<LI>Description: The CF standard for fields contains an optional standard_name Attribute. Standard names are controlled vocabularies and not every variable in the earth system sciences contains a standard name. Because of this, ESMF implemented this optional Attribute in its own package. This package nests the CF General package (below) within it; this is described in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>StandardName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The approved CF standard name for a variable if it exists.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>4. Climate Forecast (CF) Convention General</B>

<P>

<UL>
<LI>Convention: CF
</LI>
<LI>Purpose: General
</LI>
<LI>Output Options:
    
<UL>
<LI>Tab-delimited
</LI>
<LI>Simple XML
</LI>
<LI>CIM XML (when part of the CIM Inputs package)
    
</LI>
</UL> 
</LI>
<LI>Description: The climate and forecast (CF) convention contains metadata that is designed to promote the processing and sharing of files created with the NetCDF API. The CF conventions are increasingly gaining acceptance and have been adopted by a number of projects and groups as a primary standard. The conventions define metadata that provide a definitive description of what the data in each variable represents, and the spatial and temporal properties of the data. This enables users of data from different sources to decide which quantities are comparable, and facilitates building applications with powerful extraction, regridding, and display capabilities. The ESMF CF Attribute package contains the three mandatory Attributes required to describe fields. 
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name </B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>LongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An ad-hoc long descriptive name which may, for example, be used for labeling plots</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>ShortName*</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The short_name is technically not part of the CF stanard but is commonly the name of the variable on the output file and so is
 distinct from the long_name</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>Units</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The value of the units attribute is a string that can be recognized by UNIDATA's Udunits package</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
</TABLE>
<BR>* Attribute required to be set, if any attributes are set within this package, the CF/Extended, or ESMF/General package, to produce valid CIM XML output. It is valid to set none of the attributes in this package, the CF/Extended, or ESMF/General package, in which case no field CIM output will be produced. 
<BR>
<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022400000000000000"></A>
<A NAME="ArrayAttributePackages"></A>
<BR>
35.2.4 Array Attribute packages
</H3>

<P>
At this time the Array packages are the same as the Field packages.

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022500000000000000"></A>
<A NAME="GridAttributePackages"></A>
<BR>
35.2.5 Grid Attribute packages
</H3>

<P>
There are 2 grid attribute packages in ESMF. 

<P>

<OL>
<LI>GFDL Gridspec
</LI>
<LI>ESMF Grid
</LI>
</OL>

<P>
<BR>
<BR>

<P>
<B>1. Gridspec</B>

<P>
<A NAME="CIMGridAttributePackage"></A>
<P>

<UL>
<LI>Convention: GridSpec
</LI>
<LI>Purpose: General
</LI>
<LI>Output Options:
    
<UL>
<LI>Simple XML
</LI>
<LI>If combined with the ESMF Grid package, this package can be used to create a Grid object by reading in an XML file with these attributes. This is currently limited to 2D regularly distributed rectinlinear grids. See Section <A HREF="node5.html#example:GridCrFromFile">27.3.24</A> for details. 
    
</LI>
</UL>
</LI>
<LI>Description: This package contains the Attributes developed as part of GFDL's Gridspec standard.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>CongruentTiles</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates whether or not all the tiles contained within a grid mosaic are of the same size and shape.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>True, False</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>DimensionOrder</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The order in which latitude and longitude appear within the two dimensional grid array.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>DiscretizationType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Specifies the method by which a two-dimensional coordinate system is sampled to form a computational grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Logically rectangular, Pixel-based catchment, Structured triangular, Unstructured triangular</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>GeometryType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates the geometric figure used to approximate the shape of the Earth, e.g. "sphere".</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Ellipsoid, Plane, Sphere</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>GridType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A text description of the grid that uses common terminology.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>Gnomonic,Cubed Sphere,Displaced Pole, Icosahedral geodesic, Reduced gaussian, Regular lat lon, Spectral gaussian, Tripolar, Yin Yang</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>HorizontalResolution</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of points within the horizontal domain of a model or grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>IsConformal</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates if the grid tile is angle-preserving. If so, angles measured on the grid are equal to the equivalent angles on the Earth.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>True, False</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>IsRegular</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates whether or not the horizontal coordinates of the grid can be defined using 1D arrays (vectors). This means that grid node locations are defined by the cartesian product of the X/Lon and Y/Lat coordinate vectors. It also means that grid cells are logically rectangular (they may also be physically rectangular in the case of projected coordinates).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>True, False</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>IsUniform</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates whether or not the horizontal coordinates of a grid have fixed offsets in the X and Y directions. If the offset is the same in both directions then the grid is logically square, otherwise it is logically rectangular.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>True, False</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>NorthPoleLocation</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Defines the lat-long position of the 'north pole' used by the grid tile in the case of rotated/displaced pole grids.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>NumberOfCells</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of cells in an unstructured grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>NumberOfGridTiles</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of tiles in a mosaic.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>NX</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Specifies the length of the X, or longitude, dimension of the grid tile.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>NY</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Specifies the length of the Y, or latitude, dimension of the grid tile.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>
<B>2. ESMF Grid</B>

<P>
<A NAME="ESMFGridAttributePackage"></A>
<P>

<UL>
<LI>Convention: ESMF
</LI>
<LI>Purpose: General
</LI>
<LI>Includes: 
    
<UL>
<LI>GridSpec General
    
</LI>
</UL>
</LI>
<LI>Output Options:
    
<UL>
<LI>Simple XML
</LI>
<LI>If combined with the Gridspec Package, this package can be used to create a Grid object by reading in an XML file with these attributes. This is currently limited to 2D regularly distributed logically-rectangular grids. See Section <A HREF="node5.html#example:GridCrFromFile">27.3.24</A> for details. 
    
</LI>
</UL>
</LI>
<LI>Description: This package contains two Attributes required by ESMF to generate grids from a file. They describe the decomposition of a grid across ESMF DEs.  This package nests the GridSpec General package (above) within it; this is described in Section <A HREF="node6.html#sec:AttPackNesting">35.3</A>.
</LI>
</UL>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113><B>Controlled Vocabulary</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>RegDecompX</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of DEs in X a particular grid is decomposed into.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><TT>RegDecompY</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of DEs in Y a particular grid is decomposed into.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=113>N/A</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022600000000000000">
35.2.6 Table of available Attributes</A>
</H3>

<P>
The following is an alphabetical list of all the attributes implemented in ESMF, their definitions, and which packages they are contained within. 

<P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><B>Name</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142><B>Definition</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57><B>Attribute Package</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Agency</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An administrative unit of government.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESG Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CodingLanguage</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The computer language in which a unit of software is written.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESG Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CompilerName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The brand of the software that takes source code and turns it into an executable.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CompilerVersion</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The specific configuration value of the software used to take source code and turn it into executable code.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CouplingPurpose</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The form of the input condition (e.g. initial condition or boundary condition).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CouplingSource</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The component the input condition is coming from.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>CouplingTarget</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The component the input condition is going to.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Description</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A multi-line description of a component or input.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main, CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Date</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date of the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>DimensionOrder</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The order in which latitude and longitude appear within the two dimensional grid array.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>DiscretizationType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Specifies the method by which a two-dimensional coordinate system is sampled to form a computational grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>DOI</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The assigned Digital Object Identifier (DOI) of the citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>EmailAddress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The email address that others can use to ask questions about a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Frequency</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The frequency (e.g. months, days) that a field from one component is input to another.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>FullName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of a model, model component, simulation, experiment, or dataset with all acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESG Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>GeometryType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates the geometric figure used to approximate the shape of the Earth, e.g. "sphere".</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>GridType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A text description of the grid that uses common terminology.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>IsConformal</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates if the grid tile is angle-preserving. If so, angles measured on the grid are equal to the equivalent angles on the Earth.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>IsRegular</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates whether or not the horizontal coordinates of the grid can be defined using 1D arrays (vectors). This means that grid node locations are defined by the cartesian product of the X/Lon and Y/Lat coordinate vectors. It also means that grid cells are logically rectangular (they may also be physically rectangular in the case of projected coordinates).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Institution</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An organization associated with a model component, simulation, or dataset.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESG Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Intent</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An indication of whether a field or state is imported into or exported from a particular model component. This refers to coupling, and not history output.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESMF State, ESMF Field</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>IsUniform</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Indicates whether or not the horizontal coordinates of a grid have fixed offsets in the X and Y directions. If the offset is the same in both directions then the grid is logically square, otherwise it is logically rectangular.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>LongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of an object with all acronyms spelled out. For fields, it is an ad-hoc long descriptive name which may, for example, be used for labeling plots.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main, CF General</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>LongTitle</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The text of the citation or pointer (e.g. URL) that further describes a model component or simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineCoresPerProcessor</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of sub-divided elements or mini-chips on a computer chip.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineDescription</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short note about the machine.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineInterconnectType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The technology used to associate each node in a supercomputer with every other node.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineMaximumProcessors</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The highest number of computer chips on a computer system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name given to a computer by its system administrators. This is not the brand name of the system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineOperatingSystem</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software that is responsible for the management and coordination of activities and the sharing of resources of a computer.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineProcessorType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of computer chip used in a particular computer platform.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineSystem</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of computer system (e.g. vector, parallel, cluster, etc.).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MachineVendor</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The brand name of a computer system.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Platform</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>MetadataVersion</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The version number of the simulation metadata.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ModelComponentFramework</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software package or mechanism used to transfer and transform data between model components.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESG Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ModelType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short string describing the discipline of a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Name</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of an author, contact, funder, centre, or principal investigator.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>NameType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The type of entity that Name references.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>NorthPoleLocation</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Defines the lat-long position of the 'north pole' used by the grid tile in the case of rotated/displaced pole grids.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>NumberOfCells</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of cells in an unstructured grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>NX</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Specifies the length of the X, or longitude, dimension of the grid tile.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>NY</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Specifies the length of the Y, or latitude, dimension of the grid tile.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>Gridspec</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PhysicalAddress</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The address of the person designated to provide information about a model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PhysicalDomain</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A description of the geographic range being simulated.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESG Basic Component</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PresentationForm</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A description of the type of citation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PreviousVersion</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Name of the previous version of a model or model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>PreviousVersionDescription</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A short note about the previous version of the model or model component.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ReleaseDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The year a model component was issued.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>RegDecompX</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of DEs in X a particular grid is decomposed into.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESMF Grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>RegDecompY</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of DEs in Y a particular grid is decomposed into.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ESMF Grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ResponsiblePartyRole</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A flag to define the role of the Responsible Party.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Responsible Party</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>For component: a version of the component name that contains acronyms.  For field:  The short_name is technically not part of the CF stanard but is commonly the name of the variable on the output file and so is distinct from the long_name.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main, CF General</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>ShortTitle</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>An abbreviation for the citation.  This could be the short scientific citation (e.g. Murphy, 2009) or the title of a web page.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationDuration</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The length of time a simulation runs.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationEndDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date in simulated time of the end of a model simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationEnsembleID</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The reference name or number of the ensemble to which a simulation belongs.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationLongName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of the simulation with any acronyms spelled out.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationNumberOfProcessingElements</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The number of PEs used in the simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationProjectName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A campaign, such as a model intercomparison project, that may involve multiple groups and experiments.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationRationale</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The reason for performing a simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationStartDate</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The date in simulated time of the start of a model simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SimulationShortName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The name of the simulation.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SpatialRegriddingMethod</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Method used to interpolate a field from one grid (source grid) to another (target grid).</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>SpatialRegriddingDimension</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Dimension of the regridding method.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>StandardName</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The approved CF standard name for a variable if it exists.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CF Extended</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>TimeTransformationType</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>Temporal transformation performed on the input field before or after regridding onto the target grid.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Technique</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The software package or mechanism used to transfer and transform data between model components.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Inputs</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>URL</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>URL of the object being described. Exists in multple packages.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main, ISO Responsible Party, ISO Citation</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Units</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>The value of the units attribute is a string that can be recognized by UNIDATA's Udunits package.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CF General</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=198><TT>Version</TT></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=142>A specific form or variation of an artifact i.e. a unit of software or metadata.</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=57>CIM Main, ESG Basic Component</TD>
</TR>
</TABLE>

<P>
<BR>
<BR>

<P>

<H3><A NAME="SECTION06022700000000000000"></A>
<A NAME="sec:CustomAttPacks"></A>
<BR>
35.2.7 Custom Attribute packages
</H3>

<P>
ESMF allows for the creation of custom attribute packages, each of which has a user-defined convention and purpose, as well as a set of user-defined attributes. This can be done to augment one of the pre-defined packages (via package nesting <A HREF="node6.html#sec:AttPackNesting">35.3</A>) or to create a suite of attributes unique to the user. Examples of how to create such custom packages are contained in Sections <A HREF="node6.html#ex:AttributePackageEx">35.6.2</A> and <A HREF="node6.html#ex:AttributeCustPackEx">35.6.3</A>.

<P>

<H2><A NAME="SECTION06023000000000000000">
35.3 Attribute Packages Nesting</A>
</H2>

<P>
<A NAME="sec:AttPackNesting"></A>
<P>
Nesting is a way of creating larger Attribute packages out of smaller ones and allows users to add the attributes they want to an existing package. It is very useful when combining a custom package with a pre-defined package. One or more child Attribute packages can be nested within a parent package, and this can be repeated multiple times, allowing a full Attribute tree (hierarchical) structure to be created.  Breaking Attributes up into smaller packages that are then nested also allows for the construction of complex attribute trees where certain structures repeat themselves, allowing for Attribute package reusability.

<P>
Several of the ESMF pre-defined packages, when added to an ESMF object, are created with nested packages:

<P>
CIM Main - Component package - is a nest with three child packages:

<OL>
<LI>CIM Platform
</LI>
<LI>CIM Responsible Party (one or more - user specifiable)
</LI>
<LI>CIM Citation (one or more - user specifiable)
</LI>
</OL>

<P>
CIM Inputs - Field package - is a nest with one child package:

<OL>
<LI>ESG (or ESMF) General (with CF Extended and CF General packages nested within it)
</LI>
</OL>

<P>
ESG (or ESMF) General - Field package - is a nest with one child package:

<OL>
<LI>CF Extended (with a CF General package nested within it)
</LI>
</OL>

<P>
CF Extended - Field package - is a nest with one child package:

<OL>
<LI>CF General
</LI>
</OL>

<P>
ESMF General - Grid package - is a nest with one child package:

<OL>
<LI>GridSpec General
</LI>
</OL>

<P>
An explanation of the Attribute packages specifiers is in order at this point.  The purpose specifier is really just meant as an additional means, beyond the use of "convention", to specify Attribute packages.  One could imagine that the CF convention would want to be able to have Attribute packages divided up in some fashion, which ESMF could then keep track of with the purpose specifier.  It was added with the intention of allowing Attributes, and packages, maximum flexibility.  Take the Field's ESMF standard Attribute package for example.  This package is made up of three nested Attribute packages.  The lowest one is made up of three Attributes with convention=CF and purpose=General.  The next level contains one Attribute with convention=CF but purpose=Extended.  On top of this is the convention=ESG package, also with purpose=General.

<P>

<H2><A NAME="SECTION06024000000000000000">
35.4 Export Formats</A>
</H2>

<P>
<A NAME="sec:AttributeExports"></A>
<P>
The <TT>ESMF_AttributeWrite()</TT> interface is used to write the contents of an Attribute package to a file.  This routine can be called on any ESMF object that is capable of holding Attribute packages.  It can also write out all Attributes in Attribute packages with the same specifiers throughout an entire ESMF object hierarchy. 

<P>
There are three primary ways of exporting Attributes:

<OL>
<LI>Tab-delimited ASCII
</LI>
<LI>Simple XML 
</LI>
<LI>CIM XML
</LI>
</OL>

<P>
The flag that is used in the <TT>ESMF_AttributeWrite()</TT> interface to determine which format for writing the Attribute packages is called the <TT>ESMF_AttWriteFlag</TT>, with values as described below.  The resulting file will be placed in the execution directory after it is written and closed.

<P>

<H3><A NAME="SECTION06024100000000000000">
35.4.1 Tab-delimited ASCII</A>
</H3>

<P>
When <TT>ESMF_AttWriteFlag</TT> is set to <TT>ESMF_ATTWRITE_TAB</TT> (the default), a tab-delimited ascii file containing name-value pairs of attributes in the packages will be written.  The file will be named for the name of the ESMF object from which <TT>ESMF_AttributeWrite()</TT> is called. The suffix will be .stdout.

<P>

<H3><A NAME="SECTION06024200000000000000">
35.4.2 Simple XML</A>
</H3>

<P>
When <TT>ESMF_AttWriteFlag</TT> is set to <TT>ESMF_ATTWRITE_XML</TT>, an XML file containing name-value pairs of attributes in the packages will be written.  The file will be named for the name of the ESMF object from which <TT>ESMF_AttributeWrite()</TT> is called. The suffix will be .xml.

<P>

<H3><A NAME="SECTION06024300000000000000">
35.4.3 CIM XML</A>
</H3>

<P>
When the ESMF object from which <TT>ESMF_AttributeWrite()</TT> is called is a Component, and the Attribute package convention="CIM 1.5", and the purpose="Model Component Simulation Description", and <TT>ESMF_AttWriteFlag</TT> is set to <TT>ESMF_ATTWRITE_XML</TT>, an XML file conforming to the CIM standard will be written.  The file will contain Attributes from the entire Component tree and their contained Fields.  The file will be named for the name of the ESMF Component object from which <TT>ESMF_AttributeWrite()</TT> is called, and the suffix will be .xml.


<P>

<H2><A NAME="SECTION06025000000000000000">
35.5 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION06025100000000000000"></A>
<A NAME="const:attgetcount"></A>
<BR>
35.5.1 ESMF_ATTGETCOUNT
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Indicates whether or not to descend the Attribute hierarchy for the present operation.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AttGetCountFlag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ATTGETCOUNT_ATTRIBUTE</STRONG></DT>
<DD>This option will allow the routine to return the number of single Attributes.
	
</DD>
<DT><STRONG>ESMF_ATTGETCOUNT_ATTPACK</STRONG></DT>
<DD>This option will allow the routine to return the number of Attribute packages.
	
</DD>
<DT><STRONG>ESMF_ATTGETCOUNT_ATTLINK</STRONG></DT>
<DD>This option will allow the routine to return the number of Attribute links.
	
</DD>
<DT><STRONG>ESMF_ATTGETCOUNT_TOTAL</STRONG></DT>
<DD>This option will allow the routine to return the total number of Attributes.
</DD>
</DL>

<P>

<H3><A NAME="SECTION06025200000000000000"></A>
<A NAME="const:atttree"></A>
<BR>
35.5.2 ESMF_ATTTREE
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Indicates whether or not to descend the Attribute hierarchy for the present operation.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AttTreeFlag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ATTTREE_OFF</STRONG></DT>
<DD>This option will allow the routine to only descend the first base level of the Attribute hierarchy.
	
</DD>
<DT><STRONG>ESMF_ATTTREE_ON</STRONG></DT>
<DD>This option will allow the routine to descend the entire Attribute hierarchy.
</DD>
</DL>

<P>

<H3><A NAME="SECTION06025300000000000000"></A>
<A NAME="const:attwrite"></A>
<BR>
35.5.3 ESMF_ATTWRITE
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Indicates which file format to use in the write operation.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AttWriteFlag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ATTWRITE_XML</STRONG></DT>
<DD>This option will allow the routine to write in xml format.
	
</DD>
<DT><STRONG>ESMF_ATTWRITE_TAB</STRONG></DT>
<DD>This option will allow the routine to write in tab-delimited format.
</DD>
</DL>

<P>

<H2><A NAME="SECTION06026000000000000000">
35.6 Use and Examples</A>
</H2>

<P>
This section describes the use of the Attribute class.  There are eight 
examples that follow, which outline the use of Attributes at three increasing 
levels of difficulty.  The first example covers basic Attribute manipulations 
on the gridded Component.  The second example covers the Attribute package 
capabilities, including Attribute package nesting and Attribute hierarchy 
linking.  The third example covers Attribute management in a distributed 
environment and the I/O utilities.  These examples will be best understood if 
followed in an ascending order from basic to advanced.  The fourth example 
shows how to use the CIM Attribute packages.  The last four examples cover 
setting of Attribute packages and custom Attributes from an XML file.

<P>

<P>

<P>

<H3><A NAME="SECTION06026100000000000000"></A> <A NAME="ex:AttributeEx"></A>
<BR>
35.6.1 Basic Attribute usage
</H3>

<P>
This example illustrates the most basic usage of the Attribute class.  
   This demonstration of Attribute manipulation is limited to the gridded 
   Component, but the same principles apply to the coupler Component, State, 
   Grid, FieldBundle, Field, ArrayBundle and Array.  The
   functionality that is demonstrated includes setting and getting Attributes, 
   working with Attributes with different types and lists, removing Attributes,
   and getting default Attributes.  Various other uses of 
   <TT>ESMF_AttributeGet()</TT> is covered in detail in the last section.  The
   first thing we must do is declare variables and initialize ESMF. 

<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
      implicit none

      ! Local variables  
      integer                 :: rc, finalrc, petCount, localPet, &amp;
                                 itemCount, count
      type(ESMF_VM)           :: vm
      type(ESMF_GridComp)     :: gridcomp
      character(ESMF_MAXSTR)  :: name
      type(ESMF_TypeKind_Flag)     :: tk

      integer(ESMF_KIND_I4)                :: inI4
      integer(ESMF_KIND_I4), dimension(3)  :: inI4l
      integer(ESMF_KIND_I8)                :: inI8
      integer(ESMF_KIND_I8), dimension(3)  :: inI8l
      real(ESMF_KIND_I4)                   :: inR4
      real(ESMF_KIND_I4), dimension(3)     :: inR4l
      real(ESMF_KIND_I8)                   :: inR8
      real(ESMF_KIND_I8), dimension(3)     :: inR8l
      character(ESMF_MAXSTR)               :: inChar
      character(ESMF_MAXSTR), dimension(3) :: inCharl, &amp;
                                           defaultCharl, dfltoutCharl
      character(ESMF_MAXSTR), dimension(8) :: outCharl
      logical                              :: inLog
      logical, dimension(3)                :: inLogl, value
      
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, defaultlogfilename="AttributeEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
      
      ! get the vm
      call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=rc)
</PRE>

<P>
We will construct the gridded Component which will be responsible for all
      of the Attributes we will be manipulating. 

<P>
<PRE>
      if (petCount&lt;4) then
        gridcomp = ESMF_GridCompCreate(name="gridcomp", &amp;
          petList=(/0/), rc=rc)
      else 
        gridcomp = ESMF_GridCompCreate(name="gridcomp", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
We can set Attributes using the <TT>ESMF_AttributeSet()</TT> command.  
       Attributes can be any of several different types, all of which are 
       demonstrated here. 

<P>
<PRE>
      inI4 = 4
      inI4l = (/1,2,3/)
      inI8 = 4
      inI8l = (/1,2,3/)
      inR4 = 4
      inR4l = (/1,2,3/)
      inR8 = 4
      inR8l = (/1,2,3/)
      inChar = "Character string 4"
      inCharl = (/ "Character string 1", &amp;
                   "Character string 2", &amp;
                   "Character string 3" /)
      inLog = .true.
      inLogl = (/.true., .false., .true. /)
      
      call ESMF_AttributeSet(gridcomp, name="ESMF_I4name", value=inI4, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="ESMF_I4namelist", &amp;
        valueList=inI4l, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="ESMF_I8name", value=inI8,  rc=rc)
      call ESMF_AttributeSet(gridcomp, name="ESMF_I8namelist", &amp;
        valueList=inI8l, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="ESMF_R4name", value=inR4, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="ESMF_R4namelist", &amp;
        valueList=inR4l, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="ESMF_R8name", value=inR8, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="ESMF_R8namelist", &amp;
        valueList=inR8l, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="Character_name", &amp;
        value=inChar, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="Character_namelist", &amp;
        valueList=inCharl, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="Logical_name", value=inLog, rc=rc)
      call ESMF_AttributeSet(gridcomp, name="Logical_namelist", &amp;
        valueList=inLogl, rc=rc)
</PRE>

<P>
We can retrieve Attributes by issuing the <TT>ESMF_AttributeGet()</TT> 
       command.  This command can also be used with an optional default 
       value (or value list) so that if the Attribute is not found a value is 
       returned without an error code.  Removal of Attributes is also 
       possible, and is demonstrated here as well.  One of the Attributes
       previously created will be retrieved, then removed, then 
       retrieved again using a default return value.  In order to use the 
       default return value capabilites, we must first set up a default parameter. 

<P>
<PRE>
      defaultCharl = (/ "Character string 4", &amp;
                        "Character string 5", &amp;
                        "Character string 6" /)
      
      itemCount=3
      call ESMF_AttributeGet(gridcomp, name="Character_namelist", &amp;
        valueList=outCharl(1:5), itemCount=itemCount, rc=rc) 
                    
      call ESMF_AttributeRemove(gridcomp, name="Character_namelist", rc=rc)
      
      call ESMF_AttributeGet(gridcomp, name="Character_namelist", &amp;
        valueList=dfltoutCharl, defaultvalueList=defaultCharl,rc=rc)
</PRE>

<P>
There are more overloaded instances of <TT>ESMF_AttributeGet()</TT> 
      which allow the retrieval of Attribute information by name or index 
      number, or a query for the count of the Attributes on a certain object.  
      These capabilities are demonstrated here by first retrieving the name of
      an Attribute using the index number, keep in mind that these index
      numbers start from 1.  Then the name that is retrieved
      is used to get other information about the Attribute, such as the
      typekind, and the number of items in the value of the Attribute.
      This information is then used to actually retreive the Attribute value.
      Then the count of the number of Attributes on the object will be retrieved. 

<P>
<PRE>
      call ESMF_AttributeGet(gridcomp, attributeIndex=11 , name=name, rc=rc)
      
      call ESMF_AttributeGet(gridcomp, name=name, typekind=tk, &amp;
        itemCount=itemCount, rc=rc)
      
      if (tk==ESMF_TYPEKIND_Logical .AND. itemCount==3) then
        call ESMF_AttributeGet(gridcomp, name=name, valueList=value, rc=rc)
      endif
      
      call ESMF_AttributeGet(gridcomp, count=count, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION06026200000000000000"></A> <A NAME="ex:AttributePackageEx"></A>
<BR>
35.6.2 Attribute packages
</H3>

<P>
This example is slightly more complex than the example presented in section 
   <A HREF="node6.html#ex:AttributeEx">35.6.1</A> and illustrates the use of the Attribute class to
   create Attribute hierarchies using Attribute packages.  A gridded Component
   is used in conjunction with two States, a FieldBundle, and various realistic
   Fields to create an Attribute hierarchy and copy it from one State to another.  
   Attribute packages are created on the Component and Fields, and the 
   standard Attributes in each package are used in the Attribute hierarchy.
   The Attribute package nesting capability is demonstrated by nesting the standard
   ESMF supplied packages for the Fields inside a user specified Attribute package
   with a customized convention. 

<P>
We must construct the ESMF objects that will be responsible for the
      Attributes we will be manipulating.  These objects include the 
      gridded Component, two States, a FieldBundle, and 10 Fields.  In this trivial 
      example we are constructing empty Fields with no underlying Grid. 

<P>
<PRE>
      if (petCount&lt;4) then
        gridcomp = ESMF_GridCompCreate(name="gridded_comp_ex2", &amp;
          petList=(/0/), rc=rc)
      else 
        gridcomp = ESMF_GridCompCreate(name="gridded_comp_ex2", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
      importState = ESMF_StateCreate(name="importState",  &amp;
                                     stateintent=ESMF_STATEINTENT_IMPORT, rc=rc)
      exportState = ESMF_StateCreate(name="exportState",  &amp;
                                     stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
        
      DPEDT = ESMF_FieldEmptyCreate(name='DPEDT', rc=rc)
      DTDT = ESMF_FieldEmptyCreate(name='DTDT', rc=rc)
      DUDT = ESMF_FieldEmptyCreate(name='DUDT', rc=rc)
      DVDT = ESMF_FieldEmptyCreate(name='DVDT', rc=rc)
      PHIS = ESMF_FieldEmptyCreate(name='PHIS', rc=rc)
      QTR = ESMF_FieldEmptyCreate(name='QTR', rc=rc)
      CNV = ESMF_FieldEmptyCreate(name='CNV', rc=rc)
      CONVCPT = ESMF_FieldEmptyCreate(name='CONVCPT', rc=rc)
      CONVKE = ESMF_FieldEmptyCreate(name='CONVKE', rc=rc)
      CONVPHI = ESMF_FieldEmptyCreate(name='CONVPHI', rc=rc)
      
      fbundle = ESMF_FieldBundleCreate(name="fbundle", rc=rc)
</PRE>

<P>
Now we can add Attribute packages to all of the appropriate objects.
      We will use the ESMF supplied Attribute packages for the Fields and 
      the Component.  On the Fields, we will first use 
      <TT>ESMF_AttributeAdd()</TT> to create standard Attribute packages, then
      we will nest customized Attribute packages around the ESMF standard
      Attribute packages.  In this simple example the purpose for the Attribute packages will
      be specified as "General" in all cases. 

<P>
<PRE>
      convESMF = 'ESMF'
      convCC = 'CustomConvention'
      purpGen = 'General'

      attrList(1) = 'Coordinates'
      attrList(2) = 'Mask'

      ! DPEDT
      call ESMF_AttributeAdd(DPEDT, convention=convESMF, purpose=purpGen, &amp;
        rc=rc)
      call ESMF_AttributeAdd(DPEDT, convention=convCC, purpose=purpGen,   &amp;
        attrList=attrList, nestConvention=convESMF, nestPurpose=purpGen,  &amp;
        rc=rc)
</PRE>

<P>
... and so on for the other 9 Fields.

<P>
The standard Attribute package currently supplied by ESMF for 
       Field contains 6 Attributes, 2 of which are set automatically.  
       The remaining 4 Attributes in the standard Field Attribute
       package must be set manually by the user.   We must also
       set the Attributes of our own custom Attribute package, which
       is built around the ESMF standard Attribute package. 

<P>
<PRE>
      name1 = 'ShortName'
      name2 = 'StandardName'
      name3 = 'LongName'
      name4 = 'Units'
      
      ! DPEDT
      value1 = 'DPEDT'
      value2 = 'tendency_of_air_pressure'
      value3 = 'Edge pressure tendency'
      value4 = 'Pa s-1'
      ! Custom Attributes
      call ESMF_AttributeSet(DPEDT, name='Coordinates', value='latlon', &amp;
        convention=convCC, purpose=purpGen, rc=rc)
      call ESMF_AttributeSet(DPEDT, name='Mask', value='yes', &amp;
        convention=convCC, purpose=purpGen, rc=rc)
      ! ESMF Attributes
      call ESMF_AttributeSet(DPEDT, name1, value1, convention=convESMF, &amp;
        purpose=purpGen, rc=rc)
      call ESMF_AttributeSet(DPEDT, name2, value2, convention=convESMF, &amp;
        purpose=purpGen, rc=rc)
      call ESMF_AttributeSet(DPEDT, name3, value3, convention=convESMF, &amp;
        purpose=purpGen, rc=rc)
      call ESMF_AttributeSet(DPEDT, name4, value4, convention=convESMF, &amp;
        purpose=purpGen, rc=rc)
</PRE>

<P>
... and so on for the other 9 Fields.

<P>
The standard Attribute package currently supplied by ESMF for 
       Component contains 10 Attributes.  These Attributes conform to both
       the ESG and CF conventions, and must be set manually. 

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'Agency', 'NASA', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'Author', 'Max Suarez', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'CodingLanguage', &amp;
      'Fortran 90', convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'Discipline', &amp;
      'Atmosphere', convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'ComponentLongName', &amp;
      'Goddard Earth Observing System Version 5 Finite Volume Dynamical Core', &amp;
        convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'ModelComponentFramework', &amp;
      'ESMF', convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'ComponentShortName', &amp;
      'GEOS-5 FV dynamical core', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'PhysicalDomain', &amp;
      'Earth system', convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'Version', &amp;
      'GEOSagcm-EROS-beta7p12', convention=convESMF, purpose=purpGen, rc=rc)
</PRE>

<P>
Adding the Fields to the FieldBundle will automatically ``link" the 
       Attribute hierarchies.  The same type of link will be generated
       when adding a FieldBundle to a State. 

<P>
<PRE>
      call ESMF_FieldBundleAdd(fbundle, (/DPEDT/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/DTDT/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/DUDT/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/DVDT/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/PHIS/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/QTR/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/CNV/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/CONVCPT/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/CONVKE/), rc=rc)
      call ESMF_FieldBundleAdd(fbundle, (/CONVPHI/), rc=rc)
      
      call ESMF_StateAdd(exportState, fieldbundleList=(/fbundle/), rc=rc)
</PRE>

<P>
The link between a State and the Component of interest must be
       set manually. 

<P>
<PRE>
      call ESMF_AttributeLink(gridcomp, exportState, rc=rc)
</PRE>

<P>
There are currently two different formats available for writing
       the contents of the Attribute packages in an Attribute hierarchy.
       There is an XML formatted write, which generates an .xml file in the
       execution directory with the contents of the write.  There is also
       a tab-delimited write which writes to standard out, a file generated
       in the execution directory with the extension .stdout.  Either of 
       the <TT>ESMF_AttributeWrite()</TT> formats can be called on any of the objects which
       are capable of manipulating Attributes, but only from objects in an 
       Attribute hierarchy which contain ESMF standard Attribute packages can it be confirmed that any 
       relevant information be written.  The <TT>ESMF_AttributeWrite()</TT>
       capability is only functional for single-item Attributes at this point, it
       will be more robust in future releases.  A flag is used to 
       specify which format to write, the default is tab-delimited. 

<P>
<PRE>
      call ESMF_AttributeWrite(gridcomp,convESMF,purpGen, &amp;
        attwriteflag=ESMF_ATTWRITE_XML,rc=rc)
      call ESMF_AttributeWrite(gridcomp,convESMF,purpGen,rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION06026300000000000000"></A>  <A NAME="ex:AttributeCustPackEx"></A>
<BR>
35.6.3 Custom Attribute package
</H3>

<P>
This example illustrates how to create a user-defined, custom Attribute 
   package.  The package is created on a gridded Component with three custom
   Attributes. 

<P>
We must construct the ESMF gridded Component object that will be 
      responsible for the custom Attribute package we will be manipulating. 

<P>
<PRE>
      if (petCount&lt;4) then
        gridcomp = ESMF_GridCompCreate(name="gridded_comp_ex3", &amp;
          petList=(/0/), rc=rc)
      else 
        gridcomp = ESMF_GridCompCreate(name="gridded_comp_ex3", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
Now we can add a custom Attribute package to the gridded Component object. 

<P>
<PRE>
      customConv = 'CustomConvention'
      customPurp = 'CustomPurpose'

      customAttrList(1) = 'CustomAttrName1'
      customAttrList(2) = 'CustomAttrName2'
      customAttrList(3) = 'CustomAttrName3'

      call ESMF_AttributeAdd(gridcomp, convention=customConv, &amp;
        purpose=customPurp, attrList=customAttrList, rc=rc)
</PRE>

<P>
We must set the Attribute values of our custom Attribute package. 

<P>
<PRE>
    call ESMF_AttributeSet(gridcomp, 'CustomAttrName1', 'CustomAttrValue1', &amp;
      convention=customConv, purpose=customPurp, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'CustomAttrName2', 'CustomAttrValue2', &amp;
      convention=customConv, purpose=customPurp, rc=rc)
    call ESMF_AttributeSet(gridcomp, 'CustomAttrName3', 'CustomAttrValue3', &amp;
      convention=customConv, purpose=customPurp, rc=rc)
</PRE>

<P>
Write out the contents of our custom Attribute package to an XML file,
       which is generated with a .xml file extension in the execution directory.  

<P>
<PRE>
      call ESMF_AttributeWrite(gridcomp,customConv,customPurp, &amp;
        attwriteflag=ESMF_ATTWRITE_XML,rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION06026400000000000000">
35.6.4 Updating Attributes in a distributed environment</A>
</H3>

<P>
This advanced example illustrates the proper methods of Attribute manipulation
   in a distributed environment to ensure consistency of metadata across the VM. 
   This example is much more complicated than the previous two because we will
   be following the flow of control of a typical model run with two gridded Components
   and one coupling Component.  We will start out in the application driver, declaring
   Components, States, and the routines used to initialize, run and finalize the user's
   model Components.  Then we will follow the control flow into the actual Component level
   through initialize, run, and finalize examining how Attributes are used to organize the
   metadata.

<P>
This example follows a simple user model with two gridded Components and one coupling Component. 
   The initialize routines are used to set up the application data and the run 
   routines are used to manipulate the data.  Accordingly, most of the Attribute manipulation
   will take place in the initialize phase of each of the three Components.  The two gridded
   Components will be running on exclusive pieces of the VM and the coupler Component will 
   encompass the entire VM so that it can handle the Attribute communications.  

<P>
The control flow of this
   example will start in the application driver, after which it will complete three cycles
   through the three Components.  The first cycle will be through the initialize routines, 
   from the first gridded Component to the second gridded Component to the coupler Component.  The 
   second cycle will go through the run routines, from the first gridded Component to the 
   coupler Component to the second Gridded component.  The third cycle will be through the
   finalize routines in the same order as the first cycle.

<P>
In the application driver, we must now construct some ESMF objects, 
   such as the gridded Components, the coupler Component, and the States.  This
   is also where it is determined which subsets of the PETs of the VM the
   Components will be using to run their initialize, run, and finalize routines. 

<P>
<PRE>
        gridcomp1 = ESMF_GridCompCreate(name="gridcomp1", &amp;
          petList=(/0,1/), rc=rc)
        gridcomp2 = ESMF_GridCompCreate(name="gridcomp2", &amp;
          petList=(/2,3/), rc=rc)
        cplcomp = ESMF_CplCompCreate(name="cplcomp", &amp;
          petList=(/0,1,2,3/), rc=rc)

      c1exp = ESMF_StateCreate(name="Comp1 exportState", &amp;
                               stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)
      c2imp = ESMF_StateCreate(name="Comp2 importState", &amp;
                               stateintent=ESMF_STATEINTENT_IMPORT, rc=rc)
</PRE>

<P>
Before the individual components are initialized, run, and finalized Attributes should be set at the
   Component level.  Here we are going to use the ESG Attribute package on 
   the first gridded Component.  The Attribute package is added, and then
   each of the Attributes is set.  The Attribute hierarchy of the Component
   is then linked to the Attribute hierarchy of the export State in a 
   manual fashion. 

<P>
<PRE>
      convESMF = 'ESMF'
      purpGen = 'General'
    call ESMF_AttributeAdd(gridcomp1, convention=convESMF, purpose=purpGen, &amp;
      rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'Agency', 'NASA', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'Author', 'Max Suarez', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'CodingLanguage', &amp;
      'Fortran 90', convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'Discipline', &amp;
      'Atmosphere', convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'ComponentLongName', &amp;
   'Goddard Earth Observing System Version 5 Finite Volume Dynamical Core', &amp;
        convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'ModelComponentFramework', &amp;
      'ESMF', &amp;
      convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'ComponentShortName', &amp;
      'GEOS-5 FV dynamical core', convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'PhysicalDomain', &amp;
      'Earth system', convention=convESMF, purpose=purpGen, rc=rc)
    call ESMF_AttributeSet(gridcomp1, 'Version', &amp;
      'GEOSagcm-EROS-beta7p12', convention=convESMF, purpose=purpGen, rc=rc)
      
      call ESMF_AttributeLink(gridcomp1, c1exp, rc=rc)
</PRE>

<P>
Now the individual Components will be run.  First we will initialize the two
   gridded Components, then we will initialize the coupler Component. 
   During each of these Component initialize routines Attribute
   packages will be added, and the Attributes set.  The Attribute
   hierarchies will also be linked.  As the gridded Components will
   be running on exclusive portions of the VM, the Attributes will need to 
   be made available across the VM using an <TT>ESMF_StateReconcile()</TT>
   call in the coupler Component.  The majority of the work
   with Attributes will take place in this portion of the 
   model run, as metadata rarely needs to be changed during run time.  

<P>
What 
   follows are the calls from the driver code that run the initialize, run, and finalize routines
   for each of the Components.  After these calls we will step through the first 
   cycle as explained in the introduction, through the intialize routines of
   gridded Component 1 to gridded Component 2 to the coupler Component. 

<P>
<PRE>
      call ESMF_GridCompInitialize(gridcomp1, exportState=c1exp, rc=rc)
      call ESMF_GridCompInitialize(gridcomp2, importState=c2imp, rc=rc)
      call ESMF_CplCompInitialize(cplcomp, importState=c1exp, &amp;
        exportState=c2imp, rc=rc)

      call ESMF_GridCompRun(gridcomp1, exportState=c1exp, rc=rc)
      call ESMF_CplCompRun(cplcomp, importState=c1exp, &amp;
        exportState=c2imp, userRc=urc, rc=rc)
        
      call ESMF_GridCompRun(gridcomp2, importState=c2imp, rc=rc)
      
      call ESMF_GridCompFinalize(gridcomp1, exportState=c1exp, rc=rc)
      call ESMF_GridCompFinalize(gridcomp2, importState=c2imp, rc=rc)
      call ESMF_CplCompFinalize(cplcomp, importState=c1exp, &amp;
        exportState=c2imp, rc=rc)
</PRE>

<P>

<P>

<P>

<P>
In the first gridded Component initialize routine we need to create some
   Attribute packages and set all of the Attributes.  These Attributes will
   be attached to realistic Fields, containing a Grid, which are contained in a 
   FieldBundle.  The first thing to do is declare variables and make the Grid. 

<P>
<PRE>
    type(ESMF_VM)            :: vm
    integer                  :: petCount, status, myPet
    character(ESMF_MAXSTR)   :: name1,name2,name3,name4,value1,value2, &amp;
                                value3,value4,convESMF,purpGen,convCC
    type(ESMF_ArraySpec)     :: arrayspec
    type(ESMF_Grid)          :: grid
    type(ESMF_Field)         :: DPEDT,DTDT,DUDT,DVDT,PHIS,QTR,CNV,CONVCPT, &amp;
                                CONVKE,CONVPHI
    type(ESMF_FieldBundle)   :: fieldbundle
    character(ESMF_MAXSTR),dimension(2)   :: attrList         
    
    rc = ESMF_SUCCESS

    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)

    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, &amp;
           rc=rc)
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/100,150/), &amp;
      regDecomp=(/1,petCount/), &amp;
      gridEdgeLWidth=(/0,0/), gridEdgeUWidth=(/0,0/), &amp;
      indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
At this point the Fields will need to have Attribute packages attached to them, and the
   Attributes will be set with appropriate values. 

<P>
<PRE>
    convCC = 'CustomConvention'
    convESMF = 'ESMF'
    purpGen = 'General'
    name1 = 'ShortName'
    name2 = 'StandardName'
    name3 = 'LongName'
    name4 = 'Units'
 
    value1 = 'DPEDT'
    value2 = 'tendency_of_air_pressure'
    value3 = 'Edge pressure tendency'
    value4 = 'Pa s-1'
      
    DPEDT = ESMF_FieldCreate(grid, arrayspec=arrayspec, &amp;
              staggerloc=ESMF_STAGGERLOC_CENTER, rc=status)
    call ESMF_AttributeAdd(DPEDT, convention=convESMF, purpose=purpGen, &amp;
      rc=status)
    call ESMF_AttributeSet(DPEDT, name1, value1, convention=convESMF, &amp;
      purpose=purpGen, rc=status)
    call ESMF_AttributeSet(DPEDT, name2, value2, convention=convESMF, &amp;
      purpose=purpGen, rc=status)
    call ESMF_AttributeSet(DPEDT, name3, value3, convention=convESMF, &amp;
      purpose=purpGen, rc=status)
    call ESMF_AttributeSet(DPEDT, name4, value4, convention=convESMF, &amp;
      purpose=purpGen, rc=status)
</PRE>

<P>
... and so on for the other 9 Fields.

<P>
Now the Fields will be added to the FieldBundle, at which point the Attribute
   hierarchies of the Fields will also be attached to the Attribute hierarchy of
   the FieldBundle.  After that, the FieldBundle will be attached to the export
   State, again at which time the Attribute hierarchy of the FieldBundle will be
   attached to the Attribute hierarchy of the export State. 

<P>
<PRE>
    fieldbundle = ESMF_FieldBundleCreate(name="fieldbundle", rc=status)
    call ESMF_FieldBundleSet(fieldbundle, grid=grid, rc=status)
      
    call ESMF_FieldBundleAdd(fieldbundle, (/DPEDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DTDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DUDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/DVDT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/PHIS/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/QTR/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CNV/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVCPT/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVKE/), rc=status)
    call ESMF_FieldBundleAdd(fieldbundle, (/CONVPHI/), rc=status)

    call ESMF_StateAdd(exportState, fieldbundleList=(/fieldbundle/), rc=status)
</PRE>

<P>
At this point, the driver of the model run will transfer control to the 
   initialize phase of the second gridded Component. 

<P>
In the second gridded Component initialize routine we don't have
   anything to do.  The data that was created in the initialize routine
   of the first gridded Component will be passed to this Component through
   the coupler Component.  The data will not be used in this Component
   until the run phase of the model.  So now the application driver transfers
   control to the initialize phase of the coupler Component. 

<P>
In the coupler Component initialize routine all that is required 
   is to ensure consistent data across the VM.  The data created
   in the first gridded Component on one set of the PETs in the VM is
   intended to be read and manipulated by the second gridded Component
   which runs on an exclusive set of the PETs of the VM for this 
   application.  We need to first make that data consistent across the
   entire VM with the <TT>ESMF_StateReconcile()</TT> call.
   This State level call handles both the data - Fields and FieldBundles, 
   and the metadata - Attribute and Attribute packages.  There is a flag in
   this call to allow the user to specify whether they want 
   the metadata to be reconciled or not. 

<P>
<PRE>
    type(ESMF_VM)         :: vm

    rc = ESMF_SUCCESS

    call ESMF_CplCompGet(comp, vm=vm, rc=rc)
    call ESMF_StateReconcile(importState, vm=vm, &amp;
               attreconflag=ESMF_ATTRECONCILE_ON, rc=rc)
    call ESMF_StateReconcile(exportState, vm=vm, &amp;
               attreconflag=ESMF_ATTRECONCILE_ON, rc=rc)
</PRE>

<P>
At this point, the driver of the model run will transfer control to the 
   run phase of the first gridded Component. 

<P>
In the run phase of the first gridded Component is typically where the
   data contained in the Fields is manipulated.  For this simple example
   we will do no actual data manipulation because all we are interested in
   at this point is the metadata.  What we will do is add a nested Attribute
   package inside the currently existing Attribute package on each Field.  We
   will also change the value of one of the Attributes in the original Attribute
   package, and remove another of the Attributes from the original Attribute 
   package on each of the Fields.  The first thing is to declare variables and
   get the Component, VM, State, and FieldBundle. 

<P>
<PRE>
    type(ESMF_VM)               :: vm
    integer                     :: petCount, status, myPet, k
    character(ESMF_MAXSTR)      :: name2,value2,convESMF,purpGen,purp2,name3
    character(ESMF_MAXSTR),dimension(2) :: attrList
    type(ESMF_Field)            :: field
    type(ESMF_FieldBundle)      :: fieldbundle
    type(ESMF_Grid)             :: grid

    rc = ESMF_SUCCESS

    convESMF = 'ESMF'
    purpGen = 'General'
    name2 = 'StandardName'
    value2 = 'default_standard_name'
    name3 = 'LongName'
    
    purp2 = 'Extended'
    attrList(1) = 'Coordinates'
    attrList(2) = 'Mask'
    
    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)

    call ESMF_StateGet(exportState, "fieldbundle", fieldbundle, rc=rc)
    call ESMF_FieldBundleGet(fieldbundle, grid=grid, rc=rc)
</PRE>

<P>
At this point we will extract each of the Fields in the FieldBundle in turn
   and change the value of one Attribute in the original Attribute package, 
   add a nested Attribute package, and delete one other of the Attributes in the
   original Attribute package.  These three changes represent, respectively, a
   value change and two structural changes to the Attribute hierarchy during
   run time, which must be reconciled across the VM before the second gridded
   Component can be allowed to further manipulate the Attribute hierarchy. 

<P>
<PRE>
    do k = 1, 10
        call ESMF_FieldBundleGet(fieldbundle, fieldIndex=k, field=field, rc=rc)
        call ESMF_AttributeSet(field, name2, value2, convention=convESMF, &amp;
          purpose=purpGen, rc=status)
        call ESMF_AttributeAdd(field, convention=convESMF, purpose=purp2, &amp;
          attrList=attrList, nestConvention=convESMF, nestPurpose=purpGen, &amp;
          rc=rc)
        call ESMF_AttributeSet(field, name='Coordinates', value='Latlon', &amp;
          convention=convESMF, purpose=purp2, rc=rc)
        call ESMF_AttributeSet(field, name='Mask', value='Yes', &amp;
          convention=convESMF, purpose=purp2, rc=rc)
        call ESMF_AttributeRemove(field, name=name3, convention=convESMF, &amp;
          purpose=purpGen, rc=status)
    enddo
</PRE>

<P>
At this point, the driver of the model run will transfer control to the 
   run phase of the coupler Component. 

<P>
In the run phase of the coupler Component we must now ensure that the
   entire VM again has a consistent view of the Attribute hierarchy.  This 
   is different from the communication done in the initialize phase of the
   model run because the only structural change that has occurred is in the
   Attribute hierarchy.  Therefore an <TT>ESMF_AttributeUpdate()</TT> call can
   be used at this point to reconcile these changes.  It should be noted that
   the <TT>ESMF_AttributeUpdate()</TT> call will reconcile value changes to the
   Attribute hierarchy as well as structural changes.

<P>
The first thing to do is to retrieve the Component, VM, and States.  Then
   <TT>ESMF_AttributeUpdate()</TT> will be called on the import State to accomplish
   a VM wide communication.  Afterwards, the Attribute hierarchy can be transfered,
   in a local sense, from the import State to the export State using an
   <TT>ESMF_AttributeCopy()</TT> call.   

<P>
<PRE>
    type(ESMF_VM)               :: vm
    integer                     :: myPet
    
    integer, dimension(2)       :: rootList

    rc = ESMF_SUCCESS

    call ESMF_CplCompGet(comp, vm=vm, rc=rc)

    call ESMF_VMGet(vm, localPet=myPet, rc=rc)

    call ESMF_StateGet(importState, rc=rc)
    call ESMF_StateGet(exportState, rc=rc)

    rootList = (/0,1/)
    call ESMF_AttributeUpdate(importState, vm, rootList=rootList, rc=rc)
   
    call ESMF_AttributeCopy(importState, exportState, &amp;
      ESMF_COPY_ALIAS, ESMF_ATTTREE_ON, rc=rc)
</PRE>

<P>
At this point the entire VM has a consistent view of the Attribute hierarchy
   that was recently modified during <I>run time</I> in the first gridded component
   and the driver of the model run will transfer control to the 
   run phase of the second gridded Component. 

<P>
In the run phase of the second gridded Component is normally where
   a user model would again manipulate the data it was given.  In this
   simple example we are only dealing with the metadata, which has already
   been ensured for consistency across the VM, including the exclusive
   piece of which is being used in this Component.  Therefore we are free
   to use the metadata as we wish, considering only that any changes we 
   make to it during run time will have to first be reconciled before other
   parts of the VM can use them.  However, this is not our concern at this
   point because we will now explore the capabilities of <TT>ESMF_AttributeWrite()</TT>.

<P>
First we will get the Component and VM.  Then we will write out the 
   Attribute hierarchy to an .xml file, 
   after which we will write out the Attribute hierarchy to a more reader
   friendly tab-delimited format.  Both of these write calls will output their
   respective data into files in the execution directory, in either a .xml
   or .stdout file.   

<P>
<PRE>
    type(ESMF_VM)               :: vm
    integer                     :: petCount, status, myPet
    character(ESMF_MAXSTR)      :: convESMF,purpGen
    
    rc = ESMF_SUCCESS

    call ESMF_GridCompGet(comp, vm=vm, rc=status)
    if (status .ne. ESMF_SUCCESS) return
    call ESMF_VMGet(vm, petCount=petCount, localPet=myPet, rc=status)
    if (status .ne. ESMF_SUCCESS) return

    convESMF = 'ESMF'
    purpGen = 'General'

    if (myPet .eq. 2) then
      call ESMF_AttributeWrite(importState,convESMF,purpGen, &amp;
        attwriteflag=ESMF_ATTWRITE_XML, rc=rc)
      call ESMF_AttributeWrite(importState,convESMF,purpGen,rc=rc)
      if (rc .ne. ESMF_SUCCESS) return
    endif
</PRE>

<P>
At this point the driver of the model run would normally transfer control
   to the finalize phase of the first gridded Component.  However, there is
   not much of interest as far as metadata is concerned in this portion
   of the model run.  So with that we will conclude this example.

<P>

<P>

<P>

<H3><A NAME="SECTION06026500000000000000"></A>
   <A NAME="sec:attribute:usage:cimAttPack"></A>
<BR>
35.6.5 CIM Attribute packages
</H3>

<P>
This example illustrates the use of the Metafor CIM Attribute packages,
   supplied by ESMF, to create an Attribute hierarchy on an ESMF object tree.
   A gridded Component is used together with a State and a realistic Field
   to create a simple ESMF object tree.  CIM Attributes packages are created
   on the Component and Field, and then the individual Attributes within the
   packages are populated with values.  Finally, all the Attributes are written
   to a CIM-formatted XML file.  For a more comprehensive example, see the
   ESMF_AttributeCIM system test.

<P>
<PRE>
      ! Use ESMF framework module
      use ESMF
      implicit none

      ! Local variables  
      integer                 :: rc, finalrc, petCount, localPet
      type(ESMF_VM)           :: vm
      type(ESMF_Field)        :: ozone
      type(ESMF_State)        :: exportState
      type(ESMF_GridComp)     :: gridcomp
      character(ESMF_MAXSTR)  :: convCIM, purpComp, purpProp
      character(ESMF_MAXSTR)  :: purpField, purpPlatform
      character(ESMF_MAXSTR)  :: convISO, purpRP, purpCitation
      character(ESMF_MAXSTR), dimension(2)  :: compPropAtt
      
      ! initialize ESMF
      finalrc = ESMF_SUCCESS
      call ESMF_Initialize(vm=vm, defaultlogfilename="AttributeCIMEx.Log", &amp;
        logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
      if (rc/=ESMF_SUCCESS) goto 10
      
      ! get the vm
      call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=rc)
      if (rc/=ESMF_SUCCESS) goto 10
</PRE>

<P>
Create the ESMF objects that will hold the CIM Attributes.
      These objects include a gridded Component, a State, and a Field.
      In this example we are constructing empty Fields without an
      underlying Grid.

<P>
<PRE>
      ! Create Component
      gridcomp = ESMF_GridCompCreate(name="gridded_component", &amp;
        petList=(/0/), rc=rc)

      ! Create State
      exportState = ESMF_StateCreate(name="exportState",  &amp;
        stateintent=ESMF_STATEINTENT_EXPORT, rc=rc)

      ! Create Field
      ozone = ESMF_FieldEmptyCreate(name='ozone', rc=rc)
</PRE>

<P>
Now add CIM Attribute packages to the Component and Field.  Also, add
      a CIM Component Properties package, to contain two custom attributes.

<P>
<PRE>
      convCIM = 'CIM 1.5'
      purpComp = 'Model Component Simulation Description'
      purpProp = 'General Component Properties Description'
      purpField = 'Inputs Description'
      purpPlatform = 'Platform Description'

      convISO = 'ISO 19115'
      purpRP = 'Responsible Party Description'
      purpCitation = 'Citation Description'

      ! Add CIM Attribute package to the gridded Component
      call ESMF_AttributeAdd(gridcomp, convention=convCIM, &amp;
        purpose=purpComp, rc=rc)

      ! Specify the gridded Component to have a Component Properties
      ! package with two custom attributes, with user-specified names
      compPropAtt(1) = 'SimulationType'
      compPropAtt(2) = 'SimulationURL'
      call ESMF_AttributeAdd(gridcomp, convention=convCIM, purpose=purpProp, &amp;
        attrList=compPropAtt, rc=rc)
      
      ! Add CIM Attribute package to the Field
      call ESMF_AttributeAdd(ozone, convention=convCIM, purpose=purpField, &amp;
        rc=rc)
</PRE>

<P>
The standard Attribute package supplied by ESMF for a CIM Component
       contains several Attributes, grouped into sub-packages.  These 
       Attributes conform to the CIM convention as defined by Metafor and
       their values are set individually.

<P>
<PRE>
      !
      ! Top-level model component attributes, set on gridded component
      !
      call ESMF_AttributeSet(gridcomp, 'ShortName', 'EarthSys_Atmos', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'LongName', &amp;
        'Earth System High Resolution Global Atmosphere Model', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'Description', &amp;
        'EarthSys brings together expertise from the global ' // &amp;
        'community in a concerted effort to develop coupled ' // &amp;
        'climate models with increased horizontal resolutions.  ' // &amp;
        'Increasing the horizontal resolution of coupled climate ' // &amp;
        'models will allow us to capture climate processes and ' // &amp;
        'weather systems in much greater detail.', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'Version', '2.0', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'ReleaseDate', '2009-01-01T00:00:00Z', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'ModelType', 'aerosol', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'URL', &amp;
        'www.earthsys.org', convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MetadataVersion', '1.1', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)

      ! Simulation run attributes
      call ESMF_AttributeSet(gridcomp, 'SimulationShortName', &amp;
                                       'SMS.f09_g16.X.hector', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'SimulationLongName', &amp;
        'EarthSys - Earth System Modeling Framework Earth System Model 1.0', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'SimulationRationale', &amp;
    'EarthSys-ESMF simulation run in repsect to CMIP5 core experiment 1.1 ()', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'SimulationStartDate', &amp;
                                       '1960-01-01T00:00:00Z', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'SimulationDuration', 'P10Y', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'SimulationNumberOfProcessingElements', &amp;
                                       '16', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)

      ! Document genealogy
      call ESMF_AttributeSet(gridcomp, 'PreviousVersion', &amp;
                                       'EarthSys1 Atmosphere', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'PreviousVersionDescription', &amp;
       'Horizontal resolution increased to 1.20 x 0.80 degrees; ' // &amp;
       'Timestep reduced from 30 minutes to 15 minutes.', &amp;
        convention=convCIM, purpose=purpComp, rc=rc)

      ! Platform description attributes
      call ESMF_AttributeSet(gridcomp, 'CompilerName', 'Pathscale', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'CompilerVersion', '3.0', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineName', 'HECToR', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineDescription', &amp;
        'HECToR (Phase 2a) is currently an integrated system known ' // &amp;
        'as Rainier, which includes a scalar MPP XT4 system, a vector ' // &amp;
        'system known as BlackWidow, and storage systems.', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineSystem', 'Parallel', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineOperatingSystem', 'Unicos', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineVendor', 'Cray Inc', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineInterconnectType', &amp;
                                       'Cray Interconnect', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineMaximumProcessors', '22656', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineCoresPerProcessor', '4', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'MachineProcessorType', 'AMD X86_64', &amp;
        convention=convCIM, purpose=purpPlatform, rc=rc)

      ! Component Properties: custom attributes
      call ESMF_AttributeSet(gridcomp, 'SimulationType', 'branch', &amp;
        convention=convCIM, purpose=purpProp, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'SimulationURL', &amp;
                                       'http://earthsys.org/simulations', &amp;
        convention=convCIM, purpose=purpProp, rc=rc)
</PRE>

<P>
Set the attribute values of the Responsible Party sub-package, created
      above for the gridded Component in the ESMF_AttributeAdd(gridcomp, ...)
      call.

<P>
<PRE>
      ! Responsible party attributes (for Principal Investigator)
      call ESMF_AttributeSet(gridcomp, 'Name', 'John Doe', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'Abbreviation', 'JD', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'PhysicalAddress', &amp;
          'Department of Meteorology, University of ABC', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'EmailAddress', &amp;
                                       'john.doe@earthsys.org', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'ResponsiblePartyRole', 'PI', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'URL', 'www.earthsys.org', &amp;
        convention=convISO, purpose=purpRP, rc=rc)
</PRE>

<P>
Set the attribute values of the Citation sub-package, created above
      for the gridded Component in the ESMF_AttributeAdd(gridcomp, ...) call.

<P>
<PRE>
      ! Citation attributes
      call ESMF_AttributeSet(gridcomp, 'ShortTitle', 'Doe_2009', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'LongTitle', &amp;
       'Doe, J.A.; Norton, A.B.; ' // &amp;
       'Clark, G.H.; Davies, I.J.. 2009 EarthSys: ' // &amp;
       'The Earth System High Resolution Global Atmosphere Model - Model ' // &amp;
       'description and basic evaluation. Journal of Climate, 15 (2). ' // &amp;
       '1261-1296.', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'Date', '2010-03-15', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'PresentationForm', 'Online Refereed', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'DOI', 'doi:17.1035/2009JCLI4508.1', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
      call ESMF_AttributeSet(gridcomp, 'URL', &amp;
                             'http://www.earthsys.org/publications', &amp;
        convention=convISO, purpose=purpCitation, rc=rc)
</PRE>

<P>
The standard Attribute package currently supplied by ESMF for 
       CIM Fields contains a standard CF-Extended package nested within it.

<P>
<PRE>
      ! ozone CF-Extended Attributes
      call ESMF_AttributeSet(ozone, 'ShortName', 'Global_O3_mon', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'StandardName', 'ozone', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'LongName', 'ozone', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'Units', 'unknown', &amp;
       convention=convCIM, purpose=purpField, rc=rc)

      ! ozone CIM Attributes
      call ESMF_AttributeSet(ozone, 'CouplingPurpose', 'Boundary', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'CouplingSource', 'EarthSys_Atmos', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'CouplingTarget', 'EarthSys_AtmosDynCore', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'Description', &amp;
                                    'Global Ozone concentration ' // &amp;
                                    'monitoring in the atmosphere.', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'SpatialRegriddingMethod', &amp;
                                    'Conservative-First-Order', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'SpatialRegriddingDimension', '3D', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'Frequency', '15 Minutes', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
      call ESMF_AttributeSet(ozone, 'TimeTransformationType', &amp;
                                    'TimeInterpolation', &amp;
       convention=convCIM, purpose=purpField, rc=rc)
</PRE>

<P>
Adding the Field to the State will automatically link the 
       Attribute hierarchies from the State to the Field

<P>
<PRE>
      ! Add the Field directly to the State
      call ESMF_StateAdd(exportState, fieldList=(/ozone/), rc=rc)
</PRE>

<P>
The Attribute link between a Component and a State must be set manually.

<P>
<PRE>
      ! Link the State to the gridded Component
      call ESMF_AttributeLink(gridcomp, exportState, rc=rc)
</PRE>

<P>
Write the entire CIM Attribute hierarchy, beginning at the gridded
       Component (the top), to an XML file formatted to conform to CIM
       specifications.  The CIM output tree structure differs from the
       internal Attribute hierarchy in that it has all the attributes of
       the fields within its top-level &lt;modelComponent&gt; record.  The filename
       used, gridded_component.xml, is derived from the name of the gridded
       Component, given as an input argument in the ESMF_GridCompCreate()
       call above.  The file is written to the examples execution directory.

<P>
<PRE>
      call ESMF_AttributeWrite(gridcomp, convCIM, purpComp, &amp;
        attwriteflag=ESMF_ATTWRITE_XML,rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION06026600000000000000">
35.6.6 Read an XML file-based ESG Attribute package for a Gridded Component</A>
</H3>
   This example shows how to read an ESG Attribute Package for a Gridded
   Component from an XML file.  The XML file contains Attribute values filled-in
   by the user.  The standard ESG Component Attribute Package is supplied with
   ESMF and is defined in an XSD file, which is used to validate the XML file.
   See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Superstructure/Component/etc/esmf_gridcomp.xml (Attribute Package values) and
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Superstructure/Component/etc/esmf_comp.xsd (Attribute Package definition).
   
</DD>
</DL> 

<P>
<PRE>
      ! ESMF Framework module
      use ESMF
      implicit none

      ! local variables
      type(ESMF_GridComp)    :: gridcomp
      character(ESMF_MAXSTR) :: attrvalue
      type(ESMF_VM)          :: vm
      integer                :: rc, petCount, localPet
</PRE>

<P>
<PRE>
      ! initialize ESMF
      call ESMF_Initialize(vm=vm, defaultlogfilename="AttReadGridCompEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! get the vm
      call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=rc)
</PRE>

<P>
<PRE>
      if (petCount&lt;4) then
        gridcomp = ESMF_GridCompCreate(name="gridcomp", &amp;
          petList=(/0/), rc=rc)
      else
        gridcomp = ESMF_GridCompCreate(name="gridcomp", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
<PRE>
      ! Read an XML file to populate the ESG Attribute package of a GridComp.
      ! The file is validated against an internal, ESMF-supplied XSD file
      ! defining the standard ESG Component Attribute package (see file
      ! pathnames above).
      call ESMF_AttributeRead(comp=gridcomp, fileName="esmf_gridcomp.xml", &amp;
          rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "ComponentShortName" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='ComponentShortName', &amp;
                             value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "ComponentLongName" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='ComponentLongName', &amp;
                             value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Agency" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Agency', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Institution" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Institution', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Version" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Version', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Author" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Author', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "Discipline" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='Discipline', value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "PhysicalDomain" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='PhysicalDomain', &amp;
                             value=attrValue, convention='ESG', &amp;
                             purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "CodingLanguage" Attribute from a GridComp Test
      call ESMF_AttributeGet(gridcomp, name='CodingLanguage', &amp;
                             value=attrValue,  convention='ESG', &amp;
                             purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get ESG "ModelComponentFramework" Attribute from a GridComp
      call ESMF_AttributeGet(gridcomp, name='ModelComponentFramework', &amp;
                             value=attrValue, &amp;
                             convention='ESG', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridCompDestroy(gridcomp, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION06026700000000000000">
35.6.7 Read an XML file-based CF Attribute package for a Field</A>
</H3>
   This example shows how to read a CF Attribute Package for a Field from an
   XML file.  The XML file contains Attribute values filled-in by the user.
   The standard CF Attribute Package is supplied with ESMF and is defined in
   an XSD file, which is used to validate the XML file.  See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Field/etc/esmf_field.xml (Attribute Package values) and
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Field/etc/esmf_field.xsd (Attribute Package definition).
   
</DD>
</DL> 

<P>
<PRE>
      ! ESMF Framework module
      use ESMF
      implicit none

      ! local variables
      type(ESMF_Field)       :: field
      character(ESMF_MAXSTR) :: attrvalue
      type(ESMF_VM)          :: vm
      integer                :: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF
      call ESMF_Initialize(vm=vm, defaultlogfilename="AttReadFieldEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! Create a field
      field = ESMF_FieldEmptyCreate(name="field", rc=rc)
</PRE>

<P>
<PRE>
      ! Read an XML file to populate the CF Attribute package of a Field.
      ! The file is validated against an internal, ESMF-supplied XSD file
      ! defining the standard CF Attribute package (see file pathnames above).
      call ESMF_AttributeRead(field=field, fileName="esmf_field.xml", rc=rc)
</PRE>

<P>
<PRE>
      ! Get CF "ShortName" Attribute from a Field
      call ESMF_AttributeGet(field, name='ShortName', value=attrValue, &amp;
                             convention='CF', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get CF "StandardName" Attribute from a Field
      call ESMF_AttributeGet(field, name='StandardName', &amp;
                             value=attrValue, &amp;
                             convention='CF', purpose='Extended', rc=rc)
</PRE>

<P>
<PRE>
      ! Get CF "LongName" Attribute from a Field
      call ESMF_AttributeGet(field, name='LongName', value=attrValue, &amp;
                             convention='CF', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get CF "Units" Attribute from a Field
      call ESMF_AttributeGet(field, name='Units', value=attrValue, &amp;
                             convention='CF', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_FieldDestroy(field, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION06026800000000000000">
35.6.8 Read an XML file-based GridSpec Attribute package for a Grid</A>
</H3>
   This example shows how to read a GridSpec Attribute Package from an
   XML file.  The XML file contains Attribute values filled-in by the user.
   The standard GridSpec Attribute Package is supplied with ESMF and is defined
   in an XSD file, which is used to validate the XML file.  See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Grid/etc/esmf_grid.xml (Attribute Package values) and
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Grid/etc/esmf_grid.xsd (Attribute Package definition)
   
</DD>
</DL>

<P>
<PRE>
      ! ESMF Framework module
      use ESMF
      implicit none

      ! local variables
      type(ESMF_Grid)        :: grid
      character(ESMF_MAXSTR) :: attrvalue
      type(ESMF_VM)          :: vm
      integer                :: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF
      call ESMF_Initialize(vm=vm, &amp;
                    defaultlogfilename="AttReadGridEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! Create a grid
      grid = ESMF_GridEmptyCreate(rc=rc)
</PRE>

<P>
<PRE>
      ! Read an XML file to populate the GridSpec Attribute package of a Grid.
      ! The file is validated against an internal, ESMF-supplied XSD file
      ! defining the standard GridSpec Attribute package (see file pathnames
      ! above).
      call ESMF_AttributeRead(grid=grid, fileName="esmf_grid.xml", rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "GridType" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='GridType', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "CongruentTiles" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='CongruentTiles', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "NumberOfGridTiles" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='NumberOfGridTiles', &amp;
                             value=attrValue, convention='GridSpec', &amp;
                             purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "DimensionOrder" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='DimensionOrder', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "DiscretizationType" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='DiscretizationType', &amp;
                             value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "GeometryType" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='GeometryType', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "IsConformal" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='IsConformal', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "IsRegular" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='IsRegular', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "IsUniform" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='IsUniform', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "NorthPoleLocation" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='NorthPoleLocation', &amp;
                             value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "NumberOfCells" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='NumberOfCells', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "NX" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='NX', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "NY" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='NY', value=attrValue, &amp;
                             convention='GridSpec', purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      ! Get GridSpec "HorizontalResolution" Attribute from a Grid
      call ESMF_AttributeGet(grid, name='HorizontalResolution', &amp;
                             value=attrValue, convention='GridSpec', &amp;
                             purpose='General', rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_GridDestroy(grid, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION06026900000000000000">
35.6.9 Read and validate an XML file-based set of user-defined Attributes for a Coupler Component</A>
</H3>
   This example shows how to read and validate, from an XML and XSD file,
   respectively, a set of user-defined custom Attributes for a Coupler Component.
   See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Superstructure/Component/etc/custom_cplcomp.xml (Attribute values) and 
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Superstructure/Component/etc/custom_cplcomp.xsd (Attribute definitions)
   
</DD>
</DL> 

<P>
<PRE>
      ! ESMF Framework module
      use ESMF
      implicit none

      ! local variables
      type(ESMF_CplComp)     :: cplcomp
      character(ESMF_MAXSTR) :: attrvalue
      type(ESMF_VM)          :: vm
      integer                :: rc, petCount, localPet
</PRE>

<P>
<PRE>
      ! initialize ESMF
      call ESMF_Initialize(vm=vm, &amp;
                    defaultlogfilename="AttReadCustCplCompEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>
<PRE>
      ! get the vm
      call ESMF_VMGet(vm, petCount=petCount, localPet=localPet, rc=rc)
</PRE>

<P>
<PRE>
      if (petCount&lt;4) then
        cplcomp = ESMF_CplCompCreate(name="cplcomp", &amp;
          petList=(/0/), rc=rc)
      else
        cplcomp = ESMF_CplCompCreate(name="cplcomp", &amp;
          petList=(/0,1,2,3/), rc=rc)
      endif
</PRE>

<P>
<PRE>
      ! Read an XML file to decorate a Coupler Component with custom,
      ! user-defined attributes, and validate them against a corresponding
      ! XSD schema file (see file pathnames above).
      call ESMF_AttributeRead(comp=cplcomp, fileName="custom_cplcomp.xml", &amp;
                              schemaFileName="custom_cplcomp.xsd", rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute1" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute1', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute2" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute2', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute3" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute3', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute4" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute4', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      ! Get custom "MyAttribute5" from CplComp
      call ESMF_AttributeGet(cplcomp, name='MyAttribute5', value=attrValue, &amp;
           rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CplCompDestroy(cplcomp, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION06027000000000000000">
35.7 Restrictions and Future Work</A>
</H2>

<P>

<H3><A NAME="SECTION06027100000000000000">
35.7.1 Attributes</A>
</H3>

<P>

<UL>
<LI>Case insensitive Attribute names, conventions, purposes, and values will be enabled in a future release.
</LI>
</UL>

<P>

<H3><A NAME="SECTION06027200000000000000">
35.7.2 Attribute packages</A>
</H3>

<P>

<UL>
<LI>A future capability may be to automatically create default object Attribute packages upon ESMF object creation.
</LI>
<LI>The implemention of Grids is still in flux within the CIM.  This will affect the final appearance of the Gridspec package in both ESMF and ESG. It is anticipated that an additional CIM Grid Attribute Package will be created.
</LI>
<LI>A CIM Scientific Property Attribute Package will be added. For CMIP5, hundreds of Scientific Properties have been identified. All of these will be added to ESMF. 
</LI>
<LI>The Attribute packages ISO Responsible Party, ISO Citation, and CIM Platform can only be created automatically within a CIM Main component Attribute package.  In a future release, it will be possible to create these within other CIM Attribute packages as required, or as separate, standalone packages.
</LI>
</UL>

<P>

<H3><A NAME="SECTION06027300000000000000">
35.7.3 Attribute hierarchies</A>
</H3>

<P>

<UL>
<LI>The option of "deep" copies of an Attribute hierarchy will be added.
</LI>
</UL>

<P>

<H3><A NAME="SECTION06027400000000000000">
35.7.4 Attribute import and export</A>
</H3>

<UL>
<LI>The CIM XML output in this release validates against the official CIM v1.5 release.  CIM development is continuing, with further releases expected.  ESMF, in its future releases, will conform to these future CIM releases.
</LI>
<LI>The CIM XML output format, as described above, is currently ingestable into ESG. However, ESG, like CIM, is in flux with active development.  When ESG officially releases, future releases of ESMF will be compatible with it.  The goal is for all three of ESMF, ESG, and CIM to be compatible with each other.
</LI>
<LI>Only the CIM XML format is targeted for ingestion by ESG, not ESMF XML nor tab-delimited.
</LI>
<LI>CIM Attribute packages can only be output (to CIM XML); they may be inputtable (via XML) in a future release.
</LI>
<LI>The ESMF grid Attribute package XML output file only contains the nested GridSpec Attributes; Attributes RegDecompX and RegDecompY will be added in a future release. 
</LI>
</UL>

<P>

<H2><A NAME="SECTION06028000000000000000">
35.8 Design and Implementation Notes</A>
</H2>

<P>
This section covers Attribute memory deallocation, the use of <TT>ESMF_AttributeGet()</TT>, Attribute package nesting capabilities, issues with Attributes in a distributed environment, and reading/writing of Attributes via XML files.  Issues and procedures dealing with Attribute memory deallocation, using <TT>ESMF_AttributeGet()</TT> to retrieve Attribute lists, and nested Attribute package capabilities are discussed to help avoid misuse.  The limitations with Attributes in a distributed environment are also discussed, with an outline of the future work to be done in this area. 

<P>

<H3><A NAME="SECTION06028100000000000000">
35.8.1 Attribute memory deallocation</A>
</H3>

<P>
The Attribute class presents a somewhat different paradigm with respect to memory deallocation than other ESMF objects.  The <TT>ESMF_AttributeRemove()</TT> call can be issued to remove any Attribute from an ESMF object or an Attribute package on an ESMF object.  This call is also enabled to remove entire Attribute packages with one call, which would remove any nested Attribute packages as well.  The user is <B>not</B> required to remove all Attributes that are used in a model run.  The entire Attribute hierarchy will be removed automatically by ESMF, provided the ESMF objects which contain them are properly destroyed.  

<P>
The decision to remove either an Attribute or an Attribute package is made by calling <TT>ESMF_AttributeRemove()</TT> with the correct optional arguments.  If an Attribute which is not associated with any Attribute package should be removed, then the call must be issued without a convention or purpose argument.  If an Attribute in an Attribute package is to be removed, then the call should be issued with all three of name, convention, and purpose.  Finally, if an entire Attribute package is to be removed the call should be issued with a convention and purpose, but no Attribute name.

<P>

<H3><A NAME="SECTION06028200000000000000">
35.8.2 Using <TT>ESMF_AttributeGet()</TT> to retrieve Attribute lists</A>
</H3>

<P>
The behavior of the <TT>ESMF_AttributeGet()</TT> routine, when retrieving an Attribute containing a value list, follows a slightly different convention than other similar ESMF routines.  This routine requires the input of a Fortran array as a place to store the retrieved values of the Attribute list.  If the array that is given is longer that the list of Attribute values, the first part of the array will be filled, leaving the extra space untouched.  If, however, the array passed in is shorter than the number of Attribute values, the routine will exit with a return code which is not equal to <B>ESMF_SUCCESS</B>.  It is suggested that if it is required by the user to use a Fortran array that is longer than the number of Attribute values returned, only the indices of the array which the user desires to be filled with retrieved Attribute values should be passed into the routine.  

<P>
Similar behavior is exhibited with the <TT>defaultvalueList</TT> argument in the <TT>ESMF_AttributeGet()</TT> routine.  The difference here is that if the <TT>valueList</TT> is shorter than the <TT>defaultvalueList</TT> only the appropriate values will be filed in, and the routine will exit without error.  Likewise, if the <TT>valueList</TT> is longer than the <TT>defaultvalueList</TT> then the entire <TT>valueList</TT> will be populated with the beginning section of the <TT>defaultvalueList</TT> that is given.

<P>

<H3><A NAME="SECTION06028300000000000000">
35.8.3 Using Attribute package nesting capabilites</A>
</H3>

<P>
There is a recommended practice to organizing metadata conventions when using nested Attribute packages.  The most general Attribute packages should always be added first, followed by the more specific ones.  For instance, when adding Attribute packages to a Field, it is recommended that the CF convention be added first, followed by the ESG convention, followed by any additional customized Attribute packages.  

<P>
At this time there are several ESMF supplied Attribute packages, with a convention of ESMF and a purpose of General.  These Attribute packages are generated by calling <TT>ESMF_AttributeAdd()</TT> with the appropriate convention and purpose.  The ESMF standard Attribute packages can be customized by nesting a custom Attribute package around them; they can also be modified in other ways but this is not suggested practice at this time.

<P>
Another consideration when using nested Attribute packages is to remember that when a nested Attribute package is removed every nested Attribute package below the point of removal will also be removed (like pruning a tree branch).  Thus, by removing the ESG Attribute package on a Field, the CF Attribute package contained within it will also be removed.

<P>

<H3><A NAME="SECTION06028400000000000000"></A>
<A NAME="sec:Att:Dist"></A>
<BR>
35.8.4 Attributes in a distributed environment
</H3>

<P>
This section discusses the methods of building a consistent view of the metadata across the VM of a model run.  To better explain the ESMF capabilities for ensuring the integrity of Attributes in a distributed environment, a small working vocabulary of ESMF Attributes will be presented.  Three types of changes to an Attribute hierarchy need to be specified, these are: 1. <B>link changes</B> are structural links created when two separate Attribute hierarchies are linked, 2. <B>structural changes</B> are changes which occur when Attributes or Attribute packages are added or removed within a single level of an Attribute hierarchy, and 3. <B>value changes</B> occur when the value portion of any single Attribute is modified.  These definitions will help to describe how <TT>ESMF_StateReconcile()</TT> and <TT>ESMF_AttributeUpdate()</TT> can be effectively used to ensure a consistent view of the metadata throughout a model run.

<P>
The <TT>ESMF_StateReconcile()</TT> call is used to create a consistent view of ESMF objects over the entire VM in the initialization phase of a model run.  All Attributes that are attached to an ESMF object contained in the State, i.e. an object that is being reconciled, can also be reconciled.  This is done by setting a flag in the <TT>ESMF_StateReconcile()</TT> call, see the State documentation for details.  This means that, at the conclusion of <TT>ESMF_StateReconcile()</TT> there is a one-to-one correspondence between Attribute hierarchies and the ESMF objects they represent.  This is the only place where link changes in an Attribute hierarchy can be resolved.

<P>
The <TT>ESMF_AttributeUpdate()</TT> call can be used any time during the run phase of a model to insure that either structural or value changes made to an Attribute hierarchy on a subset of the VM are consistently represented across the remainder of the VM.  At this time, link changes cannot be resolved by <TT>ESMF_AttributeUpdate()</TT> as this would represent a departure from the one-to-one correspondence between the Attribute hierarchy and the ESMF objects it represents.  

<P>
This call is similar to <TT>ESMF_StateReconcile()</TT> in that it must be called from a location that has a view of the entire VM across which to update the Attribute hierarchy, such as a coupler Component.  The main difference is that <TT>ESMF_AttributeUpdate()</TT> operates only on the underlying Attribute hierarchy of the given ESMF object.  The Attribute hierarchy may be updated as many times as necessary, this call is much more efficient than <TT>ESMF_StateReconcile()</TT> for this reason.  

<P>
The specification of a list of PETs that are to be used as the basis for the update is a key feature of this interface.  This allows a many-to-many communication, as well as the direct specification of which PETs are to be updated and which are to be used as the "real" values.  One caveat with this routine is that upon completion the destination PETs will have all of the missing Attributes from the source PETs, but this is not true the other way around.  This basically boils down to the fact that the end product of calling <TT>ESMF_AttributeUpdate()</TT> is <I>not</I> the union of the Attributes on both source and destination PETs.  This can be achieved, however, by calling <TT>ESMF_AttributeUpdate()</TT> twice, once from source to destination, and then again from destination to source.

<P>

<H3><A NAME="SECTION06028500000000000000">
35.8.5 Writing Attribute packages to file</A>
</H3>

<P>
The <TT>ESMF_AttributeWrite()</TT> interface is in limited form at the present time, as it can only be used reliably on the ESMF standard Attribute packages.  Chances are that it will perform as expected for most Attribute packages, but for now it is only guaranteed for the ESMF standard Attribute packages.  This routine is also not yet enabled to handle multi-valued Attributes.    One thing to remember when using this interface is that if you are writing an Attribute package that contains nested Attribute packages then all Attribute nested below the top level Attribute package will be written.

<P>

<H3><A NAME="SECTION06028600000000000000"></A>
<A NAME="sec:Att:Copy"></A>
<BR>
35.8.6 Copying Attribute hierarchies
</H3>

<P>
The ability to copy an Attribute hierarchy is limited at this time.  The <TT>ESMF_AttributeCopy()</TT> routine can be used to <I>locally</I> copy an Attribute hierarchy between two States or Components.  It is important to note that this is a local copy, and no inter-PET communication is carried out.  Another thing to note is that when this functionality is based on a reference copy any further changes made to some portions of the original Attribute hierarchy will also affect the new Attribute hierarchy.

<P>
There are two flags in the <TT>ESMF_AttributeCopy()</TT> routine which specify which type of copy is desired.  At this point there are only two different varieties of Attribute hierarchy copies available.  One of the requires the <TT>ESMF_Copy_Flag</TT> to be set to <TT>ESMF_COPY_VALUE</TT> and the <TT>ESMF_AttTreeFlag</TT> to be set to <TT>ESMF_ATTTREE_OFF</TT>.  This does a copy of only the first level of an Attribute hierarchy, by value.

<P>
The second available copy can be applied by setting the <TT>ESMF_Copy_Flag</TT> to <TT>ESMF_COPY_ALIAS</TT> and the <TT>ESMF_AttTreeFlag</TT> to <TT>ESMF_ATTTREE_ON</TT>.  This copy is more of a hybrid approach of reference and value copies.  In this case the Attributes which <I>belong</I> to the object being copied are actually copied in full (by value), while the Attributes which are linked to the object being copied are referenced by a pointer (by reference).  This means that after copying an Attribute hierarchy from ESMF object A to ESMF object B with this approach, the changes made to the lower portion of either A or B's Attribute hierarchy will be reflected on <I>both</I> object A and object B.

<P>

<H3><A NAME="SECTION06028700000000000000"></A>
<A NAME="Att:Xerces"></A>
<BR>
35.8.7 Reading and writing Attributes from XML files
</H3>

<P>
The Xerces C++ library, v3.1.0 or better, is used to read and write XML files.  
More specifically, the SAX2 API is currently used, although future releases may 
also use the DOM API.  The Xerces C++ website is 
http://xerces.apache.org/xerces-c/.  For more details, see the 
"ESMF Users Guide", "Building and Installing the ESMF, Third Party Libraries,
Xerces".  Also please see the section on Attribute I/O,&nbsp;<A HREF="node5.html#io:attributeio">32.2</A>.


<P>

<H2><A NAME="SECTION06029000000000000000">
35.9 Object Model</A>
</H2>

<P>
Each Attribute contains a name-value pair in which the value can be any of several numeric, character, and logical types.  Each value type is implemented as a vector, and can hold one or several values.  The available ESMF Attribute value types include:

<P>
<A NAME="table:attTypes"></A>
<UL>
<LI><TT>ESMF_TYPEKIND_I4</TT>
</LI>
<LI><TT>ESMF_TYPEKIND_I8</TT>
</LI>
<LI><TT>ESMF_TYPEKIND_R4</TT>
</LI>
<LI><TT>ESMF_TYPEKIND_R8</TT>
</LI>
<LI><TT>ESMF_TYPEKIND_Logical</TT>
</LI>
<LI><TT>EMSF_TYPEKIND_Character</TT>
</LI>
</UL>

<P>
The other members of the Attribute class can be seen in Figure <A HREF="node6.html#fig:AttributeClassUML">27</A>  below, which shows a UML representation of the ESMF Attribute class.

<P>
In addition to a name, all Attributes within an Attribute package are identified by a convention, purpose, and the ESMF object type with which they are associated. These are additional strings that are initialized as empty until specified.

<P>
Also, all Attributes contain three vectors of pointers to other Attributes, which are empty until specified otherwise.  These vectors of Attribute pointers hold the Attributes, Attribute packages, and Attribute links.  This feature is what allows the Attribute class to self assemble complex structures for representing and organizing the metadata of an ESMF object hierarchy.

<P>
For a more detailed view of how Attribute packages and hierarchies are formed, see Figures <A HREF="node6.html#fig:AttributePackageUML">28</A> and <A HREF="node6.html#fig:AttributeHierarchyUML">29</A>, respectively.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:AttributeClassUML"></A><A NAME="50088"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 27:</STRONG>
The structure of the Attribute class</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><IMG
 WIDTH="304" HEIGHT="671" ALIGN="BOTTOM" BORDER="0"
 SRC="img96.png"
 ALT="\includegraphics[]{AttributeClassUML}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:AttributePackageUML"></A><A NAME="50093"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 28:</STRONG>
The internal object organization for the representation of Attribute packages</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><IMG
 WIDTH="632" HEIGHT="690" ALIGN="BOTTOM" BORDER="0"
 SRC="img97.png"
 ALT="\includegraphics[width=5.5in,height=6in]{AttributePackageUML}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:AttributeHierarchyUML"></A><A NAME="50098"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 29:</STRONG>
The internal object organization for the representation of Attribute hierarchies</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><IMG
 WIDTH="633" HEIGHT="690" ALIGN="BOTTOM" BORDER="0"
 SRC="img98.png"
 ALT="\includegraphics[width=5.5in,height=6in]{AttributeHierarchyUML}">
</DIV></TD></TR>
</TABLE>
</DIV>


<P>

<H2><A NAME="SECTION060210000000000000000">
35.10 Class API</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060210100000000000000">
35.10.1 ESMF_AttributeAdd - Add an ESMF standard Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackStd(&lt;object&gt;, convention, purpose, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add an ESMF standard Attribute package. See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A>
   for a description of Attribute packages and their conventions, purposes,
   and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the new Attribute package
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the new Attribute package
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060210200000000000000">
35.10.2 ESMF_AttributeAdd - Add an ESMF standard Attribute package, containing nested standard Attribute packages</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackStdN(&lt;object&gt;, convention, purpose, &amp;
   nestConvention, nestPurpose, nestAttPackInstanceCountList, &amp;
   nestAttPackInstanceNameList, nestCount, &amp;
   nestAttPackInstanceNameCount,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   character (len = *), intent(in) :: nestConvention(:)
   character (len = *), intent(in) :: nestPurpose(:)
   integer, intent(in) :: nestAttPackInstanceCountList(:)
   character (len = *), intent(out) :: nestAttPackInstanceNameList(:)
   integer, intent(in), optional :: nestCount
   integer, intent(out), optional :: nestAttPackInstanceNameCount
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add an ESMF standard Attribute package which contains a user-specified
   number of nested standard Attribute packages. ESMF generates and returns
   default instance names for the nested Attribute packages. These names
   can be used later to distinguish among multiple nested Attribute
   packages of the same type in calls to <TT>ESMF_AttributeGet()</TT>,
   <TT>ESMF_AttributeSet()</TT>, and <TT>ESMF_AttributeRemove()</TT>.
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the new Attribute package
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the new Attribute package
   
</DD>
<DT><STRONG>nestConvention</STRONG></DT>
<DD>The convention(s) of the standard Attribute package(s) around
   which to nest the new Attribute package
   
</DD>
<DT><STRONG>nestPurpose</STRONG></DT>
<DD>The purpose(s) of the standard Attribute package(s) around
   which to nest the new Attribute package
   
</DD>
<DT><STRONG>nestAttPackInstanceCountList</STRONG></DT>
<DD>The desired number of nested Attribute package instances for each
   nested (nestConvention, nestPurpose) package type. Note: if only one
   of each nested package type is desired, then the
   <TT>ESMF_AttributeAdd()</TT> overloaded method
   <TT>ESMF_AttAddPackStd()</TT> should be used.
   
</DD>
<DT><STRONG>nestAttPackInstanceNameList</STRONG></DT>
<DD>The name(s) of the nested Attribute package instances, generated
   by ESMF, used to distinguish between multiple instances of the
   same convention and purpose.
   
</DD>
<DT><STRONG>[nestCount]</STRONG></DT>
<DD>The count of the number of nested Attribute package types to add to
   the new Attribute package.
   
</DD>
<DT><STRONG>[nestAttPackInstanceNameCount]</STRONG></DT>
<DD>The number of nested Attribute package instance names.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060210300000000000000">
35.10.3 ESMF_AttributeAdd - Add a custom Attribute package or modify an existing Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackCst(&lt;object&gt;, convention, purpose, &amp;
   attrList, count, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   character (len=*), intent(in) :: attrList(:)
   integer, intent(in), optional :: count
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a custom Attribute package to &lt;object&gt;.
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>attrList</STRONG></DT>
<DD>The list of Attribute names to specify the custom Attribute package
   
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>The number of Attributes to add to the custom Attribute package
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060210400000000000000">
35.10.4 ESMF_AttributeAdd - Add a custom Attribute package with nested Attribute Packages or modify an existing Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackCstN(&lt;object&gt;, convention, purpose, &amp;
   attrList, count, nestConvention, nestPurpose, nestCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: convention
   character (len = *), intent(in) :: purpose
   character (len=*), intent(in), optional :: attrList(:)
   integer, intent(in), optional :: count
   character (len = *), intent(in) :: nestConvention(:)
   character (len = *), intent(in) :: nestPurpose(:)
   integer, intent(in), optional :: nestCount
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a custom Attribute package, with one or more nested Attribute
   packages, to &lt;object&gt;. Allows for building full multiple-child Attribute
   hierarchies (multi-child trees).
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attrList]</STRONG></DT>
<DD>The list of Attribute names to specify the custom Attribute package
   
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>The number of Attributes to add to the custom Attribute package
   
</DD>
<DT><STRONG>nestConvention</STRONG></DT>
<DD>The convention(s) of the Attribute package(s) around which to nest
   the new Attribute package
   
</DD>
<DT><STRONG>nestPurpose</STRONG></DT>
<DD>The purpose(s) of the Attribute package(s) around which to nest the
   new Attribute package
   
</DD>
<DT><STRONG>[nestCount]</STRONG></DT>
<DD>The number of nested Attribute packages to add to the custom
   Attribute package
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060210500000000000000">
35.10.5 ESMF_AttributeAdd - Add a custom Attribute package with a single nested Atrribute package, or modify an existing Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeAdd()
   subroutine ESMF_AttAddPackCstN1(&lt;object&gt;, convention, purpose, &amp;
   attrList, count, nestConvention, nestPurpose, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len=*), intent(in) :: convention
   character (len=*), intent(in) :: purpose
   character (len=*), intent(in), optional :: attrList(:)
   integer, intent(in), optional :: count
   character (len=*), intent(in) :: nestConvention
   character (len=*), intent(in) :: nestPurpose
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a custom Attribute package, with a single nested Attribute
   package, to &lt;object&gt;. Allows for building single-child Attribute
   hierarchies (single-child trees).
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attrList]</STRONG></DT>
<DD>The list of Attribute names to specify the custom Attribute package
   
</DD>
<DT><STRONG>[count]</STRONG></DT>
<DD>The number of Attributes to add to the custom Attribute package
   
</DD>
<DT><STRONG>nestConvention</STRONG></DT>
<DD>The convention of the Attribute package around which to nest
   the new Attribute package
   
</DD>
<DT><STRONG>nestPurpose</STRONG></DT>
<DD>The purpose of the Attribute package around which to nest the
   new Attribute package
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060210600000000000000">
35.10.6 ESMF_AttributeCopy - Copy an Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeCopy()
   subroutine ESMF_AttributeCopy(&lt;object1&gt;, &lt;object2&gt;, copyflag, &amp;
   atttreeflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object1&gt;, see below for supported values
   &lt;object2&gt;, see below for supported values
   type(ESMF_Copy_Flag), intent(in) :: copyflag
   type(ESMF_AttTreeFlag), intent(in) :: atttreeflag
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Copy an Attribute hierarchy from &lt;object1&gt; to &lt;object2&gt;.
   Supported values for &lt;object1&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>
   Supported values for &lt;object2&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
NOTE: Copies between different ESMF objects are not possible at this time.

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object1&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>&lt;object2&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>copyflag</STRONG></DT>
<DD>A flag to determine if the copy is to be by reference, value,
   or both. This flag is documented in section <A HREF="node2.html#const:copy">9.11</A>.
   
</DD>
<DT><STRONG>atttreeflag</STRONG></DT>
<DD>A flag to determine if the copy is supposed to descend the
   Attribute hierarchy. This flag is documented in section <A HREF="node6.html#const:atttree">35.5.2</A>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060210700000000000000">
35.10.7 ESMF_AttributeGet - Get an Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, &lt;value argument&gt;, &amp;
   &lt;defaultvalue argument&gt;, convention, purpose, &amp;
   attPackInstanceName, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;value argument&gt;, see below for supported values
   &lt;defaultvalue argument&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>value</TT> from the &lt;object&gt;, or from an Attribute
   package on the &lt;object&gt;, specified by <TT>convention</TT> and <TT>purpose</TT>,
   and optionally <TT>attPackInstanceName</TT>. A <TT>defaultvalue</TT> argument
   may be given if a return code is not desired when the Attribute is not
   found. See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute
   packages and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>
   Supported values for &lt;value argument&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: value
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(out) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out) :: value
   
</DD>
<DT></DT>
<DD>logical, intent(out) :: value
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out), value
   
</DD>
</DL>
   Supported values for &lt;defaultvalue argument&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(out), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>logical, intent(out), optional :: defaultvalue
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out), optional :: defaultvalue
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve
   
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>The value of the named Attribute
   
</DD>
<DT><STRONG>[&lt;defaultvalue argument&gt;]</STRONG></DT>
<DD>The default value of the named Attribute
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one of
   multiple Attribute package instances of the same convention and
   purpose, within a nest. If not specified, defaults to the first
   instance.
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060210800000000000000">
35.10.8 ESMF_AttributeGet - Get an Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeGet(&lt;object&gt;, name, &lt;valueList argument&gt;, &amp;
   &lt;defaultvalueList argument&gt;, convention, purpose, &amp;
   attPackInstanceName, itemCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;valueList argument&gt;, see below for supported values
   &lt;defaultvalueList argument&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return an Attribute <TT>valueList</TT> from the &lt;object&gt;, or from an
   Attribute package on the &lt;object&gt;, specified by <TT>convention</TT> and
   <TT>purpose</TT>, and optionally <TT>attPackInstanceName</TT>.
   A <TT>defaultvalueList</TT> list argument may be given if
   a return code is not desired when the Attribute is not found.
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>
   Supported values for &lt;value argument&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(out) :: valueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out) :: valueList(:)
   
</DD>
</DL>
   Supported values for &lt;defaultvalue argument&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(out), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(out), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(out), optional :: defaultvalueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(out), optional :: defaultvalueList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to retrieve
   
</DD>
<DT><STRONG>&lt;valueList argument&gt;</STRONG></DT>
<DD>The valueList of the named Attribute
   
</DD>
<DT><STRONG>[&lt;defaultvalueList argument&gt;]</STRONG></DT>
<DD>The default value list of the named Attribute
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one of
   multiple Attribute package instances of the same convention and
   purpose, within a nest. If not specified, defaults to the first
   instance. (Not implemented yet)
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in a multi-valued Attribute
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060210900000000000000">
35.10.9 ESMF_AttributeGet - Get the Attribute count</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetCount(&lt;object&gt;, count, attcountflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   integer, intent(out) :: count
   type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return the Attribute count for &lt;object&gt;.
   Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>The Attribute count for &lt;object&gt;
   
</DD>
<DT><STRONG>[attcountflag]</STRONG></DT>
<DD>The flag to specify which attribute count to return, the
   default is ESMF_ATTGETCOUNT_ATTRIBUTE. This flag is documented
   in section <A HREF="node6.html#const:attgetcount">35.5.1</A>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101000000000000000">
35.10.10 ESMF_AttributeGet - Get Attribute info by name</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetInfoByNam(&lt;object&gt;, name, &amp;
   convention, purpose, &amp;
   attPackInstanceName, typekind, &amp;
   itemCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   character (len=*), intent(in), optional :: convention
   character (len=*), intent(in), optional :: purpose
   character (len=*), intent(in), optional :: attPackInstanceName
   type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
   integer, intent(out), optional :: itemCount
   logical, intent(out), optional :: isPresent
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Return information associated with the named Attribute,
   including <TT>typekind</TT> and <TT>itemCount</TT>.
   Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to query
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one of
   multiple Attribute package instances of the same convention and
   purpose, within a nest. (Not implemented yet)
   
</DD>
<DT><STRONG>[typekind</STRONG></DT>
<DD>]
   The typekind of the Attribute
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in this Attribute
   
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>A logical flag to tell if this Attribute is present or not 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD><P>
Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101100000000000000">
35.10.11 ESMF_AttributeGet - Get Attribute info by index number</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetInfoByNum(&lt;object&gt;, attributeIndex, name, &amp;
   typekind, itemcount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   integer, intent(in) :: attributeIndex
   character (len = *), intent(out) :: name
   type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
   integer, intent(out), optional :: itemCount
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information associated with the indexed Attribute,
   including <TT>name</TT>, <TT>typekind</TT> and <TT>itemCount</TT>. Keep in
   mind that these indexes start from 1, as expected in a Fortran API.
   Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>attributeIndex</STRONG></DT>
<DD>The index number of the Attribute to query
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the Attribute
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in this Attribute
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101200000000000000">
35.10.12 ESMF_AttributeGet - Get Attribute package instance names</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeGet()
   subroutine ESMF_AttributeGetAPinstNames(&lt;object&gt;, convention, purpose, &amp;
   attPackInstanceNameList, attPackInstanceNameCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(out) :: attPackInstanceNameList(:)
   integer, intent(out) :: attPackInstanceNameCount
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get the Attribute package instance names of the specified convention
   and purpose. Also get the number of such names.
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>convention</STRONG></DT>
<DD>The convention of the Attribute package instances.
   
</DD>
<DT><STRONG>purpose</STRONG></DT>
<DD>The purpose of the Attribute package instances.
   
</DD>
<DT><STRONG>attPackInstanceNameList</STRONG></DT>
<DD>The name(s) of the Attribute package instances of the given
   convention and purpose.
   
</DD>
<DT><STRONG>attPackInstanceNameCount</STRONG></DT>
<DD>The number of Attribute package instance names.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101300000000000000">
35.10.13 ESMF_AttributeLink - Link a Component Attribute hierarchy to that of a Component or State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_CompAttLink(&lt;object1&gt;, &lt;object2&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object1&gt;, see below for supported values
   &lt;object2&gt;, see below for supported values
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach a <TT>CplComp</TT> or <TT>GridComp</TT> Attribute hierarchy to the
   hierarchy of a <TT>CplComp</TT>, <TT>GridComp</TT>, or <TT>State</TT>.
   Supported values for the &lt;object1&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp1
   
</DD>
</DL>
   Supported values for the &lt;object2&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object1&gt;</STRONG></DT>
<DD>The ``parent'' object in the Attribute hierarchy link
   
</DD>
<DT><STRONG>&lt;object2&gt;</STRONG></DT>
<DD>The ``child'' object in the Attribute hierarchy link
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101400000000000000">
35.10.14 ESMF_AttributeLink - Link a State Attribute hierarchy with the</A>
</H3>

<P>
hierarchy of a an Array, ArrayBundle, Field, FieldBundle, or State

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_StateAttLink(state, &lt;object&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF\_State), intent(inout) :: state
   &lt;object&gt;, see below for supported values
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach a <TT>State</TT> Attribute hierarchy to the hierarchy of
   a <TT>Fieldbundle</TT>, <TT>Field</TT>, or another <TT>State</TT>.
   Supported values for the &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> object
   
</DD>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>The object with which to link hierarchies
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101500000000000000">
35.10.15 ESMF_AttributeLink - Link a FieldBundle and Field Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_FieldBundleAttLink(fieldbundle, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
   type(ESMF\_Field), intent(inout) :: field
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach a <TT>FieldBundle</TT> Attribute hierarchy to the hierarchy of
   a <TT>Field</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object
   
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101600000000000000">
35.10.16 ESMF_AttributeLink - Link a Field and Grid Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_FieldAttLink(field, grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF\_Field), intent(inout) :: field
   type(ESMF\_Grid), intent(inout) :: grid
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach a <TT>Field</TT> Attribute hierarchy to the hierarchy of
   a <TT>Grid</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>An <TT>ESMF_Grid</TT> object
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101700000000000000">
35.10.17 ESMF_AttributeLink - Link an ArrayBundle and Array Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLink()
   subroutine ESMF_ArrayBundleAttLink(arraybundle, array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
   type(ESMF\_Array), intent(inout) :: array
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an <TT>ArrayBundle</TT> Attribute hierarchy to the hierarchy of
   an <TT>Array</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD>An <TT>ESMF_ArrayBundle</TT> object
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An <TT>ESMF_Array</TT> object
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101800000000000000">
35.10.18 ESMF_AttributeLinkRemove - Unlink a Component Attribute hierarchy from that of a Component or State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_CompAttLinkRemove(&lt;object1&gt;, &lt;object2&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object1&gt;, see below for supported values
   &lt;object2&gt;, see below for supported values
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach a <TT>CplComp</TT> or <TT>GridComp</TT> Attribute hierarchy from the
   hierarchy of a <TT>CplComp</TT>, <TT>GridComp</TT>, or <TT>State</TT>.
   Supported values for the &lt;object1&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp1
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp1
   
</DD>
</DL>
   Supported values for the &lt;object2&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp2
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object1&gt;</STRONG></DT>
<DD>The ``parent'' object in the Attribute hierarchy link
   
</DD>
<DT><STRONG>&lt;object2&gt;</STRONG></DT>
<DD>The ``child'' object in the Attribute hierarchy link
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602101900000000000000">
35.10.19 ESMF_AttributeLinkRemove - Unlink a State Attribute hierarchy with</A>
</H3>

<P>
the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_StateAttLinkRemove(state, &lt;object&gt;, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF\_State), intent(inout) :: state
   &lt;object&gt;, see below for supported values
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach a <TT>State</TT> Attribute hierarchy from the hierarchy of
   a <TT>Fieldbundle</TT>, <TT>Field</TT>, or another <TT>State</TT>.
   Supported values for the &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>state</STRONG></DT>
<DD>An <TT>ESMF_State</TT> object
   
</DD>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>The object with which to unlink hierarchies
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602102000000000000000">
35.10.20 ESMF_AttributeLinkRemove - Unlink a FieldBundle and Field Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_FieldBundleAttLinkRemove(fieldbundle, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
   type(ESMF\_Field), intent(inout) :: field
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach a <TT>FieldBundle</TT> Attribute hierarchy from the hierarchy of
   a <TT>Field</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object
   
</DD>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602102100000000000000">
35.10.21 ESMF_AttributeLinkRemove - Unlink a Field and Grid Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_FieldAttLinkRemove(field, grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF\_Field), intent(inout) :: field
   type(ESMF\_Grid), intent(inout) :: grid
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach a <TT>Field</TT> Attribute hierarchy from the hierarchy of
   a <TT>Grid</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>An <TT>ESMF_Grid</TT> object
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602102200000000000000">
35.10.22 ESMF_AttributeLinkRemove - Unlink an ArrayBundle and Array Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_AttributeLinkRemove()
   subroutine ESMF_ArrayBundleAttLinkRemove(arraybundle, array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
   type(ESMF\_Array), intent(inout) :: array
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Unattach an <TT>ArrayBundle</TT> Attribute hierarchy from the hierarchy of
   an <TT>Array</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD>An <TT>ESMF_ArrayBundle</TT> object
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An <TT>ESMF_Array</TT> object
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602102300000000000000">
35.10.23 ESMF_AttributeRead - Read Attributes from an XML file</A>
</H3>

<P>
<A NAME="api:AttributeRead"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeRead(&lt;object&gt;, fileName, schemaFileName, &amp;
   convention, purpose, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len=*), intent(in), optional :: fileName
   character (len=*), intent(in), optional :: schemaFileName
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Read Attributes for &lt;object&gt; from fileName, whose format is XML.
   schemaFileName format is XSD. If present, the schemaFileName is used to
   validate the contents of fileName. schemaFileName must be specified for
   a fileName containing custom, user-defined Attributes. schemaFileName
   need not be specified for convention and purposes specifying a standard,
   ESMF-supplied Attribute package. If present, the convention and purpose
   specify an Attribute package which is used to filter the reading to just
   those attributes belonging to the Attribute package.
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Requires the third party Xerces C++ XML Parser library to be installed,
   v3.1.0 or better. For more details, see the "ESMF Users Guide",
   "Building and Installing the ESMF, Third Party Libraries, Xerces" and
   the website
   <BR>
   "http://xerces.apache.org/xerces-c". Also please see the
   section on Attribute I/O,&nbsp;<A HREF="node5.html#io:attributeio">32.2</A>.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array ! not yet implemented
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arrayBundle ! not yet implemented
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: cplComp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: gridComp
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle ! not yet implemented
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distGrid ! not yet implemented
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>The <TT>ESMF</TT> object onto which the read Attributes will be placed
   
</DD>
<DT><STRONG>[fileName]</STRONG></DT>
<DD>The name of the XML file to read
   
</DD>
<DT><STRONG>[schemaFileName]</STRONG></DT>
<DD>The name of the XSD file to validate the contents of fileName
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package to read
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package to read
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602102400000000000000">
35.10.24 ESMF_AttributeRemove - Remove an Attribute or Attribute package</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeRemove(&lt;object&gt;, name, convention, purpose, &amp;
   attPackInstanceName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in), optional :: name
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Remove an Attribute, or Attribute package on &lt;object&gt;.
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of the Attribute to remove
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one of
   multiple Attribute package instances of the same convention and
   purpose, within a nest. If not specified, defaults to the first
   instance. (Not implemented yet)
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>
NOTE: An entire Attribute package can be removed by specifying
   <TT>convention</TT> and <TT>purpose</TT> only, without <TT>name</TT>. By specifying
   <TT>convention</TT>, <TT>purpose</TT>, and <TT>name</TT> an Attribute will be removed
   from the corresponding Attribute package, if it exists. An
   Attribute can be removed directly from &lt;object&gt; by specifying
   <TT>name</TT>, without <TT>convention</TT> and <TT>purpose</TT>.

<P>

<P>

<H3><A NAME="SECTION0602102500000000000000">
35.10.25 ESMF_AttributeSet - Set an Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeSet(&lt;object&gt;, name, &lt;value argument&gt;, &amp;
   convention, purpose, attPackInstanceName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;value argument&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an Attribute to &lt;object&gt;, or set an Attribute in an
   Attribute package. The Attribute has a <TT>name</TT> and <TT>value</TT>,
   and, if in an Attribute package, a <TT>convention</TT> and <TT>purpose</TT>,
   and optionally an <TT>attPackInstanceName</TT>.
   See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description of Attribute packages
   and their conventions, purposes, and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>
   Supported values for the &lt;value argument&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in) :: value
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in) :: value
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in) :: value
   
</DD>
<DT></DT>
<DD>logical, intent(in) :: value
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in), :: value
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to set
   
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>The value of the Attribute to set
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one of
   multiple Attribute package instances of the same convention and
   purpose, within a nest. If not specified, defaults to the first
   instance.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602102600000000000000">
35.10.26 ESMF_AttributeSet - Set an Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeSet(&lt;object&gt;, name, &lt;valueList argument&gt;, &amp;
   convention, purpose, attPackInstanceName, &amp;
   itemCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in) :: name
   &lt;valueList argument&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   character (len = *), intent(in), optional :: attPackInstanceName
   integer, intent(in), optional :: itemCount
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Attach an Attribute to &lt;object&gt;, or set an Attribute in an
   Attribute package. The Attribute has a <TT>name</TT> and a
   <TT>valueList</TT>, with an <TT>itemCount</TT>, and, if in an Attribute
   package, a <TT>convention</TT> and <TT>purpose</TT>, and optionally an
   <TT>attPackInstanceName</TT>. See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a
   description of Attribute packages and their conventions, purposes,
   and object types.

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_DistGrid), intent(inout) :: distgrid
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>
   Supported values for the &lt;value argument&gt; are:
   <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R4), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>real (ESMF_KIND_R8), intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>logical, intent(in) :: valueList(:)
   
</DD>
<DT></DT>
<DD>character (len = *), intent(in) :: valueList(:)
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>name</STRONG></DT>
<DD>The name of the Attribute to set
   
</DD>
<DT><STRONG>&lt;valueList argument&gt;</STRONG></DT>
<DD>The valueList of the Attribute to set
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attPackInstanceName]</STRONG></DT>
<DD>The name of an Attribute package instance, specifying which one of
   multiple Attribute package instances of the same convention and
   purpose, within a nest. If not specified, defaults to the first
   instance. (Not implemented yet)
   
</DD>
<DT><STRONG>[itemCount]</STRONG></DT>
<DD>The number of items in a multi-valued Attribute
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602102700000000000000">
35.10.27 ESMF_AttributeUpdate - Update an Attribute hierarchy</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeUpdate(&lt;object&gt;, vm, rootList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   type(ESMF_VM), intent(in) :: vm
   integer, intent(in) :: rootList(:)
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Update an Attribute hierarchy during runtime.
   Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>vm</STRONG></DT>
<DD>The virtural machine over which this Attribute hierarchy
   should be updated
   
</DD>
<DT><STRONG>rootList</STRONG></DT>
<DD>The list of ``root'' PETs that are to be used to update
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0602102800000000000000">
35.10.28 ESMF_AttributeWrite - Write an Attribute package</A>
</H3>

<P>
<A NAME="api:AttributeWrite"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_AttributeWrite(&lt;object&gt;, convention, purpose, &amp;
   attwriteflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;object&gt;, see below for supported values
   character (len = *), intent(in), optional :: convention
   character (len = *), intent(in), optional :: purpose
   type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write the Attribute package for &lt;object&gt;. The Attribute package defines
   the convention, purpose, and object type of the associated Attributes. Either
   tab-delimited or xml format is acheived by using <TT>attwriteflag</TT>.
   Currently, only ESMF/ESG/CF Field Attribute packages can be written in
   tab-delimited format. See Section&nbsp;<A HREF="node6.html#sec:AttPacks">35.2</A> for a description
   of Attribute packages and their conventions, purposes, and object types.

<P>
For xml output, requires the third party Xerces C++ XML Parser library
   to be installed, v3.1.0 or better. For more details, see the
   <I>ESMF Users Guide</I>, under the section <I>Building and Installing
   the ESMF, Third Party Libraries, Xerces</I> and the website
   "http://xerces.apache.org/xerces-c". Also please see the section on
   Attribute I/O,&nbsp;<A HREF="node5.html#io:attributeio">32.2</A>.

<P>
Note: For an object type of <TT>ESMF_GridComp</TT>, convention='WaterML',
   purpose='TimeSeries', and
   <BR>
attwriteflag=ESMF_ATTWRITE_XML, an XML file
   conforming to a hydrologic standard called WaterML will be written. See
   the following for more information:

<P>
<DL>
<DT></DT>
<DD>"http://his.cuahsi.org/wofws.html"
   
</DD>
<DT></DT>
<DD>"http://www.earthsystemcurator.org/projects/waterml.shtml"
   
</DD>
</DL>

<P>
An ESMF Use Test Case is available which showcases an example of how
   to write a WaterML file; please see

<P>
<DL>
<DT></DT>
<DD>"http://esmf.cvs.sourceforge.net/viewvc/esmf/use_test_cases/ESMF_WaterML"
   
</DD>
<DT></DT>
<DD>"http://esmf.cvs.sourceforge.net/viewvc/esmf/use_test_cases/README"
   
</DD>
</DL>

<P>
Supported values for &lt;object&gt; are:
   <DL>
<DT></DT>
<DD>type(ESMF_Array), intent(inout) :: array
   
</DD>
<DT></DT>
<DD>type(ESMF_ArrayBundle), intent(inout) :: arraybundle
   
</DD>
<DT></DT>
<DD>type(ESMF_CplComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_GridComp), intent(inout) :: comp
   
</DD>
<DT></DT>
<DD>type(ESMF_Field), intent(inout) :: field
   
</DD>
<DT></DT>
<DD>type(ESMF_FieldBundle), intent(inout) :: fieldbundle
   
</DD>
<DT></DT>
<DD>type(ESMF_Grid), intent(inout) :: grid
   
</DD>
<DT></DT>
<DD>type(ESMF_State), intent(inout) :: state
   
</DD>
</DL>

<P>
The arguments are:
   <DL>
<DT><STRONG>&lt;object&gt;</STRONG></DT>
<DD>An <TT>ESMF</TT> object
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of the Attribute package
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of the Attribute package
   
</DD>
<DT><STRONG>[attwriteflag]</STRONG></DT>
<DD>The flag to specify which format is desired for the write, the
   default is ESMF_ATTWRITE_TAB. This flag is documented in
   section <A HREF="node6.html#const:attwrite">35.5.3</A>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors
   
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION06030000000000000000">
36 Time Manager Utility</A>
</H1>
  
<P>
The ESMF Time Manager utility includes software for time and date 
representation and calculations, model time advancement, and the 
identification of unique and periodic events.  Since multi-component 
geophysical applications often require synchronization across
the time management schemes of the individual components, the 
Time Manager's standard calendars and consistent time representation 
promote component interoperability.
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Drift-free timekeeping through an integer-based internal time 
representation.  Both integers and reals can be specified at the interface.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>The ability to represent time as a rational fraction, to support 
exact timekeeping in applications that involve grid refinement.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for many calendar kinds, including user-customized calendars.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for both concurrent and sequential modes of component execution.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for varying and negative time steps.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A NAME="SECTION06031000000000000000">
36.1 Time Manager Classes</A>
</H2>
There are five ESMF classes that represent time concepts:

<UL>
<LI><B>Calendar</B>  A Calendar can be used to keep track of the 
date as an ESMF Gridded Component advances in time. Standard calendars 
(such as Gregorian and 360-day) and user-specified calendars are 
supported.  Calendars can be queried for quantities such as seconds 
per day, days per month, and days per year.  
</LI>
<LI><B>Time</B> A Time represents a time instant in a particular
calendar, such as November 28, 1964, at 7:31pm EST in the Gregorian 
calendar.  The Time class can be used 
to represent the start and stop time of a time integration.
</LI>
<LI><B>TimeInterval</B> TimeIntervals represent a period 
of time, such as 300 milliseconds.  Time steps can be represented 
using TimeIntervals.  
</LI>
<LI><B>Clock</B> Clocks collect the parameters and 
methods used for model time advancement into a convenient 
package.  A Clock can be queried for quantities such
as start time, stop time, current time, and time step.  Clock
methods include incrementing the current time, and determining
if it is time to stop.  
</LI>
<LI><B>Alarm</B> Alarms identify unique or periodic events
by ``ringing'' - returning a true value - at specified times.  
For example, an Alarm might be set to ring on the day of the 
year when leaves start falling from the trees in a climate model.
</LI>
</UL>

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="749" HEIGHT="215" ALIGN="BOTTOM" BORDER="0"
 SRC="img99.png"
 ALT="\includegraphics[]{TimeMgr_desc}">

</DIV>

<P>
In the remainder of this section, we briefly summarize the 
functionality that the Time Manager classes provide.  Detailed 
descriptions and usage examples precede the API listing for each 
class.

<P>

<H2><A NAME="SECTION06032000000000000000">
36.2 Calendar</A>
</H2>
An ESMF Calendar can be queried for seconds per day, days per month 
and days per year.  The flexible definition of Calendars allows them
to be defined for planetary bodies other than Earth.  The set of supported 
calendars includes:
<DL>
<DT><STRONG>Gregorian</STRONG></DT>
<DD>The standard Gregorian calendar.
</DD>
<DT><STRONG>no-leap</STRONG></DT>
<DD>The Gregorian calendar with no leap years.
</DD>
<DT><STRONG>Julian</STRONG></DT>
<DD>The standard Julian date calendar.
</DD>
<DT><STRONG>Julian Day</STRONG></DT>
<DD>The standard Julian days calendar.
</DD>
<DT><STRONG>Modified Julian Day</STRONG></DT>
<DD>The Modified Julian days calendar.
</DD>
<DT><STRONG>360-day</STRONG></DT>
<DD>A 30-day-per-month, 12-month-per-year calendar.
</DD>
<DT><STRONG>no calendar</STRONG></DT>
<DD>Tracks only elapsed model time in hours, minutes, seconds.
</DD>
</DL>
See Section&nbsp;<A HREF="node6.html#sec:Calendar">37.1</A> for more details on supported standard 
calendars, and how to create a customized ESMF Calendar.

<P>

<H2><A NAME="SECTION06033000000000000000">
36.3 Time Instants and TimeIntervals</A>
</H2>

<P>
<A NAME="subsec:Time_Instants_and_TimeIntervals"></A>TimeIntervals and Time instants (simply called Times) are the computational 
building blocks of the Time Manager utility.  TimeIntervals support operations
such as add, subtract, compare size, reset value, copy value, and subdivide
by a scalar.  Times, which are moments in time associated with specific
Calendars, can be incremented or decremented by TimeIntervals, compared to
determine which of two Times is later, differenced to obtain the TimeInterval
between two Times, copied, reset, and manipulated in other useful ways.
Times support a host of different queries, both for values of individual Time 
components such as year, month, day, and second, and for derived values such 
as day of year, middle of current month and Julian day.  It is also possible 
to retrieve the value of the hardware realtime clock in the form of a 
Time.  See Sections&nbsp;<A HREF="node6.html#sec:Time">38.1</A> and&nbsp;<A HREF="node6.html#sec:TimeInterval">39.1</A>, respectively,
for use and examples of Times and TimeIntervals.

<P>
Since climate modeling, numerical weather prediction and other 
Earth and space applications have widely varying time scales and require 
different sorts of calendars, Times and TimeIntervals must support 
a wide range of time specifiers, spanning nanoseconds to years.  The
interfaces to these time classes are defined so that the user can specify a time
using a combination of units selected from the list shown in 
Table&nbsp;<A HREF="node6.html#table:timeOpts">36.4</A>.  

<P>

<H2><A NAME="SECTION06034000000000000000">
36.4 Clocks and Alarms</A>
</H2>
Although it is possible to repeatedly step a Time forward by a 
TimeInterval using arithmetic on these basic types, it is useful to 
identify a higher-level concept to represent this function.  We refer to 
this capability as a Clock, and include in its required features the 
ability to store the start and stop times of 
a model run, to check when time advancement should cease, 
and to query the value of quantities such as the current time and the
time at the previous time step.  The Time Manager includes a class 
with methods that return a true value when a periodic or unique event 
has taken place; we refer to these as Alarms.  Applications may contain 
temporary or multiple Clocks and Alarms.  Sections&nbsp;<A HREF="node6.html#sec:Clock">40.1</A> and
<A HREF="node6.html#sec:Alarm">41.1</A> describe the use of Clocks and Alarms in detail.

<P>

<P>

<A NAME="table:timeOpts"></A>
<DIV ALIGN="CENTER">
</DIV>
<BR><P></P>
<DIV ALIGN="CENTER">

<A NAME="51711"></A>
<TABLE CELLPADDING=3 BORDER="1">
<CAPTION><STRONG>Table 5:</STRONG>
Specifiers for Times and TimeIntervals</CAPTION>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72>Unit</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Meaning</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;yy|yy_i8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Year.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>mm</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Month of the year.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>dd</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Day of the month.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;d|d_i8|d_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Julian or Modified Julian day.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;h|h_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Hour.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;m|m_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Minute.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;s|s_i8|s_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Second.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;ms|ms_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Millisecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;us|us_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Microsecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;ns|ns_r8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Nanosecond.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>O</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Time zone offset in integer number of hours and minutes.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;sN|sN_i8&gt;</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Numerator for times of the form s <B><!-- MATH
 $+ 
\frac{{\rm sN}}{{\rm sD}}$
 -->
<IMG
 WIDTH="37" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img100.png"
 ALT="$ +
\frac{{\rm sN}}{{\rm sD}}$"></B>, where s is seconds and s, sN, and
sD are integers.  This format provides a mechanism for supporting
exact behavior.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=72><B>&lt;sD|sD_i8</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=252>Denominator for times of the form s <B><!-- MATH
 $+ 
\frac{{\rm sN}}{{\rm sD}}$
 -->
<IMG
 WIDTH="37" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img100.png"
 ALT="$ +
\frac{{\rm sN}}{{\rm sD}}$"></B>, where s is seconds and s, sN, and
sD are integers.</TD>
</TR>
</TABLE>
</DIV>
<BR>
<DIV ALIGN="CENTER">
</DIV>

<P>

<P>

<H2><A NAME="SECTION06035000000000000000">
36.5 Design and Implementation Notes</A>
</H2>

<OL>
<LI><B>Base TimeIntervals and Times on the same integer representation.</B> 
It is useful to allow both TimeIntervals and Times to 
inherit from a single class, BaseTime.  In C++, this can be
implemented by using inheritance.  In Fortran, it can be implemented
by having the derived types TimeIntervals and Times
contain a derived type BaseTime.  In both cases, the 
BaseTime class can be made private and invisible to the user.

<P>
The result of this strategy is that Time Intervals and 
Times gain a consistent core representation of time as well a set
of basic methods.

<P>
The BaseTime class can be designed with a minimum number of elements
to represent any required time.  The design is based on the idea used
in the real-time POSIX 1003.1b-1993 standard.  That is, to represent
time simply as a pair of integers: one for seconds (whole) and one for
nanoseconds (fractional).  These can then be converted at the interface
level to any desired format.

<P>
For ESMF, this idea can be modified and extended, in order to handle the
requirements for a large time range (&gt; 200,000 years) and to exactly
represent any rational fraction, not just nanoseconds.  To handle the
large time range, a 64-bit or greater integer is used for whole seconds.
Any rational fractional second is expressed using two additional integers:
a numerator and a denominator.  Both the whole seconds and fractional
numerator are signed to handle negative time intervals and instants.
For arithmetic consistency both must carry the same sign (both positve
or both negative), except, of course, for zero values.  The fractional
seconds element (numerator) is bounded with respect to whole seconds. 
If the absolute value of the
numerator becomes greater than or equal to the denominator, whole
seconds are incremented or decremented accordingly and the numerator is
reset to the remainder.  Conversions are performed upon demand by
interface methods within the TimeInterval and
Time classes.  This is done because different applications require different
representations of time intervals and time instances.  Floating point values as well as integers can be specified for the various time units in the interfaces, see Table&nbsp;<A HREF="node6.html#table:timeOpts">36.4</A>.  Floating point values are represented internally as integer-based rational fractions.

<P>
The BaseTime class defines increment and decrement methods for basic
TimeInterval calculations between Time instants.  It is done here rather
than in the Calendar class because it can be done with simple 
second-based arithmetic that is calendar independent.  

<P>
Comparison methods can also be defined in the BaseTime class.  These
perform equality/inequality, less than, and greater than comparisons
between any two TimeIntervals or Times.  These methods capture
the common comparison logic between TimeIntervals and Times and
hence are defined here for sharing.

<P>
</LI>
<LI><B>The Time class depends on a calendar.</B> The Time class contains 
an internal Calendar class.  
Upon demand by a user, the results of an increment or decrement operation are 
converted to user units, which may be calendar-dependent, via methods 
obtained from their internal Calendar.

<P>
</LI>
</OL>

<P>

<P>

<P>

<H2><A NAME="SECTION06036000000000000000">
36.6 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
Time Manager utility.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="749" HEIGHT="345" ALIGN="BOTTOM" BORDER="0"
 SRC="img101.png"
 ALT="\includegraphics[]{TimeMgr_obj}">   

</DIV>

<P>

<H1><A NAME="SECTION06040000000000000000">
37 Calendar Class</A>
</H1>

<P>

<H2><A NAME="SECTION06041000000000000000">
37.1 Description</A>
</H2>

<P>
<A NAME="sec:Calendar"></A>The Calendar class represents the standard calendars used in 
geophysical modeling:  Gregorian, Julian, Julian Day, Modified Julian Day, 
no-leap, 360-day, and no-calendar.  It also supports a user-customized 
calendar.  Brief descriptions are provided for each calendar below.  For more 
information on standard calendars, see&nbsp;[<A
 HREF="node8.html#Seidelman">21</A>] and&nbsp;[<A
 HREF="node8.html#Meyer1">15</A>].

<P>

<H2><A NAME="SECTION06042000000000000000">
37.2 Constants</A>
</H2>

<P>
<A NAME="subsec:Calendar_options"></A>
<P>

<H3><A NAME="SECTION06042100000000000000"></A>
<A NAME="const:calkindflag"></A>
<BR>
37.2.1 ESMF_CALKIND
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Supported calendar kinds.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_CalKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_CALKIND_360DAY</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
In the 360-day calendar, there are 12 months, each of which has 30 days.  
Like the no-leap calendar, this is a simple approximation to the Gregorian
calendar sometimes used by modelers.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_CUSTOM</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
The user can set calendar parameters in the generic calendar.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_GREGORIAN</STRONG></DT>
<DD><I>Valid range: 3/1/4801 BC to 10/29/292,277,019,914 </I>
<BR>
The Gregorian calendar is the calendar currently in use 
throughout Western countries.  Named after Pope Gregory XIII, it is a minor 
correction to the older Julian calendar. In the Gregorian calendar every
fourth year is a leap year in which February has 29 and not 28 days;
however, years divisible by 100 are not leap years unless they are also 
divisible  by 400.  As in the Julian calendar, days begin at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_JULIAN</STRONG></DT>
<DD><I>Valid range: 3/1/4713 BC to 4/24/292,271,018,333 </I> 
<BR>
The Julian calendar was introduced by Julius Caesar in 46 B.C., and 
reached its final form in 4 A.D.  The Julian calendar differs from the 
Gregorian only in the determination of leap years, lacking the correction 
for years divisible by 100 and 400 in the Gregorian calendar.  In the Julian 
calendar, any year is a leap year if divisible by 4.  Days are considered to 
begin at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_JULIANDAY</STRONG></DT>
<DD><I>Valid range:  +/- 1x10<IMG
 WIDTH="20" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img102.png"
 ALT="$^{14}$"></I> 
<BR>
Julian days simply enumerate the days and fraction of a day which 
have elapsed since the start of the Julian era, defined as beginning at noon 
on Monday, 1st January of year 4713 B.C. in the Julian calendar.  Julian days, 
unlike the dates in the Julian and Gregorian calendars, begin at noon.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_MODJULIANDAY</STRONG></DT>
<DD><I>Valid range:  +/- 1x10<IMG
 WIDTH="20" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img102.png"
 ALT="$^{14}$"></I>
<BR>
The Modified Julian Day (MJD) was introduced by space scientists in
 the late 1950's.  It is defined as an offset from the Julian Day (JD):

<P>
MJD = JD - 2400000.5

<P>
The half day is subtracted so that the day starts at midnight.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_NOCALENDAR</STRONG></DT>
<DD><I>Valid range: machine limits</I>
<BR>
The no-calendar option simply tracks the elapsed model time in seconds.

<P>
</DD>
<DT><STRONG>ESMF_CALKIND_NOLEAP</STRONG></DT>
<DD><I>Valid range: machine limits</I> 
<BR>
The no-leap calendar is the Gregorian calendar with no leap years - 
February is always assumed to have 28 days.  Modelers sometimes use this 
calendar as a simple, close approximation to the Gregorian calendar.

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION06043000000000000000">
37.3 Use and Examples</A>
</H2>

<P>
In most multi-component Earth system applications, the timekeeping in 
each component 
must refer to the same standard calendar in order for the components 
to properly synchronize.  It therefore makes sense to create as few 
ESMF Calendars as possible, preferably one per application.
A typical strategy would be to create a single Calendar at the start
of an application, and use that Calendar in all subsequent calls that
accept a Calendar, such as <TT>ESMF_TimeSet</TT>.

<P>
The following example shows how to set up an ESMF Calendar.  

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_CalendarEx - Calendar creation examples
!
! !DESCRIPTION:
!
! This program shows examples of how to create different calendar kinds
!-----------------------------------------------------------------------------

      ! ESMF Framework module
      use ESMF
      implicit none

      ! instantiate calendars
      type(ESMF_Calendar) :: gregorianCalendar
      type(ESMF_Calendar) :: julianDayCalendar

      ! local variables for Get methods
      integer(ESMF_KIND_I8) :: dl
      type(ESMF_Time) :: time

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultlogfilename="CalendarEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06043100000000000000">
37.3.1 Calendar creation</A>
</H3>

<P>
This example shows how to create two <TT>ESMF_Calendars</TT>. 

<P>
<PRE>
      ! create a Gregorian calendar
      gregorianCalendar = ESMF_CalendarCreate(ESMF_CALKIND_GREGORIAN, &amp;
                                              name="Gregorian", rc=rc)
</PRE>

<P>
<PRE>
      ! create a Julian Day calendar
      julianDayCalendar = ESMF_CalendarCreate(ESMF_CALKIND_JULIANDAY, &amp;
                                              name="JulianDay", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06043200000000000000">
37.3.2 Calendar comparison</A>
</H3>

<P>
This example shows how to compare an <TT>ESMF_Calendar</TT> with a known
   calendar kind. 

<P>
<PRE>
      ! compare calendar kind against a known type
      if (gregorianCalendar == ESMF_CALKIND_GREGORIAN) then
        print *, "gregorianCalendar is of type ESMF_CALKIND_GREGORIAN."
      else
        print *, "gregorianCalendar is not of type ESMF_CALKIND_GREGORIAN."
      end if
</PRE>

<P>

<H3><A NAME="SECTION06043300000000000000">
37.3.3 Time conversion between Calendars</A>
</H3>

<P>
This example shows how to convert a time from one <TT>ESMF_Calendar</TT>
   to another. 

<P>
<PRE>
      call ESMF_TimeSet(time, yy=2004, mm=4, dd=17, &amp;
                        calendar=gregorianCalendar, rc=rc)
</PRE>

<P>
<PRE>
      ! switch time's calendar to perform conversion
      call ESMF_TimeSet(time, calendar=julianDayCalendar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeGet(time, d_i8=dl, rc=rc)
      print *, "Gregorian date 2004/4/17 is ", dl, &amp;
               " days in the Julian Day calendar."
</PRE>

<P>

<H3><A NAME="SECTION06043400000000000000">
37.3.4 Calendar destruction</A>
</H3>

<P>
This example shows how to destroy two <TT>ESMF_Calendars</TT>. 

<P>
<PRE>
      call ESMF_CalendarDestroy(julianDayCalendar, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_CalendarDestroy(gregorianCalendar, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_CalendarEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION06044000000000000000">
37.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Months per year set to 12.</B> Due to the requirement of only Earth modeling, the number of months per year is hard-coded at 12.  However, for easy modification, this is implemented via a C preprocessor #define MONTHS_PER_YEAR in ESMCI_Calendar.h.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION06045000000000000000">
37.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06045100000000000000">
37.5.1 ESMF_CalendarAssignment(=) - Assign a Calendar to another Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       calendar1 = calendar2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar) :: calendar1
       type(ESMF_Calendar) :: calendar2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign <TT>calendar1</TT> as an alias to the same <TT>ESMF_Calendar</TT> 
       object in memory as <TT>calendar2</TT>. If <TT>calendar2</TT> is invalid, then 
       <TT>calendar1</TT> will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar1</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object on the left hand side of the 
            assignment.
       
</DD>
<DT><STRONG>calendar2</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object on the right hand side of the 
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045200000000000000">
37.5.2 ESMF_CalendarOperator(==) - Test if Calendar argument 1 is equal to Calendar argument 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (&lt;calendar argument 1&gt; == &lt;calendar argument 2&gt;) then ... endif
                                   OR
       result = (&lt;calendar argument 1&gt; == &lt;calendar argument 2&gt;)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       &lt;calendar argument 1&gt;, see below for supported values
       &lt;calendar argument 2&gt;, see below for supported values
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Calendar</TT> class.
       Compare an <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> with
       another calendar object or calendar kind for equality.  Return
       <TT>.true.</TT> if equal, <TT>.false.</TT> otherwise.  Comparison is based on
       calendar kind, which is a property of a calendar object.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and both are of  
       type <TT>ESMF_CALKIND_CUSTOM</TT>, then all the calendar's properties, 
       except name, are compared.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and either of them
       is not in the <TT>ESMF_INIT_CREATED</TT> status, an error will be logged.
       However, this does not affect the return value, which is <TT>.true.</TT> 
       when both arguments are in the <EM>same</EM> status, and <TT>.false.</TT>
       otherwise.

<P>
If one argument is an <TT>ESMF_Calendar</TT> object, and the other is an
       <TT>ESMF_CalKind_Flag</TT>, and the calendar object is not in the
       <TT>ESMF_INIT_CREATED</TT> status, an error will be logged and
       <TT>.false.</TT> will be returned.

<P>
Supported values for &lt;calendar argument 1&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar1
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag1
       
</DD>
</DL>
       Supported values for &lt;calendar argument 2&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar2
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag2
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>&lt;calendar argument 1&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            left hand side of the equality operation.
       
</DD>
<DT><STRONG>&lt;calendar argument 2&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            right hand side of the equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045300000000000000">
37.5.3 ESMF_CalendarOperator(/=) - Test if Calendar argument 1 is not equal to Calendar argument 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (&lt;calendar argument 1&gt; /= &lt;calendar argument 2&gt;) then ... endif
                                   OR
       result = (&lt;calendar argument 1&gt; /= &lt;calendar argument 2&gt;)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       &lt;calendar argument 1&gt;, see below for supported values
       &lt;calendar argument 2&gt;, see below for supported values
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Calendar</TT> class.
       Compare a <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> with
       another calendar object or calendar kind for inequality.  Return
       <TT>.true.</TT> if not equal, <TT>.false.</TT> otherwise.  Comparison is based
       on calendar kind, which is a property of a calendar object.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and both are of  
       type <TT>ESMF_CALKIND_CUSTOM</TT>, then all the calendar's properties,
       except name, are compared.

<P>
If both arguments are <TT>ESMF_Calendar</TT> objects, and either of them
       is not in the <TT>ESMF_INIT_CREATED</TT> status, an error will be logged.
       However, this does not affect the return value, which is <TT>.true.</TT> 
       when both arguments are <EM>not</EM> in the <EM>same</EM> status, and
       <TT>.false.</TT> otherwise.

<P>
If one argument is an <TT>ESMF_Calendar</TT> object, and the other is an
       <TT>ESMF_CalKind_Flag</TT>, and the calendar object is not in the
       <TT>ESMF_INIT_CREATED</TT> status, an error will be logged and
       <TT>.true.</TT> will be returned.

<P>
Supported values for &lt;calendar argument 1&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar1
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag1
       
</DD>
</DL>
       Supported values for &lt;calendar argument 2&gt; are:
       <DL>
<DT></DT>
<DD>type(ESMF_Calendar),     intent(in) :: calendar2
       
</DD>
<DT></DT>
<DD>type(ESMF_CalKind_Flag), intent(in) :: calkindflag2
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>&lt;calendar argument 1&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            left hand side of the non-equality operation.
       
</DD>
<DT><STRONG>&lt;calendar argument 2&gt;</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> object or <TT>ESMF_CalKind_Flag</TT> on the
            right hand side of the non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045400000000000000">
37.5.4 ESMF_CalendarCreate - Create a new ESMF Calendar of built-in type</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateBuiltIn(calkindflag, &amp;
         name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateBuiltIn
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates and sets a <TT>calendar</TT> to the given built-in
       <TT>ESMF_CalKind_Flag</TT>. 

<P>
The arguments are:
       <DL>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The built-in <TT>ESMF_CalKind_Flag</TT>.  Valid values are:
              <BR>
              <TT>ESMF_CALKIND_360DAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_GREGORIAN</TT>,
              <BR>
              <TT>ESMF_CALKIND_JULIAN</TT>, 
              <BR>
              <TT>ESMF_CALKIND_JULIANDAY</TT>,
              <BR>
              <TT>ESMF_CALKIND_MODJULIANDAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_NOCALENDAR</TT>,
              <BR>
and <TT>ESMF_CALKIND_NOLEAP</TT>.
              <BR>
See Section&nbsp;<A HREF="node6.html#subsec:Calendar_options">37.2</A> for a description of each
            calendar kind.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created calendar.  If not specified, a
            default unique name will be generated: "CalendarNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045500000000000000">
37.5.5 ESMF_CalendarCreate - Create a copy of an ESMF Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateCopy(calendar, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a complete (deep) copy of a given <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The <TT>ESMF_Calendar</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045600000000000000">
37.5.6 ESMF_CalendarCreate - Create a new custom ESMF Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarCreate()
       function ESMF_CalendarCreateCustom(&amp;
         daysPerMonth, secondsPerDay, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Calendar) :: ESMF_CalendarCreateCustom
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,               intent(in),  optional :: daysPerMonth(:)
       integer(ESMF_KIND_I4), intent(in),  optional :: secondsPerDay
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYear   ! not imp
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYearDn ! not imp
       integer(ESMF_KIND_I4), intent(in),  optional :: daysPerYearDd ! not imp
       character (len=*),     intent(in),  optional :: name
       integer,               intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a custom <TT>ESMF_Calendar</TT> and sets its properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
            The number of months per year is variable and taken from the
            size of the array.  If unspecified, months per year = 0,
            with the days array undefined.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.  Defaults to 86400 if not 
            specified.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  Use with daysPerYearDn and
            daysPerYearDd (see below) to specify a days-per-year calendar
            for any planetary body.  Default = 0.  (Not implemented yet).
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer numerator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear (see above) and daysPerYearDd (see below) to
            specify a days-per-year calendar for any planetary body.
            Default = 0.  (Not implemented yet).

</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer denominator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear and daysPerYearDn (see above) to
            specify a days-per-year calendar for any planetary body.
            Default = 1.  (Not implemented yet).
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created calendar.  If not specified, a
            default unique name will be generated: "CalendarNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045700000000000000">
37.5.7 ESMF_CalendarDestroy - Release resources associated with a Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarDestroy(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(inout)          :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Calendar</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045800000000000000">
37.5.8 ESMF_CalendarGet - Get Calendar properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarGet(calendar, &amp;
         name, calkindflag, daysPerMonth, monthsPerYear, &amp;
         secondsPerDay, secondsPerYear, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),    intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_CalKind_Flag),intent(out), optional :: calkindflag
       integer,                intent(out), optional :: daysPerMonth(:)
       integer,                intent(out), optional :: monthsPerYear
       integer(ESMF_KIND_I4),  intent(out), optional :: secondsPerDay
       integer(ESMF_KIND_I4),  intent(out), optional :: secondsPerYear
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYear   !not imp
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYearDn !not imp
       integer(ESMF_KIND_I4),  intent(out), optional :: daysPerYearDd !not imp
       character (len=*),      intent(out), optional :: name
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets one or more of an <TT>ESMF_Calendar</TT>'s properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>The <TT>CalKind_Flag</TT> ESMF_CALKIND_GREGORIAN, 
            ESMF_CALKIND_JULIAN, etc.
       
</DD>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
       
</DD>
<DT><STRONG>[monthsPerYear]</STRONG></DT>
<DD>Integer number of months per year; the size of the
            daysPerMonth array.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.
       
</DD>
<DT><STRONG>[secondsPerYear]</STRONG></DT>
<DD>Integer number of seconds per year.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  For calendars with
            intercalations, daysPerYear is the number of days for years without
            an intercalation.  For other calendars, it is the number of days in
            every year.  (Not implemented yet).
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer fractional number of days per year (numerator).
            For calendars with intercalations, daysPerYearDn/daysPerYearDd is
            the average fractional number of days per year (e.g. 25/100 for
            Julian 4-year intercalation).  For other calendars, it is zero.
            (Not implemented yet).

</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer fractional number of days per year (denominator).  See
            daysPerYearDn above.  (Not implemented yet).
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06045900000000000000">
37.5.9 ESMF_CalendarIsLeapYear - Determine if given year is a leap year</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarIsLeapYear()
       function ESMF_CalendarIsLeapYear&lt;kind&gt;(calendar, yy, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_CalendarIsLeapYear&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),       intent(in)            :: calendar
       integer(ESMF_KIND_&lt;kind&gt;), intent(in)            :: yy
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the given year is a leap year within the given
       calendar, and <TT>.false.</TT> otherwise.  See also 
       <TT>ESMF_TimeIsLeapYear()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to determine leap year within.
       
</DD>
<DT><STRONG>yy</STRONG></DT>
<DD>Year to check for leap year.  The type is integer and the &lt;kind&gt; can
            be either I4 or I8:  <TT>ESMF_KIND_I4</TT> or <TT>ESMF_KIND_I8</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451000000000000000">
37.5.10 ESMF_CalendarPrint - Print the contents of a Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarPrint(calendar, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
       character (len=*),   intent(in),  optional :: options
       integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Calendar</TT>'s properties to <TT>stdio</TT>, 
       in support of testing and debugging.  The options control the 
       type of information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all calendar property
                               values. 
<BR>            "calkindflag"    - print the calendar's type 
                                 (e.g. ESMF_CALKIND_GREGORIAN). 
<BR>            "daysPerMonth"   - print the array of number of days for
                                 each month. 
<BR>            "daysPerYear"    - print the number of days per year
                               (integer and fractional parts). 
<BR>            "monthsPerYear"  - print the number of months per year. 
<BR>            "name"           - print the calendar's name. 
<BR>            "secondsPerDay"  - print the number of seconds in a day. 
<BR>            "secondsPerYear" - print the number of seconds in a year. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451100000000000000">
37.5.11 ESMF_CalendarSet - Set a Calendar to a built-in type</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSet()
       subroutine ESMF_CalendarSetBuiltIn(calendar, calkindflag, &amp;
         name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),     intent(inout)         :: calendar
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets <TT>calendar</TT> to the given built-in <TT>ESMF_CalKind_Flag</TT>. 

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The built-in <TT>CalKind_Flag</TT>.  Valid values are:
              <BR>
              <TT>ESMF_CALKIND_360DAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_GREGORIAN</TT>,
              <BR>
              <TT>ESMF_CALKIND_JULIAN</TT>, 
              <BR>
              <TT>ESMF_CALKIND_JULIANDAY</TT>,
              <BR>
              <TT>ESMF_CALKIND_MODJULIANDAY</TT>, 
              <BR>
              <TT>ESMF_CALKIND_NOCALENDAR</TT>,
              <BR>
and <TT>ESMF_CALKIND_NOLEAP</TT>.
              <BR>
See Section&nbsp;<A HREF="node6.html#subsec:Calendar_options">37.2</A> for a description of each
            calendar kind.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451200000000000000">
37.5.12 ESMF_CalendarSet - Set properties of a custom Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSet()
       subroutine ESMF_CalendarSetCustom(calendar, &amp;
         daysPerMonth, secondsPerDay, &amp;
         daysPerYear, daysPerYearDn, daysPerYearDd, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),  intent(inout)         :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,              intent(in),  optional :: daysPerMonth(:)
       integer(ESMF_KIND_I4),intent(in),  optional :: secondsPerDay
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYear   !not imp
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYearDn !not imp
       integer(ESMF_KIND_I4),intent(in),  optional :: daysPerYearDd !not imp
       character (len=*),    intent(in),  optional :: name
       integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets properties in a custom <TT>ESMF_Calendar</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[daysPerMonth]</STRONG></DT>
<DD>Integer array of days per month, for each month of the year.
            The number of months per year is variable and taken from the
            size of the array.  If unspecified, months per year = 0,
            with the days array undefined.
       
</DD>
<DT><STRONG>[secondsPerDay]</STRONG></DT>
<DD>Integer number of seconds per day.  Defaults to 86400 if not 
            specified.
       
</DD>
<DT><STRONG>[daysPerYear]</STRONG></DT>
<DD>Integer number of days per year.  Use with daysPerYearDn and
            daysPerYearDd (see below) to specify a days-per-year calendar
            for any planetary body.  Default = 0.  (Not implemented yet).
       
</DD>
<DT><STRONG>[daysPerYearDn]</STRONG></DT>
<DD>Integer numerator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear (see above) and daysPerYearDd (see below) to
            specify a days-per-year calendar for any planetary body.
            Default = 0.  (Not implemented yet).
       
</DD>
<DT><STRONG>[daysPerYearDd]</STRONG></DT>
<DD>Integer denominator portion of fractional number of days per year
            (daysPerYearDn/daysPerYearDd).
            Use with daysPerYear and daysPerYearDn (see above) to
            specify a days-per-year calendar for any planetary body.
            Default = 1.  (Not implemented yet).

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this calendar.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451300000000000000">
37.5.13 ESMF_CalendarSetDefault - Set the default Calendar kind</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSetDefault()
       subroutine ESMF_CalendarSetDefaultKind(calkindflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
       integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the default <TT>calendar</TT> to the given type.  Subsequent Time
       Manager operations requiring a calendar where one isn't specified will
       use the internal calendar of this type.

<P>
The arguments are:
       <DL>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>The calendar kind to be the default.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451400000000000000">
37.5.14 ESMF_CalendarSetDefault - Set the default Calendar</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_CalendarSetDefault()
       subroutine ESMF_CalendarSetDefaultCal(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar),     intent(in)            :: calendar
       integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the default <TT>calendar</TT> to the one given.  Subsequent Time
       Manager operations requiring a calendar where one isn't specified will
       use this calendar.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD>The object instance to be the default.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060451500000000000000">
37.5.15 ESMF_CalendarValidate - Validate a Calendar's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_CalendarValidate(calendar, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Calendar), intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>calendar</TT> is valid.  
       Must be one of the defined calendar kinds.  daysPerMonth, daysPerYear,
       secondsPerDay must all be greater than or equal to zero.

<P>
The arguments are:
       <DL>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>ESMF_Calendar</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H1><A NAME="SECTION06050000000000000000">
38 Time Class</A>
</H1>

<P>

<H2><A NAME="SECTION06051000000000000000">
38.1 Description</A>
</H2>
<A NAME="sec:Time"></A>
<P>
A Time represents a specific point in time.  In order to accommodate
the range of time scales in Earth system applications, Times in
the ESMF an be specified in many different ways, from years to 
nanoseconds.  The Time interface is designed so that you select one or 
more options from a list of time units in order to specify a 
Time. The options for specifying a Time are shown in 
Table&nbsp;<A HREF="node6.html#table:timeOpts">36.4</A>.  

<P>
There are Time methods defined for setting and getting a
Time, incrementing and decrementing a Time by a TimeInterval,
taking the difference between two Times, and comparing Times.
Special quantities such as the middle of the month and the 
day of the year associated with a particular Time can be retrieved. 
There is a method for returning the Time value as a string in 
the ISO 8601 format YYYY-MM-DDThh:mm:ss [<A
 HREF="node8.html#ISO">12</A>].

<P>
A Time that is specified in hours, minutes, seconds, or subsecond intervals 
does not need to be associated with a standard calendar; a Time whose
specification includes time units of a day and greater must be.  The 
ESMF representation
of a calendar, the Calendar class, is described in Section&nbsp;<A HREF="node6.html#sec:Calendar">37.1</A>.
The <TT>ESMF_TimeSet</TT> method is used to initialize a Time as well as
associate it with a Calendar.  If a Time method is invoked in which a Calendar
is necessary and one has not been set, the ESMF method will return an error
condition.

<P>
In the ESMF the TimeInterval class is used to represent time periods.
This class is frequently used in combination with the Time class.
The Clock class, for example, advances model time by incrementing a
Time with a TimeInterval. 

<P>

<P>

<H2><A NAME="SECTION06052000000000000000">
38.2 Use and Examples</A>
</H2>

<P>
Times are most frequently used to represent start, stop, and current 
model times.  The following examples show how to create, initialize, and
manipulate <TT>Time</TT>.

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_TimeEx - Time initialization and manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of Time initialization and manipulation
!-----------------------------------------------------------------------------

      ! ESMF Framework module
      use ESMF
      implicit none

      ! instantiate two times
      type(ESMF_Time) :: time1, time2

      ! instantiate a time interval
      type(ESMF_TimeInterval) :: timeinterval1

      ! local variables for Get methods
      integer :: YY, MM, DD, H, M, S

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="TimeEx.Log", &amp;
        logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06052100000000000000">
38.2.1 Time initialization</A>
</H3>

<P>
This example shows how to initialize an <TT>ESMF_Time</TT>. 

<P>
<PRE>
      ! initialize time1 to 2/28/2000 2:24:45
      call ESMF_TimeSet(time1, yy=2000, mm=2, dd=28, h=2, m=24, s=45, rc=rc)
</PRE>

<P>
<PRE>
      print *, "Time1 = "
      call ESMF_TimePrint(time1, options="string", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06052200000000000000">
38.2.2 Time increment</A>
</H3>

<P>
This example shows how to increment an <TT>ESMF_Time</TT> by
   an <TT>ESMF_TimeInterval</TT>. 

<P>
<PRE>
      ! initialize a time interval to 2 days, 8 hours, 36 minutes, 15 seconds
      call ESMF_TimeIntervalSet(timeinterval1, d=2, h=8, m=36, s=15, rc=rc)
</PRE>

<P>
<PRE>
      print *, "Timeinterval1 = "
      call ESMF_TimeIntervalPrint(timeinterval1, options="string", rc=rc)
</PRE>

<P>
<PRE>
      ! increment time1 with timeinterval1
      time2 = time1 + timeinterval1

      call ESMF_TimeGet(time2, yy=YY, mm=MM, dd=DD, h=H, m=M, s=S, rc=rc)
      print *, "time2 = time1 + timeinterval1 = ", YY, "/", MM, "/", DD, &amp;
               " ",  H, ":", M, ":", S
</PRE>

<P>

<H3><A NAME="SECTION06052300000000000000">
38.2.3 Time comparison</A>
</H3>

<P>
This example shows how to compare two <TT>ESMF_Times</TT>. 

<P>
<PRE>
      if (time2 &gt; time1) then
        print *, "time2 is larger than time1"
      else
        print *, "time1 is smaller than or equal to time2"
      endif

      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_TimeEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION06053000000000000000">
38.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limits on size and resolution of Time.</B>  The limits on the size and 
resolution of the time representation are based on the
64-bit integer types used.  For seconds, a signed 64-bit integer
will have a range of +/- <IMG
 WIDTH="28" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img103.png"
 ALT="$2^{63}$">-1, or +/- 9,223,372,036,854,775,807.  This
corresponds to a maximum size of +/- (<IMG
 WIDTH="28" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img103.png"
 ALT="$2^{63}$">-1)/(86400 * 365.25) or
+/- 292,271,023,045 years.

<P>
For fractional seconds, a signed 64-bit integer will handle a resolution of
+/- <IMG
 WIDTH="28" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img104.png"
 ALT="$2^{31}$">-1, or +/- 9,223,372,036,854,775,807 parts of a second.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION06054000000000000000">
38.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06054100000000000000">
38.4.1 ESMF_TimeAssignment(=) - Assign a Time to another Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       time1 = time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time) :: time1
       type(ESMF_Time) :: time2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Set <TT>time1</TT> equal to <TT>time2</TT>.  This is the default Fortran
       assignment, which creates a complete, independent copy of <TT>time2</TT> 
       as <TT>time1</TT>.  If <TT>time2</TT> is an invalid <TT>ESMF_Time</TT> object then
       <TT>time1</TT> will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be set.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be copied.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054200000000000000">
38.4.2 ESMF_TimeOperator(+) - Increment a Time by a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(+)
       time2 = time1 + timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Time) :: time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (+) operator for the <TT>ESMF_Time</TT> class to increment
       <TT>time1</TT> with <TT>timeinterval</TT> and return the result as an
       <TT>ESMF_Time</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to increment.
       
</DD>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to add to the given <TT>ESMF_Time</TT>.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054300000000000000">
38.4.3 ESMF_TimeOperator(-) - Decrement a Time by a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(-)
       time2 = time1 - timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Time) :: time2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_Time</TT> class to decrement
       <TT>time1</TT> with <TT>timeinterval</TT>, and return the result as an
       <TT>ESMF_Time</TT>.

<P>
The arguments are:      
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to decrement.
       
</DD>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to subtract from the given
            <TT>ESMF_Time</TT>.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054400000000000000">
38.4.4 ESMF_TimeOperator(-) - Return the difference between two Times</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(-)
       time3 = time1 - time2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Time) :: time3
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in) :: time1
       type(ESMF_Time),         intent(in) :: time2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_Time</TT> class to return the
       difference between <TT>time1</TT> and <TT>time2</TT> as an
       <TT>ESMF_TimeInterval</TT>.  It is assumed that <TT>time1</TT> is later than
       <TT>time2</TT>; if not, the resulting <TT>ESMF_TimeInterval</TT> will have a
       negative value.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The first <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054500000000000000">
38.4.5 ESMF_TimeOperator(==) - Test if Time 1 is equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (time1 == time2) then ... endif
                    OR
       result = (time1 == time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> and <TT>time2</TT> represent the same instant 
       in time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054600000000000000">
38.4.6 ESMF_TimeOperator(/=) - Test if Time 1 is not equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (time1 /= time2) then ... endif
                    OR
       result = (time1 /= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> and <TT>time2</TT> do not represent the same 
       instant in time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054700000000000000">
38.4.7 ESMF_TimeOperator(&lt;) - Test if Time 1 is less than Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&lt;)
       if (time1 &lt; time2) then ... endif
                    OR
       result = (time1 &lt; time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is earlier in time than <TT>time2</TT>, and 
       <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054800000000000000">
38.4.8 ESMF_TimeOperator(&lt;=) - Test if Time 1 is less than or equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&lt;=)
       if (time1 &lt;= time2) then ... endif
                    OR
       result = (time1 &lt;= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is earlier in time or the same time as 
       <TT>time2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06054900000000000000">
38.4.9 ESMF_TimeOperator(&gt;) - Test if Time 1 is greater than Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&gt;)
       if (time1 &gt; time2) then ... endif
                    OR
       result = (time1 &gt; time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is later in time than <TT>time2</TT>, and 
       <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541000000000000000">
38.4.10 ESMF_TimeOperator(&gt;=) - Test if Time 1 is greater than or equal to Time 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&gt;=)
       if (time1 &gt;= time2) then ... endif
                    OR
       result = (time1 &gt;= time2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in) :: time1
       type(ESMF_Time), intent(in) :: time2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;=) operator for the <TT>ESMF_Time</TT> class to return 
       <TT>.true.</TT> if <TT>time1</TT> is later in time or the same time as 
       <TT>time2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>First <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>Second <TT>ESMF_Time</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541100000000000000">
38.4.11 ESMF_TimeGet - Get a Time value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeGet(time, &amp;
         yy, yy_i8, &amp;
         mm, dd, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         calendar, calkindflag, timeZone, &amp;
         timeString, timeStringISOFrac, &amp;
         dayOfWeek, midMonth, &amp;
         dayOfYear,  dayOfYear_r8, &amp;
         dayOfYear_intvl, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(in)            :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer,                 intent(out), optional :: mm
       integer,                 intent(out), optional :: dd
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       integer,                 intent(out), optional :: timeZone ! not imp
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: dayOfWeek
       type(ESMF_Time),         intent(out), optional :: midMonth
       integer(ESMF_KIND_I4),   intent(out), optional :: dayOfYear
       real(ESMF_KIND_R8),      intent(out), optional :: dayOfYear_r8
       type(ESMF_TimeInterval), intent(out), optional :: dayOfYear_intvl
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>time</TT> in units specified by the user
       via Fortran optional arguments.  See <TT>ESMF_TimeSet()</TT> above for a
       description of time units and calendars.

<P>
The ESMF Time Manager represents and manipulates time internally with 
       integers to maintain precision.  Hence, user-specified floating point 
       values are converted internally from integers.  For example, if a time
       value is 5 and 3/8 seconds (s=5, sN=3, sD=8), and you want to get it as
       floating point seconds, you would get 5.375 (s_r8=5.375).

<P>
Units are bound (normalized) by the next larger unit specified.  For
       example, if a time is defined to be 2:00 am on February 2, 2004, then
       <TT>ESMF_TimeGet(dd=day, h=hours, s=seconds)</TT> would return
         <TT>day = 2</TT>, <TT>hours = 2</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeGet(dd = day, s=seconds)</TT> would return
         <TT>day = 2</TT>, <TT>seconds = 7200</TT>.
       Note that <TT>hours</TT> and <TT>seconds</TT> are bound by a day.  If bound
       by a month,
       <TT>ESMF_TimeGet(mm=month, h=hours, s=seconds)</TT> would return
         <TT>month = 2</TT>, <TT>hours = 26</TT>, <TT>seconds = 0</TT>,
       and <TT>ESMF_TimeGet(mm = month, s=seconds)</TT> would return
         <TT>month = 2</TT>, <TT>seconds = 93600</TT> (26 * 3600).
       Similarly, if bound to a year,
       <TT>ESMF_TimeGet(yy=year, h=hours, s=seconds)</TT> would return
         <TT>year = 2004</TT>, <TT>hours = 770</TT> (32*24 + 2), <TT>seconds = 0</TT>,
       and <TT>ESMF_TimeGet(yy = year, s=seconds)</TT> would return
         <TT>year = 2004</TT>, <TT>seconds = 2772000</TT> (770 * 3600).

<P>
For <TT>timeString</TT>, <TT>timeStringISOFrac</TT>, <TT>dayOfWeek</TT>,
       <TT>midMonth</TT>, <TT>dayOfYear</TT>, <TT>dayOfYear_intvl</TT>, and
       <TT>dayOfYear_r8</TT> described below, valid calendars are Gregorian,
       Julian, No Leap, 360 Day and Custom calendars.  Not valid for
       Julian Day, Modified Julian Day, or No Calendar. 
<BR>
<P>
For <TT>timeString</TT> and <TT>timeStringISOFrac</TT>, YYYY format returns
       at least 4 digits; years &lt;= 999 are padded on the left with zeroes and
       years &gt;= 10000 return the number of digits required.

<P>
For timeString, convert <TT>ESMF_Time</TT>'s value into partial ISO 8601
       format YYYY-MM-DDThh:mm:ss[:n/d].  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].
       See also method <TT>ESMF_TimePrint()</TT>.

<P>
For timeStringISOFrac, convert <TT>ESMF_Time</TT>'s value into full ISO 8601
       format YYYY-MM-DDThh:mm:ss[.f].  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].
       See also method <TT>ESMF_TimePrint()</TT>.

<P>
For dayOfWeek, gets the day of the week the given <TT>ESMF_Time</TT>
       instant falls on.  ISO 8601 standard:  Monday = 1 through Sunday = 7.
       See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].

<P>
For midMonth, gets the middle time instant of the month that the given
       <TT>ESMF_Time</TT> instant falls on.

<P>
For dayOfYear, gets the day of the year that the given <TT>ESMF_Time</TT>
       instant falls on.  See range discussion in argument list below.
       Return as an integer value.

<P>
For dayOfYear_r8, gets the day of the year the given <TT>ESMF_Time</TT>
       instant falls on.  See range discussion in argument list below.
       Return as floating point value; fractional part represents the time of
       day.

<P>
For dayOfYear_intvl, gets the day of the year the given <TT>ESMF_Time</TT>
       instant falls on.  Return as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month.
       
</DD>
<DT><STRONG>[dd]</STRONG></DT>
<DD>Integer day of the month.
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>Associated timezone (hours offset from UCT, e.g. EST = -5).
            (Not implemented yet).
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time value to format string YYYY-MM-DDThh:mm:ss[:n/d],
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimePrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time value to strict ISO 8601 format string
            YYYY-MM-DDThh:mm:ss[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method
            <TT>ESMF_TimePrint()</TT>.
       
</DD>
<DT><STRONG>[dayOfWeek]</STRONG></DT>
<DD>The time instant's day of the week [1-7].
       
</DD>
<DT><STRONG>[MidMonth]</STRONG></DT>
<DD>The given time instant's middle-of-the-month time instant.
       
</DD>
<DT><STRONG>[dayOfYear]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's integer day of the year.
            [1-366] for Gregorian and Julian calendars, [1-365] for No-Leap
            calendar.  [1-360] for 360-Day calendar.  User-defined range
            for Custom calendar.
       
</DD>
<DT><STRONG>[dayOfYear_r8]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's floating point day of the year.
            [1.x-366.x] for Gregorian and Julian calendars, [1.x-365.x] for
            No-Leap calendar.  [1.x-360.x] for 360-Day calendar.  User-defined
            range for Custom calendar.
       
</DD>
<DT><STRONG>[dayOfYear_intvl]</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> instant's day of the year as an
            <TT>ESMF_TimeInterval</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541200000000000000">
38.4.12 ESMF_TimeIsLeapYear - Determine if a Time is in a leap year</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_TimeIsLeapYear(time, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_TimeIsLeapYear
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in)            :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,         intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if given time is in a leap year, and false otherwise.
       See also <TT>ESMF_CalendarIsLeapYear()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to check for leap year.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541300000000000000">
38.4.13 ESMF_TimeIsSameCalendar - Compare Calendars of two Times</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_TimeIsSameCalendar(time1, time2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_TimeIsSameCalendar
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(in)            :: time1
       type(ESMF_Time), intent(in)            :: time2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,         intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if the Calendars in these Times are
       the same, false otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>time1</STRONG></DT>
<DD>The first <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>time2</STRONG></DT>
<DD>The second <TT>ESMF_Time</TT> in comparison.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541400000000000000">
38.4.14 ESMF_TimePrint - Print the contents of a Time </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimePrint(time, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),   intent(in)            :: time
       character (len=*), intent(in),  optional :: options
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out the contents of an <TT>ESMF_Time</TT> to <TT>stdout</TT>, in
       support of testing and debugging.  The options control the type of
       information and level of detail.  For options "string" and "string
       isofrac", YYYY format returns at least 4 digits; years &lt;= 999 are
       padded on the left with zeroes and years &gt;= 10000 return the number
       of digits required. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The <TT>ESMF_Time</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all Time property values. 
<BR>            "string" - prints <TT>time</TT>'s value in ISO 8601 format for all units
                       through seconds.  For any non-zero fractional seconds,
                       prints in integer rational fraction form n/d.  Format is
                       YYYY-MM-DDThh:mm:ss[:n/d], where [:n/d] is the 
                       integer numerator and denominator of the fractional
                       seconds value, if present.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method
                       <TT>ESMF_TimeGet(..., timeString= , ...)</TT> 
<BR>            "string isofrac" - prints <TT>time</TT>'s value in strict ISO 8601
                       format for all units, including any fractional seconds
                       part.  Format is YYYY-MM-DDThh:mm:ss[.f] where [.f]
                       represents fractional seconds in decimal form, if present.
                       See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method
                       <TT>ESMF_TimeGet(..., timeStringISOFrac= , ...)</TT> 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541500000000000000">
38.4.15 ESMF_TimeSet - Initialize or set a Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeSet(time, &amp;
         yy, yy_i8, &amp;
         mm, dd, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         calendar, calkindflag, &amp;
         timeZone, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),         intent(inout)         :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer,                 intent(in),  optional :: mm
       integer,                 intent(in),  optional :: dd
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       type(ESMF_Calendar),     intent(in),  optional :: calendar
       type(ESMF_CalKind_Flag), intent(in),  optional :: calkindflag
       integer,                 intent(in),  optional :: timeZone ! not imp
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Initializes an <TT>ESMF_Time</TT> with a set of user-specified units
       via Fortran optional arguments.

<P>
The range of valid values for mm and dd depend on the calendar used.
       For Gregorian, Julian, and No-Leap calendars, mm is [1-12] and dd is
       [1-28,29,30, or 31], depending on the value of mm and whether yy or
       yy_i8 is a leap year.  For the 360-day calendar, mm is [1-12] and dd is
       [1-30].  For the Julian-day, Modified Julian-day, and No-calendar,
       yy, yy_i8, mm, and dd are invalid inputs, since these calendars do not
       define them.  When valid, the yy and yy_i8 arguments should be fully
       specified, e.g. 2003 instead of 03.  yy and yy_i8 ranges are only
       limited by machine word size, except for the Gregorian and Julian
       calendars, where the lowest (proleptic) date limits are 3/1/-4800 and
       3/1/-4712, respectively.  This is a limitation of the Gregorian
       date-to-Julian day and Julian date-to-Julian day conversion algorithms
       used to convert Gregorian and Julian dates to the internal representation
       of seconds.  See&nbsp;[<A
 HREF="node8.html#Fli68">8</A>] for a description of the Gregorian
       date-to-Julian day algorithm and&nbsp;[<A
 HREF="node8.html#Hat84">11</A>] for a description of the
       Julian date-to-Julian day algorithm.  The Custom calendar will have
       user-defined values for yy, yy_i8, mm, and dd.

<P>
The Julian day specifier, d or d_i8, can only be used with the
       Julian-day and Modified Julian Day calendars, and has a valid range
       depending on the word size.  For a signed 32-bit d, the range for
       Julian-day is [+/- 24855].  For a signed 64-bit d or d_i8, the valid
       range for Julian-day is [+/- 106,751,991,167,300].  The Julian day
       number system adheres to the conventional standard where the reference
       day of d=0 corresponds to 11/24/-4713 in the proleptic Gregorian calendar
       and 1/1/-4712 in the proleptic Julian calendar.  See&nbsp;[<A
 HREF="node8.html#Meyer2">16</A>] and
&nbsp;[<A
 HREF="node8.html#JDNcalculator">1</A>].

<P>
The Modified Julian Day, introduced by space scientists in the late
       1950's, is defined as Julian-day - 2400000.5.  See&nbsp;[<A
 HREF="node8.html#MJD">23</A>].

<P>
Note that d and d_i8 are not valid for the No-Calendar.  To remain
       consistent with non-Earth calendars added to ESMF in the future, ESMF
       requires a calendar to be planet-specific.  Hence the No-Calendar does
       not know what a day is; it cannot assume an Earth day of 86400 seconds.

<P>
Hours, minutes, seconds, and sub-seconds can be used with any calendar,
       since they are standardized units that are the same for any planet.

<P>
Time manager represents and manipulates time internally with integers
       to maintain precision. Hence, user-specified floating point values are
       converted internally to integers.  Sub-second values are represented
       internally with an integer numerator and denominator fraction (sN/sD).
       The smallest required resolution is nanoseconds (denominator), per Time
       Manager requirement TMG3.1.  For example, pi can be represented as s=3,
       sN=141592654, sD=1000000000.  However, via sN_i8 and sD_i8, larger
       values can be used.  If specifying a constant floating point value, be
       sure to provide at least 16 digits to take full advantage of double
       precision, for example s_r8=2.718281828459045d0 for 'e' seconds.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer year (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer year (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer month.  Default = 1
       
</DD>
<DT><STRONG>[dd]</STRONG></DT>
<DD>Integer day of the month.  Default = 1
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian days (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.  Default = 0
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.  Default = 0
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.  Default = 0
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.  Default = 0
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.  Default = 0
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
            Default = 0
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
            Default = 1
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
            Default = 1
       
</DD>
<DT><STRONG>calendar</STRONG></DT>
<DD>Associated <TT>Calendar</TT>.  Defaults to calendar
            <TT>ESMF_CALKIND_NOCALENDAR</TT> or default specified in
            <TT>ESMF_Initialize()</TT> or <TT>ESMF_CalendarSetDefault()</TT>.
            Alternate to, and mutually exclusive with, calkindflag
            below.  Primarily for specifying a custom calendar kind.

</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Alternate to, and mutually exclusive with, calendar above.  More
            convenient way of specifying a built-in calendar kind.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>Associated timezone (hours offset from UTC, e.g. EST = -5).
            Default = 0 (UTC).  (Not implemented yet).
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541600000000000000">
38.4.16 ESMF_TimeSyncToRealTime - Get system real time (wall clock time)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeSyncToRealTime(time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time), intent(inout) :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the system real time (wall clock time), and returns it as an
       <TT>ESMF_Time</TT>.  Accurate to the nearest second.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD>The object instance to receive the real time.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060541700000000000000">
38.4.17 ESMF_TimeValidate - Validate a Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeValidate(time, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Time),   intent(in)            :: time
       character (len=*), intent(in),  optional :: options
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether an <TT>ESMF_Time</TT> is valid.
       Must be a valid date/time on a valid calendar.
       The options control the type of validation.

<P>
The arguments are:
       <DL>
<DT><STRONG>time</STRONG></DT>
<DD><TT>ESMF_Time</TT> instant to be validated.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options. If none specified, validates all <TT>time</TT> property
              values. 
<BR>            "calendar" - validate only the <TT>time</TT>'s calendar. 
<BR>            "timezone" - validate only the <TT>time</TT>'s timezone. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H1><A NAME="SECTION06060000000000000000">
39 TimeInterval Class</A>
</H1>

<P>

<H2><A NAME="SECTION06061000000000000000">
39.1 Description</A>
</H2>
<A NAME="sec:TimeInterval"></A>A TimeInterval represents a period between time instants.  
It can be either positive or negative.  Like the Time interface, 
the TimeInterval interface is designed so that you can choose 
one or more options from a list of time units in order 
to specify a TimeInterval.
See Section&nbsp;<A HREF="node6.html#subsec:Time_Instants_and_TimeIntervals">36.3</A>, 
Table&nbsp;<A HREF="node6.html#table:timeOpts">36.4</A> for the available options.

<P>
There are TimeInterval methods defined for setting and getting 
a TimeInterval, for incrementing and decrementing a TimeInterval 
by another TimeInterval, and for multiplying and dividing 
TimeIntervals by integers, reals, fractions and other TimeIntervals.  
Methods are also defined to take the absolute value and negative 
absolute value of a TimeInterval, and for comparing the length of two
TimeIntervals.

<P>
The class used to represent time instants in ESMF is Time,
and this class is frequently used in operations along with 
TimeIntervals.  For example, the difference between two
Times is a TimeInterval.  

<P>
When a TimeInterval is used in calculations that involve an absolute 
reference time, such as incrementing a Time with a TimeInterval, calendar 
dependencies may be introduced.  The length of the time period that the 
TimeInterval represents will depend on the reference Time and the 
standard calendar that is associated with it.  The calendar dependency becomes 
apparent when, for example, adding a TimeInterval of 1 day to the Time 
of February 28, 1996, at 4:00pm EST.  In a 360 day calendar, the 
resulting date would be February 29, 1996, at 4:00pm EST.  In a no-leap 
calendar, the result would be March 1, 1996, at 4:00pm EST.

<P>
TimeIntervals are used by other parts of the ESMF timekeeping
system, such as Clocks (Section&nbsp;<A HREF="node6.html#sec:Clock">40.1</A>) and Alarms 
(Section&nbsp;<A HREF="node6.html#sec:Alarm">41.1</A>).

<P>

<P>

<H2><A NAME="SECTION06062000000000000000">
39.2 Use and Examples</A>
</H2>

<P>
A typical use for a TimeInterval in a geophysical model 
is representation of the time step by which the model is 
advanced.  Some models change the size of their time step as 
the model run progresses; this could
be done by incrementing or decrementing the original time 
step by another TimeInterval, or by dividing or multiplying
the time step by an integer value.  An example of advancing 
model time using a TimeInterval representation of a time
step is shown in Section&nbsp;<A HREF="node6.html#sec:Clock">40.1</A>.

<P>
The following brief example shows how to create, initialize 
and manipulate <TT>TimeInterval</TT>.

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_TimeIntervalEx - Time Interval initialization and 
!                                 manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of Time Interval initialization and manipulation
!-----------------------------------------------------------------------------

      ! ESMF Framework module
      use ESMF
      implicit none

      ! instantiate some time intervals
      type(ESMF_TimeInterval) :: timeinterval1, timeinterval2, timeinterval3

      ! local variables
      integer :: d, h, m, s

      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="TimeIntervalEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06062100000000000000">
39.2.1 TimeInterval initialization</A>
</H3>

<P>
This example shows how to initialize two <TT>ESMF_TimeIntervals</TT>. 

<P>
<PRE>
      ! initialize time interval1 to 1 day
      call ESMF_TimeIntervalSet(timeinterval1, d=1, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalPrint(timeinterval1, options="string", rc=rc)
</PRE>

<P>
<PRE>
      ! initialize time interval2 to 4 days, 1 hour, 30 minutes, 10 seconds
      call ESMF_TimeIntervalSet(timeinterval2, d=4, h=1, m=30, s=10, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalPrint(timeinterval2, options="string", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06062200000000000000">
39.2.2 TimeInterval conversion</A>
</H3>

<P>
This example shows how to convert <TT>ESMF_TimeIntervals</TT> into 
   different units. 

<P>
<PRE>
      call ESMF_TimeIntervalGet(timeinterval1, s=s, rc=rc)
      print *, "Time Interval1 = ", s, " seconds."
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalGet(timeinterval2, h=h, m=m, s=s, rc=rc)
      print *, "Time Interval2 = ", h, " hours, ", m, " minutes, ", &amp;
                                    s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062300000000000000">
39.2.3 TimeInterval difference</A>
</H3>

<P>
This example shows how to calculate the difference between two 
   <TT>ESMF_TimeIntervals</TT>.  

<P>
<PRE>
      ! difference between two time intervals
      timeinterval3 = timeinterval2 - timeinterval1
     call ESMF_TimeIntervalGet(timeinterval3, d=d, h=h, m=m, s=s, rc=rc)
     print *, "Difference between TimeInterval2 and TimeInterval1 = ", &amp;
           d, " days, ", h, " hours, ", m, " minutes, ", s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062400000000000000">
39.2.4 TimeInterval multiplication</A>
</H3>

<P>
This example shows how to multiply an <TT>ESMF_TimeInterval</TT>.  

<P>
<PRE>
      ! multiply time interval by an integer
      timeinterval3 = timeinterval2 * 3
      call ESMF_TimeIntervalGet(timeinterval3, d=d, h=h, m=m, s=s, rc=rc)
      print *, "TimeInterval2 multiplied by 3 = ", d, " days, ", h, &amp;
               " hours, ", m, " minutes, ", s, " seconds."
</PRE>

<P>

<H3><A NAME="SECTION06062500000000000000">
39.2.5 TimeInterval comparison</A>
</H3>

<P>
This example shows how to compare two <TT>ESMF_TimeIntervals</TT>.  

<P>
<PRE>
      ! comparison
      if (timeinterval1 &lt; timeinterval2) then
        print *, "TimeInterval1 is smaller than TimeInterval2"
      else 
        print *, "TimeInterval1 is larger than or equal to TimeInterval2"
      end if

      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_TimeIntervalEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION06063000000000000000">
39.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limits on time span.</B> The limits on the time span that can be
represented are based on the 64-bit integer types used.  For
seconds, a signed 64-bit integer will have a range of +/- <IMG
 WIDTH="28" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img103.png"
 ALT="$2^{63}$">-1, or
+/- 9,223,372,036,854,775,807.  This corresponds to a range of
+/- (<IMG
 WIDTH="28" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img103.png"
 ALT="$2^{63}$">-1)/(86400 * 365.25) or +/- 292,271,023,045 years.

<P>
For fractional seconds, a signed 64-bit integer will handle a resolution of
+/- <IMG
 WIDTH="28" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img104.png"
 ALT="$2^{31}$">-1, or +/- 9,223,372,036,854,775,807 parts of a second.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION06064000000000000000">
39.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06064100000000000000">
39.4.1 ESMF_TimeIntervalAssignment(=) - Assign a TimeInterval to another TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       timeinterval1 = timeinterval2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval) :: timeinterval1
       type(ESMF_TimeInterval) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Set <TT>timeinterval1</TT> equal to <TT>timeinterval2</TT>.  This is the default
       Fortran assignment, which creates a complete, independent copy of
       <TT>timeinterval2</TT> as <TT>timeinterval1</TT>.  If <TT>timeinterval2</TT> is an
       invalid <TT>ESMF_TimeInterval</TT> object then <TT>timeinterval1</TT> will be
       equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to be set.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The <TT>ESMF_TimeInterval</TT> to be copied.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064200000000000000">
39.4.2 ESMF_TimeIntervalOperator(+) - Add two TimeIntervals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(+)
       sum = timeinterval1 + timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: sum
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (+) operator for the <TT>ESMF_TimeInterval</TT> class to
       add <TT>timeinterval1</TT> to <TT>timeinterval2</TT> and return the
       sum as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The augend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The addend.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064300000000000000">
39.4.3 ESMF_TimeIntervalOperator(-) - Subtract one TimeInterval from another</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(-)
       difference = timeinterval1 - timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: difference
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_TimeInterval</TT> class to
       subtract <TT>timeinterval2</TT> from <TT>timeinterval1</TT> and return
       the difference as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The minuend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The subtrahend.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064400000000000000">
39.4.4 ESMF_TimeIntervalOperator(-) - Perform unary negation on a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(-)
       timeinterval = -timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: -timeInterval
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (-) operator for the <TT>ESMF_TimeInterval</TT> class to
       perform unary negation on <TT>timeinterval</TT> and return the result.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The time interval to be negated.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064500000000000000">
39.4.5 ESMF_TimeIntervalOperator(/) - Divide two TimeIntervals, return double precision quotient</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/)
       quotient = timeinterval1 / timeinterval2
</PRE><EM>RETURN VALUE:</EM>
<PRE>       real(ESMF_KIND_R8) :: quotient
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>timeinterval1</TT> divided by <TT>timeinterval2</TT> as a
       double precision quotient.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064600000000000000">
39.4.6 ESMF_TimeIntervalOperator(/) - Divide a TimeInterval by an integer, return TimeInterval quotient </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/)
       quotient = timeinterval / divisor
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: quotient
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
       integer(ESMF_KIND_I4),   intent(in) :: divisor
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/) operator for the <TT>ESMF_TimeInterval</TT> class to
       divide a <TT>timeinterval</TT> by an integer <TT>divisor</TT>, and
       return the quotient as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>divisor</STRONG></DT>
<DD>Integer divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064700000000000000">
39.4.7 ESMF_TimeIntervalFunction(MOD) - Divide two TimeIntervals, return TimeInterval remainder</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface MOD
       function MOD(timeinterval1, timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: MOD
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the Fortran intrinsic MOD() function for the
       <TT>ESMF_TimeInterval</TT> class to return the remainder of 
       <TT>timeinterval1</TT> divided by <TT>timeinterval2</TT> as an 
       <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>The dividend.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>The divisor.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064800000000000000">
39.4.8 ESMF_TimeIntervalOperator(*) - Multiply a TimeInterval by an integer</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(*)
       product = timeinterval * multiplier
                     OR
       product = multiplier * timeinterval
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: product
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
       integer(ESMF_KIND_I4),   intent(in) :: multiplier
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (*) operator for the <TT>ESMF_TimeInterval</TT> class to
       multiply a <TT>timeinterval</TT> by an integer <TT>multiplier</TT>,
       and return the product as an <TT>ESMF_TimeInterval</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The multiplicand.
       
</DD>
<DT><STRONG>multiplier</STRONG></DT>
<DD>The integer multiplier.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06064900000000000000">
39.4.9 ESMF_TimeIntervalOperator(==) - Test if TimeInterval 1 is equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (timeinterval1 == timeinterval2) then ... endif
                    OR
       result = (timeinterval1 == timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> and <TT>timeinterval2</TT> 
       represent an equal duration of time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641000000000000000">
39.4.10 ESMF_TimeIntervalOperator(/=) - Test if TimeInterval 1 is not equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (timeinterval1 /= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 /= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> and <TT>timeinterval2</TT> do not 
       represent an equal duration of time, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641100000000000000">
39.4.11 ESMF_TimeIntervalOperator(&lt;) - Test if TimeInterval 1 is less than TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&lt;)
       if (timeinterval1 &lt; timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &lt; timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a lesser duration of time 
       than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641200000000000000">
39.4.12 ESMF_TimeIntervalOperator(&lt;=) - Test if TimeInterval 1 is less than or equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&lt;=)
       if (timeinterval1 &lt;= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &lt;= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&lt;=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a lesser or equal duration 
       of time than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641300000000000000">
39.4.13 ESMF_TimeIntervalOperator(&gt;) - Test if TimeInterval 1 is greater than TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&gt;)
       if (timeinterval1 &gt; timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &gt; timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a greater duration of time 
       than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641400000000000000">
39.4.14 ESMF_TimeIntervalOperator(&gt;=) - Test if TimeInterval 1 is greater than or equal to TimeInterval 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(&gt;=)
       if (timeinterval1 &gt;= timeinterval2) then ... endif
                    OR
       result = (timeinterval1 &gt;= timeinterval2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval1
       type(ESMF_TimeInterval), intent(in) :: timeinterval2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (&gt;=) operator for the <TT>ESMF_TimeInterval</TT> class to
       return <TT>.true.</TT> if <TT>timeinterval1</TT> is a greater or equal 
       duration of time than <TT>timeinterval2</TT>, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval1</STRONG></DT>
<DD>First <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
<DT><STRONG>timeinterval2</STRONG></DT>
<DD>Second <TT>ESMF_TimeInterval</TT> in comparison.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641500000000000000">
39.4.15 ESMF_TimeIntervalAbsValue - Get the absolute value of a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_TimeIntervalAbsValue(timeinterval)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: ESMF_TimeIntervalAbsValue
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the absolute value of <TT>timeinterval</TT>.

<P>
The argument is:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to take the absolute value of.
            Absolute value is returned as the value of the function.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641600000000000000">
39.4.16 ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDur(timeinterval, &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer years (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer years (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer months (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer months (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641700000000000000">
39.4.17 ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurStart(timeinterval, startTimeIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTimeIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>startTimeIn</STRONG></DT>
<DD>INPUT argument:  pins a calendar interval to a specific point
            in time to allow conversion between relative units (yy, mm, d) and
            absolute units (d, h, m, s).  Overrides any startTime and/or endTime
            previously set.  Mutually exclusive with endTimeIn and calendarIn.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer years (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer years (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer months (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer months (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641800000000000000">
39.4.18 ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurCal(timeinterval, calendarIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendarIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>calendarIn</STRONG></DT>
<DD>INPUT argument:  pins a calendar interval to a specific calendar
            to allow conversion between relative units (yy, mm, d) and
            absolute units (d, h, m, s).  Mutually exclusive with startTimeIn
            and endTimeIn since they contain a calendar.  Alternate to, and
            mutually exclusive with, calkindflagIn below.  Primarily for
            specifying a custom calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer years (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer years (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer months (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer months (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit). 
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit). 
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060641900000000000000">
39.4.19 ESMF_TimeIntervalGet - Get a TimeInterval value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalGet()
       subroutine ESMF_TimeIntervalGetDurCalTyp(timeinterval, calkindflagIn, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         startTime, &amp;
         calendar, calkindflag, &amp;
         timeString, &amp;
         timeStringISOFrac, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflagIn ! Input
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(out), optional :: yy
       integer(ESMF_KIND_I8),   intent(out), optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: mm
       integer(ESMF_KIND_I8),   intent(out), optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: d
       integer(ESMF_KIND_I8),   intent(out), optional :: d_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: h
       integer(ESMF_KIND_I4),   intent(out), optional :: m
       integer(ESMF_KIND_I4),   intent(out), optional :: s
       integer(ESMF_KIND_I8),   intent(out), optional :: s_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: ms
       integer(ESMF_KIND_I4),   intent(out), optional :: us
       integer(ESMF_KIND_I4),   intent(out), optional :: ns
       real(ESMF_KIND_R8),      intent(out), optional :: d_r8
       real(ESMF_KIND_R8),      intent(out), optional :: h_r8
       real(ESMF_KIND_R8),      intent(out), optional :: m_r8
       real(ESMF_KIND_R8),      intent(out), optional :: s_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ms_r8
       real(ESMF_KIND_R8),      intent(out), optional :: us_r8
       real(ESMF_KIND_R8),      intent(out), optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(out), optional :: sN
       integer(ESMF_KIND_I8),   intent(out), optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(out), optional :: sD
       integer(ESMF_KIND_I8),   intent(out), optional :: sD_i8
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       character (len=*),       intent(out), optional :: timeString
       character (len=*),       intent(out), optional :: timeStringISOFrac
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the value of <TT>timeinterval</TT> in units specified by the
       user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally from integers.

<P>
Units are bound (normalized) to the next larger unit specified.  For
       example, if a time interval is defined to be one day, then
       <TT>ESMF_TimeIntervalGet(d = days, s = seconds)</TT> would return
         <TT>days = 1</TT>, <TT>seconds = 0</TT>,
       whereas <TT>ESMF_TimeIntervalGet(s = seconds)</TT> would return
         <TT>seconds = 86400</TT>.

<P>
For timeString, converts <TT>ESMF_TimeInterval</TT>'s value into
       partial ISO 8601 format PyYmMdDThHmMs[:n/d]S.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
For timeStringISOFrac, converts <TT>ESMF_TimeInterval</TT>'s value into
       full ISO 8601 format PyYmMdDThHmMs[.f]S.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method <TT>ESMF_TimeIntervalPrint()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>calkindflagIn</STRONG></DT>
<DD>INPUT argument:  Alternate to, and mutually exclusive with,
            calendarIn above.  More convenient way of specifying a built-in
            calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer years (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer years (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer months (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer months (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>Starting time, if set, of an absolute calendar interval
            (yy, mm, and/or d).
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>Associated <TT>Calendar</TT>, if any.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>Associated <TT>CalKind_Flag</TT>, if any.
       
</DD>
<DT><STRONG>[timeString]</STRONG></DT>
<DD>Convert time interval value to format string PyYmMdDThHmMs[:n/d]S,
            where n/d is numerator/denominator of any fractional seconds and
            all other units are in ISO 8601 format.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and
&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.

</DD>
<DT><STRONG>[timeStringISOFrac]</STRONG></DT>
<DD>Convert time interval value to strict ISO 8601 format string
            PyYmMdDThHmMs[.f], where f is decimal form of any fractional
            seconds.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>]. See also method
            <TT>ESMF_TimeIntervalPrint()</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642000000000000000">
39.4.20 ESMF_TimeIntervalNegAbsValue - Return the negative absolute value of a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_TimeIntervalNegAbsValue(timeinterval)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_TimeInterval) :: ESMF_TimeIntervalNegAbsValue
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in) :: timeinterval
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the negative absolute value of <TT>timeinterval</TT>.

<P>
The argument is:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to take the negative absolute value of.
            Negative absolute value is returned as the value of the function.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642100000000000000">
39.4.21 ESMF_TimeIntervalPrint - Print the contents of a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeIntervalPrint(timeinterval, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
       character (len=*),       intent(in),  optional :: options
       integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out the contents of an <TT>ESMF_TimeInterval</TT> to <TT>stdout</TT>,
       in support of testing and debugging.  The options control the type of
       information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>Time interval to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options.  If none specified, prints all <TT>timeinterval</TT>
            property values. 
<BR>            "string" - prints <TT>timeinterval</TT>'s value in ISO 8601 format
                       for all units through seconds.  For any non-zero
                       fractional seconds, prints in integer rational
                       fraction form n/d.  Format is PyYmMdDThHmMs[:n/d]S,
                       where [:n/d] is the integer numerator and denominator
                       of the fractional seconds value, if present.
                       See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].  See also method
                       <TT>ESMF_TimeIntervalGet(..., timeString= , ...)</TT> 
<BR>            "string isofrac" - prints <TT>timeinterval</TT>'s value in strict
                       ISO 8601 format for all units, including any fractional
                       seconds part.  Format is PyYmMdDThHmMs[.f]S, where [.f]
                       represents fractional seconds in decimal form,
                       if present.  See&nbsp;[<A
 HREF="node8.html#ISO">12</A>] and&nbsp;[<A
 HREF="node8.html#ISOnotes">2</A>].
                       See also method <TT>ESMF_TimeIntervalGet(..., timeStringISOFrac= , ...)</TT> 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642200000000000000">
39.4.22 ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDur(timeinterval, &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer years (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer years (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer months (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer months (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.  Default = 0
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.  Default = 0
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.  Default = 0
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.  Default = 0
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.  Default = 0
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
            Default = 0
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
            Default = 1
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
            Default = 1
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642300000000000000">
39.4.23 ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurStart(timeinterval, startTime, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Time),         intent(in)            :: startTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>startTime</STRONG></DT>
<DD>Starting time of an absolute calendar interval 
            (yy, mm, and/or d); pins a calendar interval to a specific point 
            in time.  If not set, and calendar also not set, calendar interval 
            "floats" across all calendars and times.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer years (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer years (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer months (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer months (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.  Default = 0
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.  Default = 0
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.  Default = 0
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.  Default = 0
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.  Default = 0
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
            Default = 0
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
            Default = 1
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8).
                                                             (large, &gt;= 64-bit).
            Default = 1
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642400000000000000">
39.4.24 ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurCal(timeinterval, calendar, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_Calendar),     intent(in)            :: calendar
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calendar</STRONG></DT>
<DD><TT>Calendar</TT> used to give better definition to 
            calendar interval (yy, mm, and/or d) for arithmetic, comparison, 
            and conversion operations.  Allows calendar interval to "float" 
            across all times on a specific calendar.  Default = NULL; 
            if startTime also not specified, calendar interval "floats" across 
            all calendars and times.  Mutually exclusive with startTime since 
            it contains a calendar.  Alternate to, and mutually exclusive with, 
            calkindflag below.  Primarily for specifying a custom calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer years (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer years (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer months (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer months (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.  Default = 0
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.  Default = 0
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.  Default = 0
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.  Default = 0
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.  Default = 0
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
            Default = 0
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8).
                                                             (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
            Default = 1
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8).
                                                             (large, &gt;= 64-bit).
            Default = 1
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642500000000000000">
39.4.25 ESMF_TimeIntervalSet - Initialize or set a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_TimeIntervalSet()
       subroutine ESMF_TimeIntervalSetDurCalTyp(timeinterval, calkindflag, &amp;
         &amp;
         yy, yy_i8, &amp;
         mm, mm_i8, &amp;
         d, d_i8, &amp;
         h, m, &amp;
         s, s_i8, &amp;
         ms, us, ns, &amp;
         d_r8, h_r8, m_r8, s_r8, &amp;
         ms_r8, us_r8, ns_r8, &amp;
         sN, sN_i8, sD, sD_i8, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(inout)         :: timeinterval
       type(ESMF_CalKind_Flag), intent(in)            :: calkindflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),   intent(in),  optional :: yy
       integer(ESMF_KIND_I8),   intent(in),  optional :: yy_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: mm
       integer(ESMF_KIND_I8),   intent(in),  optional :: mm_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: d
       integer(ESMF_KIND_I8),   intent(in),  optional :: d_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: h
       integer(ESMF_KIND_I4),   intent(in),  optional :: m
       integer(ESMF_KIND_I4),   intent(in),  optional :: s
       integer(ESMF_KIND_I8),   intent(in),  optional :: s_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: ms
       integer(ESMF_KIND_I4),   intent(in),  optional :: us
       integer(ESMF_KIND_I4),   intent(in),  optional :: ns
       real(ESMF_KIND_R8),      intent(in),  optional :: d_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: h_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: m_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: s_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ms_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: us_r8
       real(ESMF_KIND_R8),      intent(in),  optional :: ns_r8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sN
       integer(ESMF_KIND_I8),   intent(in),  optional :: sN_i8
       integer(ESMF_KIND_I4),   intent(in),  optional :: sD
       integer(ESMF_KIND_I8),   intent(in),  optional :: sD_i8
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the value of the <TT>ESMF_TimeInterval</TT> in units specified by
       the user via Fortran optional arguments.

<P>
The ESMF Time Manager represents and manipulates time internally with
       integers to maintain precision.  Hence, user-specified floating point
       values are converted internally to integers.

<P>
Ranges are limited only by machine word size.  Numeric defaults are 0,
       except for sD, which is 1.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD>The object instance to initialize.
       
</DD>
<DT><STRONG>calkindflag</STRONG></DT>
<DD>Alternate to, and mutually exclusive with, 
            calendar above.  More convenient way of specifying a built-in 
            calendar kind.
       
</DD>
<DT><STRONG>[yy]</STRONG></DT>
<DD>Integer years (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[yy_i8]</STRONG></DT>
<DD>Integer years (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm]</STRONG></DT>
<DD>Integer months (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[mm_i8]</STRONG></DT>
<DD>Integer months (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[d]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[d_i8]</STRONG></DT>
<DD>Integer Julian, or Modified Julian, days (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[h]</STRONG></DT>
<DD>Integer hours.  Default = 0
       
</DD>
<DT><STRONG>[m]</STRONG></DT>
<DD>Integer minutes.  Default = 0
       
</DD>
<DT><STRONG>[s]</STRONG></DT>
<DD>Integer seconds (&gt;= 32-bit).  Default = 0
       
</DD>
<DT><STRONG>[s_i8]</STRONG></DT>
<DD>Integer seconds (large, &gt;= 64-bit).  Default = 0
       
</DD>
<DT><STRONG>[ms]</STRONG></DT>
<DD>Integer milliseconds.  Default = 0
       
</DD>
<DT><STRONG>[us]</STRONG></DT>
<DD>Integer microseconds.  Default = 0
       
</DD>
<DT><STRONG>[ns]</STRONG></DT>
<DD>Integer nanoseconds.  Default = 0
       
</DD>
<DT><STRONG>[d_r8]</STRONG></DT>
<DD>Double precision days.  Default = 0.0.
       
</DD>
<DT><STRONG>[h_r8]</STRONG></DT>
<DD>Double precision hours.  Default = 0.0.
       
</DD>
<DT><STRONG>[m_r8]</STRONG></DT>
<DD>Double precision minutes.  Default = 0.0.
       
</DD>
<DT><STRONG>[s_r8]</STRONG></DT>
<DD>Double precision seconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ms_r8]</STRONG></DT>
<DD>Double precision milliseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[us_r8]</STRONG></DT>
<DD>Double precision microseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[ns_r8]</STRONG></DT>
<DD>Double precision nanoseconds.  Default = 0.0.
       
</DD>
<DT><STRONG>[sN]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN/sD).
            Default = 0
       
</DD>
<DT><STRONG>[sN_i8]</STRONG></DT>
<DD>Integer numerator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
            Default = 0
       
</DD>
<DT><STRONG>[sD]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN/sD).
            Default = 1
       
</DD>
<DT><STRONG>[sD_i8]</STRONG></DT>
<DD>Integer denominator of fractional seconds (sN_i8/sD_i8)
                                                             (large, &gt;= 64-bit).
            Default = 1
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060642600000000000000">
39.4.26 ESMF_TimeIntervalValidate - Validate a TimeInterval</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_TimeIntervalValidate(timeinterval, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeinterval
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>timeinterval</TT> is valid.
       If fractional value, denominator must be non-zero.

<P>
The arguments are:
       <DL>
<DT><STRONG>timeinterval</STRONG></DT>
<DD><TT>ESMF_TimeInterval</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H1><A NAME="SECTION06070000000000000000">
40 Clock Class</A>
</H1>

<P>

<H2><A NAME="SECTION06071000000000000000">
40.1 Description</A>
</H2>

<P>
<A NAME="sec:Clock"></A>
<P>
The Clock class advances model time and tracks its associated
date on a specified Calendar.  It stores start time, stop time,
current time, previous time, and a time step.  It can also store
a reference time, typically the time instant at which a simulation 
originally began.  For a restart run, the reference time can be 
different than the start time, when the application execution resumes.

<P>
A user can call the <TT>ESMF_ClockSet</TT> method and reset the time 
step as desired.  

<P>
A Clock also stores a list of Alarms, which can be set to flag 
events that occur at a specified time instant or at 
a specified time interval.  See Section&nbsp;<A HREF="node6.html#sec:Alarm">41.1</A> for 
details on how to use Alarms.

<P>
There are methods for setting and getting the Times and 
Alarms associated with a Clock.  Methods are defined for 
advancing the Clock's current time, checking if the 
stop time has been reached, reversing direction, and 
synchronizing with a real clock. 

<P>

<H2><A NAME="SECTION06072000000000000000">
40.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION06072100000000000000"></A>
<A NAME="const:direction"></A>
<BR>
40.2.1 ESMF_DIRECTION
</H3>

<P>
<I>DESCRIPTION:
<BR></I>

Specifies the time-stepping direction of a clock.  Use with "direction"
argument to methods <TT>ESMF_ClockSet()</TT> and <TT>ESMF_ClockGet()</TT>.
Cannot be used with method <TT>ESMF_ClockCreate()</TT>, since it only
initializes a clock in the default forward mode; a clock must be advanced
(timestepped) at least once before reversing direction via
<TT>ESMF_ClockSet()</TT>.  This also holds true for negative timestep clocks
which are initialized (created) with stopTime &lt; startTime, since "forward"
means timestepping from startTime towards stopTime
(see <TT>ESMF_DIRECTION_FORWARD</TT> below).

<P>
"Forward" and "reverse" directions are distinct from postive and negative
timesteps.  "Forward" means timestepping in the direction established at
<TT>ESMF_ClockCreate()</TT>, from startTime towards stopTime, regardless
of the timestep sign.  "Reverse" means timestepping in the opposite direction,
back towards the clock's startTime, regardless of the timestep sign.

<P>
Clocks and alarms run in reverse in such a way that the state of a clock and
its alarms after each time step is precisely replicated as it was in forward
time-stepping mode.  All methods which query clock and alarm state will
return the same result for a given timeStep, regardless of the direction of
arrival.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Direction_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DIRECTION_FORWARD</STRONG></DT>
<DD>Upon calling <TT>ESMF_ClockAdvance()</TT>, the clock will timestep from
its startTime toward its stopTime.  This is the default direction.  A user
can use either <TT>ESMF_ClockIsStopTime()</TT> or <TT>ESMF_ClockIsDone()</TT>
methods to determine when stopTime is reached.  This forward behavior also
holds for negative timestep clocks which are initialized (created) with
stopTime &lt; startTime.

<P>
</DD>
<DT><STRONG>ESMF_DIRECTION_REVERSE</STRONG></DT>
<DD>Upon calling <TT>ESMF_ClockAdvance()</TT>, the clock will timestep backwards
toward its startTime.  Use method <TT>ESMF_ClockIsDone()</TT> to determine when
startTime is reached.  This reverse behavior also holds for negative timestep
clocks which are initialized (created) with stopTime &lt; startTime.

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION06073000000000000000">
40.3 Use and Examples</A>
</H2>

<P>
The following is a typical sequence for using a Clock in a 
geophysical model.

<P>
<B>At initialize:</B>

<UL>
<LI>Set a Calendar.
</LI>
<LI>Set start time, stop time and time step as Times and 
Time Intervals.
</LI>
<LI>Create and Initialize a Clock using the start time, stop time and time
step.
</LI>
<LI>Define Times and Time Intervals associated with special
events, and use these to set Alarms.
</LI>
</UL>

<P>
<B>At run:</B>

<UL>
<LI>Advance the Clock, checking for ringing alarms as needed.
</LI>
<LI>Check if it is time to stop.
</LI>
</UL>

<P>
<B>At finalize:</B>

<UL>
<LI>Since Clocks and Alarms are deep classes, they need to be explicitly
destroyed at finalization.  Times and TimeIntervals are lightweight classes,
so they don't need explicit destruction.
</LI>
</UL>

<P>
The following code example illustrates Clock usage.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_ClockEx - Clock initialization and time-stepping
!
! !DESCRIPTION:
!
! This program shows an example of how to create, initialize, advance, and
! examine a basic clock
!-----------------------------------------------------------------------------

      ! ESMF Framework module
      use ESMF
      implicit none

      ! instantiate a clock 
      type(ESMF_Clock) :: clock

      ! instantiate time_step, start and stop times
      type(ESMF_TimeInterval) :: timeStep
      type(ESMF_Time) :: startTime
      type(ESMF_Time) :: stopTime

      ! local variables for Get methods
      type(ESMF_Time) :: currTime
      integer(ESMF_KIND_I8) :: advanceCount
      integer :: YY, MM, DD, H, M, S

      ! return code
      integer :: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="ClockEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06073100000000000000">
40.3.1 Clock creation</A>
</H3>

<P>
This example shows how to create and initialize an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! initialize time interval to 2 days, 4 hours (6 timesteps in 13 days)
      call ESMF_TimeIntervalSet(timeStep, d=2, h=4, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize start time to 4/1/2003 2:24:00 ( 1/10 of a day )
      call ESMF_TimeSet(startTime, yy=2003, mm=4, dd=1, h=2, m=24, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize stop time to 4/14/2003 2:24:00 ( 1/10 of a day )
      call ESMF_TimeSet(stopTime, yy=2003, mm=4, dd=14, h=2, m=24, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize the clock with the above values
      clock = ESMF_ClockCreate(timeStep, startTime, stopTime=stopTime, &amp;
                               name="Clock 1", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06073200000000000000">
40.3.2 Clock advance</A>
</H3>

<P>
This example shows how to time-step an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! time step clock from start time to stop time
      do while (.not.ESMF_ClockIsStopTime(clock, rc=rc))
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockAdvance(clock, rc=rc)
</PRE>

<P>
<PRE>
      end do
</PRE>

<P>

<H3><A NAME="SECTION06073300000000000000">
40.3.3 Clock examination</A>
</H3>

<P>
This example shows how to examine an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! get the clock's final current time
      call ESMF_ClockGet(clock, currTime=currTime, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeGet(currTime, yy=YY, mm=MM, dd=DD, h=H, m=M, s=S, rc=rc) 
      print *, "The clock's final current time is ", YY, "/", MM, "/", DD, &amp;
               " ", H, ":", M, ":", S
</PRE>

<P>
<PRE>
      ! get the number of times the clock was advanced
      call ESMF_ClockGet(clock, advanceCount=advanceCount, rc=rc)
      print *, "The clock was advanced ", advanceCount, " times."
</PRE>

<P>

<H3><A NAME="SECTION06073400000000000000">
40.3.4 Clock reversal</A>
</H3>

<P>
This example shows how to time-step an <TT>ESMF_Clock</TT> in reverse mode. 

<P>
<PRE>
      call ESMF_ClockSet(clock, direction=ESMF_DIRECTION_REVERSE, rc=rc)
</PRE>

<P>
<PRE>
      ! time step clock in reverse from stop time back to start time;
      !  note use of ESMF_ClockIsDone() rather than ESMF_ClockIsStopTime()
      do while (.not.ESMF_ClockIsDone(clock, rc=rc))
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockAdvance(clock, rc=rc)
</PRE>

<P>
<PRE>
      end do
</PRE>

<P>

<H3><A NAME="SECTION06073500000000000000">
40.3.5 Clock destruction</A>
</H3>

<P>
This example shows how to destroy an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! destroy clock
      call ESMF_ClockDestroy(clock, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_ClockEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION06074000000000000000">
40.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Alarm list allocation factor</B>  The alarm list within a clock is
dynamically allocated automatically, 200 alarm references at a time.
This constant is defined in both Fortran and C++ with a #define for ease
of modification.

<P>
</LI>
<LI><B>Clock variable timesteps in reverse</B> 

In order for a clock with
variable timesteps to be run in <TT>ESMF_DIRECTION_REVERSE</TT>, the user must
supply those timesteps to <TT>ESMF_ClockAdvance()</TT>.  Essentially, the user
must save the timesteps while in forward mode.  In a future release, the
Time Manager will assume this responsibility by saving the clock state
(including the timeStep) at every timestep while in forward mode.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION06075000000000000000">
40.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06075100000000000000">
40.5.1 ESMF_ClockAssignment(=) - Assign a Clock to another Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       clock1 = clock2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock) :: clock1
       type(ESMF_Clock) :: clock2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign <TT>clock1</TT> as an alias to the same <TT>ESMF_Clock</TT> object in 
       memory as <TT>clock2</TT>. If <TT>clock2</TT> is invalid, then <TT>clock1</TT> 
       will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the 
            assignment.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the 
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075200000000000000">
40.5.2 ESMF_ClockOperator(==) - Test if Clock 1 is equal to Clock 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (clock1 == clock2) then ... endif
                    OR
       result = (clock1 == clock2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in) :: clock1
       type(ESMF_Clock), intent(in) :: clock2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Clock</TT> class.
       Compare two clocks for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created clocks and identical for clocks created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both
       sides are in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075300000000000000">
40.5.3 ESMF_ClockOperator(/=) - Test if Clock 1 is not equal to Clock 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (clock1 /= clock2) then ... endif
                    OR
       result = (clock1 /= clock2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in) :: clock1
       type(ESMF_Clock), intent(in) :: clock2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Clock</TT> class.
       Compare two clocks for inequality; return <TT>.true.</TT> if not equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created clocks and identical for clocks created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both sides
       are <EM>not</EM> in the <EM>same</EM> status, and <TT>.false.</TT> otherwise. 

<P>
The arguments are:
       <DL>
<DT><STRONG>clock1</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the left hand side of the 
            non-equality operation.
       
</DD>
<DT><STRONG>clock2</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> object on the right hand side of the 
            non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075400000000000000">
40.5.4 ESMF_ClockAdvance - Advance a Clock's current time by one time step</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockAdvance(clock, &amp;
         timeStep, ringingAlarmList, ringingAlarmCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       type(ESMF_Alarm),        intent(out), optional :: ringingAlarmList(:)
       integer,                 intent(out), optional :: ringingAlarmCount
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Advances the <TT>clock</TT>'s current time by one time step:  either the
       <TT>clock</TT>'s, or the passed-in <TT>timeStep</TT> (see below).  When the
       <TT>clock</TT> is in <TT>ESMF_DIRECTION_FORWARD</TT> (default), this method
       adds the <TT>timeStep</TT> to the <TT>clock</TT>'s current time.
       In <TT>ESMF_DIRECTION_REVERSE</TT>, <TT>timeStep</TT> is subtracted from the
       current time.  In either case, <TT>timeStep</TT> can be positive or negative.
       See the "direction" argument in method <TT>ESMF_ClockSet()</TT>.
       <TT>ESMF_ClockAdvance()</TT> optionally returns a list and number of ringing
       <TT>ESMF_Alarm</TT>s.  See also method <TT>ESMF_ClockGetRingingAlarms()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to advance.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Time step is performed with given timeStep, instead of
            the <TT>ESMF_Clock</TT>'s.  Does not replace the <TT>ESMF_Clock</TT>'s 
            timeStep; use <TT>ESMF_ClockSet(clock, timeStep, ...)</TT> for
            this purpose.  Supports applications with variable time steps.
            timeStep can be positive or negative.
       
</DD>
<DT><STRONG>[ringingAlarmList]</STRONG></DT>
<DD>Returns the array of alarms that are ringing after the
            time step.
       
</DD>
<DT><STRONG>[ringingAlarmCount]</STRONG></DT>
<DD>The number of alarms ringing after the time step.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075500000000000000">
40.5.5 ESMF_ClockCreate - Create a new ESMF Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_ClockCreate()
       function ESMF_ClockCreateNew(timeStep, startTime, &amp;
         stopTime, runDuration, runTimeStepCount, refTime, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Clock) :: ESMF_ClockCreateNew
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_TimeInterval), intent(in)            :: timeStep
       type(ESMF_Time),         intent(in)            :: startTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: runDuration
       integer,                 intent(in),  optional :: runTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates and sets the initial values in a new <TT>ESMF_Clock</TT>.    

<P>
The arguments are:
       <DL>
<DT><STRONG>timeStep</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval, which can be
            positive or negative.
       
</DD>
<DT><STRONG>startTime</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.  Can be less than or
            or greater than stopTime, depending on a positive or negative
            timeStep, respectively, and whether a stopTime is specified;
            see below.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.  Can be greater than or
            less than the startTime, depending on a positive or negative
            timeStep, respectively.  If neither stopTime, runDuration, nor
            runTimeStepCount is specified, clock runs "forever"; user must
            use other means to know when to stop (e.g. ESMF_Alarm or
            ESMF_ClockGet(clock, currTime)).  Mutually exclusive with
            runDuration and runTimeStepCount.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + runDuration.
            Can be positive or negative, consistent with the timeStep's sign.
            Mutually exclusive with stopTime and runTimeStepCount.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + (runTimeStepCount * timeStep).
            stopTime can be before startTime if timeStep is negative.
            Mutually exclusive with stopTime and runDuration.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.  Provides reference point
            for simulation time (see currSimTime in ESMF_ClockGet() below).
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created clock.  If not specified, a
            default unique name will be generated: "ClockNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075600000000000000">
40.5.6 ESMF_ClockCreate - Create a copy of an existing ESMF Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_ClockCreate()
       function ESMF_ClockCreateCopy(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Clock) :: ESMF_ClockCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a deep copy of a given <TT>ESMF_Clock</TT>, but does not copy its
       list of <TT>ESMF_Alarm</TT>s (pointers), since an <TT>ESMF_Alarm</TT> can only
       be associated with one <TT>ESMF_Clock</TT>.  Hence, the returned
       <TT>ESMF_Clock</TT> copy has no associated <TT>ESMF_Alarm</TT>s, the same as
       with a newly created <TT>ESMF_Clock</TT>.  If desired, new
       <TT>ESMF_Alarm</TT>s must be created and associated with this copied
       <TT>ESMF_Clock</TT> via <TT>ESMF_AlarmCreate()</TT>, or existing 
       <TT>ESMF_Alarm</TT>s must be re-associated with this copied
       <TT>ESMF_Clock</TT> via <TT>ESMF_AlarmSet(...clock=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075700000000000000">
40.5.7 ESMF_ClockDestroy - Release resources associated with a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockDestroy(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)          :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Clock</TT>.  This releases
       the list of associated <TT>ESMF_Alarm</TT>s (pointers), but not the
       <TT>ESMF_Alarm</TT>s themselves; the user must explicitly call 
       <TT>ESMF_AlarmDestroy()</TT> on each <TT>ESMF_Alarm</TT> to release its
       resources.  <TT>ESMF_ClockDestroy()</TT> and corresponding 
       <TT>ESMF_AlarmDestroy()</TT>s can be called in either order.

<P>
If <TT>ESMF_ClockDestroy()</TT> is called before <TT>ESMF_AlarmDestroy()</TT>,
       any <TT>ESMF_Alarm</TT>s that were in the <TT>ESMF_Clock</TT>'s list will  
       no longer be associated with any <TT>ESMF_Clock</TT>.  If desired,
       these "orphaned" <TT>ESMF_Alarm</TT>s can be associated with a different
       <TT>ESMF_Clock</TT> via a call to <TT>ESMF_AlarmSet(...clock=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Clock</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075800000000000000">
40.5.8 ESMF_ClockGet - Get a Clock's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGet(clock, &amp;
         timeStep, startTime, stopTime, &amp;
         runDuration, runTimeStepCount, refTime, currTime, prevTime, &amp;
         currSimTime, prevSimTime, calendar, calkindflag, timeZone, &amp;
         advanceCount, alarmCount, direction, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(out), optional :: timeStep
       type(ESMF_Time),         intent(out), optional :: startTime
       type(ESMF_Time),         intent(out), optional :: stopTime
       type(ESMF_TimeInterval), intent(out), optional :: runDuration
       real(ESMF_KIND_R8),      intent(out), optional :: runTimeStepCount
       type(ESMF_Time),         intent(out), optional :: refTime
       type(ESMF_Time),         intent(out), optional :: currTime
       type(ESMF_Time),         intent(out), optional :: prevTime
       type(ESMF_TimeInterval), intent(out), optional :: currSimTime
       type(ESMF_TimeInterval), intent(out), optional :: prevSimTime
       type(ESMF_Calendar),     intent(out), optional :: calendar
       type(ESMF_CalKind_Flag), intent(out), optional :: calkindflag
       integer,                 intent(out), optional :: timeZone
       integer(ESMF_KIND_I8),   intent(out), optional :: advanceCount
       integer,                 intent(out), optional :: alarmCount
       type(ESMF_Direction_Flag),    intent(out), optional :: direction
       character (len=*),       intent(out), optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets one or more of the properties of an <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval.
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to get <TT>ESMF_Clock</TT>'s stopping time;
               runDuration = stopTime - startTime.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to get <TT>ESMF_Clock</TT>'s stopping time;
               runTimeStepCount = (stopTime - startTime) / timeStep.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.
       
</DD>
<DT><STRONG>[currTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s current time.
       
</DD>
<DT><STRONG>[prevTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s previous time.  Equals currTime at
            the previous time step.
       
</DD>
<DT><STRONG>[currSimTime]</STRONG></DT>
<DD>The current simulation time (currTime - refTime).
       
</DD>
<DT><STRONG>[prevSimTime]</STRONG></DT>
<DD>The previous simulation time.  Equals currSimTime at
            the previous time step.
       
</DD>
<DT><STRONG>[calendar]</STRONG></DT>
<DD>The <TT>Calendar</TT> on which all the <TT>Clock</TT>'s times are defined.
       
</DD>
<DT><STRONG>[calkindflag]</STRONG></DT>
<DD>The <TT>CalKind_Flag</TT> on which all the <TT>Clock</TT>'s times are
            defined.
       
</DD>
<DT><STRONG>[timeZone]</STRONG></DT>
<DD>The timezone within which all the <TT>Clock</TT>'s times are defined.
       
</DD>
<DT><STRONG>[advanceCount]</STRONG></DT>
<DD>The number of times the <TT>ESMF_Clock</TT> has been advanced.
            Increments in <TT>ESMF_DIRECTION_FORWARD</TT> and decrements in
            <TT>ESMF_DIRECTION_REVERSE</TT>; see "direction" argument below and 
            in <TT>ESMF_ClockSet()</TT>.

</DD>
<DT><STRONG>[alarmCount]</STRONG></DT>
<DD>The number of <TT>ESMF_Alarm</TT>s in the <TT>ESMF_Clock</TT>'s
            <TT>ESMF_Alarm</TT> list.
       
</DD>
<DT><STRONG>[direction]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time stepping direction.  See also
            <TT>ESMF_ClockIsReverse()</TT>, an alternative for convenient use in
            "if" and "do while" constructs.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this clock.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06075900000000000000">
40.5.9 ESMF_ClockGetAlarm - Get an Alarm in a Clock's Alarm list</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetAlarm(clock, alarmname, alarm, &amp;
         rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
       character (len=*), intent(in)            :: alarmname
       type(ESMF_Alarm),  intent(out)           :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the <TT>alarm</TT> whose name is the value of alarmname in the 
       <TT>clock</TT>'s <TT>ESMF_Alarm</TT> list.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to get the <TT>ESMF_Alarm</TT> from.
       
</DD>
<DT><STRONG>alarmname</STRONG></DT>
<DD>The name of the desired <TT>ESMF_Alarm</TT>.
       
</DD>
<DT><STRONG>alarm</STRONG></DT>
<DD>The desired alarm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751000000000000000">
40.5.10 ESMF_ClockGetAlarmList - Get a list of Alarms from a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetAlarmList(clock, alarmlistflag, &amp;
         timeStep, alarmList, alarmCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),          intent(in)            :: clock
       type(ESMF_AlarmList_Flag), intent(in)            :: alarmlistflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval),   intent(in),  optional :: timeStep
       type(ESMF_Alarm),          intent(out), optional :: alarmList(:)
       integer,                   intent(out), optional :: alarmCount
       integer,                   intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the <TT>clock</TT>'s list of alarms and/or number of alarms.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance from which to get an <TT>ESMF_Alarm</TT> list 
            and/or count of <TT>ESMF_Alarm</TT>s.
       
</DD>
<DT><STRONG>alarmlistflag</STRONG></DT>
<DD>The kind of list to get:

<P>
<TT>ESMF_ALARMLIST_ALL</TT> :
                  Returns the <TT>ESMF_Clock</TT>'s entire list of alarms.

<P>
<TT>ESMF_ALARMLIST_NEXTRINGING</TT> :
                  Return only those alarms that will ring upon the next
                  <TT>clock</TT> time step.  Can optionally specify argument
                  <TT>timeStep</TT> (see below) to use instead of the <TT>clock</TT>'s.
                  See also method <TT>ESMF_AlarmWillRingNext()</TT> for checking a
                  single alarm.

<P>
<TT>ESMF_ALARMLIST_PREVRINGING</TT> :
                  
                  Return only those alarms that were ringing on the previous
                  <TT>ESMF_Clock</TT> time step.  See also method
                  <TT>ESMF_AlarmWasPrevRinging()</TT> for checking a single alarm.

<P>
<TT>ESMF_ALARMLIST_RINGING</TT> :
                  Returns only those <TT>clock</TT> alarms that are currently
                  ringing.  See also method <TT>ESMF_ClockAdvance()</TT> for
                  getting the list of ringing alarms subsequent to a time step.
                  See also method <TT>ESMF_AlarmIsRinging()</TT> for checking a
                  single alarm.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Optional time step to be used instead of the <TT>clock</TT>'s.
            Only used with <TT>ESMF_ALARMLIST_NEXTRINGING alarmlistflag</TT>
            (see above); ignored if specified with other <TT>alarmlistflags</TT>.

</DD>
<DT><STRONG>[alarmList]</STRONG></DT>
<DD>The array of returned alarms.  If given, the array must be large
            enough to hold the number of alarms of the specified 
            <TT>alarmlistflag</TT> in the specified <TT>clock</TT>.
       
</DD>
<DT><STRONG>[alarmCount]</STRONG></DT>
<DD>If specified, returns the number of <TT>ESMF_Alarm</TT>s of the 
            specified <TT>alarmlistflag</TT> in the specified <TT>clock</TT>.  
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751100000000000000">
40.5.11 ESMF_ClockGetNextTime - Calculate a Clock's next time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockGetNextTime(clock, nextTime, &amp;
         timeStep, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
       type(ESMF_Time),         intent(out)           :: nextTime
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Calculates what the next time of the <TT>clock</TT> will be, based on
       the <TT>clock</TT>'s current time step or an optionally passed-in
       <TT>timeStep</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance for which to get the next time.
       
</DD>
<DT><STRONG>nextTime</STRONG></DT>
<DD>The resulting <TT>ESMF_Clock</TT>'s next time.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The time step interval to use instead of the clock's.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751200000000000000">
40.5.12 ESMF_ClockIsDone - Based on its direction, test if the Clock has reached or exceeded its stop time or start time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_ClockIsDone(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsDone
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if currentTime is greater than or equal to stopTime
       in <TT>ESMF_DIRECTION_FORWARD</TT>, or if currentTime is less than or 
       equal to startTime in <TT>ESMF_DIRECTION_REVERSE</TT>.  It returns false 
       otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751300000000000000">
40.5.13 ESMF_ClockIsReverse - Test if the Clock is in reverse mode</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_ClockIsReverse(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsReverse
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if clock is in <TT>ESMF_DIRECTION_REVERSE</TT>, and false if 
       in <TT>ESMF_DIRECTION_FORWARD</TT>.  Allows convenient use in "if" and 
       "do while" constructs.  Alternative to 
       <TT>ESMF_ClockGet(...direction=...)</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751400000000000000">
40.5.14 ESMF_ClockIsStopTime - Test if the Clock has reached or exceeded its stop time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_ClockIsStopTime(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsStopTime
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if the <TT>clock</TT> has reached or exceeded its stop time,
       and false otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751500000000000000">
40.5.15 ESMF_ClockIsStopTimeEnabled - Test if the Clock's stop time is enabled</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_ClockIsStopTimeEnabled(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_ClockIsStopTimeEnabled
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns true if the <TT>clock</TT>'s stop time is set and enabled,
       and false otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to check.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751600000000000000">
40.5.16 ESMF_ClockPrint - Print the contents of a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockPrint(clock, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
       character (len=*), intent(in),  optional :: options
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Clock</TT>'s properties to <TT>stdout</TT>, in
       support of testing and debugging.  The options control the type of
       information and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD><TT>ESMF_Clock</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all <TT>clock</TT> property
            values.
<BR>            "advanceCount" - print the number of times the clock has been
                             advanced. 
<BR>            "alarmCount"   - print the number of alarms in the clock's list. 
<BR>            "alarmList"    - print the clock's alarm list. 
<BR>            "currTime"     - print the current clock time. 
<BR>            "direction"    - print the clock's timestep direction. 
<BR>            "name"         - print the clock's name. 
<BR>            "prevTime"     - print the previous clock time. 
<BR>            "refTime"      - print the clock's reference time. 
<BR>            "startTime"    - print the clock's start time. 
<BR>            "stopTime"     - print the clock's stop time. 
<BR>            "timeStep"     - print the clock's time step. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751700000000000000">
40.5.17 ESMF_ClockSet - Set one or more properties of a Clock</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockSet(clock, &amp;
         timeStep, startTime, stopTime, &amp;
         runDuration, runTimeStepCount, refTime, currTime, advanceCount, &amp;
         direction, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       type(ESMF_Time),         intent(in),  optional :: startTime
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: runDuration
       integer,                 intent(in),  optional :: runTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       type(ESMF_Time),         intent(in),  optional :: currTime
       integer(ESMF_KIND_I8),   intent(in),  optional :: advanceCount
       type(ESMF_Direction_Flag),    intent(in),  optional :: direction
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets/resets one or more of the properties of an <TT>ESMF_Clock</TT> that
       was previously initialized via <TT>ESMF_ClockCreate()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to set.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s time step interval, which can be positive or
            negative.  This is used to change a clock's timestep property for
            those applications that need variable timesteps.  See
            <TT>ESMF_ClockAdvance()</TT> below for specifying variable timesteps
            that are NOT saved as the clock's internal time step property.
            See "direction" argument below for behavior with
            
<BR>
t ESMF_DIRECTION_REVERSE direction.
       
</DD>
<DT><STRONG>[startTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s starting time.  Can be less than or
            or greater than stopTime, depending on a positive or negative
            timeStep, respectively, and whether a stopTime is specified;
            see below.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s stopping time.  Can be greater than or
            less than the startTime, depending on a positive or negative
            timeStep, respectively.  If neither stopTime, runDuration, nor
            runTimeStepCount is specified, clock runs "forever"; user must
            use other means to know when to stop (e.g. ESMF_Alarm or
            ESMF_ClockGet(clock, currTime)).
            Mutually exclusive with runDuration and runTimeStepCount.
       
</DD>
<DT><STRONG>[runDuration]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + runDuration.
            Can be positive or negative, consistent with the timeStep's sign.
            Mutually exclusive with stopTime and runTimeStepCount.
       
</DD>
<DT><STRONG>[runTimeStepCount]</STRONG></DT>
<DD>Alternative way to specify <TT>ESMF_Clock</TT>'s stopping time;
               stopTime = startTime + (runTimeStepCount * timeStep).
            stopTime can be before startTime if timeStep is negative.
            Mutually exclusive with stopTime and runDuration.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The <TT>ESMF_Clock</TT>'s reference time.
            See description in <TT>ESMF_ClockCreate()</TT> above.
       
</DD>
<DT><STRONG>[currTime]</STRONG></DT>
<DD>The current time.
       
</DD>
<DT><STRONG>[advanceCount]</STRONG></DT>
<DD>The number of times the clock has been timestepped.
       
</DD>
<DT><STRONG>[direction]</STRONG></DT>
<DD>Sets the clock's time-stepping direction.  If called with
            <TT>ESMF_DIRECTION_REVERSE</TT>, sets the clock in "reverse" mode,
            causing it to timestep back towards its startTime.  If called
            with <TT>ESMF_DIRECTION_FORWARD</TT>, sets the clock in normal,
            "forward" mode, causing it to timestep in the direction of its
            startTime to stopTime.  This holds true for negative timestep
            clocks as well, which are initialized (created) with
            stopTime &lt; startTime.  The default mode is
            <TT>ESMF_DIRECTION_FORWARD</TT>, established at 
            <TT>ESMF_ClockCreate()</TT>.  timeStep can also be specified as an 
            argument at the same time, which allows for a change in magnitude 
            and/or sign of the clock's timeStep.  If not specified with 
            <TT>ESMF_DIRECTION_REVERSE</TT>, the clock's current timeStep is 
            effectively negated.  If timeStep is specified, its sign is used as 
            specified; it is not negated internally.  E.g., if the specified 
            timeStep is negative and the clock is placed in 
            <TT>ESMF_DIRECTION_REVERSE</TT>, subsequent calls to
            <TT>ESMF_ClockAdvance()</TT> will cause the clock's current time to
            be decremented by the new timeStep's magnitude.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this clock.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060751800000000000000">
40.5.18 ESMF_ClockStopTimeDisable - Disable a Clock's stop time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockStopTimeDisable(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Disables a <TT>ESMF_Clock</TT>'s stop time; <TT>ESMF_ClockIsStopTime()</TT>
       will always return false, allowing a clock to run past its stopTime.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance whose stop time to disable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060751900000000000000">
40.5.19 ESMF_ClockStopTimeEnable - Enable an Clock's stop time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockStopTimeEnable(clock, stopTime, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),  intent(in),  optional :: stopTime
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Enables a <TT>ESMF_Clock</TT>'s stop time, allowing
       <TT>ESMF_ClockIsStopTime()</TT> to respect the stopTime.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance whose stop time to enable.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time to set or reset.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060752000000000000000">
40.5.20 ESMF_ClockSyncToRealTime - Set Clock's current time to wall clock time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockSyncToRealTime(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock), intent(inout)         :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets a <TT>clock</TT>'s current time to the wall clock time.  It is
       accurate to the nearest second.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The object instance to be synchronized with wall clock time.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060752100000000000000">
40.5.21 ESMF_ClockValidate - Validate a Clock's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ClockValidate(clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),  intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>clock</TT> is valid.  
       Must have a valid startTime and timeStep.  If <TT>clock</TT> has a
       stopTime, its currTime must be within startTime to stopTime, inclusive;
       also startTime's and stopTime's calendars must be the same.

<P>
The arguments are:  
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD><TT>ESMF_Clock</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H1><A NAME="SECTION06080000000000000000">
41 Alarm Class</A>
</H1>

<P>

<H2><A NAME="SECTION06081000000000000000">
41.1 Description</A>
</H2>

<P>
<A NAME="sec:Alarm"></A>The Alarm class identifies events that occur at specific Times
or specific TimeIntervals by returning a true value at those times
or subsequent times, and a false value otherwise.  

<P>

<H2><A NAME="SECTION06082000000000000000">
41.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION06082100000000000000"></A>
<A NAME="const:alarmlist"></A>
<BR>
41.2.1 ESMF_ALARMLIST
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies the characteristics of Alarms that populate
a retrieved Alarm list.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_AlarmList_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_ALARMLIST_ALL</STRONG></DT>
<DD>All alarms.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_NEXTRINGING</STRONG></DT>
<DD>Alarms that will ring before or at the next timestep.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_PREVRINGING</STRONG></DT>
<DD>Alarms that rang at or since the last timestep.

<P>
</DD>
<DT><STRONG>ESMF_ALARMLIST_RINGING</STRONG></DT>
<DD>Only ringing alarms.

<P>
</DD>
</DL>

<P>

<H2><A NAME="SECTION06083000000000000000">
41.3 Use and Examples</A>
</H2>

<P>
Alarms are used in conjunction with Clocks (see Section&nbsp;<A HREF="node6.html#sec:Clock">40.1</A>).
Multiple Alarms can be associated with a Clock.  During the
<TT>ESMF_ClockAdvance()</TT> method, a Clock iterates over its internal Alarms
to determine if any are ringing.  Alarms ring when a specified Alarm 
time is reached or exceeded, taking into account whether the time step is
positive or negative.  In <TT>ESMF_DIRECTION_REVERSE</TT>
(see Section&nbsp;<A HREF="node6.html#sec:Clock">40.1</A>), alarms ring in reverse, i.e., they begin
ringing when they originally ended, and end ringing when they originally
began.  On completion of the time advance call, the Clock optionally returns
a list of ringing alarms.

<P>
Each ringing Alarm can then be processed using Alarm methods for identifying,
turning off, disabling or resetting the Alarm.

<P>
Alarm methods are defined for obtaining the ringing state, turning the
ringer on/off, enabling/disabling the Alarm, and getting/setting 
associated times.

<P>
The following example shows how to set and process Alarms.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_AlarmEx - Alarm examples
!
! !DESCRIPTION:
!
! This program shows an example of how to create, initialize, and process
! alarms associated with a clock.
!-----------------------------------------------------------------------------

      ! ESMF Framework module
      use ESMF
      implicit none

      ! instantiate time_step, start, stop, and alarm times
      type(ESMF_TimeInterval) :: timeStep, alarmInterval
      type(ESMF_Time) :: alarmTime, startTime, stopTime

      ! instantiate a clock 
      type(ESMF_Clock) :: clock

      ! instantiate Alarm lists
      integer, parameter :: NUMALARMS = 2
      type(ESMF_Alarm) :: alarm(NUMALARMS)

      ! local variables for Get methods
      integer :: ringingAlarmCount  ! at any time step (0 to NUMALARMS)

      ! name, loop counter, result code
      character (len=ESMF_MAXSTR) :: name
      integer :: i, rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultCalKind=ESMF_CALKIND_GREGORIAN, &amp;
        defaultlogfilename="AlarmEx.Log", &amp;
        logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083100000000000000">
41.3.1 Clock initialization</A>
</H3>

<P>
This example shows how to create and initialize an <TT>ESMF_Clock</TT>. 

<P>
<PRE>
      ! initialize time interval to 1 day
      call ESMF_TimeIntervalSet(timeStep, d=1, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize start time to 9/1/2003
      call ESMF_TimeSet(startTime, yy=2003, mm=9, dd=1, rc=rc)
</PRE>

<P>
<PRE>
      ! initialize stop time to 9/30/2003
      call ESMF_TimeSet(stopTime, yy=2003, mm=9, dd=30, rc=rc)
</PRE>

<P>
<PRE>
      ! create &amp; initialize the clock with the above values
      clock = ESMF_ClockCreate(timeStep, startTime, stopTime=stopTime, &amp;
                               name="The Clock", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083200000000000000">
41.3.2 Alarm initialization</A>
</H3>

<P>
This example shows how to create and initialize two <TT>ESMF_Alarms</TT> and
   associate them with the clock. 

<P>
<PRE>
      ! Initialize first alarm to be a one-shot on 9/15/2003 and associate
      ! it with the clock
      call ESMF_TimeSet(alarmTime, yy=2003, mm=9, dd=15, rc=rc)
</PRE>

<P>
<PRE>
      alarm(1) = ESMF_AlarmCreate(clock, &amp;
         ringTime=alarmTime, name="Example alarm 1", rc=rc)
</PRE>

<P>
<PRE>
      ! Initialize second alarm to ring on a 1 week interval starting 9/1/2003
      ! and associate it with the clock
      call ESMF_TimeSet(alarmTime, yy=2003, mm=9, dd=1, rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_TimeIntervalSet(alarmInterval, d=7, rc=rc)
</PRE>

<P>
<PRE>
      ! Alarm gets default name "Alarm002"
      alarm(2) = ESMF_AlarmCreate(clock=clock, ringTime=alarmTime, &amp;
                                  ringInterval=alarmInterval, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06083300000000000000">
41.3.3 Clock advance and Alarm processing</A>
</H3>

<P>
This example shows how to advance an <TT>ESMF_Clock</TT> and process any 
   resulting ringing alarms. 

<P>
<PRE>
      ! time step clock from start time to stop time
      do while (.not.ESMF_ClockIsStopTime(clock, rc=rc))
</PRE>

<P>
<PRE>
        ! perform time step and get the number of any ringing alarms
        call ESMF_ClockAdvance(clock, ringingAlarmCount=ringingAlarmCount, &amp;
                               rc=rc)
</PRE>

<P>
<PRE>
        call ESMF_ClockPrint(clock, options="currTime string", rc=rc)
</PRE>

<P>
<PRE>
        ! check if alarms are ringing
        if (ringingAlarmCount &gt; 0) then
          print *, "number of ringing alarms = ", ringingAlarmCount

          do i = 1, NUMALARMS
            if (ESMF_AlarmIsRinging(alarm(i), rc=rc)) then
</PRE>

<P>
<PRE>
              call ESMF_AlarmGet(alarm(i), name=name, rc=rc)
              print *, trim(name), " is ringing!"
</PRE>

<P>
<PRE>
              ! after processing alarm, turn it off
              call ESMF_AlarmRingerOff(alarm(i), rc=rc)
</PRE>

<P>
<PRE>
            end if ! this alarm is ringing
          end do ! each ringing alarm
        endif ! ringing alarms
      end do ! timestep clock
</PRE>

<P>

<H3><A NAME="SECTION06083400000000000000">
41.3.4 Alarm and Clock destruction</A>
</H3>

<P>
This example shows how to destroy <TT>ESMF_Alarms</TT> and <TT>ESMF_Clocks</TT>. 

<P>
<PRE>
      call ESMF_AlarmDestroy(alarm(1), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_AlarmDestroy(alarm(2), rc=rc)
</PRE>

<P>
<PRE>
      call ESMF_ClockDestroy(clock, rc=rc)
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_AlarmEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION06084000000000000000">
41.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Alarm list allocation factor</B>  The alarm list within a clock is
dynamically allocated automatically, 200 alarm references at a time.
This constant is defined in both Fortran and C++ with a #define for ease
of modification.

<P>
</LI>
<LI><B>Sticky alarm end times in reverse</B>  For sticky alarms, there is
an implicit limitation that in order to properly reverse timestep through a
ring end time, that time must have already been traversed in the forward
direction.  This is due to the fact that the Time Manager cannot predict
when user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
will be logged when this limitation is not satisfied.

<P>
</LI>
<LI><B>Sticky alarm ring interval in reverse</B>  

For repeating sticky alarms,
it is currently assumed that the ringInterval is constant, so that only the
time of the last call to <TT>ESMF_AlarmRingerOff()</TT> is saved.  In
<TT>ESMF_DIRECTION_REVERSE</TT>, this information is used to turn sticky alarms
back on.  In a future release, ringIntervals will be allowed to be variable,
by saving alarm state at every timestep.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION06085000000000000000">
41.5 Design and Implementation Notes</A>
</H2>

<P>
The Alarm class is designed as a deep, dynamically allocatable class,
based on a pointer type.  This allows for both indirect and direct
manipulation of alarms.  Indirect alarm manipulation is where ESMF_Alarm API
methods, such as ESMF_AlarmRingerOff(), are invoked on alarm references
(pointers) returned from ESMF_Clock queries such as "return ringing alarms."
Since the method is performed on an alarm reference, the actual alarm held
by the clock is affected, not just a user's local copy.  Direct alarm
manipulation is the more common case where alarm API methods are invoked on
the original alarm objects created by the user.

<P>
For consistency, the ESMF_Clock class is also designed as a deep, dynamically
allocatable class. 

<P>
An additional benefit from this approach is that Clocks and Alarms can be
created and used from anywhere in a user's code without regard to the scope
in which they were created.  In constrast, statically created Alarms and
Clocks would disappear if created within a user's routine that returns,
whereas dynamically allocated Alarms and Clocks will persist until explicitly
destroyed by the user.

<P>

<H2><A NAME="SECTION06086000000000000000">
41.6 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06086100000000000000">
41.6.1 ESMF_AlarmAssignment(=) - Assign an Alarm to another Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface assignment(=)
       alarm1 = alarm2
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm) :: alarm1
       type(ESMF_Alarm) :: alarm2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign <TT>alarm1</TT> as an alias to the same <TT>ESMF_Alarm</TT> object in 
       memory as <TT>alarm2</TT>. If <TT>alarm2</TT> is invalid, then <TT>alarm1</TT> 
       will be equally invalid after the assignment.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the 
            assignment.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the 
            assignment.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086200000000000000">
41.6.2 ESMF_AlarmOperator(==) - Test if Alarm 1 is equal to Alarm 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(==)
       if (alarm1 == alarm2) then ... endif
                    OR
       result = (alarm1 == alarm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in) :: alarm1
       type(ESMF_Alarm), intent(in) :: alarm2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_Alarm</TT> class.
       Compare two alarms for equality; return <TT>.true.</TT> if equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created alarms and identical for alarms created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both
       sides are in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the equality
            operation.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the equality
            operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086300000000000000">
41.6.3 ESMF_AlarmOperator(/=) - Test if Alarm 1 is not equal to Alarm 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       interface operator(/=)
       if (alarm1 /= alarm2) then ... endif
                    OR
       result = (alarm1 /= alarm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in) :: alarm1
       type(ESMF_Alarm), intent(in) :: alarm2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_Alarm</TT> class.
       Compare two alarms for inequality; return <TT>.true.</TT> if not equal,
       <TT>.false.</TT> otherwise. Comparison is based on IDs, which are distinct
       for newly created alarms and identical for alarms created as copies.

<P>
If either side of the equality test is not in the
       <TT>ESMF_INIT_CREATED</TT> status an error will be logged. However, this
       does not affect the return value, which is <TT>.true.</TT> when both sides
       are <EM>not</EM> in the <EM>same</EM> status, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm1</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the left hand side of the 
            non-equality operation.
       
</DD>
<DT><STRONG>alarm2</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> object on the right hand side of the 
            non-equality operation.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086400000000000000">
41.6.4 ESMF_AlarmCreate - Create a new ESMF Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_AlarmCreate()
       function ESMF_AlarmCreateNew(clock, &amp;
         ringTime, ringInterval, stopTime, ringDuration, ringTimeStepCount, &amp;
         refTime, enabled, sticky, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Alarm) :: ESMF_AlarmCreateNew
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Clock),        intent(in)            :: clock
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Time),         intent(in),  optional :: ringTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringInterval
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       logical,                 intent(in),  optional :: enabled
       logical,                 intent(in),  optional :: sticky
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates and sets the initial values in a new <TT>ESMF_Alarm</TT>.

<P>
In <TT>ESMF_DIRECTION_REVERSE</TT> (see Section&nbsp;<A HREF="node6.html#sec:Clock">40.1</A>), alarms 
       ring in reverse, i.e., they begin ringing when they originally ended, 
       and end ringing when they originally began.

<P>
The arguments are:
       <DL>
<DT><STRONG>clock</STRONG></DT>
<DD>The clock with which to associate this newly created alarm.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The ring time for a one-shot alarm or the first ring time for a 
            repeating (interval) alarm.  Must specify at least one of ringTime
            or ringInterval.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.  If
            <TT>ringTime</TT> is not also specified (first ring time), it will be
            calculated as the <TT>clock</TT>'s current time plus <TT>ringInterval</TT>.
            Must specify at least one of ringTime or ringInterval.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.  If not
            specified, an interval alarm will repeat forever.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The absolute ring duration.  If not sticky (see argument below),
            alarms rings for ringDuration, then turns itself off.  Default is
            zero (unused).  Mutually exclusive with ringTimeStepCount (below);
            used only if set to a non-zero duration and ringTimeStepCount is 1
            (see below).
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The relative ring duration.  If not sticky (see argument below),
            alarms rings for ringTimeStepCount, then turns itself off.
            Default is 1: a non-sticky alarm will ring for one clock time step.
            Mutually exclusive with ringDuration (above); used if
            ringTimeStepCount &gt; 1.  If ringTimeStepCount is 1 (default) and
            ringDuration is non-zero, ringDuration is used (see above), otherwise
            ringTimeStepCount is used.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>Sets the enabled state; default is on (true).  If disabled,
            an alarm will not function at all.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>Sets the sticky state; default is on (true).  If sticky,
            once an alarm is ringing, it will remain ringing until turned off 
            manually via a user call to <TT>ESMF_AlarmRingerOff()</TT>.
            If not sticky, an alarm will turn itself off after a certain
            ring duration specified by either ringDuration or
            ringTimeStepCount (see above).  There is an implicit limitation
            that in order to properly reverse timestep through a ring end
            time in <TT>ESMF_DIRECTION_REVERSE</TT>, that time must have already
            been traversed in the forward direction.  This is due to the fact
            that the Time Manager cannot predict when user code will call
            <TT>ESMF_AlarmRingerOff()</TT>.  An error message will be logged
            when this limitation is not satisfied.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created alarm.  If not specified,
            a default unique name will be generated: "AlarmNNN" where NNN
            is a unique sequence number from 001 to 999.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086500000000000000">
41.6.5 ESMF_AlarmCreate - Create a copy of an existing ESMF Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_AlarmCreate()
       function ESMF_AlarmCreateCopy(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Alarm) :: ESMF_AlarmCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a complete (deep) copy of a given <TT>ESMF_Alarm</TT>.
       The returned <TT>ESMF_Alarm</TT> copy is associated with the same
       <TT>ESMF_Clock</TT> as the original <TT>ESMF_Alarm</TT>.  If desired, use
       <TT>ESMF_AlarmSet(...clock=...)</TT> to re-associate the 
       <TT>ESMF_Alarm</TT> copy with a different <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The <TT>ESMF_Alarm</TT> to copy.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086600000000000000">
41.6.6 ESMF_AlarmDestroy - Release resources associated with an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmDestroy(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)          :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with this <TT>ESMF_Alarm</TT>.  Also
       removes this <TT>ESMF_Alarm</TT> from its associated <TT>ESMF_Clock</TT>'s
       list of <TT>ESMF_Alarm</TT>s (removes the <TT>ESMF_Alarm</TT> pointer from
       the list).

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>Release resources associated with this <TT>ESMF_Alarm</TT> and mark the
         object as invalid.  It is an error to pass this object into any other
         routines after being destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06086700000000000000">
41.6.7 ESMF_AlarmDisable - Disable an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmDisable(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Disables an <TT>ESMF_Alarm</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to disable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06086800000000000000">
41.6.8 ESMF_AlarmEnable - Enable an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmEnable(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Enables an <TT>ESMF_Alarm</TT> to function.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to enable.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06086900000000000000">
41.6.9 ESMF_AlarmGet - Get Alarm properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmGet(alarm, &amp;
         clock, ringTime, prevRingTime, ringInterval, stopTime, ringDuration, &amp;
         ringTimeStepCount, timeStepRingingCount, ringBegin, ringEnd, &amp;
         refTime, ringing, ringingOnPrevTimeStep, enabled, sticky, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Clock),        intent(out), optional :: clock
       type(ESMF_Time),         intent(out), optional :: ringTime
       type(ESMF_Time),         intent(out), optional :: prevRingTime
       type(ESMF_TimeInterval), intent(out), optional :: ringInterval
       type(ESMF_Time),         intent(out), optional :: stopTime
       type(ESMF_TimeInterval), intent(out), optional :: ringDuration
       integer,                 intent(out), optional :: ringTimeStepCount
       integer,                 intent(out), optional :: timeStepRingingCount
       type(ESMF_Time),         intent(out), optional :: ringBegin
       type(ESMF_Time),         intent(out), optional :: ringEnd
       type(ESMF_Time),         intent(out), optional :: refTime
       logical,                 intent(out), optional :: ringing
       logical,                 intent(out), optional :: ringingOnPrevTimeStep
       logical,                 intent(out), optional :: enabled
       logical,                 intent(out), optional :: sticky
       character (len=*),       intent(out), optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets one or more of an <TT>ESMF_Alarm</TT>'s properties.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to query.
       
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>The associated clock.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The ring time for a one-shot alarm or the next repeating alarm.
       
</DD>
<DT><STRONG>[prevRingTime]</STRONG></DT>
<DD>The previous ring time.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The ring duration.  Mutually exclusive with 
            ringTimeStepCount (see below).
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The number of time steps comprising the ring duration.  Mutually
            exclusive with ringDuration (see above).
       
</DD>
<DT><STRONG>[timeStepRingingCount]</STRONG></DT>
<DD>The number of time steps for which the alarm has been ringing thus
            far.  Used internally for tracking ringTimeStepCount ring 
            durations (see above).  Mutually exclusive with ringBegin
            (see below).  Increments in <TT>ESMF_DIRECTION_FORWARD</TT> and 
            decrements in <TT>ESMF_DIRECTION_REVERSE</TT>; 
            see Section&nbsp;<A HREF="node6.html#sec:Clock">40.1</A>.
       
</DD>
<DT><STRONG>[ringBegin]</STRONG></DT>
<DD>The time when the alarm began ringing.  Used internally for tracking
            ringDuration (see above).  Mutually exclusive with
            timeStepRingingCount (see above).
       
</DD>
<DT><STRONG>[ringEnd]</STRONG></DT>
<DD>The time when the alarm ended ringing.  Used internally for
            re-ringing alarm in <TT>ESMF_DIRECTION_REVERSE</TT>.

</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[ringing]</STRONG></DT>
<DD>The current ringing state.
            See also <TT>ESMF_AlarmRingerOn()</TT>, <TT>ESMF_AlarmRingerOff()</TT>.
       
</DD>
<DT><STRONG>[ringingOnPrevTimeStep]</STRONG></DT>
<DD>The ringing state upon the previous time step. Same as
            <TT>ESMF_AlarmWasPrevRinging()</TT>.

</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>The enabled state.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>The sticky state. 
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name of this alarm.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861000000000000000">
41.6.10 ESMF_AlarmIsEnabled - Check if Alarm is enabled</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmIsEnabled(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsEnabled
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> is enabled.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for enabled state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861100000000000000">
41.6.11 ESMF_AlarmIsRinging - Check if Alarm is ringing</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmIsRinging(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsRinging
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> is ringing.

<P>
See also method
             <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_RINGING, ...)</TT>
       to get a list of all ringing alarms belonging to an <TT>ESMF_Clock</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The alarm to check for ringing state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861200000000000000">
41.6.12 ESMF_AlarmIsSticky - Check if Alarm is sticky</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmIsSticky(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmIsSticky
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>alarm</TT> is sticky.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for sticky state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861300000000000000">
41.6.13 ESMF_AlarmNotSticky - Unset an Alarm's sticky flag</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmNotSticky(alarm, &amp;
         ringDuration, ringTimeStepCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Unset an <TT>ESMF_Alarm</TT>'s sticky flag; once alarm is ringing,
       it turns itself off after ringDuration.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to unset sticky.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>If not sticky, alarms rings for ringDuration, then turns itself off.
            Mutually exclusive with ringTimeStepCount (see below and full
            description in method <TT>ESMF_AlarmCreate()</TT> or
            <TT>ESMF_AlarmSet()</TT>).
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>If not sticky, alarms rings for ringTimeStepCount, then turns
            itself off.  Mutually exclusive with ringDuration (see above and
            full description in method <TT>ESMF_AlarmCreate()</TT> or
            <TT>ESMF_AlarmSet()</TT>).

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861400000000000000">
41.6.14 ESMF_AlarmPrint - Print out an Alarm's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmPrint(alarm, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),  intent(in)            :: alarm
       character (len=*), intent(in),  optional :: options
       integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints out an <TT>ESMF_Alarm</TT>'s properties to <TT>stdout</TT>, in support
       of testing and debugging.  The options control the type of information
       and level of detail. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD><TT>ESMF_Alarm</TT> to be printed out.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options. If none specified, prints all <TT>alarm</TT> property values.
<BR>            "clock"        - print the associated clock's name. 
<BR>            "enabled"      - print the alarm's ability to ring. 
<BR>            "name"         - print the alarm's name. 
<BR>            "prevRingTime" - print the alarm's previous ring time. 
<BR>            "ringBegin"    - print time when the alarm actually begins to ring.
<BR>            "ringDuration" - print how long this alarm is to remain ringing. 
<BR>            "ringEnd"      - print time when the alarm actually ends ringing.
<BR>            "ringing"                - print the alarm's current ringing state.
<BR>            "ringingOnPrevTimeStep"  - print whether the alarm was ringing 
                                       immediately after the previous clock
                                       time step. 
<BR>            "ringInterval" - print the alarm's periodic ring interval. 
<BR>            "ringTime"     - print the alarm's next time to ring. 
<BR>            "ringTimeStepCount" - print how long this alarm is to remain
                                  ringing, in terms of a number of clock time
                                  steps. 
<BR>            "refTime"      - print the alarm's interval reference (base) time. 
<BR>            "sticky"       - print whether the alarm must be turned off
                             manually. 
<BR>            "stopTime"     - print when alarm intervals end. 
<BR>            "timeStepRingingCount"   - print the number of time steps the
                                       alarm has been ringing thus far. 
<BR>       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861500000000000000">
41.6.15 ESMF_AlarmRingerOff - Turn off an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmRingerOff(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Turn off an <TT>ESMF_Alarm</TT>; unsets ringing state.  For a sticky
       alarm, this method must be called to turn off its ringing state.
       This is true for either <TT>ESMF_DIRECTION_FORWARD</TT> (default) or
       <TT>ESMF_DIRECTION_REVERSE</TT>.  See Section&nbsp;<A HREF="node6.html#sec:Clock">40.1</A>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to turn off.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060861600000000000000">
41.6.16 ESMF_AlarmRingerOn - Turn on an Alarm</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmRingerOn(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Turn on an <TT>ESMF_Alarm</TT>; sets ringing state.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to turn on.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861700000000000000">
41.6.17 ESMF_AlarmSet - Set Alarm properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmSet(alarm, &amp;
         clock, ringTime, ringInterval, stopTime, ringDuration, &amp;
         ringTimeStepCount, refTime, ringing, enabled, sticky, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Clock),        intent(in),  optional :: clock
       type(ESMF_Time),         intent(in),  optional :: ringTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringInterval
       type(ESMF_Time),         intent(in),  optional :: stopTime
       type(ESMF_TimeInterval), intent(in),  optional :: ringDuration
       integer,                 intent(in),  optional :: ringTimeStepCount
       type(ESMF_Time),         intent(in),  optional :: refTime
       logical,                 intent(in),  optional :: ringing
       logical,                 intent(in),  optional :: enabled
       logical,                 intent(in),  optional :: sticky
       character (len=*),       intent(in),  optional :: name
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets/resets one or more of the properties of an <TT>ESMF_Alarm</TT> that
       was previously initialized via <TT>ESMF_AlarmCreate()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to set.
       
</DD>
<DT><STRONG>[clock]</STRONG></DT>
<DD>Re-associates this alarm with a different clock.
       
</DD>
<DT><STRONG>[ringTime]</STRONG></DT>
<DD>The next ring time for a one-shot alarm or a repeating (interval)
            alarm.
       
</DD>
<DT><STRONG>[ringInterval]</STRONG></DT>
<DD>The ring interval for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[stopTime]</STRONG></DT>
<DD>The stop time for repeating (interval) alarms.
       
</DD>
<DT><STRONG>[ringDuration]</STRONG></DT>
<DD>The absolute ring duration.  If not sticky (see argument below),
            alarms rings for ringDuration, then turns itself off.  Default is
            zero (unused).  Mutually exclusive with ringTimeStepCount (below);
            used only if set to a non-zero duration and ringTimeStepCount is 1
            (see below).
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[ringTimeStepCount]</STRONG></DT>
<DD>The relative ring duration.  If not sticky (see argument below),
            alarms rings for ringTimeStepCount, then turns itself off.
            Default is 1: a non-sticky alarm will ring for one clock time step.
            Mutually exclusive with ringDuration (above); used if
            ringTimeStepCount &gt; 1.  If ringTimeStepCount is 1 (default) and
            ringDuration is non-zero, ringDuration is used (see above), otherwise
            ringTimeStepCount is used.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[refTime]</STRONG></DT>
<DD>The reference (i.e. base) time for an interval alarm.
       
</DD>
<DT><STRONG>[ringing]</STRONG></DT>
<DD>Sets the ringing state.
            See also <TT>ESMF_AlarmRingerOn()</TT>, <TT>ESMF_AlarmRingerOff()</TT>.
       
</DD>
<DT><STRONG>[enabled]</STRONG></DT>
<DD>Sets the enabled state.  If disabled, an alarm will not function
            at all.
            See also <TT>ESMF_AlarmEnable()</TT>, <TT>ESMF_AlarmDisable()</TT>.
       
</DD>
<DT><STRONG>[sticky]</STRONG></DT>
<DD>Sets the sticky state.  If sticky, once an alarm is ringing, it
            will remain ringing until turned off manually via a user call to
            <TT>ESMF_AlarmRingerOff()</TT>.  If not sticky, an alarm will turn
            itself off after a certain ring duration specified by either
            ringDuration or ringTimeStepCount (see above).
            There is an implicit limitation that in order to properly reverse
            timestep through a ring end time in <TT>ESMF_DIRECTION_REVERSE</TT>,
            that time must have already been traversed in the forward direction.
            This is due to the fact that the Time Manager cannot predict when
            user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
            will be logged when this limitation is not satisfied.
            See also <TT>ESMF_AlarmSticky()</TT>, <TT>ESMF_AlarmNotSticky()</TT>.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The new name for this alarm.  
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861800000000000000">
41.6.18 ESMF_AlarmSticky - Set an Alarm's sticky flag</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmSticky(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(inout)         :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Set an <TT>ESMF_Alarm</TT>'s sticky flag; once alarm is ringing,
       it remains ringing until <TT>ESMF_AlarmRingerOff()</TT> is called.
       There is an implicit limitation that in order to properly reverse
       timestep through a ring end time in <TT>ESMF_DIRECTION_REVERSE</TT>, that
       time must have already been traversed in the forward direction.
       This is due to the fact that an <TT>ESMF_Alarm</TT> cannot predict when
       user code will call <TT>ESMF_AlarmRingerOff()</TT>.  An error message
       will be logged when this limitation is not satisfied.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to be set sticky.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060861900000000000000">
41.6.19 ESMF_AlarmValidate - Validate an Alarm's properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_AlarmValidate(alarm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),  intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Performs a validation check on an <TT>ESMF_Alarm</TT>'s properties.
       Must have a valid ringTime, set either directly or indirectly via
       ringInterval.  See <TT>ESMF_AlarmCreate()</TT>.

<P>
The arguments are:  
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD><TT>ESMF_Alarm</TT> to be validated.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060862000000000000000">
41.6.20 ESMF_AlarmWasPrevRinging - Check if Alarm was ringing on the previous Clock timestep</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmWasPrevRinging(alarm, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmWasPrevRinging
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm), intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> was ringing on the previous clock timestep.

<P>
See also method
         <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_PREVRINGING, ...)</TT>
       get a list of all alarms belonging to a <TT>ESMF_Clock</TT> that were
       ringing on the previous time step.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The object instance to check for previous ringing state.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060862100000000000000">
41.6.21 ESMF_AlarmWillRingNext - Check if Alarm will ring upon the next Clock timestep</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_AlarmWillRingNext(alarm, timeStep, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_AlarmWillRingNext
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Alarm),        intent(in)            :: alarm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TimeInterval), intent(in),  optional :: timeStep
       integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>ESMF_Alarm</TT> will ring on the next clock timestep, either
       the current clock timestep or a passed-in timestep.

<P>
See also method
         <TT>ESMF_ClockGetAlarmList(clock, ESMF_ALARMLIST_NEXTRINGING, ...)</TT>
       to get a list of all alarms belonging to a <TT>ESMF_Clock</TT> that will
       ring on the next time step.

<P>
The arguments are:
       <DL>
<DT><STRONG>alarm</STRONG></DT>
<DD>The alarm to check for next ringing state.
       
</DD>
<DT><STRONG>[timeStep]</STRONG></DT>
<DD>Optional timestep to use instead of the clock's.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H1><A NAME="SECTION06090000000000000000">
42 Config Class</A>
</H1>

<P>

<H2><A NAME="SECTION06091000000000000000">
42.1 Description</A>
</H2>

<P>
<A NAME="sec:Config"></A>
<P>
ESMF Configuration Management is based on NASA DAO's 
Inpak 90 package, a Fortran 90 collection of routines/functions
for accessing <EM>Resource Files</EM> in ASCII format.The package 
is optimized for minimizing formatted I/O, performing all of its 
string operations in memory using Fortran intrinsic functions.
<BR>
<P>

<H3><A NAME="SECTION06091100000000000000">
42.1.1 Package history</A>
</H3>

<P>
The ESMF Configuration Management Package was evolved by
Leonid Zaslavsky and Arlindo da Silva from Ipack90 package
created by Arlindo da Silva at NASA DAO.

<P>
Back in the 70's Eli Isaacson wrote IOPACK in Fortran
66.  In June of 1987 Arlindo da Silva wrote Inpak77 using
Fortran 77 string functions; Inpak 77 is a vastly
simplified IOPACK, but has its own goodies not found in
IOPACK.  Inpak 90 removes some obsolete functionality in
Inpak77, and parses the whole resource file in memory for
performance.

<P>

<H3><A NAME="SECTION06091200000000000000">
42.1.2 Resource files</A>
</H3>

<P>
A <EM>Resource File (RF)</EM> is a text file consisting of list of 
   <EM>label</EM>-<EM>value</EM> pairs. There is a limit of 250 characters 
   per line and the Resource File can contain a maximum of 200 records. 
   Each <EM>label</EM> should be followed by some data, the <EM>value</EM>. 
   An example Resource File follows.  It is the file used in the example 
   below. 

<P>
<PRE>
 # This is an example Resource File.  
 # It contains a list of &lt;label,value&gt; pairs.
 # The colon after the label is required. 

 # The values after the label can be an list.
 # Multiple types are authorized.
  
  my_file_names:         jan87.dat jan88.dat jan89.dat  # all strings
  constants:             3.1415   25                    # float and integer
  my_favorite_colors:    green blue 022               


 # Or, the data can be a list of single value pairs. 
 # It is simplier to retrieve data in this format:

  radius_of_the_earth:   6.37E6         
  parameter_1:           89
  parameter_2:           78.2
  input_file_name:       dummy_input.netcdf 


 # Or, the data can be located in a table using the following
 # syntax:

  my_table_name::
   1000     3000     263.0
    925     3000     263.0
    850     3000     263.0
    700     3000     269.0
    500     3000     287.0
    400     3000     295.8
    300     3000     295.8
  ::
</PRE>

<P>
Note that the colon after the label is required and that the double colon is required
 to declare tabular data. 

<P>
Resource files are intended for random access (except between ::'s in a 
 table definition). This means that order in which a particular 
 <EM>label-value</EM> pair is retreived is not dependent upon the original order 
 of the pairs. The only exception to this, however, is when the same <EM>label</EM> appears 
 multiple times within the Resource File.

<P>

<P>

<H2><A NAME="SECTION06092000000000000000">
42.2 Use and Examples</A>
</H2>

<P>

<P>

<P>
This example/test code performs simple Config/Resource File routines. It does not
   include attaching a Config to a component. The important thing to remember there
   is that you can have one Config per component. 

<P>
There are two methodologies for accessing data in a Resource File.  This example will
   demonstrate both.

<P>
Note the API section contains a complete description of arguments in
   the methods/functions demonstrated in this example. 

<P>

<H3><A NAME="SECTION06092100000000000000">
42.2.1 Variable declarations</A>
</H3>

<P>
The following are the variable declarations used as arguments in the following code 
   fragments. They represent the locals names for the variables listed in the Resource 
   File (RF).  Note they do not need to be the same. 

<P>
<PRE>
      character(ESMF_MAXSTR) :: fname ! config file name
      character*20  :: fn1, fn2, fn3, input_file ! strings to be read in
      integer       :: rc            ! error return code (0 is OK)
      integer       :: i_n           ! the first constant in the RF
      real          :: param_1       ! the second constant in the RF
      real          :: radius        ! radius of the earth
      real          :: table(7,3)    ! an array to hold the table in the RF

      type(ESMF_Config)   :: cf      ! the Config itself
</PRE>

<P>

<H3><A NAME="SECTION06092200000000000000">
42.2.2 Creation of a Config</A>
</H3>

<P>
While there are two methodologies for accessing the data within a Resource File, 
   there is only one way to create the initial Config and load its ASCII text into 
   memory. This is the first step in the process.

<P>
Note that subsequent calls to <TT>ESMF_ConfigLoadFile</TT> will OVERWRITE the current
   Config NOT append to it. There is no means of appending to a Config. 

<P>
<PRE>
      cf = ESMF_ConfigCreate(rc=rc)             ! Create the empty Config
</PRE>

<P>
<PRE>
      fname = "myResourceFile.rc"                ! Name the Resource File
      call ESMF_ConfigLoadFile(cf, fname, rc=rc) ! Load the Resource File 
                                                 ! into the empty Config
</PRE>

<P>

<H3><A NAME="SECTION06092300000000000000">
42.2.3 How to retrieve a label with a single value</A>
</H3>
   The first method for retrieving information from the 
   Resource File takes advantage of the &lt;label,value&gt; relationship
   within the file and access the data in a dictionary-like manner. This is the
   simplest methodology, but it does imply the use of only one value per label
   in the Resource File.  

<P>
Remember,
   that the order in which a particular label/value pair is retrieved
   is not dependent upon the order which they exist within the Resource File.  

<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, radius, label='radius_of_the_earth:', &amp;
                                 default=1.0, rc=rc)
</PRE>

<P>
Note that the colon must be included in the label string when using this
   methodology.  It is also important to provide a default value in case the label
   does not exist in the file 

<P>
This methodology works for all types. The following is an example of retrieving a 
   string: 

<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, input_file, label='input_file_name:', &amp;
                                 default="./default.nc", rc=rc)
</PRE>

<P>
The same code fragment can be used to demonstrate what happens when the label is not 
   present.  Note that "file_name" does not exist in the Resource File. The result of 
   its abscense is the default value provided in the call. 

<P>
<PRE>
    call ESMF_ConfigGetAttribute(cf, input_file, label='file_name:', &amp;
                                 default="./default.nc", rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION06092400000000000000">
42.2.4 How to retrieve a label with multiple values</A>
</H3>
   When there are multiple, mixed-typed values associated with a label, the 
   values can be retrieved in two steps:  1) Use ESMF_ConfigFindLabel() 
   to find the label in the Config class; 2) use
   ESMF_ConfigGetAttribute() without the optional 'label' argument to 
   retrieve the values one at a time, reading from left to right in
   the record. 

<P>
A second reminder that the order in which a particular label/value pair is 
   retrieved is not dependent upon the order which they exist within the 
   Resource File. The label used in this method allows the user to skip to
   any point in the file.  

<P>
<PRE>
      call ESMF_ConfigFindLabel(cf, 'constants:', rc=rc) ! Step a) Find the 
                                                         ! label
</PRE>

<P>
Two constants, radius and i_n, can now be retrieved without having to specify their
   label or use an array. They are also different types. 

<P>
<PRE>
      call ESMF_ConfigGetAttribute(cf, param_1, rc=rc) ! Step b) read in the 
                                                       ! first constant in 
                                                       ! the sequence
      call ESMF_ConfigGetAttribute(cf, i_n, rc=rc)     ! Step c) read in the 
                                                       ! second constant in 
                                                       ! the sequence
</PRE>

<P>
This methodology also works with strings. 

<P>
<PRE>
       call ESMF_ConfigFindLabel(cf, 'my_file_names:', &amp;
               rc=rc)                       ! Step a) find the label
</PRE>

<P>
<PRE>
       call ESMF_ConfigGetAttribute(cf, fn1, &amp;
                 rc=rc)                    ! Step b) retrieve the 1st filename
       call ESMF_ConfigGetAttribute(cf, fn2, &amp;
                 rc=rc)                    ! Step c) retrieve the 2nd filename
       call ESMF_ConfigGetAttribute(cf, fn3, &amp;
                 rc=rc)                    ! Step d) retrieve the 3rd filename
</PRE>

<P>

<H3><A NAME="SECTION06092500000000000000">
42.2.5 How to retrieve a table</A>
</H3>

<P>
To access tabular data, the user must use the multi-value method.  

<P>
<PRE>
      call ESMF_ConfigFindLabel(cf, 'my_table_name::', &amp;
               rc=rc)        ! Step a) Set the label location to the 
                             ! beginning of the table
</PRE>

<P>
Subsequently, <TT>call ESMF_ConfigNextLine()</TT> is used to move the location 
   to the next row of the table. The example table in the Resource File contains
   7 rows and 3 columns (7,3). 

<P>
<PRE>
      do i = 1, 7
        call ESMF_ConfigNextLine(cf, rc=rc) ! Step b) Increment the rows
        do j = 1, 3                         ! Step c) Fill in the table 
          call ESMF_ConfigGetAttribute(cf, table(i,j), rc=rc)
        enddo
      enddo
</PRE>

<P>

<H3><A NAME="SECTION06092600000000000000">
42.2.6 Destruction of a Config</A>
</H3>

<P>
The work with the configuration file <TT>cf</TT> is finalized by call to
   <TT>ESMF_ConfigDestroy()</TT>: 

<P>
<PRE>
      call ESMF_ConfigDestroy(cf, rc=rc) ! Destroy the Config
</PRE>

<P>

<P>

<H2><A NAME="SECTION06093000000000000000">
42.3 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION06093100000000000000">
42.3.1 ESMF_ConfigAssignment(=) - Config assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     config1 = config2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Config) :: config1
     type(ESMF_Config) :: config2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Assign config1 as an alias to the same ESMF Config object in memory
     as config2. If config2 is invalid, then config1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>config1</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>config2</STRONG></DT>
<DD>The <TT>ESMF_Config</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093200000000000000">
42.3.2 ESMF_ConfigCreate - Instantiate a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       type(ESMF_Config) function ESMF_ConfigCreate(rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,intent(out), optional              :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Instantiates an <TT>ESMF_Config</TT> object for use in subsequent calls.

<P>
The arguments are:
     <DL>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093300000000000000">
42.3.3 ESMF_ConfigDestroy - Destroy a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigDestroy(config, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys the <TT>config</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093400000000000000">
42.3.4 ESMF_ConfigFindLabel - Find a label</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigFindLabel(config, label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)           :: config 
       character(len=*),  intent(in)              :: label
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,           intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Finds the <TT>label</TT> (key) string in the <TT>config</TT> object.  

<P>
Since the search is done by looking for a string, possibly multi-worded,
     in the whole <TT>Config</TT> object, it is important to use special 
     conventions to distinguish <TT>labels</TT> from other words. This is done 
     in the Resource File by using the DAO convention to finish 
     line labels with a (:) and table labels with a double colon (::).

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>label</STRONG></DT>
<DD>Identifying label. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       Equals -1 if buffer could not be loaded, -2 if label not found,
       and -3 if invalid operation with index.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093500000000000000">
42.3.5 ESMF_ConfigGetAttribute - Get a value </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_ConfigGetAttribute(config, &lt;value&gt;, &amp;
          label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Config), intent(inout)         :: config     
        &lt;value argument&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        character(len=*),  intent(in),  optional :: label 
        character(len=*),  intent(in),  optional :: default 
        integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets a value from the <TT>config</TT> object.  When the
        value is a sequence of characters
        it will be terminated by the first white space.

<P>
Supported values for &lt;value argument&gt; are:
        <DL>
<DT></DT>
<DD>character(len=*), intent(out)          :: value
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), intent(out)      :: value    
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), intent(out)      :: value
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(out)   :: value
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(out)   :: value
        
</DD>
<DT></DT>
<DD>logical, intent(out)                   :: value
        
</DD>
</DL>

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>Returned value.
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifing label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if <TT>label</TT> is not found in <TT>config</TT> object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06093600000000000000">
42.3.6 ESMF_ConfigGetAttribute - Get a list of values </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_ConfigGetAttribute(config, &lt;value list argument&gt;, &amp;
          count, label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Config), intent(inout)         :: config     
        &lt;value list argument&gt;, see below for values      
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,           intent(in)   optional :: count
        character(len=*),  intent(in),  optional :: label 
        character(len=*),  intent(in),  optional :: default 
        integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets a list of values from the <TT>config</TT> object.  

<P>
Supported values for &lt;value list argument&gt; are:
        <DL>
<DT></DT>
<DD>real(ESMF_KIND_R4), intent(inout)      :: valueList(:)
        
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), intent(inout)      :: valueList(:)
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(inout)   :: valueList(:)
        
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I8), intent(inout)   :: valueList(:)
        
</DD>
<DT></DT>
<DD>logical, intent(inout)                   :: valueList(:)
        
</DD>
</DL>

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value list argument&gt;</STRONG></DT>
<DD>Returned value.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of returned values expected.  
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifing label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if <TT>label</TT> is not found in <TT>config</TT> object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION06093700000000000000">
42.3.7 ESMF_ConfigGetChar - Get a character</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ConfigGetChar(config, value, &amp;
         label, default, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)         :: config 
       character,         intent(out)           :: value
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),  optional :: label   
       character,         intent(in),  optional :: default
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets a character <TT>value</TT> from the <TT>config</TT> object.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>value</STRONG></DT>
<DD>Returned value. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label. 
     
</DD>
<DT><STRONG>[default]</STRONG></DT>
<DD>Default value if label is not found in configuration object. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093800000000000000">
42.3.8 ESMF_ConfigGetDim - Get table sizes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigGetDim(config, lineCount, columnCount, &amp;
       label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)         :: config
       integer,           intent(out)           :: lineCount
       integer,           intent(out)           :: columnCount
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),  optional :: label
       integer,           intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the number of lines in the table in <TT>lineCount</TT> and 
    the maximum number of words in a table line in <TT>columnCount</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>lineCount</STRONG></DT>
<DD>Returned number of lines in the table. 
     
</DD>
<DT><STRONG>columnCount</STRONG></DT>
<DD>Returned maximum number of words in a table line. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label (if present), otherwise current line.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION06093900000000000000">
42.3.9 ESMF_ConfigGetLen - Get the length of the line in words</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     integer function ESMF_ConfigGetLen(config, label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),   optional :: label
       integer,           intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets the length of the line in words by counting words
   disregarding types.  Returns the word count as an integer.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying label.   If not specified, use the current line.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931000000000000000">
42.3.10 ESMF_ConfigLoadFile - Load resource file into memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigLoadFile(config, filename, &amp;
       delayout, unique, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config),   intent(inout)         :: config     
       character(len=*),    intent(in)            :: filename 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_DELayout), intent(in),  optional :: delayout 
       logical,             intent(in),  optional :: unique 
       integer,             intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Resource file with <TT>filename</TT> is loaded into memory.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Configuration file name.
     
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> associated with this <TT>config</TT> object.
     
</DD>
<DT><STRONG>[unique]</STRONG></DT>
<DD>If specified as true, uniqueness of labels are checked and 
       error code set if duplicates found.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931100000000000000">
42.3.11 ESMF_ConfigNextLine - Find next line</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigNextLine(config, tableEnd, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,           intent(out),  optional :: tableEnd
       integer,           intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Selects the next line (for tables).

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>[tableEnd]</STRONG></DT>
<DD>If specifed as <TT>TRUE</TT>, end of table mark (::) is checked.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931200000000000000">
42.3.12 ESMF_ConfigSetAttribute - Set a value</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_ConfigSetAttribute(config, &lt;value argument&gt;, &amp;
         label, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)           :: config     
       &lt;value argument&gt;, see below for supported values
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*),  intent(in),   optional  :: label 
       integer,           intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets a value in the <TT>config</TT> object.

<P>
Supported values for &lt;value argument&gt; are:
        <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in)            :: value
        
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>config</STRONG></DT>
<DD>Already created <TT>ESMF_Config</TT> object.
     
</DD>
<DT><STRONG>&lt;value argument&gt;</STRONG></DT>
<DD>Value to set. 
     
</DD>
<DT><STRONG>[label]</STRONG></DT>
<DD>Identifying attribute label. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060931300000000000000">
42.3.13 ESMF_ConfigValidate - Validate a Config object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ConfigValidate(config, &amp;
       options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Config), intent(inout)          :: config 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character (len=*), intent(in),   optional :: options
       integer,           intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Checks whether a <TT>config</TT> object is valid.

<P>
The arguments are:
     <DL>
<DT><STRONG>config</STRONG></DT>
<DD><TT>ESMF_Config</TT> object to be validated.
     
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>If none specified:  simply check that the buffer is not full and the
         pointers are within range.
       "unusedAttributes" - Report to the default logfile all attributes not
         retrieved via a call to <TT>ESMF_ConfigGetAttribute()</TT> or
         <TT>ESMF_ConfigGetChar()</TT>.  The attribute name (label) will be
         logged via <TT>ESMF_LogErr</TT> with the WARNING log message type.
         For an array-valued attribute, retrieving at least one value via
         <TT>ESMF_ConfigGetAttribute()</TT> or <TT>ESMF_ConfigGetChar()</TT>
         constitutes being "used."

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       Equals <TT>ESMF_RC_ATTR_UNUSED</TT> if any unused attributes are found
       with option "unusedAttributes" above.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION060100000000000000000">
43 Log Class</A>
</H1>

<P>

<H2><A NAME="SECTION060101000000000000000">
43.1 Description</A>
</H2>

<P>
<A NAME="sec:Log"></A>
<P>
The Log class consists of a variety of methods for writing error, warning, and
informational messages to files.  A default Log is created at ESMF
initialization.  Other Logs can be created later in the code by the user.  Most
Log methods take a Log as an optional argument and apply to the default Log
when another Log is not specified.  A set of standard return codes and
associated messages are provided for error handling.  

<P>
Log provides capabilities to store message entries in a buffer, which is 
flushed to a file, either when the buffer is full, or when the user calls an 
<TT>ESMF_LogFlush()</TT> method.  Currently, the default is for the Log to flush
after every ten entries.  This can easily be changed by using the 
<TT>ESMF_LogSet()</TT> method and setting the <TT>maxElements</TT> property to 
another value.  The <TT>ESMF_LogFlush()</TT> method is automatically called when 
the program exits by any means (program completion, halt on error, or when the
Log is closed).

<P>
The user has the capability to abort the program on conditions such as
an error or on a warning by using the <TT>ESMF_LogSet()</TT> method with
the <TT>logmsgAbort</TT> argument.  For example if the  <TT>logmsgAbort</TT> array
is set to <TT>(ESMF_LOGMSG_ERROR,ESMF_LOGMSG_WARNING)</TT>, the program will 
stop on any and all warning or errors.  When the <TT>logmsgAbort</TT> argument
is set to  <TT>ESMF_LOGMSG_ERROR</TT>, the program will only abort on
errors.  Lastly, the user can choose to never abort by using
<TT>ESMF_LOGMSG_NONE</TT>; this is the default.

<P>
Log will automatically put the PET number into the Log.  Also, the user can 
either specify <TT>ESMF_LOGKIND_SINGLE</TT> which writes all the entries to a single 
Log or <TT>ESMF_LOGKIND_MULTI</TT> which writes entries to multiple Logs according to 
the PET number.  To distinguish Logs from each other when using 
<TT>ESMF_LOGKIND_MULTI</TT>, the PET number (in the format <TT>PETx.</TT>) will be 
prepended to the file name where x is the PET number.

<P>
Opening multiple log files and writing log messages from all the processors
may affect the application performance while running on a large number of
processors.  For that reason, <TT>ESMF_LOGKIND_NONE</TT> is provided to
switch off the Log capability.  All the Log methods have no effect
in the <TT>ESMF_LOGKIND_NONE</TT> mode.

<P>
A tracing capability may be enabled by setting the <TT>trace</TT> flag by
using the <TT>ESMF_LogSet()</TT> method.  When tracing is enabled, calls to
methods such as <TT>ESMF_LogFoundError</TT>, <TT>ESMF_LogFoundAllocError</TT>,
and <TT>ESMF_LogFoundDeallocError</TT> are logged in the default log file.
This can result in voluminous output.  It is typically used only around areas
of code which are being debugged.

<P>
Other options that are planned for Log are to adjust the verbosity of output, and to optionally write to <TT>stdout</TT> instead of file(s).

<P>

<P>

<H2><A NAME="SECTION060102000000000000000">
43.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION060102100000000000000"></A>
<A NAME="const:logerr"></A>
<BR>
43.2.1 ESMF_LOGERR
</H3>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGERR_PASSTHRU</STRONG></DT>
<DD>A named character constant, with a predefined generic error message, 
		that can be used for the <TT>msg</TT> argument in any <TT>ESMF_Log</TT> 
		routine.  The message indicated 
		by this named constant is ``<I>Passing error in return code</I>."
</DD>
</DL>

<P>

<H3><A NAME="SECTION060102200000000000000"></A>
<A NAME="const:logkindflag"></A>
<BR>
43.2.2 ESMF_LOGKIND
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies a single log file, multiple log files (one per PET), or no log files.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_LogKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGKIND_SINGLE</STRONG></DT>
<DD>Use a single log file, combining messages from all of the PETs.  Not supported on some platforms.
   
</DD>
<DT><STRONG>ESMF_LOGKIND_MULTI</STRONG></DT>
<DD>Use multiple log files -- one per PET.  (Default.)
   
</DD>
<DT><STRONG>ESMF_LOGKIND_NONE</STRONG></DT>
<DD>Do not issue messages to a log file.
</DD>
</DL>

<P>

<H3><A NAME="SECTION060102300000000000000"></A>
<A NAME="const:logmsgflag"></A>
<BR>
43.2.3 ESMF_LOGMSG
</H3>

<P>
<I>DESCRIPTION:
<BR></I>

Specifies a message level

<P>
The type of this flag is:

<P>
<TT>type(ESMF_LogMsg_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_LOGMSG_INFO</STRONG></DT>
<DD>Informational messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_WARNING</STRONG></DT>
<DD>Warning messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_ERROR</STRONG></DT>
<DD>Error messages
   
</DD>
<DT><STRONG>ESMF_LOGMSG_TRACE</STRONG></DT>
<DD>Trace messages
</DD>
</DL>

<P>
Valid predefined named array constant values are:

<P>
<DL>
<DT><STRONG>ESMF_LOGMSG_ALL</STRONG></DT>
<DD>All messages
	
</DD>
<DT><STRONG>ESMF_LOGMSG_NONE</STRONG></DT>
<DD>No messages
	
</DD>
<DT><STRONG>ESMF_LOGMSG_NOTRACE</STRONG></DT>
<DD>All messages EXCEPT trace messages
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION060103000000000000000">
43.3 Use and Examples</A>
</H2>

<P>
By default <TT>ESMF_Initialize()</TT> opens a default Log in 
<TT>ESMF_LOGKIND_MULTI</TT> mode. ESMF handles the initialization and finalization
of the default Log so the user can immediately start using it. If additional Log
objects are desired, they must be explicitly created or opened using
<TT>ESMF_LogOpen()</TT>.

<P>
<TT>ESMF_LogOpen()</TT> requires a Log object and filename argument. Additionally,
the user can specify single or multi Logs by setting the <TT>logkindflag</TT> property
to <TT>ESMF_LOGKIND_SINGLE</TT> or <TT>ESMF_LOGKIND_MULTI</TT>.
This is useful as the PET numbers are automatically added to the Log entries.
A single Log will put all entries, regardless of PET number, into a single
log while a multi Log will create multiple Logs with the PET number prepended
to the filename and all entries will be written to their corresponding Log 
by their PET number.

<P>
By default, the Log file is not truncated at the start of a new run; it just
gets appended each time.  Future functionality may include an option to
either truncate or append to the Log file. 

<P>
In all cases where a Log is opened, a Fortran unit number is assigned to a specific
Log.  A Log is assigned an unused unit number using the algorithm described in
the <TT>ESMF_IOUnitGet()</TT> method.

<P>
The user can then set or get options on how the Log should be used 
with the <TT>ESMF_LogSet()</TT> and <TT>ESMF_LogGet()</TT> methods.  These are 
partially implemented at this time. 

<P>
Depending on how the options are set, <TT>ESMF_LogWrite()</TT> either writes user
messages directly to a Log file or writes to a buffer that can be flushed when 
full or by using the <TT>ESMF_LogFlush()</TT> method.  The default is to flush 
after every ten entries because <TT>maxElements</TT> is initialized to ten 
(which means the buffer reaches its full state after every ten writes and then
flushes).

<P>
A message filtering option may be set with <TT>ESMF_LogSet()</TT> so
that only selected message types are actually written to the log.  One key
use of this feature is to allow placing informational log write requests
into the code for debugging or tracing.  Then, when the informational entries
are not needed, the messages at that level may be turned off -- leaving only
warning and error messages in the logs. 

<P>
For every <TT>ESMF_LogWrite()</TT>, a time and date stamp is prepended to the
Log entry.  The time is given in microsecond precision.  The user can call 
other methods to write to the Log.  In every case, all methods eventually make 
a call implicitly to <TT>ESMF_LogWrite()</TT> even though the user may never 
explicitly call it.

<P>
When calling <TT>ESMF_LogWrite()</TT>, the user can supply an optional line,
file and method.  These arguments can be passed in explicitly or with the help
of cpp macros.  In the latter case, a define for an <TT>ESMF_FILENAME</TT> must 
be placed at the beginning of a file and a define for <TT>ESMF_METHOD</TT> must
be placed at the beginning of each method.  The user can then use the
<TT>ESMF_CONTEXT</TT> cpp macro in place of line, file and method to insert the 
parameters into the method.  The user does not have to specify line number as
it is a value supplied by cpp.

<P>
An example of Log output is given below running with <TT>logkindflag</TT> 
property set to <TT>ESMF_LOGKIND_MULTI</TT> (default) using the default Log:

<P>
(Log file <TT>PET0.ESMF_LogFile</TT>)
<PRE>
20041105 163418.472210 INFO      PET0     Running with ESMF Version 2.2.1
</PRE>

<P>
(Log file <TT>PET1.ESMF_LogFile</TT>)
<PRE>
20041105 163419.186153 ERROR     PET1     ESMF_Field.F90             812  
ESMF_FieldGet No Grid or Bad Grid attached to Field
</PRE>

<P>
The first entry shows date and time stamp.  The time is given in microsecond 
precision.  The next item shown is the type of message (INFO in this case).  
Next, the PET number is added.  Lastly, the content is written.

<P>
The second entry shows something slightly different.  In this case, we have
an ERROR.  The method name (ESMF_Field.F90) is automatically provided from 
the cpp macros as well as the line number (812).  Then the content of the 
message is written.

<P>
When done writing messages, the default Log is closed by calling 
<TT>ESMF_LogFinalize()</TT>  or <TT>ESMF_LogClose()</TT> for user created Logs.  
Both methods will release the assigned unit number.

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_LogErrEx - Log Error examples
!
! !DESCRIPTION:
!
! This program shows examples of Log Error writing
!-----------------------------------------------------------------------------

! Macros for cpp usage
! File define
#define ESMF_FILENAME "ESMF_LogErrEx.F90"
! Method define
#define ESMF_METHOD "program ESMF_LogErrEx"
#include "ESMF_LogMacros.inc"

    ! ESMF Framework module
    use ESMF
    implicit none
    
    ! return variables
    integer :: rc1, rc2, rc3, rcToTest, allocRcToTest
    type(ESMF_LOG) :: alog  ! a log object that is not the default log
    type(ESMF_LogKind_Flag) :: logkindflag
    type(ESMF_Time) :: time
    integer, pointer :: intptr(:)
</PRE>

<P>

<H3><A NAME="SECTION060103100000000000000">
43.3.1 Default Log</A>
</H3>

<P>
This example shows how to use the default Log.  This example does not use cpp
   macros but does use multi Logs.  A separate Log will be created for each PET. 

<P>
<PRE>
    ! Initialize ESMF to initialize the default Log
    call ESMF_Initialize(rc=rc1, logkindflag=ESMF_LOGKIND_MULTI)
</PRE>

<P>
<PRE>
    ! LogWrite 
    call ESMF_LogWrite("Log Write 2", ESMF_LOGMSG_INFO, rc=rc2)
</PRE>

<P>
<PRE>
    ! LogMsgSetError
    call ESMF_LogSetError(ESMF_RC_OBJ_BAD, msg="Convergence failure", &amp;
                             rcToReturn=rc2)
    ! LogMsgFoundError
    call ESMF_TimeSet(time, calkindflag=ESMF_CALKIND_NOCALENDAR)
    call ESMF_TimeSyncToRealTime(time, rc=rcToTest)
    if (ESMF_LogFoundError(rcToTest, msg="getting wall clock time", &amp;
                              rcToReturn=rc2)) then
        ! Error getting time. The previous call will have printed the error
        ! already into the log file.  Add any additional error handling here.
        ! (This call is expected to provoke an error from the Time Manager.)
    endif

    ! LogMsgFoundAllocError
    allocate(intptr(10), stat=allocRcToTest)
    if (ESMF_LogFoundAllocError(allocRcToTest, msg="integer array", &amp;
                                   rcToReturn=rc2)) then
        ! Error during allocation.  The previous call will have logged already
        ! an error message into the log.
    endif
    deallocate(intptr)
</PRE>

<P>

<H3><A NAME="SECTION060103200000000000000">
43.3.2 User created Log</A>
</H3>
   This example shows how to use a user created Log.  This example uses
   cpp macros. 

<P>
<PRE>
    ! Open a Log named "Testlog.txt" associated with alog.
    call ESMF_LogOpen(alog, "TestLog.txt", rc=rc1)
</PRE>

<P>
<PRE>
    ! LogWrite
    call ESMF_LogWrite("Log Write 2", ESMF_LOGMSG_INFO, &amp;
                       line=__LINE__, file=ESMF_FILENAME, &amp;
                       method=ESMF_METHOD, log=alog, rc=rc2)
</PRE>

<P>
<PRE>
    ! LogMsgSetError
    call ESMF_LogSetError(ESMF_RC_OBJ_BAD,  msg="Interpolation Failure", &amp;
                          line=__LINE__, file=ESMF_FILENAME, &amp;
                           method=ESMF_METHOD, rcToReturn=rc2, log=alog)
</PRE>

<P>

<H3><A NAME="SECTION060103300000000000000">
43.3.3 Get and Set</A>
</H3>
   This example shows how to use Get and Set routines, on both the default Log
   and the user created Log from the previous examples. 

<P>
<PRE>
    ! This is an example showing a query of the default Log.  Please note that
    ! no Log is passed in the argument list, so the default Log will be used.
    call ESMF_LogGet(logkindflag=logkindflag, rc=rc3)
</PRE>

<P>
<PRE>
    ! This is an example setting a property of a Log that is not the default.
    ! It was opened in a previous example, and the handle for it must be
    ! passed in the argument list.
    call ESMF_LogSet(log=alog, logmsgAbort=(/ESMF_LOGMSG_ERROR/), rc=rc2)
</PRE>

<P>
<PRE>
    ! Close the user log.
    call ESMF_LogClose(alog, rc=rc3)
</PRE>

<P>
<PRE>
    ! Finalize ESMF to close the default log
    call ESMF_Finalize(rc=rc1)
</PRE>

<P>

<P>

<H2><A NAME="SECTION060104000000000000000">
43.4 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Line, file and method are only available when using the C 
preprocessor</B>
Message writing methods are expanded using the ESMF macro ESMF_CONTEXT 
that adds the predefined symbolic constants __LINE__ and __FILE__ (or 
the ESMF constant ESMF_FILENAME if defined) and the ESMF constant ESMF_METHOD 
to the argument list.  Using these constants, we can associate a file name, 
line number and method name with the message.  If the CPP preprocessor is not 
used, this expansion will not be done and hence the ESMF macro ESMF_CONTEXT 
can not be used, leaving the file name, line number and method out of the Log 
text.

<P>
</LI>
<LI><B>Get and set methods are partially implemented.</B>
Currently, the <TT>ESMF_LogGet()</TT> and <TT>ESMF_LogSet()</TT> methods are 
partially implemented.   

<P>
</LI>
<LI><B>Log only appends entries.</B>
All writing to the Log is appended rather than overwriting the Log.  Future 
enhancements include the option to either append to an existing Log or 
overwrite the existing Log.

<P>
</LI>
<LI><B>Avoiding conflicts with the default Log.</B>

The private methods <TT>ESMF_LogInitialize()</TT> and <TT>ESMF_LogFinalize()</TT> 
are called during <TT>ESMF_Initialize()</TT> and <TT>ESMF_Finalize()</TT> 
respectively, so they do not need to be called if the default Log is used. 
If a new Log is required, <TT>ESMF_LogOpen()</TT> is used with a new Log object 
passed in so that there are no conflicts with the default Log.

<P>
</LI>
<LI><B>ESMF_LOGKIND_SINGLE does not work properly.</B>
When the <TT>ESMF_LogKind_Flag</TT> is set to <TT>ESMF_LOGKIND_SINGLE</TT>, different system may behave
differently.  The log messages from some processors may be lost or overwritten
by other processors.  Users are advised not to use this mode.  The MPI-based
I/O will be implemented to fix the problem in the future release. 

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION060105000000000000000">
43.5 Design and Implementation Notes</A>
</H2>

<OL>
<LI>The Log class was implemented in Fortran and uses the Fortran I/O 
libraries when the class methods are called from Fortran. The C/C++ Log
methods use the Fortran I/O library by calling utility functions that are
written in Fortran. These utility functions call the standard Fortran write, 
open and close functions.  At initialization an <TT>ESMF_LOG</TT> is created. 
The <TT>ESMF_LOG</TT> stores information for a specific Log file.   When working 
with more than one Log file, multiple <TT>ESMF_LOG</TT>'s are required (one 
<TT>ESMF_LOG</TT> for each Log file).  For each Log, a handle is returned 
through the <TT>ESMF_LogInitialize</TT> method for the default log or <TT>ESMF_LogOpen</TT> for a user created log.  The user can specify single or multi logs by 
setting the <TT>logkindflag</TT> property in the <TT>ESMF_LogInitialize</TT> or 
<TT>ESMF_Open</TT> method to <TT>ESMF_LOGKIND_SINGLE</TT> or <TT>ESMF_LOGKIND_MULTI</TT>.
Similarly, the user can set the <TT>logkindflag</TT> property for the default
Log with the <TT>ESMF_Initialize</TT> method call.
The <TT>logkindflag</TT> is useful as the PET numbers are automatically added to the 
log entries.  A single log will put all entries, regardless of PET number, 
into a single log while a multi log will create multiple logs with the PET 
number prepended to the filename and all entries will be written to their 
corresponding log by their PET number.

<P>
The properties for a Log are set with the <TT>ESMF_LogSet()</TT> method and 
retrieved with the <TT>ESMF_LogGet()</TT> method.

<P>
Additionally, buffering is enabled.  Buffering allows <TT>ESMF</TT> to manage 
output data streams in a desired way.  Writing to the buffer is transparent 
to the user because all the Log entries are handled automatically by the 
<TT>ESMF_LogWrite()</TT> method.  All the user has to do is specify the buffer
size (the default is ten) by setting the <TT>maxElements</TT> property.  Every 
time the <TT>ESMF_LogWrite()</TT> method is called, a LogEntry element is 
populated with the <TT>ESMF_LogWrite()</TT> information.  When the buffer is 
full (i.e., when all the LogEntry elements are populated), the buffer will be 
flushed and all the contents will be written to file.  If buffering is not 
needed, that is <TT>maxElements=1</TT> or <TT>flushImmediately=ESMF_TRUE</TT>, 
the <TT>ESMF_LogWrite()</TT> method will immediately write to the Log file(s).
</LI>
</OL>

<P>

<H2><A NAME="SECTION060106000000000000000">
43.6 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the
Log class.  See Appendix A, <I>A Brief Introduction to UML</I>,
for a translation table that lists the symbols in the diagram and their 
meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="749" HEIGHT="331" ALIGN="BOTTOM" BORDER="0"
 SRC="img105.png"
 ALT="\includegraphics[]{Log_obj}">   

</DIV>

<P>

<H2><A NAME="SECTION060107000000000000000">
43.7 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060107100000000000000">
43.7.1 ESMF_LogAssignment(=) - Log assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     log1 = log2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Log) :: log1
     type(ESMF_Log) :: log2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Assign log1 as an alias to the same ESMF Log object in memory
     as log2. If log2 is invalid, then log1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>log1</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>log2</STRONG></DT>
<DD>The <TT>ESMF_Log</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107200000000000000">
43.7.2 ESMF_LogClose - Close Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LogClose(log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Log), intent(inout)	        :: log
 type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
       integer,        intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This routine closes the user log file(s) associated with <TT>log</TT>.
        If the log is not explicitly closed, it will be closed by
        <TT>ESMF_Finalize</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>log</STRONG></DT>
<DD>An <TT>ESMF_Log</TT> object.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107300000000000000">
43.7.3 ESMF_LogFlush - Flush the Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LogFlush(log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> type(ESMF_KeywordEnforcer), optional :: keywordEnforcer ! must use keywords below
       type(ESMF_Log), intent(inout), optional :: log
       integer,        intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine flushes the file buffer associated with <TT>log</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107400000000000000">
43.7.4 ESMF_LogFoundAllocError - Check Fortran allocation status error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_LogFoundAllocError(statusToCheck,  &amp;
                                        msg,line,file, &amp;
                                        method,rcToReturn,log)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical                                    :: ESMF_LogFoundAllocError
</PRE><EM>ARGUMENTS:</EM>
<PRE>        
       integer,          intent(in)              :: statusToCheck 	      
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg			      
       integer,          intent(in),    optional :: line  		      
       character(len=*), intent(in),    optional :: file  		      
       character(len=*), intent(in),    optional :: method		      
       integer,          intent(out),   optional :: rcToReturn		      
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when a Fortran status code
        returned from a memory allocation indicates an allocation error.
        An ESMF predefined memory allocation error message 
        will be added to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>, 
        <TT>line</TT>, <TT>file</TT> and 
        <TT>method</TT>.  Additionally, statusToCheck will be converted to 
        <TT>rcToReturn</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>statusToCheck</STRONG></DT>
<DD>Fortran allocation status to check.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name. 
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, set the <TT>rcToReturn</TT> value to 
              <TT>ESMF_RC_MEM</TT> which is the error code for a memory 
              allocation eror.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
  	     of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107500000000000000">
43.7.5 ESMF_LogFoundDeallocError - Check Fortran deallocation status error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_LogFoundDeallocError(statusToCheck,  &amp;
                                          msg,line,file, &amp;
                                          method,rcToReturn,log)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical ::ESMF_LogFoundDeallocError
</PRE><EM>ARGUMENTS:</EM>
<PRE>        
       integer,          intent(in)              :: statusToCheck 	     	
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg			     	
       integer,          intent(in),    optional :: line  		     	
       character(len=*), intent(in),    optional :: file  		     	
       character(len=*), intent(in),    optional :: method		     	
       integer,          intent(out),   optional :: rcToReturn		     	
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> when a Fortran status code
        returned from a memory deallocation indicates an deallocation error.
        An ESMF predefined memory deallocation error message 
        will be added to the <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>, 
        <TT>line</TT>, <TT>file</TT> and 
        <TT>method</TT>.  Additionally, statusToCheck will be converted to 
        <TT>rcToReturn</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>statusToCheck</STRONG></DT>
<DD>Fortran deallocation status to check.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name. 
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, set the <TT>rcToReturn</TT> value to 
              <TT>ESMF_RC_MEM</TT> which is the error code for a memory 
              allocation eror.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
  	     of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107600000000000000">
43.7.6 ESMF_LogFoundError - Check ESMF return code for error and write message</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       function ESMF_LogFoundError(rcToCheck,   &amp;
                                   msg, line, file, method, &amp;
                                   rcToReturn, log)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       logical :: ESMF_LogFoundError
</PRE><EM>ARGUMENTS:</EM>
<PRE>  	
       integer,          intent(in),    optional :: rcToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(out),   optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This function returns <TT>.true.</TT> for ESMF return codes that indicate
        an error.  A predefined error message will added to the <TT>ESMF_Log</TT> 
        along with
        a user added <TT>msg</TT>, <TT>line</TT>, <TT>file</TT> and <TT>method</TT>.  
        Additionally, <TT>rcToReturn</TT> is set to <TT>rcToCheck</TT>.

<P>
The arguments are:
        <DL>
<DT><STRONG>[rcToCheck</STRONG></DT>
<DD>]
              Return code to check. Default is <TT>ESMF_SUCCESS</TT>.
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name. 
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, copy the <TT>rcToCheck</TT> value to <TT>rc</TT>.
              This is not the return code for this function; it allows
              the calling code to do an assignment of the error code
              at the same time it is testing the value.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107700000000000000">
43.7.7 ESMF_LogOpen - Open Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_LogOpen(log, filename, logkindflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Log),          intent(inout)         :: log		   
     character(len=*),        intent(in)            :: filename	   
     type(ESMF_LogKind_Flag), intent(in),  optional :: logkindflag 	    
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This routine opens a file named <TT>filename</TT> and associates
        it with the <TT>ESMF_Log</TT>.  If the incoming log is already a
        valid Log object, no new Log is opened and the Log argument remains
        unchanged.

<P>
The arguments are:
        <DL>
<DT><STRONG>log</STRONG></DT>
<DD>An <TT>ESMF_Log</TT> object.
        
</DD>
<DT><STRONG>filename</STRONG></DT>
<DD>Name of log file to be opened.
        
</DD>
<DT><STRONG>[logkindflag]</STRONG></DT>
<DD>Set the logkindflag. See section <A HREF="node6.html#const:logkindflag">43.2.2</A> for a list of
              valid options.
              If not specified, defaults to <TT>ESMF_LOGKIND_MULTI</TT>.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107800000000000000">
43.7.8 ESMF_LogSet - Set Log parameters</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> 	subroutine ESMF_LogSet(log, verbose, flush, rootOnly,  &amp;
                            logmsgAbort, stream, maxElements, logmsgList,  &amp;
                            errorMask, trace, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>  	
       type(ESMF_Log),      intent(inout), optional :: log 		   
       logical,             intent(in),    optional :: verbose		   
       logical,             intent(in),    optional :: flush		   
       logical,             intent(in),    optional :: rootOnly		   
       type(ESMF_LogMsg_Flag), intent(in), optional :: logmsgAbort(:)		   
       integer,             intent(in),    optional :: stream		   
       integer,             intent(in),    optional :: maxElements 	   
       type(ESMF_LogMsg_Flag), intent(in), optional :: logmsgList(:) 	   
       integer,             intent(in),    optional :: errorMask(:)
       logical,             intent(in),    optional :: trace	   
       integer,             intent(out),   optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine sets the properties for the Log object.

<P>
The arguments are:
        <DL>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
              of the default Log.
        
</DD>
<DT><STRONG>[verbose]</STRONG></DT>
<DD>Verbose flag.
        
</DD>
<DT><STRONG>[rootOnly]</STRONG></DT>
<DD>Root only flag.
        
</DD>
<DT><STRONG>[logmsgAbort]</STRONG></DT>
<DD>Sets the condition on which ESMF aborts.  The array
              can contain any combination of ESMF_LOGMSG named constants.  These
              named constants are described in section <A HREF="node6.html#const:logmsgflag">43.2.3</A>.
        
</DD>
<DT><STRONG>[stream]</STRONG></DT>
<DD>The type of stream, with the following valid values and meanings:
              <DL>
<DT></DT>
<DD>0  free;
                
</DD>
<DT></DT>
<DD>1  preordered. 
              
</DD>
</DL>
        
</DD>
<DT><STRONG>[maxElements]</STRONG></DT>
<DD>Maximum number of elements in the Log.
        
</DD>
<DT><STRONG>[logmsgList]</STRONG></DT>
<DD>An array of message types that will be logged.  Log write requests
              not matching the list will be ignored.  By default all messages
              will be logged.  If an empty array is provided, no messages will be logged.
              See section <A HREF="node6.html#const:logmsgflag">43.2.3</A> for a list of
              valid message types.  
        
</DD>
<DT><STRONG>[errorMask]</STRONG></DT>
<DD>List of error codes that will <EM>not</EM> be logged as errors.
        
</DD>
<DT><STRONG>[trace]</STRONG></DT>
<DD>If set to true, calls such as <TT>ESMF_LogFoundError</TT>,
              <TT>ESMF_LogFoundAllocError</TT>, and <TT>ESMF_LogFoundDeallocError</TT>
              will be logged as a tool for program flow tracing.  This may generate
              voluminous output in the log.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060107900000000000000">
43.7.9 ESMF_LogSetError - Set ESMF return code for error and write msg</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LogSetError(rcToCheck,  &amp;
                                   msg, line, file, method, &amp;
                                   rcToReturn, log)
</PRE><EM>ARGUMENTS:</EM>
<PRE>  	
       integer,          intent(in)              :: rcToCheck
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       character(len=*), intent(in),    optional :: msg
       integer,          intent(in),    optional :: line
       character(len=*), intent(in),    optional :: file
       character(len=*), intent(in),    optional :: method
       integer,          intent(out),   optional :: rcToReturn
       type(ESMF_Log),   intent(inout), optional :: log
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine sets the <TT>rcToReturn</TT> value to <TT>rcToCheck</TT> if
        <TT>rcToReturn</TT> is present and writes this error code to the <TT>ESMF_Log</TT>
        if an error is generated.  A predefined error message will added to the 
        <TT>ESMF_Log</TT> along with a user added <TT>msg</TT>, <TT>line</TT>, <TT>file</TT>
        and <TT>method</TT>.  

<P>
The arguments are:
        <DL>
<DT><STRONG>rcToCheck</STRONG></DT>
<DD>rc value for set
        
</DD>
<DT><STRONG>[msg]</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor macro <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name. 
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[rcToReturn]</STRONG></DT>
<DD>If specified, copy the <TT>rcToCheck</TT> value to <TT>rcToreturn</TT>.
              This is not the return code for this function; it allows
              the calling code to do an assignment of the error code
              at the same time it is testing the value.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
  	     of the default Log.

<P>
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601071000000000000000">
43.7.10 ESMF_LogWrite - Write to Log file(s)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       recursive subroutine ESMF_LogWrite(msg, logmsgList,  &amp;
                                          line, file, method, log, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character(len=*),   intent(in)              :: msg	    
       type(ESMF_LogMsg_Flag), intent(in)          :: logmsgList    
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,            intent(in),    optional :: line	    
       character(len=*),   intent(in),    optional :: file	    
       character(len=*),   intent(in),    optional :: method     
       type(ESMF_Log),     intent(inout), optional :: log	    
       integer,            intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This subroutine writes to the file associated with an <TT>ESMF_Log</TT>.
        A message is passed in along with the <TT>logmsgList</TT>, <TT>line</TT>, 
        <TT>file</TT> and <TT>method</TT>.  If the write to the <TT>ESMF_Log</TT>
        is successful, the function will return a logical <TT>true</TT>.  This 
        function is the base function used by all the other <TT>ESMF_Log</TT> 
        writing methods.

<P>
The arguments are:
        <DL>
<DT><STRONG>msg</STRONG></DT>
<DD>User-provided message string.
        
</DD>
<DT><STRONG>logmsgList</STRONG></DT>
<DD>The type of message.  See Section&nbsp;<A HREF="node6.html#const:logmsgflag">43.2.3</A> for
              possible values.
        
</DD>
<DT><STRONG>[line]</STRONG></DT>
<DD>Integer source line number.  Expected to be set by
              using the preprocessor macro <TT>__LINE__</TT> macro.
        
</DD>
<DT><STRONG>[file]</STRONG></DT>
<DD>User-provided source file name. 
        
</DD>
<DT><STRONG>[method]</STRONG></DT>
<DD>User-provided method string.
        
</DD>
<DT><STRONG>[log]</STRONG></DT>
<DD>An optional <TT>ESMF_Log</TT> object that can be used instead
  	     of the default Log.
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION060110000000000000000">
44 DELayout Class</A>
</H1>

<P>

<H2><A NAME="SECTION060111000000000000000">
44.1 Description</A>
</H2>

<P>
The DELayout class provides an additional layer of abstraction on top of the Virtual Machine (VM) layer. DELayout does this by introducing DEs (Decomposition Elements) as logical resource units. The DELayout object keeps track of the relationship between its DEs and the resources of the associated VM object. 

<P>
The relationship between DEs and VM resources (PETs (Persistent Execution Threads) and VASs (Virtual Address Spaces)) contained in a DELayout object is defined during its creation and cannot be changed thereafter. There are, however, a number of hint and specification arguments that can be used to shape the DELayout during its creation.

<P>
Contrary to the number of PETs and VASs contained in a VM object, which are fixed by the available resources, the number of DEs contained in a DELayout can be chosen freely to best match the computational problem or other design criteria. Creating a DELayout with less DEs than there are PETs in the associated VM object can be used to share resources between decomposed objects within an ESMF component. Creating a DELayout with more DEs than there are PETs in the associated VM object can be used to evenly partition the computation over the available resources.

<P>
The simplest case, however, is where the DELayout contains the same number of DEs as there are PETs in the associated VM context. In this case the DELayout may be used to re-label the hardware and operating system resources held by the VM. For instance, it is possible to order the resources so that specific DEs have best available communication paths. The DELayout will map the DEs to the PETs of the VM according to the resource details provided by the VM instance. 

<P>
Furthermore, general DE to PET mapping can be used to offer computational resources with finer granularity than the VM does. The DELayout can be queried for computational and communication capacities of DEs and DE pairs, respectively. This information can be used to best utilize the DE resources when partitioning the computational problem. In combination with other ESMF classes, general DE to PET mapping can be used to realize cache blocking, communication hiding and dynamic load balancing.

<P>
Finally, the DELayout layer offers primitives that allow a work queue style dynamic load balancing between DEs.

<P>

<H2><A NAME="SECTION060112000000000000000">
44.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION060112100000000000000"></A>
<A NAME="const:pin_flag"></A>
<BR>
44.2.1 ESMF_PIN
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Specifies which VM resource DEs are pinned to - i.e. PETs or VASs.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_Pin_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_PIN_DE_TO_PET</STRONG></DT>
<DD>Pin DEs against PETs. This means that even if a group of PETs in the 
    VM are sharing a common virtual address space (VAS), DEs cannot
    be shared between PETs, but must be serviced by the specific PET they
    are pinned to.
  
</DD>
<DT><STRONG>ESMF_PIN_DE_TO_VAS</STRONG></DT>
<DD>Pin DEs against VASs. DEs may be serviced by any PET that is 
    executing within the virtual address space (VAS) the DE is pinned to.
</DD>
</DL>

<P>

<H3><A NAME="SECTION060112200000000000000"></A>
<A NAME="const:servicereply_flag"></A>
<BR>
44.2.2 ESMF_SERVICEREPLY
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Reply when a PET offers to service a DE.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_ServiceReply_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_SERVICEREPLY_ACCEPT</STRONG></DT>
<DD>The service offer has been accepted. The PET is expected to service the DE.
  
</DD>
<DT><STRONG>ESMF_SERVICEREPLY_DENY</STRONG></DT>
<DD>The service offer has been denied. The PET is expected to not service the
    DE.
</DD>
</DL>

<P>

<H2><A NAME="SECTION060113000000000000000">
44.3 Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to create, use and destroy DELayout objects.

<P>

<P>

<P>

<H3><A NAME="SECTION060113100000000000000">
44.3.1 Default DELayout</A>
</H3>

<P>
Without specifying any of the optional parameters the created 
   <TT>ESMF_DELayout</TT>
   defaults into having as many DEs as there are PETs in the associated VM 
   object. Consequently the resulting DELayout describes a simple 1-to-1 DE to
   PET mapping. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(rc=rc)
</PRE>

<P>
The default DE to PET mapping is simply:
   <PRE>
   DE 0  -&gt; PET 0
   DE 1  -&gt; PET 1
   ...
</PRE>

<P>
DELayout objects that are not used any longer should be destroyed. 

<P>
<PRE>
  call ESMF_DELayoutDestroy(delayout, rc=rc)
</PRE>

<P>
The optional <TT>vm</TT> argument can be provided to DELayoutCreate() to lower 
   the method's overhead by the amount it takes to determine the current VM. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(vm=vm, rc=rc)
</PRE>

<P>
By default all PETs of the associated VM will be considered. However, if the 
   optional argument <TT>petList</TT> is present DEs will only be mapped against
   the PETs contained in the list. When the following example is executed on
   four PETs it creates a DELayout with four DEs by default that are mapped 
   to the provided PETs in their given order. It is erroneous to specify PETs 
   that are not part of the VM context on which the DELayout is defined.  

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petList=(/(i,i=petCount-1,1,-1)/), rc=rc)
</PRE>

<P>
Once the end of the petList has been reached the DE to PET mapping 
   continues from the beginning of the list. For a 4 PET VM the above created
   DELayout will end up with the following DE to PET mapping:

<P>
<PRE>
   DE 0  -&gt; PET 3
   DE 1  -&gt; PET 2
   DE 2  -&gt; PET 1
   DE 2  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION060113200000000000000">
44.3.2 DELayout with specified number of DEs</A>
</H3>

<P>
The <TT>deCount</TT> argument can be used to specify the number of DEs. In this
   example a DELayout is created that contains four times as many DEs as there 
   are PETs in the VM. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=4*petCount, rc=rc)
</PRE>

<P>
Cyclic DE to PET mapping is the default. For 4 PETs this means:
   <PRE>
   DE 0, 4,  8, 12  -&gt; PET 0
   DE 1, 5,  9, 13  -&gt; PET 1
   DE 2, 6, 10, 14  -&gt; PET 2
   DE 3, 7, 11, 15  -&gt; PET 3
</PRE>
   The default DE to PET mapping can be overridden by providing the
   <TT>deGrouping</TT> argument. This argument provides a positive integer group 
   number for each DE in the DELayout. All of the DEs of a group will be mapped 
   against the same PET. The actual group index is arbitrary (but must be 
   positive) and its value is of no consequence. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=4*petCount, &amp;
    deGrouping=(/(i/4,i=0,4*petCount-1)/), rc=rc)
</PRE>

<P>
This will achieve blocked DE to PET mapping. For 4 PETs this means:
   <PRE>
   DE  0,  1,  2,  3  -&gt; PET 0
   DE  4,  5,  6,  7  -&gt; PET 1
   DE  8,  9, 10, 11  -&gt; PET 2
   DE 12, 13, 14, 15  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION060113300000000000000">
44.3.3 DELayout with computational and communication weights</A>
</H3>

<P>
The quality of the partitioning expressed by the DE to PET mapping depends
   on the amount and quality of information provided during DELayout creation.
   In the following example the <TT>compWeights</TT> argument is used to specify
   relative computational weights for all DEs and communication weights for
   DE pairs are provided by the <TT>commWeights</TT> argument. The example assumes
   four DEs. 

<P>
<PRE>
  allocate(compWeights(4))
  allocate(commWeights(4, 4))
  ! setup compWeights and commWeights according to computational problem
  delayout = ESMF_DELayoutCreate(deCount=4, compWeights=compWeights, &amp;
    commWeights=commWeights, rc=rc)
  deallocate(compWeights, commWeights)
</PRE>

<P>
The resulting DE to PET mapping depends on the specifics of the VM object and
   the provided compWeights and commWeights arrays. 

<P>

<H3><A NAME="SECTION060113400000000000000">
44.3.4 DELayout from petMap</A>
</H3>

<P>
Full control over the DE to PET mapping is provided via the <TT>petMap</TT>
   argument. This example maps the DEs to PETs in reverse order. In the 4-PET
   case this will result in the following mapping:
   <PRE>
   DE 0 -&gt; PET 3
   DE 1 -&gt; PET 2
   DE 2 -&gt; PET 1
   DE 3 -&gt; PET 0
</PRE> 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/(i,i=petCount-1,0,-1)/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060113500000000000000">
44.3.5 DELayout from petMap with multiple DEs per PET</A>
</H3>

<P>
The <TT>petMap</TT> argument gives full control over DE to PET mapping. The 
   following example run on 4 or more PETs maps DEs to PETs according to the 
   following table:
   <PRE>
   DE 0 -&gt; PET 3
   DE 1 -&gt; PET 3
   DE 2 -&gt; PET 1
   DE 3 -&gt; PET 0
   DE 4 -&gt; PET 2
   DE 5 -&gt; PET 1
   DE 6 -&gt; PET 3
   DE 7 -&gt; PET 1
</PRE> 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/3, 3, 1, 0, 2, 1, 3, 1/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION060113600000000000000">
44.3.6 Working with a DELayout - simple 1-to-1 DE to PET mapping</A>
</H3>

<P>
The simplest case is a DELayout with as many DEs as PETs where each DE is 
   against a separate PET. This of course implies that the number of
   DEs equals the number of PETs. This special 1-to-1 DE to PET
   mapping is very common and many codes assume this mapping. The following 
   example code shows how a DELayout can be queried about its mapping. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, oneToOneFlag=oneToOneFlag, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  if (.not. oneToOneFlag) then
    ! handle the unexpected case of general DE to PET mapping
  endif
  allocate(localDeList(1))
  call ESMF_DELayoutGet(delayout, localDeList=localDeList, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  myDe = localDeList(1)
  deallocate(localDeList)
</PRE>

<P>

<H3><A NAME="SECTION060113700000000000000">
44.3.7 Working with a DELayout - general DE to PET mapping</A>
</H3>

<P>
In general a DELayout may describe a DE to PET mapping that is not 1-to-1. The
   following example shows how code can be written in a general form that will 
   work on all PETs for DELayouts with general or 1-to-1 DE to PET mapping. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=petCount+2, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  allocate(localDeList(localDeCount))
  call ESMF_DELayoutGet(delayout, localDeList=localDeList, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  do i=1, localDeCount
    workDe = localDeList(i)
!    print *, "I am PET", localPET, " and I am working on DE ", workDe
  enddo
  deallocate(localDeList)
</PRE>

<P>

<H3><A NAME="SECTION060113800000000000000">
44.3.8 Work queue dynamic load balancing</A>
</H3>

<P>
The DELayout API includes two calls that can be used to easily implement
   work queue dynamic load balancing. The work load is broken up into DEs 
   (more than there are PETs) and processed by the PETs. Load balancing is
   only possible for ESMF multi-threaded VMs and requires that DEs are pinned
   to VASs instead of the PETs (default). The following example will
   run for any VM and DELayout, however, load balancing will only occur under the
   mentioned conditions. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=petCount+2, &amp;
    pinflag=ESMF_PIN_DE_TO_VAS, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, vasLocalDeCount=localDeCount, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  allocate(localDeList(localDeCount))
  call ESMF_DELayoutGet(delayout, vasLocalDeList=localDeList, rc=rc)
  if (rc /= ESMF_SUCCESS) finalrc=rc
  do i=1, localDeCount
    workDe = localDeList(i)
    print *, "I am PET", localPET, &amp;
             " and I am offering service for DE ", workDe
    reply = ESMF_DELayoutServiceOffer(delayout, de=workDe, rc=rc)
    if (rc /= ESMF_SUCCESS) finalrc=rc
    if (reply == ESMF_SERVICEREPLY_ACCEPT) then
      ! process work associated with workDe
      print *, "I am PET", localPET, ", service offer for DE ", workDe, &amp;
        " was accepted."
      call ESMF_DELayoutServiceComplete(delayout, de=workDe, rc=rc)
      if (rc /= ESMF_SUCCESS) finalrc=rc
    endif
  enddo
  deallocate(localDeList)
</PRE>

<P>

<P>

<H2><A NAME="SECTION060114000000000000000">
44.4 Restrictions and Future Work</A>
</H2>

<P>

<P>

<H2><A NAME="SECTION060115000000000000000">
44.5 Design and Implementation Notes</A>
</H2>

<P>
The DELayout class is a light weight object. It stores the DE to PET and VAS mapping for all DEs within all PET instances and a list of local DEs for each PET instance. The DELayout does not store the computational and communication weights optionally provided as arguments to the create method. These hints are only used during create while they are available in user owned arrays.

<P>

<H2><A NAME="SECTION060116000000000000000">
44.6 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060116100000000000000">
44.6.1 ESMF_DELayoutAssignment(=) - DELayout assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     delayout1 = delayout2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout) :: delayout1
     type(ESMF_DELayout) :: delayout2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign delayout1 as an alias to the same ESMF DELayout object in memory
     as delayout2. If delayout2 is invalid, then delayout1 will be equally
     invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116200000000000000">
44.6.2 ESMF_DELayoutOperator(==) - DELayout equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (delayout1 == delayout2) then ... endif
               OR
     result = (delayout1 == delayout2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout), intent(in) :: delayout1
     type(ESMF_DELayout), intent(in) :: delayout2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether delayout1 and delayout2 are valid aliases to the same ESMF
     DELayout object in memory. For a more general comparison of two
     ESMF DELayouts, going beyond the simple alias test, the 
     ESMF_DELayoutMatch() function (not yet implemented) must
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116300000000000000">
44.6.3 ESMF_DELayoutOperator(/=) - DELayout not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (delayout1 /= delayout2) then ... endif
               OR
     result = (delayout1 /= delayout2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout), intent(in) :: delayout1
     type(ESMF_DELayout), intent(in) :: delayout2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether delayout1 and delayout2 are <I>not</I> valid aliases to the
     same ESMF DELayout object in memory. For a more general comparison of two
     ESMF DELayouts, going beyond the simple alias test, the 
     ESMF_DELayoutMatch() function (not yet implemented) must
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>delayout1</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>delayout2</STRONG></DT>
<DD>The <TT>ESMF_DELayout</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116400000000000000">
44.6.4 ESMF_DELayoutCreate - Create DELayout object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DELayoutCreate()
   function ESMF_DELayoutCreateDefault(deCount, deGrouping, &amp;
     pinflag, petList, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                      intent(in),  optional :: deCount
     integer, target,              intent(in),  optional :: deGrouping(:)
     type(ESMF_Pin_Flag),          intent(in),  optional :: pinflag
     integer, target,              intent(in),  optional :: petList(:)
     type(ESMF_VM),                intent(in),  optional :: vm
     integer,                      intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DELayout) :: ESMF_DELayoutCreateDefault
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DELayout</TT> object on the basis of optionally provided
       restrictions. By default a DELayout with deCount equal to petCount will
       be created, each DE mapped to a single PET. However, the number of DEs
       as well grouping of DEs and PETs can be specified via the optional
       arguments.

<P>
The arguments are:
       <DL>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>Number of DEs to be provided by the created DELayout. By default
            the number of DEs equals the number of PETs in the associated VM
            context. Specifying a <TT>deCount</TT> smaller than the number
            of PETs will result in unassociated PETs.
            This may be used to share VM resources between DELayouts within the
            same ESMF component. Specifying a <TT>deCount</TT> greater than the 
            number of PETs will result in multiple DE to PET mapping.
       
</DD>
<DT><STRONG>[deGrouping]</STRONG></DT>
<DD>This optional argument must be of size deCount. Its content assigns
            a DE group index to each DE of the DELayout. A group index of -1 
            indicates that the associated DE isn't member of any particular 
            group. The significance of DE groups is that all the DEs belonging
            to a certain group will be mapped against the <EM>same</EM> PET. This
            does not, however, mean that DEs belonging to different DE groups 
            must be mapped to different PETs.
       
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>This flag specifies which type of resource DEs are pinned to. 
            The default is to pin DEs to PETs. Alternatively it is
            also possible to pin DEs to VASs. See section 
            <A HREF="node6.html#const:pin_flag">44.2.1</A> for a list of valid pinning options.
       
</DD>
<DT><STRONG>[petList]</STRONG></DT>
<DD>List specifying PETs to be used by this DELayout. This can be used
            to control the PET overlap between DELayouts within the same
            ESMF component. It is erroneous to specify PETs that are not within 
            the provided VM context. The default is to include all the PETs of
            the VM.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116500000000000000">
44.6.5 ESMF_DELayoutCreate - Create DELayout from petMap</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DELayoutCreate()
   function ESMF_DELayoutCreateFromPetMap(petMap, pinflag, &amp;
     vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                      intent(in)            :: petMap(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Pin_Flag),          intent(in),  optional :: pinflag
     type(ESMF_VM),                intent(in),  optional :: vm
     integer,                      intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DELayout) :: ESMF_DELayoutCreateFromPetMap
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DELayout</TT> with exactly specified DE to PET mapping.

<P>
This ESMF method must be called in unison by all PETs of the VM. Calling
       this method from a PET not part of the VM or not calling it from a PET
       that is part of the VM will result in undefined behavior. ESMF does not
       guard against violation of the unison requirement. The call is not
       collective, there is no communication between PETs.

<P>
The arguments are:
       <DL>
<DT><STRONG>petMap</STRONG></DT>
<DD>List specifying the DE-to-PET mapping. The list elements correspond 
            to DE 0, 1, 2, ... and map against the specified PET of the VM
            context. The size of the <TT>petMap</TT> 
            argument determines the number of DEs in the created DELayout. It is
            erroneous to specify a PET identifier that lies outside the VM 
            context.
       
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>This flag specifies which type of resource DEs are pinned to. 
            The default is to pin DEs to PETs. Alternatively it is
            also possible to pin DEs to VASs. See section 
            <A HREF="node6.html#const:pin_flag">44.2.1</A> for a list of valid pinning options.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object. The VM of the current context is the
            typical and default value.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116600000000000000">
44.6.6 ESMF_DELayoutDestroy - Release resources associated with DELayout object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DELayoutDestroy(delayout, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(inout)          :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_DELayout</TT> object.

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> object to be destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116700000000000000">
44.6.7 ESMF_DELayoutGet - Get DELayout internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DELayoutGet(delayout, vm, deCount, petMap, &amp;
     vasMap, oneToOneFlag, pinflag, localDeCount, localDeList, &amp;
     vasLocalDeCount, vasLocalDeList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),      intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_VM),            intent(out), optional :: vm
     integer,                  intent(out), optional :: deCount
     integer, target,          intent(out), optional :: petMap(:)
     integer, target,          intent(out), optional :: vasMap(:)
     logical,                  intent(out), optional :: oneToOneFlag
     type(ESMF_Pin_Flag),      intent(out), optional :: pinflag
     integer,                  intent(out), optional :: localDeCount
     integer, target,          intent(out), optional :: localDeList(:)
     integer,                  intent(out), optional :: vasLocalDeCount
     integer, target,          intent(out), optional :: vasLocalDeList(:)
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Access to DELayout information.

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Queried <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Upon return this holds the <TT>ESMF_VM</TT> object on which the delayout
          is defined.
       
</DD>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>Upon return this holds the total number of DEs.
       
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Upon return this holds the list of PETs against which the DEs are 
          mapped. The <TT>petMap</TT> argument must at least be of size
          <TT>deCount</TT>.
       
</DD>
<DT><STRONG>[vasMap]</STRONG></DT>
<DD>Upon return this holds the list of VASs against which the DEs are 
          mapped. The <TT>vasMap</TT> argument must at least be of size
          <TT>deCount</TT>.
       
</DD>
<DT><STRONG>[oneToOneFlag]</STRONG></DT>
<DD>Upon return this holds <TT>.TRUE.</TT> if the specified 
          <TT>ESMF_DELayout</TT> describes a 1-to-1 mapping between DEs and PETs,
          <TT>.FALSE.</TT> otherwise.
       
</DD>
<DT><STRONG>[pinflag]</STRONG></DT>
<DD>Upon return this flag will indicate the type of DE pinning. 
          See section <A HREF="node6.html#const:pin_flag">44.2.1</A> for a list of valid pinning 
          options.
       
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>Upon return this holds the number of DEs associated with the local PET.
       
</DD>
<DT><STRONG>[localDeList]</STRONG></DT>
<DD>Upon return this holds the list of DEs associated with the local PET.
          The provided argument must at least be of size <TT>localDeCount</TT>.
       
</DD>
<DT><STRONG>[vasLocalDeCount]</STRONG></DT>
<DD>Upon return this holds the number of DEs associated with the local VAS.
       
</DD>
<DT><STRONG>[vasLocalDeList]</STRONG></DT>
<DD>Upon return this holds the list of DEs associated with the local VAS.
          The provided argument must at least be of size <TT>vasLocalDeCount</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116800000000000000">
44.6.8 ESMF_DELayoutPrint - Print DELayout internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DELayoutPrint(delayout, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Prints internal information about the specified <TT>ESMF_DELayout</TT> 
       object to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060116900000000000000">
44.6.9 ESMF_DELayoutServiceComplete - Close service window</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine ESMF_DELayoutServiceComplete(delayout, de, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
     integer,              intent(in)            :: de
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
The PET who's service offer was accepted for <TT>de</TT> must use 
     <TT>ESMF_DELayoutServiceComplete</TT> to close the service window.

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>de</STRONG></DT>
<DD>DE for which to close service window.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601161000000000000000">
44.6.10 ESMF_DELayoutServiceOffer - Offer service for a DE in DELayout</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive function ESMF_DELayoutServiceOffer(delayout, de, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
     integer,              intent(in)            :: de
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_ServiceReply_Flag) :: ESMF_DELayoutServiceOffer
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Offer service for a DE in the <TT>ESMF_DELayout</TT> object. This call
       together with <TT>ESMF_DELayoutServiceComplete()</TT> provides the
       synchronization primitives between the PETs of an ESMF multi-threaded VM
       necessary for dynamic load balancing via a work queue approach.

<P>
The calling PET will either receive <TT>ESMF_SERVICEREPLY_ACCEPT</TT> if
       the service offer has been accepted by DELayout or 
       <TT>ESMF_SERVICEREPLY_DENY</TT> if the service offer was denied. The 
       service offer paradigm is different from a simple mutex approach in that
       the DELayout keeps track of the number of service offers issued for each
       DE by each PET and accepts only one PET's offer for each offer increment.
       This requires that all PETs use <TT>ESMF_DELayoutServiceOffer()</TT> in 
       unison. See section <A HREF="node6.html#const:servicereply_flag">44.2.2</A> for the potential return
       values.

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>de</STRONG></DT>
<DD>DE for which service is offered by the calling PET.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601161100000000000000">
44.6.11 ESMF_DELayoutValidate - Validate DELayout internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DELayoutValidate(delayout, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DELayout),  intent(in)            :: delayout
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>delayout</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>delayout</STRONG></DT>
<DD>Specified <TT>ESMF_DELayout</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION060120000000000000000">
45 VM Class</A>
</H1>

<P>

<H2><A NAME="SECTION060121000000000000000">
45.1 Description</A>
</H2>

<P>
The ESMF VM (Virtual Machine) class is a generic representation of hardware and system software resources. There is exactly one VM object per ESMF Component, providing the execution environment for the Component code. The VM class handles all resource management tasks for the Component class and provides a description of the underlying configuration of the compute resources used by a Component.

<P>
In addition to resource description and management, the VM class offers the lowest level of ESMF communication methods. The VM communication calls are very similar to MPI. Data references in VM communication calls must be provided as raw, language specific, one-dimensional, contiguous data arrays. The similarity between VM and MPI communication calls is striking and there are many equivalent point-to-point and collective communication calls. However, unlike MPI, the VM communication calls support communication between threaded PETs in a completely transparent fashion.

<P>
Many ESMF applications do not interact with the VM class directly very much. The  resource management aspect is wrapped completely transparent into the ESMF Component concept. Often the only reason that user code queries a Component
object for the associated VM object is to inquire about resource information, such as the <TT>localPet</TT> or the <TT>petCount</TT>. Further, for most applications the use of higher level communication APIs, such as provided by Array and Field, are much more convenient than using the low level VM communication calls.

<P>
The basic elements of a VM are called PETs, which stands for Persistent Execution Threads. These are equivalent to OS threads with a lifetime of at least that of the associated component. All VM functionality is expressed in terms of PETs. In the simplest, and most common case, a PET is equivalent to an MPI process. However, ESMF also supports multi-threading, where multiple PETs run as Pthreads inside the same virtual address space (VAS).

<P>
The resource management functions of the VM class become visible when a component, or the driver code, creates sub-components. Section <A HREF="node4.html#sec:AppDriverSetVM">14.4.5</A> discusses this aspect from the Superstructure 
perspective and provides links to the relevant Component examples in the documentation.

<P>
There are two parts to resource management, the parent and the child. When the parent component creates a child component, the parent VM object provides the resources on which the child is created with <TT>ESMF_GridCompCreate()</TT> or <TT>ESMF_CplCompCreate()</TT>. The optional <TT>petList</TT> argument to these calls limits the resources that the parent gives to a specific child. The child component, may specify - during its optional 
<TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> method - how it wants to arrange the inherited resources in its own VM. After this, all standard ESMF methods of the Component, including <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, will execute in the child VM. Notice that the <TT>ESMF_&lt;Grid/Cpl&gt;CompSetVM()</TT> routine, although part of the child Component, must execute <EM>before</EM> the child VM has been started up. It runs in the parent VM context. The child VM is created and started up just before the user-written set services routine, specified as an argument to <TT>ESMF_&lt;Grid/Cpl&gt;CompSetServices()</TT>, is entered.

<P>

<H2><A NAME="SECTION060122000000000000000">
45.2 Use and Examples</A>
</H2>

<P>
The concept of the ESMF Virtual Machine (VM) is so fundamental to the framework that every ESMF application uses it. However, for many user applications the VM class is transparently hidden behind the ESMF Component concept and higher data classes (e.g. Array, Field). The interaction between user code and VM is often only indirect. The following examples provide an overview of where the VM class can come into play in user code.

<P>

<P>

<P>

<H3><A NAME="SECTION060122100000000000000">
45.2.1 Global VM</A>
</H3>

<P>
This complete example program demonstrates the simplest ESMF application, 
   consisting of only a main program without any Components. The global
   VM, which is automatically created during the <TT>ESMF_Initialize()</TT> call,
   is obtained using two different methods. First the global VM will be returned
   by <TT>ESMF_Initialize()</TT> if the optional <TT>vm</TT> argument is specified.
   The example uses the VM object obtained this way to call the VM print method.
   Second, the global VM can be obtained anywhere in the user application using
   the <TT>ESMF_VMGetGlobal()</TT> call. The identical VM is returned and several
   VM query methods are called to inquire about the associated resources.

<P>
<PRE>
program ESMF_VMDefaultBasicsEx

  use ESMF
  
  implicit none
  
  ! local variables
  integer:: rc
  type(ESMF_VM):: vm
  integer:: localPet, petCount, peCount, ssiId, vas
</PRE>

<P>
<PRE>
  call ESMF_Initialize(vm=vm, defaultlogfilename="VMDefaultBasicsEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  ! Providing the optional vm argument to ESMF_Initialize() is one way of
  ! obtaining the global VM.
</PRE>

<P>
<PRE>
  call ESMF_VMPrint(vm, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_VMGetGlobal(vm=vm, rc=rc)
  ! Calling ESMF_VMGetGlobal() anywhere in the user application is the other
  ! way to obtain the global VM object.
</PRE>

<P>
<PRE>
  call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, peCount=peCount, &amp;
    rc=rc)
  ! The VM object contains information about the associated resources. If the
  ! user code requires this information it must query the VM object.
</PRE>

<P>
<PRE>
  print *, "This PET is localPet: ", localPet
  print *, "of a total of ",petCount," PETs in this VM."
  print *, "There are ", peCount," PEs referenced by this VM"

  call ESMF_VMGet(vm, localPet, peCount=peCount, ssiId=ssiId, vas=vas, rc=rc)
</PRE>

<P>
<PRE>
  print *, "This PET is executing in virtual address space (VAS) ", vas
  print *, "located on single system image (SSI) ", ssiId
  print *, "and is associated with ", peCount, " PEs."

  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060122200000000000000">
45.2.2 Getting the MPI Communicator from an VM object</A>
</H3>

<P>
Sometimes user code requires access to the MPI communicator, e.g. to support
   legacy code that contains explict MPI communication calls. The correct way of
   wrapping such code into ESMF is to obtain the MPI intra-communicator out of
   the VM object. In order not to interfere with ESMF communications it is
   advisable to duplicate the communicator before using it in user-level MPI
   calls. In this example the duplicated communicator is used for a user
   controlled <TT>MPI_Barrier()</TT>.

<P>
<PRE>
  integer:: mpic
</PRE>

<P>
<PRE>
  integer:: mpic2
</PRE>

<P>
<PRE>
  call ESMF_VMGet(vm, mpiCommunicator=mpic, rc=rc)
  ! The returned MPI communicator spans the same MPI processes that the VM
  ! is defined on.
</PRE>

<P>
<PRE>
  call MPI_Comm_dup(mpic, mpic2, ierr)
  ! Duplicate the MPI communicator not to interfere with ESMF communications.
  ! The duplicate MPI communicator can be used in any MPI call in the user
  ! code. Here the MPI_Barrier() routine is called.
  call MPI_Barrier(mpic2, ierr)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060122300000000000000">
45.2.3 Nesting ESMF inside a user MPI application</A>
</H3>

<P>
It is possible to nest an ESMF application inside a user application that 
   explicitly calls <TT>MPI_Init()</TT> and <TT>MPI_Finalize()</TT>. The
   <TT>ESMF_Initialize()</TT> call automatically checks whether MPI has already
   been initialized, and if so does not call <TT>MPI_Init()</TT> internally. 
   On the finalize side, <TT>ESMF_Finalize()</TT> can be instructed to <EM>not</EM>
   call <TT>MPI_Finalize()</TT>, making it the responsibility of the outer code
   to finalize MPI.

<P>
<PRE>
  call MPI_Init(ierr)
  ! User code initializes MPI.
</PRE>

<P>
<PRE>
  call ESMF_Initialize(defaultlogfilename="VMUserMpiEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  ! ESMF_Initialize() does not call MPI_Init() if it finds MPI initialized.
</PRE>

<P>
<PRE>
  call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
  ! Calling with endflag=ESMF_END_KEEPMPI instructs ESMF_Finalize() to keep
  ! MPI active.
</PRE>

<P>
<PRE>
  call MPI_Finalize(ierr)
  ! It is the responsibility of the outer user code to finalize MPI.
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060122400000000000000">
45.2.4 Nesting ESMF inside a user MPI application on a subset of MPI ranks</A>
</H3>

<P>
The previous example demonstrated that it is possible to nest an ESMF 
   application, i.e. <TT>ESMF_Initialize()</TT>...<TT>ESMF_Finalize()</TT> inside
   <TT>MPI_Init()</TT>...<TT>MPI_Finalize()</TT>. It is not necessary that all
   MPI ranks enter the ESMF application. The following example shows how the
   user code can pass an MPI communicator to <TT>ESMF_Initialize()</TT>, and
   enter the ESMF application on a subset of MPI ranks.

<P>
<PRE>
  call MPI_Init(ierr)
  ! User code initializes MPI.
</PRE>

<P>
<PRE>
  call MPI_Comm_rank(MPI_COMM_WORLD, rank, ierr)
  ! User code determines the local rank.
</PRE>

<P>
<PRE>
  ! User code prepares MPI communicator "esmfComm" that only contains
  ! rank 0 and 1.
</PRE>

<P>
<PRE>
  if (rank &lt; 2) then
    call ESMF_Initialize(mpiCommunicator=esmfComm, &amp;
		    defaultlogfilename="VMUserMpiCommEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
    ! Only call ESMF_Initialize() on rank 0 and 1, passing the prepared MPI
    ! communicator that spans these ranks.
</PRE>

<P>
<PRE>
    call ESMF_Finalize(endflag=ESMF_END_KEEPMPI, rc=rc)
    ! Finalize ESMF without finalizing MPI. The user application will call
    ! MPI_Finalize() on all ranks.
</PRE>

<P>
<PRE>
  endif
</PRE>

<P>
<PRE>
  call MPI_Finalize(ierr)
  ! User code finalizes MPI.
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060122500000000000000">
45.2.5 Send/Recv</A>
</H3>

<P>
The VM layer provides MPI-like point-to-point communication. Use 
   <TT>ESMF_VMSend()</TT> and <TT>ESMF_VMRecv()</TT> to pass data between two PETs.
   The following code sends data from PET 'src' and receives it on PET 'dst'.
   Both PETs must be part of the same VM. The sendData and recvData arguments
   must be 1-dimensional arrays.

<P>
<PRE>
  if (localPet==src) &amp;
    call ESMF_VMSend(vm, sendData=localData, count=count, dstPet=dst, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet==dst) &amp;
    call ESMF_VMRecv(vm, recvData=localData, count=count, srcPet=src, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060122600000000000000">
45.2.6 Scatter and Gather</A>
</H3>

<P>
The VM layer provides MPI-like collective communication. <TT>ESMF_VMScatter()</TT>
   scatters data located on <TT>root</TT> PET across all the PETs of the VM. 
   <TT>ESMF_VMGather()</TT> provides the opposite operation, gathering data from
   all the PETs of the VM onto <TT>root</TT> PET.

<P>
<PRE>
  call ESMF_VMScatter(vm, sendData=array1, recvData=array2, count=nsize, &amp;
    rootPet=scatterRoot, rc=rc)
  ! Both sendData and recvData must be 1-d arrays.
</PRE>

<P>
<PRE>
  call ESMF_VMGather(vm, sendData=array2, recvData=array1, count=nsize, &amp;
    rootPet=gatherRoot, rc=rc)
  ! Both sendData and recvData must be 1-d arrays.
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060122700000000000000">
45.2.7 AllReduce and AllFullReduce</A>
</H3>

<P>
Use <TT>ESMF_VMAllReduce()</TT> to reduce data distributed across the PETs of a 
   VM into a result vector, returned on all the PETs. Further, use
   <TT>ESMF_VMAllFullReduce()</TT> to reduce the data into a single scalar returned
   on all PETs.

<P>
<PRE>
  call ESMF_VMAllReduce(vm, sendData=array1, recvData=array2, count=nsize, &amp;
    reduceflag=ESMF_REDUCE_SUM, rc=rc)
  ! Both sendData and recvData must be 1-d arrays. Reduce distributed 
  ! sendData element by element into recvData and return in on all PETs.
</PRE>

<P>
<PRE>
  call ESMF_VMAllFullReduce(vm, sendData=array1, recvData=result, &amp;
    count=nsize, reduceflag=ESMF_REDUCE_SUM, rc=rc)
  ! sendData must be 1-d array. Fully reduce the distributed sendData 
  ! into a single scalar and return it in recvData on all PETs.
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060122800000000000000">
45.2.8 VM and Components</A>
</H3>

<P>
The following example shows the role that the VM plays in connection with ESMF 
   Components. A single Component is created in the main program. Through the
   optional <TT>petList</TT> argument the driver code specifies that only resources
   associated with PET 0 are given to the <TT>gcomp</TT> object. 

<P>
When the Component code is invoked through the standard ESMF Component methods
   Initialize, Run, or Finalize the Component's VM is automatically entered.
   Inside of the user-written Component code the Component VM can be obtained
   by querying the Component object. The VM object will indicate that only a
   single PET is executing the Component code.

<P>
<PRE>
module ESMF_VMComponentEx_gcomp_mod
</PRE>

<P>
<PRE>
  recursive subroutine mygcomp_init(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc

    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

  
  recursive subroutine mygcomp_run(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc
    
    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

  recursive subroutine mygcomp_final(gcomp, istate, estate, clock, rc)
    type(ESMF_GridComp)   :: gcomp
    type(ESMF_State)      :: istate, estate
    type(ESMF_Clock)      :: clock
    integer, intent(out)  :: rc
    
    ! local variables
    type(ESMF_VM):: vm
    
    ! get this Component's vm    
    call ESMF_GridCompGet(gcomp, vm=vm)
    
    ! the VM object contains information about the execution environment of
    ! the Component

    call ESMF_VMPrint(vm, rc=rc)
    
    rc = 0
  end subroutine !--------------------------------------------------------------

end module
</PRE>

<P>
<PRE>
program ESMF_VMComponentEx
  use ESMF
  use ESMF_VMComponentEx_gcomp_mod
  implicit none
  
  ! local variables
</PRE>

<P>
<PRE>
  gcomp = ESMF_GridCompCreate(petList=(/0/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompSetServices(gcomp, mygcomp_register, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompInitialize(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompRun(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompFinalize(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_GridCompDestroy(gcomp, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>

<P>

<H2><A NAME="SECTION060123000000000000000">
45.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Fortran array section syntax is not supported</B> for source and
destination arguments in VM communication calls. Just as for MPI, the VM
communication calls require contiguous data arrays. Fortran array sections are
not guaranteed to be contiguous. This fundamental restriction is not likely to
change in future releases.

<P>
</LI>
<LI><B>Non-blocking <TT>Reduce()</TT> operations <EM>not</EM> implemented.</B> None of the reduce communication calls have an implementation for the non-blocking feature. This affects:

<UL>
<LI><TT>ESMF_VMAllFullReduce()</TT>,
</LI>
<LI><TT>ESMF_VMAllReduce()</TT>,
</LI>
<LI><TT>ESMF_VMReduce()</TT>.
</LI>
</UL>

<P>
</LI>
<LI><B>Limitations when using <TT>mpiuni</TT> mode.</B> In <TT>mpiuni</TT> mode non-blocking communications are limited to one outstanding message per source-destination PET pair. Furthermore, in <TT>mpiuni</TT> mode the message length must be smaller than the internal ESMF buffer size.

<P>
</LI>
<LI><B>Alternative communication paths not accessible.</B> All user accessible VM communication calls are currently implemented using MPI-1.2. VM's implementation of alternative communication techniques, such as shared memory between threaded PETs and POSIX IPC between PETs located on the same single system image, are currently inaccessible to the user. (One exception to this is the <TT>mpiuni</TT> case for which the VM automatically utilizes a shared memory path.)

<P>
</LI>
<LI><B>Data arrays in VM comm calls are <EM>assumed shape</EM> with rank=1.</B> Currently all dummy arrays in VM comm calls are defined as <EM>assumed shape</EM> arrays of rank=1. The motivation for this choice is that the use of assumed shape dummy arrays guards against the Fortran copy in/out problem. However it may not be as flexible as desired from the user perspective. Alternatively all dummy arrays could be defined as <EM>assumed size</EM> arrays, as it is done in most MPI implementations, allowing arrays of various rank to be passed into the comm methods.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION060124000000000000000">
45.4 Design and Implementation Notes</A>
</H2>

<P>
The VM class provides an additional layer of abstraction on top of the POSIX machine model, making it suitable for HPC applications. There are four key aspects the VM class deals with.

<P>

<OL>
<LI>Encapsulation of hardware and operating system details within the concept of Persistent Execution Threads (PETs).

<P>
</LI>
<LI>Resource management in terms of PETs with a guard against over-subscription.

<P>
</LI>
<LI>Topological description of the underlying configuration of the compute resources in terms of PETs.

<P>
</LI>
<LI>Transparent communication API for point-to-point and collective PET-based primitives, hiding the many different communication channels and offering best possible performance.

<P>
</LI>
</OL>

<P>
<DIV ALIGN="CENTER">
<!-- MATH
 $\scalebox{0.6}{\includegraphics{VM_design}}$
 -->
<IMG
 WIDTH="722" HEIGHT="527" ALIGN="BOTTOM" BORDER="0"
 SRC="img106.png"
 ALT="\scalebox{0.6}{\includegraphics{VM_design}}">
</DIV>

<P>
<B>Definition of terms used in the diagram</B>

<P>

<UL>
<LI>PE: A processing element (PE) is an alias for the smallest physical processing unit available on a particular hardware platform. In the language of today's microprocessor architecture technology a PE is identical to a core, however, if future microprocessor designs change the smallest physical processing unit the mapping of the PE to actual hardware will change accordingly. Thus the PE layer separates the hardware specific part of the VM from the hardware-independent part. Each PE is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>Core: A Core is the smallest physical processing unit which typically comprises a register set, an integer arithmetic unit, a floating-point unit and various control units. Each Core is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>CPU: The central processing unit (CPU) houses single or multiple cores, providing them with the interface to system memory, interconnects and IO. Typically the CPU provides some level of caching for the instruction and data streams in and out of the Cores. Cores in a multi-core CPU typically share some caches. Each CPU is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>SSI: A single system image (SSI) spans all the CPUs controlled by a single running instance of the operating system. SMP and NUMA are typical multi-CPU SSI architectures. Each SSI is labeled with an id number which identifies it uniquely within all of the VM instances of an ESMF application.

<P>
</LI>
<LI>TOE: A thread of execution (TOE) executes an instruction sequence. TOE's come in two flavors: PET and TET.

<P>
</LI>
<LI>PET: A persistent execution thread (PET) executes an instruction sequence on an associated set of data. The PET has a lifetime at least as long as the associated data set. In ESMF the PET is the central concept of abstraction provided by the VM class. The PETs of an VM object are labeled from 0 to N-1 where N is the total number of PETs in the VM object.

<P>
</LI>
<LI>TET: A transient execution thread (TET) executes an instruction sequence on an associated set of data. A TET's lifetime might be shorter than that of the associated data set.

<P>
</LI>
<LI>OS-Instance: The OS-Instance of a TOE describes how a particular TOE is instantiated on the OS level. Using POSIX terminology a TOE will run as a single thread within a single- or multi-threaded process.

<P>
</LI>
<LI>Pthreads: Communication via the POSIX Thread interface.

<P>
</LI>
<LI>MPI-1, MPI-2: Communication via MPI standards 1 and 2.

<P>
</LI>
<LI>armci: Communication via the aggregate remote memory copy interface.

<P>
</LI>
<LI>SHMEM: Communication via the SHMEM interface.

<P>
</LI>
<LI>OS-IPC: Communication via the operating system's inter process communication interface. Either POSIX IPC or System V IPC.

<P>
</LI>
<LI>InterCon-lib: Communication via the interconnect's library native interface. An example is the Elan library for Quadrics.

<P>
</LI>
</UL>

<P>
The POSIX machine abstraction, while a very powerful concept, needs augmentation when applied to HPC applications. Key elements of the POSIX abstraction are processes, which provide virtually unlimited resources (memory, I/O, sockets, ...) to possibly multiple threads of execution. Similarly POSIX threads create the illusion that there is virtually unlimited processing power available to each POSIX process. While the POSIX abstraction is very suitable for many multi-user/multi-tasking applications that need to share limited physical resources, it does not directly fit the HPC workload where over-subscription of resources is one of the most expensive modes of operation.

<P>
ESMF's virtual machine abstraction is based on the POSIX machine model but holds additional information about the available physical processing units in terms of Processing Elements (PEs). A PE is the smallest physical processing unit and encapsulates the hardware details (Cores, CPUs and SSIs).

<P>
There is exactly one physical machine layout for each application, and all VM instances have access to this information. The PE is the smallest processing unit which, in today's microprocessor technology, corresponds to a single Core. Cores are arranged in CPUs which in turn are arranged in SSIs. The setup of the physical machine layout is part of the ESMF initialization process.

<P>
On top of the PE concept the key abstraction provided by the VM is the PET. All user code is executed by PETs while OS and hardware details are hidden. The VM class contains a number of methods which allow the user to prescribe how the PETs of a desired virtual machine should be instantiated on the OS level and how they should map onto the hardware. This prescription is kept in a private virtual machine plan object which is created at the same time the associated component is being created. Each time component code is entered through one of the component's registered top-level methods (Initialize/Run/Finalize), the virtual machine plan along with a pointer to the respective user function is used to instantiate the user code on the PETs of the associated VM in form of single- or multi-threaded POSIX processes.

<P>
The process of starting, entering, exiting and shutting down a VM is very transparent, all spawning and joining of threads is handled by VM methods "behind the scenes". Furthermore, fundamental synchronization and communication primitives are provided on the PET level through a uniform API, hiding details related to the actual instantiation of the participating PETs.

<P>
Within a VM object each PE of the physical machine maps to 0 or 1 PETs. Allowing unassigned PEs provides a means to prevent over-subscription between multiple concurrently running virtual machines. Similarly a maximum of one PET per PE prevents over-subscription within a single VM instance. However, over-subscription is possible by subscribing PETs from different virtual machines to the same PE. This type of over-subscription can be desirable for PETs associated with IO work loads expected to be used infrequently and to block often on IO requests.

<P>
On the OS level each PET of a VM object is represented by a POSIX thread (Pthread) either belonging to a single- or multi-threaded process and maps to at least 1 PE of the physical machine, ensuring its execution. Mapping a single PET to multiple PEs provides resources for user-level multi-threading, in which case the user code inquires how many PEs are associated with its PET and if there are multiple PEs available the user code can spawn an equal number of threads (e.g. OpenMP) without risking over-subscription. Typically these user spawned threads are short-lived and used for fine-grained parallelization in form of TETs. All PEs mapped against a single PET must be part of a unique SSI in order to allow user-level multi-threading!

<P>
In addition to discovering the physical machine the ESMF initialization process sets up the default global virtual machine. This VM object, which is the ultimate parent of all VMs created during the course of execution, contains as many PETs as there are PEs in the physical machine. All of its PETs are instantiated in form of single-threaded MPI processes and a 1:1 mapping of PETs to PEs is used for the default global VM.

<P>
The VM design and implementation is based on the POSIX process and thread model as well as the MPI-1.2 standard. As a consequence of the latter standard the number of processes is static during the course of execution and is determined at start-up. The VM implementation further requires that the user starts up the ESMF application with as many MPI processes as there are PEs in the available physical machine using the platform dependent mechanism to ensure proper process placement. 

<P>
All MPI processes participating in a VM are grouped together by means of an MPI_Group object and their context is defined via an MPI_Comm object (MPI intra-communicator). The PET local process id within each virtual machine is equal to the MPI_Comm_rank in the local MPI_Comm context whereas the PET process id is equal to the MPI_Comm_rank in MPI_COMM_WORLD. The PET process id is used within the VM methods to determine the virtual memory space a PET is operating in. 

<P>
In order to provide a migration path for legacy MPI-applications the VM offers accessor functions to its MPI_Comm object. Once obtained this object may be used in explicit user-code MPI calls within the same context.

<P>

<P>

<H2><A NAME="SECTION060125000000000000000">
45.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION060125100000000000000">
45.5.1 ESMF_VMAssignment(=) - VM assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     vm1 = vm2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM) :: vm1
     type(ESMF_VM) :: vm2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign vm1 as an alias to the same ESMF VM object in memory
     as vm2. If vm2 is invalid, then vm1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125200000000000000">
45.5.2 ESMF_VMOperator(==) - VM equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (vm1 == vm2) then ... endif
               OR
     result = (vm1 == vm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in) :: vm1
     type(ESMF_VM), intent(in) :: vm2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether vm1 and vm2 are valid aliases to the same ESMF
     VM object in memory. For a more general comparison of two ESMF VMs,
     going beyond the simple alias test, the ESMF_VMMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125300000000000000">
45.5.3 ESMF_VMOperator(/=) - VM not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (vm1 /= vm2) then ... endif
               OR
     result = (vm1 /= vm2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in) :: vm1
     type(ESMF_VM), intent(in) :: vm2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether vm1 and vm2 are <I>not</I> valid aliases to the
     same ESMF VM object in memory. For a more general comparison of two ESMF
     VMs, going beyond the simple alias test, the ESMF_VMMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>vm1</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>vm2</STRONG></DT>
<DD>The <TT>ESMF_VM</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125400000000000000">
45.5.4 ESMF_VMAllFullReduce - Fully reduce data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllFullReduce(vm, sendData, recvData, &amp;
      count, reduceflag, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;),         intent(out)           :: recvData
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data 
     array of &lt;type&gt;&lt;kind&gt; across the <TT>ESMF_VM</TT> object 
     into a single value of the same &lt;type&gt;&lt;kind&gt;. The result is
     returned on all PETs. Different reduction operations can be specified.
     <BR>

<P>
This method is overloaded for: <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT> error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData. Must be the same on all PETs.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node2.html#const:reduce">9.35</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125500000000000000">
45.5.5 ESMF_VMAllGather - Gather data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllGather(vm, sendData, recvData, count, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data 
     from all PETs of an <TT>ESMF_VM</TT> object into an array on all PETs.
     <BR>

<P>
This method is overloaded for: 
     <BR>
     <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid <TT>recvData</TT> argument.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be gathered from each PET. Must be the
          same on all PETs.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125600000000000000">
45.5.6 ESMF_VMAllGatherV - GatherV data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllGatherV(vm, sendData, sendCount, &amp;
      recvData, recvCounts, recvOffsets, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data 
     from all PETs of an <TT>ESMF_VM</TT> object into an array on all PETs.
     <BR>

<P>
This method is overloaded for: <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>. 
     <BR>

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT> error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to all other
          PETs.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received from corresponding
          source PET.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking the start of
          element sequence to be received from source PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125700000000000000">
45.5.7 ESMF_VMAllReduce - Reduce data across VM, result on all PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllReduce(vm, sendData, recvData, count, &amp;
      reduceflag, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data 
     array across the <TT>ESMF_VM</TT> object into a contiguous data array of the
     same &lt;type&gt;&lt;kind&gt;. The result array is returned on all PETs. 
     Different reduction operations can be specified.
     <BR>

<P>
This method is overloaded for: <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>. 
     <BR>

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT> error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData and recvData. Must be the same on all
          PETs.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node2.html#const:reduce">9.35</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125800000000000000">
45.5.8 ESMF_VMAllToAllV - AllToAllV communications across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMAllToAllV(vm, sendData, sendCounts, &amp;
      sendOffsets, recvData, recvCounts, recvOffsets, syncflag, &amp;
      commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCounts(:)
      integer,                          intent(in)            :: sendOffsets(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that performs a total exchange
     operation, sending pieces of the contiguous data buffer <TT>semdData</TT> to
     all other PETs while receiving data into the contiguous data buffer
     <TT>recvData</TT> from all other PETs.
<BR>

<P>
This method is overloaded for: <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>. 
     <BR>

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT> error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCounts</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to
          destination PET.
     
</DD>
<DT><STRONG>sendOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>sendData</TT> marking to start of
          element sequence to be send from local PET to destination PET.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received by local PET from
          source PET.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking to start of
          element sequence to be received by local PET from source PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060125900000000000000">
45.5.9 ESMF_VMBarrier - VM wide barrier</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMBarrier(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),  intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,        intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that blocks calling PET until
     all PETs of the VM context have issued the call.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251000000000000000">
45.5.10 ESMF_VMBroadcast - Broadcast data across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMBroadcast(vm, bcstData, count, rootPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(inout)         :: bcstData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that broadcasts a contiguous 
     data array from <TT>rootPet</TT> to all other PETs of the <TT>ESMF_VM</TT>
     object.
     <BR>

<P>
This method is overloaded for: 
     <BR>
     <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <BR>
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>bcstData</STRONG></DT>
<DD>Contiguous data array. On <TT>rootPet</TT> <TT>bcstData</TT> holds data that
          is to be broadcasted to all other PETs. On all other PETs 
          <TT>bcstData</TT> is used to receive the broadcasted data.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData and recvData. Must be the same on all
          PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being broadcast.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251100000000000000">
45.5.11 ESMF_VMCommWait - Wait for non-blocking VM communication to complete</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMCommWait(vm, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),         intent(in)            :: vm
     type(ESMF_CommHandle), intent(in)            :: commhandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,               intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Wait for non-blocking VM communication specified by the <TT>commhandle</TT> to
     complete.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>commhandle</STRONG></DT>
<DD>Handle specifying a previously issued non-blocking communication 
          request.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251200000000000000">
45.5.12 ESMF_VMCommWaitAll - Wait for all non-blocking VM comms to complete</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMCommWaitAll(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Wait for <EM>all</EM> pending non-blocking VM communication within the 
     specified VM context to complete.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251300000000000000">
45.5.13 ESMF_VMGather - Gather data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMGather(vm, sendData, recvData, count, rootPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data 
     from all PETs of an <TT>ESMF_VM</TT> object (including <TT>rootPet</TT>) into an
     array on <TT>rootPet</TT>.
     <BR>

<P>
This method is overloaded for: 
     <BR>
     <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>, 
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. Only the <TT>recvData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be send from each PET to <TT>rootPet</TT>. Must be
          the same on all PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which data is gathereds.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251400000000000000">
45.5.14 ESMF_VMGatherV - GatherV data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMGatherV(vm, sendData, sendCount, recvData, &amp;
      recvCounts, recvOffsets, rootPet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCount
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCounts(:)
      integer,                          intent(in)            :: recvOffsets(:)
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that gathers contiguous data 
     from all PETs of an <TT>ESMF_VM</TT> object into an array on rootPet.
     <BR>

<P>
This method is overloaded for: <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT> error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to send from local PET to all other
          PETs.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>recvCounts</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to be received from corresponding
          source PET.
     
</DD>
<DT><STRONG>recvOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>recvData</TT> marking the start of
          element sequence to be received from source PET.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which data is gathered.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251500000000000000">
45.5.15 ESMF_VMGet - Get VM internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_VMGet()
   subroutine ESMF_VMGetDefault(vm, localPet, petCount, &amp;
     peCount, mpiCommunicator, pthreadsEnabledFlag, openMPEnabledFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),      intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: localPet
     integer,            intent(out), optional :: petCount
     integer,            intent(out), optional :: peCount
     integer,            intent(out), optional :: mpiCommunicator
     logical,            intent(out), optional :: pthreadsEnabledFlag
     logical,            intent(out), optional :: openMPEnabledFlag
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal information about the specified <TT>ESMF_VM</TT> object.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Queried <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[localPet]</STRONG></DT>
<DD>Upon return this holds the id of the PET that issued this call.
     
</DD>
<DT><STRONG>[petCount]</STRONG></DT>
<DD>Upon return this holds the number of PETs in the specified 
          <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[peCount]</STRONG></DT>
<DD>Upon return this holds the number of PEs referenced by the specified
          <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[mpiCommunicator]</STRONG></DT>
<DD>Upon return this holds the MPI intra-communicator used by the 
          specified <TT>ESMF_VM</TT> object. This communicator may be used for
          user-level MPI communications. It is recommended that the user
          duplicates the communicator via <TT>MPI_Comm_Dup()</TT> in order to
          prevent any interference with ESMF communications.
     
</DD>
<DT><STRONG>[pthreadsEnabledFlag]</STRONG></DT>
<DD><DL>
<DT><STRONG><TT>.TRUE.</TT></STRONG></DT>
<DD>ESMF has been compiled with Pthreads.
          
</DD>
<DT><STRONG><TT>.FALSE.</TT></STRONG></DT>
<DD>ESMF has not been compiled with Pthreads.
          
</DD>
</DL>
     
</DD>
<DT><STRONG>[openMPEnabledFlag]</STRONG></DT>
<DD><DL>
<DT><STRONG><TT>.TRUE.</TT></STRONG></DT>
<DD>ESMF has been compiled with OpenMP.
          
</DD>
<DT><STRONG><TT>.FALSE.</TT></STRONG></DT>
<DD>ESMF has not been compiled with OpenMP.
          
</DD>
</DL>
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251600000000000000">
45.5.16 ESMF_VMGet - Get VM PET local internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_VMGet()
   subroutine ESMF_VMGetPetLocalInfo(vm, pet, peCount, ssiId, &amp;
     threadCount, threadId, vas, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
     integer,       intent(in)            :: pet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: peCount
     integer,       intent(out), optional :: ssiId
     integer,       intent(out), optional :: threadCount
     integer,       intent(out), optional :: threadId
     integer,       intent(out), optional :: vas
     integer,       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal information about a specific PET within an <TT>ESMF_VM</TT> 
     object.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Queried <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>pet</STRONG></DT>
<DD>Queried PET id within the specified <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[peCount]</STRONG></DT>
<DD>Upon return this holds the number of PEs associated with the specified
          PET in the <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[ssiId]</STRONG></DT>
<DD>Upon return this holds the id of the single-system image (SSI) the
          specified PET is running on.
     
</DD>
<DT><STRONG>[threadCount]</STRONG></DT>
<DD>Upon return this holds the number of PETs in the specified PET"s 
          thread group.
     
</DD>
<DT><STRONG>[threadId]</STRONG></DT>
<DD>Upon return this holds the thread id of the specified PET within the 
          PET"s thread group.
     
</DD>
<DT><STRONG>[vas]</STRONG></DT>
<DD>Virtual address space in which this PET operates.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251700000000000000">
45.5.17 ESMF_VMGetGlobal - Get Global VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMGetGlobal(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(out)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get the global <TT>ESMF_VM</TT> object. This is the VM object
     that is created during <TT>ESMF_Initialize()</TT> and is the ultimate
     parent of all VM objects in an ESMF application. It is identical to the VM
     object returned by <TT>ESMF_Initialize(..., vm=vm, ...)</TT>.

<P>
The <TT>ESMF_VMGetGlobal()</TT> call provides access to information about the
     global execution context via the global VM. This call is necessary because
     ESMF does not created a global ESMF Component during
     <TT>ESMF_Initialize()</TT> that could be queried for information about
     the global execution context of an ESMF application.

<P>
Usage of <TT>ESMF_VMGetGlobal()</TT> from within Component code is
     strongly discouraged. ESMF Components should only access their own VM
     objects through Component methods. Global information, if required by
     the Component user code, should be passed down to the Component from the 
     driver through the Component calling interface.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Upon return this holds the <TT>ESMF_VM</TT> object of the global execution 
       context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251800000000000000">
45.5.18 ESMF_VMGetCurrent - Get Current VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMGetCurrent(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(out)           :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get the <TT>ESMF_VM</TT> object of the current execution context. Calling
     <TT>ESMF_VMGetCurrent()</TT> within an ESMF Component, will return the
     same VM object as
     <TT>ESMF_GridCompGet(..., vm=vm, ...)</TT> or
     <TT>ESMF_CplCompGet(..., vm=vm, ...)</TT>.

<P>
The main purpose of providing <TT>ESMF_VMGetCurrent()</TT> is to simplify ESMF
     adoption in legacy code. Specifically, code that uses <TT>MPI_COMM_WORLD</TT>
     deep within its calling tree can easily be modified to use the correct MPI
     communicator of the current ESMF execution context. The advantage is that
     these modifications are very local, and do not require wide reaching
     interface changes in the legacy code to pass down the ESMF component object,
     or the MPI communicator.

<P>
The use of <TT>ESMF_VMGetCurrent()</TT> is strongly discouraged in newly
     written Component code. Instead, the ESMF Component object should be used as
     the appropriate container of ESMF context information. This object should be
     passed between the subroutines of a Component, and be queried for any
     Component specific information.

<P>
Outside of a Component context, i.e. within the driver context, the call
     to <TT>ESMF_VMGetCurrent()</TT> is identical to <TT>ESMF_VMGetGlobal()</TT>.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Upon return this holds the <TT>ESMF_VM</TT> object of the current execution
       context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601251900000000000000">
45.5.19 ESMF_VMPrint - Print VM internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMPrint(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM),  intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,        intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information about the specified <TT>ESMF_VM</TT> to
     <TT>stdout</TT>.
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Specified <TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252000000000000000">
45.5.20 ESMF_VMRecv - Receive data from srcPet</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMRecv(vm, recvData, count, srcPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                 intent(in)            :: vm
      integer(ESMF_KIND_I4), target, intent(out)           :: recvData(:)  
      integer,                       intent(in)            :: count
      integer,                       intent(in)            :: srcPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),          intent(in),  optional :: syncflag
      type(ESMF_CommHandle),         intent(out), optional :: commhandle
      integer,                       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Receive contiguous data from <TT>srcPet</TT> within the same <TT>ESMF_VM</TT> 
     object.
     <BR>

<P>
This method is overloaded for: 
     <BR>
     <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>,
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <BR>
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be received.
     
</DD>
<DT><STRONG>srcPet</STRONG></DT>
<DD>Sending PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252100000000000000">
45.5.21 ESMF_VMReduce - Reduce data from across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMReduce(vm, sendData, recvData, count, &amp;
      reduceflag, rootPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      type(ESMF_Reduce_Flag),           intent(in)            :: reduceflag
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that reduces a contiguous data 
     array across the <TT>ESMF_VM</TT> object into a contiguous data array of 
     the same &lt;type&gt;&lt;kind&gt;. The result array is returned on <TT>rootPet</TT>. 
     Different reduction operations can be specified.
     <BR>

<P>
This method is overloaded for: <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
T<SMALL>ODO:</SMALL> The current version of this method does not provide an 
     implementation of the <EM>non-blocking</EM> feature. When calling this 
     method with <TT>syncflag = ESMF_SYNC_NONBLOCKING</TT> error code 
     <TT>ESMF_RC_NOT_IMPL</TT> will be returned and an error will be 
     logged.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. All PETs must specify a
          valid source array.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements in sendData and recvData. Must be the same on all
          PETs.
     
</DD>
<DT><STRONG>reduceflag</STRONG></DT>
<DD>Reduction operation. See section <A HREF="node2.html#const:reduce">9.35</A> for a list of 
          valid reduce operations.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET on which reduced data is returned.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252200000000000000">
45.5.22 ESMF_VMScatter - Scatter data across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMScatter(vm, sendData, recvData, count, &amp;
      rootPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that scatters contiguous data 
     from the <TT>rootPet</TT> to all PETs across the <TT>ESMF_VM</TT> object
     (including <TT>rootPet</TT>).
     <BR>

<P>
This method is overloaded for: 
     <BR>
     <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>,
     <TT>ESMF_TYPEKIND_LOGICAL</TT>.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. Only the <TT>sendData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received. All PETs must specify a
          valid destination array.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be send from <TT>rootPet</TT> to each of the PETs.
          Must be the same on all PETs.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being scattered.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252300000000000000">
45.5.23 ESMF_VMScatterV - ScatterV across VM</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMScatterV(vm, sendData, sendCounts, &amp;
      sendOffsets, recvData, recvCount, rootPet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)
      integer,                          intent(in)            :: sendCounts(:)
      integer,                          intent(in)            :: sendOffsets(:)
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)
      integer,                          intent(in)            :: recvCount
      integer,                          intent(in)            :: rootPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Collective <TT>ESMF_VM</TT> communication call that scatters contiguous data 
     from the <TT>rootPet</TT> to all PETs across the <TT>ESMF_VM</TT> object
     (including <TT>rootPet</TT>).
     <BR>

<P>
This method is overloaded for: <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send. Only the <TT>sendData</TT>
          array specified by the <TT>rootPet</TT> will be used by this method.
     
</DD>
<DT><STRONG>sendCounts</STRONG></DT>
<DD>Number of <TT>sendData</TT> elements to be send to corresponding
          receive PET.
     
</DD>
<DT><STRONG>sendOffsets</STRONG></DT>
<DD>Offsets in units of elements in <TT>sendData</TT> marking the start of
          element sequence to be send to receive PET.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Single data variable to be received. All PETs must specify a
          valid result variable.
     
</DD>
<DT><STRONG>recvCount</STRONG></DT>
<DD>Number of <TT>recvData</TT> elements to receive by local PET from
          <TT>rootPet</TT>.
     
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds data that is being scattered.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252400000000000000">
45.5.24 ESMF_VMSend - Send data to dstPet</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMSend(vm, sendData, count, dstPet, &amp;
      syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)  
      integer,                          intent(in)            :: count
      integer,                          intent(in)            :: dstPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Send contiguous data to <TT>dstPet</TT> within the same <TT>ESMF_VM</TT> object.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send.
     
</DD>
<DT><STRONG>count</STRONG></DT>
<DD>Number of elements to be send.
     
</DD>
<DT><STRONG>dstPet</STRONG></DT>
<DD>Receiving PET.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252500000000000000">
45.5.25 ESMF_VMSendRecv - Send and Recv data to and from PETs</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>    subroutine ESMF_VMSendRecv(vm, sendData, sendCount, dstPet, &amp;
      recvData, recvCount, srcPet, syncflag, commhandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_VM),                    intent(in)            :: vm
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)            :: sendData(:)  
      integer,                          intent(in)            :: sendCount
      integer,                          intent(in)            :: dstPet
      &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(out)           :: recvData(:)  
      integer,                          intent(in)            :: recvCount
      integer,                          intent(in)            :: srcPet
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
      type(ESMF_Sync_Flag),             intent(in),  optional :: syncflag
      type(ESMF_CommHandle),            intent(out), optional :: commhandle
      integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Send contiguous data to <TT>dstPet</TT> within the same <TT>ESMF_VM</TT> object
     while receiving contiguous data from <TT>srcPet</TT> within the same 
     <TT>ESMF_VM</TT> object. The <TT>sendData</TT> and <TT>recvData</TT> arrays must be
     disjoint!
<BR>

<P>
This method is overloaded for: 
     <BR>
     <TT>ESMF_TYPEKIND_I4</TT>,
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>,
     <TT>ESMF_TYPEKIND_LOGICAL</TT>, 
     <BR>
     <TT>ESMF_TYPEKIND_CHARACTER</TT>.
     <BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>vm</STRONG></DT>
<DD><TT>ESMF_VM</TT> object.
     
</DD>
<DT><STRONG>sendData</STRONG></DT>
<DD>Contiguous data array holding data to be send.
     
</DD>
<DT><STRONG>sendCount</STRONG></DT>
<DD>Number of elements to be send.
     
</DD>
<DT><STRONG>dstPet</STRONG></DT>
<DD>PET that holds <TT>recvData</TT>.
     
</DD>
<DT><STRONG>recvData</STRONG></DT>
<DD>Contiguous data array for data to be received.
     
</DD>
<DT><STRONG>recvCount</STRONG></DT>
<DD>Number of elements to be received.
     
</DD>
<DT><STRONG>srcPet</STRONG></DT>
<DD>PET that holds <TT>sendData</TT>.
     
</DD>
<DT><STRONG>[syncflag]</STRONG></DT>
<DD>Flag indicating whether this call behaves blocking or non-blocking.
          The default is <TT>ESMF_SYNC_BLOCKING</TT>. See section
          <A HREF="node2.html#const:sync">9.44</A> for a complete list of options.
     
</DD>
<DT><STRONG>[commhandle]</STRONG></DT>
<DD>If present, a communication handle will be returned in case of a 
          non-blocking request (see argument <TT>syncflag</TT>). The
          <TT>commhandle</TT> can be used in <TT>ESMF_VMCommWait()</TT> to block the
          calling PET until the communication call has finished PET-locally. If
          no <TT>commhandle</TT> was supplied to a non-blocking call the VM method
          <TT>ESMF_VMCommWaitAll()</TT> may be used to block on all currently queued
          communication calls of the VM context.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252600000000000000">
45.5.26 ESMF_VMValidate - Validate VM internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMValidate(vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_VM), intent(in)            :: vm
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>vm</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>vm</STRONG></DT>
<DD>Specified <TT>ESMF_VM</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252700000000000000">
45.5.27 ESMF_VMWtime - Get floating-point number of seconds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMWtime(time, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(out)           :: time
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get floating-point number of seconds of elapsed wall-clock time since some
     time in the past.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>time</STRONG></DT>
<DD>Time in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252800000000000000">
45.5.28 ESMF_VMWtimeDelay - Delay execution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMWtimeDelay(delay, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(in)            :: delay
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Delay execution for amount of seconds.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>delay</STRONG></DT>
<DD>Delay time in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0601252900000000000000">
45.5.29 ESMF_VMWtimePrec - Timer precision as floating-point number of seconds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_VMWtimePrec(prec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(out)           :: prec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get a run-time estimate of the timer precision as floating-point number 
     of seconds. This is a relatively expensive call since the timer precision
     is measured several times before the maximum is returned as the estimate.
     The returned value is PET-specific and may differ across the VM 
     context.
<BR>

<P>
The arguments are:
     <DL>
<DT><STRONG>prec</STRONG></DT>
<DD>Timer precision in seconds.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION060130000000000000000">
46 Fortran I/O and System Utilities</A>
</H1>

<P>

<H2><A NAME="SECTION060131000000000000000">
46.1 Description</A>
</H2>

<P>
<A NAME="sec:IOUtil"></A>
<P>
The ESMF Fortran I/O utilities provide portable methods to access
capabilities which are often implemented in different
ways amongst different environments.  Currently, two utility
methods are implemented: <TT>ESMF_IOUnitGet()</TT>, to find an unopened
unit number within the range of unit numbers that ESMF
is allowed to use, and <TT>ESMF_IOUnitFlush()</TT> to flush the
I/O buffer associated with a specific Fortran unit.


<P>

<H2><A NAME="SECTION060132000000000000000">
46.2 Use and Examples</A>
</H2>

<P>

<H3><A NAME="SECTION060132100000000000000"></A> <A NAME="fio:unitnumbers"></A>
<BR>
46.2.1 Fortran unit number management
</H3>
The <TT>ESMF_UtilIOUnitGet()</TT> method is provided so that applications
using ESMF can remain free of unit number conflicts -- both when combined
with other third party code, or with ESMF itself.  This call is typically
used just prior to an <TT>OPEN</TT> statement:

<P>
<PRE>
  call ESMF_UtilIOUnitGet (unit=grid_unit, rc=rc)
  open (unit=grid_unit, file='grid_data.dat', status='old', action='read')
</PRE>

<P>
By default, unit numbers between 50 and 99 are scanned to find an unopened
unit number.

<P>
Internally, ESMF also uses <TT>ESMF_UtilIOUnitGet()</TT> when it needs to open
Fortran unit numbers for file I/O.  By using the same API for both user and
ESMF code, unit number collisions can be avoided.

<P>
When integrating ESMF into an application where there are conflicts with
other uses of the same unit number range, such as when hard-coded unit number
values are used, an alternative unit number range can be specified.
The <TT>ESMF_Initialize()</TT> optional arguments <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT>
may be set as needed.  Note that <TT>IOUnitUpper</TT> must be set to a value higher than
<TT>IOUnitLower</TT>, and that both must be non-negative.  Otherwise <TT>ESMF_Initialize</TT>
will return a return code of <TT>ESMF_FAILURE</TT>.  ESMF itself does not typically need more
than about five units for internal use.

<P>
<PRE>
  call ESMF_Initialize (..., IOUnitLower=120, IOUnitUpper=140)
</PRE>

<P>
All current Fortran environments have preconnected unit numbers, such as
units 5 and 6 for standard input and output, in the single digit range.
So it is recommended that the unit number range is chosen to begin at unit 10
or higher to avoid these preconnected units.

<P>

<H3><A NAME="SECTION060132200000000000000">
46.2.2 Flushing output</A>
</H3>

<P>
Fortran run-time libraries generally use buffering techniques to improve I/O
performance.  However output buffering can be problematic when output is needed,
but is ``trapped'' in the buffer because it is not full.
This is a common occurance when debugging a program, and inserting <TT>WRITE</TT> statements
to track down the bad area of code.  If the program crashes before the output
buffer has been flushed, the desired debugging output may never be seen -- giving
a misleading indication of where the problem occurred.  It would be desirable
to ensure that the output buffer is flushed at predictable
points in the program in order to get the needed results.
Likewise, in parallel code, predictable flushing of output buffers is a common
requirement, often in conjunction with <TT>ESMF_VMBarrier()</TT> calls.  

<P>
The <TT>ESMF_UtilIOUnitFlush()</TT> API is provided to flush a unit as desired.  Here is
an example of code which prints debug values, and serializes the output to a
terminal in PET order:

<P>
<PRE>
  type(ESMF_VM) :: vm

  integer :: tty_unit
  integer :: me, npets

  call ESMF_Initialize (vm=vm, rc=rc)
  call ESMF_VMGet (vm, localPet=me, petCount=npes)

  call ESMF_UtilIOUnitGet (unit=tty_unit)
  open (unit=tty_unit, file='/dev/tty', status='old', action='write')
  ...
  call ESMF_VMBarrier (vm=vm)
  do, i=0, npets-1
    if (i == me) then
      write (tty_unit, *) 'PET: ', i, ', values are: ', a, b, c
      call ESMF_UtilIOUnitFlush (unit=tty_unit)
    end if
    call ESMF_VMBarrier (vm=vm)
  end do
</PRE>

<P>

<H2><A NAME="SECTION060133000000000000000">
46.3 Design and Implementation Notes</A>
</H2>

<P>

<H3><A NAME="SECTION060133100000000000000">
46.3.1 Fortran unit number management</A>
</H3>

<P>
When ESMF needs to open a Fortran I/O unit, it calls <TT>ESMF_IOUnitGet()</TT> to find
an unopened unit number.  As delivered, the range of unit numbers that are
searched are between <TT>ESMF_LOG_FORTRAN_UNIT_NUMBER</TT> (normally set to
50), and <TT>ESMF_LOG_UPPER</TT> (normally set to 99.)
Unopened unit numbers are found by using the Fortran <TT>INQUIRE</TT> statement.

<P>
When integrating ESMF into an application where there are conflicts with
other uses of the same unit number range, an alternative range can be specified
in the <TT>ESMF_Initialize()</TT> call by setting the <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT>
arguments as needed.  <TT>ESMF_IOUnitGet()</TT> will then search the alternate range
of unit numbers.  Note that <TT>IOUnitUpper</TT> must be set to a value higher than
<TT>IOUnitLower</TT>, and that both must be non-negative.  Otherwise <TT>ESMF_Initialize</TT>
will return a return code of <TT>ESMF_FAILURE</TT>.

<P>
Fortran unit numbers are not standardized in the Fortran 90 Standard.  The standard
only requires that they be non-negative integers.  But other than that, it is
up to the compiler writers and application developers to provide and
use units which work with the particular implementation.  For example,
units 5 and 6 are a defacto standard for ``standard input'' and
``standard output'' -- even though this is not specified in the actual Fortran
standard.  The Fortran standard also does not specifiy which unit numbers can
be used, nor does it specify how many can be open simultaneously.

<P>
Since all current compilers have preconnected unit numbers, and these are
typically found on units lower than 10, it is recommended that applications
use unit numbers 10 and higher.

<P>

<H3><A NAME="SECTION060133200000000000000">
46.3.2 Flushing output</A>
</H3>

<P>
When ESMF needs to flush a Fortran unit, the <TT>ESMF_IOUnitFlush()</TT> API is used
to centralize the file flushing capability, because Fortran has not historically
had a standard mechanism for flushing output buffers.  Most compilers run-time libraries
support various library extensions to provide this functionality -- though,
being non-standard, the spelling and number of arguments vary between implementations.
Fortran 2003 also provides for a <TT>FLUSH</TT> statement which is built into the
language.  When possible, <TT>ESMF_IOUnitFlush()</TT> uses the F2003 <TT>FLUSH</TT> statement.
With older compilers, the appropriate library call is made.

<P>

<H2><A NAME="SECTION060134000000000000000">
46.4 Utility API</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060134100000000000000">
46.4.1 ESMF_UtilGetArg - Return a command line argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArg(argindex, argvalue, arglength, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,      intent(in)            :: argindex
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*), intent(out), optional :: argvalue
     integer,      intent(out), optional :: arglength
     integer,      intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method returns a copy of a command line argument specified
   when the process was started.  This argument is the same as an
   equivalent C++ program would find in the argv array.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>argindex</STRONG></DT>
<DD>A non-negative index into the command line argument <TT>argv</TT> array.
   If argindex is negative or greater than the number of user-specified
   arguments, <TT>ESMF_RC_ARG_VALUE</TT> is returned in the <TT>rc</TT> argument.
   
</DD>
<DT><STRONG>[argvalue]</STRONG></DT>
<DD>Returns a copy of the desired command line argument.  If the provided
   character string is longer than the command line argument, the string
   will be blank padded.  If the string is too short, truncation will
   occur and <TT>ESMF_RC_ARG_SIZE</TT> is returned in the <TT>rc</TT> argument.
   
</DD>
<DT><STRONG>[arglength]</STRONG></DT>
<DD>Returns the length of the desired command line argument in characters.
   The length result does not depend on the length of the <TT>value</TT>
   string.  It may be used to query the length of the argument.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060134200000000000000">
46.4.2 ESMF_UtilGetArgC - Return number of command line arguments</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArgC(count, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(out)           :: count
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method returns the number of command line arguments specified
   when the process was started.

<P>
The number of arguments returned does not include the name of the
   command itself - which is typically returned as argument zero.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>count</STRONG></DT>
<DD>Count of command line arguments.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION060134300000000000000">
46.4.3 ESMF_UtilGetArgIndex - Return the index of a command line argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilGetArgIndex(argvalue, argindex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*), intent(in)            :: argvalue
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,      intent(out), optional :: argindex
     integer,      intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method searches for, and returns the index of a desired command
   line argument.  An example might be to find a specific keyword
   (e.g., -esmf_path) so that its associated value argument could be
   obtained by adding 1 to the argindex and calling <TT>ESMF_UtilGetArg()</TT>.

<P>
Some MPI implementations do not consistently provide command line
   arguments on PETs other than PET 0.  It is therefore recommended
   that PET 0 call this method and broadcast the results to the other
   PETs by using the <TT>ESMF_VMBroadcast()</TT> method.

<P>
The arguments are:

<P>
<DL>
<DT><STRONG>argvalue</STRONG></DT>
<DD>A character string which will be searched for in the command line
   argument list.
   
</DD>
<DT><STRONG>[argindex]</STRONG></DT>
<DD>If the <TT>value</TT> string is found, the position will be returned
   as a non-negative integer.  If the string is not found, a negative
   value will be returned.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION060134400000000000000">
46.4.4 ESMF_UtilIOUnitFlush - Flush output on a unit number</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilIOUnitFlush(unit, rc)
</PRE><EM>PARAMETERS:</EM>
<PRE>     integer, intent(in)            :: unit
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Call the system-dependent routine to force output on a specific
     Fortran unit number.

<P>
The arguments are:
       <DL>
<DT><STRONG>unit</STRONG></DT>
<DD>A Fortran I/O unit number.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION060134500000000000000">
46.4.5 ESMF_UtilIOUnitGet - Scan for a free I/O unit number</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_UtilIOUnitGet(unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(out)           :: unit
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Scan for, and return, a free Fortran I/O unit number.
     By default, the range of unit numbers returned is between 50 and 99
     (parameters <TT>ESMF_LOG_FORTRAN_UNIT_NUMBER</TT> and <TT>ESMF_LOG_UPPER</TT>
     respectively.) When integrating ESMF into an application where these values
     conflict with other usages, the range of values may be moved by setting the
     optional <TT>IOUnitLower</TT> and <TT>IOUnitUpper</TT> arguments in the initial
     <TT>ESMF_Initialize()</TT> call with values in a safe, alternate, range.

<P>
The Fortran unit number which is returned is not reserved in any way.
     Successive calls without intervening <TT>OPEN</TT> or <TT>CLOSE</TT> statements
     (or other means of connecting to units), might not return a unique unit
     number.  It is recommended that an <TT>OPEN</TT> statement immediately follow
     the call to <TT>ESMF_IOUnitGet()</TT> to activate the unit.

<P>
The arguments are:
       <DL>
<DT><STRONG>unit</STRONG></DT>
<DD>A Fortran I/O unit number.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html2287"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html2283"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html2277"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html2285"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html2288"
  HREF="node7.html">6 References</A>
<B> Up:</B> <A NAME="tex2html2284"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html2278"
  HREF="node5.html">4 Infrastructure: Fields and</A>
 &nbsp <B>  <A NAME="tex2html2286"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
