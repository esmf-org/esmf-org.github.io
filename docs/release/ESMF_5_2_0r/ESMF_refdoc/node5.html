<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>4 Infrastructure: Fields and Grids</TITLE>
<META NAME="description" CONTENT="4 Infrastructure: Fields and Grids">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node6.html">
<LINK REL="previous" HREF="node4.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node6.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html1768"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1764"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1758"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1766"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1769"
  HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html1765"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1759"
  HREF="node4.html">3 Superstructure</A>
 &nbsp <B>  <A NAME="tex2html1767"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html1770"
  HREF="node5.html#SECTION05010000000000000000">20 Overview of Infrastructure Data Handling</A>
<UL>
<LI><A NAME="tex2html1771"
  HREF="node5.html#SECTION05011000000000000000">20.1 Infrastructure Data Classes</A>
<LI><A NAME="tex2html1772"
  HREF="node5.html#SECTION05012000000000000000">20.2 Design and Implementation Notes</A>
</UL>
<LI><A NAME="tex2html1773"
  HREF="node5.html#SECTION05020000000000000000">21 FieldBundle Class</A>
<UL>
<LI><A NAME="tex2html1774"
  HREF="node5.html#SECTION05021000000000000000">21.1 Description</A>
<LI><A NAME="tex2html1775"
  HREF="node5.html#SECTION05022000000000000000">21.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1776"
  HREF="node5.html#SECTION05022100000000000000">21.2.1 Create a FieldBundle</A>
<LI><A NAME="tex2html1777"
  HREF="node5.html#SECTION05022200000000000000">21.2.2 Access FieldBundle data</A>
<LI><A NAME="tex2html1778"
  HREF="node5.html#SECTION05022300000000000000">21.2.3 Destroy a FieldBundle</A>
<LI><A NAME="tex2html1779"
  HREF="node5.html#SECTION05022400000000000000">21.2.4 Redistribute data from a source FieldBundle to a destination FieldBundle</A>
<LI><A NAME="tex2html1780"
  HREF="node5.html#SECTION05022500000000000000">21.2.5 Perform sparse matrix multiplication from a source FieldBundle 
    to a destination FieldBundle</A>
<LI><A NAME="tex2html1781"
  HREF="node5.html#SECTION05022600000000000000">21.2.6 Perform FieldBundle halo update</A>
</UL>
<LI><A NAME="tex2html1782"
  HREF="node5.html#SECTION05023000000000000000">21.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1783"
  HREF="node5.html#SECTION05024000000000000000">21.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1784"
  HREF="node5.html#SECTION05025000000000000000">21.5 Class API: Basic FieldBundle Methods</A>
<UL>
<LI><A NAME="tex2html1785"
  HREF="node5.html#SECTION05025100000000000000">21.5.1 ESMF_FieldBundleAssignment(=)</A>
<LI><A NAME="tex2html1786"
  HREF="node5.html#SECTION05025200000000000000">21.5.2 ESMF_FieldBundleOperator(==)</A>
<LI><A NAME="tex2html1787"
  HREF="node5.html#SECTION05025300000000000000">21.5.3 ESMF_FieldBundleOperator(/=)</A>
<LI><A NAME="tex2html1788"
  HREF="node5.html#SECTION05025400000000000000">21.5.4 ESMF_FieldBundleAdd</A>
<LI><A NAME="tex2html1789"
  HREF="node5.html#SECTION05025500000000000000">21.5.5 ESMF_FieldBundleAddReplace</A>
<LI><A NAME="tex2html1790"
  HREF="node5.html#SECTION05025600000000000000">21.5.6 ESMF_FieldBundleCreate</A>
<LI><A NAME="tex2html1791"
  HREF="node5.html#SECTION05025700000000000000">21.5.7 ESMF_FieldBundleDestroy</A>
<LI><A NAME="tex2html1792"
  HREF="node5.html#SECTION05025800000000000000">21.5.8 ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html1793"
  HREF="node5.html#SECTION05025900000000000000">21.5.9 ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html1794"
  HREF="node5.html#SECTION050251000000000000000">21.5.10 ESMF_FieldBundleGet</A>
<LI><A NAME="tex2html1795"
  HREF="node5.html#SECTION050251100000000000000">21.5.11 ESMF_FieldBundleHalo</A>
<LI><A NAME="tex2html1796"
  HREF="node5.html#SECTION050251200000000000000">21.5.12 ESMF_FieldBundleHaloRelease</A>
<LI><A NAME="tex2html1797"
  HREF="node5.html#SECTION050251300000000000000">21.5.13 ESMF_FieldBundleHaloStore</A>
<LI><A NAME="tex2html1798"
  HREF="node5.html#SECTION050251400000000000000">21.5.14 ESMF_FieldBundlePrint</A>
<LI><A NAME="tex2html1799"
  HREF="node5.html#SECTION050251500000000000000">21.5.15 ESMF_FieldBundleRead</A>
<LI><A NAME="tex2html1800"
  HREF="node5.html#SECTION050251600000000000000">21.5.16 ESMF_FieldBundleRedist</A>
<LI><A NAME="tex2html1801"
  HREF="node5.html#SECTION050251700000000000000">21.5.17 ESMF_FieldBundleRedistRelease</A>
<LI><A NAME="tex2html1802"
  HREF="node5.html#SECTION050251800000000000000">21.5.18 ESMF_FieldBundleRedistStore</A>
<LI><A NAME="tex2html1803"
  HREF="node5.html#SECTION050251900000000000000">21.5.19 ESMF_FieldBundleRedistStore</A>
<LI><A NAME="tex2html1804"
  HREF="node5.html#SECTION050252000000000000000">21.5.20 ESMF_FieldBundleRegrid</A>
<LI><A NAME="tex2html1805"
  HREF="node5.html#SECTION050252100000000000000">21.5.21 ESMF_FieldBundleRegridRelease</A>
<LI><A NAME="tex2html1806"
  HREF="node5.html#SECTION050252200000000000000">21.5.22 ESMF_FieldBundleRegridStore</A>
<LI><A NAME="tex2html1807"
  HREF="node5.html#SECTION050252300000000000000">21.5.23 ESMF_FieldBundleRemove</A>
<LI><A NAME="tex2html1808"
  HREF="node5.html#SECTION050252400000000000000">21.5.24 ESMF_FieldBundleReplace</A>
<LI><A NAME="tex2html1809"
  HREF="node5.html#SECTION050252500000000000000">21.5.25 ESMF_FieldBundleSMM</A>
<LI><A NAME="tex2html1810"
  HREF="node5.html#SECTION050252600000000000000">21.5.26 ESMF_FieldBundleSMMRelease</A>
<LI><A NAME="tex2html1811"
  HREF="node5.html#SECTION050252700000000000000">21.5.27 ESMF_FieldBundleSMMStore</A>
<LI><A NAME="tex2html1812"
  HREF="node5.html#SECTION050252800000000000000">21.5.28 ESMF_FieldBundleSMMStore</A>
<LI><A NAME="tex2html1813"
  HREF="node5.html#SECTION050252900000000000000">21.5.29 ESMF_FieldBundleValidate</A>
<LI><A NAME="tex2html1814"
  HREF="node5.html#SECTION050253000000000000000">21.5.30 ESMF_FieldBundleWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html1815"
  HREF="node5.html#SECTION05030000000000000000">22 Field Class</A>
<UL>
<LI><A NAME="tex2html1816"
  HREF="node5.html#SECTION05031000000000000000">22.1 Description</A>
<LI><A NAME="tex2html1817"
  HREF="node5.html#SECTION05032000000000000000">22.2 Constants</A>
<UL>
<LI><A NAME="tex2html1818"
  HREF="node5.html#SECTION05032100000000000000">22.2.1 ESMF_FIELDSTATUS</A>
<LI><A NAME="tex2html1819"
  HREF="node5.html#SECTION05032200000000000000">22.2.2 ESMF_POLEMETHOD</A>
<LI><A NAME="tex2html1820"
  HREF="node5.html#SECTION05032300000000000000">22.2.3 ESMF_REGRIDMETHOD</A>
</UL>
<LI><A NAME="tex2html1821"
  HREF="node5.html#SECTION05033000000000000000">22.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1822"
  HREF="node5.html#SECTION05033100000000000000">22.3.1 Field create and destroy</A>
<LI><A NAME="tex2html1823"
  HREF="node5.html#SECTION05033200000000000000">22.3.2 Get Fortran data pointer, bounds, and counts information from a Field</A>
<LI><A NAME="tex2html1824"
  HREF="node5.html#SECTION05033300000000000000">22.3.3 Get Grid, Array, and other information from a Field</A>
<LI><A NAME="tex2html1825"
  HREF="node5.html#SECTION05033400000000000000">22.3.4 Create a Field with a Grid, typekind, and rank</A>
<LI><A NAME="tex2html1826"
  HREF="node5.html#SECTION05033500000000000000">22.3.5 Create a Field with a Grid and Arrayspec</A>
<LI><A NAME="tex2html1827"
  HREF="node5.html#SECTION05033600000000000000">22.3.6 Create a Field with a Grid and Array</A>
<LI><A NAME="tex2html1828"
  HREF="node5.html#SECTION05033700000000000000">22.3.7 Create an empty Field and complete it
   with FieldEmptySet and FieldEmptyComplete</A>
<LI><A NAME="tex2html1829"
  HREF="node5.html#SECTION05033800000000000000">22.3.8 Create an empty Field and complete it with FieldEmptyComplete</A>
<LI><A NAME="tex2html1830"
  HREF="node5.html#SECTION05033900000000000000">22.3.9 Create a 7D Field with a 5D Grid and 2D ungridded bounds
   from a Fortran data array</A>
<LI><A NAME="tex2html1831"
  HREF="node5.html#SECTION050331000000000000000">22.3.10 Create a 2D Field with a 2D Grid and a Fortran data array</A>
<LI><A NAME="tex2html1832"
  HREF="node5.html#SECTION050331100000000000000">22.3.11 Create a 2D Field with a 2D Grid and a Fortran data pointer</A>
<LI><A NAME="tex2html1833"
  HREF="node5.html#SECTION050331200000000000000">22.3.12 Create a 3D Field with a 2D Grid and a 3D Fortran data array</A>
<LI><A NAME="tex2html1834"
  HREF="node5.html#SECTION050331300000000000000">22.3.13 Create a 3D Field with a 2D Grid and a 3D Fortran data array with gridToFieldMap argument</A>
<LI><A NAME="tex2html1835"
  HREF="node5.html#SECTION050331400000000000000">22.3.14 Create a 3D Field with a 2D Grid and a 3D Fortran data array with halos</A>
<LI><A NAME="tex2html1836"
  HREF="node5.html#SECTION050331500000000000000">22.3.15 Create a Field from a LocStream, typekind, and rank</A>
<LI><A NAME="tex2html1837"
  HREF="node5.html#SECTION050331600000000000000">22.3.16 Create a Field from a LocStream and arrayspec</A>
<LI><A NAME="tex2html1838"
  HREF="node5.html#SECTION050331700000000000000">22.3.17 Create a Field from a Mesh, typekind, and rank</A>
<LI><A NAME="tex2html1839"
  HREF="node5.html#SECTION050331800000000000000">22.3.18 Create a Field from a Mesh and arrayspec</A>
<LI><A NAME="tex2html1840"
  HREF="node5.html#SECTION050331900000000000000">22.3.19 Create a Field from a Mesh and an Array</A>
<LI><A NAME="tex2html1841"
  HREF="node5.html#SECTION050332000000000000000">22.3.20 Create a Field from a Mesh and an ArraySpec with optional features</A>
<LI><A NAME="tex2html1842"
  HREF="node5.html#SECTION050332100000000000000">22.3.21 Create a Field with replicated dimensions</A>
<LI><A NAME="tex2html1843"
  HREF="node5.html#SECTION050332200000000000000">22.3.22 Create a Field on an arbitrarily distributed Grid</A>
<LI><A NAME="tex2html1844"
  HREF="node5.html#SECTION050332300000000000000">22.3.23 Create a Field on an arbitrarily distributed Grid with replicated dimensions &amp; ungridded bounds</A>
<LI><A NAME="tex2html1845"
  HREF="node5.html#SECTION050332400000000000000">22.3.24 Field regridding</A>
<LI><A NAME="tex2html1846"
  HREF="node5.html#SECTION050332500000000000000">22.3.25 Precompute a regridding operation between two Fields</A>
<LI><A NAME="tex2html1847"
  HREF="node5.html#SECTION050332600000000000000">22.3.26 Apply a regridding operation between a pair of Fields</A>
<LI><A NAME="tex2html1848"
  HREF="node5.html#SECTION050332700000000000000">22.3.27 Release the stored information for a regridding operation</A>
<LI><A NAME="tex2html1849"
  HREF="node5.html#SECTION050332800000000000000">22.3.28 Precompute a regridding operation using masks</A>
<LI><A NAME="tex2html1850"
  HREF="node5.html#SECTION050332900000000000000">22.3.29 Regrid troubleshooting guide</A>
<LI><A NAME="tex2html1851"
  HREF="node5.html#SECTION050333000000000000000">22.3.30 Field Regrid Example: Mesh to Mesh</A>
<LI><A NAME="tex2html1852"
  HREF="node5.html#SECTION050333100000000000000">22.3.31 Gather Field data onto root PET</A>
<LI><A NAME="tex2html1853"
  HREF="node5.html#SECTION050333200000000000000">22.3.32 Scatter Field data from root PET onto its set of joint PETs</A>
<LI><A NAME="tex2html1854"
  HREF="node5.html#SECTION050333300000000000000">22.3.33 Redistribute data from source Field to destination Field</A>
<LI><A NAME="tex2html1855"
  HREF="node5.html#SECTION050333400000000000000">22.3.34 FieldRedist as a form of scatter involving arbitrary distribution</A>
<LI><A NAME="tex2html1856"
  HREF="node5.html#SECTION050333500000000000000">22.3.35 FieldRedist as a form of gather involving arbitrary distribution</A>
<LI><A NAME="tex2html1857"
  HREF="node5.html#SECTION050333600000000000000">22.3.36 Sparse matrix multiplication from source Field to destination Field</A>
<LI><A NAME="tex2html1858"
  HREF="node5.html#SECTION050333700000000000000">22.3.37 Field Halo solving a domain decomposed heat transfer problem</A>
</UL>
<LI><A NAME="tex2html1859"
  HREF="node5.html#SECTION05034000000000000000">22.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html1860"
  HREF="node5.html#SECTION05035000000000000000">22.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html1861"
  HREF="node5.html#SECTION05036000000000000000">22.6 Class API</A>
<UL>
<LI><A NAME="tex2html1862"
  HREF="node5.html#SECTION05036100000000000000">22.6.1 ESMF_FieldAssignment(=)</A>
<LI><A NAME="tex2html1863"
  HREF="node5.html#SECTION05036200000000000000">22.6.2 ESMF_FieldOperator(==)</A>
<LI><A NAME="tex2html1864"
  HREF="node5.html#SECTION05036300000000000000">22.6.3 ESMF_FieldOperator(/=)</A>
<LI><A NAME="tex2html1865"
  HREF="node5.html#SECTION05036400000000000000">22.6.4 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1866"
  HREF="node5.html#SECTION05036500000000000000">22.6.5 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1867"
  HREF="node5.html#SECTION05036600000000000000">22.6.6 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1868"
  HREF="node5.html#SECTION05036700000000000000">22.6.7 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1869"
  HREF="node5.html#SECTION05036800000000000000">22.6.8 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1870"
  HREF="node5.html#SECTION05036900000000000000">22.6.9 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1871"
  HREF="node5.html#SECTION050361000000000000000">22.6.10 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1872"
  HREF="node5.html#SECTION050361100000000000000">22.6.11 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1873"
  HREF="node5.html#SECTION050361200000000000000">22.6.12 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1874"
  HREF="node5.html#SECTION050361300000000000000">22.6.13 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1875"
  HREF="node5.html#SECTION050361400000000000000">22.6.14 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1876"
  HREF="node5.html#SECTION050361500000000000000">22.6.15 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1877"
  HREF="node5.html#SECTION050361600000000000000">22.6.16 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1878"
  HREF="node5.html#SECTION050361700000000000000">22.6.17 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1879"
  HREF="node5.html#SECTION050361800000000000000">22.6.18 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1880"
  HREF="node5.html#SECTION050361900000000000000">22.6.19 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1881"
  HREF="node5.html#SECTION050362000000000000000">22.6.20 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1882"
  HREF="node5.html#SECTION050362100000000000000">22.6.21 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1883"
  HREF="node5.html#SECTION050362200000000000000">22.6.22 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1884"
  HREF="node5.html#SECTION050362300000000000000">22.6.23 ESMF_FieldCreate</A>
<LI><A NAME="tex2html1885"
  HREF="node5.html#SECTION050362400000000000000">22.6.24 ESMF_FieldDestroy</A>
<LI><A NAME="tex2html1886"
  HREF="node5.html#SECTION050362500000000000000">22.6.25 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1887"
  HREF="node5.html#SECTION050362600000000000000">22.6.26 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1888"
  HREF="node5.html#SECTION050362700000000000000">22.6.27 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1889"
  HREF="node5.html#SECTION050362800000000000000">22.6.28 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1890"
  HREF="node5.html#SECTION050362900000000000000">22.6.29 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1891"
  HREF="node5.html#SECTION050363000000000000000">22.6.30 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1892"
  HREF="node5.html#SECTION050363100000000000000">22.6.31 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1893"
  HREF="node5.html#SECTION050363200000000000000">22.6.32 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1894"
  HREF="node5.html#SECTION050363300000000000000">22.6.33 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1895"
  HREF="node5.html#SECTION050363400000000000000">22.6.34 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1896"
  HREF="node5.html#SECTION050363500000000000000">22.6.35 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1897"
  HREF="node5.html#SECTION050363600000000000000">22.6.36 ESMF_FieldEmptyComplete</A>
<LI><A NAME="tex2html1898"
  HREF="node5.html#SECTION050363700000000000000">22.6.37 ESMF_FieldEmptyCreate</A>
<LI><A NAME="tex2html1899"
  HREF="node5.html#SECTION050363800000000000000">22.6.38 ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html1900"
  HREF="node5.html#SECTION050363900000000000000">22.6.39 ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html1901"
  HREF="node5.html#SECTION050364000000000000000">22.6.40 ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html1902"
  HREF="node5.html#SECTION050364100000000000000">22.6.41 ESMF_FieldEmptySet</A>
<LI><A NAME="tex2html1903"
  HREF="node5.html#SECTION050364200000000000000">22.6.42 ESMF_FieldGet</A>
<LI><A NAME="tex2html1904"
  HREF="node5.html#SECTION050364300000000000000">22.6.43 ESMF_FieldGet</A>
<LI><A NAME="tex2html1905"
  HREF="node5.html#SECTION050364400000000000000">22.6.44 ESMF_FieldGetBounds</A>
<LI><A NAME="tex2html1906"
  HREF="node5.html#SECTION050364500000000000000">22.6.45 ESMF_FieldPrint</A>
<LI><A NAME="tex2html1907"
  HREF="node5.html#SECTION050364600000000000000">22.6.46 ESMF_FieldRead</A>
<LI><A NAME="tex2html1908"
  HREF="node5.html#SECTION050364700000000000000">22.6.47 ESMF_FieldValidate</A>
<LI><A NAME="tex2html1909"
  HREF="node5.html#SECTION050364800000000000000">22.6.48 ESMF_FieldWrite</A>
</UL>
<LI><A NAME="tex2html1910"
  HREF="node5.html#SECTION05037000000000000000">22.7 Class API: Field Utilities</A>
<UL>
<LI><A NAME="tex2html1911"
  HREF="node5.html#SECTION05037100000000000000">22.7.1 ESMF_GridGetFieldBounds</A>
<LI><A NAME="tex2html1912"
  HREF="node5.html#SECTION05037200000000000000">22.7.2 ESMF_LocStreamGetFieldBounds</A>
<LI><A NAME="tex2html1913"
  HREF="node5.html#SECTION05037300000000000000">22.7.3 ESMF_MeshGetFieldBounds</A>
<LI><A NAME="tex2html1914"
  HREF="node5.html#SECTION05037400000000000000">22.7.4 ESMF_XGridGetFieldBounds</A>
</UL>
<LI><A NAME="tex2html1915"
  HREF="node5.html#SECTION05038000000000000000">22.8 Class API: Field Communications</A>
<UL>
<LI><A NAME="tex2html1916"
  HREF="node5.html#SECTION05038100000000000000">22.8.1 ESMF_FieldGather</A>
<LI><A NAME="tex2html1917"
  HREF="node5.html#SECTION05038200000000000000">22.8.2 ESMF_FieldHalo</A>
<LI><A NAME="tex2html1918"
  HREF="node5.html#SECTION05038300000000000000">22.8.3 ESMF_FieldHaloRelease</A>
<LI><A NAME="tex2html1919"
  HREF="node5.html#SECTION05038400000000000000">22.8.4 ESMF_FieldHaloStore</A>
<LI><A NAME="tex2html1920"
  HREF="node5.html#SECTION05038500000000000000">22.8.5 ESMF_FieldRedist</A>
<LI><A NAME="tex2html1921"
  HREF="node5.html#SECTION05038600000000000000">22.8.6 ESMF_FieldRedistRelease</A>
<LI><A NAME="tex2html1922"
  HREF="node5.html#SECTION05038700000000000000">22.8.7 ESMF_FieldRedistStore</A>
<LI><A NAME="tex2html1923"
  HREF="node5.html#SECTION05038800000000000000">22.8.8 ESMF_FieldRedistStore</A>
<LI><A NAME="tex2html1924"
  HREF="node5.html#SECTION05038900000000000000">22.8.9 ESMF_FieldRegrid</A>
<LI><A NAME="tex2html1925"
  HREF="node5.html#SECTION050381000000000000000">22.8.10 ESMF_FieldRegridRelease</A>
<LI><A NAME="tex2html1926"
  HREF="node5.html#SECTION050381100000000000000">22.8.11 ESMF_FieldRegridStore</A>
<LI><A NAME="tex2html1927"
  HREF="node5.html#SECTION050381200000000000000">22.8.12 ESMF_FieldRegridStore</A>
<LI><A NAME="tex2html1928"
  HREF="node5.html#SECTION050381300000000000000">22.8.13 ESMF_FieldScatter</A>
<LI><A NAME="tex2html1929"
  HREF="node5.html#SECTION050381400000000000000">22.8.14 ESMF_FieldSMM</A>
<LI><A NAME="tex2html1930"
  HREF="node5.html#SECTION050381500000000000000">22.8.15 ESMF_FieldSMMRelease</A>
<LI><A NAME="tex2html1931"
  HREF="node5.html#SECTION050381600000000000000">22.8.16 ESMF_FieldSMMStore</A>
<LI><A NAME="tex2html1932"
  HREF="node5.html#SECTION050381700000000000000">22.8.17 ESMF_FieldSMMStore</A>
</UL>
</UL>
<LI><A NAME="tex2html1933"
  HREF="node5.html#SECTION05040000000000000000">23 ArrayBundle Class</A>
<UL>
<LI><A NAME="tex2html1934"
  HREF="node5.html#SECTION05041000000000000000">23.1 Description</A>
<LI><A NAME="tex2html1935"
  HREF="node5.html#SECTION05042000000000000000">23.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1936"
  HREF="node5.html#SECTION05042100000000000000">23.2.1 Create an ArrayBundle from a list of Arrays</A>
<LI><A NAME="tex2html1937"
  HREF="node5.html#SECTION05042200000000000000">23.2.2 Access Arrays inside the ArrayBundle</A>
<LI><A NAME="tex2html1938"
  HREF="node5.html#SECTION05042300000000000000">23.2.3 Destroy an ArrayBundle and its constituents</A>
<LI><A NAME="tex2html1939"
  HREF="node5.html#SECTION05042400000000000000">23.2.4 Halo communication</A>
</UL>
<LI><A NAME="tex2html1940"
  HREF="node5.html#SECTION05043000000000000000">23.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1941"
  HREF="node5.html#SECTION05044000000000000000">23.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1942"
  HREF="node5.html#SECTION05045000000000000000">23.5 Class API</A>
<UL>
<LI><A NAME="tex2html1943"
  HREF="node5.html#SECTION05045100000000000000">23.5.1 ESMF_ArrayBundleAssignment(=)</A>
<LI><A NAME="tex2html1944"
  HREF="node5.html#SECTION05045200000000000000">23.5.2 ESMF_ArrayBundleOperator(==)</A>
<LI><A NAME="tex2html1945"
  HREF="node5.html#SECTION05045300000000000000">23.5.3 ESMF_ArrayBundleOperator(/=)</A>
<LI><A NAME="tex2html1946"
  HREF="node5.html#SECTION05045400000000000000">23.5.4 ESMF_ArrayBundleAdd</A>
<LI><A NAME="tex2html1947"
  HREF="node5.html#SECTION05045500000000000000">23.5.5 ESMF_ArrayBundleAddReplace</A>
<LI><A NAME="tex2html1948"
  HREF="node5.html#SECTION05045600000000000000">23.5.6 ESMF_ArrayBundleCreate</A>
<LI><A NAME="tex2html1949"
  HREF="node5.html#SECTION05045700000000000000">23.5.7 ESMF_ArrayBundleDestroy</A>
<LI><A NAME="tex2html1950"
  HREF="node5.html#SECTION05045800000000000000">23.5.8 ESMF_ArrayBundleGet</A>
<LI><A NAME="tex2html1951"
  HREF="node5.html#SECTION05045900000000000000">23.5.9 ESMF_ArrayBundleGet</A>
<LI><A NAME="tex2html1952"
  HREF="node5.html#SECTION050451000000000000000">23.5.10 ESMF_ArrayBundleGet</A>
<LI><A NAME="tex2html1953"
  HREF="node5.html#SECTION050451100000000000000">23.5.11 ESMF_ArrayBundleHalo</A>
<LI><A NAME="tex2html1954"
  HREF="node5.html#SECTION050451200000000000000">23.5.12 ESMF_ArrayBundleHaloRelease</A>
<LI><A NAME="tex2html1955"
  HREF="node5.html#SECTION050451300000000000000">23.5.13 ESMF_ArrayBundleHaloStore</A>
<LI><A NAME="tex2html1956"
  HREF="node5.html#SECTION050451400000000000000">23.5.14 ESMF_ArrayBundlePrint</A>
<LI><A NAME="tex2html1957"
  HREF="node5.html#SECTION050451500000000000000">23.5.15 ESMF_ArrayBundleRead</A>
<LI><A NAME="tex2html1958"
  HREF="node5.html#SECTION050451600000000000000">23.5.16 ESMF_ArrayBundleRedist</A>
<LI><A NAME="tex2html1959"
  HREF="node5.html#SECTION050451700000000000000">23.5.17 ESMF_ArrayBundleRedistRelease</A>
<LI><A NAME="tex2html1960"
  HREF="node5.html#SECTION050451800000000000000">23.5.18 ESMF_ArrayBundleRedistStore</A>
<LI><A NAME="tex2html1961"
  HREF="node5.html#SECTION050451900000000000000">23.5.19 ESMF_ArrayBundleRedistStore</A>
<LI><A NAME="tex2html1962"
  HREF="node5.html#SECTION050452000000000000000">23.5.20 ESMF_ArrayBundleRemove</A>
<LI><A NAME="tex2html1963"
  HREF="node5.html#SECTION050452100000000000000">23.5.21 ESMF_ArrayBundleReplace</A>
<LI><A NAME="tex2html1964"
  HREF="node5.html#SECTION050452200000000000000">23.5.22 ESMF_ArrayBundleSMM</A>
<LI><A NAME="tex2html1965"
  HREF="node5.html#SECTION050452300000000000000">23.5.23 ESMF_ArrayBundleSMMRelease</A>
<LI><A NAME="tex2html1966"
  HREF="node5.html#SECTION050452400000000000000">23.5.24 ESMF_ArrayBundleSMMStore</A>
<LI><A NAME="tex2html1967"
  HREF="node5.html#SECTION050452500000000000000">23.5.25 ESMF_ArrayBundleSMMStore</A>
<LI><A NAME="tex2html1968"
  HREF="node5.html#SECTION050452600000000000000">23.5.26 ESMF_ArrayBundleWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html1969"
  HREF="node5.html#SECTION05050000000000000000">24 Array Class</A>
<UL>
<LI><A NAME="tex2html1970"
  HREF="node5.html#SECTION05051000000000000000">24.1 Description</A>
<LI><A NAME="tex2html1971"
  HREF="node5.html#SECTION05052000000000000000">24.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html1972"
  HREF="node5.html#SECTION05052100000000000000">24.2.1 Array from native Fortran array with 1 DE per PET</A>
<LI><A NAME="tex2html1973"
  HREF="node5.html#SECTION05052200000000000000">24.2.2 Array from native Fortran array with extra elements for halo or padding</A>
<LI><A NAME="tex2html1974"
  HREF="node5.html#SECTION05052300000000000000">24.2.3 Array from <TT>ESMF_LocalArray</TT></A>
<LI><A NAME="tex2html1975"
  HREF="node5.html#SECTION05052400000000000000">24.2.4 Create Array with automatic memory allocation</A>
<LI><A NAME="tex2html1976"
  HREF="node5.html#SECTION05052500000000000000">24.2.5 Native language memory access</A>
<LI><A NAME="tex2html1977"
  HREF="node5.html#SECTION05052600000000000000">24.2.6 Regions and default bounds</A>
<LI><A NAME="tex2html1978"
  HREF="node5.html#SECTION05052700000000000000">24.2.7 Array bounds</A>
<LI><A NAME="tex2html1979"
  HREF="node5.html#SECTION05052800000000000000">24.2.8 Computational region and extra elements for halo or padding</A>
<LI><A NAME="tex2html1980"
  HREF="node5.html#SECTION05052900000000000000">24.2.9 Create 1D and 3D Arrays</A>
<LI><A NAME="tex2html1981"
  HREF="node5.html#SECTION050521000000000000000">24.2.10 Working with Arrays of different rank</A>
<LI><A NAME="tex2html1982"
  HREF="node5.html#SECTION050521100000000000000">24.2.11 Array and DistGrid rank - 2D+1 Arrays</A>
<LI><A NAME="tex2html1983"
  HREF="node5.html#SECTION050521200000000000000">24.2.12 Arrays with replicated dimensions</A>
<LI><A NAME="tex2html1984"
  HREF="node5.html#SECTION050521300000000000000">24.2.13 Communication - Scatter and Gather</A>
<LI><A NAME="tex2html1985"
  HREF="node5.html#SECTION050521400000000000000">24.2.14 Communication - Halo</A>
<LI><A NAME="tex2html1986"
  HREF="node5.html#SECTION050521500000000000000">24.2.15 Communication - Halo for arbitrary distribution</A>
<LI><A NAME="tex2html1987"
  HREF="node5.html#SECTION050521600000000000000">24.2.16 Communication - Redist</A>
<LI><A NAME="tex2html1988"
  HREF="node5.html#SECTION050521700000000000000">24.2.17 Communication - SparseMatMul</A>
<LI><A NAME="tex2html1989"
  HREF="node5.html#SECTION050521800000000000000">24.2.18 Communication - Scatter and Gather, revisited</A>
<LI><A NAME="tex2html1990"
  HREF="node5.html#SECTION050521900000000000000">24.2.19 Non-blocking Communications</A>
</UL>
<LI><A NAME="tex2html1991"
  HREF="node5.html#SECTION05053000000000000000">24.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html1992"
  HREF="node5.html#SECTION05054000000000000000">24.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html1993"
  HREF="node5.html#SECTION05055000000000000000">24.5 Class API</A>
<UL>
<LI><A NAME="tex2html1994"
  HREF="node5.html#SECTION05055100000000000000">24.5.1 ESMF_ArrayAssignment(=)</A>
<LI><A NAME="tex2html1995"
  HREF="node5.html#SECTION05055200000000000000">24.5.2 ESMF_ArrayOperator(==)</A>
<LI><A NAME="tex2html1996"
  HREF="node5.html#SECTION05055300000000000000">24.5.3 ESMF_ArrayOperator(/=)</A>
<LI><A NAME="tex2html1997"
  HREF="node5.html#SECTION05055400000000000000">24.5.4 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html1998"
  HREF="node5.html#SECTION05055500000000000000">24.5.5 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html1999"
  HREF="node5.html#SECTION05055600000000000000">24.5.6 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2000"
  HREF="node5.html#SECTION05055700000000000000">24.5.7 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2001"
  HREF="node5.html#SECTION05055800000000000000">24.5.8 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2002"
  HREF="node5.html#SECTION05055900000000000000">24.5.9 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2003"
  HREF="node5.html#SECTION050551000000000000000">24.5.10 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2004"
  HREF="node5.html#SECTION050551100000000000000">24.5.11 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2005"
  HREF="node5.html#SECTION050551200000000000000">24.5.12 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2006"
  HREF="node5.html#SECTION050551300000000000000">24.5.13 ESMF_ArrayCreate</A>
<LI><A NAME="tex2html2007"
  HREF="node5.html#SECTION050551400000000000000">24.5.14 ESMF_ArrayDestroy</A>
<LI><A NAME="tex2html2008"
  HREF="node5.html#SECTION050551500000000000000">24.5.15 ESMF_ArrayGather</A>
<LI><A NAME="tex2html2009"
  HREF="node5.html#SECTION050551600000000000000">24.5.16 ESMF_ArrayGet</A>
<LI><A NAME="tex2html2010"
  HREF="node5.html#SECTION050551700000000000000">24.5.17 ESMF_ArrayGet</A>
<LI><A NAME="tex2html2011"
  HREF="node5.html#SECTION050551800000000000000">24.5.18 ESMF_ArrayGet</A>
<LI><A NAME="tex2html2012"
  HREF="node5.html#SECTION050551900000000000000">24.5.19 ESMF_ArrayGet</A>
<LI><A NAME="tex2html2013"
  HREF="node5.html#SECTION050552000000000000000">24.5.20 ESMF_ArrayHalo</A>
<LI><A NAME="tex2html2014"
  HREF="node5.html#SECTION050552100000000000000">24.5.21 ESMF_ArrayHaloRelease</A>
<LI><A NAME="tex2html2015"
  HREF="node5.html#SECTION050552200000000000000">24.5.22 ESMF_ArrayHaloStore</A>
<LI><A NAME="tex2html2016"
  HREF="node5.html#SECTION050552300000000000000">24.5.23 ESMF_ArrayPrint</A>
<LI><A NAME="tex2html2017"
  HREF="node5.html#SECTION050552400000000000000">24.5.24 ESMF_ArrayRead</A>
<LI><A NAME="tex2html2018"
  HREF="node5.html#SECTION050552500000000000000">24.5.25 ESMF_ArrayRedist</A>
<LI><A NAME="tex2html2019"
  HREF="node5.html#SECTION050552600000000000000">24.5.26 ESMF_ArrayRedistRelease</A>
<LI><A NAME="tex2html2020"
  HREF="node5.html#SECTION050552700000000000000">24.5.27 ESMF_ArrayRedistStore</A>
<LI><A NAME="tex2html2021"
  HREF="node5.html#SECTION050552800000000000000">24.5.28 ESMF_ArrayRedistStore</A>
<LI><A NAME="tex2html2022"
  HREF="node5.html#SECTION050552900000000000000">24.5.29 ESMF_ArrayScatter</A>
<LI><A NAME="tex2html2023"
  HREF="node5.html#SECTION050553000000000000000">24.5.30 ESMF_ArraySet</A>
<LI><A NAME="tex2html2024"
  HREF="node5.html#SECTION050553100000000000000">24.5.31 ESMF_ArraySet</A>
<LI><A NAME="tex2html2025"
  HREF="node5.html#SECTION050553200000000000000">24.5.32 ESMF_ArraySMM</A>
<LI><A NAME="tex2html2026"
  HREF="node5.html#SECTION050553300000000000000">24.5.33 ESMF_ArraySMMRelease</A>
<LI><A NAME="tex2html2027"
  HREF="node5.html#SECTION050553400000000000000">24.5.34 ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html2028"
  HREF="node5.html#SECTION050553500000000000000">24.5.35 ESMF_ArraySMMStore</A>
<LI><A NAME="tex2html2029"
  HREF="node5.html#SECTION050553600000000000000">24.5.36 ESMF_ArrayValidate</A>
<LI><A NAME="tex2html2030"
  HREF="node5.html#SECTION050553700000000000000">24.5.37 ESMF_ArrayWrite</A>
</UL>
</UL>
<LI><A NAME="tex2html2031"
  HREF="node5.html#SECTION05060000000000000000">25 LocalArray Class</A>
<UL>
<LI><A NAME="tex2html2032"
  HREF="node5.html#SECTION05061000000000000000">25.1 Description</A>
<LI><A NAME="tex2html2033"
  HREF="node5.html#SECTION05062000000000000000">25.2 Restrictions and Future Work</A>
<LI><A NAME="tex2html2034"
  HREF="node5.html#SECTION05063000000000000000">25.3 Class API</A>
<UL>
<LI><A NAME="tex2html2035"
  HREF="node5.html#SECTION05063100000000000000">25.3.1 ESMF_LocalArrayAssignment(=)</A>
<LI><A NAME="tex2html2036"
  HREF="node5.html#SECTION05063200000000000000">25.3.2 ESMF_LocalArrayOperator(==)</A>
<LI><A NAME="tex2html2037"
  HREF="node5.html#SECTION05063300000000000000">25.3.3 ESMF_LocalArrayOperator(/=)</A>
<LI><A NAME="tex2html2038"
  HREF="node5.html#SECTION05063400000000000000">25.3.4 ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html2039"
  HREF="node5.html#SECTION05063500000000000000">25.3.5 ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html2040"
  HREF="node5.html#SECTION05063600000000000000">25.3.6 ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html2041"
  HREF="node5.html#SECTION05063700000000000000">25.3.7 ESMF_LocalArrayCreate</A>
<LI><A NAME="tex2html2042"
  HREF="node5.html#SECTION05063800000000000000">25.3.8 ESMF_LocalArrayDestroy</A>
<LI><A NAME="tex2html2043"
  HREF="node5.html#SECTION05063900000000000000">25.3.9 ESMF_LocalArrayGet</A>
<LI><A NAME="tex2html2044"
  HREF="node5.html#SECTION050631000000000000000">25.3.10 ESMF_LocalArrayGet</A>
</UL>
</UL>
<LI><A NAME="tex2html2045"
  HREF="node5.html#SECTION05070000000000000000">26 ArraySpec Class</A>
<UL>
<LI><A NAME="tex2html2046"
  HREF="node5.html#SECTION05071000000000000000">26.1 Description</A>
<LI><A NAME="tex2html2047"
  HREF="node5.html#SECTION05072000000000000000">26.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2048"
  HREF="node5.html#SECTION05072100000000000000">26.2.1 Set ArraySpec values</A>
<LI><A NAME="tex2html2049"
  HREF="node5.html#SECTION05072200000000000000">26.2.2 Get ArraySpec values</A>
</UL>
<LI><A NAME="tex2html2050"
  HREF="node5.html#SECTION05073000000000000000">26.3 Restrictions and Future Work</A>
<LI><A NAME="tex2html2051"
  HREF="node5.html#SECTION05074000000000000000">26.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html2052"
  HREF="node5.html#SECTION05075000000000000000">26.5 Class API</A>
<UL>
<LI><A NAME="tex2html2053"
  HREF="node5.html#SECTION05075100000000000000">26.5.1 ESMF_ArraySpecAssignment(=)</A>
<LI><A NAME="tex2html2054"
  HREF="node5.html#SECTION05075200000000000000">26.5.2 ESMF_ArraySpecOperator(==)</A>
<LI><A NAME="tex2html2055"
  HREF="node5.html#SECTION05075300000000000000">26.5.3 ESMF_ArraySpecOperator(/=)</A>
<LI><A NAME="tex2html2056"
  HREF="node5.html#SECTION05075400000000000000">26.5.4 ESMF_ArraySpecGet</A>
<LI><A NAME="tex2html2057"
  HREF="node5.html#SECTION05075500000000000000">26.5.5 ESMF_ArraySpecPrint</A>
<LI><A NAME="tex2html2058"
  HREF="node5.html#SECTION05075600000000000000">26.5.6 ESMF_ArraySpecSet</A>
<LI><A NAME="tex2html2059"
  HREF="node5.html#SECTION05075700000000000000">26.5.7 ESMF_ArraySpecValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2060"
  HREF="node5.html#SECTION05080000000000000000">27 Grid Class</A>
<UL>
<LI><A NAME="tex2html2061"
  HREF="node5.html#SECTION05081000000000000000">27.1 Description</A>
<UL>
<LI><A NAME="tex2html2062"
  HREF="node5.html#SECTION05081100000000000000">27.1.1 Grid Representation in ESMF</A>
<LI><A NAME="tex2html2063"
  HREF="node5.html#SECTION05081200000000000000">27.1.2 Supported Grids</A>
<LI><A NAME="tex2html2064"
  HREF="node5.html#SECTION05081300000000000000">27.1.3 Grid Topologies and Periodicity</A>
<LI><A NAME="tex2html2065"
  HREF="node5.html#SECTION05081400000000000000">27.1.4 Grid Distribution</A>
<LI><A NAME="tex2html2066"
  HREF="node5.html#SECTION05081500000000000000">27.1.5 Grid Coordinates</A>
<LI><A NAME="tex2html2067"
  HREF="node5.html#SECTION05081600000000000000">27.1.6 Coordinate Specification and Generation</A>
<LI><A NAME="tex2html2068"
  HREF="node5.html#SECTION05081700000000000000">27.1.7 Staggering</A>
</UL>
<LI><A NAME="tex2html2069"
  HREF="node5.html#SECTION05082000000000000000">27.2 Constants</A>
<UL>
<LI><A NAME="tex2html2070"
  HREF="node5.html#SECTION05082100000000000000">27.2.1 ESMF_COORDSYS</A>
<LI><A NAME="tex2html2071"
  HREF="node5.html#SECTION05082200000000000000">27.2.2 ESMF_GRIDCONN</A>
<LI><A NAME="tex2html2072"
  HREF="node5.html#SECTION05082300000000000000">27.2.3 ESMF_GRIDITEM</A>
<LI><A NAME="tex2html2073"
  HREF="node5.html#SECTION05082400000000000000">27.2.4 ESMF_GRIDMATCH</A>
<LI><A NAME="tex2html2074"
  HREF="node5.html#SECTION05082500000000000000">27.2.5 ESMF_GRIDSTATUS</A>
<LI><A NAME="tex2html2075"
  HREF="node5.html#SECTION05082600000000000000">27.2.6 ESMF_POLEKIND</A>
<LI><A NAME="tex2html2076"
  HREF="node5.html#SECTION05082700000000000000">27.2.7 ESMF_STAGGERLOC</A>
</UL>
<LI><A NAME="tex2html2077"
  HREF="node5.html#SECTION05083000000000000000">27.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2078"
  HREF="node5.html#SECTION05083100000000000000">27.3.1 Create single-tile Grid shortcut method</A>
<LI><A NAME="tex2html2079"
  HREF="node5.html#SECTION05083200000000000000">27.3.2 Create a 2D regularly distributed rectilinear Grid
                    with uniformly spaced coordinates</A>
<LI><A NAME="tex2html2080"
  HREF="node5.html#SECTION05083300000000000000">27.3.3 Create a periodic 2D regularly distributed rectilinear Grid</A>
<LI><A NAME="tex2html2081"
  HREF="node5.html#SECTION05083400000000000000">27.3.4 Create a 2D irregularly distributed rectilinear Grid
                    with uniformly spaced coordinates</A>
<LI><A NAME="tex2html2082"
  HREF="node5.html#SECTION05083500000000000000">27.3.5 Create a 2D irregularly distributed Grid
                    with curvilinear coordinates</A>
<LI><A NAME="tex2html2083"
  HREF="node5.html#SECTION05083600000000000000">27.3.6 Create an irregularly distributed rectilinear Grid with
                  a non-distributed vertical dimension</A>
<LI><A NAME="tex2html2084"
  HREF="node5.html#SECTION05083700000000000000">27.3.7 Create an arbitrarily distributed rectilinear Grid with
                  a non-distributed vertical dimension</A>
<LI><A NAME="tex2html2085"
  HREF="node5.html#SECTION05083800000000000000">27.3.8 Create a curvilinear Grid using the coordinates defined 
   in a SCRIP file</A>
<LI><A NAME="tex2html2086"
  HREF="node5.html#SECTION05083900000000000000">27.3.9 Create an empty Grid in a parent Component 
   for completion in a child Component</A>
<LI><A NAME="tex2html2087"
  HREF="node5.html#SECTION050831000000000000000">27.3.10 Grid stagger locations</A>
<LI><A NAME="tex2html2088"
  HREF="node5.html#SECTION050831100000000000000">27.3.11 Associate coordinates with stagger locations</A>
<LI><A NAME="tex2html2089"
  HREF="node5.html#SECTION050831200000000000000">27.3.12 Specify the relationship of coordinate Arrays
                 to index space dimensions</A>
<LI><A NAME="tex2html2090"
  HREF="node5.html#SECTION050831300000000000000">27.3.13 Access coordinates</A>
<LI><A NAME="tex2html2091"
  HREF="node5.html#SECTION050831400000000000000">27.3.14 Associate items with stagger locations</A>
<LI><A NAME="tex2html2092"
  HREF="node5.html#SECTION050831500000000000000">27.3.15 Access items</A>
<LI><A NAME="tex2html2093"
  HREF="node5.html#SECTION050831600000000000000">27.3.16 Grid regions and bounds</A>
<LI><A NAME="tex2html2094"
  HREF="node5.html#SECTION050831700000000000000">27.3.17 Get Grid coordinate bounds</A>
<LI><A NAME="tex2html2095"
  HREF="node5.html#SECTION050831800000000000000">27.3.18 Get Grid stagger location bounds</A>
<LI><A NAME="tex2html2096"
  HREF="node5.html#SECTION050831900000000000000">27.3.19 Get Grid stagger location information</A>
<LI><A NAME="tex2html2097"
  HREF="node5.html#SECTION050832000000000000000">27.3.20 Create an Array at a stagger location</A>
<LI><A NAME="tex2html2098"
  HREF="node5.html#SECTION050832100000000000000">27.3.21 Create more complex Grids using DistGrid</A>
<LI><A NAME="tex2html2099"
  HREF="node5.html#SECTION050832200000000000000">27.3.22 Specify custom stagger locations</A>
<LI><A NAME="tex2html2100"
  HREF="node5.html#SECTION050832300000000000000">27.3.23 Specify custom stagger padding</A>
<LI><A NAME="tex2html2101"
  HREF="node5.html#SECTION050832400000000000000">27.3.24 Create a 2D regularly distributed rectilinear Grid from file</A>
</UL>
<LI><A NAME="tex2html2102"
  HREF="node5.html#SECTION05084000000000000000">27.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html2103"
  HREF="node5.html#SECTION05085000000000000000">27.5 Design and Implementation Notes</A>
<UL>
<LI><A NAME="tex2html2104"
  HREF="node5.html#SECTION05085100000000000000">27.5.1 Grid Topology</A>
</UL>
<LI><A NAME="tex2html2105"
  HREF="node5.html#SECTION05086000000000000000">27.6 Class API: General Grid Methods</A>
<UL>
<LI><A NAME="tex2html2106"
  HREF="node5.html#SECTION05086100000000000000">27.6.1 ESMF_GridAssignment(=)</A>
<LI><A NAME="tex2html2107"
  HREF="node5.html#SECTION05086200000000000000">27.6.2 ESMF_GridOperator(==)</A>
<LI><A NAME="tex2html2108"
  HREF="node5.html#SECTION05086300000000000000">27.6.3 ESMF_GridOperator(/=)</A>
<LI><A NAME="tex2html2109"
  HREF="node5.html#SECTION05086400000000000000">27.6.4 ESMF_GridAddCoord</A>
<LI><A NAME="tex2html2110"
  HREF="node5.html#SECTION05086500000000000000">27.6.5 ESMF_GridAddItem</A>
<LI><A NAME="tex2html2111"
  HREF="node5.html#SECTION05086600000000000000">27.6.6 ESMF_GridCreate</A>
<LI><A NAME="tex2html2112"
  HREF="node5.html#SECTION05086700000000000000">27.6.7 ESMF_GridCreate</A>
<LI><A NAME="tex2html2113"
  HREF="node5.html#SECTION05086800000000000000">27.6.8 ESMF_GridCreate</A>
<LI><A NAME="tex2html2114"
  HREF="node5.html#SECTION05086900000000000000">27.6.9 ESMF_GridCreate</A>
<LI><A NAME="tex2html2115"
  HREF="node5.html#SECTION050861000000000000000">27.6.10 ESMF_GridCreate</A>
<LI><A NAME="tex2html2116"
  HREF="node5.html#SECTION050861100000000000000">27.6.11 ESMF_GridCreate</A>
<LI><A NAME="tex2html2117"
  HREF="node5.html#SECTION050861200000000000000">27.6.12 ESMF_GridCreate</A>
<LI><A NAME="tex2html2118"
  HREF="node5.html#SECTION050861300000000000000">27.6.13 ESMF_GridCreate</A>
<LI><A NAME="tex2html2119"
  HREF="node5.html#SECTION050861400000000000000">27.6.14 ESMF_GridCreate</A>
<LI><A NAME="tex2html2120"
  HREF="node5.html#SECTION050861500000000000000">27.6.15 ESMF_GridCreate</A>
<LI><A NAME="tex2html2121"
  HREF="node5.html#SECTION050861600000000000000">27.6.16 ESMF_GridCreate1PeriDim</A>
<LI><A NAME="tex2html2122"
  HREF="node5.html#SECTION050861700000000000000">27.6.17 ESMF_GridCreate1PeriDim</A>
<LI><A NAME="tex2html2123"
  HREF="node5.html#SECTION050861800000000000000">27.6.18 ESMF_GridCreate1PeriDim</A>
<LI><A NAME="tex2html2124"
  HREF="node5.html#SECTION050861900000000000000">27.6.19 ESMF_GridCreate2PeriDim</A>
<LI><A NAME="tex2html2125"
  HREF="node5.html#SECTION050862000000000000000">27.6.20 ESMF_GridCreate2PeriDim</A>
<LI><A NAME="tex2html2126"
  HREF="node5.html#SECTION050862100000000000000">27.6.21 ESMF_GridCreate2PeriDim</A>
<LI><A NAME="tex2html2127"
  HREF="node5.html#SECTION050862200000000000000">27.6.22 ESMF_GridCreateNoPeriDim</A>
<LI><A NAME="tex2html2128"
  HREF="node5.html#SECTION050862300000000000000">27.6.23 ESMF_GridCreateNoPeriDim</A>
<LI><A NAME="tex2html2129"
  HREF="node5.html#SECTION050862400000000000000">27.6.24 ESMF_GridCreateNoPeriDim</A>
<LI><A NAME="tex2html2130"
  HREF="node5.html#SECTION050862500000000000000">27.6.25 ESMF_GridDestroy</A>
<LI><A NAME="tex2html2131"
  HREF="node5.html#SECTION050862600000000000000">27.6.26 ESMF_GridEmptyComplete</A>
<LI><A NAME="tex2html2132"
  HREF="node5.html#SECTION050862700000000000000">27.6.27 ESMF_GridEmptyComplete</A>
<LI><A NAME="tex2html2133"
  HREF="node5.html#SECTION050862800000000000000">27.6.28 ESMF_GridEmptyComplete</A>
<LI><A NAME="tex2html2134"
  HREF="node5.html#SECTION050862900000000000000">27.6.29 ESMF_GridEmptyCreate</A>
<LI><A NAME="tex2html2135"
  HREF="node5.html#SECTION050863000000000000000">27.6.30 ESMF_GridGet</A>
<LI><A NAME="tex2html2136"
  HREF="node5.html#SECTION050863100000000000000">27.6.31 ESMF_GridGet</A>
<LI><A NAME="tex2html2137"
  HREF="node5.html#SECTION050863200000000000000">27.6.32 ESMF_GridGet</A>
<LI><A NAME="tex2html2138"
  HREF="node5.html#SECTION050863300000000000000">27.6.33 ESMF_GridGet</A>
<LI><A NAME="tex2html2139"
  HREF="node5.html#SECTION050863400000000000000">27.6.34 ESMF_GridGet</A>
<LI><A NAME="tex2html2140"
  HREF="node5.html#SECTION050863500000000000000">27.6.35 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2141"
  HREF="node5.html#SECTION050863600000000000000">27.6.36 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2142"
  HREF="node5.html#SECTION050863700000000000000">27.6.37 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2143"
  HREF="node5.html#SECTION050863800000000000000">27.6.38 ESMF_GridGetCoord</A>
<LI><A NAME="tex2html2144"
  HREF="node5.html#SECTION050863900000000000000">27.6.39 ESMF_GridGetCoordBounds</A>
<LI><A NAME="tex2html2145"
  HREF="node5.html#SECTION050864000000000000000">27.6.40 ESMF_GridGetItem</A>
<LI><A NAME="tex2html2146"
  HREF="node5.html#SECTION050864100000000000000">27.6.41 ESMF_GridGetItem</A>
<LI><A NAME="tex2html2147"
  HREF="node5.html#SECTION050864200000000000000">27.6.42 ESMF_GridGetItemBounds</A>
<LI><A NAME="tex2html2148"
  HREF="node5.html#SECTION050864300000000000000">27.6.43 ESMF_GridMatch</A>
<LI><A NAME="tex2html2149"
  HREF="node5.html#SECTION050864400000000000000">27.6.44 ESMF_GridSetCoord</A>
<LI><A NAME="tex2html2150"
  HREF="node5.html#SECTION050864500000000000000">27.6.45 ESMF_GridSetItem</A>
<LI><A NAME="tex2html2151"
  HREF="node5.html#SECTION050864600000000000000">27.6.46 ESMF_GridValidate</A>
</UL>
<LI><A NAME="tex2html2152"
  HREF="node5.html#SECTION05087000000000000000">27.7 Class API: StaggerLoc Methods</A>
<UL>
<LI><A NAME="tex2html2153"
  HREF="node5.html#SECTION05087100000000000000">27.7.1 ESMF_StaggerLocSet</A>
<LI><A NAME="tex2html2154"
  HREF="node5.html#SECTION05087200000000000000">27.7.2 ESMF_StaggerLocSet</A>
<LI><A NAME="tex2html2155"
  HREF="node5.html#SECTION05087300000000000000">27.7.3 ESMF_StaggerLocString</A>
<LI><A NAME="tex2html2156"
  HREF="node5.html#SECTION05087400000000000000">27.7.4 ESMF_StaggerLocPrint</A>
</UL>
</UL>
<LI><A NAME="tex2html2157"
  HREF="node5.html#SECTION05090000000000000000">28 LocStream Class</A>
<UL>
<LI><A NAME="tex2html2158"
  HREF="node5.html#SECTION05091000000000000000">28.1 Description</A>
<LI><A NAME="tex2html2159"
  HREF="node5.html#SECTION05092000000000000000">28.2 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2160"
  HREF="node5.html#SECTION05092100000000000000">28.2.1 Create a LocStream with user allocated memory</A>
<LI><A NAME="tex2html2161"
  HREF="node5.html#SECTION05092200000000000000">28.2.2 Create a LocStream with internally allocated memory</A>
<LI><A NAME="tex2html2162"
  HREF="node5.html#SECTION05092300000000000000">28.2.3 Create a LocStream from a background Grid</A>
</UL>
<LI><A NAME="tex2html2163"
  HREF="node5.html#SECTION05093000000000000000">28.3 Class API</A>
<UL>
<LI><A NAME="tex2html2164"
  HREF="node5.html#SECTION05093100000000000000">28.3.1 ESMF_LocStreamAssignment(=)</A>
<LI><A NAME="tex2html2165"
  HREF="node5.html#SECTION05093200000000000000">28.3.2 ESMF_LocStreamOperator(==)</A>
<LI><A NAME="tex2html2166"
  HREF="node5.html#SECTION05093300000000000000">28.3.3 ESMF_LocStreamOperator(/=)</A>
<LI><A NAME="tex2html2167"
  HREF="node5.html#SECTION05093400000000000000">28.3.4 ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html2168"
  HREF="node5.html#SECTION05093500000000000000">28.3.5 ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html2169"
  HREF="node5.html#SECTION05093600000000000000">28.3.6 ESMF_LocStreamAddKey</A>
<LI><A NAME="tex2html2170"
  HREF="node5.html#SECTION05093700000000000000">28.3.7 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2171"
  HREF="node5.html#SECTION05093800000000000000">28.3.8 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2172"
  HREF="node5.html#SECTION05093900000000000000">28.3.9 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2173"
  HREF="node5.html#SECTION050931000000000000000">28.3.10 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2174"
  HREF="node5.html#SECTION050931100000000000000">28.3.11 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2175"
  HREF="node5.html#SECTION050931200000000000000">28.3.12 ESMF_LocStreamCreate</A>
<LI><A NAME="tex2html2176"
  HREF="node5.html#SECTION050931300000000000000">28.3.13 ESMF_LocStreamDestroy</A>
<LI><A NAME="tex2html2177"
  HREF="node5.html#SECTION050931400000000000000">28.3.14 ESMF_LocStreamGet</A>
<LI><A NAME="tex2html2178"
  HREF="node5.html#SECTION050931500000000000000">28.3.15 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html2179"
  HREF="node5.html#SECTION050931600000000000000">28.3.16 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html2180"
  HREF="node5.html#SECTION050931700000000000000">28.3.17 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html2181"
  HREF="node5.html#SECTION050931800000000000000">28.3.18 ESMF_LocStreamGetKey</A>
<LI><A NAME="tex2html2182"
  HREF="node5.html#SECTION050931900000000000000">28.3.19 ESMF_LocStreamGet</A>
<LI><A NAME="tex2html2183"
  HREF="node5.html#SECTION050932000000000000000">28.3.20 ESMF_LocStreamPrint</A>
<LI><A NAME="tex2html2184"
  HREF="node5.html#SECTION050932100000000000000">28.3.21 ESMF_LocStreamValidate</A>
</UL>
</UL>
<LI><A NAME="tex2html2185"
  HREF="node5.html#SECTION050100000000000000000">29 Mesh Class</A>
<UL>
<LI><A NAME="tex2html2186"
  HREF="node5.html#SECTION050101000000000000000">29.1 Description</A>
<UL>
<LI><A NAME="tex2html2187"
  HREF="node5.html#SECTION050101100000000000000">29.1.1 Mesh representation in ESMF</A>
<LI><A NAME="tex2html2188"
  HREF="node5.html#SECTION050101200000000000000">29.1.2 Supported Meshes</A>
</UL>
<LI><A NAME="tex2html2189"
  HREF="node5.html#SECTION050102000000000000000">29.2 Constants</A>
<UL>
<LI><A NAME="tex2html2190"
  HREF="node5.html#SECTION050102100000000000000">29.2.1 ESMF_MESHELEMTYPE</A>
<LI><A NAME="tex2html2191"
  HREF="node5.html#SECTION050102200000000000000">29.2.2 ESMF_FILEFORMAT</A>
</UL>
<LI><A NAME="tex2html2192"
  HREF="node5.html#SECTION050103000000000000000">29.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2193"
  HREF="node5.html#SECTION050103100000000000000">29.3.1 Mesh creation</A>
<LI><A NAME="tex2html2194"
  HREF="node5.html#SECTION050103200000000000000">29.3.2 Create a small single PET Mesh in one step</A>
<LI><A NAME="tex2html2195"
  HREF="node5.html#SECTION050103300000000000000">29.3.3 Create a small single PET Mesh in three steps</A>
<LI><A NAME="tex2html2196"
  HREF="node5.html#SECTION050103400000000000000">29.3.4 Create a small Mesh on 4 PETs in one step</A>
<LI><A NAME="tex2html2197"
  HREF="node5.html#SECTION050103500000000000000">29.3.5 Create a Mesh from a SCRIP Grid file or an ESMF unstructured Grid file</A>
<LI><A NAME="tex2html2198"
  HREF="node5.html#SECTION050103600000000000000">29.3.6 Remove Mesh memory</A>
</UL>
<LI><A NAME="tex2html2199"
  HREF="node5.html#SECTION050104000000000000000">29.4 Class API</A>
<UL>
<LI><A NAME="tex2html2200"
  HREF="node5.html#SECTION050104100000000000000">29.4.1 ESMF_MeshAssignment(=)</A>
<LI><A NAME="tex2html2201"
  HREF="node5.html#SECTION050104200000000000000">29.4.2 ESMF_MeshOperator(==)</A>
<LI><A NAME="tex2html2202"
  HREF="node5.html#SECTION050104300000000000000">29.4.3 ESMF_MeshOperator(/=)</A>
<LI><A NAME="tex2html2203"
  HREF="node5.html#SECTION050104400000000000000">29.4.4 ESMF_MeshAddElements</A>
<LI><A NAME="tex2html2204"
  HREF="node5.html#SECTION050104500000000000000">29.4.5 ESMF_MeshAddNodes</A>
<LI><A NAME="tex2html2205"
  HREF="node5.html#SECTION050104600000000000000">29.4.6 ESMF_MeshCreate</A>
<LI><A NAME="tex2html2206"
  HREF="node5.html#SECTION050104700000000000000">29.4.7 ESMF_MeshCreate</A>
<LI><A NAME="tex2html2207"
  HREF="node5.html#SECTION050104800000000000000">29.4.8 ESMF_MeshCreate</A>
<LI><A NAME="tex2html2208"
  HREF="node5.html#SECTION050104900000000000000">29.4.9 ESMF_MeshDestroy</A>
<LI><A NAME="tex2html2209"
  HREF="node5.html#SECTION0501041000000000000000">29.4.10 ESMF_MeshFreeMemory</A>
<LI><A NAME="tex2html2210"
  HREF="node5.html#SECTION0501041100000000000000">29.4.11 ESMF_MeshGet</A>
</UL>
</UL>
<LI><A NAME="tex2html2211"
  HREF="node5.html#SECTION050110000000000000000">30 XGrid Class</A>
<UL>
<LI><A NAME="tex2html2212"
  HREF="node5.html#SECTION050111000000000000000">30.1 Description</A>
<LI><A NAME="tex2html2213"
  HREF="node5.html#SECTION050112000000000000000">30.2 Constants</A>
<UL>
<LI><A NAME="tex2html2214"
  HREF="node5.html#SECTION050112100000000000000">30.2.1 ESMF_XGRIDSIDE</A>
</UL>
<LI><A NAME="tex2html2215"
  HREF="node5.html#SECTION050113000000000000000">30.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2216"
  HREF="node5.html#SECTION050113100000000000000">30.3.1 Create an XGrid from user input data then use it for regridding</A>
<LI><A NAME="tex2html2217"
  HREF="node5.html#SECTION050113200000000000000">30.3.2 Query the XGrid for its internal information</A>
<LI><A NAME="tex2html2218"
  HREF="node5.html#SECTION050113300000000000000">30.3.3 Destroying the XGrid and other resources</A>
</UL>
<LI><A NAME="tex2html2219"
  HREF="node5.html#SECTION050114000000000000000">30.4 Restrictions and Future Work</A>
<UL>
<LI><A NAME="tex2html2220"
  HREF="node5.html#SECTION050114100000000000000">30.4.1 Restrictions and Future Work</A>
</UL>
<LI><A NAME="tex2html2221"
  HREF="node5.html#SECTION050115000000000000000">30.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html2222"
  HREF="node5.html#SECTION050116000000000000000">30.6 Class API</A>
<UL>
<LI><A NAME="tex2html2223"
  HREF="node5.html#SECTION050116100000000000000">30.6.1 ESMF_XGridAssignment(=)</A>
<LI><A NAME="tex2html2224"
  HREF="node5.html#SECTION050116200000000000000">30.6.2 ESMF_XGridOperator(==)</A>
<LI><A NAME="tex2html2225"
  HREF="node5.html#SECTION050116300000000000000">30.6.3 ESMF_XGridOperator(/=)</A>
<LI><A NAME="tex2html2226"
  HREF="node5.html#SECTION050116400000000000000">30.6.4 ESMF_XGridCreate</A>
<LI><A NAME="tex2html2227"
  HREF="node5.html#SECTION050116500000000000000">30.6.5 ESMF_XGridDestroy</A>
<LI><A NAME="tex2html2228"
  HREF="node5.html#SECTION050116600000000000000">30.6.6 ESMF_XGridGet</A>
<LI><A NAME="tex2html2229"
  HREF="node5.html#SECTION050116700000000000000">30.6.7 ESMF_XGridGet</A>
<LI><A NAME="tex2html2230"
  HREF="node5.html#SECTION050116800000000000000">30.6.8 ESMF_XGridGet</A>
</UL>
</UL>
<LI><A NAME="tex2html2231"
  HREF="node5.html#SECTION050120000000000000000">31 DistGrid Class</A>
<UL>
<LI><A NAME="tex2html2232"
  HREF="node5.html#SECTION050121000000000000000">31.1 Description</A>
<LI><A NAME="tex2html2233"
  HREF="node5.html#SECTION050122000000000000000">31.2 Constants</A>
<UL>
<LI><A NAME="tex2html2234"
  HREF="node5.html#SECTION050122100000000000000">31.2.1 ESMF_DISTGRIDMATCH</A>
</UL>
<LI><A NAME="tex2html2235"
  HREF="node5.html#SECTION050123000000000000000">31.3 Use and Examples</A>
<UL>
<LI><A NAME="tex2html2236"
  HREF="node5.html#SECTION050123100000000000000">31.3.1 Single tile DistGrid with regular decomposition</A>
<LI><A NAME="tex2html2237"
  HREF="node5.html#SECTION050123200000000000000">31.3.2 DistGrid and DELayout</A>
<LI><A NAME="tex2html2238"
  HREF="node5.html#SECTION050123300000000000000">31.3.3 Single tile DistGrid with decomposition by DE blocks</A>
<LI><A NAME="tex2html2239"
  HREF="node5.html#SECTION050123400000000000000">31.3.4 Single tile DistGrid with periodic boundaries</A>
<LI><A NAME="tex2html2240"
  HREF="node5.html#SECTION050123500000000000000">31.3.5 2D tilework DistGrid with regular decomposition</A>
<LI><A NAME="tex2html2241"
  HREF="node5.html#SECTION050123600000000000000">31.3.6 Arbitrary DistGrids with user-supplied sequence indices</A>
</UL>
<LI><A NAME="tex2html2242"
  HREF="node5.html#SECTION050124000000000000000">31.4 Restrictions and Future Work</A>
<LI><A NAME="tex2html2243"
  HREF="node5.html#SECTION050125000000000000000">31.5 Design and Implementation Notes</A>
<LI><A NAME="tex2html2244"
  HREF="node5.html#SECTION050126000000000000000">31.6 Class API</A>
<UL>
<LI><A NAME="tex2html2245"
  HREF="node5.html#SECTION050126100000000000000">31.6.1 ESMF_DistGridAssignment(=)</A>
<LI><A NAME="tex2html2246"
  HREF="node5.html#SECTION050126200000000000000">31.6.2 ESMF_DistGridOperator(==)</A>
<LI><A NAME="tex2html2247"
  HREF="node5.html#SECTION050126300000000000000">31.6.3 ESMF_DistGridOperator(/=)</A>
<LI><A NAME="tex2html2248"
  HREF="node5.html#SECTION050126400000000000000">31.6.4 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2249"
  HREF="node5.html#SECTION050126500000000000000">31.6.5 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2250"
  HREF="node5.html#SECTION050126600000000000000">31.6.6 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2251"
  HREF="node5.html#SECTION050126700000000000000">31.6.7 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2252"
  HREF="node5.html#SECTION050126800000000000000">31.6.8 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2253"
  HREF="node5.html#SECTION050126900000000000000">31.6.9 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2254"
  HREF="node5.html#SECTION0501261000000000000000">31.6.10 ESMF_DistGridCreate</A>
<LI><A NAME="tex2html2255"
  HREF="node5.html#SECTION0501261100000000000000">31.6.11 ESMF_DistGridDestroy</A>
<LI><A NAME="tex2html2256"
  HREF="node5.html#SECTION0501261200000000000000">31.6.12 ESMF_DistGridGet</A>
<LI><A NAME="tex2html2257"
  HREF="node5.html#SECTION0501261300000000000000">31.6.13 ESMF_DistGridGet</A>
<LI><A NAME="tex2html2258"
  HREF="node5.html#SECTION0501261400000000000000">31.6.14 ESMF_DistGridGet</A>
<LI><A NAME="tex2html2259"
  HREF="node5.html#SECTION0501261500000000000000">31.6.15 ESMF_DistGridMatch</A>
<LI><A NAME="tex2html2260"
  HREF="node5.html#SECTION0501261600000000000000">31.6.16 ESMF_DistGridPrint</A>
<LI><A NAME="tex2html2261"
  HREF="node5.html#SECTION0501261700000000000000">31.6.17 ESMF_DistGridValidate</A>
</UL>
<LI><A NAME="tex2html2262"
  HREF="node5.html#SECTION050127000000000000000">31.7 Class API: DistGridConnection Methods</A>
<UL>
<LI><A NAME="tex2html2263"
  HREF="node5.html#SECTION050127100000000000000">31.7.1 ESMF_DistGridConnectionSet</A>
</UL>
</UL>
<LI><A NAME="tex2html2264"
  HREF="node5.html#SECTION050130000000000000000">32 IO Capability</A>
<UL>
<LI><A NAME="tex2html2265"
  HREF="node5.html#SECTION050131000000000000000">32.1 Description</A>
<LI><A NAME="tex2html2266"
  HREF="node5.html#SECTION050132000000000000000">32.2 Attribute I/O</A>
<LI><A NAME="tex2html2267"
  HREF="node5.html#SECTION050133000000000000000">32.3 Data I/O</A>
<LI><A NAME="tex2html2268"
  HREF="node5.html#SECTION050134000000000000000">32.4 Data formats</A>
<LI><A NAME="tex2html2269"
  HREF="node5.html#SECTION050135000000000000000">32.5 Restrictions and Future Work</A>
<LI><A NAME="tex2html2270"
  HREF="node5.html#SECTION050136000000000000000">32.6 Design and Implementation Notes</A>
</UL>
<LI><A NAME="tex2html2271"
  HREF="node5.html#SECTION050140000000000000000">33 Overview of Distributed Data Methods</A>
<UL>
<LI><A NAME="tex2html2272"
  HREF="node5.html#SECTION050141000000000000000">33.1 Higher Level Functions</A>
<LI><A NAME="tex2html2273"
  HREF="node5.html#SECTION050142000000000000000">33.2 Lower Level Functions</A>
<LI><A NAME="tex2html2274"
  HREF="node5.html#SECTION050143000000000000000">33.3 Common Options</A>
<LI><A NAME="tex2html2275"
  HREF="node5.html#SECTION050144000000000000000">33.4 Design and Implementation Notes</A>
<LI><A NAME="tex2html2276"
  HREF="node5.html#SECTION050145000000000000000">33.5 Object Model</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION05000000000000000000">
4 Infrastructure:  Fields and Grids</A>
</H1>

<P>

<P>

<H1><A NAME="SECTION05010000000000000000">
20 Overview of Infrastructure Data Handling</A>
</H1>

The ESMF infrastructure data classes are part of the framework's 
hierarchy of structures for handling Earth system model data and 
metadata on parallel platforms.  The hierarchy is in complexity; the 
simplest data class in the infrastructure represents a distributed data
array and the most complex data class represents a bundle of physical 
fields that are discretized on the same grid.  Data class methods 
are called both from user-written code and from other classes 
internal to the framework. 

Data classes are distributed over <B>DE</B>s, or <B>Decomposition Elements</B>.  
A DE represents a piece of a decomposition.  A DELayout is a collection
of DEs with some associated connectivity that describes a specific 
distribution.  For example, the distribution of a grid divided 
into four segments in the x-dimension would be expressed in ESMF as
a DELayout with four DEs lying along an x-axis. This abstract concept 
enables a data decomposition to be defined in 
terms of threads, MPI processes, virtual decomposition elements, or
combinations of these without changes to user code.  This is a
primary strategy for ensuring optimal performance and portability
for codes using the ESMF for communications.

ESMF data classes are useful because they provide a standard, 
convenient way for developers to collect together information 
related to model or observational data.  The information assembled 
in a data class includes a data pointer, a set of attributes 
(e.g. units, although attributes can also be user-defined), and a 
description of an associated grid.  The same set of information within 
an ESMF data object can be used by the framework to arrange 
intercomponent data transfers, to perform I/O, for communications
such as gathers and scatters, for simplification of interfaces 
within user code, for debugging, and for other functions.  
This unifies and organizes codes overall so that the user need not
define different representations of metadata for the same field 
for I/O and for component coupling.  

Since it is critical that users be able to introduce ESMF into their
codes easily and incrementally, ESMF data classes can be created based 
on native Fortran pointers.  Likewise, there are methods for retrieving 
native Fortran pointers from within ESMF data objects.  This allows
the user to perform allocations using ESMF, and to retrieve Fortran
arrays later for optimized model calculations.  The ESMF data classes 
do not have associated differential operators or other mathematical 
methods.

For flexibility, it is not necessary to build an ESMF data object 
all at once.  For example, it's possible to create a 
field but to defer allocation of the associated field data until 
a later time.

<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchy of data structures designed specifically for the Earth 
system domain and high performance, parallel computing.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multi-use ESMF structures simplify user code overall.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Data objects support incremental construction and deferred allocation.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Native Fortran arrays can be associated with or retrieved from ESMF data
objects, for ease of adoption, convenience, and performance.</TD>
</TR>
</TABLE>
</DIV>
<H2><A NAME="SECTION05011000000000000000">
20.1 Infrastructure Data Classes</A>
</H2>

The main classes that are used for model and observational data manipulation
are as follows:

<UL>
<LI><B>Array</B>  An ESMF Array contains a data pointer, 
information about its associated datatype, precision, and 
dimension.  

Data elements in Arrays are partitioned into categories 
defined by the role the data element plays in distributed halo 
operations.  Haloing - sometimes called ghosting - is the 
practice of copying portions of array data to multiple memory 
locations to ensure that data dependencies can be satisfied 
quickly when performing a calculation.  ESMF Arrays contain 
an <B>exclusive</B> domain, which contains data elements
updated exclusively and definitively by a given DE; a 
<B>computational</B> domain, which contains all data elements
with values that are updated by the DE in computations; and 
a <B>total</B> domain, which includes both the computational 
domain and data elements from other DEs which may be read 
but are not updated in computations.

</LI>
<LI><B>ArrayBundle</B> ArrayBundles are collections of
Arrays that are stored in a single object.  Unlike FieldBundles,
they don't need to be distributed the same way across PETs.  The
motivation for ArrayBundles is both convenience and performance.

</LI>
<LI><B>Field</B>  A Field holds model and/or observational 
data together with its underlying grid or set of spatial 
locations.  It provides methods for configuration, 
initialization, setting and retrieving data values, 
data I/O, data regridding, and manipulation of attributes.

</LI>
<LI><B>FieldBundle</B> Groups of Fields on the same underlying 
physical grid can be collected into a single object called a FieldBundle.  
A FieldBundle provides two major functions: it allows groups of 
Fields to be manipulated using a single identifier, for example 
during export or import of data between Components; and 
it allows data from multiple Fields to be packed together 
in memory for higher locality of reference and ease in 
subsetting operations.  Packing a set of Fields into a single
FieldBundle before performing a data communication allows the set 
to be transferred at once rather than as a Field at a time.
This can improve performance on high-latency platforms.

FieldBundle objects contain methods for setting and retrieving constituent 
fields, regridding, data I/O, and reordering of data in memory.

</LI>
</UL>


<P>

<P>

<H2><A NAME="SECTION05012000000000000000">
20.2 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>In communication methods such as Regrid, Redist, Scatter, etc. 
the FieldBundle and Field code cascades down through the Array code, so 
that the actual implementation exist in only one place in the source.

<P>
</LI>
</OL>

<P>

<P>

<P>

<H1><A NAME="SECTION05020000000000000000">
21 FieldBundle Class</A>
</H1>

<P>

<H2><A NAME="SECTION05021000000000000000">
21.1 Description</A>
</H2>

<P>
A FieldBundle functions mainly as a convenient container for storing
similar Fields.  It represents ``bundles'' of Fields that are 
discretized on the same Grid, Mesh, LocStream, or XGrid and distributed in the same manner.
The FieldBundle is an important data structure because it can be added to a State, 
which is used for sending and receiving data between Components.

<P>
In the common case where FieldBundle is built on top of a Grid,
Fields within a FieldBundle may be located at different locations relative 
to the vertices of their common Grid.  The Fields in a FieldBundle may
be of different dimensions, as long as the Grid dimensions that 
are distributed are the same.  For example, a surface Field on 
a distributed lat/lon Grid and a 3D Field with an added vertical 
dimension on the same distributed lat/lon Grid can be included
in the same FieldBundle.

<P>
FieldBundles can be created and destroyed, can have Attributes 
added or retrieved, and can have Fields added, removed, replaced, or retrieved.
Methods include queries that return information about the FieldBundle
itself and about the Fields that it contains.  The Fortran 
data pointer of a Field within a FieldBundle can be obtained 
by first retrieving the Field with a call to <TT>ESMF_FieldBundleGet()</TT>,
and then using <TT>ESMF_FieldGet()</TT> to get the data.

<P>
In the future FieldBundles will serve as a mechanism for performance
optimization.  ESMF will take advantage of the similarities of the
Fields within a FieldBundle to optimize collective communication,
IO, and regridding.  See Section <A HREF="node5.html#sec:bundlerest">21.3</A> for a 
description of features that are scheduled for future work.

<P>

<H2><A NAME="SECTION05022000000000000000">
21.2 Use and Examples</A>
</H2>

<P>
Examples of creating, destroying and accessing FieldBundles and their
constituent Fields are provided in this section, along with some
notes on FieldBundle methods.

<P>

<H3><A NAME="SECTION05022100000000000000">
21.2.1 Create a FieldBundle</A>
</H3>

<P>
After creating multiple Fields by calling <TT>ESMF_FieldCreate()</TT>, a FieldBundle
can be created by passing a list of the Fields into the method 
<TT>ESMF_FieldBundleCreate()</TT>.  The FieldBundle will contain
references to the Fields.  An empty FieldBundle can also be created
and Fields added one at a time or in groups.

<P>

<H3><A NAME="SECTION05022200000000000000">
21.2.2 Access FieldBundle data</A>
</H3>

<P>
To access data in a FieldBundle the user can provide a Field
name and retrieve the Field's Fortran data pointer.  Alternatively,
the user can retrieve the data in the form of an ESMF 
Field and use the Field-level interfaces.

<P>

<H3><A NAME="SECTION05022300000000000000">
21.2.3 Destroy a FieldBundle</A>
</H3>

<P>
The user must call <TT>ESMF_FieldBundleDestroy()</TT> before 
deleting any of the Fields it contains.  Because Fields
can be shared by multiple FieldBundles and States, they are
not deleted by this call.

<P>

<P>

<P>

<P>
<I>DESCRIPTION:
<BR></I>

<P>
See the following code fragments for examples of how to create new FieldBundles.

<P>
<PRE>
 
     ! Example program showing various ways to create a FieldBundle object.
 
     program ESMF_FieldBundleCreateEx
 
     ! ESMF Framework module
     use ESMF
 
     implicit none
     
     ! Local variables
     integer :: i, rc, fieldcount
     type(ESMF_Grid) :: grid
     type(ESMF_ArraySpec) :: arrayspec
     character (len = ESMF_MAXSTR) :: bname1, fname1, fname2
     type(ESMF_Field) :: field(10), returnedfield1, returnedfield2
     type(ESMF_Field) :: simplefield
     type(ESMF_FieldBundle) :: bundle1, bundle2, bundle3
</PRE> 

<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create several Fields and add them to a new FieldBundle.
 
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
                                  regDecomp=(/2,2/), name="atmgrid", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R8, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field(1) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="pressure", rc=rc)
</PRE>

<P>
<PRE>
    field(2) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="temperature", rc=rc)
</PRE>

<P>
<PRE>
    field(3) = ESMF_FieldCreate(grid, arrayspec, &amp;
                                staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
                                name="heat flux", rc=rc)
</PRE>

<P>
<PRE>
    bundle1 = ESMF_FieldBundleCreate(fieldList=field(1:3), &amp;
				name="atmosphere data", rc=rc)

    print *, "FieldBundle example 1 returned"
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create an empty FieldBundle and then add a single field to it.


    simplefield = ESMF_FieldCreate(grid, arrayspec, &amp;
                  staggerloc=ESMF_STAGGERLOC_CENTER, name="rh", rc=rc)
</PRE>

<P>
<PRE>
    bundle2 = ESMF_FieldBundleCreate(name="time step 1", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleAdd(bundle2, (/simplefield/), rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle2, fieldCount=fieldcount, rc=rc)

    print *, "FieldBundle example 2 returned, fieldcount =", fieldcount
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Create an empty FieldBundle and then add multiple fields to it.


    bundle3 = ESMF_FieldBundleCreate(name="southern hemisphere", rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleAdd(bundle3, field(1:3), rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle3, fieldCount=fieldcount, rc=rc)

    print *, "FieldBundle example 3 returned, fieldcount =", fieldcount
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------
!   !  Get a Field back from a FieldBundle, first by name and then by index.
!   !  Also get the FieldBundle name.

    call ESMF_FieldBundleGet(bundle1, "pressure", field=returnedfield1, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldGet(returnedfield1, name=fname1, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle1, 2, returnedfield2, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldGet(returnedfield2, name=fname2, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldBundleGet(bundle1, name=bname1, rc=rc)

    print *, "FieldBundle example 4 returned, field names = ", &amp;
                   trim(fname1), ", ", trim(fname2)
    print *, "FieldBundle name = ", trim(bname1)
</PRE>

<P>
<PRE>
!-------------------------------------------------------------------------

     call ESMF_FieldBundleDestroy(bundle1, rc=rc)
</PRE>

<P>
<PRE>
     call ESMF_FieldBundleDestroy(bundle2, rc=rc)
</PRE>

<P>
<PRE>
     call ESMF_FieldBundleDestroy(bundle3, rc=rc)
</PRE>

<P>
<PRE>
     do i=1, 3
         call ESMF_FieldDestroy(field(i),rc=rc)
</PRE>

<P>
<PRE>
     enddo

     call ESMF_FieldDestroy(simplefield, rc=rc)
</PRE>

<P>
<PRE>
     end program ESMF_FieldBundleCreateEx
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05022400000000000000"></A>
   <A NAME="sec:fieldbundle:usage:redist_1dptr"></A>
<BR>
21.2.4 Redistribute data from a source FieldBundle to a destination FieldBundle
</H3>

<P>
A user can use <TT>ESMF_FieldBundleRedist</TT> interface to redistribute data from 
   source FieldBundle to destination FieldBundle. This interface is overloaded by type and kind;
   In the version of <TT>ESMF_FieldBundleRedist</TT> without factor argument, a default value
   of factor 1 is used.

<P>
In this example, we first create two FieldBundles, a source FieldBundle and a destination
   FieldBundle. Then we use <TT>ESMF_FieldBundleRedist</TT> to
   redistribute data from source FieldBundle to destination FieldBundle. 

<P>
<PRE>
    ! retrieve VM and its context info such as PET number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create distgrid and grid for field and fieldbundle creation
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
        regDecomp=(/2,2/), rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 3, ESMF_TYPEKIND_I4, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create src and dst FieldBundles pair
    srcFieldBundle = ESMF_FieldBundleCreate(rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dstFieldBundle = ESMF_FieldBundleCreate(rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create src and dst Fields and add the Fields into FieldBundles
    do i = 1, 3
        srcField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            ungriddedLBound=(/1/), ungriddedUBound=(/4/), &amp;
            totalLWidth=(/1,1/), totalUWidth=(/1,2/), &amp;
            rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        call ESMF_FieldGet(srcField(i), localDe=0, farrayPtr=srcfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        srcfptr = lpe

        call ESMF_FieldBundleAdd(srcFieldBundle, (/srcField(i)/), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        dstField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            ungriddedLBound=(/1/), ungriddedUBound=(/4/), &amp;
            totalLWidth=(/1,1/), totalUWidth=(/1,2/), &amp;
            rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        call ESMF_FieldGet(dstField(i), localDe=0, farrayPtr=dstfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        dstfptr = 0

        call ESMF_FieldBundleAdd(dstFieldBundle, (/dstField(i)/), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! perform redist
    call ESMF_FieldBundleRedistStore(srcFieldBundle, dstFieldBundle, &amp;
         routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldBundleRedist(srcFieldBundle, dstFieldBundle, &amp;
         routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify redist
    do l = 1, 3
        call ESMF_FieldGet(dstField(l), localDe=0, farrayPtr=fptr, &amp;
          exclusiveLBound=exLB, exclusiveUBound=exUB, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        ! Verify that the redistributed data in dstField is correct.
        ! Before the redist op, the dst Field contains all 0. 
        ! The redist op reset the values to the PE value, 
        ! verify this is the case.
        ! MUST use exclusive bounds because Redist operates 
        ! within excl. region.
        do k = exLB(3), exUB(3)
            do j = exLB(2), exUB(2)
                do i = exLB(1), exUB(1)
                   if(fptr(i,j,k) .ne. lpe) finalrc = ESMF_FAILURE
                enddo
            enddo
        enddo
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! release route handle
    call ESMF_FieldRedistRelease(routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldBundleDestroy(srcFieldBundle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_FieldBundleDestroy(dstFieldBundle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    do i = 1, 3
        call ESMF_FieldDestroy(srcField(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
        call ESMF_FieldDestroy(dstField(i), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo
    call ESMF_GridDestroy(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_DistGridDestroy(distgrid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05022500000000000000"></A>
   <A NAME="sec:fieldbundle:usage:smm_1dptr"></A>
<BR>
21.2.5 Perform sparse matrix multiplication from a source FieldBundle 
    to a destination FieldBundle
</H3>

<P>
A user can use <TT>ESMF_FieldBundleSMM</TT> interface to perform SMM from 
   source FieldBundle to destination FieldBundle. This interface is overloaded by type and kind;

<P>
In this example, we first create two FieldBundles, a source FieldBundle and a destination
   FieldBundle. Then we use <TT>ESMF_FieldBundleSMM</TT> to
   perform sparse matrix multiplication from source FieldBundle to destination FieldBundle.

<P>
The operation performed in this example is better illustrated in 
   section <A HREF="node5.html#sec:field:usage:smm_1dptr">22.3.36</A>.

<P>
Section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> provides a detailed discussion of the 
   sparse matrix mulitiplication operation implemented in ESMF. 

<P>
<PRE>
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create distgrid and grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        gridEdgeLWidth=(/0/), gridEdgeUWidth=(/0/), &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create field bundles and fields
    srcFieldBundle = ESMF_FieldBundleCreate(rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dstFieldBundle = ESMF_FieldBundleCreate(rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    do i = 1, 3
        srcField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            totalLWidth=(/1/), totalUWidth=(/2/), &amp;
            rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        call ESMF_FieldGet(srcField(i), localDe=0, farrayPtr=srcfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        srcfptr = 1

        call ESMF_FieldBundleAdd(srcFieldBundle, (/srcField(i)/), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        dstField(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
            totalLWidth=(/1/), totalUWidth=(/2/), &amp;
            rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        call ESMF_FieldGet(dstField(i), localDe=0, farrayPtr=dstfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        dstfptr = 0

        call ESMF_FieldBundleAdd(dstFieldBundle, (/dstField(i)/), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! initialize factorList and factorIndexList
    allocate(factorList(4))
    allocate(factorIndexList(2,4))
    factorList = (/1,2,3,4/)
    factorIndexList(1,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    factorIndexList(2,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    call ESMF_FieldBundleSMMStore(srcFieldBundle, dstFieldBundle, &amp;
        routehandle, factorList, factorIndexList, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! perform smm
    call ESMF_FieldBundleSMM(srcFieldBundle, dstFieldBundle, routehandle, &amp;
          rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify smm
    do l = 1, 3
        call ESMF_FieldGet(dstField(l), localDe=0, farrayPtr=fptr, &amp;
            exclusiveLBound=exlb, exclusiveUBound=exub, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

        ! Verify that the smm data in dstField(l) is correct.
        ! Before the smm op, the dst Field contains all 0. 
        ! The smm op reset the values to the index value, verify 
        ! this is the case.
        !write(*, '(9I3)') l, lpe, fptr
        do i = exlb(1), exub(1)
            if(fptr(i) .ne. i) finalrc = ESMF_FAILURE
        enddo
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! release SMM route handle
    call ESMF_FieldBundleSMMRelease(routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! release all acquired resources
    call ESMF_FieldBundleDestroy(srcFieldBundle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_FieldBundleDestroy(dstFieldBundle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    do l = 1, 3
        call ESMF_FieldDestroy(srcField(l), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
        call ESMF_FieldDestroy(dstField(l), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo
    call ESMF_GridDestroy(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_DistGridDestroy(distgrid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    deallocate(factorList, factorIndexList)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05022600000000000000"></A>
   <A NAME="sec:fieldbundle:usage:halo"></A>
<BR>
21.2.6 Perform FieldBundle halo update
</H3>

<P>

   <TT>ESMF_FieldBundleHalo</TT> interface can be used to perform halo update
   of all the Fields contained in the <TT>ESMF_FieldBundle</TT>.

<P>
In this example, we will set up a FieldBundle for a 2D viscous and compressible
   flow problem. We will illustrate the FieldBundle halo update operation but we will
   not solve the non-linear PDEs here. The emphasis here is to demonstrate
   how to set up halo regions, how a numerical scheme updates
   the exclusive regions, and how halo update communicates data in the halo regions. Here
   are the governing equations:

<P>
<!-- MATH
 $u_t + u u_x + v u_y + \frac{1}{\rho} p_x = 0$
 -->
<IMG
 WIDTH="186" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img14.png"
 ALT="$u_t + u u_x + v u_y + \frac{1}{\rho} p_x = 0$"> (conservation of momentum in x-direction)

<P>
<!-- MATH
 $v_t + u v_x + v v_y + \frac{1}{\rho} p_y = 0$
 -->
<IMG
 WIDTH="181" HEIGHT="37" ALIGN="MIDDLE" BORDER="0"
 SRC="img15.png"
 ALT="$v_t + u v_x + v v_y + \frac{1}{\rho} p_y = 0$"> (conservation of momentum in y-direction)

<P>
<!-- MATH
 ${\rho}_t + {\rho u}_x + {\rho v}_y = 0$
 -->
<IMG
 WIDTH="138" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img16.png"
 ALT="${\rho}_t + {\rho u}_x + {\rho v}_y = 0$"> (conservation of mass)

<P>
<!-- MATH
 $\frac{\rho}{\rho^\gamma} + u {(\frac{p}{\rho^\gamma})}_x + v {(\frac{p}{\rho^\gamma})}_y = 0$
 -->
<IMG
 WIDTH="185" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img17.png"
 ALT="$\frac{\rho}{\rho^\gamma} + u {(\frac{p}{\rho^\gamma})}_x + v {(\frac{p}{\rho^\gamma})}_y = 0$"> (conservation of energy)

<P>
The four unknowns are pressure <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$p$">, density <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$\rho$">, velocity (<IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="$u$">, <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img21.png"
 ALT="$v$">). The grids
   are set up using Arakawa D stagger (<IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$p$"> on corner, <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$\rho$"> at center, <IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="$u$"> and <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img21.png"
 ALT="$v$"> on edges).
   <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$p$">, <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$\rho$">, <IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="$u$">, and <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img21.png"
 ALT="$v$"> are bounded by necessary boundary conditions and initial conditions.

<P>
Section <A HREF="node5.html#Array:Halo">24.2.14</A> provides a detailed discussion of the 
   halo operation implemented in ESMF. 

<P>
<PRE>
    ! create distgrid and grid according to the following decomposition 
    ! and stagger pattern, r is density.
    !
    ! p--------u-------+p+-------u--------p
    ! !                 |                 |
    ! !                 |                 |
    ! !                 |                 |
    ! v        r        v        r        v
    ! !      PET 0      |      PET 1      |
    ! !                 |                 |
    ! !                 |                 |
    ! p--------u-------+p+-------u--------p
    ! !                 |                 |
    ! !                 |                 |
    ! !                 |                 |
    ! v        r        v        r        v
    ! !      PET 2      |      PET 3      |
    ! !                 |                 |
    ! !                 |                 |
    ! p--------u-------+p+-------u--------p
    !
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/256,256/), &amp;
        regDecomp=(/2,2/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create field bundles and fields
    fieldBundle = ESMF_FieldBundleCreate(rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! set up exclusive/total region for the fields
    !
    ! halo: L/U, nDim, nField, nPet
    ! halo configuration for pressure, and similarly for density, u, and v
    halo(1,1,1,1) = 0
    halo(2,1,1,1) = 0
    halo(1,2,1,1) = 0
    halo(2,2,1,1) = 0
    halo(1,1,1,2) = 1   ! halo in x direction on left hand side of pet 1
    halo(2,1,1,2) = 0
    halo(1,2,1,2) = 0
    halo(2,2,1,2) = 0
    halo(1,1,1,3) = 0
    halo(2,1,1,3) = 1   ! halo in y direction on upper side of pet 2
    halo(1,2,1,3) = 0
    halo(2,2,1,3) = 0
    halo(1,1,1,4) = 1   ! halo in x direction on left hand side of pet 3
    halo(2,1,1,4) = 1   ! halo in y direction on upper side of pet 3
    halo(1,2,1,4) = 0
    halo(2,2,1,4) = 0
</PRE>

<P>
<PRE>
    ! names and staggers of the 4 unknown fields
    names(1) = "pressure"
    names(2) = "density"
    names(3) = "u"
    names(4) = "v"
    staggers(1) = ESMF_STAGGERLOC_CORNER
    staggers(2) = ESMF_STAGGERLOC_CENTER
    staggers(3) = ESMF_STAGGERLOC_EDGE2
    staggers(4) = ESMF_STAGGERLOC_EDGE1
    
    ! create a FieldBundle
    lpe = lpe + 1
    do i = 1, 4
        field(i) = ESMF_FieldCreate(grid, arrayspec, &amp;
                totalLWidth=(/halo(1,1,i,lpe), halo(1,2,i,lpe)/), &amp;
                totalUWidth=(/halo(2,1,i,lpe), halo(2,2,i,lpe)/), &amp;
                staggerloc=staggers(i), name=names(i), &amp;
                rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
        call ESMF_FieldBundleAdd(fieldBundle, (/field(i)/), rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! compute the routehandle
    call ESMF_FieldBundleHaloStore(fieldBundle, routehandle=routehandle, &amp;
                                   rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    do iter = 1, 10
        do i = 1, 4
            call ESMF_FieldGet(field(i), farrayPtr=fptr, &amp;
                exclusiveLBound=excllb, exclusiveUBound=exclub, rc=rc)
            if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
            sizes = exclub - excllb
            ! fill the total region with 0.
            fptr = 0.
            ! only update the exclusive region on local PET
            do j = excllb(1), exclub(1)
              do k = excllb(2), exclub(2)
                fptr(j,k) = iter * cos(2.*PI*j/sizes(1))*sin(2.*PI*k/sizes(2))
              enddo 
            enddo 
        enddo
        ! call halo execution to update the data in the halo region,
        ! it can be verified that the halo regions change from 0. 
        ! to non zero values.
        call ESMF_FieldBundleHalo(fieldbundle, routehandle=routehandle, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo
    ! release halo route handle
    call ESMF_FieldBundleHaloRelease(routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<H2><A NAME="SECTION05023000000000000000">
21.3 Restrictions and Future Work</A>
</H2>

<P>
<A NAME="sec:bundlerest"></A>
<P>

<OL>
<LI><B>No mathematical operators.</B>
The FieldBundle class does not support differential or other
mathematical operators.  We do not anticipate providing this 
functionality in the near future.

<P>
</LI>
<LI><B>Limited validation and print options.</B>
We are planning to increase the number of validity checks available
for FieldBundles as soon as possible.  We also will
be working on print options.

<P>
</LI>
<LI><B>Packed data not supported.</B>
One of the options that we are currently working on for FieldBundles is
packing.  Packing means that the data from all the
Fields that comprise the FieldBundle are manipulated collectively.
This operation can be done without 
destroying the original Field data.  Packing is being designed to 
facilitate optimized regridding, data communication, and IO operations.  
This will reduce the latency overhead of the communication.  

<P>
</LI>
<LI><B>Interleaving Fields within a FieldBundle.</B>
Data locality is important for performance on some computing
platforms.  An interleave option will allow the user to create
a packed FieldBundle in which Fields are either concatenated in memory
or in which Field elements are interleaved.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION05024000000000000000">
21.4 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI><B>Fields in a FieldBundle reference the same Grid, Mesh, LocStream, or XGrid.</B>
In order to reduce memory requirements and ensure consistency, the 
Fields within a FieldBundle all reference the same Grid, Mesh, 
LocStream, or XGrid object. This restriction may be relaxed in the future.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION05025000000000000000">
21.5 Class API: Basic FieldBundle Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05025100000000000000">
21.5.1 ESMF_FieldBundleAssignment(=) - FieldBundle assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     fieldbundle1 = fieldbundle2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle) :: fieldbundle1
     type(ESMF_FieldBundle) :: fieldbundle2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign fieldbundle1 as an alias to the same ESMF fieldbundle object in memory
     as fieldbundle2. If fieldbundle2 is invalid, then fieldbundle1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldbundle1</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>fieldbundle2</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025200000000000000">
21.5.2 ESMF_FieldBundleOperator(==) - FieldBundle equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (fieldbundle1 == fieldbundle2) then ... endif
               OR
     result = (fieldbundle1 == fieldbundle2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle1
     type(ESMF_FieldBundle), intent(in) :: fieldbundle2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether fieldbundle1 and fieldbundle2 are valid aliases to the same ESMF
     fieldbundle object in memory. For a more general comparison of two ESMF FieldBundles,
     going beyond the simple alias test, the ESMF_FieldBundleMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldbundle1</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>fieldbundle2</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025300000000000000">
21.5.3 ESMF_FieldBundleOperator(/=) - FieldBundle not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (fieldbundle1 /= fieldbundle2) then ... endif
               OR
     result = (fieldbundle1 /= fieldbundle2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in) :: fieldbundle1
     type(ESMF_FieldBundle), intent(in) :: fieldbundle2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether fieldbundle1 and fieldbundle2 are <I>not</I> valid aliases to the
     same ESMF fieldbundle object in memory. For a more general comparison of two ESMF
     FieldBundles, going beyond the simple alias test, the ESMF_FieldBundleMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldbundle1</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>fieldbundle2</STRONG></DT>
<DD>The <TT>ESMF_FieldBundle</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025400000000000000">
21.5.4 ESMF_FieldBundleAdd - Add Fields to a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_FieldBundleAdd()   
     subroutine ESMF_FieldBundleAddList(fieldbundle, fieldList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)         :: fieldbundle
     type(ESMF_Field),       intent(in)            :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Add Field(s) to a FieldBundle. It is an error if <TT>fieldList</TT> contains
     Fields that match by name Fields already contained in 
     <TT>fieldbundle</TT> when multiflag
     is set to <TT>.false.</TT> and relaxedflag is set to <TT>.false.</TT>.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be added to.
     
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>List of <TT>ESMF_Field</TT> objects to be added.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be added to <TT>ESMF_FieldBundle</TT>. For <TT>.false.</TT> added items must
       have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add"
       under <TT>multiflag=.false.</TT> mode, where it is <EM>not</EM> an error if 
       <TT>fieldList</TT> contains items with names that are also found in 
       <TT>ESMF_FieldBundle</TT>. The <TT>ESMF_FieldBundle</TT> is left unchanged for these items.
       For <TT>.false.</TT> this is treated as an error condition. 
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025500000000000000">
21.5.5 ESMF_FieldBundleAddReplace - Conditionally add or replace Fields in a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleAddReplace(fieldbundle, fieldList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)         :: fieldbundle
     type(ESMF_Field),       intent(in)            :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Fields in <TT>fieldList</TT> that do not match any Fields by name in 
     <TT>fieldbundle</TT> are added to the FieldBundle. Fields in <TT>fieldList</TT>
     that match any Fields by name in <TT>fieldbundle</TT> replace those Fields.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be manipulated.
     
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>List of <TT>ESMF_Field</TT> objects to be added or used as replacement.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025600000000000000">
21.5.6 ESMF_FieldBundleCreate - Create a FieldBundle from a list of Fields</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_FieldBundleCreate(fieldList, &amp;
       multiflag, relaxedflag, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Field), intent(in),  optional :: fieldList(:)
     logical,          intent(in),  optional :: multiflag
     logical,          intent(in),  optional :: relaxedflag
     character (len=*),intent(in),  optional :: name
     integer,          intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_FieldBundle) :: ESMF_FieldBundleCreate
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_FieldBundle</TT> object from a list of existing Fields.

<P>
The creation of a FieldBundle leaves the bundled Fields unchanged, they
     remain valid individual objects. a FieldBundle is a light weight container
     of Field references. The actual data remains in place, there are no
     data movements or duplications associated with the creation of an 
     FieldBundle.

<P>
<DL>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>List of <TT>ESMF_Field</TT> objects to be bundled.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be added to <TT>fieldbundle</TT>. For <TT>.false.</TT> added items must
       have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add"
       under <TT>multiflag=.false.</TT> mode, where it is <EM>not</EM> an error if 
       <TT>fieldList</TT> contains items with names that are also found in 
       <TT>fieldbundle</TT>. The <TT>fieldbundle</TT> is left unchanged for these items.
       For <TT>.false.</TT> this is treated as an error condition. 
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the created <TT>ESMF_FieldBundle</TT>. A default name is generated
       if not specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025700000000000000">
21.5.7 ESMF_FieldBundleDestroy - Release resources associated with a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleDestroy(fieldbundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)           :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_FieldBundle</TT> object. The member Fields are not
   touched by this operation and remain valid objects that need to be 
   destroyed individually if necessary.

<P>
The arguments are:
   <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025800000000000000">
21.5.8 ESMF_FieldBundleGet - Get information about a Field by name</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_FieldBundleGet()   
     subroutine ESMF_FieldBundleGetItem(fieldbundle, fieldName, &amp;
       field, fieldCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in)            :: fieldbundle
     character(len=*),       intent(in)            :: fieldName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Field),       intent(out), optional :: field
     integer,                intent(out), optional :: fieldCount
     logical,                intent(out), optional :: isPresent
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get information about items that match <TT>fieldName</TT> in FieldBundle.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be queried.
     
</DD>
<DT><STRONG>fieldName</STRONG></DT>
<DD>Specified name.
     
</DD>
<DT><STRONG>[field]</STRONG></DT>
<DD>Upon return holds the requested field item. It is an error if this
       argument was specified and there is not exactly one field item in 
       <TT>ESMF_FieldBundle</TT> that matches <TT>fieldName</TT>.
     
</DD>
<DT><STRONG>[fieldCount]</STRONG></DT>
<DD>Number of Fields with <TT>fieldName</TT> in <TT>ESMF_FieldBundle</TT>.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Upon return indicates whether field(s) with <TT>fieldName</TT> exist
       in <TT>ESMF_FieldBundle</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05025900000000000000">
21.5.9 ESMF_FieldBundleGet - Get a list of Fields by name</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_FieldBundleGet()   
     subroutine ESMF_FieldBundleGetList(fieldbundle, fieldName, fieldList, &amp;
       rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in)            :: fieldbundle
     character(len=*),       intent(in)            :: fieldName
     type(ESMF_Field),       intent(out)           :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get the list of Fields from fieldbundle that match fieldName.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be queried.
     
</DD>
<DT><STRONG>fieldName</STRONG></DT>
<DD>Specified name.
     
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>List of Fields in <TT>ESMF_FieldBundle</TT> that match <TT>fieldName</TT>. The
       argument must be allocated to be at least of size <TT>fieldCount</TT>
       returned for this <TT>fieldName</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251000000000000000">
21.5.10 ESMF_FieldBundleGet - Get information of the FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_FieldBundleGet()   
     subroutine ESMF_FieldBundleGetListAll(fieldbundle, &amp;
       geomtype, grid, locstream, mesh, xgrid, &amp;
       fieldCount, fieldList, fieldNameList, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),  intent(in)            :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_GeomType_Flag),intent(out), optional :: geomtype
     type(ESMF_Grid),         intent(out), optional :: grid
     type(ESMF_LocStream),    intent(out), optional :: locstream
     type(ESMF_Mesh),         intent(out), optional :: mesh
     type(ESMF_XGrid),        intent(out), optional :: xgrid
     integer,                 intent(out), optional :: fieldCount
     type(ESMF_Field),        intent(out), optional :: fieldList(:)
     character(len=*),        intent(out), optional :: fieldNameList(:)
     character(len=*),        intent(out), optional :: name
     integer,                 intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get the list of all Fields and field names bundled in a FieldBundle.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> to be queried.
     
</DD>
<DT><STRONG>[geomtype]</STRONG></DT>
<DD>Flag that indicates what type of geometry this FieldBundle object holds. 
        Can be <TT>ESMF_GEOMTYPE_GRID</TT>, <TT>ESMF_GEOMTYPE_MESH</TT>, <TT>ESMF_GEOMTYPE_LOCSTREAM</TT>,
        <TT>ESMF_GEOMTYPE_XGRID</TT>
     
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD>The Grid object that this FieldBundle object holds. 
     
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>The LocStream object that this FieldBundle object holds. 
     
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>The Mesh object that this FieldBundle object holds. 
     
</DD>
<DT><STRONG>[xgrid]</STRONG></DT>
<DD>The XGrid object that this FieldBundle object holds. 
     
</DD>
<DT><STRONG>[fieldCount]</STRONG></DT>
<DD>Upon return holds the number of Fields bundled in the fieldbundle.
     
</DD>
<DT><STRONG>[fieldList]</STRONG></DT>
<DD>Upon return holds a list of Fields bundled in <TT>ESMF_FieldBundle</TT>. The
           argument must be allocated to be at least of size <TT>fieldCount</TT>.
     
</DD>
<DT><STRONG>[fieldNameList]</STRONG></DT>
<DD>Upon return holds a list of the names of the field bundled in 
           <TT>ESMF_FieldBundle</TT>. The argument must be allocated to be at least of
           size <TT>fieldCount</TT>.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the fieldbundle object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251100000000000000">
21.5.11 ESMF_FieldBundleHalo - Execute a FieldBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleHalo(fieldbundle, routehandle, &amp;
     checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(inout)           :: fieldbundle
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed FieldBundle halo operation for the Fields in FieldBundle.
     See <TT>ESMF_FieldBundleStore()</TT> on how to compute routehandle.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. The data in this 
         FieldBundle may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251200000000000000">
21.5.12 ESMF_FieldBundleHaloRelease - Release resources associated with a FieldBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleHaloRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with a FieldBundle halo operation. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251300000000000000">
21.5.13 ESMF_FieldBundleHaloStore - Precompute a FieldBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleHaloStore(fieldbundle, routehandle, &amp;
       rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)           :: fieldbundle
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle halo operation over the data in <TT>fieldbundle</TT>. 
     By definition, all elements in the total Field regions that lie
     outside the exclusive regions will be considered potential destination
     elements for halo. However, only those elements that have a corresponding
     halo source element, i.e. an exclusive element on one of the DEs, will be
     updated under the halo operation. Elements that have no associated source
     remain unchanged under halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldBundleHalo()</TT> on any FieldBundle that is weakly congruent
     and typekind conform to <TT>fieldbundle</TT>. Congruency for FieldBundles is
     given by the congruency of its constituents.
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> containing data to be haloed. The data in this 
         FieldBundle may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251400000000000000">
21.5.14 ESMF_FieldBundlePrint - Print FieldBundle internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundlePrint(fieldbundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in)              :: fieldbundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>fieldbundle</TT> object. 
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251500000000000000">
21.5.15 ESMF_FieldBundleRead - Read Fields to a FieldBundle from file(s)</A>
</H3>

<P>
<A NAME="api:FieldBundleRead"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRead(fieldbundle, file, &amp;
     singleFile, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)          :: fieldbundle
     character(*),           intent(in)             :: file
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional  :: singleFile
     type(ESMF_IOFmtFlag),   intent(in),  optional  :: iofmt
     integer,                intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Read field data to a FieldBundle object from file(s).
     For this API to be functional, the environment variable <TT>ESMF_PIO</TT> 
     should be set to "internal" when the ESMF library is built.
     Please see the section on Data I/O,&nbsp;<A HREF="node5.html#io:dataio">32.3</A>.

<P>
Limitations:
     
<UL>
<LI>Only 1 DE per PET supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
     
</DD>
<DT><STRONG>file</STRONG></DT>
<DD>The name of the file from which fieldbundle data is read.
     
</DD>
<DT><STRONG>[singleFile]</STRONG></DT>
<DD>A logical flag, the default is .true., i.e., all Fields in the bundle 
       are stored in one single file. If .false., each field is stored 
       in separate files; these files are numbered with the name based on the
       argument "file". That is, a set of files are named: [file_name]001,
       [file_name]002, [file_name]003,...
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format. Please see Section&nbsp;<A HREF="node2.html#opt:iofmtflag">9.25</A> for the list
       of options.  If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251600000000000000">
21.5.16 ESMF_FieldBundleRedist - Execute a FieldBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRedist(srcFieldBundle, dstFieldBundle, &amp;
     routehandle, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in),    optional  :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout), optional  :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical,                intent(in),    optional  :: checkflag
         integer,                intent(out),   optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed FieldBundle redistribution from <TT>srcFieldBundle</TT> to
     <TT>dstFieldBundle</TT>. Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be
     weakly congruent and typekind conform with the respective FieldBundles used during 
     <TT>ESMF_FieldBundleRedistStore()</TT>. Congruent FieldBundles possess
     matching DistGrids and the shape of the local array tiles matches between
     the FieldBundles for every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions.

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
     <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleRedistStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentations using this method see Section  
     <A HREF="node5.html#sec:fieldbundle:usage:redist_1dptr">21.2.4</A>. 

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251700000000000000">
21.5.17 ESMF_FieldBundleRedistRelease - Release resources associated with a FieldBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRedistRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with a FieldBundle redistribution. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050251800000000000000">
21.5.18 ESMF_FieldBundleRedistStore - Precompute a FieldBundle redistribution with local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleRedistStore() 
   subroutine ESMF_FieldBundleRedistStore&lt;type&gt;&lt;kind&gt;(srcFieldBundle, &amp;
     dstFieldBundle, routehandle, factor, &amp;
     srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in)             :: srcFieldBundle  
     type(ESMF_FieldBundle), intent(inout)          :: dstFieldBundle  
     type(ESMF_RouteHandle), intent(inout)          :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)           :: factor
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),   optional :: srcToDstTransposeMap(:)
     integer,                intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle redistribution operation from <TT>srcFieldBundle</TT> to <TT>dstFieldBundle</TT>. 
   PETs that
   specify a <TT>factor</TT> argument must use the &lt;type&gt;&lt;kind&gt; overloaded interface. Other 
   PETs call into the interface without <TT>factor</TT> argument. If multiple PETs specify 
   the <TT>factor</TT> argument its type and kind as well as its value must match across 
   all PETs. If none of the PETs specifies a <TT>factor</TT> argument the default will be a  
   factor of 1. 

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of <EM>sequence indices</EM>. 
   Redistribution corresponds to an identity mapping of the source FieldBundle vector to 
   the destination FieldBundle vector. 

<P>
Source and destination FieldBundles may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination FieldBundles may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle 
   and dstFieldBundle arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
   <TT>ESMF_FieldBundleRedist()</TT> on any pair of FieldBundles that are congruent and typekind 
   conform with the srcFieldBundle, dstFieldBundle pair. Congruent FieldBundles possess matching 
   DistGrids and the shape of the local array tiles matches between the FieldBundles for 
   every DE. For weakly congruent Fields the sizes of the 
   undistributed dimensions, that vary faster with memory than the first distributed 
   dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
   can be applied to a large class of similar Fields that differ in the number of 
   elements in the left most undistributed dimensions. 

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node5.html#sec:fieldbundle:usage:redist_1dptr">21.2.4</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. 
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this 
         FieldBundle may be destroyed by this call. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multiply source data.
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcFieldBundle</TT>. Each 
   entry maps the corresponding <TT>srcFieldBundle</TT> dimension 
   against the specified <TT>dstFieldBundle</TT> 
   dimension. Mixing of distributed and undistributed dimensions is supported.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050251900000000000000">
21.5.19 ESMF_FieldBundleRedistStore - Precompute a FieldBundle redistribution with local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleRedistStore() 
   subroutine ESMF_FieldBundleRedistStoreNF(srcFieldBundle, dstFieldBundle, &amp; 
          routehandle, factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in)             :: srcFieldBundle  
     type(ESMF_FieldBundle), intent(inout)          :: dstFieldBundle  
     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),   optional :: srcToDstTransposeMap(:)
     integer,                intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle redistribution operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of <EM>sequence indices</EM>. 
   Redistribution corresponds to an identity mapping of the source FieldBundle vector to 
   the destination FieldBundle vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle and dstFieldBundle 
   arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
   <TT>ESMF_FieldBundleRedist()</TT> on any pair of Fields that are congruent and typekind 
   conform with the srcFieldBundle, dstFieldBundle pair. Congruent Fields possess matching 
   DistGrids and the shape of the local array tiles matches between the Fields for 
   every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node5.html#sec:fieldbundle:usage:redist_1dptr">21.2.4</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. 
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this 
         FieldBundle may be destroyed by this call. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcFieldBundle</TT>. Each 
   entry maps the corresponding <TT>srcFieldBundle</TT> dimension 
   against the specified <TT>dstFieldBundle</TT> 
   dimension. Mixing of distributed and undistributed dimensions is supported.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050252000000000000000">
21.5.20 ESMF_FieldBundleRegrid - Execute a FieldBundle regrid operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRegrid(srcFieldBundle, dstFieldBundle, &amp;
          routehandle, zeroregion, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in),    optional  :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout), optional  :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         type(ESMF_Region_Flag), intent(in),    optional  :: zeroregion
         logical,                intent(in),    optional  :: checkflag
         integer,                intent(out),   optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed FieldBundle regrid from <TT>srcFieldBundle</TT> to
     <TT>dstFieldBundle</TT>. Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be
     congruent and typekind conform with the respective FieldBundles used during 
     <TT>ESMF_FieldBundleRegridStore()</TT>. Congruent FieldBundles possess
     matching DistGrids and the shape of the local array tiles matches between
     the FieldBundles for every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions.

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
     <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleRegridStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstFieldBundle</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstFieldBundle</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination FieldBundle that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#const:region">9.36</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252100000000000000">
21.5.21 ESMF_FieldBundleRegridRelease - Release resources associated with a FieldBundle regrid operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleRegridRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with a FieldBundle regrid operation. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252200000000000000">
21.5.22 ESMF_FieldBundleRegridStore - Precompute a FieldBundle regrid operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleRegridStore(srcFieldBundle, dstFieldBundle, &amp;
                                            srcMaskValues, dstMaskValues, &amp;
                                            regridmethod, polemethod, &amp;
                                            regridPoleNPnts,  &amp;
                                            unmappedaction, routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),        intent(in)             :: srcFieldBundle
     type(ESMF_FieldBundle),        intent(inout)          :: dstFieldBundle
     integer(ESMF_KIND_I4),         intent(in),   optional :: srcMaskValues(:)
     integer(ESMF_KIND_I4),         intent(in),   optional :: dstMaskValues(:)
     type(ESMF_RegridMethod_Flag),  intent(in),   optional :: regridmethod
     type(ESMF_PoleMethod_Flag),    intent(in),   optional :: polemethod
     integer,                       intent(in),   optional :: regridPoleNPnts
     type(ESMF_UnmappedAction_Flag),intent(in),   optional :: unmappedaction
     type(ESMF_RouteHandle),        intent(inout),optional :: routehandle
     integer,                       intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle regrid operation over the data in <TT>srcFieldBundle</TT> and
     <TT>dstFieldBundle</TT> pair. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldBundleRegrid()</TT> on any FieldBundle pairs that are weakly congruent
     and typekind conform to the FieldBundle pair used here.
     Congruency for FieldBundles is
     given by the congruency of its constituents.
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions.
     Note <TT>ESMF_FieldBundleRegridStore()</TT> assumes the coordinates used in the Grids 
     upon which the FieldBundles are built are in degrees.  

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcFieldbundle</STRONG></DT>
<DD>Source <TT>ESMF_FieldBundle</TT> containing data to be regridded.
    
</DD>
<DT><STRONG>[srcMaskValues]</STRONG></DT>
<DD>List of values that indicate a source point should be masked out. 
       If not specified, no masking will occur. 
     
</DD>
<DT><STRONG>dstFieldbundle</STRONG></DT>
<DD>Destination <TT>ESMF_FieldBundle</TT>.
    
</DD>
<DT><STRONG>[dstMaskValues]</STRONG></DT>
<DD>List of values that indicate a destination point should be masked out. 
       If not specified, no masking will occur.
    
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
      can't be mapped to a source cell. Options are 
      <TT>ESMF_UNMAPPEDACTION_ERROR</TT> or 
      <TT>ESMF_UNMAPPEDACTION_IGNORE</TT>. If not specified, defaults 
      to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. 
     
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. Please see Section&nbsp;<A HREF="node5.html#opt:regridmethod">22.2.3</A> for a list of
       valid options. If not specified, defaults to <TT>ESMF_REGRIDMETHOD_BILINEAR</TT>.
     
</DD>
<DT><STRONG>[polemethod]</STRONG></DT>
<DD>Which type of artificial pole
      to construct on the source Grid for regridding. Please see Section&nbsp;<A HREF="node5.html#const:polemethod">22.2.2</A> for a list of
      valid options. If not specified, defaults to <TT>ESMF_POLEMETHOD_ALLAVG</TT>. 
     
</DD>
<DT><STRONG>[regridPoleNPnts]</STRONG></DT>
<DD>If <TT>polemethod</TT> is <TT>ESMF_POLEMETHOD_NPNTAVG</TT>.
      This parameter indicates how many points should be averaged
      over. Must be specified if <TT>polemethod</TT> is 
      <TT>ESMF_POLEMETHOD_NPNTAVG</TT>.
     
</DD>
<DT><STRONG>[routehandle]</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252300000000000000">
21.5.23 ESMF_FieldBundleRemove - Remove Fields from FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleRemove(fieldbundle, fieldNameList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)         :: fieldbundle
     character(len=*),       intent(in)            :: fieldNameList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Remove field(s) by name from FieldBundle. In the relaxed setting it is 
     <EM>not</EM> an error if <TT>fieldNameList</TT> contains names that are not 
     found in <TT>fieldbundle</TT>.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> from which to remove items.
     
</DD>
<DT><STRONG>fieldNameList</STRONG></DT>
<DD>List of items to remove.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple Fields with the same name
       to be removed from <TT>fieldbundle</TT>. For <TT>.false.</TT>, items to be
       removed must have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "remove"
       where it is <EM>not</EM> an error if <TT>fieldNameList</TT> contains item
       names that are not found in <TT>fieldbundle</TT>. For <TT>.false.</TT> this is 
       treated as an error condition. 
       Further, in <TT>multiflag=.false.</TT> mode, the relaxed definition of
       "remove" also covers the case where there are multiple items in
       <TT>fieldbundle</TT> that match a single entry in <TT>fieldNameList</TT>.
       For <TT>relaxedflag=.false.</TT> this is treated as an error condition.
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252400000000000000">
21.5.24 ESMF_FieldBundleReplace - Replace Fields in FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldBundleReplace(fieldbundle, fieldList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(inout)         :: fieldbundle
     type(ESMF_Field),       intent(in)            :: fieldList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Replace field(s) by name in FieldBundle. In the relaxed setting it is not
     an error if <TT>fieldList</TT> contains Fields that do not match by name any
     item in <TT>fieldbundle</TT>. These Fields are simply ignored in this case.

<P>
<DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> in which to replace items.
     
</DD>
<DT><STRONG>fieldList</STRONG></DT>
<DD>List of items to replace.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be replaced in <TT>fieldbundle</TT>. For <TT>.false.</TT>, items to be
       replaced must have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "replace"
       where it is <EM>not</EM> an error if <TT>fieldList</TT> contains items with
       names that are not found in <TT>fieldbundle</TT>. These items in 
       <TT>fieldList</TT> are ignored in the relaxed mode. For <TT>.false.</TT> this
       is treated as an error condition.
       Further, in <TT>multiflag=.false.</TT> mode, the relaxed definition of
       "replace" also covers the case where there are multiple items in
       <TT>fieldbundle</TT> that match a single entry by name in <TT>fieldList</TT>.
       For <TT>relaxedflag=.false.</TT> this is treated as an error condition.
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252500000000000000">
21.5.25 ESMF_FieldBundleSMM - Execute a FieldBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleSMM(srcFieldBundle, dstFieldBundle, &amp;
         routehandle, zeroregion, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_FieldBundle), intent(in),    optional  :: srcFieldBundle
         type(ESMF_FieldBundle), intent(inout), optional  :: dstFieldBundle
         type(ESMF_RouteHandle), intent(inout)            :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         type(ESMF_Region_Flag), intent(in),    optional  :: zeroregion
         logical,                intent(in),    optional  :: checkflag
         integer,                intent(out),   optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed FieldBundle sparse matrix multiplication from <TT>srcFieldBundle</TT> to
     <TT>dstFieldBundle</TT>. Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> must be
     congruent and typekind conform with the respective FieldBundles used during 
     <TT>ESMF_FieldBundleSMMStore()</TT>. Congruent FieldBundles possess
     matching DistGrids and the shape of the local array tiles matches between
     the FieldBundles for every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
It is erroneous to specify the identical FieldBundle object for <TT>srcFieldBundle</TT> and
     <TT>dstFieldBundle</TT> arguments.

<P>
See <TT>ESMF_FieldBundleSMMStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentations using this method see Section  
     <A HREF="node5.html#sec:fieldbundle:usage:smm_1dptr">21.2.5</A>. 

<P>
<DL>
<DT><STRONG>[srcFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstFieldBundle]</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstFieldBundle</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstFieldBundle</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 

<P>
<TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination FieldBundle that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#const:region">9.36</A> for a complete list of
       valid settings.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input FieldBundle pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252600000000000000">
21.5.26 ESMF_FieldBundleSMMRelease - Release resources associated with a FieldBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleSMMRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with a FieldBundle sparse matrix multiplication. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050252700000000000000">
21.5.27 ESMF_FieldBundleSMMStore - Precompute a FieldBundle sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleSMMStore() 
   subroutine ESMF_FieldBundleSMMStore&lt;type&gt;&lt;kind&gt;(srcFieldBundle, &amp;
     dstFieldBundle,  routehandle, factorList, factorIndexList, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),   intent(in)            :: srcFieldBundle  
     type(ESMF_FieldBundle),   intent(inout)         :: dstFieldBundle  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factorList(:) 
     integer,                  intent(in),           :: factorIndexList(:,:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle sparse matrix multiplication operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with 
   <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source FieldBundle vector to 
   the destination FieldBundle vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle 
   and dstFieldBundle arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
   <TT>ESMF_FieldBundleSMM()</TT> on any pair of FieldBundles that are congruent and typekind 
   conform with the srcFieldBundle, dstFieldBundle pair. Congruent FieldBundles possess matching 
   DistGrids and the shape of the local array tiles matches between the FieldBundles for 
   every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node5.html#sec:fieldbundle:usage:smm_1dptr">21.2.5</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. 
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this 
         FieldBundle may be destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
   
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcFieldBundle</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstFieldBundle</TT>. For this format to be a valid
       option source and destination FieldBundles must have matching number of
       tensor elements (the product of the sizes of all Field tensor dimensions).
       Under this condition an identiy matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the 

<P>
<TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcFieldBundle</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstFieldBundle</TT>.

<P>
See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of 
       <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050252800000000000000">
21.5.28 ESMF_FieldBundleSMMStore - Precompute a FieldBundle sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldBundleSMMStore() 
   subroutine ESMF_FieldBundleSMMStoreNF(srcFieldBundle, dstFieldBundle, &amp; 
          routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle),   intent(in)            :: srcFieldBundle  
     type(ESMF_FieldBundle),   intent(inout)         :: dstFieldBundle  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a FieldBundle sparse matrix multiplication operation from <TT>srcFieldBundle</TT>
   to <TT>dstFieldBundle</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcFieldBundle</TT> and <TT>dstFieldBundle</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source FieldBundle vector to 
   the destination FieldBundle vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical FieldBundle object for srcFieldBundle and dstFieldBundle 
   arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
   <TT>ESMF_FieldBundleSMM()</TT> on any pair of FieldBundles that are congruent and typekind 
   conform with the srcFieldBundle, dstFieldBundle pair. Congruent FieldBundles possess matching 
   DistGrids and the shape of the local array tiles matches between the FieldBundles for 
   every DE. For weakly congruent Fields the sizes of the 
     undistributed dimensions, that vary faster with memory than the first distributed 
     dimension, are permitted to be different. This means that the same <TT>routehandle</TT> 
     can be applied to a large class of similar Fields that differ in the number of 
     elements in the left most undistributed dimensions. 

<P>
This method is overloaded for
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>, 
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node5.html#sec:fieldbundle:usage:smm_1dptr">21.2.5</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with source data. 
   
</DD>
<DT><STRONG>dstFieldBundle</STRONG></DT>
<DD><TT>ESMF_FieldBundle</TT> with destination data. The data in this 
         FieldBundle may be destroyed by this call. 
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050252900000000000000">
21.5.29 ESMF_FieldBundleValidate - Validate fieldbundle internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleValidate(fieldbundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in)              :: fieldbundle
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>fieldbundle</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>Specified <TT>ESMF_FieldBundle</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050253000000000000000">
21.5.30 ESMF_FieldBundleWrite - Write the Fields into a file</A>
</H3>

<P>
<A NAME="api:FieldBundleWrite"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldBundleWrite(fieldbundle, file, &amp;
     singleFile, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in)              :: fieldbundle
     character(*),           intent(in)              :: file
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional  :: singleFile
     integer,                intent(in),   optional  :: timeslice
     type(ESMF_IOFmtFlag),   intent(in),   optional  :: iofmt
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write the Fields into a file. For this API to be functional,
     the environment variable <TT>ESMF_PIO</TT> should be set to "internal"
     when the ESMF library is built. Please see the section on 
     Data I/O,&nbsp;<A HREF="node5.html#io:dataio">32.3</A>.

<P>
Limitations:
     
<UL>
<LI>Only 1 DE per PET supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>fieldbundle</STRONG></DT>
<DD>An <TT>ESMF_FieldBundle</TT> object.
     
</DD>
<DT><STRONG>file</STRONG></DT>
<DD>The name of the output file to which field bundle data is written.
     
</DD>
<DT><STRONG>[singleFile]</STRONG></DT>
<DD>A logical flag, the default is .true., i.e., all fields in the bundle 
       are written in one single file. If .false., each field will be written
       in separate files; these files are numbered with the name based on the
       argument "file". That is, a set of files are named: [file_name]001,
       [file_name]002, [file_name]003,...
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Some IO formats (e.g. NetCDF) support the output of data in form of
       time slices. The <TT>timeslice</TT> argument provides access to this
       capability. Usage of this feature requires that the first slice is
       written with a positive <TT>timeslice</TT> value, and that subsequent slices
       are written with a <TT>timeslice</TT> argument that increments by one each
       time. By default, i.e. by omitting the <TT>timeslice</TT> argument, no
       provisions for time slicing are made in the output file.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format. Please see Section&nbsp;<A HREF="node2.html#opt:iofmtflag">9.25</A> for the list
       of options.  If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05030000000000000000">
22 Field Class</A>
</H1>

<P>

<H2><A NAME="SECTION05031000000000000000">
22.1 Description</A>
</H2>

<P>
An ESMF Field represents a physical field, such as temperature.
The motivation for including Fields in ESMF is that bundles of 
Fields are the entities that are normally exchanged when coupling
Components.  

<P>
The ESMF Field class contains distributed and discretized field data, a reference 
to its associated grid, and metadata.  The Field class stores the grid <I>staggering</I>
for that physical field.
This is the relationship of how the data array of a field maps onto a grid 
(e.g. one item per
cell located at the cell center, one item per cell located at the NW
corner,  one item per cell vertex, etc.).  This means that different Fields
which are on the same underlying ESMF Grid but have different
staggerings can share the same Grid object without needing to replicate
it multiple times. 

<P>
Fields can be added to States for use in inter-Component
data communications.  Fields can also be added to FieldBundles,
which are groups of Fields on the same underlying Grid.  
One motivation for packing Fields into FieldBundles is convenience; 
another is the ability to perform optimized collective data transfers.  

<P>
Field communication capabilities include: data redistribution, regridding, scatter,
gather, sparse-matrix multiplication, and halo update.  These are discussed
in more detail in the documentation for the specific method calls.  
ESMF does not currently support vector fields, so the components of 
a vector field must be stored as separate Field objects.  

<P>

<H2><A NAME="SECTION05032000000000000000">
22.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05032100000000000000"></A>
<A NAME="const:fieldstatus"></A>
<BR>
22.2.1 ESMF_FIELDSTATUS
</H3>

<P>
<I>DESCRIPTION:
<BR></I>  

An ESMF_Field can be in different status after initialization. Field status can be queried using <TT>ESMF_FieldGet()</TT> method.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_FieldStatus_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_FIELDSTATUS_EMPTY</STRONG></DT>
<DD>Field is empty without geombase or data storage. Such a Field can be added to a <TT>ESMF_State</TT> and participate <TT>ESMF_StateReconcile()</TT>. 
</DD>
<DT><STRONG>ESMF_FIELDSTATUS_GRIDSET</STRONG></DT>
<DD>Field is partially created. It has a geombase object internally created and the geombase object associates with either a <TT>ESMF_Grid</TT>, or a <TT>ESMF_Mesh</TT>, or an <TT>ESMF_XGrid</TT>, or a <TT>ESMF_LocStream</TT>. It's an error to set another geombase object in such a Field. It can also be added to a <TT>ESMF_State</TT> and participate <TT>ESMF_StateReconcile()</TT>.
</DD>
<DT><STRONG>ESMF_FIELDSTATUS_COMPLETE</STRONG></DT>
<DD>Field is completely created with geombase and data storage internally allocated. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION05032200000000000000"></A>
<A NAME="const:polemethod"></A>
<BR>
22.2.2 ESMF_POLEMETHOD
</H3>

<P>
<I>DESCRIPTION:
<BR></I>  

When interpolating between two Grids which have been mapped to a sphere these can be used to specify the type of artificial pole to create on the source Grid during interpolation. Creating the pole allows destination points above the top row or below the bottom row of the source Grid to still be mapped.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_PoleMethod_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_POLEMETHOD_NONE</STRONG></DT>
<DD>No pole. Destination points which lie above the top or below the bottom row of the source Grid won't be mapped. 
</DD>
<DT><STRONG>ESMF_POLEMETHOD_ALLAVG</STRONG></DT>
<DD>Construct an artificial pole placed in the center of the top (or bottom) row of nodes, but projected onto the sphere formed by the rest of the grid. The value at this pole is the average of all the source values surrounding the pole.
</DD>
<DT><STRONG>ESMF_POLEMETHOD_NPNTAVG</STRONG></DT>
<DD>Construct an artificial pole placed in the center of the top (or bottom) row of nodes, but projected onto the sphere formed by the rest of the grid. The value at this pole is the average of the N source nodes next to the pole and surrounding the destination point (i.e. the value may differ for each destination point). Here N is set by using the <TT>regridPoleNPnts</TT> parameter and ranges from 1 to the number of nodes around the pole. This option is useful for interpolating values which may be zeroed out by averaging around the entire pole (e.g. vector components). 
</DD>
<DT><STRONG>ESMF_POLEMETHOD_TEETH</STRONG></DT>
<DD>No new pole point is constructed, instead the holes at the poles are filled by constructing triangles across the top and bottom row of the source Grid. This can be useful because no averaging occurs, however, because the top and bottom of the sphere are now flat, for a big enough mismatch between the size of the destination and source pole holes, some destination points may still not be able to be mapped to the source Grid. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION05032300000000000000"></A>
<A NAME="opt:regridmethod"></A>
<BR>
22.2.3 ESMF_REGRIDMETHOD
</H3>

<P>
<I>DESCRIPTION:
<BR></I>  
Specify which interpolation method to use during regridding. 

<P>
The type of this flag is:

<P>
<TT>type(ESMF_RegridMethod_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_REGRIDMETHOD_BILINEAR</STRONG></DT>
<DD>Bilinear interpolation. Destination value is a linear combination of the source values in the cell which contains the destination point. The weights for the linear combination are based on the distance of destination point from each source value. 
</DD>
<DT><STRONG>ESMF_REGRIDMETHOD_PATCH</STRONG></DT>
<DD>Higher-order patch recovery interpolation. Destination value is a weighted average of 2D polynomial patches constructed from cells surrounding the source cell which contains the destination point. This method typically results in better approximations to values and derivatives than bilinear. However, because of its larger stencil, it also results in a much larger interpolation matrix (and thus routeHandle) than the bilinear. 
</DD>
<DT><STRONG>ESMF_REGRIDMETHOD_CONSERVE</STRONG></DT>
<DD>First order conservative interpolation. Value of a destination cell is the weighted sum of the values of the source cells that it overlaps. The weights are determined by the amount the source cell overlaps the destination cell. Will typically give less accurate approximations to values than the other interpolation methods, however, will do a much better job preserving the integral of the value between the source and destination.  Needs corner coordinate values to be provided in the Grid. Currently only works for Fields created on the Grid center stagger (or the Mesh element location). 
</DD>
</DL>

<P>

<H2><A NAME="SECTION05033000000000000000">
22.3 Use and Examples</A>
</H2>

<P>
A Field serves as an annotator of data, since it carries 
a description of the grid it is associated with and metadata 
such as name and units.  Fields can be used in this capacity
alone, as convenient, descriptive containers into which arrays 
can be placed and retrieved.  However, for most codes the primary 
use of Fields is in the context of import and export States,
which are the objects that carry coupling information between 
Components.  Fields enable data to be self-describing, and a
State holding ESMF Fields contains data in a standard format
that can be queried and manipulated.  

<P>
The sections below go into more detail about Field usage.

<P>

<H3><A NAME="SECTION05033100000000000000">
22.3.1 Field create and destroy</A>
</H3>

<P>
Fields can be created and destroyed at any time during 
application execution.  However, these Field methods require 
some time to complete.  We do not recommend that the user
create or destroy Fields inside performance-critical 
computational loops.

<P>
All versions of the <TT>ESMF_FieldCreate()</TT> 
routines require a Grid object as input, or require a Grid
be added before most operations involving Fields can be performed.
The Grid contains the information needed to know which 
Decomposition Elements (DEs) are participating in 
the processing of this Field, and which subsets of the data
are local to a particular DE.

<P>
The details of how the create process happens depends 
on which of the variants of the <TT>ESMF_FieldCreate()</TT> 
call is used.  Some of the variants are discussed below.

<P>
There are versions of the <TT>ESMF_FieldCreate()</TT> interface
which create the Field based on the input Grid.  The ESMF
can allocate the proper amount of 
space but not assign initial values.  The user code
can then get the pointer to the uninitialized buffer and 
set the initial data values.

<P>
Other versions of the <TT>ESMF_FieldCreate()</TT> interface
allow user code to attach arrays that have already been
allocated by the user.  Empty Fields can also be created in
which case the data can be added at some later time.

<P>
For versions of Create which do not specify data values,
user code can create an ArraySpec object, which
contains information about the typekind and rank of the
data values in the array.  Then at Field create time, the
appropriate amount of memory is allocated to contain the
data which is local to each DE.

<P>
When finished with a <TT>ESMF_Field</TT>, the <TT>ESMF_FieldDestroy</TT> method
removes it.  However, the objects inside the <TT>ESMF_Field</TT>
created externally should be destroyed separately, 
since objects can be added to
more than one <TT>ESMF_Field</TT>.  For example, the same <TT>ESMF_Grid</TT>
can be referenced by multiple <TT>ESMF_Field</TT>s.  In this case the
internal Grid is not deleted by the <TT>ESMF_FieldDestroy</TT> call.

<P>

<P>

<P>

<H3><A NAME="SECTION05033200000000000000"></A>
  <A NAME="sec:field:usage:field_get_dataptr"></A>
<BR>
22.3.2 Get Fortran data pointer, bounds, and counts information from a Field
</H3>

<P>
A user can get bounds and counts information from an <TT>ESMF_Field</TT>
    through the <TT>ESMF_FieldGet()</TT> interface.  Also available through this interface
    is the intrinsic
    Fortran data pointer contained in the internal <TT>ESMF_Array</TT> object
    of an <TT>ESMF_Field</TT>. The bounds and counts information are DE specific
    for the associated Fortran data pointer.

<P>
For a better discussion of the terminologies, bounds and widths in ESMF
    e.g. exclusive, computational, total bounds
    for the lower and upper corner of data region, etc.., user can refer to 
    the explanation of these concepts for Grid and Array in their respective sections 
    in the <I>Reference Manual</I>, e.g. Section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> on Array
    and Section <A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> on Grid.

<P>
In this example, we first create a 3D Field based on a 3D Grid and Array.
    Then we use the <TT>ESMF_FieldGet()</TT> interface to retrieve the data pointer,
    potentially updating or verifying its values. We also retrieve the bounds and counts
    information of the 3D Field to assist in data element iteration.

<P>
<PRE>
    xdim = 180
    ydim = 90
    zdim = 50

    ! create a 3D data Field from a Grid and Array.
    ! first create a Grid 
    grid3d = ESMF_GridCreateNoPeriDim(minIndex=(/1,1,1/), &amp;
            maxIndex=(/xdim,ydim,zdim/), &amp;
            regDecomp=(/2,2,1/), name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGet(grid=grid3d, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
           distgrid=distgrid3d, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGetFieldBounds(grid=grid3d, localDe=0, &amp;
        staggerloc=ESMF_STAGGERLOC_CENTER, totalCount=fa_shape, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    allocate(farray(fa_shape(1), fa_shape(2), fa_shape(3)) )

    ! create an Array 
    array3d = ESMF_ArrayCreate(distgrid3d, farray, &amp;
	indexflag=ESMF_INDEX_DELOCAL, rc=rc) 
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a Field
    field = ESMF_FieldCreate(grid=grid3d, array=array3d, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    ! retrieve the Fortran data pointer from the Field
    call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farray1, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! retrieve the Fortran data pointer from the Field and bounds
    call ESMF_FieldGet(field=field, localDe=0, farrayPtr=farray1, &amp;
        computationalLBound=compLBnd, computationalUBound=compUBnd, &amp;
        exclusiveLBound=exclLBnd, exclusiveUBound=exclUBnd, &amp;
        totalLBound=totalLBnd, totalUBound=totalUBnd, &amp;
        computationalCount=comp_count, &amp;
        exclusiveCount=excl_count, &amp;
        totalCount=total_count, &amp;
        rc=rc)   

    ! iterate through the total bounds of the field data pointer
    do k = totalLBnd(3), totalUBnd(3)
        do j = totalLBnd(2), totalUBnd(2)
            do i = totalLBnd(1), totalUBnd(1)
                farray1(i, j, k) = sin(2*i/total_count(1)*PI) + &amp;
                    sin(4*j/total_count(2)*PI) + &amp;
                    sin(8*k/total_count(2)*PI)
            enddo
        enddo
    enddo
</PRE>

<P>

<H3><A NAME="SECTION05033300000000000000"></A>
  <A NAME="sec:field:usage:field_get_default"></A>
<BR>
22.3.3 Get Grid, Array, and other information from a Field
</H3>

<P>
A user can get the internal <TT>ESMF_Grid</TT> and <TT>ESMF_Array</TT> 
    from a <TT>ESMF_Field</TT>.  Note that the user should not issue any destroy command
    on the retrieved grid or array object since they are referenced
    from within the <TT>ESMF_Field</TT>. The retrieved objects should be used
    in a read-only fashion to query additional information not directly
    available through the <TT>ESMF_FieldGet()</TT> interface.

<P>
<PRE>
    call ESMF_FieldGet(field, grid=grid, array=array, &amp;
        typekind=typekind, dimCount=dimCount, staggerloc=staggerloc, &amp;
        gridToFieldMap=gridToFieldMap, &amp;
        ungriddedLBound=ungriddedLBound, ungriddedUBound=ungriddedUBound, &amp;
        totalLWidth=totalLWidth, totalUWidth=totalUWidth, &amp; 
        name=name, &amp;
        rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05033400000000000000"></A>
  <A NAME="sec:field:usage:create_grid_tkr"></A>
<BR>
22.3.4 Create a Field with a Grid, typekind, and rank
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> from an <TT>ESMF_Grid</TT> and
    typekind/rank.
    This create method associates the two objects.  

<P>
We first create a Grid with a regular distribution that is
    10x20 index in 2x2 DEs.  This version of Field create simply
    associates the data with the Grid.  The data is referenced
    explicitly on a regular 2x2 uniform grid. 
    Finally we create a Field from
    the Grid, typekind, rank, and a user specified StaggerLoc.

<P>
This example also illustrates a typical use of this Field creation
    method. By creating a Field from a Grid and typekind/rank, the
    user allows the ESMF library to create a internal Array in the Field.
    Then the user can use <TT>ESMF_FieldGet()</TT> to retrieve the Fortran
    data array
    and necessary bounds information to assign initial values to it. 

<P>
<PRE>
    ! create a grid
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a Field from the Grid and arrayspec
    field1 = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_R4, &amp;
        indexflag=ESMF_INDEX_DELOCAL, &amp;
        staggerloc=ESMF_STAGGERLOC_CENTER, name="pressure", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(field1, localDe=0, farrayPtr=farray2dd, &amp;
        totalLBound=ftlb, totalUBound=ftub, totalCount=ftc, rc=rc)

    do i = ftlb(1), ftub(1)
        do j = ftlb(2), ftub(2)
            farray2dd(i, j) = sin(i/ftc(1)*PI) * cos(j/ftc(2)*PI) 
        enddo
    enddo

    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION05033500000000000000"></A>
  <A NAME="sec:field:usage:create_grid_arrayspec"></A>
<BR>
22.3.5 Create a Field with a Grid and Arrayspec
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> from an <TT>ESMF_Grid</TT> and a
    <TT>ESMF_Arrayspec</TT> with corresponding rank and type.  
    This create method associates the two objects.  

<P>
We first create a Grid with a regular distribution that is
    10x20 index in 2x2 DEs.  This version of Field create simply
    associates the data with the Grid.  The data is referenced
    explicitly on a regular 2x2 uniform grid. 
    Then we create an ArraySpec.  Finally we create a Field from
    the Grid, ArraySpec, and a user specified StaggerLoc.

<P>
This example also illustrates a typical use of this Field creation
    method. By creating a Field from a Grid and an ArraySpec, the
    user allows the ESMF library to create a internal Array in the Field.
    Then the user can use <TT>ESMF_FieldGet()</TT> to retrieve the Fortran
    data array
    and necessary bounds information to assign initial values to it. 

<P>
<PRE>
    ! create a grid
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! setup arrayspec
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a Field from the Grid and arrayspec
    field1 = ESMF_FieldCreate(grid, arrayspec, &amp;
         indexflag=ESMF_INDEX_DELOCAL, &amp;
         staggerloc=ESMF_STAGGERLOC_CENTER, name="pressure", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(field1, localDe=0, farrayPtr=farray2dd, &amp;
        totalLBound=ftlb, totalUBound=ftub, totalCount=ftc, rc=rc)

    do i = ftlb(1), ftub(1)
        do j = ftlb(2), ftub(2)
            farray2dd(i, j) = sin(i/ftc(1)*PI) * cos(j/ftc(2)*PI) 
        enddo
    enddo

    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
A user can also create an ArraySpec that has a different rank
     from the Grid, For example, the following code shows creation of 
     of 3D Field from a 2D Grid using a 3D ArraySpec.

<P>
This example also demonstrates the technique to create a typical
     3D data Field that has 2 gridded dimensions and 1 ungridded
     dimension. 

<P>
First we create a 2D grid with an index space of 180x360 equivalent to
     180x360 Grid cells (note that for a distributed memory computer, this
     means each 
     grid cell will be on a separate PE!). In the FieldCreate call, we use gridToFieldMap
     to indicate the mapping between Grid dimension and Field dimension.
     For the ungridded dimension (typically the altitude), we use
     ungriddedLBound and ungriddedUBound to describe its bounds. Internally
     the ungridded dimension has a stride of 1, so the number of elements
     of the ungridded dimension is ungriddedUBound - ungriddedLBound + 1.

<P>
Note that gridToFieldMap in this specific example is (/1,2/) which
     is the default value
     so the user can neglect this argument for the FieldCreate call. 

<P>
<PRE>
    grid2d = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), &amp;
          maxIndex=(/180,360/), regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 3, ESMF_TYPEKIND_R4, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field1 = ESMF_FieldCreate(grid2d, arrayspec, &amp;
         indexflag=ESMF_INDEX_DELOCAL, &amp;
         staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
         gridToFieldMap=(/1,2/), &amp;
         ungriddedLBound=(/1/), ungriddedUBound=(/50/), &amp;
         name="pressure", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION05033600000000000000"></A>
  <A NAME="sec:field:usage:create_grid_array"></A>
<BR>
22.3.6 Create a Field with a Grid and Array
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> from an <TT>ESMF_Grid</TT> and a 
    <TT>ESMF_Array</TT>. The Grid was created in the previous example.

<P>
This example creates a 2D <TT>ESMF_Field</TT> from a 2D <TT>ESMF_Grid</TT>
    and a 2D <TT>ESMF_Array</TT>. 

<P>
<PRE>
    ! Get necessary information from the Grid
    call ESMF_GridGet(grid, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
        distgrid=distgrid, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a 2D ESMF_TYPEKIND_R4 arrayspec
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_R4, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a ESMF_Array from the arrayspec and distgrid
    array2d = ESMF_ArrayCreate(arrayspec=arrayspec, &amp;
            distgrid=distgrid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a ESMF_Field from the grid and array
    field4 = ESMF_FieldCreate(grid, array2d, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION05033700000000000000"></A>
  <A NAME="sec:field:usage:partial_creation"></A>
<BR>
22.3.7 Create an empty Field and complete it
   with FieldEmptySet and FieldEmptyComplete
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> in three steps: first create an empty 
    <TT>ESMF_Field</TT>; then set a <TT>ESMF_Grid</TT> on the empty <TT>ESMF_Field</TT>;
    and finally complete the <TT>ESMF_Field</TT> by calling <TT>ESMF_FieldEmptyComplete</TT>.

<P>
<PRE>
    ! create an empty Field
    field3 = ESMF_FieldEmptyCreate(name="precip", rc=rc)
</PRE>

<P>
<PRE>
    ! use FieldGet to retrieve the Field Status
    call ESMF_FieldGet(field3, status=fstatus, rc=rc)
</PRE>

<P>
Once the Field is created, we can verify that the status of the Field
    is <TT>ESMF_FIELDSTATUS_EMPTY</TT>. 

<P>
<PRE>
    ! Test the status of the Field
    if(fstatus /= ESMF_FIELDSTATUS_EMPTY) finalrc = ESMF_FAILURE
</PRE>

<P>
Next we set a Grid on the empty Field. We use the 2D grid created in
    a previous example simply to demonstrate the method. The Field data points
    will be on east edge of the Grid cells with the specified
    <TT>ESMF_STAGGERLOC_EDGE1</TT>. 

<P>
<PRE>
    ! Set a grid on the Field
    call ESMF_FieldEmptySet(field3, grid2d, &amp;
             staggerloc=ESMF_STAGGERLOC_EDGE1, rc=rc)
</PRE>

<P>
<PRE>
    ! use FieldGet to retrieve the Field Status again
    call ESMF_FieldGet(field3, status=fstatus, rc=rc)
</PRE>

<P>
<PRE>
    ! Test the status of the Field
    if(fstatus /= ESMF_FIELDSTATUS_GRIDSET) finalrc = ESMF_FAILURE
</PRE>

<P>
The partially created Field is completed by specifying the typekind of its
     data storage. This method is overloaded with one of the
     following parameters, arrayspec, typekind, Fortran array, or Fortran array pointer.
     Additional optional arguments can be used to specify ungridded dimensions and
     halo regions similar to the other Field creation methods.  

<P>
<PRE>
    ! Complete the Field by specifying the data typekind 
    ! to be allocated internally.
    call ESMF_FieldEmptyComplete(field3, typekind=ESMF_TYPEKIND_R8, &amp;
      ungriddedLBound=(/1/), ungriddedUBound=(/5/), rc=rc)
</PRE>

<P>
<PRE>
    ! use FieldGet to retrieve the Field Status again
    call ESMF_FieldGet(field3, status=fstatus, rc=rc)
</PRE>

<P>
<PRE>
    ! Test the status of the Field
    if(fstatus /= ESMF_FIELDSTATUS_COMPLETE) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION05033800000000000000"></A>
  <A NAME="sec:field:usage:create_empty"></A>
<BR>
22.3.8 Create an empty Field and complete it with FieldEmptyComplete
</H3>

<P>
A user can create an empty <TT>ESMF_Field</TT>.
    Then the user can finalize the empty <TT>ESMF_Field</TT> from a <TT>ESMF_Grid</TT> 
    and a intrinsic 
    Fortran data array. This interface is overloaded for typekind and rank
    of the Fortran data array.

<P>
In this example, both grid and Fortran array pointer are 2 dimensional
    and each dimension index maps in order, i.e. 1st dimension of grid maps to
    1st dimension of Fortran array pointer, 2nd dimension of grid maps to 2nd dimension of
    Fortran array pointer, so on and so forth. 

<P>
In order to create or complete a Field from a Grid and a Fortran array pointer, 
    certain rules of the Fortran array bounds must be obeyed. We will discuss these
    rules as we progress in Field creation examples.  We will make
    frequent reference to the terminologies for bounds and widths in ESMF. 
    For a better discussion of
    these terminologies and concepts behind them, 
    e.g. exclusive, computational, total bounds
    for the lower and upper corner of data region, etc.., users can refer to 
    the explanation of these concepts for Grid and Array in their respective sections 
    in the <I>Reference Manual</I>, e.g. Section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> on Array
    and Section <A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> on Grid.
    The examples here are designed to help a user to get up to speed with
    creating Fields for typical use.

<P>
This example introduces a helper method, the <TT>ESMF_GridGetFieldBounds</TT>
    interface that facilitates the computation of Fortran data array bounds
    and shape to assist <TT>ESMF_FieldEmptyComplete</TT> finalizing a Field from a
    instrinsic Fortran data array and a Grid.

<P>
<PRE>
    ! create an empty Field
    field3 = ESMF_FieldEmptyCreate(name="precip", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! use FieldGet to retrieve total counts 
    call ESMF_GridGetFieldBounds(grid2d, localDe=0, &amp;
        staggerloc=ESMF_STAGGERLOC_CENTER, totalCount=ftc, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! allocate the 2d Fortran array based on retrieved total counts
    allocate(farray2d(ftc(1), ftc(2)))

    ! finalize the Field
    call ESMF_FieldEmptyComplete(field3, grid2d, farray2d, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05033900000000000000"></A>
  <A NAME="sec:field:usage:create_5dgrid_7dptr_2dungridded"></A>
<BR>
22.3.9 Create a 7D Field with a 5D Grid and 2D ungridded bounds
   from a Fortran data array
</H3>

<P>
In this example, we will show how to create a 7D Field from a 5D <TT>   ESMF_Grid</TT> and 2D ungridded bounds with arbitrary halo widths and 
   gridToFieldMap.

<P>
We first create a 5D DistGrid and a 5D Grid based on the DistGrid; then
   <TT>ESMF_GridGetFieldBounds</TT> computes the shape of a 7D array in fsize. We can then
   create a 7D Field from the 5D Grid and the 7D Fortran data array with
   other assimilating parameters. 

<P>
<PRE>
    ! create a 5d distgrid
    distgrid5d = ESMF_DistGridCreate(minIndex=(/1,1,1,1,1/), &amp;
        maxIndex=(/10,4,10,4,6/), regDecomp=(/2,1,2,1,1/), rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a 5d Grid
    grid5d = ESMF_GridCreate(distgrid=distgrid5d, name="grid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! use FieldGet to retrieve total counts 
    call ESMF_GridGetFieldBounds(grid5d, localDe=0, ungriddedLBound=(/1,2/), &amp;
        ungriddedUBound=(/4,5/), &amp;
        totalLWidth=(/1,1,1,2,2/), totalUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        totalCount=fsize, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! allocate the 7d Fortran array based on retrieved total counts
    allocate(farray7d(fsize(1), fsize(2), fsize(3), fsize(4), fsize(5), &amp;
			fsize(6), fsize(7)))

    ! create the Field
    field7d = ESMF_FieldCreate(grid5d, farray7d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/1,2/), ungriddedUBound=(/4,5/), &amp;
        totalLWidth=(/1,1,1,2,2/), totalUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
A user can allocate the Fortran array in a different manner using the lower and
    upper bounds returned from FieldGet through the optional totalLBound and totalUBound
    arguments. In the following example, we create another 7D Field by retrieving the bounds
    and allocate the Fortran array with this approach. In this scheme, indexing the
    Fortran array is sometimes more convenient than using the shape directly. 

<P>
<PRE>
    call ESMF_GridGetFieldBounds(grid5d, localDe=0, ungriddedLBound=(/1,2/), &amp;
        ungriddedUBound=(/4,5/), &amp;
        totalLWidth=(/1,1,1,2,2/), totalUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        totalLBound=flbound, totalUBound=fubound, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    allocate(farray7d2(flbound(1):fubound(1), flbound(2):fubound(2), &amp;
		       flbound(3):fubound(3), flbound(4):fubound(4), &amp;
		       flbound(5):fubound(5), flbound(6):fubound(6), &amp;
                       flbound(7):fubound(7)) )

    field7d2 = ESMF_FieldCreate(grid5d, farray7d2, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/1,2/), ungriddedUBound=(/4,5/), &amp;
        totalLWidth=(/1,1,1,2,2/), totalUWidth=(/1,2,3,4,5/), &amp;
        gridToFieldMap=(/3,2,5,4,1/), &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050331000000000000000"></A>
  <A NAME="sec:field:usage:create_2darray"></A>
<BR>
22.3.10 Create a 2D Field with a 2D Grid and a Fortran data array
</H3>

<P>
A user can create an <TT>ESMF_Field</TT> directly from an <TT>ESMF_Grid</TT> and an intrinsic 
    Fortran data array. This interface is overloaded for typekind and rank
    of the Fortran data array.  

<P>
In the following example, each dimension size of the Fortran array is equal to the 
    exclusive bounds of its corresponding 
    Grid dimension queried from the Grid through <TT>ESMF_GridGet()</TT> public interface.

<P>
Formally let fa_shape(i) be the shape of i-th dimension of user supplied Fortran array,
    then rule 1 states:  
    <PRE>
   
    (1) fa_shape(i) = exclusiveCount(i)         
                  i = 1...GridDimCount
</PRE>

<P>
fa_shape(i) defines the shape of i-th dimension of the Fortran array.
    ExclusiveCount are the number of data elements of i-th dimension in the exclusive region queried
    from <TT>ESMF_GridGet</TT> interface. <EM>Rule 1 assumes that the Grid and the Fortran intrinsic
    array have same number of dimensions; and optional arguments
    of FieldCreate from Fortran array are left unspecified using default setup</EM>. These assumptions 
    are true for most typical use of FieldCreate from Fortran data array. This is the easiest way
    to create a Field from a Grid and Fortran intrinsic data array.

<P>
Fortran array dimension sizes (called shape in most Fortran language books) are equivalent
    to the bounds and counts used in this manual.  The following equation holds: 
    <PRE>
   
    fa_shape(i) = shape(i) = counts(i) = upper_bound(i) - lower_bound(i) + 1
</PRE>

<P>
These typically mean the same concept unless specifically explained to mean something else.
    For example, ESMF uses DimCount very often to mean number of dimensions instead of its meaning
    implied in the above equation. We'll clarify the meaning of a word when ambiguity could occur.

<P>
Rule 1 is most useful for a user working with Field creation from a Grid and a Fortran
    data array in most scenarios. It extends to higher dimension count, 3D, 4D, etc...
    Typically, as the code example demonstrates, a user first creates a Grid 
    , then uses <TT>ESMF_GridGet()</TT>
    to retrieve the exclusive counts.  Next the user calculates the shape
    of each Fortran array dimension according to rule 1. The Fortran data array is allocated
    and initialized based on the computed shape.  A Field can either be created in one shot
    created empty and finished using <TT>ESMF_FieldEmptyComplete</TT>.

<P>
There are important details that can be skipped but are good to know for <TT>ESMF_FieldEmptyComplete</TT>
    and <TT>ESMF_FieldCreate</TT> from a Fortran data array. 1) these methods require <EM>each PET contains
    exactly one DE</EM>. This implies that a code using FieldCreate from a data array or FieldEmptyComplete must
    have the same number of DEs and PETs, formally <!-- MATH
 $n_{DE} = n_{PET}$
 -->
<IMG
 WIDTH="98" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img22.png"
 ALT="$n_{DE} = n_{PET}$">. Violation of this condition
    will cause run time failures. 2) the bounds and counts retrieved from GridGet are DE specific
    or equivalently PET specific, which means that <EM>the Fortran array shape could be different from one
    PET to another</EM>.

<P>
<PRE>
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
          regDecomp=(/2,2/), name="atmgrid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGet(grid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
        exclusiveCount=gec, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    allocate(farray(gec(1), gec(2)) )

    field = ESMF_FieldCreate(grid, farray, ESMF_INDEX_DELOCAL, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050331100000000000000"></A>
  <A NAME="sec:field:usage:create_2dptr"></A>
<BR>
22.3.11 Create a 2D Field with a 2D Grid and a Fortran data pointer
</H3>

<P>
The setup of this example is similar to the previous section except 
   that the Field is created from a data pointer instead of a data array.
   We highlight the ability to deallocate the internal fortran data
   pointer queried from the Field. This gives a user more flexibility with
   memory management.

<P>
<PRE>
    allocate(farrayPtr(gec(1), gec(2)) )

    field = ESMF_FieldCreate(grid, farrayPtr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_FieldGet(field, farrayPtr=farrayPtr2, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    ! deallocate the retrieved fortran array pointer
    deallocate(farrayPtr2)
</PRE>

<P>

<H3><A NAME="SECTION050331200000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr"></A>
<BR>
22.3.12 Create a 3D Field with a 2D Grid and a 3D Fortran data array
</H3>

<P>
This example demonstrates a typical use of <TT>ESMF_Field</TT> combining
    a 2D grid and a 3D Fortran native data array. One immediate problem follows: 
    how does one define the bounds of the ungridded dimension? This is
    solved by the optional arguments <TT>ungriddedLBound</TT> and <TT>ungriddedUBound</TT>
    of the <TT>ESMF_FieldCreate</TT> interface. By definition, <TT>ungriddedLBound</TT>
    and <TT>ungriddedUBound</TT>
    are both 1 dimensional integer Fortran arrays.

<P>
Formally, let fa_shape(j=1...FieldDimCount-GridDimCount) be the shape of the
    ungridded dimensions of a Field relative to the Grid used in Field creation.
    The Field dimension count is equal to the number of dimensions of the Fortran array, which
    equals the number of dimensions of the resultant Field. GridDimCount is
    the number of dimensions of the Grid. 

<P>
fa_shape(j) is computed as:
    <PRE>
   
    fa_shape(j) = ungriddedUBound(j) - ungriddedLBound(j) + 1
</PRE>

<P>
fa_shape is easy to compute when the gridded and ungridded dimensions do not
    mix. However, it's conceivable that at higher dimension count, gridded and ungridded
    dimensions can interleave. To aid the computation of ungridded dimension shape
    we formally introduce the mapping concept.

<P>
Let <!-- MATH
 $map_{A,B}(i=1...n_A) = i_B$
 -->
<IMG
 WIDTH="179" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img23.png"
 ALT="$map_{A,B}(i=1...n_A) = i_B$">, and <!-- MATH
 $i_B \in [\phi, 1...n_B]$
 -->
<IMG
 WIDTH="109" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$i_B \in [\phi, 1...n_B]$">. <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$n_A$"> is the number
    of elements in set A, <IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img26.png"
 ALT="$n_B$"> is the number of elements in set B. <IMG
 WIDTH="79" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img27.png"
 ALT="$map_{A,B}(i)$"> defines
    a mapping from i-th element of set A to <IMG
 WIDTH="23" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img28.png"
 ALT="$i_B$">-th element in set B. <IMG
 WIDTH="53" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img29.png"
 ALT="$i_B = \phi$"> 
    indicates there does not exist a mapping from i-th element of set A to set B.

<P>
Suppose we have a mapping from dimension index of ungriddedLBound (or
    ungriddedUBound) to Fortran array dimension index, called ugb2fa. 
    By definition, <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$n_A$"> equals to the dimension count of
    ungriddedLBound (or ungriddedUBound), <IMG
 WIDTH="27" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img26.png"
 ALT="$n_B$"> equals to the dimension count of
    the Fortran array. We can now formulate the computation of ungridded
    dimension shape as rule 2:
    <PRE>
   
    (2) fa_shape(ugb2fa(j)) = ungriddedUBound(j) - ungriddedLBound(j) + 1 
                          j = 1..FortranArrayDimCount - GridDimCount
</PRE>

<P>
The mapping can be computed in linear time proportional to the
    Fortran array dimension count (or rank) using the following algorithm in pseudocode:
    <PRE>
  
    map_index = 1
    do i = 1, farray_rank
        if i-th dimension of farray is ungridded
            ugb2fa(map_index) = i
            map_index = map_index + 1
        endif
    enddo
</PRE>

<P>
Here we use rank and dimension count interchangably. These 2 terminologies are typically
    equivalent. But there are subtle differences
    under certain conditions. Rank is the total number of dimensions of a tensor object.
    Dimension count allows a finer description of the heterogeneous dimensions in that object.
    For example, A Field of rank 5 can have 3 gridded dimensions and 2 ungridded dimensions.
    Rank is precisely the summation of dimension count of all types of dimensions. 

<P>
For example, if a 5D array is used with a 3D Grid, there are 2 ungridded dimensions:
    ungriddedLBound=(/1,2/) and ungriddedUBound=(/5,7/).
    Suppose the distribution of dimensions look like (O, X, O, X, O), O means gridded,
    X means ungridded. Then the mapping from ungridded bounds to Fortran array is
    ugb2fa=(/2, 4/). The shape of 2nd and 4th dimension of Fortran array should equal
    (5, 8).

<P>
Back to our 3D Field created from a 2D Grid and 3D Fortran array example, suppose the 3rd
    Field dimension is ungridded, ungriddedLBound=(/3/), ungriddedUBound=(/9/).
    First we use rule 1 to compute shapes of the gridded Fortran array dimension,
    then we use rule 2 to compute shapes of the ungridded Fortran array dimension.
    In this example, we used the exclusive bounds obtained in the previous
    example. 

<P>
<PRE>
    fa_shape(1) = gec(1) ! rule 1
    fa_shape(2) = gec(2)
    fa_shape(3) = 7 ! rule 2 9-3+1
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050331300000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr_map"></A>
<BR>
22.3.13 Create a 3D Field with a 2D Grid and a 3D Fortran data array with gridToFieldMap argument
</H3>

<P>
Building upon the previous example, we will create a 3D Field from
    a 2D grid and 3D array but with a slight twist. In this example, we
    introduce the gridToFieldMap argument that allows a user to map Grid 
    dimension index to Field dimension index.

<P>
In this example, both dimensions of the Grid are distributed and the
    mapping from DistGrid to Grid is (/1,2/). We will introduce rule 3
    assuming distgridToGridMap=(/1,2,3...gridDimCount/), and distgridDimCount equals
    to gridDimCount. This is a reasonable assumption in typical Field use.

<P>
We apply the mapping gridToFieldMap on rule 1 to create rule 3:
    <PRE>
   
    (3) fa_shape(gridToFieldMap(i)) = exclusiveCount(i)        
                                  i = 1,..GridDimCount.
</PRE>

<P>
Back to our example, suppose the 2nd
    Field dimension is ungridded, ungriddedLBound=(/3/), ungriddedUBound=(/9/).
    gridToFieldMap=(/3,1/), meaning the 1st Grid dimension maps to 3rd Field dimension,
    and 2nd Grid dimension maps to 1st Field dimension.

<P>
First we use rule 3 to compute shapes of the gridded Fortran array dimension,
    then we use rule 2 to compute shapes of the ungridded Fortran array dimension.
    In this example, we use the exclusive bounds obtained in the previous
    example. 

<P>
<PRE>
    gridToFieldMap2d(1) = 3
    gridToFieldMap2d(2) = 1
    do i = 1, 2
        fa_shape(gridToFieldMap2d(i)) = gec(i)
    end do
    fa_shape(2) = 7
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        gridToFieldMap=gridToFieldMap2d, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050331400000000000000"></A>
  <A NAME="sec:field:usage:create_2dgrid_3dptr_map_halo"></A>
<BR>
22.3.14 Create a 3D Field with a 2D Grid and a 3D Fortran data array with halos
</H3>

<P>
This example is similar to example <A HREF="node5.html#sec:field:usage:create_2dgrid_3dptr_map">22.3.13</A>, 
    in addition we will show
    a user can associate different halo width to a Fortran array to create
    a Field through the totalLWidth and totalUWidth optional arguments.
    A diagram of the dimension configuration from Grid, halos, and Fortran data array
    is shown here.
  <DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:fieldparameter"></A><A NAME="13780"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 12:</STRONG>
Field dimension configuration from Grid, halos, and Fortran data array.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{FieldParameterSetup}}$
 -->
<IMG
 WIDTH="683" HEIGHT="736" ALIGN="BOTTOM" BORDER="0"
 SRC="img30.png"
 ALT="\scalebox{0.75}{\includegraphics{FieldParameterSetup}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The <TT>ESMF_FieldCreate()</TT> interface supports creating a Field from a Grid and a
    Fortran array padded with halos on the distributed dimensions of the Fortran
    array. Using this technique one can avoid passing non-contiguous Fortran array
    slice to FieldCreate. It guarantees the same exclusive region,
    and by using halos, it also defines a bigger total region to contain 
    the entire contiguous memory block of the Fortran array.

<P>
The elements of totalLWidth and totalUWidth are applied in the order
    distributed dimensions appear in the Fortran array. By definition, 
    totalLWidth and totalUWidth are 1 dimensional arrays of non-negative 
    integer values. The size of haloWidth arrays is equal to the number of distributed
    dimensions of the Fortran array, which is also equal to the number of
    distributed dimensions of the Grid used in the Field creation.

<P>
Because the order of totalWidth (representing both totalLWidth and
    totalUWidth) element is applied to the order distributed dimensions
    appear in the Fortran array dimensions, it's quite simple to compute
    the shape of distributed dimensions of the Fortran array. They are done
    in a similar manner when applying ungriddedLBound and ungriddedUBound 
    to ungridded dimensions of the Fortran array defined by rule 2.

<P>
Assume we have the mapping from the dimension index of totalWidth
    to the dimension index of Fortran array, called mhw2fa; and we also
    have the mapping from dimension index of Fortran array to dimension
    index of the Grid, called fa2g. The shape of
    distributed dimensions of a Fortran array can be computed by rule 4: 

<P>
<PRE>
  
    (4) fa_shape(mhw2fa(k)) = exclusiveCount(fa2g(mhw2fa(k)) + 
                              totalUWidth(k) + totalLWidth(k)
                          k = 1...size(totalWidth)
</PRE>

<P>
This rule may seem confusing but algorithmically the computation
    can be done by the following pseudocode:

<P>
<PRE>
  
    fa_index = 1
    do i = 1, farray_rank
       if i-th dimension of Fortran array is distributed
           fa_shape(i) = exclusiveCount(fa2g(i)) + 
                         totalUWidth(fa_index) + totalLWidth(fa_index)
           fa_index = fa_index + 1
       endif
    enddo
</PRE>

<P>
The only complication then is to figure out the mapping from Fortran
    array dimension index to Grid dimension index. This process can
    be done by computing the reverse mapping from Field to Grid.

<P>
Typically, we don't have to consider these complications if the following
    conditions are met: 1) All Grid dimensions are distributed. 2) DistGrid
    in the Grid has a dimension index mapping to the Grid in the form of 
    natural order (/1,2,3,.../). This natural order mapping is the
    default mapping between various objects throughout ESMF. 3) Grid to Field
    mapping is in the form of natural order, i.e. default mapping. These
    seem like a lot of conditions but they are the default case in the interaction
    among DistGrid, Grid, and Field. When these conditions are met, which
    is typically true, the shape of distributed dimensions of Fortran array
    follows rule 5 in a simple form:

<P>
<PRE>
  
    (5) fa_shape(k) = exclusiveCount(k) + 
                      totalUWidth(k) + totalLWidth(k) 
                  k = 1...size(totalWidth)
</PRE>

<P>
Let's examine an example on how to apply rule 5. Suppose we have a
    5D array and a 3D Grid that has its first 3 dimensions mapped to the first
    3 dimensions of the Fortran array. totalLWidth=(/1,2,3/), 
    totalUWidth=(/7,9,10/), then by rule 5, the following pseudo code
    can be used to compute the shape of the first 3 dimensions of the Fortran
    array. The shape of the remaining two ungridded dimensions can be
    computed according to rule 2.

<P>
<PRE>
  
    do k = 1, 3
        fa_shape(k) = exclusiveCount(k) + 
                      totalUWidth(k) + totalLWidth(k)) 
    enddo
</PRE>

<P>
Suppose now gridToFieldMap=(/2,3,4/) instead which says
    the first dimension of Grid maps to the 2nd dimension of Field (or 
    Fortran array) and so on and so forth, we can obtain a more general form 
    of rule 5 by introducing first_distdim_index shift when Grid to Field
    map (gridToFieldMap) is in the form of (/a,a+1,a+2.../).

<P>
<PRE>
  
    (6) fa_shape(k+first_distdim_index-1) = exclusiveCount(k) +
                                            totalUWidth(k) + totalLWidth(k)
                                        k = 1...size(totalWidth)
</PRE>

<P>
It's obvious that first_distdim_index=a. If the first dimension of the Fortran
    array is distributed, then rule 6 degenerates into rule 5, which is
    the typical case.

<P>
Back to our example creating a 3D Field from a 2D Grid and a 3D intrinsic
    Fortran array, we will use the Grid created from previous example
    that satisfies condition 1 and 2. We'll also use a simple gridToFieldMap
    (1,2) which is the default mapping that satisfies condition 3. 
    First we use rule 5 to compute
    the shape of distributed dimensions then we use rule 2 to compute the shape
    of the ungridded dimensions. 

<P>
<PRE>
    gridToFieldMap2d(1) = 1
    gridToFieldMap2d(2) = 2
    totalLWidth2d(1) = 3
    totalLWidth2d(2) = 4
    totalUWidth2d(1) = 3
    totalUWidth2d(2) = 5
    do k = 1, 2
        fa_shape(k) = gec(k) + totalLWidth2d(k) + totalUWidth2d(k)
    end do
    fa_shape(3) = 7          ! 9-3+1
    allocate(farray3d(fa_shape(1), fa_shape(2), fa_shape(3)))
    field = ESMF_FieldCreate(grid, farray3d, ESMF_INDEX_DELOCAL, &amp;
        ungriddedLBound=(/3/), ungriddedUBound=(/9/), &amp;
        totalLWidth=totalLWidth2d, totalUWidth=totalUWidth2d, &amp;
        gridToFieldMap=gridToFieldMap2d, &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050331500000000000000"></A>
  <A NAME="sec:field:usage:create_locs_tkr"></A>
<BR>
22.3.15 Create a Field from a LocStream, typekind, and rank
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_LocStream</TT> 
   and typekind/rank.
   The location stream object is uniformly distributed
   in a 1 dimensional space on 4 DEs. The rank is 1 dimensional. 
   Please refer to LocStream examples section for more information on LocStream creation.

<P>
<PRE>
    locs = ESMF_LocStreamCreate(minIndex=1, maxIndex=16, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field = ESMF_FieldCreate(locs, typekind=ESMF_TYPEKIND_I4, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050331600000000000000"></A>
  <A NAME="sec:field:usage:create_locs_arrayspec"></A>
<BR>
22.3.16 Create a Field from a LocStream and arrayspec
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_LocStream</TT> 
   and an <TT>ESMF_Arrayspec</TT>.
   The location stream object is uniformly distributed
   in a 1 dimensional space on 4 DEs. The arrayspec is 1 dimensional. 
   Please refer to LocStream examples section for more information on LocStream creation.

<P>
<PRE>
    locs = ESMF_LocStreamCreate(minIndex=1, maxIndex=16, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field = ESMF_FieldCreate(locs, arrayspec, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050331700000000000000"></A>
  <A NAME="sec:field:usage:create_mesh_tkr"></A>
<BR>
22.3.17 Create a Field from a Mesh, typekind, and rank
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT> 
   and typekind/rank.
   The mesh object is on a Euclidean surface that is partitioned to a 2x2 rectangular
   space with 4 elements and 9 nodes. The nodal space is represented by
   a distgrid with 9 indices. Field is created on locally owned nodes on each PET.
   Therefore, the created Field has 9 data points globally.
   The mesh object can be represented by the picture
   below. For more information on Mesh creation, please see Section&nbsp;<A HREF="node5.html#sec:mesh:usage:meshCreation">29.3.1</A>.
   <PRE>
                Mesh Ids
  
    2.0   7 ------- 8 -------- 9
          |         |          |
          |    3    |    4     |
          |         |          |
    1.0   4 ------- 5 -------- 6
          |         |          |
          |    1    |    2     |
          |         |          |
    0.0   1 ------- 2 -------- 3
  
         0.0       1.0        2.0 
  
        Node Ids at corners
        Element Ids in centers
   
  
               Mesh Owners
  
    2.0   2 ------- 2 -------- 3
          |         |          |
          |    2    |    3     |
          |         |          |
    1.0   0 ------- 0 -------- 1
          |         |          |
          |    0    |    1     |
          |         |          |
    0.0   0 ------- 0 -------- 1
  
         0.0       1.0        2.0 
  
        Node Owners at corners
        Element Owners in centers
</PRE> 

<P>
<PRE>
      ! Create Mesh structure in 1 step
      mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
             nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
             nodeOwners=nodeOwners, elementIds=elemIds,&amp;
             elementTypes=elemTypes, elementConn=elemConn, &amp;
             rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

      ! Field is created on the 1 dimensinonal nodal distgrid. On
      ! each PET, Field is created on the locally owned nodes.
      field = ESMF_FieldCreate(mesh, typekind=ESMF_TYPEKIND_I4, rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050331800000000000000"></A>
  <A NAME="sec:field:usage:create_mesh_arrayspec"></A>
<BR>
22.3.18 Create a Field from a Mesh and arrayspec
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT> 
   and an <TT>ESMF_Arrayspec</TT>.
   The mesh object is on a Euclidean surface that is partitioned to a 2x2 rectangular
   space with 4 elements and 9 nodes. The nodal space is represented by
   a distgrid with 9 indices. Field is created on locally owned nodes on each PET.
   Therefore, the created Field has 9 data points globally.
   The mesh object can be represented by the picture
   below. For more information on Mesh creation, please see Section&nbsp;<A HREF="node5.html#sec:mesh:usage:meshCreation">29.3.1</A>.

<P>
<PRE>
      ! Create Mesh structure in 1 step
      mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
             nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
             nodeOwners=nodeOwners, elementIds=elemIds,&amp;
             elementTypes=elemTypes, elementConn=elemConn, &amp;
             rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

      call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_I4, rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

      ! Field is created on the 1 dimensinonal nodal distgrid. On
      ! each PET, Field is created on the locally owned nodes.
      field = ESMF_FieldCreate(mesh, arrayspec, rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050331900000000000000"></A>
  <A NAME="sec:field:usage:create_mesh_array"></A>
<BR>
22.3.19 Create a Field from a Mesh and an Array
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT> 
   and an <TT>ESMF_Array</TT>. The mesh object is created in the previous example and
   the array object is retrieved from the field created in the previous example too.

<P>
<PRE>
    call ESMF_MeshGet(mesh, nodalDistgrid=distgrid, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    array = ESMF_ArrayCreate(distgrid=distgrid, arrayspec=arrayspec, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    ! query the array from the previous example
    call ESMF_FieldGet(field, array=array, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    ! create a Field from a mesh and an array
    field1 = ESMF_FieldCreate(mesh, array, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<H3><A NAME="SECTION050332000000000000000"></A>
  <A NAME="sec:field:usage:createMeshArrayspecOpt"></A>
<BR>
22.3.20 Create a Field from a Mesh and an ArraySpec with optional features
</H3>

<P>
In this example, an <TT>ESMF_Field</TT> is created from an <TT>ESMF_Mesh</TT>
   and an <TT>ESMF_ArraySpec</TT>. The mesh object is created in the previous example.
   The Field is also created with optional arguments such as ungridded dimensions
   and dimension mapping.

<P>
In this example, the mesh is mapped to the 2nd dimension of the
   <TT>ESMF_Field</TT>, with its first dimension being the ungridded dimension with bounds 1,3.

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, 2, ESMF_TYPEKIND_I4, rc=rc)
    field = ESMF_FieldCreate(mesh, arrayspec=arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/3/), rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050332100000000000000"></A>
  <A NAME="sec:field:usage:create_repdim"></A>
<BR>
22.3.21 Create a Field with replicated dimensions
</H3>

<P>
In this example an <TT>ESMF_Field</TT> with replicated dimension is created from an <TT>ESMF_Grid</TT> and 
    an <TT>ESMF_Arrayspec</TT>. A user can also use other <TT>ESMF_FieldCreate()</TT> methods to create replicated
    dimension Field, this example illustrates the key concepts and use of a replicated dimension Field.

<P>
Normally gridToFieldMap argument in <TT>ESMF_FieldCreate()</TT> should not contain
    0 value entries. However, for Field with replicated dimension, a 0 entry in gridToFieldMap
    indicates the corresponding Grid dimension is replicated in the Field. In such a Field,
    the rank of the Field is no longer necessarily greater than its Grid rank.
    An example will make this clear. We will start by creating Distgrid and Grid.

<P>
<PRE>
    ! create 4D distgrid
    distgrid = ESMF_DistGridCreate(minIndex=(/1,1,1,1/), &amp;
        maxIndex=(/6,4,6,4/), regDecomp=(/2,1,2,1/), rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create 4D grid on top of the 4D distgrid
    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create 3D arrayspec
    call ESMF_ArraySpecSet(arrayspec, 3, ESMF_TYPEKIND_R8, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
In this example, a user creates a 3D Field with replicated dimension
   replicated along the 2nd and 4th dimension of its underlying 4D Grid. 
   In addition, the 2nd dimension of the Field is ungridded (why?). The 1st and
   3rd dimensions of the Field have halos. 

<P>
<PRE>
    ! create field, 2nd and 4th dimensions of the Grid are replicated
    field = ESMF_FieldCreate(grid, arrayspec, indexflag=ESMF_INDEX_DELOCAL, &amp;
        gridToFieldMap=(/1,0,2,0/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/4/), &amp;
        totalLWidth=(/1,1/), totalUWidth=(/4,5/), &amp;
        staggerloc=ESMF_STAGGERLOC_CORNER, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! get basic information from the field
    call ESMF_FieldGet(field, grid=grid1, array=array, typekind=typekind, &amp;
        dimCount=dimCount, staggerloc=lstaggerloc, &amp;
        gridToFieldMap=lgridToFieldMap, ungriddedLBound=lungriddedLBound, &amp;
        ungriddedUBound=lungriddedUBound, totalLWidth=ltotalLWidth, &amp;
        totalUWidth=ltotalUWidth, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! get bounds information from the field
    call ESMF_FieldGet(field, localDe=0, farrayPtr=farray, &amp;
        exclusiveLBound=felb, exclusiveUBound=feub, exclusiveCount=fec, &amp;
        computationalLBound=fclb, computationalUBound=fcub, &amp;
        computationalCount=fcc, totalLBound=ftlb, totalUBound=ftub, &amp;
        totalCount=ftc, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Next we verify that the field and array bounds agree with each other 

<P>
<PRE>
    call ESMF_ArrayGet(array, rank=arank, dimCount=adimCount, rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    gridrank_repdim = 0
    do i = 1, size(gridToFieldMap)
        if(gridToFieldMap(i) == 0) gridrank_repdim = gridrank_repdim + 1
    enddo
</PRE>

<P>
Number of undistributed dimension of the array <I>X</I> is computed from
   total rank of the array <I>A</I>, the dimension count of its underlying distgrid
   <I>B</I> and number of replicated dimension in the distgrid <I>C</I>. 
   We have the following formula: X = A - (B - C) 

<P>
<PRE>
    allocate(audlb(arank-adimCount+gridrank_repdim), &amp;
	audub(arank-adimCount+gridrank_repdim))
    call ESMF_ArrayGet(array, exclusiveLBound=aelb, exclusiveUBound=aeub, &amp;
        computationalLBound=aclb, computationalUBound=acub, &amp;
        totalLBound=atlb, totalUBound=atub, &amp;
        undistLBound=audlb, undistUBound=audub, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    
    ! verify the ungridded bounds from field match 
    ! undistributed bounds from its underlying array
    do i = 1, arank-adimCount
        if(lungriddedLBound(i) .ne. audlb(i) ) &amp;
            rc = ESMF_FAILURE
    enddo
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    do i = 1, arank-adimCount
        if(lungriddedUBound(i) .ne. audub(i) ) &amp;
            rc = ESMF_FAILURE
    enddo
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
We then verify the data in the replicated dimension Field can be updated and accessed. 

<P>
<PRE>
    do ik = ftlb(3), ftub(3)
     do ij = ftlb(2), ftub(2)
      do ii = ftlb(1), ftub(1)
        farray(ii,ij,ik) = ii+ij*2+ik
      enddo
     enddo
    enddo
    ! access and verify
    call ESMF_FieldGet(field, localDe=0, farrayPtr=farray1, &amp;
        rc=rc)
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE
    do ik = ftlb(3), ftub(3)
     do ij = ftlb(2), ftub(2)
      do ii = ftlb(1), ftub(1)
        n = ii+ij*2+ik
        if(farray1(ii,ij,ik) .ne. n ) rc = ESMF_FAILURE
      enddo
     enddo
    enddo
    if (rc.NE.ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! release resources
    call ESMF_FieldDestroy(field)
    call ESMF_GridDestroy(grid)
    call ESMF_DistGridDestroy(distgrid)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050332200000000000000"></A>
  <A NAME="sec:field:usage:createArbGrid"></A>
<BR>
22.3.22 Create a Field on an arbitrarily distributed Grid
</H3>

<P>
With the introduction of Field on arbitrarily distributed Grid, Field has two kinds of dimension
    count: one associated geometrical (or physical) dimensionality, the other one associated with its
    memory index space representation. Field and Grid dimCount reflect the physical index 
    space of the objects. A new type of dimCount  rank should be added to both of these entities. 
    rank gives the number of dimensions of the memory index space of the objects.
    This would be the dimension of the pointer pulled out of Field and the
    size of the bounds vector, for example. 

<P>
For non-arbitrary Grids rank=dimCount, but for grids and fields with
    arbitrary dimensions rank = dimCount - (number of Arb dims) + 1
    (Internally Field can use the Arb info from the grid to create the mapping
    from the Field Array to the DistGrid)

<P>
When creating a Field size(GridToFieldMap)=dimCount for both Arb and Non-arb grids
    This array specifies the mapping of Field to Grid identically for both Arb and Nonarb grids 
    If a zero occurs in an entry corresponding to any arbitrary dimension, then
    a zero must occur in every entry corresponding to an arbitrary dimension (i.e.
    all arbitrary dimensions must either be all replicated or all not replicated,
    they can't be broken apart).

<P>
In this example an <TT>ESMF_Field</TT> is created from an arbitrarily distributed <TT>ESMF_Grid</TT> and 
    an <TT>ESMF_Arrayspec</TT>. A user can also use other <TT>ESMF_FieldCreate()</TT> methods to create 
    such a Field, this example illustrates the key concepts and use of Field on arbitrary distributed Grid.

<P>
The Grid is 3 dimensional in physics index space but the first two dimension are collapsed into
    a single memory index space. Thus the result Field is 3D in physics index space and 2D in memory index
    space. This is made obvious with the 2D arrayspec used to create this Field.

<P>
<PRE>
    ! create a 3D grid with the first 2 dimensions collapsed 
    ! and arbitrarily distributed
    grid3d = ESMF_GridCreateNoPeriDim(coordTypeKind=ESMF_TYPEKIND_R8, &amp;
      minIndex=(/1,1,1/), maxIndex=(/xdim, ydim,zdim/), &amp;
      arbIndexList=localArbIndex,arbIndexCount=localArbIndexCount, &amp;
      name="arb3dgrid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a 2D arrayspec
    call ESMF_ArraySpecSet(arrayspec2D, rank=2, typekind=ESMF_TYPEKIND_R4, &amp;
         rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create a 2D Field using the Grid and the arrayspec
    field = ESMF_FieldCreate(grid3d, arrayspec2D, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    call ESMF_FieldGet(field, rank=rank, dimCount=dimCount, &amp;
                       rc=rc)
    if (myPet .eq. 0) print *, 'Field rank, dimCount', &amp;
                                rank, dimCount
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    ! verify that the dimension counts are correct
    if (rank .ne. 2) correct = .false.
    if (dimCount .ne. 3) correct = .false.
</PRE>

<P>

<H3><A NAME="SECTION050332300000000000000"></A>
  <A NAME="sec:field:usage:createArbGridRep"></A>
<BR>
22.3.23 Create a Field on an arbitrarily distributed Grid with replicated dimensions &amp; ungridded bounds
</H3>

<P>
The next example is slightly more complicated in
    that the Field also contains ungridded dimension and its gridded dimension
    is replicated on the arbitrarily distributed dimension of the Grid.

<P>
The same 3D Grid and 2D arrayspec in the previous example
    are used but a gridToFieldMap argument
    is supplied to the <TT>ESMF_FieldCreate()</TT> call. The first 2 entries of
    the map are 0, the last (3rd) entry is 1. The 3rd dimension of the Grid is
    mapped to the first dimension of the Field, this dimension is then replicated
    on the arbitrarily distributed dimensions of the Grid. In addition, the
    Field also has one ungridded dimension. Thus the final dimension count of the
    Field is 2 in both physics and memory index space.

<P>
<PRE>
    field = ESMF_FieldCreate(grid3d, arrayspec2D,gridToFieldMap=(/0,0,1/), &amp;
            ungriddedLBound=(/1/), ungriddedUBound=(/10/),rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    call ESMF_FieldGet(field, rank=rank, dimCount=dimCount, &amp;
                       rc=rc)
    if (myPet .eq. 0) print *, 'Field rank, dimCount', &amp;
                                rank, dimCount
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    if (rank .ne. 2) correct = .false.
    if (dimCount .ne. 2) correct = .false.
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050332400000000000000">
22.3.24 Field regridding</A>
</H3>

<P>
The Field regrid operation moves data between Fields which lie on different Grids. In order to do this the data in
   the source Field is interpolated to the destination Grid and then put into the destination Field. In ESMF the regrid operation
   is implemented as a sparse matrix multiply. The <TT>ESMF_FieldRegridStore()</TT> call generates the sparse matrix for
   the regrid operation. This matrix may be either retrieved in a factor and index raw form, or may be retrieved in the form
   of a routeHandle which contains an internal representation of the communication and mathermatical operations necessary to 
   perform the regrid. Note <TT>ESMF_FieldRegridStore()</TT> assumes the latitude and longitude coordinates of the grid
   are in degrees.  The routeHandle can then be used in an <TT>ESMF_FieldRegrid()</TT> call to perform the interpolation
   between the two Fields. The routeHandle depends only on the coordinates in the Grids where the Fields are built, so 
   as long as the coordinates stay the same, the operation can be performed multiple times using the same routeHandle. This is true
   even if the Field data changes. The same routeHandle may also be used to interpolate between any source and destination Field 
   which lie on the same stagger location and Grid as the original Fields. 
   When it's no longer needed the routeHandle should be destroyed by using <TT>ESMF_FieldRegridRelease()</TT> to free the memory it's using.  

<P>
There are two options for accessing ESMF regridding functionality: online and offline.  Online regridding means that the 
   weights are generated via subroutine calls during the execution of the users code. This is the method described in the following 
   sections. Offline regridding means that the weights are generated by a seperate application from the user code. Please see 
   Section&nbsp;<A HREF="node3.html#sec:ESMF_RegridWeightGen">12</A> for a description of the offline regridding application and the options it supports.

<P>
ESMF currently supports regridding only on a subset of the full range of Grids and Meshes it supports. 

<P>
In 2D ESMF supports regridding between any combination of the following:
   
<UL>
<LI>Structured Grids composed of a single logically rectangular patch
</LI>
<LI>Unstructured Meshes composed of any combination of triangles and quadralaterals (e.g. rectangles)
   
</LI>
</UL>

<P>
In 3D ESMF supports regridding between any combination of the following:
   
<UL>
<LI>Structured Grids composed of a single logically rectangular patch
</LI>
<LI>Unstructured Meshes composed of hexahedrons (e.g. cubes). 
   
</LI>
</UL>
   Note that regridding involving tetrahedra is currently NOT supported. 

<P>
In terms of masking, ESMF regrid currently supports masking for Fields built on structured Grids. The user may mask out points in 
   the source Field or destination Field or both. The user also has the option to return an error for unmapped destination points or
   to ignore them. At this point ESMF does not support extrapolation to destination points outside the unmasked source Field. 

<P>
ESMF currently supports three options for interpolation: bilinear, patch, and conservative. 
   Bilinear interpolation calculates the value for the 
   destination point as a combination of multiple linear interpolations, one for each dimension of the Grid. Note that for ease of 
   use, the term bilinear interpolation is used for 3D interpolation in ESMF as well, although it should more properly be referred 
   to as trilinear interpolation.

<P>
Patch (or higher-order) interpolation is the ESMF version of a techique called ``patch recovery'' commonly
   used in finite element modeling&nbsp;[<A
 HREF="node8.html#PatchInterp1">5</A>]&nbsp;[<A
 HREF="node8.html#PatchInterp2">10</A>]. It typically results in better approximations to 
   values and derivatives when compared to bilinear interpolation.
   Patch interpolation works by constructing multiple polynomial patches to represent
   the data in a source cell. For 2D grids, these polynomials
   are currently 2nd degree 2D polynomials. One patch is constructed for each corner of the source cell, and the patch is constructed 
   by doing a least squared fit through the data in the cells surrounding the corner. The interpolated value at the destination point is 
   then a weighted average of the values of the patches at that point. The patch method has a larger
   stencil than the bilinear, for this reason the patch weight matrix can be correspondingly larger
   than the bilinear matrix (e.g. for a quadrilateral grid the patch matrix is around 4x the size of
   the bilinear matrix). This can be an issue when performing a regrid operation close to the memory
   limit on a machine. 

<P>
First-order conservative interpolation&nbsp;[<A
 HREF="node8.html#ConservativeOrder1">19</A>] is also available as a regridding method. This method will 
   typically have  a larger interpolation error than the previous two methods, but will do a much better job of preserving the 
   value of the integral of data between the source and destination grid. In this method the value across each source cell
   is treated as a constant. The weights for a particular destination cell, are the area of intersection of each 
   source cell with the destination cell divided by the area of the destination cell.
   Areas in this case are the great circle areas of the polygons which make up the cells (the cells around each center are 
   defined by the corner coordinates in the grid file). To use this method the user must have created their Fields on the center 
   stagger location (<TT>ESMF_STAGGERLOC_CENTER</TT>) for Grids  or the element location (<TT>ESMF_MESHLOC_ELEMENT</TT>) for Meshes.
   For Grids, the corner stagger location (<TT>ESMF_STAGGERLOC_CORNER</TT>) must contain coordinates describing the outer perimeter of the
   Grid cells. Currently conservative interpolation is only supported for 2D Grids and Meshes. 

<P>
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="14374"></A>
<TABLE>
<CAPTION><STRONG>Table 1:</STRONG>
Comparison of the offline vs. online regridding capabilities of ESMF</CAPTION>
<TR><TD>  <DIV ALIGN="CENTER">  <BR>
  <TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="CENTER">Online</TD>
<TD ALIGN="CENTER">Offline</TD>
</TR>
<TR><TD ALIGN="LEFT">2D Polygons</TD>
<TD ALIGN="LEFT">Triangles</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Quadrilaterals</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">3D Polygons</TD>
<TD ALIGN="LEFT">Hexahedrons</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">Regridding</TD>
<TD ALIGN="LEFT">Bilinear</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Patch</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Conservative (1st order)</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">Masking</TD>
<TD ALIGN="LEFT">Destination</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Source</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Unmapped points</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER">&nbsp;</TD>
</TR>
<TR><TD ALIGN="LEFT">Pole Options</TD>
<TD ALIGN="LEFT">Full circle average</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">N-point average</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
<TR><TD ALIGN="LEFT">&nbsp;</TD>
<TD ALIGN="LEFT">Teeth pole</TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
<TD ALIGN="CENTER"><IMG
 WIDTH="19" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img31.png"
 ALT="$\surd$"></TD>
</TR>
</TABLE>
  <A NAME="Regriddingcapabilities"></A>  </DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
The following sections give examples of using the regridding functionality.

<P>

<H3><A NAME="SECTION050332500000000000000">
22.3.25 Precompute a regridding operation between two Fields</A>
</H3>
   To create the sparse matrix regrid operator we call the
   <TT>ESMF_FieldRegridStore()</TT> routine.  In this example we
   choose the <TT>ESMF_REGRIDMETHOD_BILINEAR</TT> regridding method.  Other
   methods are available and more we will be added in the future.
   This method creates two meshes, and a Rendezvous decomposition of these
   meshes is computed.  An octree search is performed, followed by a determination
   of which source cell each destination gridpoint is in.  Bilinear weights
   are then computed locally on each cell.  This matrix of weights is, finally,
   sent back to the destination grid's row decomposition and declared as a 
   sparse matrix.  This matrix is embedded in the routeHandle object.
   Note the coordinates of the source and destination grids upon whilch the source and destination fields are 
   defined should be in degrees.   

<P>
<PRE>
  call ESMF_FieldRegridStore(srcField=srcField, dstField=dstField, &amp;
                  routeHandle=routeHandle, &amp;
                  indices=indices, weights=weights, &amp;
                  regridmethod=ESMF_REGRIDMETHOD_BILINEAR, rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050332600000000000000">
22.3.26 Apply a regridding operation between a pair of Fields</A>
</H3>
   The <TT>ESMF_FieldRegrid</TT> subroutine calls <TT>ESMF_ArraySparseMatMul</TT>
   and performs a regrid from source to destination field. 

<P>
<PRE>
  call ESMF_FieldRegrid(srcField, dstField, routeHandle, rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050332700000000000000">
22.3.27 Release the stored information for a regridding operation</A>
</H3> 

<P>
<PRE>
  call ESMF_FieldRegridRelease(routeHandle, rc=localrc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050332800000000000000">
22.3.28 Precompute a regridding operation using masks</A>
</H3>
   As before, to create the sparse matrix regrid operator we call the
   <TT>ESMF_FieldRegridStore()</TT> routine. 
   However, in this case we apply masking to the regrid operation. 
   The mask value for each index location in the Grids may be set using
   the <TT>ESMF_GridAddItem()</TT> call (see Section&nbsp;<A HREF="node5.html#sec:usage:items">27.3.14</A>
   and Section&nbsp;<A HREF="node5.html#sec:usage:items:accessing">27.3.15</A>). Mask values may be set independantly 
   for the source and destination Grids. If no mask values have been set in a Grid, then it is 
   assumed no masking should be used for that Grid. The <TT>srcMaskValues</TT>
   parameter allows the user to set the list of values which indicate
   that a source location should be masked out. The <TT>dstMaskValues</TT>
   parameter allows the user to set the list of values which indicate
   that a destination location should be masked out. The absence of 
   one of these parameters indicates that no masking should be used
   for that Field (e.g no <TT>srcMaskValue</TT> parameter indicates that source
   masking shouldn't occur). The <TT>unmappedaction</TT> flag may be
   used with or without masking and indicates what should occur
   if destination points can not be mapped to a source cell. 
   Here the <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> value indicates that unmapped
   destination points are to be ignored and no sparse matrix entries should be
    generated for them.  

<P>
<PRE>
  call ESMF_FieldRegridStore(srcField=srcField, srcMaskValues=(/1/),       &amp;
                             dstField=dstField, dstMaskValues=(/1/),       &amp;
                             unmappedaction=ESMF_UNMAPPEDACTION_IGNORE, &amp;
                             routeHandle=routeHandle,                      &amp;
                             indices=indices, weights=weights,           &amp;
                             regridmethod=ESMF_REGRIDMETHOD_BILINEAR,     &amp;
                             rc=localrc)
</PRE>

<P>
The <TT>ESMF_FieldRegrid</TT> and <TT>ESMF_FieldRegridRelease</TT> calls
   may then be applied as in the previous example. 

<P>

<H3><A NAME="SECTION050332900000000000000">
22.3.29 Regrid troubleshooting guide</A>
</H3>

<P>
The below is a list of problems users commonly encounter with regridding and potential solutions. 
   This is by no means an exhaustive list, so if none of these problems fit your case, or if the solutions
   don't fix your problem, please feel free to email esmf support (esmf_support@list.woc.noaa.gov).

<P>

<P><P>
<BR>

<P>
<B>Problem:</B> Regridding is too slow.

<P>

<P>
<BR>

<P>
<B>Possible Cause:</B> The <TT>ESMF_FieldRegridStore()</TT> method is called more than is necessary. <BR>
The <TT>ESMF_FieldRegridStore()</TT> operation is a complex one and can be 
   relatively slow for some cases (large Grids, 3D grids, etc.) 

<P>

<P></P>

<P>
<B>Solution:</B> Reduce the number of <TT>ESMF_FieldRegridStore()</TT> calls to the minimum necessary. The
   routeHandle generated by the <TT>ESMF_FieldRegridStore()</TT> call depends on only four factors: the 
   stagger locations that the input Fields are created on, the coordinates in the Grids the input Fields
   are built on at those stagger locations, the padding of the input Fields 
   (specified by the <TT>totalWidth</TT> arguments in <TT>FieldCreate</TT>) and the size of the tensor
   dimensions in the input Fields (specified by the <TT>ungridded</TT> arguments in <TT>FieldCreate</TT>). 
   For any pair of Fields which share these attributes with the Fields used in the
   <TT>ESMF_FieldRegridStore</TT> call  the same routeHandle can be used. Note, that the data in the 
   Fields does NOT matter, the same routeHandle can be used no matter how the data in the Fields changes.

<P>

<P></P>

<P>
In particular:
   
<UL>
<LI>If Grid coordinates do not change during a run, then the <TT>ESMF_FieldRegridStore()</TT> call can be
   done once between a pair of Fields at the beginning and the resulting routeHandle used for each 
   timestep during the run. 

<P>
</LI>
<LI>If a pair of Fields was created with exactly the same arguments to <TT>ESMF_FieldCreate()</TT> as the 
   pair of Fields used during an <TT>ESMF_FieldRegridStore()</TT> call, then the resulting routeHandle can 
   also be used between that pair of Fields. 
   
</LI>
</UL>

<P>

<P><P>
<BR>

<P>
<B>Problem:</B> Distortions in destination Field at periodic boundary.

<P>

<P>
<BR>

<P>
<B>Possible Cause:</B> The Grid overlaps itself. With a periodic Grid, the regrid system expects
    the first point to not be a repeat of the last point. In other words,
    regrid constructs its own connection and overlap between the first and last points of the
    periodic dimension and so the Grid doesn't need to contain these. If the Grid does, then this
    can cause problems. 

<P>

<P></P>

<P>
<B>Solution:</B> Define the Grid so that it doesn't contain the overlap point. This typically means simply making
   the Grid one point smaller in the periodic dimension.  If a Field 
   constructuted on the Grid needs to contain these overlap points then the user can use the
   <TT>totalWidth</TT> arguments to include this extra padding in the Field. Note, however, 
   that the regrid won't update these extra points, so the user will have to do a copy to fill the points
   in the overlap region in the Field.  

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050333000000000000000">
22.3.30 Field Regrid Example: Mesh to Mesh</A>
</H3>
   This example demonstrates the regridding process between Fields created on Meshes. First
   the Meshes are created. This example omits the setup of the arrays describing the Mesh, but please see
   Section&nbsp;<A HREF="node5.html#sec:mesh:usage:meshCreation">29.3.1</A> for examples of this. After creation Fields are constructed on the Meshes, 
   and then ESMF_FieldRegridStore() is called to construct a RouteHandle implementing the regrid operation. Finally, ESMF_FieldRegrid() is
   called with the Fields and the RouteHandle to do the interpolation between the source Field and 
   destination Field.  Note the coordinates of the source and destination Mesh should be in degrees.

<P>
<PRE>
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Source Mesh
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Create the Mesh structure.
  ! For brevity's sake, the code to fill the Mesh creation 
  ! arrays is omitted from this example. However, here
  ! is a brief description of the arrays:
  ! srcNodeIds    - the global ids for the src nodes
  ! srcNodeCoords - the coordinates for the src nodes
  ! srcNodeOwners - which PET owns each src node
  ! srcElemIds    - the global ids of the src elements
  ! srcElemTypes  - the topological shape of each src element
  ! srcElemConn   - how to connect the nodes to form the elements
  !                 in the source mesh
  ! Several examples of setting up these arrays can be seen in
  ! the Mesh Section "Mesh Creation". 
  srcMesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=srcNodeIds, nodeCoords=srcNodeCoords, &amp;
         nodeOwners=srcNodeOwners, elementIds=srcElemIds,&amp;
         elementTypes=srcElemTypes, elementConn=srcElemConn, rc=rc)



  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create and Fill Source Field
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Set description of source Field
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=rc)

  ! Create source Field
  srcField = ESMF_FieldCreate(srcMesh, arrayspec, &amp;
                        name="source", rc=rc)

  ! Get source Field data pointer to put data into
  call ESMF_FieldGet(srcField, 0, fptr1D,  rc=rc)

  ! Get number of local nodes to allocate space
  ! to hold local node coordinates
  call ESMF_MeshGet(srcMesh, &amp;
         numOwnedNodes=numOwnedNodes, rc=rc)

  ! Allocate space to hold local node coordinates
  ! (spatial dimension of Mesh*number of local nodes)
  allocate(ownedNodeCoords(2*numOwnedNodes))

  ! Get local node coordinates
  call ESMF_MeshGet(srcMesh, &amp;
         ownedNodeCoords=ownedNodeCoords, rc=rc)

  ! Set the source Field to the function 20.0+x+y
  do i=1,numOwnedNodes
    ! Get coordinates
    x=ownedNodeCoords(2*i-1)
    y=ownedNodeCoords(2*i)

   ! Set source function
   fptr1D(i) = 20.0+x+y
  enddo

  ! Deallocate local node coordinates
  deallocate(ownedNodeCoords)


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Destination Mesh
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Create the Mesh structure.
  ! For brevity's sake, the code to fill the Mesh creation 
  ! arrays is omitted from this example. However, here
  ! is a brief description of the arrays:
  ! dstNodeIds    - the global ids for the dst nodes
  ! dstNodeCoords - the coordinates for the dst nodes
  ! dstNodeOwners - which PET owns each dst node
  ! dstElemIds    - the global ids of the dst elements
  ! dstElemTypes  - the topological shape of each dst element
  ! dstElemConn   - how to connect the nodes to form the elements
  !                 in the destination mesh
  ! Several examples of setting up these arrays can be seen in
  ! the Mesh Section "Mesh Creation". 
  dstMesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=dstNodeIds, nodeCoords=dstNodeCoords, &amp;
         nodeOwners=dstNodeOwners, elementIds=dstElemIds,&amp;
         elementTypes=dstElemTypes, elementConn=dstElemConn, rc=rc)


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Create Destination Field
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Set description of source Field
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=rc)

  ! Create destination Field
  dstField = ESMF_FieldCreate(dstMesh, arrayspec, &amp;
                        name="destination", rc=rc)

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Do Regrid
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Compute RouteHandle which contains the regrid operation
  call ESMF_FieldRegridStore( &amp;
          srcField, &amp;
          dstField=dstField, &amp;
          routeHandle=routeHandle, &amp;
          regridmethod=ESMF_REGRIDMETHOD_BILINEAR, &amp;
          rc=rc)

  ! Perform Regrid operation moving data from srcField to dstField
  call ESMF_FieldRegrid(srcField, dstField, routeHandle, rc=rc)


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! dstField now contains the interpolated data.
  ! If the Meshes don't change, then routeHandle
  ! may be used repeatedly to interpolate from 
  ! srcField to dstField.  
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   
  ! User code to use the routeHandle, Fields, and
  ! Meshes goes here before they are freed below.


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Free the objects created in the example.
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ! Free the RouteHandle
  call ESMF_FieldRegridRelease(routeHandle, rc=rc)

  ! Free the Fields
  call ESMF_FieldDestroy(srcField, rc=rc)

  call ESMF_FieldDestroy(dstField, rc=rc)

  ! Free the Meshes
  call ESMF_MeshDestroy(dstMesh, rc=rc)

  call ESMF_MeshDestroy(srcMesh, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050333100000000000000"></A>
   <A NAME="sec:field:usage:gather_2dptr"></A>
<BR>
22.3.31 Gather Field data onto root PET
</H3>

<P>
User can use <TT>ESMF_FieldGather</TT> interface to gather Field data from multiple
   PETS onto a single root PET. This interface is overloaded by type, kind, and rank.

<P>
Note that the implementation of Scatter and Gather is not seqence index based.
   If the Field is built on arbitrarily distributed Grid, Mesh, LocStream or XGrid, 
   Gather will not gather data to rootPet 
   from source data points corresponding to the sequence index on the rootPet. 
   Instead Gather will gather a contiguous memory range from source PET to
   rootPet. The size of the memory range is equal to the number of 
   data elements on the source PET. Vice versa for the Scatter operation. 
   In this case, the user should use <TT>ESMF_FieldRedist</TT> to achieve
   the same data operation result. For examples how to use <TT>ESMF_FieldRedist</TT>
   to perform Gather and Scatter, please refer to
   <A HREF="node5.html#sec:field:usage:redist_gathering">22.3.35</A> and
   <A HREF="node5.html#sec:field:usage:redist_scattering">22.3.34</A>.

<P>
In this example, we first create a 2D Field, then use <TT>ESMF_FieldGather</TT> to
   collect all the data in this Field into a data pointer on PET 0. 

<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Create a 2D Grid and use this grid to create a Field
    ! farray is the Fortran data array that contains data on each PET.
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
        regDecomp=(/2,2/), &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, rc=localrc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(field, farrayPtr=fptr, rc=localrc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    !---------Initialize pet specific field data----------------
    !    1        5         10
    ! 1  +--------+---------+
    !    |        |         |
    !    |   0    |    1    |
    !    |        |         |
    ! 10 +--------+---------+
    !    |        |         |
    !    |   2    |    3    |
    !    |        |         |
    ! 20 +--------+---------+
    fptr = lpe

    ! allocate the Fortran data array on PET 0 to store gathered data
    if(lpe .eq. 0) allocate(farrayDst(10,20))
    call ESMF_FieldGather(field, farrayDst, rootPet=0, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! check that the values gathered on rootPet are correct
    if(lpe .eq. 0) then
       do i = 1, 2
          do j = 1, 2
             if(farrayDst(i, j) .ne. (i-1)+(j-1)*2) localrc=ESMF_FAILURE
             if(farrayDst(i*5, j*10) .ne. (i-1)+(j-1)*2) localrc=ESMF_FAILURE
          enddo
       enddo
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    endif

    ! destroy all objects created in this example to prevent memory leak
    call ESMF_FieldDestroy(field, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_GridDestroy(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    if(lpe .eq. 0) deallocate(farrayDst)
</PRE>

<P>

<H3><A NAME="SECTION050333200000000000000"></A>
   <A NAME="sec:field:usage:scatter_2dptr"></A>
<BR>
22.3.32 Scatter Field data from root PET onto its set of joint PETs
</H3>

<P>
User can use <TT>ESMF_FieldScatter</TT> interface to scatter Field data from root
   PET onto its set of joint PETs. This interface is overloaded by type, kind, and rank.

<P>
In this example, we first create a 2D Field, then use <TT>ESMF_FieldScatter</TT> to
   scatter the data from a data array located on PET 0 onto this Field. 

<P>
<PRE>
    ! Create a 2D Grid and use this grid to create a Field
    ! farray is the Fortran data array that contains data on each PET.
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
        regDecomp=(/2,2/), &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    field = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, rc=localrc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! initialize values to be scattered
    !    1        5         10
    ! 1  +--------+---------+
    !    |        |         |
    !    |   0    |    1    |
    !    |        |         |
    ! 10 +--------+---------+
    !    |        |         |
    !    |   2    |    3    |
    !    |        |         |
    ! 20 +--------+---------+
    if(lpe .eq. 0) then
        allocate(farraySrc(10,20))
        farraySrc(1:5,1:10) = 0
        farraySrc(6:10,1:10) = 1
        farraySrc(1:5,11:20) = 2
        farraySrc(6:10,11:20) = 3
    endif

    ! scatter the data onto individual PETs of the Field
    call ESMF_FieldScatter(field, farraySrc, rootPet=0, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(field, localDe=0, farrayPtr=fptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify that the scattered data is properly distributed
    do i = lbound(fptr, 1), ubound(fptr, 1)
        do j = lbound(fptr, 2), ubound(fptr, 2)
            if(fptr(i, j) .ne. lpe) localrc = ESMF_FAILURE
        enddo
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! destroy all objects created in this example to prevent memory leak
    call ESMF_FieldDestroy(field, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    call ESMF_GridDestroy(grid, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    if(lpe .eq. 0) deallocate(farraySrc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050333300000000000000"></A>
   <A NAME="sec:field:usage:redist_1dptr"></A>
<BR>
22.3.33 Redistribute data from source Field to destination Field
</H3>

<P>
User can use <TT>ESMF_FieldRedist</TT> interface to redistribute data from 
   source Field to destination Field. This interface is overloaded by type and kind;
   In the version of <TT>ESMF_FieldRedist</TT> without factor argument, a default value
   of 1 is used.

<P>
In this example, we first create two 1D Fields, a source Field and a destination
   Field. Then we use <TT>ESMF_FieldRedist</TT> to
   redistribute data from source Field to destination Field.

<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=localPet, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
            regDecomp=(/4/), &amp;
            rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create srcField
    ! +--------+--------+--------+--------+
    !      0        1        2        3            ! value
    ! 1        4        8        12       16       ! bounds
    srcField = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, &amp;
      indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(srcField, farrayPtr=srcfptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    srcfptr(:) = localPet

    ! create dstField
    ! +--------+--------+--------+--------+
    !      0        0        0        0            ! value
    ! 1        4        8        12       16       ! bounds
    dstField = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, &amp;
      indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_FieldGet(dstField, farrayPtr=dstfptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
  
    dstfptr(:) = 0

    ! perform redist
    ! 1. setup routehandle from source Field to destination Field
    call ESMF_FieldRedistStore(srcField, dstField, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! 2. use precomputed routehandle to redistribute data
    call ESMF_FieldRedist(srcfield, dstField, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify redist
    call ESMF_FieldGet(dstField, localDe=0, farrayPtr=fptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Verify that the redistributed data in dstField is correct.
    ! Before the redist op, the dst Field contains all 0. 
    ! The redist op reset the values to the PE value, verify this is the case.
    do i = lbound(fptr, 1), ubound(fptr, 1)
        if(fptr(i) .ne. localPet) localrc = ESMF_FAILURE
    enddo
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Field redistribution can also be performed between weakly congruent Fields.
   In this case, source and destination Fields can have ungridded dimensions
   with size different from the Field pair used to compute the routehandle.  

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=2, rc=rc)
</PRE>

<P>
Create two fields with ungridded dimensions using the Grid created previously.
   The new Field pair has matching number of elements. The ungridded dimension
   is mapped to the first dimension of either Field. 

<P>
<PRE>
    srcFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
    dstFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
Using the previously computed routehandle, weakly congruent Fields can be
   redistributed. 

<P>
<PRE>
    call ESMF_FieldRedist(srcfieldA, dstFieldA, routehandle, rc=rc)
</PRE>

<P>
<PRE>
    call ESMF_FieldRedistRelease(routehandle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050333400000000000000"></A>
   <A NAME="sec:field:usage:redist_scattering"></A>
<BR>
22.3.34 FieldRedist as a form of scatter involving arbitrary distribution
</H3>

<P>
User can use <TT>ESMF_FieldRedist</TT> interface to redistribute data from 
   source Field to destination Field, where the destination Field is built on
   an arbitrarily distributed structure, e.g. <TT>ESMF_Mesh</TT>. The underlying mechanism is explained
   in section <A HREF="node5.html#Array:ScatterGatherRevisited">24.2.18</A>.

<P>
In this example, we will create 2 one dimensional Fields, the src Field has a regular decomposition
   and holds all its data on a single PET, in this case PET 0. The destination Field is built on a Mesh
   which is itself built on an arbitrarily distributed distgrid. Then we use <TT>ESMF_FieldRedist</TT> to
   redistribute data from source Field to destination Field, similar to a traditional scatter operation.

<P>
The src Field only has data on PET 0 where it is sequentially initialized, i.e. 1,2,3...This data
   will be redistributed (or scattered) from PET 0 to the destination Field arbitrarily distributed on 
   all the PETs. 

<P>
<PRE>
    ! a one dimensional grid whose elements are all located on PET 0
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/9/), &amp;
        regDecomp=(/1/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    srcField = ESMF_FieldCreate(grid, typekind=ESMF_TYPEKIND_I4, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! initialize the source data
    if (localPet == 0) then
        call ESMF_FieldGet(srcField, farrayPtr=srcfptr, rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
        do i = 1, 9
            srcfptr(i) = i
        enddo
    endif
</PRE>

<P>
For more information on Mesh creation, user can refer to Mesh examples section or Field creation
   on Mesh example for more details. 

<P>
<PRE>
      ! Create Mesh structure
      mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
             nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
             nodeOwners=nodeOwners, elementIds=elemIds,&amp;
             elementTypes=elemTypes, elementConn=elemConn, &amp;
             rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Create the destination Field on the Mesh that is arbitrarily distributed on 
   all the PETs. 

<P>
<PRE>
      dstField = ESMF_FieldCreate(mesh, typekind=ESMF_TYPEKIND_I4, rc=rc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Perform the redistribution from source Field to destination Field. 

<P>
<PRE>
     call ESMF_FieldRedistStore(srcField, dstField, &amp;
             routehandle=routehandle, rc=rc)
     if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
     call ESMF_FieldRedist(srcField, dstField, routehandle=routehandle, rc=rc)
     if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
We can now verify that the sequentially intialized source data is scattered
   on to the destination Field. The data has been scattered onto the destination
   Field with the following distribution.
  <PRE>
  
   4 elements on PET 0:  1 2 4 5
   2 elements on PET 1:  3 6
   2 elements on PET 2:  7 8
   1 element  on PET 3:  9
</PRE>
   Because the redistribution is index based, the elements also corresponds to the
   index space of Mesh in the destination Field. 

<P>
<PRE>
    call ESMF_FieldGet(dstField, farrayPtr=dstfptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
The scatter operation is successful. Since the routehandle computed with
   <TT>ESMF_FieldRedistStore</TT> can be reused, user can use the same routehandle
   to scatter multiple source Fields from a single PET to multiple destination
   Fields distributed on all PETs. The <TT>gathering</TT> operation is just the 
   opposite of the demonstrated <TT>scattering</TT> operation, where a user would
   redist from a source Field distributed on multiple PETs to a destination Field
   that only has data storage on a single PET.

<P>
Now it's time to release all the resources. 

<P>
<PRE>
    call ESMF_FieldRedistRelease(routehandle=routehandle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050333500000000000000"></A>
   <A NAME="sec:field:usage:redist_gathering"></A>
<BR>
22.3.35 FieldRedist as a form of gather involving arbitrary distribution
</H3>

<P>
Similarly, one can use the same approach to gather the data from an arbitrary distribution
   to a non-arbitrary distribution. This concept is demonstrated by using the previous Fields but 
   the data operation is reversed. This time data is gathered from the Field built on the mesh to the Field
   that has only data allocation on rootPet.

<P>
First a FieldRedist routehandle is created from the Field built on Mesh to the Field
   that has only data allocation on rootPet. 

<P>
<PRE>
    call ESMF_FieldRedistStore(dstField, srcField, routehandle=routehandle, &amp;
         rc=rc)
</PRE>

<P>
Perform FieldRedist, this will gather the data points from the Field built on mesh to
   the data pointer on the rootPet (default to 0) stored in the srcField. 

<P>
<PRE>
    call ESMF_FieldRedist(dstField, srcField, routehandle=routehandle, rc=rc)
</PRE>

<P>
Release the routehandle used for the gather operation. 

<P>
<PRE>
    call ESMF_FieldRedistRelease(routehandle=routehandle, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050333600000000000000"></A>
   <A NAME="sec:field:usage:smm_1dptr"></A>
<BR>
22.3.36 Sparse matrix multiplication from source Field to destination Field
</H3>

<P>
A user can use <TT>ESMF_FieldSMM()</TT> interface to perform sparse matrix multiplication 
   from 
   source Field to destination Field. This interface is overloaded by type and kind;

<P>
In this example, we first create two 1D Fields, a source Field and a destination
   Field. Then we use <TT>ESMF_FieldSMM</TT> to
   perform sparse matrix multiplication from source Field to destination Field.

<P>
The source and destination Field data are arranged such that each of the 4 PETs has 4
   data elements. Moreover, the source Field has all its data elements initialized to a linear
   function based on local PET number. 
   Then collectively on each PET, a SMM according to the following formula
   is preformed: <BR>
   <!-- MATH
 $dstField(i) = i * srcField(i), i = 1 ... 4$
 -->
<IMG
 WIDTH="267" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img32.png"
 ALT="$dstField(i) = i * srcField(i), i = 1 ... 4$"> <BR>
   <BR>

<P>
Because source Field data are initialized to a linear function based on local PET number, 
   the formula predicts that
   the result destination Field data on each PET is 1,2,3,4. This is verified in the
   example.

<P>
Section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> provides a detailed discussion of the 
   sparse matrix mulitiplication operation implemented in ESMF.

<P>
<PRE>
    ! Get current VM and pet number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_VMGet(vm, localPet=lpe, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create distgrid and grid
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGetFieldBounds(grid, localDe=0, totalCount=fa_shape, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create src\_farray, srcArray, and srcField
    ! +--------+--------+--------+--------+
    !      1        2        3        4            ! value
    ! 1        4        8        12       16       ! bounds
    allocate(src_farray(fa_shape(1)) )
    src_farray = lpe+1
    srcArray = ESMF_ArrayCreate(distgrid, src_farray, &amp;
		indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    srcField = ESMF_FieldCreate(grid, srcArray, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! create dst_farray, dstArray, and dstField
    ! +--------+--------+--------+--------+
    !      0        0        0        0            ! value
    ! 1        4        8        12       16       ! bounds
    allocate(dst_farray(fa_shape(1)) )
    dst_farray = 0
    dstArray = ESMF_ArrayCreate(distgrid, dst_farray, &amp;
		indexflag=ESMF_INDEX_DELOCAL, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dstField = ESMF_FieldCreate(grid, dstArray, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! perform sparse matrix multiplication
    ! 1. setup routehandle from source Field to destination Field
    ! initialize factorList and factorIndexList
    allocate(factorList(4))
    allocate(factorIndexList(2,4))
    factorList = (/1,2,3,4/)
    factorIndexList(1,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)
    factorIndexList(2,:) = (/lpe*4+1,lpe*4+2,lpe*4+3,lpe*4+4/)

    call ESMF_FieldSMMStore(srcField, dstField, routehandle, &amp;
        factorList, factorIndexList, rc=localrc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! 2. use precomputed routehandle to perform SMM
    call ESMF_FieldSMM(srcfield, dstField, routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! verify sparse matrix multiplication
    call ESMF_FieldGet(dstField, localDe=0, farrayPtr=fptr, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! Verify that the result data in dstField is correct.
    ! Before the SMM op, the dst Field contains all 0. 
    ! The SMM op reset the values to the index value, verify this is the case.
    ! +--------+--------+--------+--------+
    !  1 2 3 4  2 4 6 8  3 6 9 12  4 8 12 16       ! value
    ! 1        4        8        12       16       ! bounds
    do i = lbound(fptr, 1), ubound(fptr, 1)
        if(fptr(i) /= i*(lpe+1)) rc = ESMF_FAILURE
    enddo
</PRE>

<P>
Field sparse matrix matmul can also be performed between weakly congruent Fields.
   In this case, source and destination Fields can have ungridded dimensions
   with size different from the Field pair used to compute the routehandle.  

<P>
<PRE>
    call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=2, rc=rc)
</PRE>

<P>
Create two fields with ungridded dimensions using the Grid created previously.
   The new Field pair has matching number of elements. The ungridded dimension
   is mapped to the first dimension of either Field. 

<P>
<PRE>
    srcFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
    dstFieldA = ESMF_FieldCreate(grid, arrayspec, gridToFieldMap=(/2/), &amp;
        ungriddedLBound=(/1/), ungriddedUBound=(/10/), rc=rc)
</PRE>

<P>
Using the previously computed routehandle, weakly congruent Fields can perform
   sparse matrix matmul. 

<P>
<PRE>
    call ESMF_FieldSMM(srcfieldA, dstFieldA, routehandle, rc=rc)
</PRE>

<P>
<PRE>
    ! release route handle
    call ESMF_FieldSMMRelease(routehandle, rc=rc)
</PRE>

<P>
In the following discussion, we demonstrate how to set up a SMM routehandle
   between a pair of Fields that are different in number of gridded dimensions
   and the size of those gridded dimensions. The source Field has a 1D decomposition
   with 16 total elements; the destination Field has a 2D decomposition with
   12 total elements. For ease of understanding of the actual matrix calculation,
   a global indexing scheme is used.  

<P>
<PRE>
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/16/), &amp;
        indexflag=ESMF_INDEX_GLOBAL, &amp;
        regDecomp=(/4/), &amp;
        rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, &amp;
        indexflag=ESMF_INDEX_GLOBAL, &amp;
        name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    call ESMF_GridGetFieldBounds(grid, localDe=0, totalLBound=tlb, &amp;
                       totalUBound=tub, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
create 1D src_farray, srcArray, and srcField
  <PRE>
   +  PET0  +  PET1  +  PET2  +  PET3  +
   +--------+--------+--------+--------+
        1        2        3        4            ! value
   1        4        8        12       16       ! bounds of seq indices
</PRE> 

<P>
<PRE>
    allocate(src_farray2(tlb(1):tub(1)) )
    src_farray2 = lpe+1
    srcArray = ESMF_ArrayCreate(distgrid, src_farray2, &amp;
		  indexflag=ESMF_INDEX_GLOBAL, &amp;
      rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    !print *, lpe, '+', tlb, tub, '+', src_farray2

    srcField = ESMF_FieldCreate(grid, srcArray, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Create 2D dstField on the following distribution 
   (numbers are the sequence indices):
  <PRE>
   +  PET0  +  PET1  +  PET2  +  PET3  +
   +--------+--------+--------+--------+
   |        |        |        |        |
   |   1    |   4    |   7    |   10   |
   |        |        |        |        |
   +--------+--------+--------+--------+
   |        |        |        |        |
   |   2    |   5    |   8    |   11   |
   |        |        |        |        |
   +--------+--------+--------+--------+
   |        |        |        |        |
   |   3    |   6    |   9    |   12   |
   |        |        |        |        |
   +--------+--------+--------+--------+
</PRE> 

<P>
<PRE>
    ! Create the destination Grid
    dstGrid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/3,4/), &amp;
      indexflag = ESMF_INDEX_GLOBAL, &amp;
      regDecomp = (/1,4/), &amp;
      rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dstField = ESMF_FieldCreate(dstGrid, typekind=ESMF_TYPEKIND_R4, &amp;
      indexflag=ESMF_INDEX_GLOBAL, &amp;
      rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>
Perform sparse matrix multiplication <IMG
 WIDTH="33" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img33.png"
 ALT="$dst_i$"> = <IMG
 WIDTH="37" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img34.png"
 ALT="$M_{i,j}$"> * <IMG
 WIDTH="35" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img35.png"
 ALT="$src_j$">
   First setup routehandle from source Field to destination Field
   with prescribed factorList and factorIndexList.

<P>
The sparse matrix is of size 12x16, however only the following entries
   are filled:
   <PRE>
   M(3,1) = 0.1
   M(3,10) = 0.4
   M(8,2) = 0.25
   M(8,16) = 0.5
   M(12,1) = 0.3
   M(12,16) = 0.7
</PRE>

<P>
By the definition of matrix calculation, the 8th element on PET2 in the
   dstField equals to 0.25*srcField(2) + 0.5*srcField(16) = 0.25*1+0.5*4=2.25
   For simplicity, we will load the factorList and factorIndexList on
   PET 0 and 1, the SMMStore engine will load balance the parameters on all 4
   PETs internally for optimal performance.  

<P>
<PRE>
    if(lpe == 0) then
      allocate(factorList(3), factorIndexList(2,3))
      factorList=(/0.1,0.4,0.25/)
      factorIndexList(1,:)=(/1,10,2/)
      factorIndexList(2,:)=(/3,3,8/)
      call ESMF_FieldSMMStore(srcField, dstField, routehandle=routehandle, &amp;
          factorList=factorList, factorIndexList=factorIndexList, rc=localrc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    else if(lpe == 1) then
      allocate(factorList(3), factorIndexList(2,3))
      factorList=(/0.5,0.3,0.7/)
      factorIndexList(1,:)=(/16,1,16/)
      factorIndexList(2,:)=(/8,12,12/)
      call ESMF_FieldSMMStore(srcField, dstField, routehandle=routehandle, &amp;
          factorList=factorList, factorIndexList=factorIndexList, rc=localrc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    else
      call ESMF_FieldSMMStore(srcField, dstField, routehandle=routehandle, &amp;
          rc=localrc)
      if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    endif

    ! 2. use precomputed routehandle to perform SMM
    call ESMF_FieldSMM(srcfield, dstField, routehandle=routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050333700000000000000"></A>
   <A NAME="sec:field:usage:halo"></A>
<BR>
22.3.37 Field Halo solving a domain decomposed heat transfer problem
</H3>

<P>
<TT>ESMF_FieldHalo()</TT> interface can be used to perform halo update of a Field. This
   eases communication programming from a user perspective. By definition, user
   program only needs to update locally owned exclusive region in each domain, then call
   FieldHalo to communicate the values in the halo region from/to neighboring domain elements.
   In this example, we solve a 1D heat transfer problem: <!-- MATH
 $u_t = \alpha^2 u_{xx}$
 -->
<IMG
 WIDTH="84" HEIGHT="36" ALIGN="MIDDLE" BORDER="0"
 SRC="img36.png"
 ALT="$u_t = \alpha^2 u_{xx}$"> with the
   initial condition <IMG
 WIDTH="89" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img37.png"
 ALT="$u(0, x) = 20$"> and boundary conditions <!-- MATH
 $u(t, 0) = 10, u(t, 1) = 40$
 -->
<IMG
 WIDTH="172" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img38.png"
 ALT="$u(t, 0) = 10, u(t, 1) = 40$">.
   The temperature field <IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="$u$">
   is represented by a <TT>ESMF_Field</TT>. A finite difference explicit time steping scheme is employed.
   During each time step, FieldHalo update is called to communicate values in the halo region
   to neighboring domain elements. The steady state (as <!-- MATH
 $t \rightarrow \infty$
 -->
<IMG
 WIDTH="53" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img39.png"
 ALT="$t \rightarrow \infty$">) solution 
   is a linear temperature profile along <IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img40.png"
 ALT="$x$">. The numerical solution is an approximation of
   the steady state solution. It can be verified to represent a linear temperature profile.

<P>
Section <A HREF="node5.html#Array:Halo">24.2.14</A> provides a discussion of the 
   halo operation implemented in <TT>ESMF_Array</TT>.

<P>
<PRE>
! create 1D distgrid and grid decomposed according to the following diagram:
! +------------+   +----------------+   +---------------+   +--------------+
! |   DE 0  |  |   |  |   DE 1   |  |   |  |   DE 2  |  |   |  |   DE 3    |
! |  1 x 16 |  |   |  |  1 x 16  |  |   |  |  1 x 16 |  |   |  |  1 x 16   |
! |         | 1|&lt;-&gt;|1 |          | 1|&lt;-&gt;|1 |         | 1|&lt;-&gt;|1 |           |
! |         |  |   |  |          |  |   |  |         |  |   |  |           |
! +------------+   +----------------+   +---------------+   +--------------+
    distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/npx/), &amp;
        regDecomp=(/4/), rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    grid = ESMF_GridCreate(distgrid=distgrid, name="grid", rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    ! set up initial condition and boundary conditions of the 
    ! temperature Field
    if(lpe == 0) then
        allocate(fptr(17), tmp_farray(17))
        fptr = 20.
        fptr(1) = 10.
        tmp_farray(1) = 10.
        startx = 2
        endx = 16

        field = ESMF_FieldCreate(grid, fptr, totalUWidth=(/1/), &amp;
		name="temperature", rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    else if(lpe == 3) then
        allocate(fptr(17), tmp_farray(17))
        fptr = 20.
        fptr(17) = 40.
        tmp_farray(17) = 40.
        startx = 2
        endx = 16

        field = ESMF_FieldCreate(grid, fptr, totalLWidth=(/1/), &amp;
		name="temperature", rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    else
        allocate(fptr(18), tmp_farray(18))
        fptr = 20.
        startx = 2
        endx = 17

        field = ESMF_FieldCreate(grid, fptr, &amp;
            totalLWidth=(/1/), totalUWidth=(/1/), name="temperature", rc=rc)
        if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    endif

    ! compute the halo update routehandle of the decomposed temperature Field
    call ESMF_FieldHaloStore(field, routehandle=routehandle, rc=rc)
    if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE

    dt = 0.01
    dx = 1./npx
    alpha = 0.1

    ! Employ explicit time steping
    ! Solution converges after about 9000 steps based on apriori knowledge.
    ! The result is a linear temperature profile stored in field.
    do iter = 1, 9000
     ! only elements in the exclusive region are updated locally 
     ! in each domain
     do i = startx, endx
       tmp_farray(i) = &amp;
       fptr(i)+alpha*alpha*dt/dx/dx*(fptr(i+1)-2.*fptr(i)+fptr(i-1))
      enddo
      fptr = tmp_farray
     ! call halo update to communicate the values in the halo region to 
     ! neighboring domains
     call ESMF_FieldHalo(field, routehandle=routehandle, rc=rc)
     if(rc .ne. ESMF_SUCCESS) finalrc = ESMF_FAILURE
    enddo

    ! release the halo routehandle
    call ESMF_FieldHaloRelease(routehandle, rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION05034000000000000000">
22.4 Restrictions and Future Work</A>
</H2>

<P>

<A NAME="Field:rest"></A>

<OL>
<LI><B>CAUTION:</B> It depends on the specific entry point of <TT>ESMF_FieldCreate()</TT> used during Field creation, which Fortran operations are supported on the Fortran array pointer <TT>farrayPtr</TT>, returned by <TT>ESMF_FieldGet()</TT>. Only if the <TT>ESMF_FieldCreate()</TT> <EM>from pointer</EM> variant was used, will the returned <TT>farrayPtr</TT> variable contain the original bounds information, and be suitable for the Fortran <TT>deallocate()</TT> call. This limitation is a direct consequence of the Fortran 95 standard relating to the passing of array arguments.

<P>
</LI>
<LI><B>No mathematical operators.</B>  The Fields class does not 
currently support advanced
operations on fields, such as differential or other
mathematical operators.

<P>
</LI>
<LI><B>No vector Fields.</B>  ESMF does not currently  support storage of 
multiple vector Field components in the same Field component, although
that support is planned.  At this time users need to create a 
separate Field object to represent each vector component.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION05035000000000000000">
22.5 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>Some methods which have a Field interface are actually 
implemented at the underlying Grid or Array level; they
are inherited by the Field class.  This allows the user
API (Application Programming Interface) to present functions at
the level which is most consistent to the application without
restricting where inside the ESMF the actual implementation
is done.

<P>
</LI>
<LI>The Field class is implemented in Fortran, and as such is
defined inside the framework by a Field derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The Field class itself is very thin; it is a container class which
groups a Grid and an Array object together.

<P>
</LI>
<LI>Fields follow the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same Fields at the same point in their execution.  Since an early
user request was that global object creation not impose the overhead of
a barrier or synchronization point, Field creation does no inter-PET
communication.  For this to work, each PET must query the total number
of PETs in this VM, and which local PET number it is.  It can then
compute which DE(s) are part of the local decomposition, and any
global information can be computed in unison by all PETs independently
of the others.  In this way the overhead of communication is avoided,
at the cost of more difficulty in diagnosing program bugs which result
from not all PETs executing the same create calls.

<P>
</LI>
<LI>Related to the item above, the user request to not impose
inter-PET communication at object creation time means that requirement
FLD 1.5.1, that all Fields will have unique names, and if not specified, 
the framework will generate a unique name for it, is difficult or
impossible to support.  A part of this requirement has been implememted;
a unique object counter is maintained in the Base object class, and if
a name is not given at create time a name such as "Field003" is generated
which is guarenteed to not be repeated by the framework.   However, it
is impossible to error check that the user has not replicated a name,
and it is possible under certain conditions that if not all PETs have
created the same number of objects, that the counters on different PETs
may not stay synchronized.   This remains an open issue.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION05036000000000000000">
22.6 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05036100000000000000">
22.6.1 ESMF_FieldAssignment(=) - Field assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface assignment(=)
   field1 = field2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field) :: field1
   type(ESMF_Field) :: field2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign field1 as an alias to the same ESMF Field object in memory
   as field2. If field2 is invalid, then field1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>field1</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>field2</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05036200000000000000">
22.6.2 ESMF_FieldOperator(==) - Field equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
   if (field1 == field2) then ... endif
   OR
   result = (field1 == field2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field1
   type(ESMF_Field), intent(in) :: field2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether field1 and field2 are valid aliases to the same ESMF
   Field object in memory. For a more general comparison of two ESMF Fields,
   going beyond the simple alias test, the ESMF_FieldMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>field1</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>field2</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05036300000000000000">
22.6.3 ESMF_FieldOperator(/=) - Field not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
   if (field1 /= field2) then ... endif
   OR
   result = (field1 /= field2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field1
   type(ESMF_Field), intent(in) :: field2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether field1 and field2 are <I>not</I> valid aliases to the
   same ESMF Field object in memory. For a more general comparison of two ESMF
   Fields, going beyond the simple alias test, the ESMF_FieldMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>field1</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>field2</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05036400000000000000">
22.6.4 ESMF_FieldCreate - Create a Field from Grid and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridTKR(grid, typekind, &amp;
     indexflag, staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGridTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag), intent(in), optional :: indexflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_grid_tkr">22.3.4</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node2.html#const:indexflag">9.24</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>.
   To create a custom stagger location see section
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036500000000000000">
22.6.5 ESMF_FieldCreate - Create a Field from Grid and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridArraySpec(grid, arrayspec, &amp;
     indexflag, staggerloc, gridToFieldMap, ungriddedLBound, &amp;
     ungriddedUBound, totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGridArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag), intent(in), optional :: indexflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_grid_arrayspec">22.3.5</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node2.html#const:indexflag">9.24</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>.
   To create a custom stagger location see section
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036600000000000000">
22.6.6 ESMF_FieldCreate - Create a Field from Grid and Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateGridArray(grid, array, datacopyflag, &amp;
     staggerloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, totalLWidth, &amp;
     totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateGridArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid
     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     type(ESMF_StaggerLoc), intent(in), optional :: staggerloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     integer, intent(in), optional :: totalLWidth(:)
     integer, intent(in), optional :: totalUWidth(:)
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_grid_array">22.3.6</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is
   <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>.
   To create a custom stagger location see section
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036700000000000000">
22.6.7 ESMF_FieldCreate - Create a Field from Grid and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGridData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(grid, &amp; 
   farray, indexflag, datacopyflag, staggerloc, &amp; 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp; 
   totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateGridData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in) target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data array and <TT>ESMF_Grid</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 
   For examples and 
   associated documentations using this method see section 
   <A HREF="node5.html#sec:field:usage:create_2darray">22.3.10</A>, 
   <A HREF="node5.html#sec:field:usage:create_2dgrid_3dptr">22.3.12</A>, 
   <A HREF="node5.html#sec:field:usage:create_2dgrid_3dptr_map">22.3.13</A>, 
   <A HREF="node5.html#sec:field:usage:create_2dgrid_3dptr_map_halo">22.3.14</A>, and 
   <A HREF="node5.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">22.3.9</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>. 
   To create a custom stagger location see section 
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farray</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>farray</TT>. That is, for each gridded dimension the 
   <TT>farray</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farray</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>farray</TT>. That is, for each gridded dimension the 
   <TT>farray</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036800000000000000">
22.6.8 ESMF_FieldCreate - Create a Field from Grid and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateGridDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(grid, &amp; 
   farrayPtr, datacopyflag, staggerloc, gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateGridDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_StaggerLoc), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data pointer and <TT>ESMF_Grid</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
For examples and 
   associated documentations using this method see section 
   <A HREF="node5.html#sec:field:usage:create_2dptr">22.3.11</A>, 
   <A HREF="node5.html#sec:field:usage:create_2dgrid_3dptr">22.3.12</A>, 
   <A HREF="node5.html#sec:field:usage:create_2dgrid_3dptr_map">22.3.13</A>, 
   <A HREF="node5.html#sec:field:usage:create_2dgrid_3dptr_map_halo">22.3.14</A>, and 
   <A HREF="node5.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">22.3.9</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>. 
   To create a custom stagger location see section 
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the Field. However, ordering of the elements 
   needs to be the same as they appear in the <TT>farrayPtr</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>farrayPtr</TT>. That is, for each gridded dimension the 
   <TT>farrayPtr</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05036900000000000000">
22.6.9 ESMF_FieldCreate - Create a Field from LocStream and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSTKR(locstream, typekind, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateLSTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_TypeKind_Flag), intent(in) :: typekind
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_locs_tkr">22.3.15</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361000000000000000">
22.6.10 ESMF_FieldCreate - Create a Field from LocStream and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSArraySpec(locstream, arrayspec, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateLSArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_ArraySpec), intent(in) :: arrayspec
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_locs_arrayspec">22.3.16</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361100000000000000">
22.6.11 ESMF_FieldCreate - Create a Field from LocStream and Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateLSArray(locstream, array, &amp;
     datacopyflag, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateLSArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream
     type(ESMF_Array), intent(in) :: array
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_grid_array">22.3.6</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is
   <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the LocStream dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   LocStream dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361200000000000000">
22.6.12 ESMF_FieldCreate - Create a Field from LocStream and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateLSData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(locstream, farray, &amp; 
   indexflag, datacopyflag, gridToFieldMap, ungriddedLBound, &amp; 
   ungriddedUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateLSData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target:: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data array and <TT>ESMF_LocStream</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed.

<P>
The arguments are: 
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>locstream</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>locstream</TT>. Unlocstreamded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361300000000000000">
22.6.13 ESMF_FieldCreate - Create a Field from LocStream and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateLSDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(locstream, &amp; 
   farrayPtr, datacopyflag, gridToFieldMap, &amp; 
   name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateLSDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data pointer and <TT>ESMF_LocStream</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>locstream</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>locstream</TT>. Unlocstreamded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361400000000000000">
22.6.14 ESMF_FieldCreate - Create a Field from Mesh and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshTKR(mesh, typekind, meshloc, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateMeshTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_TypeKind_Flag), intent(in) :: typekind
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_grid_tkr">22.3.4</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set,
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361500000000000000">
22.6.15 ESMF_FieldCreate - Create a Field from Mesh and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshArraySpec(mesh, arrayspec, &amp;
     meshloc, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateMeshArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_ArraySpec), intent(in) :: arrayspec
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_grid_arrayspec">22.3.5</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set,
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361600000000000000">
22.6.16 ESMF_FieldCreate - Create a Field from Mesh and Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateMeshArray(mesh, array, meshloc, &amp;
     datacopyflag, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateMeshArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh
     type(ESMF_Array), intent(in) :: array
     type(ESMF_MeshLoc), intent(in), optional :: meshloc
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_grid_array">22.3.6</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set,
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is
   <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Mesh dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Mesh dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361700000000000000">
22.6.17 ESMF_FieldCreate - Create a Field from Mesh and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateMeshData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(mesh, &amp; 
   farray, meshloc, indexflag, datacopyflag, &amp; 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateMeshData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data array and <TT>ESMF_Mesh</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either 
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set, 
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>mesh</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>mesh</TT>. Unmeshded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361800000000000000">
22.6.18 ESMF_FieldCreate - Create a Field from Mesh and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateMeshDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(mesh, &amp; 
   farrayPtr, meshloc, datacopyflag, gridToFieldMap, &amp; 
   name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateMeshDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data pointer and <TT>ESMF_Mesh</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> object. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either 
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set, 
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>mesh</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>mesh</TT>. Unmeshded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050361900000000000000">
22.6.19 ESMF_FieldCreate - Create a Field from XGrid and typekind</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGTKR(xgrid, xgridside, gridindex, typekind, &amp;
     gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateXGTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside
     integer, intent(in), optional :: gridindex
     type(ESMF_TypeKind_Flag), intent(in) :: typekind
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_locs_tkr">22.3.15</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
   defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridSide is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Field.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362000000000000000">
22.6.20 ESMF_FieldCreate - Create a Field from XGrid and ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGArraySpec(xgrid, xgridside, gridindex, &amp;
     arrayspec, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateXGArraySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridSide
     integer, intent(in), optional :: gridIndex
     type(ESMF_ArraySpec), intent(in) :: arrayspec
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len=*), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT>. Return a new <TT>ESMF_Field</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_locs_arrayspec">22.3.16</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
   defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362100000000000000">
22.6.21 ESMF_FieldCreate - Create a Field from XGrid and Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate()
   function ESMF_FieldCreateXGArray(xgrid, xgridside, gridindex, array, &amp;
     datacopyflag, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldCreateXGArray
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid
     type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside
     integer, intent(in), optional :: gridindex
     type(ESMF_Array), intent(in) :: array
     type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
     integer, intent(in), optional :: gridToFieldMap(:)
     integer, intent(in), optional :: ungriddedLBound(:)
     integer, intent(in), optional :: ungriddedUBound(:)
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT>. This version of creation
   assumes the data exists already and is being
   passed in through an <TT>ESMF_Array</TT>. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_grid_array">22.3.6</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
   defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridSide is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on
   that side to create the Field on. If not provided, defaults to 1.
   
</DD>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the contents of the <TT>array</TT> or reference it directly.
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is
   <TT>ESMF_DATACOPY_REFERENCE</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the XGrid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   XGrid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362200000000000000">
22.6.22 ESMF_FieldCreate - Create a Field from XGrid and Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateXGData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(xgrid, &amp; 
   xgridside, gridindex, farray, indexflag, datacopyflag, &amp; 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, name,&amp; 
   rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateXGData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_XGrid), intent(in) :: xgrid 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data array and <TT>ESMF_Xgrid</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object. 
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A, 
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then 
   defaults to ESMF_XGRIDSIDE_BALANCED. 
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farray</TT> or reference directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>xgrid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>xgrid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The default is to 
   map all of the <TT>xgrid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farray</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farray</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farray</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>xgrid</TT>. Unxgridded dimensions must be in the same order they are 
   stored in the farray. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Xgrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Xgrid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than xgrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than xgrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362300000000000000">
22.6.23 ESMF_FieldCreate - Create a Field from XGrid and Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldCreate() 
   function ESMF_FieldCreateXGDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(xgrid, xgridside, &amp; 
   gridindex, farrayPtr, datacopyflag, gridToFieldMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Field) :: ESMF_FieldCreateXGDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_XGrid), intent(in) :: xgrid 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Field</TT> from a fortran data pointer and <TT>ESMF_Xgrid</TT>. 
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not 
   deallocate the fortran data pointer in this case. This gives user more flexibility over memory management. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object. 
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A, 
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then 
   defaults to ESMF_XGRIDSIDE_BALANCED. 
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the Field 
   The Field dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Whether to copy the contents of the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>xgrid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>xgrid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The default is to 
   map all of the <TT>xgrid</TT>'s dimensions against the lowest dimensions of 
   the <TT>farrayPtr</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to one and smaller than or equal to the <TT>farrayPtr</TT> rank. 
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry 
   multiple times. The total ungridded dimensions in the <TT>field</TT> 
   are the total <TT>farrayPtr</TT> dimensions less 
   the total (distributed + undistributed) dimensions in 
   the <TT>xgrid</TT>. Unxgridded dimensions must be in the same order they are 
   stored in the farrayPtr. Permutations of the order of 
   dimensions are handled via individual communication methods. For example, 
   an undistributed dimension can be remapped to a distributed dimension 
   as part of the <TT>ESMF_ArrayRedist()</TT> operation. 
   If the Field dimCount is less than the Xgrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Xgrid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362400000000000000">
22.6.24 ESMF_FieldDestroy - Release resources associated with a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldDestroy(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(inout) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Releases resources associated with the <TT>ESMF_Field</TT>. If an
   <TT>ESMF_Grid</TT> is associated with <TT>field</TT>, it will not be released. If
   <TT>field</TT> is not released with this call, it will be released by the
   automatic garbage collection facility in the scope of the Component
   that created <TT>field</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050362500000000000000">
22.6.25 ESMF_FieldEmptyComplete - Complete a Field from arrayspec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete()
 subroutine ESMF_FieldEmptyCompAS(field, arrayspec, &amp;
  indexflag, gridToFieldMap, &amp;
  ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>  type(ESMF_Field), intent(inout) :: field
  type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
  type(ESMF_Index_Flag), intent(in), optional :: indexflag
  integer, intent(in), optional :: gridToFieldMap(:)
  integer, intent(in), optional :: ungriddedLBound(:)
  integer, intent(in), optional :: ungriddedUBound(:)
  integer, intent(in), optional :: totalLWidth(:)
  integer, intent(in), optional :: totalUWidth(:)
  integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Complete an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT> based on arrayspec.
   The input <TT>ESMF_Field</TT> must have a status of
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. After this call the completed <TT>ESMF_Field</TT>
   has a status of <TT>ESMF_FIELDSTATUS_COMPLETE</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The input <TT>ESMF_Field</TT> with a status of
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node2.html#const:indexflag">9.24</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>.
   To create a custom stagger location see section
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362600000000000000">
22.6.26 ESMF_FieldEmptyComplete - Complete a Field from typekind</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete()
 subroutine ESMF_FieldEmptyCompTK(field, typekind, &amp;
  indexflag, gridToFieldMap, &amp;
  ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>  type(ESMF_Field), intent(inout) :: field
  type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
  type(ESMF_Index_Flag), intent(in), optional :: indexflag
  integer, intent(in), optional :: gridToFieldMap(:)
  integer, intent(in), optional :: ungriddedLBound(:)
  integer, intent(in), optional :: ungriddedUBound(:)
  integer, intent(in), optional :: totalLWidth(:)
  integer, intent(in), optional :: totalUWidth(:)
  integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Complete an <TT>ESMF_Field</TT> and allocate space internally for an
   <TT>ESMF_Array</TT> based on typekind.
   The input <TT>ESMF_Field</TT> must have a status of
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. After this call the completed <TT>ESMF_Field</TT>
   has a status of <TT>ESMF_FIELDSTATUS_COMPLETE</TT>.

<P>
For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:partial_creation">22.3.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The input <TT>ESMF_Field</TT> with a status of
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Data type and kind specification.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default each DE's
   exclusive region is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated Grid. See section <A HREF="node2.html#const:indexflag">9.24</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>.
   To create a custom stagger location see section
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
   to one and smaller than or equal to the <TT>field</TT> rank.
   It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
   multiple times. The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   If the Field dimCount is less than the Grid dimCount then the default
   gridToFieldMap will contain zeros for the rightmost entries. A zero
   entry in the <TT>gridToFieldMap</TT> indicates that the particular
   Grid dimension will be replicating the Field across the DEs along
   this direction.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number
   of gridded dimensions in the Field. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362700000000000000">
22.6.27 ESMF_FieldEmptyComplete - Complete a Field from Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyComp&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, &amp; 
   farray, indexflag, datacopyflag, gridToFieldMap, &amp; 
   ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;),intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Complete an <TT>ESMF_Field</TT> and allocate space internally for an 
   <TT>ESMF_Array</TT> based on typekind. 
   The input <TT>ESMF_Field</TT> must have a status of 
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. After this call the completed <TT>ESMF_Field</TT> 
   has a status of <TT>ESMF_FIELDSTATUS_COMPLETE</TT>.

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
For an example and 
   associated documentation using this method see section 
   <A HREF="node5.html#sec:field:usage:create_empty">22.3.8</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The input <TT>ESMF_Field</TT> with a status of 
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. 
   The <TT>ESMF_Field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362800000000000000">
22.6.28 ESMF_FieldEmptyComplete - Complete a Field from Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, &amp; 
   farrayPtr, datacopyflag, gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Complete an <TT>ESMF_Field</TT> and allocate space internally for an 
   <TT>ESMF_Array</TT> based on typekind. 
   The input <TT>ESMF_Field</TT> must have a status of 
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. After this call the completed <TT>ESMF_Field</TT> 
   has a status of <TT>ESMF_FIELDSTATUS_COMPLETE</TT>. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The input <TT>ESMF_Field</TT> with a status of 
   <TT>ESMF_FIELDSTATUS_GRIDSET</TT>. 
   The <TT>ESMF_Field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050362900000000000000">
22.6.29 ESMF_FieldEmptyComplete - Complete a Field from Grid started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompGrid&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, grid, &amp; 
   farray, indexflag, datacopyflag, staggerloc, gridToFieldMap, &amp; 
   ungriddedLBound, ungriddedUBound, totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target:: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>. 
   To create a custom stagger location see section 
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363000000000000000">
22.6.30 ESMF_FieldEmptyComplete - Complete a Field from Grid started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompGridPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, grid, &amp; 
   farrayPtr, datacopyflag, staggerloc, gridToFieldMap, &amp; 
   totalLWidth, totalUWidth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Grid), intent(in) :: grid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   type(ESMF_STAGGERLOC), intent(in), optional :: staggerloc 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the fortran data pointer in this case. This gives user more flexibility over memory management. 
    
   The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid 
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>. 
   To create a custom stagger location see section 
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default 
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>grid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>grid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>grid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Grid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Grid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalLWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of this array is the number 
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements 
   needs to be the same as they appear in the <TT>field</TT>. Values default 
   to 0. If values for totalUWidth are specified they must be reflected in 
   the size of the <TT>field</TT>. That is, for each gridded dimension the 
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT> 
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ). 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363100000000000000">
22.6.31 ESMF_FieldEmptyComplete - Complete a Field from LocStream started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompLS&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, locstream, &amp; 
   farray, indexflag, datacopyflag, gridToFieldMap, &amp; 
   ungriddedLBound, ungriddedUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target:: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>locstream</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than locstream dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363200000000000000">
22.6.32 ESMF_FieldEmptyComplete - Complete a Field from LocStream started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompLSPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, locstream, &amp; 
   farrayPtr, datacopyflag, gridToFieldMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_LocStream), intent(in) :: locstream 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>locstream</TT>'s dimCount. The list elements map each dimension 
   of the <TT>locstream</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>locstream</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the LocStream dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   LocStream dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363300000000000000">
22.6.33 ESMF_FieldEmptyComplete - Complete a Field from Mesh started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompMesh&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, mesh, &amp; 
   farray, meshloc, indexflag, datacopyflag, &amp; 
   gridToFieldMap, ungriddedLBound, ungriddedUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target:: farray(&lt;rank&gt;) 
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[location]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either 
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set, 
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>mesh</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than Mesh dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363400000000000000">
22.6.34 ESMF_FieldEmptyComplete - Complete a Field from Mesh started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompMeshPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, mesh, &amp; 
   farrayPtr, meshloc, datacopyflag, gridToFieldMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_Mesh), intent(in) :: mesh 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_MeshLoc), intent(in), optional :: meshloc 
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[location]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either 
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set, 
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>mesh</TT>'s dimCount. The list elements map each dimension 
   of the <TT>mesh</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>mesh</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the Mesh dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   Mesh dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363500000000000000">
22.6.35 ESMF_FieldEmptyComplete - Complete a Field from XGrid started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompXG&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, xgrid, &amp; 
   xgridside, gridindex, &amp; 
   farray, indexflag, datacopyflag, gridToFieldMap, &amp; 
   ungriddedLBound, ungriddedUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_XGrid), intent(in) :: xgrid 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target:: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(in), optional :: ungriddedLBound(:) 
   integer, intent(in), optional :: ungriddedUBound(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried but deallocating 
   the retrieved data pointer is not allowed. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A, 
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then 
   defaults to ESMF_XGRIDSIDE_BALANCED. 
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridSide is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Native fortran data array to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farray</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farray</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>xgrid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>xgrid</TT> to a dimension in the <TT>farray</TT> by 
   specifying the appropriate <TT>farray</TT> dimension index. The 
   default is to map all of the <TT>xgrid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farray</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farray</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the XGrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   XGrid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than XGrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>. 
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded 
   dimensions in the <TT>field</TT>. All ungridded dimensions of the 
   <TT>field</TT> are also undistributed. When field dimension count is 
   greater than XGrid dimension count, both ungriddedLBound and ungriddedUBound 
   must be specified. When both are specified the values are checked 
   for consistency. Note that the the ordering of 
   these ungridded dimensions is the same as their order in the <TT>field</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363600000000000000">
22.6.36 ESMF_FieldEmptyComplete - Complete a Field from XGrid started with FieldEmptyCreate </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptyComplete() 
   subroutine ESMF_FieldEmptyCompXGPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, xgrid, &amp; 
   xgridside, gridindex, &amp; 
   farrayPtr, indexflag, datacopyflag, gridToFieldMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   type(ESMF_XGrid), intent(in) :: xgrid 
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside 
   integer, intent(in), optional :: gridindex 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: gridToFieldMap(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call completes an <TT>ESMF_Field</TT> allocated with the 
   <TT>ESMF_FieldEmptyCreate()</TT> call. 

<P>
The fortran data pointer inside <TT>ESMF_Field</TT> can be queried and deallocated when 
   datacopyflag is <TT>ESMF_DATACOPY_REFERENCE</TT>. Note that the <TT>ESMF_FieldDestroy</TT> call does not deallocate 
   the fortran data pointer in this case. This gives user more flexibility over memory management.

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to be completed and 
   committed in this call. The <TT>field</TT> will have the same dimension 
   (dimCount) as the rank of the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object to complete the Field. 
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A, 
   ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then 
   defaults to ESMF_XGRIDSIDE_BALANCED. 
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on 
   that side to create the Field on. If not provided, defaults to 1. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Native fortran data pointer to be copied/referenced in the <TT>field</TT>. 
   The <TT>field</TT> dimension (dimCount) will be the same as the dimCount 
   for the <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicates whether to copy the <TT>farrayPtr</TT> or reference it directly. 
   For valid values see <A HREF="node2.html#const:datacopyflag">9.12</A>. The default is 
   <TT>ESMF_DATACOPY_REFERENCE</TT>. 
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the 
   <TT>xgrid</TT>'s dimCount. The list elements map each dimension 
   of the <TT>xgrid</TT> to a dimension in the <TT>farrayPtr</TT> by 
   specifying the appropriate <TT>farrayPtr</TT> dimension index. The 
   default is to map all of the <TT>xgrid</TT>'s dimensions against the 
   lowest dimensions of the <TT>farrayPtr</TT> in sequence, i.e. 
   <TT>gridToFieldMap</TT> = (/1,2,3,.../). 
   Unmapped <TT>farrayPtr</TT> dimensions are undistributed Field 
   dimensions. 
   All <TT>gridToFieldMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Field dimCount. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Field dimCount is less than the XGrid dimCount then the default 
   gridToFieldMap will contain zeros for the rightmost entries. A zero 
   entry in the <TT>gridToFieldMap</TT> indicates that the particular 
   XGrid dimension will be replicating the Field across the DEs along 
   this direction. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050363700000000000000">
22.6.37 ESMF_FieldEmptyCreate - Create an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_FieldEmptyCreate(name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Field) :: ESMF_FieldEmptyCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character (len = *), intent(in), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This version of <TT>ESMF_FieldCreate</TT> builds an empty <TT>ESMF_Field</TT>
   and depends on later calls to add an <TT>ESMF_Grid</TT> and <TT>ESMF_Array</TT> to
   it. The empty <TT>ESMF_Field</TT> can be completed in one more step or two more steps by
   the <TT>ESMF_FieldEmptySet</TT> and <TT>ESMF_FieldEmptyComplete</TT> methods.
   Attributes can be added to an empty Field object. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:create_empty">22.3.8</A> and <A HREF="node5.html#sec:field:usage:partial_creation">22.3.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>[name]</STRONG></DT>
<DD>Field name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050363800000000000000">
22.6.38 ESMF_FieldEmptySet - Set a Grid in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetGrid(field, grid, StaggerLoc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_Grid), intent(in) :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_STAGGERLOC), intent(in), optional :: StaggerLoc
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Set a grid and an optional staggerloc (default to center stagger
   <TT>ESMF_STAGGERLOC_CENTER</TT>) in an empty <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must be empty for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Grid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>
For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:partial_creation">22.3.7</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Grid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.
   
</DD>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[StaggerLoc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values see section <A HREF="node5.html#const:staggerloc">27.2.7</A>.
   To create a custom stagger location see section
   <A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>. The default
   value is <TT>ESMF_STAGGERLOC_CENTER</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050363900000000000000">
22.6.39 ESMF_FieldEmptySet - Set a Mesh in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetMesh(field, mesh, meshloc, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_Mesh), intent(in) :: mesh
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_MeshLoc), intent(in), optional :: meshloc
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set a mesh and an optional meshloc (default to center stagger
   <TT>ESMF_MESHLOC_NODE</TT>) in an empty <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must be empty for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Mesh</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_Mesh</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.
   
</DD>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[location]</STRONG></DT>
<DD>Which part of the mesh to build the Field on. Can be set to either
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set,
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050364000000000000000">
22.6.40 ESMF_FieldEmptySet - Set a LocStream in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetLocStream(field, locstream, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_LocStream), intent(in) :: locstream
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set a <TT>ESMF_LocStream</TT> in an empty <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must be empty for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_LocStream</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_LocStream</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

</DD>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050364100000000000000">
22.6.41 ESMF_FieldEmptySet - Set an XGrid in an empty Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldEmptySet()
   subroutine ESMF_FieldEmptySetXGrid(field, xgrid, xgridside, gridindex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field
   type(ESMF_XGrid), intent(in) :: xgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_XGridSide_Flag), intent(in), optional :: xgridside
   integer, intent(in), optional :: gridindex
   integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set a xgrid and optional xgridside (default to balanced side
   <TT>ESMF_XGRIDSIDE_Balanced</TT>) and gridindex (default to 1)
   in an empty <TT>ESMF_Field</TT>. The
   <TT>ESMF_Field</TT> must be empty for this to succeed. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_XGrid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

<P>

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Empty <TT>ESMF_Field</TT>. After this
   operation, the <TT>ESMF_Field</TT> contains
   the <TT>ESMF_XGrid</TT> internally but holds no data.
   The status of the field changes from
   <TT>ESMF_FIELDSTATUS_EMPTY</TT> to <TT>ESMF_FIELDSTATUS_GRIDSET</TT>.

</DD>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> to be set in the <TT>ESMF_Field</TT>.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Side of XGrid to retrieve a DistGrid. For valid
   predefined values see section <A HREF="node5.html#const:xgridside">30.2.1</A>.
   The default value is <TT>ESMF_XGRIDSIDE_BALANCED</TT>.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>Index to specify which DistGrid when on side A or side B.
   The default value is 1.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050364200000000000000">
22.6.42 ESMF_FieldGet - Return info associated with a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet()
   subroutine ESMF_FieldGetDefault(field, arrayspec, &amp;
     status, geomtype, grid, mesh, locstream, xgrid, array, &amp;
     typekind, dimCount, rank, staggerloc, meshloc, xgridside, &amp;
     gridindex, gridToFieldMap, ungriddedLBound, ungriddedUBound, &amp;
     totalLWidth, totalUWidth, localDeCount, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ArraySpec), intent(out), optional :: arrayspec
     type(ESMF_FieldStatus_Flag),intent(out), optional :: status
     type(ESMF_GeomType_Flag), intent(out), optional :: geomtype
     type(ESMF_Grid), intent(out), optional :: grid
     type(ESMF_Mesh), intent(out), optional :: mesh
     type(ESMF_LocStream), intent(out), optional :: locstream
     type(ESMF_XGrid), intent(out), optional :: xgrid
     type(ESMF_Array), intent(out), optional :: array
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer, intent(out), optional :: dimCount
     integer, intent(out), optional :: rank
     type(ESMF_StaggerLoc), intent(out), optional :: staggerloc
     type(ESMF_MeshLoc), intent(out), optional :: meshloc
     type(ESMF_XGridSide_Flag), intent(out), optional :: xgridside
     integer, intent(out), optional :: gridindex
     integer, intent(out), optional :: gridToFieldMap(:)
     integer, intent(out), optional :: ungriddedLBound(:)
     integer, intent(out), optional :: ungriddedUBound(:)
     integer, intent(out), optional :: totalLWidth(:,:)
     integer, intent(out), optional :: totalUWidth(:,:)
     integer, intent(out), optional :: localDeCount
     character(len=*), intent(out), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r - <EM>except those arguments indicated below</EM>.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Query an <TT>ESMF_Field</TT> for various things. All arguments after
   the <TT>field</TT> are optional. To select individual items use the
   named_argument=value syntax. For an example and
   associated documentation using this method see section
   <A HREF="node5.html#sec:field:usage:field_get_default">22.3.3</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object to query.
   
</DD>
<DT><STRONG>[arrayspec]</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information
   of the Field object.
   
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>The status of the Field. See section <A HREF="node5.html#const:fieldstatus">22.2.1</A> for a
   complete list of values.

</DD>
<DT><STRONG>[geomtype]</STRONG></DT>
<DD>The type of geometry on which the Field is built. See
   section&nbsp;<A HREF="node2.html#const:geomtype">9.19</A> for the range of values.
   
</DD>
<DT><STRONG>[grid]</STRONG></DT>
<DD><TT>ESMF_Grid</TT>.
   
</DD>
<DT><STRONG>[mesh]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>   <TT>ESMF_Mesh</TT>.
   
</DD>
<DT><STRONG>[locstream]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>   <TT>ESMF_LocStream</TT>.
   
</DD>
<DT><STRONG>[xgrid]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>   <TT>ESMF_XGrid</TT>.
   
</DD>
<DT><STRONG>[array]</STRONG></DT>
<DD><TT>ESMF_Array</TT>.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind specifier for Field. See section <A HREF="node2.html#const:typekind">9.45</A> for a
   complete list of values.
   
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of geometrical dimensions in <TT>field</TT>.
   For an detailed discussion of this parameter, please see
   section <A HREF="node5.html#sec:field:usage:createArbGrid">22.3.22</A> and
   section <A HREF="node5.html#sec:field:usage:createArbGridRep">22.3.23</A>.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Number of dimensions in the physical memory of the <TT>field</TT> data. It is
   identical to dimCount when the corresponding grid is a non-arbitrary grid.
   It is less than dimCount when the grid is arbitrarily distributed.
   For an detailed discussion of this parameter, please see
   section <A HREF="node5.html#sec:field:usage:createArbGrid">22.3.22</A> and
   section <A HREF="node5.html#sec:field:usage:createArbGridRep">22.3.23</A>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells. For valid
   predefined values and interpretation of results see
   section <A HREF="node5.html#const:staggerloc">27.2.7</A>.
   
</DD>
<DT><STRONG>[meshloc]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>
The part of the mesh to build the Field on. Can be either
   <TT>ESMF_MESHLOC_NODE</TT> or <TT>ESMF_MESHLOC_ELEMENT</TT>. If not set,
   defaults to <TT>ESMF_MESHLOC_NODE</TT>.

</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>
The side of the XGrid that the Field was created on. See section
   <A HREF="node5.html#const:xgridside">30.2.1</A> for a complete list of values.

</DD>
<DT><STRONG>[gridIndex]</STRONG></DT>
<DD>S<SMALL>TATUS:</SMALL><EM>This argument is excluded from the backward compatibility statement</EM>.
<BR>
If xgridside is <TT>ESMF_XGRIDSIDE_A</TT> or <TT>ESMF_XGRIDSIDE_B</TT>
   then this index tells which Grid/Mesh on that side the Field was
   created on.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
   <TT>grid</TT>'s dimCount. The list elements map each dimension
   of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
   specifying the appropriate <TT>field</TT> dimension index. The default is to
   map all of the <TT>grid</TT>'s dimensions against the lowest dimensions of
   the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
   The total ungridded dimensions in the <TT>field</TT>
   are the total <TT>field</TT> dimensions less
   the dimensions in
   the <TT>grid</TT>. Ungridded dimensions must be in the same order they are
   stored in the field.
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
   The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
   dimensions in the <TT>field</TT>. All ungridded dimensions of the
   <TT>field</TT> are also undistributed. When field dimension count is
   greater than grid dimension count, both ungriddedLBound and ungriddedUBound
   must be specified. When both are specified the values are checked
   for consistency. Note that the the ordering of
   these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region. The size of the first dimension of this array is the number
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalLWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   The size of the 2nd dimension of this array is localDeCount.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region. The size of the first dimension of this array is the number
   of gridded dimensions in the <TT>field</TT>. However, ordering of the elements
   needs to be the same as they appear in the <TT>field</TT>. Values default
   to 0. If values for totalUWidth are specified they must be reflected in
   the size of the <TT>field</TT>. That is, for each gridded dimension the
   <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
   + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   The size of the 2nd dimension of this array is localDeCount.
   
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>Upon return this holds the number of PET-local DEs defined in
   the DELayout associated with the Field object.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of queried item.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050364300000000000000">
22.6.43 ESMF_FieldGet - Get Fortran data pointer from a Field </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGet() 
   subroutine ESMF_FieldGetDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, localDe, &amp; 
   farrayPtr, exclusiveLBound, exclusiveUBound, exclusiveCount, &amp; 
   computationalLBound, computationalUBound, computationalCount, &amp; 
   totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: localDe 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   integer, intent(out), optional :: exclusiveLBound(:) 
   integer, intent(out), optional :: exclusiveUBound(:) 
   integer, intent(out), optional :: exclusiveCount(:) 
   integer, intent(out), optional :: computationalLBound(:) 
   integer, intent(out), optional :: computationalUBound(:) 
   integer, intent(out), optional :: computationalCount(:) 
   integer, intent(out), optional :: totalLBound(:) 
   integer, intent(out), optional :: totalUBound(:) 
   integer, intent(out), optional :: totalCount(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get a Fortran pointer to DE-local memory allocation within <TT>field</TT>. 
   For convenience DE-local bounds can be queried at the same time. 
   For an example and 
   associated documentation using this method see section 
   <A HREF="node5.html#sec:field:usage:field_get_dataptr">22.3.2</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> object. 
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>. 
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted, 
   in which case it will default to <TT>localDe=0</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Fortran array pointer which will be pointed at DE-local memory allocation. 
   It depends on the specific entry point 
   of <TT>ESMF_FieldCreate()</TT> used during <TT>field</TT> creation, which 
   Fortran operations are supported on the returned <TT>farrayPtr</TT>. See 
   <A HREF="node5.html#Field:rest">22.4</A> for more details. 
   
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region. 
   <TT>exclusiveLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region. 
   <TT>exclusiveUBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>, 
   in the exclusive region per dimension. 
   <TT>exclusiveCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region. 
   <TT>computationalLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region. 
   <TT>computationalUBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension 
   (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region. 
   <TT>totalLBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region. 
   <TT>totalUBound</TT> must be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts. 
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension 
   (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>computationalCount</TT> must 
   be allocated to be of size equal to <TT>field</TT>'s <TT>dimCount</TT>. 
   See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A> for a description 
   of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050364400000000000000">
22.6.44 ESMF_FieldGetBounds - Get Field data bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldGetBounds()
   subroutine ESMF_FieldGetBounds(field, localDe, &amp;
     exclusiveLBound, exclusiveUBound, exclusiveCount, computationalLBound, &amp;
     computationalUBound, computationalCount, totalLBound, &amp;
     totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in) :: field
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: localDe
     integer, intent(out), optional :: exclusiveLBound(:)
     integer, intent(out), optional :: exclusiveUBound(:)
     integer, intent(out), optional :: exclusiveCount(:)
     integer, intent(out), optional :: computationalLBound(:)
     integer, intent(out), optional :: computationalUBound(:)
     integer, intent(out), optional :: computationalCount(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method returns the bounds information of a field that consists of a
   internal grid and a internal array. The exclusive and computational bounds
   are shared between the grid and the array but the total bounds are the array
   bounds plus the halo width. The count is the number of elements between each
   bound pair.

<P>
The arguments are:
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Field to get the information from.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
   <TT>exclusiveLBound</TT> must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
   <TT>exclusiveUBound</TT> must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>,
   in the exclusive region per dimension.
   <TT>exclusiveCount</TT> must
   be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
   <TT>computationalLBound</TT> must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
   <TT>computationalUBound</TT> must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
   (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
   must be allocated to be of size equal to the field rank.
   Please see section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
   of the regions and their associated bounds and counts.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
   <TT>totalLBound</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
   <TT>totalUBound</TT> must be allocated to be of size equal to the field rank.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
   (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
   be allocated to be of size equal to the field rank.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<H3><A NAME="SECTION050364500000000000000">
22.6.45 ESMF_FieldPrint - Print the contents of a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldPrint(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field), intent(in)            :: field 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>field</TT> to <TT>stdout</TT>.
       This subroutine goes through the internal data members of a field
       data type and prints information of each data member. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>field</STRONG></DT>
<DD>An <TT>ESMF_Field</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050364600000000000000">
22.6.46 ESMF_FieldRead - Read Field data from a file</A>
</H3>

<P>
<A NAME="api:FieldRead"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldRead(field, file, &amp;
         timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field),     intent(inout)          :: field 
       character(*),         intent(in)             :: file 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,              intent(in),  optional  :: timeslice
       type(ESMF_IOFmtFlag), intent(in),  optional  :: iofmt 
       integer,              intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Read Field data from a file and put it into an ESMF_Field object.
     For this API to be functional, the environment variable <TT>ESMF_PIO</TT>
     should be set to "internal" when the ESMF library is built.
     Please see the section on Data I/O,&nbsp;<A HREF="node5.html#io:dataio">32.3</A>.

<P>
Limitations:
     
<UL>
<LI>Only 1 DE per PET supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object in which the read data is returned.
     
</DD>
<DT><STRONG>file</STRONG></DT>
<DD>The name of the file from which Field data is read.
     
</DD>
<DT><STRONG>timeslice</STRONG></DT>
<DD>Number of slices to be read from file, starting from the 1st slice
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format.  Please see Section&nbsp;<A HREF="node2.html#opt:iofmtflag">9.25</A> for the list 
       of options.  If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050364700000000000000">
22.6.47 ESMF_FieldValidate - Check validity of a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldValidate(field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field), intent(in)            :: field 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>field</TT> is internally consistent.
        Currently this method determines if the <TT>field</TT> is uninitialized 
        or already destroyed. It validates the contained array and grid objects.
        The code also checks if the array and grid sizes agree.
        This check compares the distgrid contained in array and grid; 
        then it proceeds to compare the computational bounds contained 
        in array and grid. 

<P>
The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> to validate.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the <TT>field</TT> 
             is valid.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050364800000000000000">
22.6.48 ESMF_FieldWrite - Write Field data into a file</A>
</H3>

<P>
<A NAME="api:FieldWrite"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldWrite(field, file, &amp;
         append, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field),     intent(in)             :: field 
       character(*),         intent(in)             :: file 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,              intent(in),  optional  :: append
       integer,              intent(in),  optional  :: timeslice
       type(ESMF_IOFmtFlag), intent(in),  optional  :: iofmt
       integer,              intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write Field data into a file.  For this API to be functional, the 
     environment variable <TT>ESMF_PIO</TT> should be set to "internal" when 
     the ESMF library is built.  Please see the section on 
     Data I/O,&nbsp;<A HREF="node5.html#io:dataio">32.3</A>.

<P>
Limitations:
     
<UL>
<LI>Only 1 DE per PET supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object that contains data to be written.
     
</DD>
<DT><STRONG>file</STRONG></DT>
<DD>The name of the output file to which Field data is written.
     
</DD>
<DT><STRONG>[append]</STRONG></DT>
<DD>Logical: if .true., data (with attributes) is appended to an
       existing file; default is .false.
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Some IO formats (e.g. NetCDF) support the output of data in form of
       time slices. The <TT>timeslice</TT> argument provides access to this
       capability. Usage of this feature requires that the first slice is
       written with a positive <TT>timeslice</TT> value, and that subsequent slices
       are written with a <TT>timeslice</TT> argument that increments by one each
       time. By default, i.e. by omitting the <TT>timeslice</TT> argument, no
       provisions for time slicing are made in the output file.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format. Please see Section&nbsp;<A HREF="node2.html#opt:iofmtflag">9.25</A> for the list 
       of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION05037000000000000000">
22.7 Class API: Field Utilities</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05037100000000000000">
22.7.1 ESMF_GridGetFieldBounds - Get precomputed Fortran data array bounds for creating a Field from a Grid and Fortran array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_GridGetFieldBounds(grid, &amp;
         localDe, staggerloc, gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLWidth, totalUWidth, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid),       intent(in)            :: grid     
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,               intent(in),  optional :: localDe
     type(ESMF_StaggerLoc), intent(in),  optional :: staggerloc 
     integer,               intent(in),  optional :: gridToFieldMap(:)    
     integer,               intent(in),  optional :: ungriddedLBound(:)
     integer,               intent(in),  optional :: ungriddedUBound(:)
     integer,               intent(in),  optional :: totalLWidth(:)
     integer,               intent(in),  optional :: totalUWidth(:)
     integer,               intent(out), optional :: totalLBound(:)
     integer,               intent(out), optional :: totalUBound(:)
     integer,               intent(out), optional :: totalCount(:)
     integer,               intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_Grid</TT> and the Fortran data array. For an example and
   associated documentation using this method see section 
   <A HREF="node5.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">22.3.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT>.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
         For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
         in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>Stagger location of data in grid cells.  For valid
         predefined values and interpretation of results see
         section <A HREF="node5.html#const:staggerloc">27.2.7</A>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
         <TT>grid</TT>|s dimCount.  The list elements map each dimension
         of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
         specifying the appropriate <TT>field</TT> dimension index. The default is to
         map all of the <TT>grid</TT>|s dimensions against the lowest dimensions of
         the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
         The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
         to one and smaller than or equal to the <TT>field</TT> rank.
         It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
         multiple times. The total ungridded dimensions in the <TT>field</TT>
         are the total <TT>field</TT> dimensions less
         the dimensions in
         the <TT>grid</TT>.  Ungridded dimensions must be in the same order they are
         stored in the <TT>field</TT>.  
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than grid dimension count, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than grid dimension count, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Lower bound of halo region.  The size of this array is the number
         of dimensions in the <TT>grid</TT>.  However, ordering of the elements
         needs to be the same as they appear in the <TT>field</TT>.  Values default
         to 0.  If values for totalLWidth are specified they must be reflected in
         the size of the <TT>field</TT>.  That is, for each gridded dimension the
         <TT>field</TT> size should be max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
         + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upper bound of halo region.  The size of this array is the number
         of dimensions in the <TT>grid</TT>.  However, ordering of the elements
         needs to be the same as they appear in the <TT>field</TT>.  Values default
         to 0.  If values for totalUWidth are specified they must be reflected in
         the size of the <TT>field</TT>.  That is, for each gridded dimension the
         <TT>field</TT> size should max( <TT>totalLWidth</TT> + <TT>totalUWidth</TT>
         + <TT>computationalCount</TT>, <TT>exclusiveCount</TT> ).
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Grid</TT> and Fortran data array.
         This is an output variable from this user interface.
         
         The relative lower bounds of Fortran data array to be used
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Grid</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Grid</TT> and Fortran data array.
         This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05037200000000000000">
22.7.2 ESMF_LocStreamGetFieldBounds - Get precomputed Fortran data array bounds for creating a Field from a LocStream and Fortran array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_LocStreamGetFieldBounds(locstream, &amp;
         localDe, gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in)            :: locstream     
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(in),  optional :: localDe
     integer,              intent(in),  optional :: gridToFieldMap(:)    
     integer,              intent(in),  optional :: ungriddedLBound(:)
     integer,              intent(in),  optional :: ungriddedUBound(:)
     integer,              intent(out), optional :: totalLBound(:)
     integer,              intent(out), optional :: totalUBound(:)
     integer,              intent(out), optional :: totalCount(:)
     integer,              intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_LocStream</TT> and the Fortran data array.  For an example and
   associated documentation using this method see section 
   <A HREF="node5.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">22.3.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT>.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
         For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
         in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to 1.
         The list elements map the dimension
         of the <TT>locstream</TT> to a dimension in the <TT>field</TT> by
         specifying the appropriate <TT>field</TT> dimension index. The default is to
         map the <TT>locstream</TT>|s dimension against the lowest dimension of
         the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1/).
         The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
         to one and smaller than or equal to the <TT>field</TT> rank.
         The total ungridded dimensions in the <TT>field</TT>
         are the total <TT>field</TT> dimensions less
         the dimensions in
         the <TT>grid</TT>.  Ungridded dimensions must be in the same order they are
         stored in the field.  
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than 1, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than 1, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05037300000000000000">
22.7.3 ESMF_MeshGetFieldBounds - Get precomputed Fortran data array bounds for creating a Field from a Mesh and a Fortran array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_MeshGetFieldBounds(mesh, &amp;
         localDe, gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in)            :: mesh     
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,         intent(in),  optional :: localDe
     integer,         intent(in),  optional :: gridToFieldMap(:)    
     integer,         intent(in),  optional :: ungriddedLBound(:)
     integer,         intent(in),  optional :: ungriddedUBound(:)
     integer,         intent(out), optional :: totalLBound(:)
     integer,         intent(out), optional :: totalUBound(:)
     integer,         intent(out), optional :: totalCount(:)
     integer,         intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_Mesh</TT> and the Fortran data array. For an example and
   associated documentation using this method see section 
   <A HREF="node5.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">22.3.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD><TT>ESMF_Mesh</TT>.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
         For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
         in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to the
         <TT>grid</TT>|s dimCount.  The list elements map each dimension
         of the <TT>grid</TT> to a dimension in the <TT>field</TT> by
         specifying the appropriate <TT>field</TT> dimension index. The default is to
         map all of the <TT>grid</TT>|s dimensions against the lowest dimensions of
         the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1,2,3,.../).
         The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
         to one and smaller than or equal to the <TT>field</TT> rank.
         It is erroneous to specify the same <TT>gridToFieldMap</TT> entry
         multiple times. The total ungridded dimensions in the <TT>field</TT>
         are the total <TT>field</TT> dimensions less
         the dimensions in
         the <TT>grid</TT>.  Ungridded dimensions must be in the same order they are
         stored in the field.  
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than grid dimension count, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than grid dimension count, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Mesh</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Mesh</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_Mesh</TT> and Fortran data array.
         This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05037400000000000000">
22.7.4 ESMF_XGridGetFieldBounds - Get precomputed Fortran data array bounds for creating a Field from an XGrid and a Fortran array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_XGridGetFieldBounds(xgrid, &amp;
         xgridside, gridindex, localDe, gridToFieldMap, &amp;
         ungriddedLBound, ungriddedUBound, &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid),          intent(in)            :: xgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_XGridSide_Flag), intent(in),  optional :: xgridside
     integer,                   intent(in),  optional :: gridindex
     integer,                   intent(in),  optional :: localDe
     integer,                   intent(in),  optional :: gridToFieldMap(:)    
     integer,                   intent(in),  optional :: ungriddedLBound(:)
     integer,                   intent(in),  optional :: ungriddedUBound(:)
     integer,                   intent(out), optional :: totalLBound(:)
     integer,                   intent(out), optional :: totalUBound(:)
     integer,                   intent(out), optional :: totalCount(:)
     integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compute the lower and upper bounds of Fortran data array that can later
   be used in FieldCreate interface to create a <TT>ESMF_Field</TT> from a
   <TT>ESMF_XGrid</TT> and the Fortran data array.  For an example and
   associated documentation using this method see section 
   <A HREF="node5.html#sec:field:usage:create_5dgrid_7dptr_2dungridded">22.3.9</A>.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to create the Field on (either ESMF_XGRIDSIDE_A,
         ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
         defaults to ESMF_XGRIDSIDE_BALANCED.
   
</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridside is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index tells which Grid on
         that side to create the Field on. If not provided, defaults to 1.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
         For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
         in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[gridToFieldMap]</STRONG></DT>
<DD>List with number of elements equal to 1.
         The list elements map the dimension
         of the <TT>locstream</TT> to a dimension in the <TT>field</TT> by
         specifying the appropriate <TT>field</TT> dimension index. The default is to
         map the <TT>locstream</TT>|s dimension against the lowest dimension of
         the <TT>field</TT> in sequence, i.e. <TT>gridToFieldMap</TT> = (/1/).
         The values of all <TT>gridToFieldMap</TT> entries must be greater than or equal
         to one and smaller than or equal to the <TT>field</TT> rank.
         The total ungridded dimensions in the <TT>field</TT>
         are the total <TT>field</TT> dimensions less
         the dimensions in
         the <TT>grid</TT>.  Ungridded dimensions must be in the same order they are
         stored in the field.  
   
</DD>
<DT><STRONG>[ungriddedLBound]</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedLBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than 1, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[ungriddedUBound]</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the <TT>field</TT>.
         The number of elements in the <TT>ungriddedUBound</TT> is equal to the number of ungridded
         dimensions in the <TT>field</TT>.  All ungridded dimensions of the
         <TT>field</TT> are also undistributed. When field dimension count is
         greater than 1, both ungriddedLBound and ungriddedUBound
         must be specified. When both are specified the values are checked
         for consistency.  Note that the the ordering of
         these ungridded dimensions is the same as their order in the <TT>field</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>The relative lower bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>The relative upper bounds of Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Number of elements need to be allocated for Fortran data array to be used
         later in <TT>ESMF_FieldCreate</TT> from <TT>ESMF_LocStream</TT> and Fortran data array.
         This is an output variable from this user interface.

<P>
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<H2><A NAME="SECTION05038000000000000000">
22.8 Class API: Field Communications</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05038100000000000000">
22.8.1 ESMF_FieldGather - Gather a Fortran array from an ESMF_Field </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldGather&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, farray, &amp; 
   rootPet, tile, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(in) :: field 
   &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(out), target :: farray(&lt;rank&gt;) 
   integer, intent(in) :: rootPet 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: tile 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gather the data of an ESMF_Field object into the <TT>farray</TT> located on 
   <TT>rootPET</TT>. A single DistGrid tile of <TT>array</TT> must be 
   gathered into <TT>farray</TT>. The optional <TT>tile</TT> 
   argument allows selection of the tile. For Fields defined on a single 
   tile DistGrid the default selection (tile 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the tile in Field. 

<P>
If the Field contains replicating DistGrid dimensions data will be 
   gathered from the numerically higher DEs. Replicated data elements in 
   numericaly lower DEs will be ignored. 

<P>
The implementation of Scatter and Gather is not seqence index based. 
   If the Field is built on arbitrarily distributed Grid, Mesh, LocStream or XGrid, 
   Gather will not gather data to rootPet 
   from source data points corresponding to the sequence index on rootPet. 
   Instead Gather will gather a contiguous memory range from source PET to 
   rootPet. The size of the memory range is equal to the number of 
   data elements on the source PET. Vice versa for the Scatter operation. 
   In this case, the user should use <TT>ESMF_FieldRedist</TT> to achieve 
   the same data operation result. For examples how to use <TT>ESMF_FieldRedist</TT> 
   to perform Gather and Scatter, please refer to 
   <A HREF="node5.html#sec:field:usage:redist_gathering">22.3.35</A> and 
   <A HREF="node5.html#sec:field:usage:redist_scattering">22.3.34</A>. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
For examples and associated documentations using this method see Section 
   <A HREF="node5.html#sec:field:usage:gather_2dptr">22.3.31</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object from which data will be gathered. 
   
</DD>
<DT><STRONG>{farray}</STRONG></DT>
<DD>The Fortran array into which to gather data. Only root 
   must provide a valid <TT>farray</TT>, the other PETs may treat 
   <TT>farray</TT> as an optional argument. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid destination array, i.e. <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The DistGrid tile in <TT>field</TT> from which to gather <TT>farray</TT>. 
   By default <TT>farray</TT> will be gathered from tile 1. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05038200000000000000">
22.8.2 ESMF_FieldHalo - Execute a FieldHalo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldHalo(field, routehandle,  &amp;
                             routesyncflag, finishedflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),       intent(inout)           :: field
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag), intent(in), optional :: routesyncflag
     logical,                intent(out),  optional  :: finishedflag
     logical,                intent(in),   optional  :: checkflag
     integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field halo operation for <TT>field</TT>. The <TT>field</TT>
     argument must be weakly congruent and typekind conform to the Field used
     during <TT>ESMF_FieldHaloStore()</TT>.
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions.

<P>
See <TT>ESMF_FieldHaloStore()</TT> on how to precompute <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[routesyncflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_ROUTESYNC_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node2.html#const:routesync">9.38</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>, or a final call with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT>. For all other <TT>routesyncflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.

</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05038300000000000000">
22.8.3 ESMF_FieldHaloRelease - Release resources associated with a Field halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldHaloRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with a Field halo operation.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05038400000000000000">
22.8.4 ESMF_FieldHaloStore - Store a FieldHalo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_FieldHaloStore(field, routehandle,  &amp;
       startregion, haloLDepth, haloUDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),       intent(inout)                :: field
     type(ESMF_RouteHandle), intent(inout)                :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_StartRegion_Flag), intent(in),    optional :: startregion
     integer,                intent(in),         optional :: haloLDepth(:)
     integer,                intent(in),         optional :: haloUDepth(:)
     integer,                intent(out),        optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a Field halo operation over the data in <TT>field</TT>. By default,
     i.e. without specifying <TT>startregion</TT>, <TT>haloLDepth</TT> and
     <TT>haloUDepth</TT>, all elements in the total Field region that lie outside
     the exclusive region will be considered potential destination elements for
     halo. However, only those elements that have a corresponding halo source
     element, i.e. an exclusive element on one of the DEs, will be updated under
     the halo operation. Elements that have no associated source remain 
     unchanged under halo.

<P>
Specifying <TT>startregion</TT> allows to change the shape of the 
     effective halo region from the inside. Setting this flag to
     <TT>ESMF_STARTREGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region of the Field are considered for potential
     destination elements for halo. The default is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>startregion</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total Field region, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Field region is
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldHalo()</TT> on any Field that is weakly congruent
     and typekind conform to <TT>field</TT>.
     Congruent Fields possess matching DistGrids, and the shape of the local
     field tiles matches between the Fieldss for every DE. For weakly congruent
     Fieldss the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fieldss that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>field</STRONG></DT>
<DD><TT>ESMF_Field</TT> containing data to be haloed. The data in this Field may be
       destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[startregion]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elments.
       See section <A HREF="node2.html#const:startregion">9.41</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>startregion</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>startregion</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05038500000000000000">
22.8.5 ESMF_FieldRedist - Execute a Field redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldRedist(srcField, dstField, routehandle,  &amp;
     checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),       intent(in),optional     :: srcField
         type(ESMF_Field),       intent(inout),optional  :: dstField
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field redistribution from <TT>srcField</TT> to
     <TT>dstField</TT>. Both <TT>srcField</TT> and <TT>dstField</TT> must be
     congruent and typekind conform with the respective Fields used during 
     <TT>ESMF_FieldRedistStore()</TT>. Congruent Fields possess
     matching DistGrids and the shape of the local array tiles matches between
     the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field redist feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
See <TT>ESMF_FieldRedistStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentations using this method see Section  
     <A HREF="node5.html#sec:field:usage:redist_1dptr">22.3.33</A>. 

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05038600000000000000">
22.8.6 ESMF_FieldRedistRelease - Release resources associated with Field redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldRedistRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with a Field redistribution. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05038700000000000000">
22.8.7 ESMF_FieldRedistStore - Precompute Field redistribution with a local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldRedistStore() 
   subroutine ESMF_FieldRedistStore&lt;type&gt;&lt;kind&gt;(srcField, dstField, &amp; 
          routehandle, factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(in)            :: srcField  
     type(ESMF_Field),         intent(inout)         :: dstField  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factor 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(in), optional  :: srcToDstTransposeMap(:) 
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="FieldRedistStoreTK"></A>   <TT>ESMF_FieldRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_FieldRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_FieldRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node5.html#FieldRedistStoreTK">22.8.7</A> and
   <A HREF="node5.html#FieldRedistStoreNF">22.8.8</A>, is described in the following paragraphs as a whole.

<P>
Store a Field redistribution operation from <TT>srcField</TT> to <TT>dstField</TT>.
   Interface <A HREF="node5.html#FieldRedistStoreTK">22.8.7</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="node5.html#FieldRedistStoreNF">22.8.8</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Field, destination Field, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Fields may differ in shape,
   however, the number of elements must match. 

<P>
If <TT>srcToDstTransposeMap</TT> is not specified the redistribution corresponds
   to an identity mapping of the sequentialized source Field to the
   sequentialized destination Field. If the <TT>srcToDstTransposeMap</TT>
   argument is provided it must be identical on all PETs. The
   <TT>srcToDstTransposeMap</TT> allows source and destination Field dimensions to
   be transposed during the redistribution. The number of source and destination
   Field dimensions must be equal under this condition and the size of mapped
   dimensions must match.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
   <TT>dstField</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldRedist()</TT> on any pair of Fields that are weakly congruent
     and typekind conform with the <TT>srcField</TT>, <TT>dstField</TT> pair. 
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field redist feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node5.html#sec:field:usage:redist_1dptr">22.3.33</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multiply data. Default is 1. See full method
     description above for details on the interplay with other PETs.
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcField</TT>. Each
     entry maps the corresponding <TT>srcField</TT> dimension against the specified
     <TT>dstField</TT> dimension. Mixing of distributed and undistributed
     dimensions is supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05038800000000000000">
22.8.8 ESMF_FieldRedistStore - Precompute Field redistribution without a local factor argument </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldRedistStore() 
   subroutine ESMF_FieldRedistStoreNF(srcField, dstField, &amp; 
          routehandle, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),       intent(in)            :: srcField  
     type(ESMF_Field),       intent(inout)         :: dstField  
     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: srcToDstTransposeMap(:) 
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="FieldRedistStoreNF"></A>   <TT>ESMF_FieldRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_FieldRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_FieldRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node5.html#FieldRedistStoreTK">22.8.7</A> and
   <A HREF="node5.html#FieldRedistStoreNF">22.8.8</A>, is described in the following paragraphs as a whole.

<P>
Store a Field redistribution operation from <TT>srcField</TT> to <TT>dstField</TT>.
   Interface <A HREF="node5.html#FieldRedistStoreTK">22.8.7</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="node5.html#FieldRedistStoreNF">22.8.8</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Field, destination Field, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Fields may differ in shape,
   however, the number of elements must match. 

<P>
If <TT>srcToDstTransposeMap</TT> is not specified the redistribution corresponds
   to an identity mapping of the sequentialized source Field to the
   sequentialized destination Field. If the <TT>srcToDstTransposeMap</TT>
   argument is provided it must be identical on all PETs. The
   <TT>srcToDstTransposeMap</TT> allows source and destination Field dimensions to
   be transposed during the redistribution. The number of source and destination
   Field dimensions must be equal under this condition and the size of mapped
   dimensions must match.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
   <TT>dstField</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldRedist()</TT> on any pair of Fields that are weakly congruent
     and typekind conform with the <TT>srcField</TT>, <TT>dstField</TT> pair. 
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field redist feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node5.html#sec:field:usage:redist_1dptr">22.3.33</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcField</TT>. Each
     entry maps the corresponding <TT>srcField</TT> dimension against the specified
     <TT>dstField</TT> dimension. Mixing of distributed and undistributed
     dimensions is supported.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05038900000000000000">
22.8.9 ESMF_FieldRegrid - Compute a regridding operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldRegrid(srcField, dstField, &amp;
                    routehandle, zeroregion, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field),       intent(in),    optional :: srcField
       type(ESMF_Field),       intent(inout), optional :: dstField
       type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_Region_Flag), intent(in),    optional :: zeroregion
       logical,                intent(in),    optional :: checkflag
       integer,                intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute the precomputed regrid operation stored in <TT>routehandle</TT> to 
     interpolate from <TT>srcField</TT> to <TT>dstField</TT>.  See <TT>ESMF_FieldRegridStore()</TT> on how to 
     precompute the <TT>routehandle</TT>. 

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> must be
     congruent with the respective Fields used during 
     <TT>ESMF_FieldRegridStore()</TT>. In the case of the Regrid operation congruent 
     Fields are built upon the same stagger location and on the same Grid. The routehandle represents
     the interpolation between the Grids as they were during the <TT>ESMF_FieldRegridStore()</TT> call.  
     So if the coordinates at the stagger location in the Grids change, a new call to <TT>ESMF_FieldRegridStore()</TT> 
     is necessary to compute the interpolation between that new set of coordinates.
     Note <TT>ESMF_FieldRegridStore()</TT> assumes the coordinates used in the Grids upon which the Fields are built are
     in degrees.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstField</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstField</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#const:region">9.36</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050381000000000000000">
22.8.10 ESMF_FieldRegridRelease - Free resources used by a regridding operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_FieldRegridRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Free resources used by regrid objec

<P>
The arguments are:
       <DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle carrying the sparse matrix
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050381100000000000000">
22.8.11 ESMF_FieldRegridStore - Precompute a Field regridding operation and return a RouteHandle and weights</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   !   Private name; call using ESMF_FieldRegridStore()
       subroutine ESMF_FieldRegridStoreNX(srcField, dstField, &amp;
                                        srcMaskValues, dstMaskValues, &amp;
                                        regridmethod, &amp;
                                        polemethod, regridPoleNPnts, &amp; 
                                        unmappedaction, &amp;
                                        routehandle, indices, weights, &amp; 
                                        srcFracField, dstFracField, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Field),            intent(in)             :: srcField
       type(ESMF_Field),            intent(inout)          :: dstField
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer(ESMF_KIND_I4),       intent(in),   optional :: srcMaskValues(:)
       integer(ESMF_KIND_I4),       intent(in),   optional :: dstMaskValues(:)
       type(ESMF_RegridMethod_Flag),intent(in),   optional :: regridmethod
       type(ESMF_PoleMethod_Flag),  intent(in),   optional :: polemethod
       integer,                     intent(in),   optional :: regridPoleNPnts
       type(ESMF_UnmappedAction_Flag),intent(in), optional :: unmappedaction
       type(ESMF_RouteHandle),      intent(inout),optional :: routehandle
       integer(ESMF_KIND_I4),       pointer,      optional :: indices(:,:)
       real(ESMF_KIND_R8),          pointer,      optional :: weights(:)
       type(ESMF_Field),            intent(inout),optional :: srcFracField
       type(ESMF_Field),            intent(inout),optional :: dstFracField
       integer,                      intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a sparse matrix operation (stored in <TT>routehandle</TT>) that 
         contains the calculations and communications necessary to interpolate
         from <TT>srcField</TT> to <TT>dstField</TT>. The routehandle can then be 
         used in the call <TT>ESMF_FieldRegrid()</TT> to interpolate between the
         Fields. The user may also get the interpolation matrix in sparse 
         matrix form via the optional arguments <TT>indices</TT> and <TT>weights</TT>.

<P>
The routehandle generated by this call is based just on the 
         coordinates at the Fields' stagger locations in the Grids contained 
         in the Fields.  If those coordinates don't change the routehandle can
         be used repeatedly to interpolate from the source Field to the 
         destination Field.  This is true even if the data in the Fields 
         changes. The routehandle may also be used to interpolate between any
         source and destination Field which are created on the same stagger 
         location and Grid as the original Fields.        

<P>
When it's no longer needed the routehandle should be destroyed by 
         using <TT>ESMF_FieldRegridRelease()</TT> to free the memory it's using. 
         Note <TT>ESMF_FieldRegridStore()</TT> assumes the coordinates used in 
         the Grids upon which the Fields are built are in degrees.  

<P>
The arguments are:
       <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD>Source Field.
       
</DD>
<DT><STRONG>[srcMaskValues]</STRONG></DT>
<DD>List of values that indicate a source point should be masked out. 
             If not specified, no masking will occur. 
       
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>Destination Field.
       
</DD>
<DT><STRONG>[dstMaskValues]</STRONG></DT>
<DD>List of values that indicate a destination point should be masked out. 
             If not specified, no masking will occur.
       
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Options are 
             <TT>ESMF_UNMAPPEDACTION_ERROR</TT> or 
             <TT>ESMF_UNMAPPEDACTION_IGNORE</TT>. If not specified, defaults 
             to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. 
       
</DD>
<DT><STRONG>[routehandle]</STRONG></DT>
<DD>The handle that implements the regrid and that can be used in later 
             <TT>ESMF_FieldRegrid</TT>.
       
</DD>
<DT><STRONG>[indices]</STRONG></DT>
<DD>The indices for the sparse matrix.
       
</DD>
<DT><STRONG>[weights]</STRONG></DT>
<DD>The weights for the sparse matrix.
       
</DD>
<DT><STRONG>[srcFracField]</STRONG></DT>
<DD>The fraction of each source cell participating in the regridding. Only 
             valid when regridmethod is <TT>ESMF_REGRIDMETHOD_CONSERVE</TT>.
             This Field needs to be created on the same location (e.g staggerloc) 
             as the srcField.
       
</DD>
<DT><STRONG>[dstFracField]</STRONG></DT>
<DD>The fraction of each destination cell participating in the regridding. Only 
             valid when regridmethod is <TT>ESMF_REGRIDMETHOD_CONSERVE</TT>.
             This Field needs to be created on the same location (e.g staggerloc) 
             as the dstField.
       
</DD>
<DT><STRONG>[regridmethod]</STRONG></DT>
<DD>The type of interpolation. Please see Section&nbsp;<A HREF="node5.html#opt:regridmethod">22.2.3</A> 
             for a list of valid options. If not specified, defaults to 
             <TT>ESMF_REGRIDMETHOD_BILINEAR</TT>.
       
</DD>
<DT><STRONG>[polemethod]</STRONG></DT>
<DD>Which type of artificial pole
             to construct on the source Grid for regridding. Please see 
             Section&nbsp;<A HREF="node5.html#const:polemethod">22.2.2</A> for a list of
             valid options. If not specified, defaults to <TT>ESMF_POLEMETHOD_ALLAVG</TT>. 
       
</DD>
<DT><STRONG>[regridPoleNPnts]</STRONG></DT>
<DD>If <TT>polemethod</TT> is <TT>ESMF_POLEMETHOD_NPNTAVG</TT>.
             This parameter indicates how many points should be averaged
             over. Must be specified if <TT>polemethod</TT> is 
             <TT>ESMF_POLEMETHOD_NPNTAVG</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050381200000000000000">
22.8.12 ESMF_FieldRegridStore - Precompute a Field regridding operation and return a RouteHandle using XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   !   Private name; call using ESMF_FieldRegridStore()
       subroutine ESMF_FieldRegridStoreX(xgrid, srcField, dstField, &amp;
                                        routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_XGrid),       intent(in)              :: xgrid
       type(ESMF_Field),       intent(in)              :: srcField
       type(ESMF_Field),       intent(inout)           :: dstField
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_RouteHandle), intent(inout), optional :: routehandle
       integer,                intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a sparse matrix operation (stored in <TT>routehandle</TT>) that contains the calculations and 
         communications necessary to interpolate from <TT>srcField</TT> to <TT>dstField</TT>. The routehandle can then be used in the call
         <TT>ESMF_FieldRegrid()</TT> to interpolate between the Fields. Informaton such as
         index mapping and weights are obtained from the XGrid by matching the Field Grids in the XGrid. It's important the Grids in the <TT>srcField</TT> and <TT>dstField</TT> donot match, i.e.
         they are different in either tological or geometric characteristic.

<P>
The routehandle generated by this call is subsequently computed based on these information.
         If those information don't change the routehandle can be used repeatedly to interpolate from the source Field to the destination Field. 
         This is true even if the data in the Fields changes. The routehandle may also be used to interpolate between any source and 
         destination Field which are created on the same stagger location and Grid as the original Fields.        

<P>
When it's no longer needed the routehandle should be destroyed by using <TT>ESMF_FieldRegridRelease()</TT> to free the memory it's using. 
         Note <TT>ESMF_FieldRegridStore()</TT> assumes the coordinates used in the Grids upon which the Fields are built are
     in degrees.  

<P>
The arguments are:
       <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>Exchange Grid.
       
</DD>
<DT><STRONG>srcField</STRONG></DT>
<DD>Source Field.
       
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD>Destination Field.
       
</DD>
<DT><STRONG>[routehandle]</STRONG></DT>
<DD>The handle that implements the regrid and that can be used in later 
             <TT>ESMF_FieldRegrid</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050381300000000000000">
22.8.13 ESMF_FieldScatter - Scatter a Fortran array across the ESMF_Field </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldScatter&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(field, farray, &amp; 
   rootPet, tile, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Field), intent(inout) :: field 
   mtype (ESMF_KIND_mtypekind),intent(in), target :: farray(mdim) 
   integer, intent(in) :: rootPet 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: tile 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Scatter the data of <TT>farray</TT> located on <TT>rootPET</TT> 
   across an ESMF_Field object. A single <TT>farray</TT> must be 
   scattered across a single DistGrid tile in Field. The optional <TT>tile</TT> 
   argument allows selection of the tile. For Fields defined on a single 
   tile DistGrid the default selection (tile 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the tile in Field. 

<P>
If the Field contains replicating DistGrid dimensions data will be 
   scattered across all of the replicated pieces. 

<P>
The implementation of Scatter and Gather is not seqence index based. 
   If the Field is built on arbitrarily distributed Grid, Mesh, LocStream or XGrid, 
   Scatter will not scatter data from rootPet 
   to the destination data points corresponding to the sequence index on the rootPet. 
   Instead Scatter will scatter a contiguous memory range from rootPet to 
   destination PET. The size of the memory range is equal to the number of 
   data elements on the destination PET. Vice versa for the Gather operation. 
   In this case, the user should use <TT>ESMF_FieldRedist</TT> to achieve 
   the same data operation result. For examples how to use <TT>ESMF_FieldRedist</TT> 
   to perform Gather and Scatter, please refer to 
   <A HREF="node5.html#sec:field:usage:redist_gathering">22.3.35</A> and 
   <A HREF="node5.html#sec:field:usage:redist_scattering">22.3.34</A>. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
For examples and associated documentations using this method see Section 
   <A HREF="node5.html#sec:field:usage:scatter_2dptr">22.3.32</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object across which data will be scattered. 
   
</DD>
<DT><STRONG>{farray}</STRONG></DT>
<DD>The Fortran array that is to be scattered. Only root 
   must provide a valid <TT>farray</TT>, the other PETs may treat 
   <TT>farray</TT> as an optional argument. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid data in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The DistGrid tile in <TT>field</TT> into which to scatter <TT>farray</TT>. 
   By default <TT>farray</TT> will be scattered into tile 1. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050381400000000000000">
22.8.14 ESMF_FieldSMM - Execute a Field sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldSMM(srcField, dstField, routehandle, &amp;
              zeroregion, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_Field),       intent(in),   optional  :: srcField
         type(ESMF_Field),       intent(inout),optional  :: dstField
         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         type(ESMF_Region_Flag),  intent(in),   optional :: zeroregion
         logical,                intent(in),   optional  :: checkflag
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Field sparse matrix multiplication from <TT>srcField</TT> to
     <TT>dstField</TT>. Both <TT>srcField</TT> and <TT>dstField</TT> must be
     congruent and typekind conform with the respective Fields used during 
     <TT>ESMF_FieldSMMStore()</TT>. Congruent Fields possess
     matching DistGrids and the shape of the local array tiles matches between
     the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field SMM feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
It is erroneous to specify the identical Field object for <TT>srcField</TT> and
     <TT>dstField</TT> arguments.

<P>
See <TT>ESMF_FieldSMMStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
For examples and associated documentations using this method see Section  
     <A HREF="node5.html#sec:field:usage:smm_1dptr">22.3.36</A>. 

<P>
<DL>
<DT><STRONG>[srcField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data.
     
</DD>
<DT><STRONG>[dstField]</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstField</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstField</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Field that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#const:region">9.36</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Field pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050381500000000000000">
22.8.15 ESMF_FieldSMMRelease - Release resources associated with Field </A>
</H3>

<P>
sparse matrix multiplication

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_FieldSMMRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>         type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
         integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with a Field sparse matrix multiplication. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050381600000000000000">
22.8.16 ESMF_FieldSMMStore - Precompute Field sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore() 
   subroutine ESMF_FieldSMMStore&lt;type&gt;&lt;kind&gt;(srcField, dstField, &amp; 
          routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(in)            :: srcField  
     type(ESMF_Field),         intent(inout)         :: dstField  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factorList(:) 
     integer,                  intent(in),           :: factorIndexList(:,:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a Field sparse matrix multiplication operation from <TT>srcField</TT>
   to <TT>dstField</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source Field vector to 
   the destination Field vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical Field object for srcField and dstField 
   arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldSMM()</TT> on any pair of Fields that are weakly congruent
     and typekind conform with the <TT>srcField</TT>, <TT>dstField</TT> pair. 
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field SMM feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node5.html#sec:field:usage:smm_1dptr">22.3.36</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
   
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.
       
       The second dimension of <TT>factorIndexList</TT> steps through the list of

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcField</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstField</TT>. For this format to be a valid
       option source and destination Fields must have matching number of
       tensor elements (the product of the sizes of all Field tensor dimensions).
       Under this condition an identiy matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcField</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstField</TT>.

<P>
See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of 
       Field <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050381700000000000000">
22.8.17 ESMF_FieldSMMStore - Precompute Field sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_FieldSMMStore() 
   subroutine ESMF_FieldSMMStoreNF(srcField, dstField, &amp; 
          routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field),         intent(in)            :: srcField  
     type(ESMF_Field),         intent(inout)         :: dstField  
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store a Field sparse matrix multiplication operation from <TT>srcField</TT>
   to <TT>dstField</TT>. PETs that specify non-zero matrix coefficients must use
   the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
   <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
   <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
   PET does not provide matrix elements. Alternatively, PETs that do not 
   provide matrix elements may also call into the overloaded interface
   <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcField</TT> and <TT>dstField</TT> are interpreted as sequentialized 
   vectors. The 
   sequence is defined by the order of DistGrid dimensions and the order of 
   tiles within the DistGrid or by user-supplied arbitrary sequence indices. See 
   section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of <EM>sequence indices</EM>. 
   SMM corresponds to an identity mapping of the source Field vector to 
   the destination Field vector. 

<P>
Source and destination Fields may be of different &lt;type&gt;&lt;kind&gt;. Further source 
   and destination Fields may differ in shape, however, the number of elements 
   must match. 

<P>
It is erroneous to specify the identical Field object for srcField and dstField 
   arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_FieldSMM()</TT> on any pair of Fields that are weakly congruent
     and typekind conform with the <TT>srcField</TT>, <TT>dstField</TT> pair. 
     Congruent Fields possess matching DistGrids, and the shape of the local
     array tiles matches between the Fields for every DE. For weakly congruent
     Fields the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Fields that differ in the number of elements in the left most
     undistributed dimensions. Because Grid dimensions are mapped to Field in a
     sequence order, it's necessary to map the ungridded dimensions to the first
     set of dimensions in order to use the weakly congruent Field SMM feature.
     Not providing a non-default gridToFieldMap during Field creation and then
     using such Fields in a weakly congruent manner in Field communication methods
     leads to undefined behavior.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is collective across the current VM.  

<P>
For examples and associated documentations using this method see Section  
   <A HREF="node5.html#sec:field:usage:smm_1dptr">22.3.36</A>. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>srcField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with source data. 
   
</DD>
<DT><STRONG>dstField</STRONG></DT>
<DD><TT>ESMF_Field</TT> with destination data. The data in this Field may be
       destroyed by this call.
   
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<H1><A NAME="SECTION05040000000000000000">
23 ArrayBundle Class</A>
</H1>

<P>

<H2><A NAME="SECTION05041000000000000000">
23.1 Description</A>
</H2>

<P>
The <TT>ESMF_ArrayBundle</TT> class allows a set of Arrays to be bundled into a
single object. The Arrays in an ArrayBundle may be of different type, kind,
rank and distribution. Besides ease of use resulting from bundling, the
ArrayBundle class offers the opportunity for performance optimization when
operating on a bundle of Arrays as a single entity.  Communication methods are 
especially good candidates for performance optimization. Best optimization
results are expected for ArrayBundles that contain Arrays that share a common
distribution, i.e. DistGrid, and are of same type, kind and rank.

<P>
ArrayBundles are one of the data objects that can be added to States,
which are used for providing to or receiving data from other Components.

<P>

<H2><A NAME="SECTION05042000000000000000">
23.2 Use and Examples</A>
</H2>

<P>
Examples of creating, destroying and accessing ArrayBundles and their
constituent Arrays are provided in this section, along with some
notes on ArrayBundle methods.

<P>

<P>

<P>

<H3><A NAME="SECTION05042100000000000000">
23.2.1 Create an ArrayBundle from a list of Arrays</A>
</H3>

<P>
First create a Fortran array of two <TT>ESMF_Array</TT> objects. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
<PRE>
  allocate(arrayList(2))
  arrayList(1) = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
                 rc=rc)
</PRE>

<P>
<PRE>
  arrayList(2) = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
                 rc=rc)
</PRE>

<P>
Now the <TT>arrayList</TT> of Arrays can be used to create an ArrayBundle object. 

<P>
<PRE>
  arraybundle = ESMF_ArrayBundleCreate(arrayList=arrayList, &amp;
    name="MyArrayBundle", rc=rc)
</PRE>

<P>
The temporary <TT>arrayList</TT> can be deallocated now. This will not affect
   the ESMF Array objects. The Array objects must not be deallocated while 
   the ArrayBundle refers to them! 

<P>
<PRE>
  deallocate(arrayList)
</PRE>

<P>
The ArrayBundle object can be printed. 

<P>
<PRE>
  call ESMF_ArrayBundlePrint(arraybundle, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05042200000000000000">
23.2.2 Access Arrays inside the ArrayBundle</A>
</H3>

<P>
Use <TT>ESMF_ArrayBundleGet()</TT> to determine how many Arrays are stored
   in an ArrayBundle. 

<P>
<PRE>
  call ESMF_ArrayBundleGet(arraybundle, arrayCount=arrayCount, rc=rc)
</PRE>

<P>
The <TT>arrayCount</TT> can be used to correctly allocate the <TT>arrayList</TT>
   variable for a second call to <TT>ESMF_ArrayBundleGet()</TT> to gain access
   to the bundled Array objects.

<P>
<PRE>
  allocate(arrayList(arrayCount))
  call ESMF_ArrayBundleGet(arraybundle, arrayList=arraylist, rc=rc)
</PRE>

<P>
The <TT>arrayList</TT> variable can be used to access the individual Arrays,
   e.g. to print them. 

<P>
<PRE>
  do i=1, arrayCount
    call ESMF_ArrayPrint(arrayList(i), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  enddo
</PRE>

<P>

<H3><A NAME="SECTION05042300000000000000">
23.2.3 Destroy an ArrayBundle and its constituents</A>
</H3>

<P>
The ArrayBundle object can be destroyed. 

<P>
<PRE>
  call ESMF_ArrayBundleDestroy(arraybundle, rc=rc)
</PRE>

<P>
After the ArrayBundle object has been destroyed it is safe to destroy its
   constituents. 

<P>
<PRE>
  call ESMF_ArrayDestroy(arrayList(1), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(arrayList(2), rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arrayList)
  
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05042400000000000000">
23.2.4 Halo communication</A>
</H3>

<P>
One of the most fundamental communication pattern in domain decomposition
   codes is the <EM>halo</EM> operation. The ESMF Array class supports halos
   by allowing memory for extra elements to be allocated on each DE. See
   section <A HREF="node5.html#Array:Halo">24.2.14</A> for a discussion of the Array level halo operation.
   The ArrayBundle level extents the Array halo operation to bundles of Arrays.

<P>
First create an <TT>ESMF_ArrayBundle</TT> object containing a set of ESMF
   Arrays. 

<P>
<PRE>
  arraybundle = ESMF_ArrayBundleCreate(arrayList=arrayList, &amp;
    name="MyArrayBundle", rc=rc)
</PRE>

<P>
The ArrayBundle object can be treated as a single entity. The
   <TT>ESMF_ArrayBundleHaloStore()</TT> call determines the most efficient
   halo exchange pattern for <EM>all</EM> Arrays that are part of
   <TT>arraybundle</TT>. 

<P>
<PRE>
  call ESMF_ArrayBundleHaloStore(arraybundle=arraybundle, &amp;
    routehandle=haloHandle, rc=rc)
</PRE>

<P>
The halo exchange pattern stored in <TT>haloHandle</TT> can now be applied to
   the <TT>arraybundle</TT> object, or any other ArrayBundle that is weakly
   congruent to the one used during the <TT>ESMF_ArrayBundleHaloStore()</TT> call. 

<P>
<PRE>
  call ESMF_ArrayBundleHalo(arraybundle=arraybundle, routehandle=haloHandle, &amp;
    rc=rc)
</PRE>

<P>
Finally, when no longer needed, the resources held by <TT>haloHandle</TT> need
   to be returned to the system by calling <TT>ESMF_ArrayBundleHaloRelease()</TT>. 

<P>
<PRE>
  call ESMF_ArrayBundleHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
Finally the ArrayBundle object can be destroyed. 

<P>
<PRE>
  call ESMF_ArrayBundleDestroy(arraybundle, rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION05043000000000000000">
23.3 Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>Adding Arrays</B> to an existing ArrayBundle is currently not supported. In the future this functionality will be provided via the
<TT>ESMF_ArrayBundleAdd()</TT> method.

<P>
</LI>
<LI><B>Removing Arrays</B> from an existing ArrayBundle is currently not supported. In the future this functionality will be provided via the
<TT>ESMF_ArrayBundleRemove()</TT> method.

<P>
</LI>
<LI><B>Non-blocking</B> ArrayBundle communications option is not yet implemented. In the future this functionality will be provided via the
<TT>routesyncflag</TT> option.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION05044000000000000000">
23.4 Design and Implementation Notes</A>
</H2>

<P>
The following is a list of implementation specific details about the current ESMF ArrayBundle.

<P>

<UL>
<LI>Implementation language is C++.
</LI>
<LI>All precomputed communication methods are based on sparse matrix
multiplication.
</LI>
</UL>

<P>

<H2><A NAME="SECTION05045000000000000000">
23.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05045100000000000000">
23.5.1 ESMF_ArrayBundleAssignment(=) - ArrayBundle assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     arraybundle1 = arraybundle2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle) :: arraybundle1
     type(ESMF_ArrayBundle) :: arraybundle2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign arraybundle1 as an alias to the same ESMF ArrayBundle object in memory
     as arraybundle2. If arraybundle2 is invalid, then arraybundle1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle1</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>arraybundle2</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045200000000000000">
23.5.2 ESMF_ArrayBundleOperator(==) - ArrayBundle equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (arraybundle1 == arraybundle2) then ... endif
               OR
     result = (arraybundle1 == arraybundle2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in) :: arraybundle1
     type(ESMF_ArrayBundle), intent(in) :: arraybundle2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether arraybundle1 and arraybundle2 are valid aliases to the same ESMF
     ArrayBundle object in memory. For a more general comparison of two ESMF ArrayBundles,
     going beyond the simple alias test, the ESMF_ArrayBundleMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle1</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>arraybundle2</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045300000000000000">
23.5.3 ESMF_ArrayBundleOperator(/=) - ArrayBundle not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (arraybundle1 /= arraybundle2) then ... endif
               OR
     result = (arraybundle1 /= arraybundle2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in) :: arraybundle1
     type(ESMF_ArrayBundle), intent(in) :: arraybundle2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether arraybundle1 and arraybundle2 are <I>not</I> valid aliases to the
     same ESMF ArrayBundle object in memory. For a more general comparison of two ESMF
     ArrayBundles, going beyond the simple alias test, the ESMF_ArrayBundleMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle1</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>arraybundle2</STRONG></DT>
<DD>The <TT>ESMF_ArrayBundle</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045400000000000000">
23.5.4 ESMF_ArrayBundleAdd - Add Arrays to an ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleAdd(arraybundle, arrayList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
     type(ESMF_Array),       intent(in)            :: arrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Add Array(s) to an ArrayBundle. It is an error if <TT>arrayList</TT> contains
     Arrays that match by name Arrays already contained in <TT>arraybundle</TT>.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be added to.
     
</DD>
<DT><STRONG>arrayList</STRONG></DT>
<DD>List of <TT>ESMF_Array</TT> objects to be added.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be added to <TT>arraybundle</TT>. For <TT>.false.</TT> added items must
       have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add"
       under <TT>multiflag=.false.</TT> mode, where it is <EM>not</EM> an error if 
       <TT>arrayList</TT> contains items with names that are also found in 
       <TT>arraybundle</TT>. The <TT>arraybundle</TT> is left unchanged for these items.
       For <TT>.false.</TT> this is treated as an error condition. 
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045500000000000000">
23.5.5 ESMF_ArrayBundleAddReplace - Conditionally add or replace Arrays in an ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleAddReplace(arraybundle, arrayList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
     type(ESMF_Array),       intent(in)            :: arrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Arrays in <TT>arrayList</TT> that do not match any Arrays by name in 
     <TT>arraybundle</TT> are added to the ArrayBundle. Arrays in <TT>arraybundle</TT>
     that match by name Arrays in <TT>arrayList</TT> are replaced by those Arrays.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be manipulated.
     
</DD>
<DT><STRONG>arrayList</STRONG></DT>
<DD>List of <TT>ESMF_Array</TT> objects to be added or used as replacement.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045600000000000000">
23.5.6 ESMF_ArrayBundleCreate - Create an ArrayBundle from a list of Arrays</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_ArrayBundleCreate(arrayList, multiflag, &amp;
     relaxedflag, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Array), intent(in),  optional :: arrayList(:)
     logical,          intent(in),  optional :: multiflag
     logical,          intent(in),  optional :: relaxedflag
     character(len=*), intent(in),  optional :: name
     integer,          intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_ArrayBundle) :: ESMF_ArrayBundleCreate
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_ArrayBundle</TT> object from a list of existing Arrays.

<P>
The creation of an ArrayBundle leaves the bundled Arrays unchanged, they
     remain valid individual objects. An ArrayBundle is a light weight container
     of Array references. The actual data remains in place, there are no
     data movements or duplications associated with the creation of an 
     ArrayBundle.

<P>
<DL>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>List of <TT>ESMF_Array</TT> objects to be bundled.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be added to <TT>arraybundle</TT>. For <TT>.false.</TT> added items must
       have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "add"
       under <TT>multiflag=.false.</TT> mode, where it is <EM>not</EM> an error if 
       <TT>arrayList</TT> contains items with names that are also found in 
       <TT>arraybundle</TT>. The <TT>arraybundle</TT> is left unchanged for these items.
       For <TT>.false.</TT> this is treated as an error condition. 
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the created <TT>ESMF_ArrayBundle</TT>. A default name is generated
       if not specified.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045700000000000000">
23.5.7 ESMF_ArrayBundleDestroy - Release resources associated with an ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleDestroy(arraybundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)           :: arraybundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_ArrayBundle</TT> object. The member Arrays are not
   touched by this operation and remain valid objects that need to be 
   destroyed individually if necessary.

<P>
The arguments are:
   <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045800000000000000">
23.5.8 ESMF_ArrayBundleGet - Get information about an Array by name</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ArrayBundleGet()   
     subroutine ESMF_ArrayBundleGetItem(arraybundle, arrayName, &amp;
       array, arrayCount, isPresent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: arraybundle
     character(len=*),       intent(in)            :: arrayName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Array),       intent(out), optional :: array
     integer,                intent(out), optional :: arrayCount
     logical,                intent(out), optional :: isPresent
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get information about items that match <TT>arrayName</TT> in ArrayBundle.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be queried.
     
</DD>
<DT><STRONG>arrayName</STRONG></DT>
<DD>Specified name.
     
</DD>
<DT><STRONG>[array]</STRONG></DT>
<DD>Upon return holds the requested Array item. It is an error if this
       argument was specified and there is not exactly one Array item in 
       <TT>arraybundle</TT> that matches <TT>arrayName</TT>.
     
</DD>
<DT><STRONG>[arrayCount]</STRONG></DT>
<DD>Number of Arrays with <TT>arrayName</TT> in <TT>arraybundle</TT>.
     
</DD>
<DT><STRONG>[isPresent]</STRONG></DT>
<DD>Upon return indicates whether Array(s) with <TT>arrayName</TT> exist
       in <TT>arraybundle</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05045900000000000000">
23.5.9 ESMF_ArrayBundleGet - Get a list of Arrays by name</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ArrayBundleGet()   
     subroutine ESMF_ArrayBundleGetList(arraybundle, arrayName, arrayList, &amp;
       rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: arraybundle
     character(len=*),       intent(in)            :: arrayName
     type(ESMF_Array),       intent(out)           :: arrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get the list of Arrays from ArrayBundle that match <TT>arrayName</TT>.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be queried.
     
</DD>
<DT><STRONG>arrayName</STRONG></DT>
<DD>Specified name.
     
</DD>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>List of Arrays in <TT>arraybundle</TT> that match <TT>arrayName</TT>. The
       argument must be allocated to be at least of size <TT>arrayCount</TT>
       returned for this <TT>arrayName</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451000000000000000">
23.5.10 ESMF_ArrayBundleGet - Get general (not Array name specific) information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     ! Private name; call using ESMF_ArrayBundleGet()   
     subroutine ESMF_ArrayBundleGetListAll(arraybundle, arrayCount, &amp;
       arrayList, arrayNameList, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: arraybundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: arrayCount
     type(ESMF_Array),       intent(out), optional :: arrayList(:)
     character(len=*),       intent(out), optional :: arrayNameList(:)
     character(len=*),       intent(out), optional :: name
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get general, i.e. not Array name specific information from the ArrayBundle.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> to be queried.
     
</DD>
<DT><STRONG>[arrayCount]</STRONG></DT>
<DD>Upon return holds the number of Arrays bundled in the ArrayBundle.
     
</DD>
<DT><STRONG>[arrayList]</STRONG></DT>
<DD>Upon return holds a list of Arrays bundled in <TT>arraybundle</TT>. The
           argument must be allocated to be at least of size <TT>arrayCount</TT>.
     
</DD>
<DT><STRONG>[arrayNameList]</STRONG></DT>
<DD>Upon return holds a list of the names of the Array bundled in 
           <TT>arraybundle</TT>. The argument must be allocated to be at least of
           size <TT>arrayCount</TT>.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the ArrayBundle object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451100000000000000">
23.5.11 ESMF_ArrayBundleHalo - Execute an ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleHalo(arraybundle, routehandle, &amp;
     checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)          :: arraybundle
     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional :: checkflag
     integer,                intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle halo operation for the Arrays in
     <TT>arrayBundle</TT>.

<P>
See <TT>ESMF_ArrayBundleHaloStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451200000000000000">
23.5.12 ESMF_ArrayBundleHaloRelease - Release resources associated with an ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleHaloRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an ArrayBundle halo operation.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451300000000000000">
23.5.13 ESMF_ArrayBundleHaloStore - Precompute an ArrayBundle halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleHaloStore(arraybundle, routehandle, &amp;
       startregion, haloLDepth, haloUDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),     intent(inout)         :: arraybundle
     type(ESMF_RouteHandle),     intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_StartRegion_Flag),intent(in),  optional :: startregion
     integer,                    intent(in),  optional :: haloLDepth(:)
     integer,                    intent(in),  optional :: haloUDepth(:)
     integer,                    intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle halo operation over the data in <TT>arraybundle</TT>. By 
     default, i.e. without specifying <TT>startregion</TT>, <TT>haloLDepth</TT>
     and <TT>haloUDepth</TT>, all elements in the total Array regions that lie
     outside the exclusive regions will be considered potential destination
     elements for halo. However, only those elements that have a corresponding
     halo source element, i.e. an exclusive element on one of the DEs, will be
     updated under the halo operation. Elements that have no associated source
     remain unchanged under halo.

<P>
Specifying <TT>startregion</TT> allows to change the shape of the 
     effective halo region from the inside. Setting this flag to
     <TT>ESMF_STARTREGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region for each Array are considered for potential
     destination elements for halo. The default is
     <TT>ESMF_STARTREGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>startregion</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total region for each Array, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Array regions are
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleHalo()</TT> on any ArrayBundle that is weakly congruent
     and typekind conform to <TT>arraybundle</TT>. Congruency for ArrayBundles is
     given by the congruency of its constituents.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> containing data to be haloed. The data in the halo
       regions may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[startregion]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elments.
       See section <A HREF="node2.html#const:startregion">9.41</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>startregion</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>startregion</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451400000000000000">
23.5.14 ESMF_ArrayBundlePrint - Print ArrayBundle internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundlePrint(arraybundle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: arraybundle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMF_ArrayBundle</TT>
     object to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451500000000000000">
23.5.15 ESMF_ArrayBundleRead - Read Arrays to an ArrayBundle from file(s)</A>
</H3>

<P>
<A NAME="api:ArrayBundleRead"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleRead(arraybundle, file, &amp;
     singleFile, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)          :: arraybundle
     character(*),           intent(in)             :: file
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional  :: singleFile
     type(ESMF_IOFmtFlag),   intent(in),  optional  :: iofmt
     integer,                intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Read Array data to an ArrayBundle object from file(s).
     For this API to be functional, the environment variable <TT>ESMF_PIO</TT> 
     should be set to "internal" when the ESMF library is built.
     Please see the section on Data I/O,&nbsp;<A HREF="node5.html#io:dataio">32.3</A>.

<P>
Limitations:
     
<UL>
<LI>Only 1 DE per PET supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD>An <TT>ESMF_ArrayBundle</TT> object.
     
</DD>
<DT><STRONG>file</STRONG></DT>
<DD>The name of the file from which ArrayBundle data is read.
     
</DD>
<DT><STRONG>[singleFile]</STRONG></DT>
<DD>A logical flag, the default is .true., i.e., all Arrays in the bundle 
       are stored in one single file. If .false., each Array is stored 
       in separate files; these files are numbered with the name based on the
       argument "file". That is, a set of files are named: [file_name]001,
       [file_name]002, [file_name]003,...
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format. Please see Section&nbsp;<A HREF="node2.html#opt:iofmtflag">9.25</A> for the list
       of options.  If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451600000000000000">
23.5.16 ESMF_ArrayBundleRedist - Execute an ArrayBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleRedist(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in),    optional :: srcArrayBundle
     type(ESMF_ArrayBundle), intent(inout), optional :: dstArrayBundle
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),    optional :: checkflag
     integer,                intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle redistribution from the Arrays in
     <TT>srcArrayBundle</TT> to the Arrays in <TT>dstArrayBundle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451700000000000000">
23.5.17 ESMF_ArrayBundleRedistRelease - Release resources associated with ArrayBundle redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleRedistRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an ArrayBundle redistribution.
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451800000000000000">
23.5.18 ESMF_ArrayBundleRedistStore - Precompute an ArrayBundle redistribution with local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleRedistStore()
   subroutine ESMF_ArrayBundleRedistStore&lt;type&gt;&lt;kind&gt;(srcArrayBundle, &amp;
     dstArrayBundle, routehandle, factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),   intent(in)            :: srcArrayBundle
     type(ESMF_ArrayBundle),   intent(inout)         :: dstArrayBundle
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factor
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(in),  optional :: srcToDstTransposeMap(:)
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle redistribution operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The redistribution
     between ArrayBundles is defined as the sequence of
     individual Array redistributions over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify a <TT>factor</TT> argument must use the
     &lt;type&gt;&lt;kind&gt; overloaded interface. Other PETs call into the interface
     without <TT>factor</TT> argument. If multiple PETs specify the <TT>factor</TT>
     argument its type and kind as well as its value must match across all
     PETs. If none of the PETs specifies a <TT>factor</TT> argument the default
     will be a factor of 1.

<P>
See the description of method <TT>ESMF_ArrayRedistStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleRedist()</TT> on any pair of ArrayBundles that 
     are weakly congruent and typekind conform with the Arrays contained in
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT>. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data. The data in these Arrays
       may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multipy source data.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in the Arrays in
       <TT>srcArrayBundle</TT>. Each
       entry maps the corresponding source Array dimension against the 
       specified destination Array dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050451900000000000000">
23.5.19 ESMF_ArrayBundleRedistStore - Precompute an ArrayBundle redistribution without local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleRedistStore()
   subroutine ESMF_ArrayBundleRedistStoreNF(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)            :: srcArrayBundle
     type(ESMF_ArrayBundle), intent(inout)         :: dstArrayBundle
     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: srcToDstTransposeMap(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle redistribution operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The redistribution
     between ArrayBundles is defined as the sequence of
     individual Array redistributions over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify a <TT>factor</TT> argument must use the
     &lt;type&gt;&lt;kind&gt; overloaded interface. Other PETs call into the interface
     without <TT>factor</TT> argument. If multiple PETs specify the <TT>factor</TT>
     argument its type and kind as well as its value must match across all
     PETs. If none of the PETs specifies a <TT>factor</TT> argument the default
     will be a factor of 1.

<P>
See the description of method <TT>ESMF_ArrayRedistStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleRedist()</TT> on any pair of ArrayBundles that 
     are weakly congruent and typekind conform with the Arrays contained in
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT>. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data. The data in these Arrays
       may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in the Arrays in
       <TT>srcArrayBundle</TT>. Each
       entry maps the corresponding source Array dimension against the 
       specified destination Array dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452000000000000000">
23.5.20 ESMF_ArrayBundleRemove - Remove Arrays from ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleRemove(arraybundle, arrayNameList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
     character(len=*),       intent(in)            :: arrayNameList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Remove Array(s) by name from ArrayBundle. In the relaxed setting it is 
     <EM>not</EM> an error if <TT>arrayNameList</TT> contains names that are not 
     found in <TT>arraybundle</TT>.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> from which to remove items.
     
</DD>
<DT><STRONG>arrayNameList</STRONG></DT>
<DD>List of items to remove.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple Arrays with the same name
       to be removed from <TT>arraybundle</TT>. For <TT>.false.</TT>, items to be
       removed must have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "remove"
       where it is <EM>not</EM> an error if <TT>arrayNameList</TT> contains item
       names that are not found in <TT>arraybundle</TT>. For <TT>.false.</TT> this is 
       treated as an error condition. 
       Further, in <TT>multiflag=.false.</TT> mode, the relaxed definition of
       "remove" also covers the case where there are multiple items in
       <TT>arraybundle</TT> that match a single entry in <TT>arrayNameList</TT>.
       For <TT>relaxedflag=.false.</TT> this is treated as an error condition.
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452100000000000000">
23.5.21 ESMF_ArrayBundleReplace - Replace Arrays in ArrayBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayBundleReplace(arraybundle, arrayList, &amp;
       multiflag, relaxedflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(inout)         :: arraybundle
     type(ESMF_Array),       intent(in)            :: arrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),  optional :: multiflag
     logical,                intent(in),  optional :: relaxedflag
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Replace Array(s) by name in ArrayBundle. In the relaxed setting it is not
     an error if <TT>arrayList</TT> contains Arrays that do not match by name any
     item in <TT>arraybundle</TT>. These Arrays are simply ignored in this case.

<P>
<DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> in which to replace items.
     
</DD>
<DT><STRONG>arrayList</STRONG></DT>
<DD>List of items to replace.
     
</DD>
<DT><STRONG>[multiflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> allows multiple items with the same name
       to be replaced in <TT>arraybundle</TT>. For <TT>.false.</TT>, items to be
       replaced must have unique names. The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[relaxedflag]</STRONG></DT>
<DD>A setting of <TT>.true.</TT> indicates a relaxed definition of "replace"
       where it is <EM>not</EM> an error if <TT>arrayList</TT> contains items with
       names that are not found in <TT>arraybundle</TT>. These items in 
       <TT>arrayList</TT> are ignored in the relaxed mode. For <TT>.false.</TT> this
       is treated as an error condition.
       Further, in <TT>multiflag=.false.</TT> mode, the relaxed definition of
       "replace" also covers the case where there are multiple items in
       <TT>arraybundle</TT> that match a single entry by name in <TT>arrayList</TT>.
       For <TT>relaxedflag=.false.</TT> this is treated as an error condition.
       The default setting is <TT>.false.</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452200000000000000">
23.5.22 ESMF_ArrayBundleSMM - Execute an ArrayBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleSMM(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, zeroregion, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in),    optional :: srcArrayBundle
     type(ESMF_ArrayBundle), intent(inout), optional :: dstArrayBundle
     type(ESMF_RouteHandle), intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Region_Flag), intent(in),    optional :: zeroregion
     logical,                intent(in),    optional :: checkflag
     integer,                intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed ArrayBundle sparse matrix multiplication from the
     Arrays in <TT>srcArrayBundle</TT> to the Arrays in <TT>dstArrayBundle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>[dstArrayBundle]</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of 
       all DEs in all Arrays in <TT>dstArrayBundle</TT> will be initialized to zero 
       before updating the elements with the results of the sparse matrix 
       multiplication. If set to <TT>ESMF_REGION_EMPTY</TT> the elements in the
       Arrays in <TT>dstArrayBundle</TT> will not be modified prior to the sparse
       matrix multiplication and results will be added to the incoming element
       values. Setting <TT>zeroregion</TT> to <TT>ESMF_REGION_SELECT</TT> will only
       zero out those elements in the destination Arrays that will be updated
       by the sparse matrix multiplication. See section <A HREF="node2.html#const:region">9.36</A>
       for a complete list of valid settings.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pairs will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452300000000000000">
23.5.23 ESMF_ArrayBundleSMMRelease - Release resources associated with ArrayBundle sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleSMMRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an ArrayBundle sparse matrix multiplication. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452400000000000000">
23.5.24 ESMF_ArrayBundleSMMStore - Precompute an ArrayBundle sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleSMMStore()
   subroutine ESMF_ArrayBundleSMMStore&lt;type&gt;&lt;kind&gt;(srcArrayBundle, &amp;
     dstArrayBundle, routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),           intent(in)    :: srcArrayBundle
     type(ESMF_ArrayBundle),           intent(inout) :: dstArrayBundle
     type(ESMF_RouteHandle),           intent(inout) :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)    :: factorList(:)
     integer,                          intent(in)    :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle sparse matrix multiplication operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The sparse matrix
     multiplication between ArrayBundles is defined as the sequence of
     individual Array sparse matrix multiplications over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
See the description of method <TT>ESMF_ArraySMMStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleSMM()</TT> on any pair of ArrayBundles that 
     are weakly congruent and typekind conform with the Arrays contained in
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT>. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data. The data in these Arrays
       may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
     
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the source Array while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in the destination Array. For this format to be a
       valid option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identiy matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the source Array. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the destination Array.

<P>
See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of 
       Array <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452500000000000000">
23.5.25 ESMF_ArrayBundleSMMStore - Precompute an ArrayBundle sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayBundleSMMStore()
   subroutine ESMF_ArrayBundleSMMStoreNF(srcArrayBundle, dstArrayBundle, &amp;
     routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle),     intent(in)             :: srcArrayBundle
     type(ESMF_ArrayBundle),     intent(inout)          :: dstArrayBundle
     type(ESMF_RouteHandle),     intent(inout)          :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                    intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store an ArrayBundle sparse matrix multiplication operation from
     <TT>srcArrayBundle</TT> to <TT>dstArrayBundle</TT>. The sparse matrix
     multiplication between ArrayBundles is defined as the sequence of
     individual Array sparse matrix multiplications over all source and
     destination Array pairs in sequence. The method requires that
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT> reference an identical
     number of <TT>ESMF_Array</TT> objects.

<P>
The effect of this method on ArrayBundles that contain aliased members is
     undefined.

<P>
PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
See the description of method <TT>ESMF_ArraySMMStore()</TT> for
     the definition of the Array based operation.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayBundleSMM()</TT> on any pair of ArrayBundles that 
     are weakly congruent and typekind conform with the Arrays contained in
     <TT>srcArrayBundle</TT> and <TT>dstArrayBundle</TT>. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with source data.
     
</DD>
<DT><STRONG>dstArrayBundle</STRONG></DT>
<DD><TT>ESMF_ArrayBundle</TT> with destination data. The data in these Arrays
       may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050452600000000000000">
23.5.26 ESMF_ArrayBundleWrite - Write the Arrays into a file</A>
</H3>

<P>
<A NAME="api:ArrayBundleWrite"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayBundleWrite(arraybundle, file, &amp;
     singleFile, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArrayBundle), intent(in)              :: arraybundle
     character(*),           intent(in)              :: file
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     logical,                intent(in),   optional  :: singleFile
     integer,                intent(in),   optional  :: timeslice
     type(ESMF_IOFmtFlag),   intent(in),   optional  :: iofmt
     integer,                intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write the Arrays into a file. For this API to be functional,
     the environment variable <TT>ESMF_PIO</TT> should be set to "internal"
     when the ESMF library is built. Please see the section on 
     Data I/O,&nbsp;<A HREF="node5.html#io:dataio">32.3</A>.

<P>
Limitations:
     
<UL>
<LI>Only 1 DE per PET supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
     <DL>
<DT><STRONG>arraybundle</STRONG></DT>
<DD>An <TT>ESMF_ArrayBundle</TT> object.
     
</DD>
<DT><STRONG>file</STRONG></DT>
<DD>The name of the output file to which array bundle data is written.
     
</DD>
<DT><STRONG>[singleFile]</STRONG></DT>
<DD>A logical flag, the default is .true., i.e., all arrays in the bundle 
       are written in one single file. If .false., each array will be written
       in separate files; these files are numbered with the name based on the
       argument "file". That is, a set of files are named: [file_name]001,
       [file_name]002, [file_name]003,...
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Some IO formats (e.g. NetCDF) support the output of data in form of
       time slices. The <TT>timeslice</TT> argument provides access to this
       capability. Usage of this feature requires that the first slice is
       written with a positive <TT>timeslice</TT> value, and that subsequent slices
       are written with a <TT>timeslice</TT> argument that increments by one each
       time. By default, i.e. by omitting the <TT>timeslice</TT> argument, no
       provisions for time slicing are made in the output file.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format. Please see Section&nbsp;<A HREF="node2.html#opt:iofmtflag">9.25</A> for the list
       of options.  If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05050000000000000000">
24 Array Class</A>
</H1>

<P>

<H2><A NAME="SECTION05051000000000000000">
24.1 Description</A>
</H2>

<P>
The Array class is an alternative to the Field class for representing 
distributed, structured data.  Unlike Fields, which are built to carry 
grid coordinate information, Arrays can only carry information about the 
<I>indices</I> associated with grid cells.  Since they do not have coordinate 
information, Arrays cannot be used to calculate interpolation weights.  
However, if the user can supply interpolation weights, the Array sparse 
matrix multiply operation can be used to apply the weights and transfer 
data to the new grid.  Arrays can also perform redistribution, scatter, 
and gather communication operations.

<P>
Like Fields, Arrays can be added to a State and used in inter-Component 
data communications.  Arrays can also be grouped together into ArrayBundles 
so that collective operations can be performed on the whole group.  One 
motivation for this is convenience; another is the ability to schedule 
optimized, collective data transfers.   

<P>
From a technical standpoint, the ESMF Array class is an index space 
based, distributed data storage class. It provides DE-local memory allocations 
within DE-centric index regions and defines the relationship to the index 
space described by the ESMF DistGrid. The Array class offers common 
communication patterns within the index space formalism. As part of the ESMF 
index space layer, Array has close relationship to the DistGrid and DELayout 
classes.

<P>

<H2><A NAME="SECTION05052000000000000000">
24.2 Use and Examples</A>
</H2>

<P>
An <TT>ESMF_Array</TT> is a distributed object that must exist on all PETs of the current context. Each PET-local instance of an Array object contains memory allocations for all PET-local DEs. There may be 0, 1, or more DEs per PET and the number of DEs per PET can differ between PETs for the same Array object. Memory allocations may be provided for each PET by the user during Array creation or can be allocated as part of the Array create call. Many of the concepts of the proposed <TT>ESMF_Array</TT> class are illustrated by the following examples.

<P>

<P>

<P>

<H3><A NAME="SECTION05052100000000000000">
24.2.1 Array from native Fortran array with 1 DE per PET</A>
</H3>

<P>
The create call of the <TT>ESMF_Array</TT> class has been overloaded
   extensively to facilitate the need for generality while keeping simple
   cases simple. The following program demonstrates one of the simpler
   cases, where existing local Fortran arrays are to be used to provide
   the PET-local memory allocations for the Array object.

<P>
<PRE>
program ESMF_ArrayFarrayEx

  use ESMF
  
  implicit none
</PRE>

<P>
The Fortran language provides a variety of ways to define and allocate
   an array. Actual Fortran array objects must either be explicit-shape or
   deferred-shape. In the first case the memory allocation and deallocation is 
   automatic from the user's perspective and the details of the allocation 
   (static or dynamic, heap or stack) are left to the compiler. (Compiler flags
   may be used to control some of the details). In the second case, i.e. for 
   deferred-shape actual objects, the array definition must include the <TT>pointer</TT> 
   or <TT>allocatable</TT> attribute and it is the user's responsibility to allocate 
   memory. While it is also the user's responsibility to deallocate memory for
   arrays with the <TT>pointer</TT> attribute the compiler will automatically deallocate
   allocatable arrays under certain circumstances defined by the Fortran
   standard.

<P>
The <TT>ESMF_ArrayCreate()</TT> interface has been written to accept native
   Fortran arrays of any flavor as a means to allow user-controlled memory
   management. The Array create call will check on each PET if sufficient 
   memory has been provided by the specified Fortran arrays and will indicate 
   an error if a problem is detected. However, the Array create call cannot
   validate the lifetime of the provided memory allocations. If, for instance,
   an Array object was created in a subroutine from an automatic explicit-shape
   array or an allocatable array, the memory allocations referenced by the Array 
   object will be automatically deallocated on return from the subroutine unless
   provisions are made by the application writer to prevent such behavior. The
   Array object cannot control when memory that has been provided by the user
   during Array creation becomes deallocated, however, the Array will indicate
   an error if its memory references have been invalidated. 

<P>
The easiest, portable way to provide safe native Fortran memory allocations
   to Array create is to use arrays with the <TT>pointer</TT> attribute. Memory allocated
   for an array pointer will not be deallocated automatically. However, in this
   case the possibility of memory leaks becomes an issue of concern. The 
   deallocation of memory provided to an Array in form of a native Fortran
   allocation will remain the users responsibility.

<P>
None of the concerns discussed above are an issue in this example where the
   native Fortran array <TT>farray</TT> is defined in the main program. All
   different types of array memory allocation are demonstrated in this example.
   First <TT>farrayE</TT> is defined as a 2D explicit-shape array on each PET which 
   will automatically provide memory for <IMG
 WIDTH="57" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img41.png"
 ALT="$10\times 10$"> elements. 

<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8)       :: farrayE(10,10)  ! explicit shape Fortran array
</PRE>

<P>
Then an allocatable array <TT>farrayA</TT> is declared which will be used
   to show user-controlled dynamic memory allocation. 

<P>
<PRE>
  real(ESMF_KIND_R8), allocatable :: farrayA(:,:) ! allocatable Fortran array
</PRE>

<P>
Finally an array with pointer attribute <TT>farrayP</TT> is declared, also used
   for user-controlled dynamic memory allocation. 

<P>
<PRE>
  real(ESMF_KIND_R8), pointer :: farrayP(:,:)   ! Fortran array pointer
</PRE>

<P>
A matching array pointer must also be available to gain access to the arrays
   held by an Array object. 

<P>
<PRE>
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:) ! matching Fortran array ptr 
  type(ESMF_DistGrid)         :: distgrid       ! DistGrid object
  type(ESMF_Array)            :: array          ! Array object
  integer                     :: rc
</PRE>

<P>
<PRE>
  call ESMF_Initialize(defaultlogfilename="ArrayFarrayEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
On each PET <TT>farrayE</TT> can be accessed directly to initialize the entire
   PET-local array. 

<P>
<PRE>
  farrayE = 12.45d0 ! initialize to some value
</PRE>

<P>
In order to create an Array object a DistGrid must first be created that 
   describes the total index space and how it is decomposed and distributed.
   In the simplest case only the <TT>minIndex</TT> and <TT>maxIndex</TT> of the 
   total space must be provided. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
This example is assumed to run on 4 PETs. The default 2D decomposition will 
   then be into 4 x 1 DEs as to ensure 1 DE per PET. 

<P>
Now the Array object can be created using the <TT>farrayE</TT> and the DistGrid
   just created. 

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=farrayE, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
The 40 x 10 index space defined by the <TT>minIndex</TT> and <TT>maxIndex</TT> 
   arguments paired with the default decomposition will result in the following
   distributed Array.

<P>
<PRE>
  
         +---------------------------&gt; 2nd dimension
         |   (1,1)-------+
         |     |         |
         |     |   DE 0  |   &lt;--- farray on PET 0
         |     |         |
         |     +------(10,10)
         |  (11,1)-------+
         |     |         |
         |     |   DE 1  |   &lt;--- farray on PET 1
         |     |         |
         |     +------(20,10)
         |  (21,1)-------+
         |     |         |
         |     |   DE 2  |   &lt;--- farray on PET 2
         |     |         |
         |     +------(30,10)
         |  (31,1)-------+
         |     |         |
         |     |   DE 3  |   &lt;--- farray on PET 3
         |     |         |
         |     +------(40,10)
         v
       1st dimension
</PRE>

<P>
Providing <TT>farrayE</TT> during Array creation does not change anything about
   the actual <TT>farrayE</TT> object. This means that each PET can use its
   local <TT>farrayE</TT> directly to access the memory referenced by the Array 
   object. 

<P>
<PRE>
  print *, farrayE
</PRE>

<P>
Another way of accessing the memory associated with an Array object is to 
   use <TT>ArrayGet()</TT> to obtain an Fortran pointer that references the
   PET-local array. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayPtr
</PRE>

<P>
Finally the Array object must be destroyed. The PET-local memory of the
   <TT>farrayE</TT>s will remain in user control and will not be altered by 
   <TT>ArrayDestroy()</TT>. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Since the memory allocation for each <TT>farrayE</TT> is automatic there is
   nothing more to do.

<P>
The interaction between <TT>farrayE</TT> and the Array class is representative
   also for the two other cases <TT>farrayA</TT> and <TT>farrayP</TT>. The only
   difference is in the handling of memory allocations. 

<P>
<PRE>
  allocate(farrayA(10,10))    ! user controlled allocation
  farrayA = 23.67d0           ! initialize to some value
  array = ESMF_ArrayCreate(farray=farrayA, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayA            ! print PET-local farrayA directly
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)! obtain array pointer
  print *, farrayPtr          ! print PET-local piece of Array through pointer
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the Array
  deallocate(farrayA)         ! user controlled de-allocation
</PRE>

<P>
The <TT>farrayP</TT> case is identical. 

<P>
<PRE>
  allocate(farrayP(10,10))    ! user controlled allocation
  farrayP = 56.81d0           ! initialize to some value
  array = ESMF_ArrayCreate(farray=farrayP, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
<PRE>
  print *, farrayP            ! print PET-local farrayA directly
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)! obtain array pointer
  print *, farrayPtr          ! print PET-local piece of Array through pointer
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the Array
  deallocate(farrayP)         ! user controlled de-allocation
</PRE>

<P>
To wrap things up the DistGrid object is destroyed and ESMF can be finalized. 

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc) ! destroy the DistGrid
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05052200000000000000"></A>
   <A NAME="Array:fpadding"></A>
<BR>
24.2.2 Array from native Fortran array with extra elements for halo or padding
</H3>

<P>
The example of the previous section showed how easy it is to create an Array
   object from existing PET-local Fortran arrays. The example did, however, not
   define any halo elements around the DE-local regions. The following code
   demonstrates how an Array object with space for a halo can be set up. 

<P>
<PRE>
program ESMF_ArrayFarrayHaloEx

  use ESMF
  
  implicit none
</PRE>

<P>
The allocatable array <TT>farrayA</TT> will be used to provide the PET-local
   Fortran array for this example. 

<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8), allocatable :: farrayA(:,:) ! allocatable Fortran array
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:)   ! matching Fortran array ptr
  type(ESMF_DistGrid)         :: distgrid         ! DistGrid object
  type(ESMF_Array)            :: array            ! Array object
  integer                     :: rc, i, j
  real                        :: localSum
</PRE>

<P>
<PRE>
  call ESMF_Initialize(defaultlogfilename="ArrayFarrayHaloEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
The Array is to cover the exact same index space as in the previous
   example. Furthermore decomposition and distribution are also kept the same.
   Hence the same DistGrid object will be created and it is expected to 
   execute this example with 4 PETs.

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
This DistGrid describes a 40 x 10 index space that will be decomposed into 
   4 DEs when executed on 4 PETs, associating 1 DE per PET. Each DE-local 
   exclusive region contains 10 x 10 elements. The DistGrid also stores and provides
   information about the relationship between DEs in index space, however,
   DistGrid does not contain information about halos. Arrays contain halo 
   information and it is possible to create multiple Arrays covering the same
   index space with identical decomposition and distribution using the same
   DistGrid object, while defining different, Array-specific halo regions.

<P>
The extra memory required to cover the halo in the Array object must be 
   taken into account when allocating the PET-local <TT>farrayA</TT> arrays. For
   a halo of 2 elements in each direction the following allocation will suffice. 

<P>
<PRE>
  allocate(farrayA(14,14))    ! Fortran array with halo: 14 = 10 + 2 * 2
</PRE>

<P>
The <TT>farrayA</TT> can now be used to create an Array object with enough space
   for a two element halo in each direction. The Array creation method checks for 
   each PET that the local Fortran array can accommodate the requested regions.

<P>
The default behavior of ArrayCreate() is to center the exclusive region within
   the total region. Consequently the following call will provide the 2 extra 
   elements on each side of the exclusive 10 x 10 region without having to specify
   any additional arguments. 

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=farrayA, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
The exclusive Array region on each PET can be accessed through a suitable
   Fortran array pointer. See section <A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A>
   for more details on Array regions. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
Following Array bounds convention, which by default puts the beginning of 
   the exclusive region at (1, 1, ...), the following loop will add up the 
   values of the local exclusive region for each DE, regardless of how the bounds
   were chosen for the original PET-local <TT>farrayA</TT> arrays. 

<P>
<PRE>
  localSum = 0.
  do j=1, 10
    do i=1, 10
      localSum = localSum + farrayPtr(i, j)
    enddo
  enddo
</PRE>

<P>
Elements with <IMG
 WIDTH="12" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img42.png"
 ALT="$i$"> or <IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img43.png"
 ALT="$j$"> in the [-1,0] or [11,12] ranges are located outside the
   exclusive region and may be used to define extra computational points or 
   halo operations.

<P>
Cleanup and shut down ESMF. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
  deallocate(farrayA)
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05052300000000000000"></A>
   <A NAME="Array:LocalArray"></A>
<BR>
24.2.3 Array from <TT>ESMF_LocalArray</TT>
</H3>

<P>
Alternative to the direct usage of Fortran arrays during Array creation
   it is also possible to first create an <TT>ESMF_LocalArray</TT> and create the
   Array from it. While this may seem more burdensome for the 1 DE per PET cases
   discussed in the previous sections it allows a straight forward 
   generalization to the multiple DE per PET case. The following example first
   recaptures the previous example using an <TT>ESMF_LocalArray</TT> and then
   expands to the multiple DE per PET case.

<P>
<PRE>
program ESMF_ArrayLarrayEx

  use ESMF
  
  implicit none
</PRE>

<P>
The current <TT>ESMF_LocalArray</TT> interface requires Fortran arrays to be 
   defined with pointer attribute. 

<P>
<PRE>
  ! local variables
  real(ESMF_KIND_R8), pointer :: farrayP(:,:)   ! Fortran array pointer
  real(ESMF_KIND_R8), pointer :: farrayPtr(:,:) ! matching Fortran array ptr 
  type(ESMF_LocalArray)       :: larray         ! ESMF_LocalArray object
  type(ESMF_LocalArray)       :: larrayRef      ! ESMF_LocalArray object
  type(ESMF_DistGrid)         :: distgrid       ! DistGrid object
  type(ESMF_Array)            :: array          ! Array object
  integer                     :: rc, i, j, de
  real                        :: localSum
  type(ESMF_LocalArray), allocatable :: larrayList(:) ! LocalArray object list
  type(ESMF_LocalArray), allocatable :: larrayRefList(:)!LocalArray obj. list
  
  type(ESMF_VM):: vm
  integer:: localPet, petCount
</PRE>

<P>
<PRE>
  call ESMF_Initialize(vm=vm, defaultlogfilename="ArrayLarrayEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
  if (petCount /= 4) then
    finalrc = ESMF_FAILURE
    goto 10
  endif
</PRE>

<P>
DistGrid and array allocation remains unchanged.

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
<PRE>
  allocate(farrayP(14,14))    ! allocate Fortran array on each PET with halo
</PRE>

<P>
Now instead of directly creating an Array object using the PET-local 
   <TT>farrayP</TT>s an <TT>ESMF_LocalArray</TT> object will be created on each PET. 

<P>
<PRE>
  larray = ESMF_LocalArrayCreate(farrayP, &amp;
               datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
</PRE>

<P>
The Array object can now be created from <TT>larray</TT>. The Array 
   creation method checks for each PET that the LocalArray can 
   accommodate the requested regions. 

<P>
<PRE>
  array = ESMF_ArrayCreate(localarrayList=(/larray/), distgrid=distgrid, rc=rc)
</PRE>

<P>
Once created there is no difference in how the Array object can be used.
   The exclusive Array region on each PET can be accessed through a suitable
   Fortran array pointer as before. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
Alternatively it is also possible (independent of how the Array object was
   created) to obtain the reference to the array allocation held by Array in 
   form of an <TT>ESMF_LocalArray</TT> object. The <TT>farrayPtr</TT> can then be
   extracted using LocalArray methods. 

<P>
<PRE>
  call ESMF_ArrayGet(array, localarray=larrayRef, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_LocalArrayGet(larrayRef, farrayPtr, rc=rc)
</PRE>

<P>
Either way the <TT>farrayPtr</TT> reference can be used now to add up the values
   of the local exclusive region for each DE. The following loop 
   works regardless of how the bounds were chosen for the original PET-local 
   <TT>farrayP</TT> arrays and consequently the PET-local <TT>larray</TT> objects. 

<P>
<PRE>
  localSum = 0.
  do j=1, 10
    do i=1, 10
      localSum = localSum + farrayPtr(i, j)
    enddo
  enddo
  print *, "localSum=", localSum
</PRE>

<P>
Cleanup. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
  call ESMF_LocalArrayDestroy(larray, rc=rc)
  deallocate(farrayP)   ! use the pointer that was used in allocate statement
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
While the usage of LocalArrays is unnecessarily cumbersome for 1 DE per PET
   Arrays, it provides a straight forward path for extending the interfaces 
   to multiple DEs per PET. 

<P>
In the following example a 8 x 8 index space will be decomposed into
   2 x 4 = 8 DEs. The situation is captured by the following DistGrid object. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/8,8/), &amp;
    regDecomp=(/2,4/), rc=rc)
</PRE>

<P>
The <TT>distgrid</TT> object created in this manner will contain 8 DEs no 
   matter how many PETs are available during execution. Assuming an execution
   on 4 PETs will result in the following distribution of the decomposition.

<P>
<PRE>
   
    +---------------------------------------&gt; 2nd dimension
    |  (1,1)
    |    +-----------+-----------+-----------+-----------+
    |    | DE0, PET0 | DE2, PET1 | DE4, PET2 | DE6, PET3 |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    +-----------+-----------+-----------+-----------+
    |    | DE1, PET0 | DE3, PET1 | DE5, PET2 | DE7, PET3 |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    |           |           |           |           |
    |    |  *    *   |  *    *   |  *    *   |  *    *   |
    |    +-----------+-----------+-----------+-----------+
    |                                                    (8,8)
    v 
   1st dimension
</PRE>

<P>
Obviously each PET is associated with 2 DEs. Each PET must allocate enough
   space for <EM>all</EM> its DEs. This is done by allocating 
   as many DE-local arrays as there are DEs on the PET. The reference to these
   array allocations is passed into ArrayCreate via a LocalArray list argument
   that holds as many elements as there are DEs on the PET. Here each PET must
   allocate for two DEs.

<P>
<PRE>
  allocate(larrayList(2))   ! 2 DEs per PET
  allocate(farrayP(4, 2))   ! without halo each DE is of size 4 x 2 
  farrayP = 123.456d0
  larrayList(1) = ESMF_LocalArrayCreate(farrayP, &amp;
    datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc) !1st DE
  allocate(farrayP(4, 2))   ! without halo each DE is of size 4 x 2 
  farrayP = 456.789d0
  larrayList(2) = ESMF_LocalArrayCreate(farrayP, &amp;
    datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc) !2nd DE
</PRE>

<P>
Notice that it is perfectly fine to <EM>re</EM>-use <TT>farrayP</TT> for all
   allocations of DE-local Fortran arrays. The allocated memory can be 
   deallocated at the end using the array pointer contained in the 
   <TT>larrayList</TT>.

<P>
With this information an Array object can be created. The <TT>distgrid</TT>
   object indicates 2 DEs for each PET and ArrayCreate() expects to find two
   LocalArray elements in <TT>larrayList</TT>. 

<P>
<PRE>
  array = ESMF_ArrayCreate(localarrayList=larrayList, distgrid=distgrid, rc=rc)
</PRE>

<P>
Usage of a LocalArray list is the only way to provide a list of variable 
   length of Fortran array allocations to ArrayCreate() for each PET. The 
   <TT>array</TT> object created by the above call is an ESMF distributed 
   object. As such it must follow the ESMF convention that requires that 
   the call to <TT>ESMF_ArrayCreate()</TT> must be issued in unison by all 
   PETs of the current context. Each PET only calls ArrayCreate() once, even if
   there are multiple DEs per PET.

<P>
The ArrayGet() method provides access to the list of LocalArrays on each PET. 

<P>
<PRE>
  allocate(larrayRefList(2))
  call ESMF_ArrayGet(array, localarrayList=larrayRefList, rc=rc)
</PRE>

<P>
Finally, access to the actual Fortran pointers is done on a per DE basis.
   Generally each PET will loop over its DEs. 

<P>
<PRE>
  do de=1, 2
    call ESMF_LocalArrayGet(larrayRefList(de), farrayPtr, rc=rc)
    localSum = 0.
    do j=1, 2
      do i=1, 4
        localSum = localSum + farrayPtr(i, j)
      enddo
    enddo
    print *, "localSum=", localSum
  enddo
</PRE>

<P>
Note: If the VM associates multiple PEs with a PET the application writer 
   may decide to use OpenMP loop parallelization on the <TT>de</TT> loop.

<P>
Cleanup requires that the PET-local deallocations are done before the 
   pointers to the actual Fortran arrays are lost. Notice that <TT>larrayList</TT>
   is used to obtain the pointers used in the deallocate statement. Pointers
   obtained from the <TT>larrayRefList</TT>, while pointing to the same data, 
   <EM>cannot</EM> be used to deallocated the array allocations! 

<P>
<PRE>
  do de=1, 2
    call ESMF_LocalArrayGet(larrayList(de), farrayPtr, rc=rc)
    deallocate(farrayPtr)
    call ESMF_LocalArrayDestroy(larrayList(de), rc=rc)
  enddo
  deallocate(larrayList)
  deallocate(larrayRefList)
  call ESMF_ArrayDestroy(array, rc=rc)
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
With that ESMF can be shut down cleanly. 

<P>
<PRE>
  call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
end program
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05052400000000000000">
24.2.4 Create Array with automatic memory allocation</A>
</H3>

<P>
In the examples of the previous sections the user provided memory allocations
   for each of the DE-local regions for an Array object. The user was able to 
   use any of the Fortran methods to allocate memory, or go through
   the <TT>ESMF_LocalArray</TT> interfaces to obtain memory allocations before
   passing them into ArrayCreate(). Alternatively ESMF offers methods that 
   handle Array memory allocations inside the library.

<P>
As before, to create an <TT>ESMF_Array</TT> object an <TT>ESMF_DistGrid</TT>
   must be created. The DistGrid object holds information about the entire 
   index space and how it is dcomposed into DE-local exclusive regions. The 
   following line of code creates a DistGrid for a 5x5 global index space that 
   is decomposed into 2 x 3 = 6 DEs. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
The following is a representation of the index space and its decompositon into
   DEs. Each asterix (*) represents a single element.

<P>
<PRE>
   
    +---------------------------------------&gt; 2nd dimension
    |  (1,1)
    |    +-----------+-----------+------+
    |    | DE 0      | DE 2      | DE 4 |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    +-----------+-----------+------+
    |    |           |           |      |
    |    | DE 1      | DE 3      | DE 5 |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    |           |           |      |
    |    |  *    *   |  *    *   |  *   |
    |    +-----------+-----------+------+
    |                                 (5,5)
    v 
   1st dimension
</PRE>

<P>
Besides the DistGrid it is the <EM>type, kind</EM> and <EM>rank</EM> information,
   "tkr" for short, that is required to create an Array object. It turns out that
   the rank of the Array object is fully determined by the DistGrid and other 
   (optional) arguments passed into ArrayCreate(), so that explicit 
   specification of the Array rank is redundant.

<P>
The simplest way to supply the type and kind information of the Array is
   directly through the <TT>typekind</TT> argument. Here a double precision Array
   is created on the previously created DistGrid. Since no other arguments are
   specified that could alter the rank of the Array it becomes equal to the 
   dimCount of the DistGrid, i.e a 2D Array is created on top of the DistGrid. 

<P>
<PRE>
  array = ESMF_ArrayCreate(typekind=ESMF_TYPEKIND_R8, distgrid=distgrid, rc=rc)
</PRE>

<P>
The different methods on how an Array object is created have no effect on
   the use of <TT>ESMF_ArrayDestroy()</TT>. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Alternatively the same Array can be created specifying the "tkr" information
   in form of an ArraySpec variable. The ArraySpec explicitly contains the 
   Array rank and thus results in an overspecification on the ArrayCreate()
   interface. ESMF checks all input information for consistency and returns 
   appropriate error codes in case any inconsistencies are found. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
The Array object created by the above call is an ESMF distributed 
   object. As such it must follow the ESMF convention that requires that 
   the call to <TT>ESMF_ArrayCreate()</TT> must be issued in unison by all 
   PETs of the current context.

<P>

<H3><A NAME="SECTION05052500000000000000">
24.2.5 Native language memory access</A>
</H3>

<P>
Access to the data held inside an ESMF Array object is provided through
   native language objects. Specifically, the <TT>farrayPtr</TT> argument returned
   by the <TT>ESMF_ArrayGet()</TT> method is a Fortran array pointer that can be
   used do access the PET-local data inside the Array object.

<P>
Many applications work in the 1 DE per PET mode, i.e. there is only
   a single DE on each PET. The Array class does not assume this special
   case, instead it supports multiple separate memory allocations on each PET.
   The number of such PET-local allocations is given by the <TT>localDeCount</TT>
   of the underlying DistGrid. Access to the DE-local memory allocations in this
   general case requires a loop over <TT>localDeCount</TT>. 

<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
</PRE>

<P>
<PRE>
  do de=0, localDeCount-1
    call ESMF_ArrayGet(array, farrayPtr=myFarray, localDe=de, rc=rc)
</PRE>

<P>
<PRE>
    ! use myFarray to access local DE data
  enddo
</PRE>

<P>
The 1 DE per PET case is so common that the ESMF Array provides simplified
   support for it. In this case the <TT>ESMF_ArrayGet()</TT> can be called 
   without specifying <TT>localDe</TT> to access the unique PET-local
   <TT>farrayPtr</TT>. An error will be returned if <TT>localDe</TT> was omitted
   for an Array that holds multiple DEs per PET.

<P>
Besides direct access to the DE-local memory allocation through the 
   Fortran array pointer, the Array can also be queried for a list of PET-local
   LocalArray objects. See section <A HREF="node5.html#Array:LocalArray">24.2.3</A> for more on LocalArray
   usage in Array. In most cases this approach is less convenient than the direct
   <TT>farrayPtr</TT> method, because it adds an extra object level between the
   Array and the native language array. Further, the 1 DE per PET case is not
   treated in a simplified manner. 

<P>
<PRE>
  allocate(larrayList(localDeCount))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
</PRE>

<P>
<PRE>
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
</PRE>

<P>
<PRE>
    ! use myFarray to access local DE data
  enddo
</PRE>

<P>

<H3><A NAME="SECTION05052600000000000000"></A>
   <A NAME="Array_regions_and_default_bounds"></A>
<BR>
24.2.6 Regions and default bounds
</H3>

<P>
Each <TT>ESMF_Array</TT> object is decomposed into DEs as specified by the
   associated <TT>ESMF_DistGrid</TT> object. Each piece of this decomposition, i.e.
   each DE, holds a chunk of the Array data in its own local piece of memory.
   The details of the Array decomposition are described in the following 
   paragraphs.

<P>
At the center of the Array decomposition is the <TT>ESMF_DistGrid</TT> class.
   The DistGrid object specified during Array creation contains three essential
   pieces of information:
   
<UL>
<LI>The extent and topology of the global domain covered by the Array object
         in terms of indexed elements. The total extent may be a composition or 
         tilework of smaller logically rectangular (LR) domain pieces or tiles.
</LI>
<LI>The decomposition of the entire domain into "element exclusive" DE-local
         LR chunks. <EM>Element exclusive</EM> means that there is no element overlap
         between DE-local chunks. This, however, does not exclude degeneracies 
         on edge boundaries for certain topologies (e.g. bipolar).
</LI>
<LI>The layout of DEs over the available PETs and thus the distribution of
         the Array data.
   
</LI>
</UL>

<P>
Each element of an Array is associated with a <EM>single</EM> DE. The union of
   elements associated with a DE, as defined by the DistGrid above, corresponds
   to a LR chunk of index space, called the <EM>exclusive region</EM> of the DE.

<P>
There is a hierarchy of four regions that can be identified for each DE in an
   Array object. Their definition and relationship to each other is as follows:
   
<UL>
<LI><EM>Interior Region</EM>: Region that only contains local elements that are
         <EM>not</EM> mapped into the halo of any other DE. The shape and size of 
         this region for a particular DE depends non-locally on the halos defined
         by other DEs and may change during computation as halo operations are
         precomputed and released. Knowledge of the interior elements may be used
         to improve performance by overlapping communications with ongoing 
         computation for a DE.
</LI>
<LI><EM>Exclusive Region</EM>: Elements for which a DE claims exclusive
         ownership. Practically this means that the DE will be the sole source
         for these elements in halo and reduce operations. There are exceptions
         to this in some topologies. The exclusive region includes all elements
         of the interior region.
</LI>
<LI><EM>Computational Region</EM>: Region that can be set arbitrarily within
         the bounds of the total region (defined next). The typical use of the
         computation region is to define bounds that only include elements that
         are updated by a DE-local computation kernel. The computational region
         does not need to include all exclusive elements and it may also contain
         elements that lie outside the exclusive region.
</LI>
<LI><EM>Total (Memory) Region</EM>: Total of all DE-locally allocated elements.
         The size and shape of the total memory region must accommodate the
         union of exclusive and computational region but may contain 
         additional elements. Elements outside the exclusive region may overlap
         with the exclusive region of another DE which makes them potential 
         receivers for Array halo operations. Elements outside the exclusive
         region that do not overlap with the exclusive region of another DE
         can be used to set boundary conditions and/or serve as extra memory 
         padding.
   
</LI>
</UL>

<P>
<PRE>
  
     +-totalLBound(:)----------------------------------+
     |\                                                |
     | \ &lt;--- totalLWidth(:)                           |
     |  \                                              |
     |   +-computationalLBound(:)------------------+   |
     |   |\                                        |   |
     |   | \ &lt;--- computationalLWidth(:)           |   |
     |   |  \                                      |   |
     |   |   +-exclusiveLBound(:)-------------+    |   |
     |   |   |                                |    |   |
     |   |   |     +------+      +-----+      |    |   |
     |   |   |     |      |      |     |      |    |   |
     |   |   |     |      +------+     |      |    |   |
     |   |   |     | "Interior Region" |      |    |   |
     |   |   |     +-----+             |      |    |   |
     |   |   |           |             |      |    |   |
     |   |   |           +-------------+      |    |   |
     |   |   |                                |    |   |
     |   |   | "Exclusive Region"             |    |   |
     |   |   +-------------exclusiveUBound(:)-+    |   |
     |   |                                     \   |   |
     |   |           computationalUWidth(:) --&gt; \  |   |
     |   |                                       \ |   |
     |   | "Computational Region"                 \|   |
     |   +------------------computationalUBound(:)-+   |
     |                                              \  | 
     |                             totalUWidth(:) -&gt; \ | 
     | "Total Region"                                 \| 
     +--------------------------------- totalUBound(:)-+
</PRE>

<P>
With the following definitions:
   <PRE>
  
   computationalLWidth(:) = exclusiveLBound(:) - computationalLBound(:)
   computationalUWidth(:) = computationalUBound(:) - exclusiveUBound(:)
</PRE>
   and
   <PRE>
  
   totalLWidth(:) = exclusiveLBound(:) - totalLBound(:)
   totalUWidth(:) = totalUBound(:) - exclusiveUBound(:)
</PRE>

<P>
The <EM>exclusive region</EM> is determined during Array creation by the 
   DistGrid argument. Optional arguments may be used to specify the 
   <EM>computational region</EM> when the Array is created, by default it will be
   set equal to the exclusive region. The <EM>total region</EM>, i.e. the actual
   memory allocation for each DE, is also determined during Array creation. When
   creating the Array object from existing Fortran arrays the total region is
   set equal to the memory provided by the Fortran arrays. Otherwise the 
   default is to allocate as much memory as is needed to accommodate the union
   of the DE-local exclusive and computational region. Finally it is also
   possible to use optional arguments to the ArrayCreate() call to specify the
   total region of the object explicitly.

<P>
The <TT>ESMF_ArrayCreate()</TT> call checks that the input parameters are
   consistent and will result in an Array that fulfills all of the above 
   mentioned requirements for its DE-local regions.

<P>
Once an Array object has been created the exclusive and total regions are
   fixed. The computational region, however, may be adjusted within the limits
   of the total region using the <TT>ArraySet()</TT> call.

<P>
The <EM>interior region</EM> is very different from the other regions in that
   it cannot be specified. The <EM>interior region</EM> for each DE is a <EM>   consequence</EM> of the choices made for the other regions collectively across
   all DEs into which an Array object is decomposed. An Array object can be
   queried for its DE-local <EM>interior regions</EM> as to offer additional
   information to the user necessary to write more efficient code.
   
<P>
By default the bounds of each DE-local <EM>total region</EM> are defined as
   to put the start of the DE-local <EM>exclusive region</EM> at the "origin" of 
   the local index space, i.e. at <TT>(1, 1, ..., 1)</TT>. With that definition the
   following loop will access each element of the DE-local memory segment for
   each PET-local DE of the Array object used in the previous sections and
   print its content. 

<P>
<PRE>
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    do i=1, size(myFarray, 1)
      do j=1, size(myFarray, 2)
        print *, "PET-local DE=", de, ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION05052700000000000000">
24.2.7 Array bounds</A>
</H3>

<P>
The loop over Array elements at the end of the last section only works
   correctly because of the default definition of the <EM>computational</EM> and
   <EM>total regions</EM> used in the example. In general, without such specific
   knowledge about an Array object, it is necessary to use a more formal approach
   to access its regions with DE-local indices.

<P>
The DE-local <EM>exclusive region</EM> takes a central role in the definition
   of Array bounds. Even as the <EM>computational region</EM> may adjust during 
   the course of execution the <EM>exclusive region</EM> remains unchanged.
   The <EM>exclusive region</EM> provides a unique reference frame
   for the index space of all Arrays associated with the same DistGrid.

<P>
There is a choice between two indexing options that needs to be made during 
   Array creation. By default each DE-local exclusive region starts at 
   <TT>(1, 1, ..., 1)</TT>. However, for some computational kernels it may be more
   convenient to choose the index bounds of the DE-local exclusive regions to 
   match the index space coordinates as they are defined in the corresponding
   DistGrid object. The second option is only available if the DistGrid object 
   does not contain any non-contiguous decompositions (such as cyclically
   decomposed dimensions).

<P>
The following example code demonstrates the safe way of dereferencing the
   DE-local exclusive regions of the previously created <TT>array</TT> object.

<P>
<PRE>
  allocate(exclusiveUBound(2, localDeCount))  ! dimCount=2
  allocate(exclusiveLBound(2, localDeCount))  ! dimCount=2
  call ESMF_ArrayGet(array, indexflag=indexflag, &amp;
    exclusiveLBound=exclusiveLBound, exclusiveUBound=exclusiveUBound, rc=rc)
  if (indexflag == ESMF_INDEX_DELOCAL) then
    ! this is the default
!    print *, "DE-local exclusive regions start at (1,1)"
    do de=1, localDeCount
      call ESMF_LocalArrayGet(larrayList(de), myFarray, &amp;
          datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
      do i=1, exclusiveUBound(1, de)
        do j=1, exclusiveUBound(2, de)
!          print *, "DE-local exclusive region for PET-local DE=", de, &amp;
!            ": array(",i,",",j,")=", myFarray(i,j)
        enddo
      enddo
    enddo
  else if (indexflag == ESMF_INDEX_GLOBAL) then
    ! only if set during ESMF_ArrayCreate()
!    print *, "DE-local exclusive regions of this Array have global bounds"
    do de=1, localDeCount
      call ESMF_LocalArrayGet(larrayList(de), myFarray, &amp;
         datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
      do i=exclusiveLBound(1, de), exclusiveUBound(1, de)
        do j=exclusiveLBound(2, de), exclusiveUBound(2, de)
!          print *, "DE-local exclusive region for PET-local DE=", de, &amp;
!            ": array(",i,",",j,")=", myFarray(i,j)
        enddo
      enddo
    enddo
  endif
  call ESMF_ArrayDestroy(array, rc=rc) ! destroy the array object
</PRE>

<P>
Obviously the second branch of this simple code will work for either case, 
   however, if a complex computational kernel was written assuming 
   <TT>ESMF_INDEX_DELOCAL</TT> type bounds the second branch would simply be 
   used to indicate the problem and bail out.

<P>
The advantage of the <TT>ESMF_INDEX_GLOBAL</TT> index option is that
   the Array bounds directly contain information on where the DE-local
   Array piece is located in a global index space sense. When the
   <TT>ESMF_INDEX_DELOCAL</TT> option is used the correspondence between local
   and global index space must be made by querying the associated DistGrid for
   the DE-local <TT>indexList</TT> arguments.

<P>

<H3><A NAME="SECTION05052800000000000000"></A>
   <A NAME="Array:padding"></A>
<BR>
24.2.8 Computational region and extra elements for halo or padding
</H3>

<P>
In the previous examples the computational region of <TT>array</TT> was chosen 
   by default to be identical to the exclusive region defined by the DistGrid
   argument during Array creation. In the following the same <TT>arrayspec</TT> and
   <TT>distgrid</TT> objects as before will be used to create an Array but now a 
   larger computational region shall be defined around each DE-local exclusive 
   region. Furthermore, extra space will be defined around the computational
   region of each DE to accommodate a halo and/or serve as memory padding.

<P>
In this example the <TT>indexflag</TT> argument is set to 
   <TT>ESMF_INDEX_GLOBAL</TT> indicating that the bounds of the exclusive region
   correspond to the index space coordinates as they are defined by the DistGrid
   object.

<P>
The same <TT>arrayspec</TT> and <TT>distgrid</TT> objects as before are used
   which also allows the reuse of the already allocated <TT>larrayList</TT>
   variable. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    computationalLWidth=(/0,3/), computationalUWidth=(/1,1/), &amp;
    totalLWidth=(/1,4/), totalUWidth=(/3,1/), &amp;
    indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
Obtain the <TT>larrayList</TT> on every PET. 

<P>
<PRE>
  allocate(localDeList(localDeCount))
  call ESMF_ArrayGet(array, localarrayList=larrayList, &amp;
    localDeList=localDeList, rc=rc)
</PRE>

<P>
The bounds of DE 1 for <TT>array</TT> are shown in the following 
   diagram to illustrate the situation. Notice that the <TT>totalLWidth</TT> and
   <TT>totalUWidth</TT> arguments in the ArrayCreate() call define the total region 
   with respect to the exclusive region given for each DE by the <TT>distgrid</TT> 
   argument.

<P>
<PRE>
        +-(3,-3)---------------------------------+ 
        |\                                       | 
        | +-(4,-2)-+-(4,1)--------------------+--+ 
        | |        |                          |  | 
        | |        |                          |  | 
        | |        |          DE 1            |  | 
        | |        |                          |  | 
        | |        |                          |  | 
        | |        | Exclusive Region         |  | 
        | |        +--------------------(5,2)-+  | 
        | | Computational Region                 | 
        | +-------------------------------(6,3)--+ 
        |                                        | 
        | Total Region                           | 
        +---------------------------------(8,3)--+
</PRE>

<P>
When working with this <TT>array</TT> it is possible for the computational
   kernel to overstep the exclusive region for both read/write access 
   (computational region) and potentially read-only access into the total region
   outside of the computational region, if a halo operation provides valid 
   entries for these elements. 

<P>
The Array object can be queried for absolute <EM>bounds</EM> 

<P>
<PRE>
  allocate(computationalLBound(2, localDeCount))  ! dimCount=2
  allocate(computationalUBound(2, localDeCount))  ! dimCount=2
  allocate(totalLBound(2, localDeCount))          ! dimCount=2
  allocate(totalUBound(2, localDeCount))          ! dimCount=2
  call ESMF_ArrayGet(array, exclusiveLBound=exclusiveLBound, &amp;
    exclusiveUBound=exclusiveUBound, &amp;
    computationalLBound=computationalLBound, &amp;
    computationalUBound=computationalUBound, &amp;
    totalLBound=totalLBound, &amp;
    totalUBound=totalUBound, rc=rc)
</PRE>

<P>
or for the relative <EM>widths</EM>. 

<P>
<PRE>
  allocate(computationalLWidth(2, localDeCount))  ! dimCount=2
  allocate(computationalUWidth(2, localDeCount))  ! dimCount=2
  allocate(totalLWidth(2, localDeCount))          ! dimCount=2
  allocate(totalUWidth(2, localDeCount))          ! dimCount=2
  call ESMF_ArrayGet(array, computationalLWidth=computationalLWidth, &amp;
    computationalUWidth=computationalUWidth, totalLWidth=totalLWidth, &amp;
    totalUWidth=totalUWidth, rc=rc)
</PRE>

<P>
Either way the dereferencing of Array data is centered around the DE-local
   exclusive region: 

<P>
<PRE>
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    ! initialize the DE-local array
    myFarray = 0.1d0 * localDeList(de)
    ! first time through the total region of array    
!    print *, "myFarray bounds for DE=", localDeList(de), &amp;
!      lbound(myFarray),  ubound(myFarray)
    do j=exclusiveLBound(2, de), exclusiveUBound(2, de)
      do i=exclusiveLBound(1, de), exclusiveUBound(1, de)
!        print *, "Excl region DE=", localDeList(de), &amp;
!        ": array(",i,",",j,")=",  myFarray(i,j)
      enddo
    enddo
    do j=computationalLBound(2, de), computationalUBound(2, de)
      do i=computationalLBound(1, de), computationalUBound(1, de)
!        print *, "Excl region DE=", localDeList(de), &amp;
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
    do j=totalLBound(2, de), totalUBound(2, de)
      do i=totalLBound(1, de), totalUBound(1, de)
!        print *, "Total region DE=", localDeList(de), &amp;
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo

    ! second time through the total region of array    
    do j=exclusiveLBound(2, de)-totalLWidth(2, de), &amp;
      exclusiveUBound(2, de)+totalUWidth(2, de)
      do i=exclusiveLBound(1, de)-totalLWidth(1, de), &amp;
        exclusiveUBound(1, de)+totalUWidth(1, de)
!        print *, "Excl region DE=", localDeList(de), &amp;
!        ": array(",i,",",j,")=", myFarray(i,j)
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION05052900000000000000">
24.2.9 Create 1D and 3D Arrays</A>
</H3>

<P>
All previous examples were written for the 2D case. There is, however, no
   restriction within the Array or DistGrid class that limits the dimensionality
   of Array objects beyond the language specific limitations (7D for Fortran). 

<P>
In order to create an <TT>n</TT>-dimensional Array the rank indicated by both
   the <TT>arrayspec</TT> and the <TT>distgrid</TT> arguments specified during Array
   create must be equal to <TT>n</TT>. A 1D Array of double precision real data
   hence requires the following <TT>arrayspec</TT>. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=1, rc=rc)
</PRE>

<P>
The index space covered by the Array and the decomposition description is
   provided to the Array create method by the <TT>distgrid</TT> argument. The index
   space in this example has 16 elements and covers the interval <IMG
 WIDTH="58" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img44.png"
 ALT="$[-10, 5]$">. It is 
   decomposed into as many DEs as there are PETs in the current context. 

<P>
<PRE>
  distgrid1D = ESMF_DistGridCreate(minIndex=(/-10/), maxIndex=(/5/), &amp;
    regDecomp=(/petCount/), rc=rc)
</PRE>

<P>
A 1D Array object with default regions can now be created. 

<P>
<PRE>
  array1D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid1D, rc=rc)
</PRE>

<P>
The creation of a 3D Array proceeds analogous to the 1D case. The rank of the
   <TT>arrayspec</TT> must be changed to 3 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
and an appropriate 3D DistGrid object must be created 

<P>
<PRE>
  distgrid3D = ESMF_DistGridCreate(minIndex=(/1,1,1/), &amp;
    maxIndex=(/16,16,16/), regDecomp=(/4,4,4/), rc=rc)
</PRE>

<P>
before an Array object can be created. 

<P>
<PRE>
  array3D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid3D, rc=rc)
</PRE>

<P>
The <TT>distgrid3D</TT> object decomposes the 3-dimensional index space into
   <!-- MATH
 $4\times 4\times 4 = 64$
 -->
<IMG
 WIDTH="106" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img45.png"
 ALT="$4\times 4\times 4 = 64$"> DEs. These DEs are laid out across the computational
   resources (PETs) of the current component according to a default DELayout that
   is created during the DistGrid create call. Notice that in the index space 
   proposal a DELayout does not have a sense of dimensionality. The DELayout
   function is simply to map DEs to PETs. The DistGrid maps chunks of index space
   against DEs and thus its rank is equal to the number of index space 
   dimensions.

<P>
The previously defined DistGrid and the derived Array object decompose 
   the index space along all three dimension. It is, however, not a requirement
   that the decomposition be along all dimensions. An Array with the same 3D
   index space could as well be decomposed along just one or along two of the
   dimensions. The following example shows how for the same index space only the
   last two dimensions are decomposed while the first Array dimension has full
   extent on all DEs. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array3D, rc=rc)
  call ESMF_DistGridDestroy(distgrid3D, rc=rc)
  distgrid3D = ESMF_DistGridCreate(minIndex=(/1,1,1/), &amp;
    maxIndex=(/16,16,16/), regDecomp=(/1,4,4/), rc=rc)
  array3D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid3D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050521000000000000000">
24.2.10 Working with Arrays of different rank</A>
</H3>
   Assume a computational kernel that involves the <TT>array3D</TT> object as it was
   created at the end of the previous section. Assume further that the kernel 
   also involves a 2D Array on a 16x16 index space where each point (j,k) was
   interacting with each (i,j,k) column of the 3D Array. An efficient formulation
   would require that the decomposition of the 2D Array must match that of the 3D
   Array and further the DELayout be identical. The following code shows how this
   can be accomplished. 

<P>
<PRE>
  call ESMF_DistGridGet(distgrid3D, delayout=delayout, rc=rc) ! get DELayout
  distgrid2D = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/16,16/), &amp;
    regDecomp=(/4,4/), delayout=delayout, rc=rc)
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  array2D = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid2D, rc=rc)
</PRE>

<P>
Now the following kernel is sure to work with <TT>array3D</TT> and <TT>array2D</TT>. 

<P>
<PRE>
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
  allocate(larrayList1(localDeCount))
  call ESMF_ArrayGet(array3D, localarrayList=larrayList1, rc=rc)
  allocate(larrayList2(localDeCount))
  call ESMF_ArrayGet(array2D, localarrayList=larrayList2, rc=rc)
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList1(de), myFarray3D, &amp;
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D = 0.1d0 * de ! initialize
    call ESMF_LocalArrayGet(larrayList2(de), myFarray2D, &amp;
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray2D = 0.5d0 * de ! initialize
    do k=1, 4
      do j=1, 4
        dummySum = 0.d0
        do i=1, 16
          dummySum = dummySum + myFarray3D(i,j,k) ! sum up the (j,k) column
        enddo
        dummySum = dummySum * myFarray2D(j,k) ! multiply with local 2D element
!        print *, "dummySum(",j,k,")=",dummySum
      enddo
    enddo
  enddo
</PRE>

<P>

<H3><A NAME="SECTION050521100000000000000">
24.2.11 Array and DistGrid rank - 2D+1 Arrays</A>
</H3>

<P>
Except for the special Array create interface that implements a copy from
   an existing Array object all other Array create interfaces require the 
   specification of at least two arguments: <TT>farray</TT> and <TT>distgrid</TT>,
   <TT>larrayList</TT> and <TT>distgrid</TT>, or <TT>arrayspec</TT> and <TT>distgrid</TT>.
   In all these cases both required arguments contain a sense of dimensionality.
   The relationship between these two arguments deserves extra attention.

<P>
The first argument, <TT>farray</TT>, <TT>larrayList</TT> or <TT>arrayspec</TT>, 
   determines the rank of the created Array object, i.e. the dimensionality
   of the actual data storage. The rank of a native language array, extracted 
   from an Array object, is equal to the rank specified by either of these
   arguments. So is the <TT>rank</TT> that is returned by the <TT>ESMF_ArrayGet()</TT>
   call.

<P>
The rank specification contained in the <TT>distgrid</TT> argument, which is of 
   type <TT>ESMF_DistGrid</TT>, on the other hand has no affect on the 
   rank of the Array. The <TT>dimCount</TT> specified by the DistGrid object,
   which may be equal, greater or less than the Array rank, determines the 
   dimensionality of the <EM>decomposition</EM>.

<P>
While there is no constraint between DistGrid <TT>dimCount</TT> and Array
   <TT>rank</TT>, there is an important relationship between the two, resulting in
   the concept of index space dimensionality. Array dimensions can be
   arbitrarily mapped against DistGrid dimension, rendering them <EM>decomposed</EM>
   dimensions. The index space dimensionality is equal to the number of 
   decomposed Array dimensions.

<P>
Array dimensions that are not mapped to DistGrid dimensions are the 
   <EM>undistributed</EM> dimensions of the Array. They are not part
   of the index space. The mapping is specified during <TT>ESMF_ArrayCreate()</TT>
   via the <TT>distgridToArrayMap</TT> argument. DistGrid dimensions that have
   not been associated with Array dimensions are <EM>replicating</EM> dimensions.
   The Array will be replicated across the DEs that lie along replication
   DistGrid dimensions.

<P>
Undistributed Array dimensions can be used to store multi-dimensional data for
   each Array index space element. One application of this is to store the 
   components of a vector quantity in a single Array. The same 2D <TT>distgrid</TT>
   object as before will be used. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
The rank in the <TT>arrayspec</TT> argument, however, must change from 2 to 3 in
   order to provide for the extra Array dimension. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
During Array creation with extra dimension(s) it is necessary to specify the
   bounds of these undistributed dimension(s). This requires two additional
   arguments, <TT>undistLBound</TT> and <TT>undistUBound</TT>, which are vectors in 
   order to accommodate multiple undistributed dimensions. The other arguments
   remain unchanged and apply across all undistributed components. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/0,1/), totalUWidth=(/0,1/), &amp;
    undistLBound=(/1/), undistUBound=(/2/), rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>
This will create <TT>array</TT> with 2+1 dimensions. The 2D DistGrid is used
   to describe decomposition into DEs with 2 Array dimensions mapped to the 
   DistGrid dimensions resulting in a 2D index space. The extra Array dimension
   provides storage for multi component user data within the Array object.

<P>
By default the <TT>distgrid</TT> dimensions are associated
   with the first Array dimensions in sequence. For the example above this means
   that the first 2 Array dimensions are decomposed according to the provided 2D
   DistGrid. The 3rd Array dimension does not have an associated DistGrid
   dimension, rendering it an undistributed Array dimension.

<P>
Native language access to an Array with undistributed dimensions is in
   principle the same as without extra dimensions. 

<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
  allocate(larrayList(localDeCount))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
</PRE>

<P>
The following loop shows how a Fortran pointer to the DE-local data chunks
   can be obtained and used to set data values in the exclusive regions. The
   <TT>myFarray3D</TT> variable must be of rank 3 to match the Array rank of
   <TT>array</TT>. However, variables such as <TT>exclusiveUBound</TT> that store the
   information about the decomposition, remain to be allocated for the 2D 
   index space. 

<P>
<PRE>
  call ESMF_ArrayGet(array, exclusiveLBound=exclusiveLBound, &amp;
    exclusiveUBound=exclusiveUBound, rc=rc)
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray3D, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D = 0.0 ! initialize
    myFarray3D(exclusiveLBound(1,de):exclusiveUBound(1,de), &amp;
      exclusiveLBound(2,de):exclusiveUBound(2,de), 1) = 5.1 ! dummy assignment
    myFarray3D(exclusiveLBound(1,de):exclusiveUBound(1,de), &amp;
      exclusiveLBound(2,de):exclusiveUBound(2,de), 2) = 2.5 ! dummy assignment
  enddo
  deallocate(larrayList)
</PRE>

<P>
For some applications the default association rules between DistGrid and Array
   dimensions may not satisfy the user's needs. The optional <TT>distgridToArrayMap</TT> 
   argument can be used during Array creation to explicitly specify the mapping 
   between DistGrid and Array dimensions. To demonstrate this the following lines
   of code reproduce the above example but with rearranged dimensions. Here the
   <TT>distgridToArrayMap</TT> argument is a list with two elements corresponding to
   the DistGrid <TT>dimCount</TT> of 2. The first element indicates which Array
   dimension the first DistGrid dimension is mapped against. Here the
   1st DistGrid dimension maps against the 3rd Array dimension and the 2nd 
   DistGrid dimension maps against the 1st Array dimension. This leaves the 2nd
   Array dimension to be the extra and undistributed dimension in the resulting
   Array object. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/3, 1/), totalLWidth=(/0,1/), totalUWidth=(/0,1/), &amp;
    undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
Operations on the Array object as a whole are unchanged by the different
   mapping of dimensions.

<P>
When working with Arrays that contain explicitly mapped Array and DistGrid 
   dimensions it is critical to know the order in which the entries of
   <EM>width</EM> and <EM>bound</EM> arguments that are associated with distributed
   Array dimensions are specified. The size of these arguments is equal to the
   DistGrid <TT>dimCount</TT>, because the maximum number of distributed Array
   dimensions is given by the dimensionality of the index space.

<P>
The order of dimensions in these arguments, however, is <EM>not</EM> that of
   the associated DistGrid. Instead each entry corresponds to the distributed
   Array dimensions in sequence. In the example above the entries in 
   <TT>totalLWidth</TT> and <TT>totalUWidth</TT> correspond to Array dimensions 1 and
   3 in this sequence. 

<P>
The <TT>distgridToArrrayMap</TT> argument optionally provided during Array create
   indicates how the DistGrid dimensions map to Array dimensions. The inverse
   mapping, i.e. Array to DistGrid dimensions, is just as important. The 
   <TT>ESMF_ArrayGet()</TT> call offers both mappings as <TT>distgridToArrrayMap</TT>
   and <TT>arrayToDistGridMap</TT>, respectively. The number of elements in 
   <TT>arrayToDistGridMap</TT> is equal to the rank of the Array. Each element
   corresponds to an Array dimension and indicates the associated DistGrid
   dimension by an integer number. An entry of "0" in <TT>arrayToDistGridMap</TT>
   indicates that the corresponding Array dimension is undistributed.

<P>
Correct understanding about the association between Array and DistGrid
   dimensions becomes critical for correct data access into the Array. 

<P>
<PRE>
  allocate(arrayToDistGridMap(3))  ! arrayRank = 3
  call ESMF_ArrayGet(array, arrayToDistGridMap=arrayToDistGridMap, &amp;
    exclusiveLBound=exclusiveLBound, exclusiveUBound=exclusiveUBound, &amp;
    localDeCount=localDeCount, rc=rc)  
  if (arrayToDistGridMap(2) /= 0) then   ! check if extra dimension at 
    ! expected index indicate problem and bail out
  endif
  ! obtain larrayList for local DEs
  allocate(larrayList(localDeCount))
  call ESMF_ArrayGet(array, localarrayList=larrayList, rc=rc)
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray3D, &amp;
       datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
    myFarray3D(exclusiveLBound(1,de):exclusiveUBound(1,de), &amp;
      1, exclusiveLBound(2,de):exclusiveUBound(2,de)) = 10.5 !dummy assignment
    myFarray3D(exclusiveLBound(1,de):exclusiveUBound(1,de), &amp;
      2, exclusiveLBound(2,de):exclusiveUBound(2,de)) = 23.3 !dummy assignment
  enddo
  deallocate(exclusiveLBound, exclusiveUBound)
  deallocate(arrayToDistGridMap)
  deallocate(larrayList)
  call ESMF_ArrayDestroy(array, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
</PRE>

<P>

<H3><A NAME="SECTION050521200000000000000">
24.2.12 Arrays with replicated dimensions</A>
</H3>

<P>
Thus far most examples demonstrated cases where the DistGrid <TT>dimCount</TT>
   was equal to the Array <TT>rank</TT>. The previous section introduced the
   concept of Array <EM>tensor</EM> dimensions when <TT>dimCount &lt; rank</TT>. In this
   section <TT>dimCount</TT> and <TT>rank</TT> are assumed completely unconstrained and
   the relationship to <TT>distgridToArrayMap</TT> and <TT>arrayToDistGridMap</TT> will
   be discussed.

<P>
The Array class allows completely arbitrary mapping between Array and
   DistGrid dimensions. Most cases considered in the previous sections used
   the default mapping which assigns the DistGrid dimensions in sequence to the
   lower Array dimensions. Extra Array dimensions, if present, are considered
   non-distributed tensor dimensions for which the optional <TT>undistLBound</TT>
   and <TT>undistUBound</TT> arguments must be specified.

<P>
The optional <TT>distgridToArrayMap</TT> argument provides the option to override
   the default DistGrid to Array dimension mapping. The entries of the
   <TT>distgridToArrayMap</TT> array correspond to the DistGrid dimensions in
   sequence and assign a unique Array dimension to each DistGrid dimension.
   DistGrid and Array dimensions are indexed starting at <TT>1</TT> for the lowest
   dimension. A value of <TT>"0"</TT> in the <TT>distgridToArrayMap</TT> array 
   indicates that the respective DistGrid dimension is <EM>not</EM> mapped against
   any Array dimension. What this means is that the Array will be replicated 
   along this DistGrid dimension.

<P>
As a first example consider the case where a 1D Array 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=1, rc=rc)
</PRE>

<P>
is created on the 2D DistGrid used during the previous section. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
Here the default DistGrid to Array dimension mapping is used which assigns
   the Array dimensions in sequence to the DistGrid dimensions starting with
   dimension "1". Extra DistGrid dimensions are considered replicator dimensions
   because the Array will be replicated along those dimensions. In the above
   example the 2nd DistGrid dimension will cause 1D Array pieces to be
   replicated along the DEs of the 2nd DistGrid dimension. Replication in the
   context of <TT>ESMF_ArrayCreate()</TT> does not mean that data values are
   communicated and replicated between different DEs, but it means that different
   DEs provide memory allocations for <EM>identical</EM> exclusive elements.

<P>
Access to the data storage of an Array that has been replicated along 
   DistGrid dimensions is the same as for Arrays without replication. 

<P>
<PRE>
  call ESMF_ArrayGet(array, localDeCount=localDeCount, rc=rc)
</PRE>

<P>
<PRE>
  allocate(larrayList(localDeCount))
  allocate(localDeList(localDeCount))
  call ESMF_ArrayGet(array, localarrayList=larrayList, &amp;
    localDeList=localDeList, rc=rc)
</PRE>

<P>
The <TT>array</TT> object was created without additional padding which means
   that the bounds of the Fortran array pointer correspond to the bounds of
   the exclusive region. The following loop will cycle through all local DEs, 
   print the DE number as well as the Fortran array pointer bounds. The bounds
   should be:
   <PRE>
            lbound       ubound
  
   DE 0:      1            3         --+
   DE 2:      1            3         --|  1st replication set
   DE 4:      1            3         --+
  
   DE 1:      1            2         --+
   DE 3:      1            2         --|  2nd replication set
   DE 5:      1            2         --+
</PRE> 

<P>
<PRE>
  do de=1, localDeCount
    call ESMF_LocalArrayGet(larrayList(de), myFarray1D, &amp;
      datacopyflag=ESMF_DATACOPY_REFERENCE, rc=rc)
</PRE>

<P>
<PRE>
    print *, "DE ",localDeList(de)," [", lbound(myFarray1D), &amp;
      ubound(myFarray1D),"]"
  enddo
  deallocate(larrayList)
  deallocate(localDeList)
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
The Fortran array pointer in the above loop was of rank 1 because the
   Array object was of rank 1. However, the <TT>distgrid</TT> object associated
   with <TT>array</TT> is 2-dimensional! Consequently DistGrid based information
   queried from <TT>array</TT> will be 2D. The <TT>distgridToArrayMap</TT> and
   <TT>arrayToDistGridMap</TT>
   arrays provide the necessary mapping to correctly associate DistGrid based 
   information with Array dimensions.

<P>
The next example creates a 2D Array 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
on the previously used 2D DistGrid. By default, i.e. without the
   <TT>distgridToArrayMap</TT>
   argument, both DistGrid dimensions would be associated with the two Array
   dimensions. However, the <TT>distgridToArrayMap</TT> specified in the following
   call will only associate the second DistGrid dimension with the first Array 
   dimension. This will render the first DistGrid dimension a replicator
   dimension and the second Array dimension a tensor dimension for which 1D
   <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments must be supplied. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,1/), undistLBound=(/11/), &amp;
    undistUBound=(/14/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Finally, the same <TT>arrayspec</TT> and <TT>distgrid</TT> arguments are used to
   create a 2D Array that is fully replicated in both dimensions of the DistGrid.
   Both Array dimensions are now tensor dimensions and both DistGrid dimensions
   are replicator dimensions. 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,0/), undistLBound=(/11,21/), &amp;
    undistUBound=(/14,22/), rc=rc)
</PRE>

<P>
The result will be an Array with local lower bound (/11,21/) and upper bound
   (/14,22/) on all 6 DEs of the DistGrid. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
Replicated Arrays can also be created from existing local Fortran arrays.
   The following Fortran array allocation will provide a 3 x 10 array on each
   PET.  

<P>
<PRE>
  allocate(myFarray2D(3,10))
</PRE>

<P>
Assuming a petCount of 4 the following DistGrid defines a 2D index space
   that is distributed across the PETs along the first dimension. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
The following call creates an Array object on the above distgrid using
   the locally existing <TT>myFarray2D</TT> Fortran arrays. The difference 
   compared to the case with automatic memory allocation is that instead of
   <TT>arrayspec</TT> the Fortran array is provided as argument. Furthermore,
   the <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments can be omitted,
   defaulting into Array tensor dimension lower bound of 1 and an upper
   bound equal to the size of the respective Fortran array dimension. 

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=myFarray2D, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, distgridToArrayMap=(/0,2/), rc=rc)
</PRE>

<P>
The <TT>array</TT> object associates the 2nd DistGrid dimension with the 2nd
   Array dimension. The first DistGrid dimension is not associated with any
   Array dimension and will lead to replication of the Array along the DEs of
   this direction. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050521300000000000000"></A>
   <A NAME="Array:ScatterGather"></A>
<BR>
24.2.13 Communication - Scatter and Gather
</H3>

<P>
It is a common situation, particularly in legacy code, that an ESMF Array
   object must be filled with data originating from a large Fortran array stored
   on a single PET. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(farray(10,20,30))
    do k=1, 30
      do j=1, 20
        do i=1, 10
          farray(i, j, k) = k*1000 + j*100 +  i
        enddo
      enddo
    enddo
  endif
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1,1/), maxIndex=(/10,20,30/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=3, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
The <TT>ESMF_ArrayScatter()</TT> method provides a convenient way of scattering
   array data from a single root PET across the DEs of an ESMF Array object. 

<P>
<PRE>
  call ESMF_ArrayScatter(array, farray=farray, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    deallocate(farray)
  endif
</PRE>

<P>
The destination of the ArrayScatter() operation are all the DEs of a single
   tile. For multi-tile Arrays the destination tile can be specified. The 
   shape of the scattered Fortran array must match the shape of the destination
   tile in the ESMF Array.

<P>
Gathering data decomposed and distributed across the DEs of an ESMF Array
   object into a single Fortran array on root PET is accomplished by calling
   <TT>ESMF_ArrayGather()</TT>. 

<P>
<PRE>
  if (localPet == 3) then
    allocate(farray(10,20,30))
  endif
  
  call ESMF_ArrayGather(array, farray=farray, rootPet=3, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 3) then
    deallocate(farray)
  endif
</PRE>

<P>
The source of the ArrayGather() operation are all the DEs of a single
   tile. For multi-tile Arrays the source tile can be specified. The 
   shape of the gathered Fortran array must match the shape of the source
   tile in the ESMF Array. 

<P>
The <TT>ESMF_ArrayScatter()</TT> operation allows to fill entire replicated
   Array objects with data coming from a single root PET. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    distgridToArrayMap=(/0,0/), undistLBound=(/11,21/), &amp;
    undistUBound=(/14,22/), rc=rc)
</PRE>

<P>
The shape of the Fortran source array used in the Scatter() call must be
   that of the contracted Array, i.e. contracted DistGrid dimensions do not
   count. For the <TT>array</TT> just created this means that the source array
   on <TT>rootPet</TT> must be of shape 4 x 2. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(myFarray2D(4,2))
    do j=1,2
      do i=1,4
        myFarray2D(i,j) = i * 100.d0 + j * 1.2345d0 ! initialize
      enddo
    enddo
  endif
  
  call ESMF_ArrayScatter(array, farray=myFarray2D, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    deallocate(myFarray2D)
  endif
</PRE>

<P>
This will have filled each local 4 x 2 Array piece with the replicated
   data of <TT>myFarray2D</TT>. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
As a second example for the use of Scatter() and Gather() consider the
   following replicated Array created from existing local Fortran arrays. 

<P>
<PRE>
  allocate(myFarray2D(3,10))
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/40,10/), rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(farray=myFarray2D, distgrid=distgrid, &amp;
    indexflag=ESMF_INDEX_DELOCAL, distgridToArrayMap=(/0,2/), rc=rc)
</PRE>

<P>
The <TT>array</TT> object associates the 2nd DistGrid dimension with the 2nd
   Array dimension. The first DistGrid dimension is not associated with any
   Array dimension and will lead to replication of the Array along the DEs of
   this direction. Still, the local arrays that comprise the <TT>array</TT> 
   object refer to independent pieces of memory and can be initialized 
   independently. 

<P>
<PRE>
  myFarray2D = localPet ! initialize
</PRE>

<P>
However, the notion of replication becomes visible when an array of shape
   3 x 10 on root PET 0 is scattered across the Array object. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(myFarray2D2(5:7,11:20))
  
    do j=11,20
      do i=5,7
        myFarray2D2(i,j) = i * 100.d0 + j * 1.2345d0 ! initialize
      enddo
    enddo
  endif
  
  call ESMF_ArrayScatter(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
<PRE>
  if (localPet == 0) then
    deallocate(myFarray2D2)
  endif
</PRE>

<P>
The Array pieces on every DE will receive the same source data, resulting
   in a replication of data along DistGrid dimension 1. 

<P>
When the inverse operation, i.e. <TT>ESMF_ArrayGather()</TT>, is applied to
   a replicated Array an intrinsic ambiguity needs to be considered. ESMF 
   defines the gathering of data of a replicated Array as the collection of data
   originating from the numerically higher DEs. This means that data in
   replicated elements associated with numerically lower DEs will be ignored
   during <TT>ESMF_ArrayGather()</TT>. For the current example this means that
   changing the Array contents on PET 1, which here corresponds to DE 1, 

<P>
<PRE>
  if (localPet == 1) then
    myFarray2D = real(1.2345, ESMF_KIND_R8)
  endif
</PRE>

<P>
will <EM>not</EM> affect the result of 

<P>
<PRE>
  allocate(myFarray2D2(3,10))
  myFarray2D2 = 0.d0    ! initialize to a known value
  call ESMF_ArrayGather(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
The result remains completely defined by the unmodified values of Array in 
   DE 3, the numerically highest DE. However, overriding the DE-local Array
   piece on DE 3 

<P>
<PRE>
  if (localPet==3) then
    myFarray2D = real(5.4321, ESMF_KIND_R8)
  endif
</PRE>

<P>
will change the outcome of 

<P>
<PRE>
  call ESMF_ArrayGather(array, farray=myFarray2D2, rootPet=0, rc=rc)
</PRE>

<P>
as expected. 

<P>
<PRE>
  deallocate(myFarray2D2)

  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050521400000000000000"></A>
   <A NAME="Array:Halo"></A>
<BR>
24.2.14 Communication - Halo
</H3>

<P>
One of the most fundamental communication pattern in domain decomposition
   codes is the <EM>halo</EM> operation. The ESMF Array class supports halos
   by allowing memory for extra elements to be allocated on each DE. See
   sections <A HREF="node5.html#Array:fpadding">24.2.2</A> and <A HREF="node5.html#Array:padding">24.2.8</A> for examples and
   details on how to create an Array with extra DE-local elements.

<P>
Here we consider an Array object that is created on a DistGrid that 
   defines a 10 x 20 index space, decomposed into 4 DEs using a regular
   2 x 2 decomposition. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/2,2/), rc=rc)
</PRE>

<P>
The Array holds 2D double precision float data. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
The <TT>totalLWidth</TT> and <TT>totalUWidth</TT> arguments are used during Array
   creation to allocate 2 extra elements along every direction outside the 
   exclusive region defined by the DistGrid for every DE. (The <TT>indexflag</TT>
   set to <TT>ESMF_INDEX_GLOBAL</TT> in this example does not affect the halo
   behavior of Array. The setting is simply more convenient for the following
   code.) 

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/2,2/), totalUWidth=(/2,2/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
Without the explicit definition of boundary conditions in the DistGrid
   the following inner connections are defined.

<P>
<PRE>
   
            +-------------------+       +-------------------+
            | \       2       / |       | \       2       / |
            |  +-------------+  |       |  +-------------+  |
            |  |     DE 0    |  |       |  |     DE 2    |  |
            |  |             |  |       |  |             |  |
            |2 |    5 x 10   | 2|  &lt;-&gt;  |2 |    5 x 10   | 2|
            |  |             |  |       |  |             |  |
            |  |             |  |       |  |             |  |
            |  +-------------+  |       |  +-------------+  |
            | /       2       \ |       | /       2       \ |
            +-------------------+       +-------------------+
  
                      ^            \/             ^
                      |            /\             |
                      v                           v
  
            +-------------------+       +-------------------+
            | \       2       / |       | \       2       / |
            |  +-------------+  |       |  +-------------+  |
            |  |     DE 1    |  |       |  |     DE 3    |  |
            |  |             |  |       |  |             |  |
            |2 |    5 x 10   | 2|  &lt;-&gt;  |2 |    5 x 10   | 2|
            |  |             |  |       |  |             |  |
            |  |             |  |       |  |             |  |
            |  +-------------+  |       |  +-------------+  |
            | /       2       \ |       | /       2       \ |
            +-------------------+       +-------------------+
</PRE>

<P>
The exclusive region on each DE is of shape 5 x 10, while the total region
   on each DE is of shape (5+2+2) x (10+2+2) = 9 x 14. In a typical application
   the elements in the exclusive region are updated exclusively by the PET that
   owns the DE. In this example the exclusive elements on every DE are
   initialized to the value <IMG
 WIDTH="48" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img46.png"
 ALT="$f(i,j)$"> of the geometric function
   <BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
f(i,j) = \sin(\alpha i)\cos(\beta j),
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="365" HEIGHT="28" BORDER="0"
 SRC="img47.png"
 ALT="\begin{displaymath}
f(i,j) = \sin(\alpha i)\cos(\beta j),
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(1)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
where
   <BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\alpha = 2\pi/N_i, i=1,...N_i
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="358" HEIGHT="28" BORDER="0"
 SRC="img48.png"
 ALT="\begin{displaymath}
\alpha = 2\pi/N_i, i=1,...N_i
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(2)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
and
   <BR>
<DIV ALIGN="RIGHT">

<!-- MATH
 \begin{equation}
\beta = 2\pi/N_j, j=1,...N_j,
\end{equation}
 -->
<TABLE WIDTH="100%" ALIGN="CENTER">
<TR VALIGN="MIDDLE"><TD ALIGN="CENTER" NOWRAP><IMG
 WIDTH="362" HEIGHT="29" BORDER="0"
 SRC="img49.png"
 ALT="\begin{displaymath}
\beta = 2\pi/N_j, j=1,...N_j,
\end{displaymath}"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
(3)</TD></TR>
</TABLE>
<BR CLEAR="ALL"></DIV><P></P>
with <IMG
 WIDTH="61" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img50.png"
 ALT="$N_i = 10$"> and <IMG
 WIDTH="63" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img51.png"
 ALT="$N_j = 20$">. 

<P>
<PRE>
  a = 2. * 3.14159 / 10.
  b = 2. * 3.14159 / 20.
  
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  
  call ESMF_ArrayGet(array, exclusiveLBound=eLB, exclusiveUBound=eUB, rc=rc)
</PRE>

<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo
</PRE>

<P>
The above loop only initializes the exclusive elements on each DE. The extra
   elements, outside the exclusive region, are left untouched, holding undefined
   values. Elements outside the exclusive region that correspond to 
   exclusive elements in neighboring DEs can be filled with the data values 
   in those neighboring elements. This is the definition of the halo operation.

<P>
In ESMF the halo communication pattern is first precomputed and stored in
   a RouteHandle object. This RouteHandle can then be used repeatedly to 
   perform the same halo operation in the most efficient way.

<P>
The default halo operation for an Array is precomputed by the following call. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
The <TT>haloHandle</TT> now holds the default halo operation for <TT>array</TT>, 
   which matches as many elements as possible outside the exclusive region to 
   their corresponding halo source elements in neighboring DEs. Elements that
   could not be matched, e.g. at the edge of the global domain with open
   boundary conditions, will not be updated by the halo operation.

<P>
The <TT>haloHandle</TT> is applied through the <TT>ESMF_ArrayHalo()</TT> method. 

<P>
<PRE>
  call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
Finally the resources held by <TT>haloHandle</TT> need to be released. 

<P>
<PRE>
  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
The <TT>array</TT> object created above defines a 2 element wide rim around the
   exclusive region on each DE. Consequently the default halo operation used
   above will have resulted in updating both elements along the inside edges.
   For simple numerical kernels often a single halo element is 
   sufficient. One way to achieve this would be to reduce the size of the 
   rim surrounding the exclusive region to 1 element along each direction. 
   However, if the same Array object is also used for higher order kernels
   during a different phase of the calculation, a larger element rim is
   required. For this case <TT>ESMF_ArrayHaloStore()</TT> offers two optional
   arguments <TT>haloLDepth</TT> and <TT>haloUDepth</TT>. Using these arguments a
   reduced halo depth can be specified. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, &amp;
    haloLDepth=(/1,1/), haloUDepth=(/1,1/), rc=rc)
</PRE>

<P>
This halo operation with a depth of 1 is sufficient to support a simple
   quadratic differentiation kernel. 

<P>
<PRE>
  allocate(farrayTemp(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)))

  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        if (i==1) then
          ! global edge
          farrayTemp(i,j) = 0.5 * (-farrayPtr(i+2,j) + 4.*farrayPtr(i+1,j) &amp;
            - 3.*farrayPtr(i,j)) / a
        else if (i==10) then
          ! global edge
          farrayTemp(i,j) = 0.5 * (farrayPtr(i-2,j) - 4.*farrayPtr(i-1,j) &amp;
            + 3.*farrayPtr(i,j)) / a
        else
          farrayTemp(i,j) = 0.5 * (farrayPtr(i+1,j) - farrayPtr(i-1,j)) / a
        endif
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
  
  deallocate(farrayTemp)

  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
The special treatment of the global edges in the above kernel is due to the 
   fact that the underlying DistGrid object does not define any special 
   boundary conditions. By default open global boundaries are assumed which
   means that the rim elements on the global edges are untouched during
   the halo operation, and cannot be used in the symmetric numerical derivative
   formula. The kernel can be simplified (and the calculation is more precise)
   with periodic boundary conditions along the first Array dimension.

<P>
First destroy the current Array and DistGrid objects. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
Create a DistGrid with periodic boundary condition along the first dimension. 

<P>
<PRE>
  allocate(connectionList(1))  ! one connection
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp;
     tileIndexA=1, tileIndexB=1, positionVector=(/10, 0/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/2,2/), connectionList=connectionList, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(connectionList)
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, &amp;
    totalLWidth=(/2,2/), totalUWidth=(/2,2/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
Initialize the exclusive elements to the same geometric function as before. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr, rc=rc)
</PRE>

<P>
<PRE>
  
  call ESMF_ArrayGet(array, exclusiveLBound=eLB, exclusiveUBound=eUB, rc=rc)
</PRE>

<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo
</PRE>

<P>
The numerical kernel only operates along the first dimension. An
   asymmetric halo depth can be used to take this fact into account. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle, &amp;
    haloLDepth=(/1,0/), haloUDepth=(/1,0/), rc=rc)
</PRE>

<P>
Now the same numerical kernel can be used without special treatment of
   global edge elements. The symmetric derivative formula can be used for
   all exclusive elements. 

<P>
<PRE>
  allocate(farrayTemp(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)))

  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        farrayTemp(i,j) = 0.5 * (farrayPtr(i+1,j) - farrayPtr(i-1,j)) / a
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
</PRE>

<P>
The precision of the above kernel can be improved by going to 
   a higher order interpolation. Doing so requires that the halo depth must be
   increased. The following code resets the exclusive Array elements
   to the test function, precomputes a RouteHandle for a halo operation
   with depth 2 along the first dimension, and finally uses the deeper halo
   in the higher order kernel. 

<P>
<PRE>
  
  do j=eLB(2,1), eUB(2,1)
    do i=eLB(1,1), eUB(1,1)
      farrayPtr(i,j) = sin(a*i) * cos(b*j)  ! test function
    enddo
  enddo

  call ESMF_ArrayHaloStore(array=array, routehandle=haloHandle2, &amp;
    haloLDepth=(/2,0/), haloUDepth=(/2,0/), rc=rc)
</PRE>

<P>
<PRE>
  do step=1, 4
    call ESMF_ArrayHalo(array=array, routehandle=haloHandle2, rc=rc)
</PRE>

<P>
<PRE>
    do j=eLB(2,1), eUB(2,1)
      do i=eLB(1,1), eUB(1,1)
        farrayTemp(i,j) = (-farrayPtr(i+2,j) + 8.*farrayPtr(i+1,j) &amp;
          - 8.*farrayPtr(i-1,j) + farrayPtr(i-2,j)) / (12.*a)
      enddo
    enddo
    farrayPtr(eLB(1,1):eUB(1,1), eLB(2,1):eUB(2,1)) = farrayTemp
  enddo
  
  deallocate(farrayTemp)
</PRE>

<P>
ESMF supports having multiple halo operations defined on the same Array
   object at the same time. Each operation can be accessed through its unique
   RouteHandle. The above kernel could have made <TT>ESMF_ArrayHalo()</TT> calls
   with a depth of 1 along the first dimension using the previously precomputed
   <TT>haloHandle</TT> if it needed to. Both RouteHandles need to release their
   resources when no longer used. 

<P>
<PRE>
  

  call ESMF_ArrayHaloRelease(routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHaloRelease(routehandle=haloHandle2, rc=rc)
</PRE>

<P>
Finally the Array and DistGrid objects can be destroyed. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050521500000000000000"></A>
   <A NAME="Array:ArbHalo"></A>
<BR>
24.2.15 Communication - Halo for arbitrary distribution
</H3>

<P>
In the previous section the Array <EM>halo</EM> operation was demonstrated 
   for regularly decomposed ESMF Arrays. However, the ESMF halo operation
   is not restricted to regular decompositions. The same Array halo methods
   apply unchanged to Arrays that are created on arbitrarily distributed
   DistGrids. This includes the non-blocking features discussed in section
   <A HREF="node5.html#Array:CommNB">24.2.19</A>.

<P>
All of the examples in this section are based on the same arbitrarily
   distributed DistGrid. Section <A HREF="node5.html#DistGrid:ArbitrarySeqInd">31.3.6</A> discusses
   DistGrids with user-supplied, arbitrary sequence indices in detail. Here
   a global index space range from 1 through 20 is decomposed across 4 DEs. 
   There are 4 PETs in this example with 1 DE per PET. Each PET constructs
   its local <TT>seqIndexList</TT> variable. 

<P>
<PRE>
  do i=1, 5
    seqIndexList(i) = localPet + (i - 1) * petCount + 1
  enddo
</PRE>

<P>
This results in the following cylic distribution scheme:
   <PRE>
   DE 0 on PET 0: seqIndexList = (/1, 5, 9, 13, 17/)
   DE 1 on PET 1: seqIndexList = (/2, 6, 10, 14, 18/)
   DE 2 on PET 2: seqIndexList = (/3, 7, 11, 15, 19/)
   DE 3 on PET 3: seqIndexList = (/4, 8, 12, 16, 20/)
</PRE>

<P>
The local <TT>arbIndexList</TT> variables are then used to create a
   DistGrid with the indicated arbitrary distribution pattern. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=seqIndexList, rc=rc)
</PRE>

<P>
The resulting DistGrid is one-dimensional, although the user code may
   interpret the sequence indices as a 1D map into a problem of higher
   dimensionality. 

<P>
In this example the local DE on each PET is associated with a 5 element
   exclusive region. Providing <TT>arbIndexList</TT> of different size on the
   different PETs is supported and would result in different number of
   exclusive elements on each PET.

<P>
Creating an ESMF Array on top of a DistGrid with arbitrary sequence indices
   is in principle no different from creating an Array on a regular DistGrid. 
   However, while an Array that was created on a regular DistGrid automatically
   inherits the index space topology information that is contained within the
   DistGrid object, there is no such topology information available for
   DistGrid objects with arbitrary sequence indices. As a consequence of
   this, Arrays created on arbitrary DistGrids do not automatically have
   the information that is required to associated halo elements with the
   exclusive elements across DEs. Instead the user must supply this information
   explicitly during Array creation.

<P>
Multiple ArrayCreate() interfaces exist that allow the creation of an Array
   on a DistGrid with arbitrary sequence indices, while supplying the sequence
   indices for the halo region of the local DE through an additional argument
   with dummy name <TT>haloSeqIndexList</TT>. As in the regular case the
   ArrayCreate() interfaces differ in the way that the memory allocations for
   the Array elements are passed into the call. The following code shows how 
   an ESMF Array can be wrapped around existing PET-local memory allocations.
   The allocations are of different size on each PET as to accommodate the correct
   number of local Array elements. 

<P>
<PRE>
  allocate(farrayPtr1d(5+localPet+1)) !use explicit Fortran allocate statement
  
  if (localPet==0) then
    array = ESMF_ArrayCreate(distgrid, farrayPtr1d, &amp;
      haloSeqIndexList=(/1/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array = ESMF_ArrayCreate(distgrid, farrayPtr1d, &amp;
      haloSeqIndexList=(/1,2/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array = ESMF_ArrayCreate(distgrid, farrayPtr1d, &amp;
      haloSeqIndexList=(/1,2,3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    array = ESMF_ArrayCreate(distgrid, farrayPtr1d, &amp;
      haloSeqIndexList=(/1,2,3,4/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
The <TT>haloSeqIndexList</TT> arguments are 1D arrays of sequence indices.
   It is through this argument that the user associates the halo elements with
   exclusive Array elements covered by the DistGrid. In this example there
   are different number of halo elements on each DE. They are associated
   with exclusive elements as follows:

<P>
<PRE>
   halo on DE 0 on PET 0: &lt;seqIndex=1&gt; first exclusive element on DE 0
   halo on DE 1 on PET 1: &lt;seqIndex=1&gt; first exclusive element on DE 0
                          &lt;seqIndex=2&gt; first exclusive element on DE 1
   halo on DE 2 on PET 2: &lt;seqIndex=1&gt; first exclusive element on DE 0
                          &lt;seqIndex=2&gt; first exclusive element on DE 1
                          &lt;seqIndex=3&gt; first exclusive element on DE 2
   halo on DE 3 on PET 3: &lt;seqIndex=1&gt; first exclusive element on DE 0
                          &lt;seqIndex=2&gt; first exclusive element on DE 1
                          &lt;seqIndex=3&gt; first exclusive element on DE 2
                          &lt;seqIndex=4&gt; first exclusive element on DE 3
</PRE>

<P>
The ArrayCreate() call checks that the provided Fortran memory allocation
   is correctly sized to hold the exclusive elements, as indicated by the
   DistGrid object, plus the halo elements as indicated by the local
   <TT>haloSeqIndexList</TT> argument. The size of the Fortran allocation must
   match exactly or a runtime error will be returned.

<P>
Analogous to the case of Arrays on regular DistGrids, it is the exclusive
   region of the local DE that is typically modified by the code running on 
   each PET. All of the ArrayCreate() calls that accept the
   <TT>haloSeqIndexList</TT> argument place the exclusive region at the beginning
   of the memory allocation on each DE and use the remaining space for the halo
   elements. The following loop demonstrates this by filling the exclusive 
   elements on each DE with initial values. Remember that in this example each 
   DE holds 5 exclusive elements associated with different arbitrary sequence 
   indices. 

<P>
<PRE>
  do i=1, 5
    farrayPtr1d(i) = seqIndexList(i) / 10.
  enddo
</PRE>

<P>
Now the exclusive elements of <TT>array</TT> are initialized on each DE, however,
   the halo elements remain unchanged. A RouteHandle can be set up that encodes
   the required communication pattern for a halo exchange. The halo exchange
   is precomputed according to the arbitrary sequence indices specified for the
   exclusive elements by the DistGrid and the sequence indices provided by the 
   user for each halo element on the local DE in form of the 
   <TT>haloSeqIndexList</TT> argument during ArrayCreate(). 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
Executing this halo operation will update the local halo elements according
   to the associated sequence indices. 

<P>
<PRE>
  call ESMF_ArrayHalo(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
As always it is good practice to release the RouteHandle when done with it. 

<P>
<PRE>
  call ESMF_ArrayHaloRelease(haloHandle, rc=rc)
</PRE>

<P>
Also the Array object should be destroyed when no longer needed. 

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
Further, since the memory allocation was done explicitly using the Fortran
   <TT>allocate()</TT> statement, it is necessary to explicitly deallocate in order
   to prevent memory leaks in the user application. 

<P>
<PRE>
  deallocate(farrayPtr1d)
</PRE>

<P>
Alternatively the exact same Array can be created where ESMF does the
   memory allocation and deallocation. In this case the <TT>typekind</TT> of the 
   Array must be specified explicitly. 

<P>
<PRE>
  if (localPet==0) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=(/1/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=(/1,2/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=(/1,2,3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=(/1,2,3,4/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
Use ArrayGet() to gain access to the local memory allocation. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr1d, rc=rc)
</PRE>

<P>
The returned Fortran pointer can now be used to initialize the exclusive
   elements on each DE as in the previous case. 

<P>
<PRE>
  do i=1, 5
    farrayPtr1d(i) = seqIndexList(i) / 10.
  enddo
</PRE>

<P>
Identical halo operations are constructed and used. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHalo(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHaloRelease(haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
A current limitation of the Array implementation restricts DistGrids that
   contain user-specified, arbitrary sequence indices to be exactly 1D
   when used to create Arrays. See section <A HREF="node5.html#Array:rest">24.3</A> for a list of 
   current implementation restrictions. However, an Array created on such a
   1D arbitrary DistGrid is allowed to have undistributed dimensions. The
   following example creates an Array on the same arbitrary DistGrid, with the
   same arbitrary sequence indices for the halo elements as before, but with
   one undistributed dimension with a size of 3. 

<P>
<PRE>
  if (localPet==0) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=(/1/), undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=(/1,2/), undistLBound=(/1/), undistUBound=(/3/), &amp;
      rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=(/1,2,3/), undistLBound=(/1/), undistUBound=(/3/), &amp;
      rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      haloSeqIndexList=(/1,2,3,4/), undistLBound=(/1/), undistUBound=(/3/), &amp;
      rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
By default the DistGrid dimension is mapped to the first Array dimension, 
   associating the remaining Array dimensions with the undistributed dimensions
   in sequence. The dimension order is important when accessing the individual
   Array elements. Here the same initialization as before is extended to 
   cover the undistributed dimension. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr2d, rc=rc)
</PRE>

<P>
<PRE>
  do j=1, 3
    do i=1, 5
      farrayPtr2d(i,j) = seqIndexList(i) / 10. + 100.*j
    enddo
  enddo
</PRE>

<P>
In the context of the Array halo operation additional undistributed dimensions
   are treated in a simple factorized manner. The same halo association between
   elements that is encoded in the 1D arbitrary sequence index scheme is
   applied to each undistributed element separately. This is completely 
   transparent on the user level and the same halo methods are used as before. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHalo(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHaloRelease(haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
In some situations it is more convenient to associate some or all of
   the undistributed dimensions with the first Array dimensions. This can be
   done easily by explicitly mapping the DistGrid dimension to an Array dimension
   other than the first one. The following code creates essentially the same 
   Array as before, but with swapped dimension order. 

<P>
<PRE>
  if (localPet==0) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=(/1/), &amp;
      undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=(/1,2/), &amp;
      undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=(/1,2,3/), &amp;
      undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    array = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=(/1,2,3,4/), &amp;
      undistLBound=(/1/), undistUBound=(/3/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
The swapped dimension order results in a swapping of <TT>i</TT> and <TT>j</TT> when
   accessing Array elements in the loop. 

<P>
<PRE>
  call ESMF_ArrayGet(array, farrayPtr=farrayPtr2d, rc=rc)
</PRE>

<P>
<PRE>
  do j=1, 3
    do i=1, 5
      farrayPtr2d(j,i) = seqIndexList(i) / 10. + 100.*j
    enddo
  enddo
</PRE>

<P>
Again there is no difference in how the the halo operations are applied. 

<P>
<PRE>
  call ESMF_ArrayHaloStore(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayHalo(array, routehandle=haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
One of the benefits of mapping the undistributed dimension(s) to the 
   "left side" of the Array dimensions is that Arrays that only differ 
   in the size of the undistributed dimension(s) are weakly congruent in this
   arrangement. Weakly congruent Arrays can reuse the same RouteHandle, saving
   the overhead that is caused by the precompute step. In order to demonstrate 
   this the RouteHandle of the previous halo call was not yet released and will
   be applied to a weakly congruent Array.

<P>
The following code creates an Array that is weakly congruent to the the 
   previous Array by using the same input information as before, only that
   the size of the undistributed dimension is now 6 instead of 3. 

<P>
<PRE>
  if (localPet==0) then
    array2 = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=(/1/), &amp;
      undistLBound=(/1/), undistUBound=(/6/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==1) then
    array2 = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=(/1,2/), &amp;
      undistLBound=(/1/), undistUBound=(/6/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==2) then
    array2 = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=(/1,2,3/), &amp;
      undistLBound=(/1/), undistUBound=(/6/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
  if (localPet==3) then
    array2 = ESMF_ArrayCreate(distgrid=distgrid, typekind=ESMF_TYPEKIND_R8, &amp;
      distgridToArrayMap=(/2/), haloSeqIndexList=(/1,2,3,4/), &amp;
      undistLBound=(/1/), undistUBound=(/6/), rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  endif
</PRE>

<P>
Again the exclusive Array elements must be initialized. 

<P>
<PRE>
  call ESMF_ArrayGet(array2, farrayPtr=farrayPtr2d, rc=rc)
</PRE>

<P>
<PRE>
  do j=1, 6
    do i=1, 5
      farrayPtr2d(j,i) = seqIndexList(i) / 10. + 100.*j
    enddo
  enddo
</PRE>

<P>
Now the <TT>haloHandle</TT> that was previously pre-computed for <TT>array</TT> can
   be used directly for the weakly congruent <TT>array2</TT>. 

<P>
<PRE>
  call ESMF_ArrayHalo(array2, routehandle=haloHandle, rc=rc)
</PRE>

<P>
Release the RouteHandle after its last use and clean up the remaining
   Array and DistGrid objects. 

<P>
<PRE>
  call ESMF_ArrayHaloRelease(haloHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayDestroy(array2, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050521600000000000000"></A>
   <A NAME="Array:Redist"></A>
<BR>
24.2.16 Communication - Redist
</H3>

<P>
Arrays used in different models often cover the same index space region,
   however, the distribution of the Arrays may be different, e.g. the models
   run on exclusive sets of PETs. Even if the Arrays are defined on the same
   list of PETs the decomposition may be different. 

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/4,1/), rc=rc)
</PRE>

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/1,4/), rc=rc)
</PRE>

<P>
The number of elements covered by <TT>srcDistgrid</TT> is identical to the number
   of elements covered by <TT>dstDistgrid</TT> - in fact the index space regions
   covered by both DistGrid objects are congruent. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>
By construction <TT>srcArray</TT> and <TT>dstArray</TT> are of identical type and
   kind. Further the number of exclusive elements matches between both Arrays.
   These are the prerequisites for the application of an Array redistribution
   in default mode. In order to increase performance of the actual 
   redistribution the communication patter must be precomputed and stored. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The <TT>redistHandle</TT> can now be used repeatedly on the <TT>srcArray</TT>, 
   <TT>dstArray</TT> pair to redistributed data from source to destination Array. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The use of the precomputed <TT>redistHandle</TT> is <EM>not</EM> restricted to
   <TT>srcArray</TT> and <TT>dstArray</TT>. The <TT>redistHandle</TT> can be used to
   redistribute data between any Array pairs that are weakly congruent to the
   Array pair used during precomputation. Arrays are congruent if they are
   defined on matching DistGrids and the shape of local array allocations match
   for all DEs. For weakly congruent Arrays the sizes of the undistributed
   dimensions, that vary faster with memory than the first distributed
   dimension, are permitted to be different. This means that the same
   <TT>redistHandle</TT> can be applied to a large class of similar Arrays that
   differ in the number of elements in the left most undistributed dimensions. 

<P>
Neither <TT>srcArray</TT> nor <TT>dstArray</TT> from above hold an undistributed
   dimension. However, the following <TT>srcArray1</TT> and <TT>dstArray1</TT> objects
   are constructed to have an undistributed dimension each, that varies fastest
   with memory. There is only one element in the undistributed dimension in each
   Array. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec3d, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
<PRE>
  srcArray1 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=srcDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/1/), rc=rc)
</PRE>

<P>
<PRE>
  dstArray1 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/1/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray1, dstArray=dstArray1, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The weak congruency feature permits the <TT>redistHandle</TT> to be used on Array
   pairs that have the same arrangement of distributed and undistributed
   dimensions, but where the first dimension is of different size, e.g. 10
   elements instead of 1. 

<P>
<PRE>
  srcArray2 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=srcDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
  dstArray2 = ESMF_ArrayCreate(arrayspec=arrayspec3d, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1/), undistUBound=(/10/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray2, dstArray=dstArray2, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
When done, the resources held by <TT>redistHandle</TT> need to be deallocated
   by the user code before the handle becomes inaccessible. 

<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=redistHandle, rc=rc)
</PRE>

<P>
In <EM>default</EM> mode, i.e. without providing the optional
   <TT>srcToDstTransposeMap</TT> argument, <TT>ESMF_ArrayRedistStore()</TT> does not
   require equal number of dimensions in source and destination Array. Only the
   total number of elements must match.

<P>
Specifying <TT>srcToDstTransposeMap</TT> switches <TT>ESMF_ArrayRedistStore()</TT>
   into <EM>transpose</EM> mode. In this mode each dimension of <TT>srcArray</TT>
   is uniquely associated with a dimension in <TT>dstArray</TT>. The sizes of 
   associated dimensions must match for each pair.

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/20,10/), &amp;
      rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>
This <TT>dstArray</TT> object covers a 20 x 10 index space while the
   <TT>srcArray</TT>, defined further up, covers a 10 x 20 index space. Setting
   <TT>srcToDstTransposeMap = (/2,1/)</TT> will associate the first and second 
   dimension of <TT>srcArray</TT> with the second and first dimension of
   <TT>dstArray</TT>, respectively. This corresponds to a transpose of dimensions.
   Since the decomposition and distribution of dimensions may be different for
   source and destination redistribution may occur at the same time. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/2,1/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The transpose mode of <TT>ESMF_ArrayRedist()</TT> is not limited to
   distributed dimensions of Arrays. The <TT>srcToDstTransposeMap</TT> argument
   can be used to transpose undistributed dimensions in the same manner.
   Furthermore transposing distributed and undistributed dimensions between
   Arrays is also supported.

<P>
The <TT>srcArray</TT> used in the following examples is of rank 4 with 2 
   distributed and 2 undistributed dimensions. The distributed dimensions
   are the two first dimensions of the Array and are distributed according to the
   <TT>srcDistgrid</TT> which describes a total index space region of 100 x 200
   elements. The last two Array dimensions are undistributed dimensions of size
   2 and 3, respectively. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=4, rc=rc)
</PRE>

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/2,3/), rc=rc)
</PRE>

<P>
The first <TT>dstArray</TT> to consider is defined on a DistGrid that also 
   describes a 100 x 200 index space region. The distribution indicated
   by <TT>dstDistgrid</TT> may be different from the source distribution. Again
   the first two Array dimensions are associated with the DistGrid dimensions in
   sequence. Furthermore, the last two Array dimensions are undistributed
   dimensions, however, the sizes are 3 and 2, respectively. 

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/100,200/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/3,2/), rc=rc)
</PRE>

<P>
The desired mapping between <TT>srcArray</TT> and <TT>dstArray</TT> dimensions
   is expressed by <TT>srcToDstTransposeMap = (/1,2,4,3/)</TT>, transposing only
   the two undistributed dimensions. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/1,2,4,3/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Next consider a <TT>dstArray</TT> that is defined on the same <TT>dstDistgrid</TT>,
   but with a different order of Array dimensions. The desired order is
   specified during Array creation using the argument 
   <TT>distgridToArrayMap = (/2,3/)</TT>. This map associates the first and second
   DistGrid dimensions with the second and third Array dimensions, respectively,
   leaving Array dimensions one and four undistributed. 

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1,1/), undistUBound=(/3,2/), &amp;
    rc=rc)
</PRE>

<P>
Again the sizes of the undistributed dimensions are chosen in reverse order
   compared to <TT>srcArray</TT>. The desired transpose mapping in this case will
   be <TT>srcToDstTransposeMap = (/2,3,4,1/)</TT>. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/2,3,4,1/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Finally consider the case where <TT>dstArray</TT> is constructed on a 
   200 x 3 index space and where the undistributed dimensions are of size
   100 and 2. 

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/200,3/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/100,2/), rc=rc)
</PRE>

<P>
By construction <TT>srcArray</TT> and <TT>dstArray</TT> hold the same number of
   elements, albeit in a very different layout. Nevertheless, with a
   <TT>srcToDstTransposeMap</TT> that maps matching dimensions from source to
   destination an Array redistribution becomes a well defined operation between
   <TT>srcArray</TT> and <TT>dstArray</TT>. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, srcToDstTransposeMap=(/3,1,4,2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The default mode of Array redistribution, i.e. without providing a
   <TT>srcToDstTransposeMap</TT> to <TT>ESMF_ArrayRedistStore()</TT>, also supports
   undistributed Array dimensions. The requirement in this case is that the 
   total undistributed element count, i.e. the product of the sizes of all
   undistributed dimensions, be the same for source and destination Array.
   In this mode the number of undistributed dimensions need not match between
   source and destination.

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=4, rc=rc)
</PRE>

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/4,1/), rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    undistLBound=(/1,1/), undistUBound=(/2,4/), rc=rc)
</PRE>

<P>
<PRE>
  dstDistgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/10,20/), &amp;
    regDecomp=(/1,4/), rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2,3/), undistLBound=(/1,1/), undistUBound=(/2,4/), &amp;
    rc=rc)
</PRE>

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> have two undistributed dimensions and
   a total count of undistributed elements of <!-- MATH
 $2 \times 4 = 8$
 -->
<IMG
 WIDTH="71" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img52.png"
 ALT="$ 2 \times 4 = 8$">.

<P>
The Array redistribution operation is defined in terms of sequentialized
   undistributed dimensions. In the above case this means that a unique sequence
   index will be assigned to each of the 8 undistributed elements. The sequence
   indices will be 1, 2, ..., 8, where sequence index 1 is assigned to the first
   element in the first (i.e. fastest varying in memory) undistributed dimension.
   The following undistributed elements are labeled in consecutive order as they
   are stored in memory. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
The redistribution operation by default applies the identity operation between
   the elements of undistributed dimensions. This means that source element with
   sequence index 1 will be mapped against destination element with sequence
   index 1 and so forth. Because of the way source and destination Arrays
   in the current example were constructed this corresponds to a mapping of
   dimensions 3 and 4 on <TT>srcArray</TT> to dimensions 1 and 4 on <TT>dstArray</TT>,
   respectively. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
Array redistribution does <EM>not</EM> require the same number of undistributed
   dimensions in source and destination Array, merely the total number of
   undistributed elements must match. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
</PRE>

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/1,3/), undistLBound=(/11/), undistUBound=(/18/), &amp;
    rc=rc)
</PRE>

<P>
This <TT>dstArray</TT> object only has a single undistributed dimension, while
   the <TT>srcArray</TT>, defined further back, has two undistributed dimensions.
   However, the total undistributed element count for both Arrays is 8. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>
In this case the default identity operation between the elements of
   undistributed dimensions corresponds to a <EM>merging</EM> of dimensions
   3 and 4 on <TT>srcArray</TT> into dimension 2 on <TT>dstArray</TT>. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=redistHandle, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050521700000000000000"></A>
   <A NAME="Array:SparseMatMul"></A>
<BR>
24.2.17 Communication - SparseMatMul
</H3>

<P>
Sparse matrix multiplication is a fundamental Array communication method. One
   frequently used application of this method is the interpolation between pairs
   of Arrays. The principle is this: the value of each element in the exclusive 
   region of the destination Array is expressed as a linear combination of <EM>   potentially all</EM> the exclusive elements of the source Array. Naturally most of
   the coefficients of these linear combinations will be zero and it is more 
   efficient to store explicit information about the non-zero elements than to 
   keep track of all the coefficients.

<P>
There is a choice to be made with respect to the format in which to store the
   information about the non-zero elements. One option is to store the value
   of each coefficient together with the corresponding destination element index
   and source element index. Destination and source indices could be expressed in
   terms of the corresponding DistGrid tile index together with the coordinate
   tuple within the tile. While this format may be the most natural way to
   express elements in the source and destination Array, it has two major drawbacks.
   First the coordinate tuple is <TT>dimCount</TT> specific and second the format
   is extremely bulky. For 2D source and destination Arrays it would require 6
   integers to store the source and destination element information for each
   non-zero coefficient and matters get worse for higher dimensions.

<P>
Both problems can be circumvented by <EM>interpreting</EM> source and destination
   Arrays as sequentialized strings or <EM>vectors</EM> of elements. This is done
   by assigning a unique <EM>sequence index</EM> to each exclusive element in both
   Arrays. With that the operation of updating the elements in the destination Array
   as linear combinations of source Array elements takes the form of a <EM>sparse
   matrix multiplication</EM>.

<P>
The default sequence index rule assigns index <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="$1$"> to the <TT>minIndex</TT> corner
   element of the first tile of the DistGrid on which the Array is defined. It then
   increments the sequence index by <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="$1$"> for each element running through the
   DistGrid dimensions by order. The index space position of the DistGrid tiles
   does not affect the sequence labeling of elements. The default sequence indices
   for 

<P>
<PRE>
  srcDistgrid = ESMF_DistGridCreate(minIndex=(/-1,0/), maxIndex=(/1,3/), rc=rc)
</PRE>

<P>
for each element are:
   <PRE>
     -------------------------------------&gt; 2nd dim
     |
     |   +------+------+------+------+
     |   |(-1,0)|      |      |(-1,3)|
     |   |      |      |      |      |
     |   |   1  |   4  |   7  |  10  |
     |   +------+------+------+------+
     |   |      |      |      |      |
     |   |      |      |      |      |
     |   |   2  |   5  |   8  |  11  |
     |   +------+------+------+------+
     |   | (1,0)|      |      | (1,3)|
     |   |      |      |      |      |
     |   |   3  |   6  |   9  |  12  |
     |   +------+------+------+------+
     |
     v
    1st dim
</PRE>

<P>
The assigned sequence indices are decomposition and distribution invariant by
   construction. Furthermore, when an Array is created with extra elements per DE on
   a DistGrid the sequence indices (which only cover the exclusive elements) remain
   unchanged. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
</PRE>

<P>
<PRE>
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    rc=rc)
</PRE>

<P>
The extra padding of 1 element in each direction around the exclusive elements on
   each DE are "invisible" to the Array spare matrix multiplication method. These
   extra elements are either updated by the computational kernel or by Array halo
   operations (not yet implemented!).

<P>
An alternative way to assign sequence indices to all the elements in the tiles
   covered by a DistGrid object is to use a special <TT>ESMF_DistGridCreate()</TT>
   call. This call has been specifically designed for 1D cases with arbitrary,
   user-supplied sequence indices. 

<P>
<PRE>
  seqIndexList(1) = localPet*10
  seqIndexList(2) = localPet*10 + 1
  dstDistgrid = ESMF_DistGridCreate(arbSeqIndexList=seqIndexList, rc=rc)
</PRE>

<P>
This call to <TT>ESMF_DistGridCreate()</TT> is collective across the current VM.
   The <TT>arbSeqIndexList</TT> argument specifies the PET-local arbitrary sequence
   indices that need to be covered by the local DE. The resulting DistGrid has
   one local DE per PET which covers the entire PET-local index range. The user
   supplied sequence indices must be unique, but the sequence may be interrupted.
   The four DEs of <TT>dstDistgrid</TT> have the following local 1D index space
   coordinates (given between "()") and sequence indices:
   <PRE>
    covered by DE 0    covered by DE 1   covered by DE 2   covered by DE 3
    on PET 0           on PET 1          on PET 2          on PET 3
    ----------------------------------------------------------------------
    (1) : 0            (1) : 10          (1) : 20          (1) : 30
    (2) : 1            (2) : 11          (2) : 21          (2) : 31
</PRE>

<P>
Again the DistGrid object provides the sequence index labeling for the
   exclusive elements of an Array created on the DistGrid regardless of extra,
   non-exclusive elements. 

<P>
<PRE>
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, rc=rc)
</PRE>

<P>
With the definition of sequence indices, either by the default rule or as user
   provided arbitrary sequence indices, it is now possible to uniquely identify
   each exclusive element in the source and destination Array by a single integer
   number. Specifying a pair of source and destination elements takes two integer
   number regardless of the number of dimensions.

<P>
The information required to carry out a sparse matrix multiplication are the
   pair of source and destination sequence indices and the associated
   multiplication factor for each pair. ESMF requires this information in form of
   two Fortran arrays. The factors are stored in a 1D array of the appropriate
   type and kind, e.g. <TT>real(ESMF_KIND_R8)::factorList(:)</TT>. Array sparse
   matrix multiplications are supported between Arrays of different type and
   kind. The type and kind of the factors can also be chosen freely. The 
   sequence index pairs associated with the factors provided by <TT>factorList</TT> 
   are stored in a 2D Fortran array of default integer kind of the shape <TT>   integer::factorIndexList(2,:)</TT>. The sequence indices of the source Array elements
   are stored in the first row of <TT>   factorIndexList</TT> while the sequence indices of the destination Array elements are
   stored in the second row.

<P>
Each PET in the current VM must call into <TT>ESMF_ArraySMMStore()</TT>
   to precompute and store the communication pattern for the sparse matrix
   multiplication. The multiplication factors may be provided in parallel, i.e.
   multiple PETs may specify <TT>factorList</TT> and <TT>factorIndexList</TT> arguments
   when calling into <TT>ESMF_ArraySMMStore()</TT>. PETs that do not
   provide factors either call with <TT>factorList</TT> and <TT>factorIndexList</TT>
   arguments containing zero elements or issue the call omitting both arguments. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(2,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/30/)         ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(2,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/11, 11, 30/) ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)
      
  endif
</PRE>

<P>
The RouteHandle object <TT>sparseMatMulHandle</TT> produced by 
   <TT>ESMF_ArraySMMStore()</TT> can now be used to call <TT>   ESMF_ArraySMM()</TT> collectively across all PETs of the current VM to
   perform
   <PRE>
     dstArray = 0.0
     do n=1, size(combinedFactorList)
         dstArray(combinedFactorIndexList(2, n)) += 
           combinedFactorList(n) * srcArray(combinedFactorIndexList(1, n))
     enddo
</PRE>
   in parallel. Here <TT>combinedFactorList</TT> and <TT>combinedFactorIndexList</TT>
   are the combined lists defined by the respective local lists provided by 
   PETs 0 and 1 in parallel. For this example 

<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
will initialize the entire <TT>dstArray</TT> to 0.0 and then update two elements:

<P>
<PRE>
   on DE 1:
   dstArray(2) = 0.5 * srcArray(0,0)  +  0.5 * srcArray(0,2)
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray(1) = 0.2 * srcArray(0,1)  +  0.8 * srcArray(1,3).
</PRE>

<P>
The call to <TT>ESMF_ArraySMM()</TT> does provide the option to turn
   the default <TT>dstArray</TT> initialization off. If argument <TT>zeroregion</TT>
   is set to <TT>ESMF_REGION_EMPTY</TT> 

<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, zeroregion=ESMF_REGION_EMPTY, rc=rc)
</PRE>

<P>
skips the initialization and elements in <TT>dstArray</TT> are updated according to:

<P>
<PRE>
     do n=1, size(combinedFactorList)
         dstArray(combinedFactorIndexList(2, n)) += 
           combinedFactorList(n) * srcArray(combinedFactorIndexList(1, n)).
     enddo
</PRE>

<P>
The <TT>ESMF_RouteHandle</TT> object returned by <TT>ESMF_ArraySMMStore()</TT>
   can be applied to any src/dst Array pairs that are weakly congurent to the
   Array pair used during precomputation. Arrays are congruent if they are
   defined on matching DistGrids and the shape of local array allocations match
   for all DEs. For weakly congruent Arrays the sizes of the undistributed
   dimensions, that vary faster with memory than the first distributed
   dimension, are permitted to be different. See section <A HREF="node5.html#Array:Redist">24.2.16</A>
   for an example of this feature demonstrated for the Redist case. The exact
   same principle applies to the SMM case.

<P>
The resources held by <TT>sparseMatMulHandle</TT> need to be deallocated by the
   user code before the handle becomes inaccessible. 

<P>
<PRE>
  call ESMF_ArraySMMRelease(routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
The Array sparse matrix multiplication also applies to Arrays with
   undistributed dimensions. The undistributed dimensions are interpreted
   in a sequentialized manner, much like the distributed dimensions,
   introducing a second sequence index for source and destination elements.
   Sequence index 1 is assigned to the first element in the first 
   (i.e. fastest varying in memory) undistributed dimension. The following
   undistributed elements are labeled in consecutive order as they are stored in
   memory.

<P>
In the simplest case the Array sparse matrix multiplication will apply an
   identity matrix to the vector of sequentialized undistributed Array elements
   for every non-zero element in the sparse matrix. The requirement in this case
   is that the total undistributed element count, i.e. the product of the sizes 
   of all undistributed dimensions, be the same for source and destination Array. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    distgridToArrayMap=(/1,2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
Setting up <TT>factorList</TT> and <TT>factorIndexList</TT> is identical to the 
   case for Arrays without undistributed dimensions. Also the call to 
   <TT>ESMF_ArraySMMStore()</TT> remains unchanged. Internally, however,
   the source and destination Arrays are checked to make sure the total
   undistributed element count matches. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(2,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/30/)         ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(2,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/11, 11, 30/) ! seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)  
  endif
</PRE>

<P>
The call into the <TT>ESMF_ArraySMM()</TT> operation is completely
   transparent with respect to whether source and/or destination Arrays contain
   undistributed dimensions. 

<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
This operation will initialize the entire <TT>dstArray</TT> to 0.0 and then 
   update four elements:

<P>
<PRE>
   on DE 1:
   dstArray[1](2) = 0.5 * srcArray(0,0)[1]  +  0.5 * srcArray(0,2)[1],
   dstArray[2](2) = 0.5 * srcArray(0,0)[2]  +  0.5 * srcArray(0,2)[2]
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray[1](1) = 0.2 * srcArray(0,1)[1]  +  0.8 * srcArray(1,3)[1],
   dstArray[2](1) = 0.2 * srcArray(0,1)[2]  +  0.8 * srcArray(1,3)[2].
</PRE>

<P>
Here indices between "()" refer to distributed dimensions while indices
   between "[]" correspond to undistributed dimensions. 

<P>
In a more general version of the Array sparse matrix multiplication the
   total undistributed element count, i.e. the product of the sizes 
   of all undistributed dimensions, need not be the same for source and
   destination Array. In this formulation each non-zero element of the sparse
   matrix is identified with a unique element in the source and destination
   Array. This requires a generalization of the <TT>factorIndexList</TT> argument
   which now must contain four integer numbers for each element. These numbers
   in sequence are the sequence index of the distributed dimensions and the
   sequence index of the undistributed dimensions of the element in the source
   Array, followed by the sequence index of the distributed dimensions and
   the sequence index of the undistributed dimensions of the element in the
   destination Array. 

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=3, rc=rc)
  srcArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=srcDistgrid, &amp;
    totalLWidth=(/1,1/), totalUWidth=(/1,1/), indexflag=ESMF_INDEX_GLOBAL, &amp;
    distgridToArrayMap=(/1,2/), undistLBound=(/1/), undistUBound=(/2/), rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_R8, rank=2, rc=rc)
  dstArray = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=dstDistgrid, &amp;
    distgridToArrayMap=(/2/), undistLBound=(/1/), undistUBound=(/4/), rc=rc)
</PRE>

<P>
Setting up <TT>factorList</TT> is identical to the previous cases since there is
   still only one value associated with each non-zero matrix element. However,
   each entry in <TT>factorIndexList</TT> now has 4 instead of just 2 components. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(factorList(1))               ! PET 0 specifies 1 factor
    allocate(factorIndexList(4,1))
    factorList = (/0.2/)                  ! factors
    factorIndexList(1,:) = (/5/)          ! seq indices into srcArray
    factorIndexList(2,:) = (/1/)          ! undistr. seq indices into srcArray
    factorIndexList(3,:) = (/30/)         ! seq indices into dstArray
    factorIndexList(4,:) = (/2/)          ! undistr. seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else if (localPet == 1) then
    allocate(factorList(3))               ! PET 1 specifies 3 factor
    allocate(factorIndexList(4,3))
    factorList = (/0.5, 0.5, 0.8/)        ! factors
    factorIndexList(1,:) = (/8, 2, 12/)   ! seq indices into srcArray
    factorIndexList(2,:) = (/2, 1, 1/)    ! undistr. seq indices into srcArray
    factorIndexList(3,:) = (/11, 11, 30/) ! seq indices into dstArray
    factorIndexList(4,:) = (/4, 4, 2/)    ! undistr. seq indices into dstArray
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, factorList=factorList, &amp;
      factorIndexList=factorIndexList, rc=rc)
      
    deallocate(factorList)
    deallocate(factorIndexList)
  else
    ! PETs 2 and 3 do not provide factors
    
    call ESMF_ArraySMMStore(srcArray=srcArray, dstArray=dstArray, &amp;
      routehandle=sparseMatMulHandle, rc=rc)  
  endif
</PRE>

<P>
The call into the <TT>ESMF_ArraySMM()</TT> operation remains
   unchanged. 

<P>
<PRE>
  call ESMF_ArraySMM(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=sparseMatMulHandle, rc=rc)
</PRE>

<P>
This operation will initialize the entire <TT>dstArray</TT> to 0.0 and then 
   update two elements:

<P>
<PRE>
   on DE 1:
   dstArray[4](2) = 0.5 * srcArray(0,0)[1]  +  0.5 * srcArray(0,2)[2],
</PRE>

<P>
and

<P>
<PRE>
   on DE 3:
   dstArray[2](1) = 0.2 * srcArray(0,1)[1]  +  0.8 * srcArray(1,3)[1],
</PRE>

<P>
Here indices in <IMG
 WIDTH="18" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img54.png"
 ALT="$()$"> refer to distributed dimensions while indices in <IMG
 WIDTH="15" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img55.png"
 ALT="$[]$">
   correspond to undistributed dimensions.

<P>

<P>

<P>

<H3><A NAME="SECTION050521800000000000000"></A>
   <A NAME="Array:ScatterGatherRevisited"></A>
<BR>
24.2.18 Communication - Scatter and Gather, revisited
</H3>

<P>
The <TT>ESMF_ArrayScatter()</TT> and <TT>ESMF_ArrayGather()</TT> calls, 
   introduced in section <A HREF="node5.html#Array:ScatterGather">24.2.13</A>, provide a convenient
   way of communicating data between a Fortran array and all of the DEs of
   a single Array tile. A key requirement of <TT>ESMF_ArrayScatter()</TT>
   and <TT>ESMF_ArrayGather()</TT> is that the <EM>shape</EM> of the Fortran array
   and the Array tile must match. This means that the <TT>dimCount</TT> must be
   equal, and that the size of each dimension must match. Element reordering
   during scatter and gather is only supported on a per dimension level,
   based on the <TT>decompflag</TT> option available during DistGrid creation.

<P>
While the <TT>ESMF_ArrayScatter()</TT> and <TT>ESMF_ArrayGather()</TT> methods
   cover a broad, and important spectrum of cases, there are situations that
   require a different set of rules to scatter and gather data between a
   Fortran array and an ESMF Array object. For instance, it is often convenient
   to create an Array on a DistGrid that was created with arbitrary,
   user-supplied sequence indices. See section <A HREF="node5.html#DistGrid:ArbitrarySeqInd">31.3.6</A>
   for more background on DistGrids with arbitrary sequence indices. 

<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet+1 ! initialize unique 
                                                     ! seq. indices
  enddo
  
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arbSeqIndexList)
  
  call ESMF_ArraySpecSet(arrayspec, typekind=ESMF_TYPEKIND_I4, rank=1, rc=rc)
</PRE>

<P>
<PRE>
  array = ESMF_ArrayCreate(arrayspec=arrayspec, distgrid=distgrid, rc=rc)
</PRE>

<P>
This <TT>array</TT> object holds 10 elements on each DE, and there is one DE
   per PET, for a total element count of 10 x <TT>petCount</TT>. The
   <TT>arbSeqIndexList</TT>, used during DistGrid creation, was constructed cyclic
   across all DEs. DE 0, for example, on a 4 PET run, would hold sequence
   indices 1, 5, 9, ... . DE 1 would hold 2, 6, 10, ..., and so on.

<P>
The usefulness of the user-specified arbitrary sequence indices becomes
   clear when they are interpreted as global element ids. The ArrayRedist()
   and ArraySMM() communication methods are based on sequence index mapping
   between source and destination Arrays. Other than providing a canonical
   sequence index order via the default sequence scheme, outlined in
   <A HREF="node5.html#Array:SparseMatMul">24.2.17</A>, ESMF does not place any restrictions on the
   sequence indices. Objects that were not created with user supplied
   sequence indices default to the ESMF sequence index order.

<P>
A common, and useful interpretation of the arbitrary sequence indices, 
   specified during DistGrid creation, is that of relating them to the 
   canonical ESMF sequence index order of another data object. Within this
   interpretation the <TT>array</TT> object created above could be viewed as an
   arbitrary distribution of a (<TT>petCount</TT> x 10) 2D array. 

<P>
<PRE>
  if (localPet == 0) then
    allocate(farray(petCount,10)) ! allocate 2D Fortran array petCount x 10
    do j=1, 10
      do i=1, petCount
        farray(i,j) = 100 + (j-1)*petCount + i    ! initialize to something
      enddo
    enddo
  else
    allocate(farray(0,0)) ! must allocate an array of size 0 on all other PETs
  endif
</PRE>

<P>
For a 4 PET run, <TT>farray</TT> on PET 0 now holds the following data.
   <PRE>
     -----1----2----3------------10-----&gt; j
     |
     1   101, 105, 109, ....  , 137
     |
     2   102, 106, 110, ....  , 138
     |
     3   103, 107, 111, ....  , 139
     |
     4   104, 108, 112, ....  , 140
     |
     |
     v
    i
</PRE>

<P>
On all other PETs <TT>farray</TT> has a zero size allocation.

<P>
Following the sequence index interpretation from above, scattering the data
   contained in <TT>farray</TT> on PET 0 across the <TT>array</TT> object created
   further up, seems like a well defined operation. Looking at it a bit closer,
   it becomes clear that it is in fact more of a redistribution than a simple
   scatter operation. The general rule for such a "redist-scatter"  operation,
   of a Fortran array, located on a single PET, into an ESMF Array, is to 
   use the canonical ESMF sequence index scheme to label the elements of the
   Fortran array, and to send the data to the Array element with the same
   sequence index.

<P>
The just described "redist-scatter" operation is much more general than
   the standard <TT>ESMF_ArrayScatter()</TT> method. It does not require shape
   matching, and supports full element reordering based on the sequence indices.
   Before <TT>farray</TT> can be scattered across <TT>array</TT> in the described way,
   it must be wrapped into an ESMF Array object itself, essentially labeling the
   array elements according to the canonical sequence index scheme.

<P>
<PRE>
  distgridAux = ESMF_DistGridCreate(minIndex=(/1,1/), &amp;
    maxIndex=(/petCount,10/), &amp;
    regDecomp=(/1,1/), rc=rc) ! DistGrid with only 1 DE
</PRE>

<P>
The first step is to create a DistGrid object with only a single DE. This
   DE must be located on the PET on which the Fortran data array resides.
   In this example <TT>farray</TT> holds data on PET 0, which is where the default
   DELayout will place the single DE defined in the DistGrid. If the <TT>farray</TT>
   was setup on a different PET, an explicit DELayout would need to be created
   first, mapping the only DE to the PET on which the data is defined.

<P>
Next the Array wrapper object can be created from the <TT>farray</TT> and the
   just created DistGrid object. 

<P>
<PRE>
  arrayAux = ESMF_ArrayCreate(farray=farray, distgrid=distgridAux, &amp;
    indexflag=ESMF_INDEX_DELOCAL, rc=rc)
</PRE>

<P>
At this point all of the pieces are in place to use <TT>ESMF_ArrayRedist()</TT>
   to do the "redist-scatter" operation. The typical store/execute/release
   pattern must be followed. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=arrayAux, dstArray=array, &amp;
    routehandle=scatterHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=arrayAux, dstArray=array, &amp;
    routehandle=scatterHandle, rc=rc)
</PRE>

<P>
In this example, after <TT>ESMF_ArrayRedist()</TT> was called, the content
   of <TT>array</TT> on a 4 PET run would look like this:
   <PRE>
    PET 0:   101, 105, 109, ....  , 137
    PET 1:   102, 106, 110, ....  , 138
    PET 2:   103, 107, 111, ....  , 139
    PET 3:   104, 108, 112, ....  , 140
</PRE>

<P>
Once set up, <TT>scatterHandle</TT> can be used repeatedly to scatter data
   from <TT>farray</TT> on PET 0 to all the DEs of <TT>array</TT>. All of the
   resources should be released once <TT>scatterHandle</TT> is no longer needed. 

<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=scatterHandle, rc=rc)
</PRE>

<P>
The opposite operation, i.e. <EM>gathering</EM> of the <TT>array</TT> data
   into <TT>farray</TT> on PET 0, follows a very similar setup. In fact, the
   <TT>arrayAux</TT> object already constructed for the scatter direction, can
   directly be re-used. The only thing that is different for the "redist-gather",
   are the <TT>srcArray</TT> and <TT>dstArray</TT> argument assignments, reflecting
   the opposite direction of data movement. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=array, dstArray=arrayAux, &amp;
    routehandle=gatherHandle, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=array, dstArray=arrayAux, &amp;
    routehandle=gatherHandle, rc=rc)
</PRE>

<P>
Just as for the scatter case, the <TT>gatherHandle</TT> can be used repeatedly
   to gather data from <TT>array</TT> into <TT>farray</TT> on PET 0. All of the
   resources should be released once <TT>gatherHandle</TT> is no longer needed. 

<P>
<PRE>
  call ESMF_ArrayRedistRelease(routehandle=gatherHandle, rc=rc)
</PRE>

<P>
Finally the wrapper Array <TT>arrayAux</TT> and the associated DistGrid object
   can also be destroyed. 

<P>
<PRE>
  call ESMF_ArrayDestroy(arrayAux, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgridAux, rc=rc)
</PRE>

<P>
Further, the primary data objects of this example must be deallocated
   and destroyed. 

<P>
<PRE>
  deallocate(farray)
  
  call ESMF_ArrayDestroy(array, rc=rc)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050521900000000000000"></A>
   <A NAME="Array:CommNB"></A>
<BR>
24.2.19 Non-blocking Communications
</H3>

<P>
All <TT>ESMF_RouteHandle</TT> based communcation methods, like 
   <TT>ESMF_ArrayRedist()</TT>, <TT>ESMF_ArrayHalo()</TT> and <TT>ESMF_ArraySMM()</TT>, 
   can be executed in blocking or non-blocking mode. The non-blocking feature is
   useful, for example, to overlap computation with communication, or to
   implement a more loosely synchronized inter-Component interaction scheme than
   is possible with the blocking communication mode.

<P>
Access to the non-blocking execution mode is provided uniformly across all
   RouteHandle based communication calls. Every such call contains the optional
   <TT>routesyncflag</TT> argument of type <TT>ESMF_RouteSync_Flag</TT>. Section
   <A HREF="node2.html#const:routesync">9.38</A> lists all of the valid settings for this flag.

<P>
It is an execution time decision to select whether to invoke a precomputed
   communication pattern, stored in a RouteHandle, in the blocking or
   non-blocking mode. Neither requires specifically precomputed RouteHandles
   - i.e. a RouteHandle is neither specifically blocking nor specifically
   non-blocking. 

<P>
<PRE>
  call ESMF_ArrayRedistStore(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, rc=rc)
</PRE>

<P>
The returned RouteHandle <TT>routehandle</TT> can be used in blocking or 
   non-blocking execution calls. The application is free to switch between
   both modes for the same RouteHandle.

<P>
By default <TT>routesyncflag</TT> is set to <TT>ESMF_ROUTESYNC_BLOCKING</TT> in all of the
   RouteHandle execution methods, and the behavior is that of the VM-wide
   collective communication calls described in the previous sections. In the
   blocking mode the user must assume that the communication call will not
   return until all PETs have exchanged the precomputed information. On the
   other hand, the user has no guarante about the exact synchronization 
   behavior, and it is unsafe to make specific assumtions. What is guaranteed
   in the blocking communication mode is that when the call returns on the
   local PET, all data exchanges associated with all local DEs have finished.
   This means that all in-bound data elements are valid and that all out-bound
   data elements can safely be overwritten by the user. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, routesyncflag=ESMF_ROUTESYNC_BLOCKING, rc=rc)
</PRE>

<P>
The same exchange pattern, that is encoded in <TT>routehandle</TT>, can be 
   executed in non-blocking mode, simply by setting the appropriate
   <TT>routesyncflag</TT> when calling into <TT>ESMF_ArrayRedist()</TT>.

<P>
At first sight there are obvious similarities between the non-blocking
   RouteHandle based execution paradigm and the non-blocking message passing
   calls provided by MPI. However, there are significant differences in
   the behavior of the non-blocking point-to-point calls that MPI defines and
   the non-blocking mode of the collective exchange patterns described by ESMF
   RouteHandles.

<P>
Setting <TT>routesyncflag</TT> to <TT>ESMF_ROUTESYNC_NBSTART</TT> in any RouteHandle
   execution call returns immediatly after all out-bound data has been moved
   into ESMF internal transfer buffers and the exchange has been initiated. 

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, routesyncflag=ESMF_ROUTESYNC_NBSTART, rc=rc)
</PRE>

<P>
Once a call with <TT>routesyncflag = ESMF_ROUTESYNC_NBSTART</TT> returns, it is safe
   to modify the out-bound data elements in the <TT>srcArray</TT> object. However,
   no guarantees are made for the in-bound data elements in <TT>dstArray</TT> at
   this phase of the non-blocking execution. It is unsafe to access these
   elements until the exchange has finished locally.

<P>
One way to ensure that the exchange has finished locally is to call 
   with <TT>routesyncflag</TT> set to <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT>.

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, routesyncflag=ESMF_ROUTESYNC_NBWAITFINISH, rc=rc)
</PRE>

<P>
Calling with <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT> instructs the
   communication method to wait and block until the previously started
   exchange has finished, and has been processed locally according to 
   the RouteHandle. Once the call returns, it is safe to access both in-bound
   and out-bound data elements in <TT>dstArray</TT> and <TT>srcArray</TT>, 
   respectively.

<P>
Some situations require more flexibility than is provided by the 
   <TT>ESMF_ROUTESYNC_NBSTART</TT> - <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> pair. For
   instance, a Component that needs to interact with several other Components,
   virtually simultanously, would initiated several different exchanges with 
   <TT>ESMF_ROUTESYNC_NBSTART</TT>. Calling with <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> for
   any of the outstanding exchanges may potentially block for a long time, 
   lowering the throughput. In the worst case a dead lock situation may arrise.
   Calling with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT> addresses this problem.

<P>
<PRE>
  call ESMF_ArrayRedist(srcArray=srcArray, dstArray=dstArray, &amp;
    routehandle=routehandle, routesyncflag=ESMF_ROUTESYNC_NBTESTFINISH, &amp;
    finishedflag=finishflag, rc=rc)
</PRE>

<P>
This call tests the locally outstanding data transfer operation in 
   <TT>routehandle</TT>, and finishes the exchange as much as currently possible.
   It does not block until the entire exchange has finished locally, instead
   it returns immediatly after one round of testing has been
   completed. The optional return argument <TT>finishedflag</TT> is set to 
   <TT>.true.</TT> if the exchange is completely finished locally, and set to 
   <TT>.false.</TT> otherwise.

<P>
The user code must decide, depending on the value of the returned
   <TT>finishedflag</TT>, whether additional calls are required to finish an
   outstanding non-blocking exchange. If so, it can be done by 
   calling <TT>ESMF_ArrayRedist()</TT> repeatly with 
   <TT>ESMF_ROUTESYNC_NBTESTFINISH</TT> until 
   <TT>finishedflag</TT> comes back with a value of <TT>.true.</TT>. Such a loop
   allows other pieces of user code to be executed between the calls. 
   A call with <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> can alternatively be used to
   block until the exchange has locally finished.

<P>
<EM>Noteworthy property.</EM>
   It is allowable to invoke a RouteHandle based communication call
   with <TT>routesyncflag</TT> set to 
   <TT>ESMF_ROUTESYNC_NBTESTFINISH</TT> or
   <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT> on a specific RouteHandle without there 
   being an outstanding non-blocking exchange. As a matter of fact, it is not
   required that there was ever a call made with <TT>ESMF_ROUTESYNC_NBSTART</TT> for
   the RouteHandle. In these cases the calls made with
   <TT>ESMF_ROUTESYNC_NBTESTFINISH</TT> or <TT>ESMF_ROUTESYNC_NBWAITFINISH</TT>  will
   simply return immediately (with <TT>finishedflag</TT> set to <TT>.true.</TT>).

<P>
<EM>Noteworthy property.</EM>
   It is fine to mix blocking and non-blocking invokations of the same 
   RouteHandle based communication call across the PETs. This means that it is
   fine for some PETs to issue the call with <TT>ESMF_ROUTESYNC_BLOCKING</TT>
   (or using the default), while other PETs call the same communication call
   with <TT>ESMF_ROUTESYNC_NBSTART</TT>.

<P>
<EM>Noteworthy restriction.</EM>
   A RouteHandle that is currently involved in an outstanding non-blocking
   exchange may <EM>not</EM> be used to start any further exchanges, neither
   blocking nor non-blocking. This restriction is independent of whether the
   newly started RouteHandle based exchange is made for the same or for 
   different data objects.

<P>

<P>

<H2><A NAME="SECTION05053000000000000000">
24.3 Restrictions and Future Work</A>
</H2>

<P>

<A NAME="Array:rest"></A>

<UL>
<LI><B>CAUTION:</B> Depending on the specific <TT>ESMF_ArrayCreate()</TT> entry point used during Array creation, certain Fortran operations are not supported on the Fortran array pointer <TT>farrayPtr</TT>, returned by <TT>ESMF_ArrayGet()</TT>. Only if the <TT>ESMF_ArrayCreate()</TT> <EM>from pointer</EM> variant was used, will the returned <TT>farrayPtr</TT> variable contain the original bounds information, and be suitable for the Fortran <TT>deallocate()</TT> call. This limitation is a direct consequence of the Fortran 95 standard relating to the passing of array arguments. Fortran array pointers returned from an Array that was created through the <EM>assumed shape array</EM> variant of <TT>ESMF_ArrayCreate()</TT> will have bounds that are consistent with the other arguments specified during Array creation. These pointers are not suitable for deallocation in accordance to the Fortran 95 standard.

<P>
</LI>
<LI><B>1D limit:</B> ArrayHalo(), ArrayRedist() and ArraySMM() operations on Arrays created on DistGrids with arbitrary sequence indices are currently limited to 1D arbitrary DistGrids. There is no restriction on the number, size
and mapping of undistributed Array dimensions in the presence of such a 1D
arbitrary DistGrid.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION05054000000000000000">
24.4 Design and Implementation Notes</A>
</H2>

<P>
The Array class is part of the ESMF index space layer and is built ontop of the DistGrid and DELayout classes. The DELayout class introduces the notion of 
<EM>decomposition elements</EM> (DEs) and their layout across the available PETs. The DistGrid describes how index space is decomposed by assigning <EM>logically rectangular index space pieces</EM> or <EM>DE-local tiles</EM> to the DEs. The Array finally associates a <EM>local memory allocation</EM> with each local DE.

<P>
The following is a list of implementation specific details about the current ESMF Array.

<P>

<UL>
<LI>Implementation language is C++.
</LI>
<LI>Local memory allocations are internally held in <TT>ESMF_LocalArray</TT>
objects.
</LI>
<LI>All precomputed communication methods are based on sparse matrix
multiplication.
</LI>
</UL>

<P>

<H2><A NAME="SECTION05055000000000000000">
24.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05055100000000000000">
24.5.1 ESMF_ArrayAssignment(=) - Array assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface assignment(=)
   array1 = array2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array) :: array1
   type(ESMF_Array) :: array2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign array1 as an alias to the same ESMF Array object in memory
   as array2. If array2 is invalid, then array1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>array1</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>array2</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055200000000000000">
24.5.2 ESMF_ArrayOperator(==) - Array equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
   if (array1 == array2) then ... endif
   OR
   result = (array1 == array2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array1
   type(ESMF_Array), intent(in) :: array2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether array1 and array2 are valid aliases to the same ESMF
   Array object in memory. For a more general comparison of two ESMF Arrays,
   going beyond the simple alias test, the ESMF_ArrayMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>array1</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>array2</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055300000000000000">
24.5.3 ESMF_ArrayOperator(/=) - Array not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
   if (array1 /= array2) then ... endif
   OR
   result = (array1 /= array2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array1
   type(ESMF_Array), intent(in) :: array2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether array1 and array2 are <I>not</I> valid aliases to the
   same ESMF Array object in memory. For a more general comparison of two ESMF
   Arrays, going beyond the simple alias test, the ESMF_ArrayMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>array1</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>array2</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055400000000000000">
24.5.4 ESMF_ArrayCreate - Create Array object from Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateFromPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(distgrid, farrayPtr, &amp; 
   datacopyflag, distgridToArrayMap, computationalEdgeLWidth, &amp; 
   computationalEdgeUWidth, computationalLWidth, &amp; 
   computationalUWidth, totalLWidth, &amp; 
   totalUWidth, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateDataPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing local native Fortran 
   arrays with pointer attribute, according to distgrid. Besides 
   <TT>farrayPtr</TT> each PET must issue this call with identical arguments in 
   order to create a consistent Array object. The bounds of the local arrays 
   are preserved by this call and determine the bounds of the total region of 
   the resulting Array object. Bounds of the DE-local exclusive regions are 
   set to be consistent with the total regions and the specified distgrid 
   argument. Bounds for Array dimensions that are not distributed are 
   automatically set to the bounds provided by <TT>farrayPtr</TT>. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. By default all tensor elements are associated with 
   stagger location 0. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Valid native Fortran array with pointer attribute. Memory must be 
   associated with the actual argument. The type/kind/rank information of 
   <TT>farrayPtr</TT> will be used to set <TT>Array</TT>'s properties 
   accordingly. The shape of <TT>farrayPtr</TT> will be checked against the 
   information contained in the <TT>distgrid</TT>. The bounds of 
   <TT>farrayPtr</TT> will be preserved by this call and the bounds of the 
   resulting Array object are set accordingly. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farrayPtr</TT> directly or will copy the data from 
   <TT>farrayPtr</TT> into a new memory allocation. Valid options are 
   <TT>ESMF_DATACOPY_REFERENCE</TT> (default) or <TT>ESMF_DATACOPY_VALUE</TT>. 
   Depending on the specific situation the <TT>ESMF_DATACOPY_REFERENCE</TT> option 
   may be unsafe when specifying an array slice for <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farrayPtr</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farrayPtr</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farrayPtr</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the computational region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the computational region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the <TT>farrayPtr</TT> argument. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05055500000000000000">
24.5.5 ESMF_ArrayCreate - Create Array object from Fortran array pointer w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateFromPtrArb&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(distgrid, farrayPtr, &amp; 
   haloSeqIndexList, keywordEnforcer datacopyflag, distgridToArrayMap, &amp; 
   name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   integer, intent(in) :: haloSeqIndexList(:) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateDataPtrArb&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing local native Fortran 
   arrays with pointer attribute, according to distgrid. Besides 
   <TT>farrayPtr</TT> each PET must issue this call with identical arguments in 
   order to create a consistent Array object. The bounds of the local arrays 
   are preserved by this call and determine the bounds of the total region of 
   the resulting Array object. Bounds of the DE-local exclusive regions are 
   set to be consistent with the total regions and the specified distgrid 
   argument. Bounds for Array dimensions that are not distributed are 
   automatically set to the bounds provided by <TT>farrayPtr</TT>. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. By default all tensor elements are associated with 
   stagger location 0. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Valid native Fortran array with pointer attribute. Memory must be 
   associated with the actual argument. The type/kind/rank information of 
   <TT>farrayPtr</TT> will be used to set <TT>Array</TT>'s properties 
   accordingly. The shape of <TT>farrayPtr</TT> will be checked against the 
   information contained in the <TT>distgrid</TT>. The bounds of 
   <TT>farrayPtr</TT> will be preserved by this call and the bounds of the 
   resulting Array object are set accordingly. 
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region. 
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will) 
   be different on each PET. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farrayPtr</TT> directly or will copy the data from 
   <TT>farrayPtr</TT> into a new memory allocation. Valid options are 
   <TT>ESMF_DATACOPY_REFERENCE</TT> (default) or <TT>ESMF_DATACOPY_VALUE</TT>. 
   Depending on the specific situation the <TT>ESMF_DATACOPY_REFERENCE</TT> option 
   may be unsafe when specifying an array slice for <TT>farrayPtr</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farrayPtr</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farrayPtr</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farrayPtr</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05055600000000000000">
24.5.6 ESMF_ArrayCreate - Create Array object from Fortran array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate() 
   function ESMF_ArrayCreateAssmdShape&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(distgrid, farray, &amp; 
   indexflag, datacopyflag, distgridToArrayMap, &amp; 
   computationalEdgeLWidth, computationalEdgeUWidth, computationalLWidth, &amp; 
   computationalUWidth, totalLWidth, &amp; 
   totalUWidth, undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_DistGrid), intent(in) :: distgrid 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   type(ESMF_Index_Flag), intent(in) :: indexflag 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: distgridToArrayMap(:) 
   integer, intent(in), optional :: computationalEdgeLWidth(:) 
   integer, intent(in), optional :: computationalEdgeUWidth(:) 
   integer, intent(in), optional :: computationalLWidth(:) 
   integer, intent(in), optional :: computationalUWidth(:) 
   integer, intent(in), optional :: totalLWidth(:) 
   integer, intent(in), optional :: totalUWidth(:) 
   integer, intent(in), optional :: undistLBound(:) 
   integer, intent(in), optional :: undistUBound(:) 
   character (len=*), intent(in), optional :: name 
   integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_Array) :: ESMF_ArrayCreateDataAssmdShape&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from an existing local native Fortran 
   array according to distgrid. Besides <TT>farray</TT> each PET must issue this 
   call with identical arguments in order to create a consistent Array object. 
   The local arrays provided must be dimensioned according to the DE-local 
   total region. Bounds of the exclusive regions are set as specified in the 
   distgrid argument. Bounds for Array dimensions that are not distributed can 
   be chosen freely using the <TT>undistLBound</TT> and <TT>undistUBound</TT> 
   arguments. 

<P>
This interface requires a 1 DE per PET decomposition. The Array object will 
   not be created and an error will be returned if this condition is not met. 

<P>
The not distributed Array dimensions form a tensor of rank = array.rank - 
   distgrid.dimCount. By default all tensor elements are associated with 
   stagger location 0. The widths of the computational region are set to 
   the provided value, or zero by default, for all tensor elements. Use 
   <TT>ESMF_ArraySet()</TT> to change these default settings after the 
   Array object has been created. 

<P>
The return value is the newly created <TT>ESMF_Array</TT> object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and 
   distributed over DEs. The dimCount of distgrid must be smaller or equal 
   to the rank of farray. 
   
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
   actual argument. The type/kind/rank information of <TT>farray</TT> will be 
   used to set <TT>Array</TT>'s properties accordingly. The shape of 
   <TT>farray</TT> will be checked against the information contained in the 
   <TT>distgrid</TT>. 
   
</DD>
<DT><STRONG>indexflag</STRONG></DT>
<DD>Indicate how DE-local indices are defined. See section 
   <A HREF="node2.html#const:indexflag">9.24</A> for a list of valid indexflag options. 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
   provided by <TT>farray</TT> directly or will copy the data from 
   <TT>farray</TT> into a new memory allocation. Valid options are 
   <TT>ESMF_DATACOPY_REFERENCE</TT> (default) or <TT>ESMF_DATACOPY_VALUE</TT>. 
   Depending on the specific situation the <TT>ESMF_DATACOPY_REFERENCE</TT> option 
   may be unsafe when specifying an array slice for <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by 
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of 
   the DistGrid object to a dimension in <TT>farray</TT> by specifying the 
   appropriate Array dimension index. The default is to map all of 
   <TT>distgrid</TT>'s dimensions against the lower dimensions of the 
   <TT>farray</TT> argument in sequence, i.e. <TT>distgridToArrayMap = 
   (/1, 2, .../)</TT>. 
   Unmapped <TT>farray</TT> dimensions are not decomposed dimensions and 
   form a tensor of rank = Array.rank - DistGrid.dimCount. 
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal 
   to zero and smaller than or equal to the Array rank. It is erroneous 
   to specify the same entry multiple times unless it is zero. 
   If the Array rank is less than the DistGrid dimCount then the default 
   distgridToArrayMap will contain zeros for the dimCount - rank 
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT> 
   indicates that the particular DistGrid dimension will be replicating 
   the Array across the DEs along this direction. 
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region for DEs 
   that are located on the edge of a tile. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the computational 
   region with respect to the lower corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the computational 
   region with respect to the upper corner of the exclusive region. 
   The default is a zero vector. 
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the lower corner of the total memory 
   region with respect to the lower corner of the computational region. 
   The default is to accommodate the union of exclusive and computational 
   region exactly. 
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is 
   specified in distgrid. It specifies the upper corner of the total memory 
   region with respect to the upper corner of the computational region. 
   The default is a vector that contains the remaining number of elements 
   in each direction as to fit the union of exclusive and computational 
   region into the memory region provided by the <TT>farray</TT> argument. 
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed. 
   By default lbound is 1. 
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed. 
   By default ubound is equal to the extent of the corresponding 
   dimension in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05055700000000000000">
24.5.7 ESMF_ArrayCreate - Create Array object from a list of LocalArray objects</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateLocalArray(distgrid, localarrayList, &amp;
     indexflag, datacopyflag, distgridToArrayMap, computationalEdgeLWidth, &amp;
     computationalEdgeUWidth, computationalLWidth, computationalUWidth, &amp;
     totalLWidth, totalUWidth, undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_LocalArray), intent(in) :: localarrayList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateLocalArray
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing <TT>ESMF_LocalArray</TT>
   objects according to distgrid. Besides <TT>localarrayList</TT> each PET must issue
   this call with identical arguments in order to create a consistent Array
   object. The local arrays provided must be dimensioned according to the
   DE-local total region. Bounds of the exclusive regions are set as specified
   in the distgrid argument. Bounds for array dimensions that are not distributed
   can be chosen freely using the <TT>undistLBound</TT> and <TT>undistUBound</TT>
   arguments.

<P>
This interface is able to handle multiple DEs per PET.

<P>
The not distributed Array dimensions form a tensor of rank = array.rank -
   distgrid.dimCount. By default all tensor elements are associated with
   stagger location 0. The widths of the computational region are set to
   the provided value, or zero by default, for all tensor elements. Use
   <TT>ESMF_ArraySet()</TT> to change these default settings after the
   Array object has been created.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>localarrayList</STRONG></DT>
<DD>List of valid <TT>ESMF_LocalArray</TT> objects, i.e. memory must be
   associated with the actual arguments. The type/kind/rank information of
   all <TT>localarrayList</TT> elements must be identical and will
   be used to set <TT>Array</TT>'s properties accordingly. The shape of each
   <TT>localarrayList</TT> element will be checked against the information
   contained in the <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node2.html#const:indexflag">9.24</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation
   provided by <TT>farray</TT> directly or will copy the data from
   <TT>farray</TT> into a new memory allocation. Valid options are
   <TT>ESMF_DATACOPY_REFERENCE</TT> (default) or <TT>ESMF_DATACOPY_VALUE</TT>.
   Depending on the specific situation the <TT>ESMF_DATACOPY_REFERENCE</TT> option
   may be unsafe when specifying an array slice for <TT>farray</TT>.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the <TT>localarrayList</TT> elements
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the <TT>localarrayList</TT> elements in sequence, i.e.
   <TT>distgridToArrayMap = (/1, 2, .../)</TT>.
   Unmapped dimensions in the <TT>localarrayList</TT> elements are not
   decomposed dimensions and form a tensor of
   rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the computational region.
   The default is to accommodate the union of exclusive and computational
   region exactly.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the exclusive region.
   The default is a vector that contains the remaining number of elements
   in each direction as to fit the union of exclusive and computational
   region into the memory region provided by the <TT>localarrayList</TT> argument.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   By default lbound is 1.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   By default ubound is equal to the extent of the corresponding
   dimension in <TT>localarrayList</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055800000000000000">
24.5.8 ESMF_ArrayCreate - Create Array object from a list of LocalArray objects w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateLocalArrayArb(distgrid, localarrayList, &amp;
     haloSeqIndexList, datacopyflag, distgridToArrayMap, undistLBound, &amp;
     undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_LocalArray), intent(in) :: localarrayList(:)
        integer, intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateLocalArrayArb
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object from existing <TT>ESMF_LocalArray</TT>
   objects according to distgrid. Each PET must issue this call in unison
   in order to create a consistent Array object. The local arrays provided must
   be dimensioned according to the DE-local total region. Bounds of the
   exclusive regions are set as specified in the distgrid argument. Bounds
   for array dimensions that are not distributed can be chosen freely using
   the <TT>undistLBound</TT> and <TT>undistUBound</TT> arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>localarrayList</STRONG></DT>
<DD>List of valid <TT>ESMF_LocalArray</TT> objects, i.e. memory must be
   associated with the actual arguments. The type/kind/rank information of
   all <TT>localarrayList</TT> elements must be identical and will
   be used to set <TT>Array</TT>'s properties accordingly. The shape of each
   <TT>localarrayList</TT> element will be checked against the information
   contained in the <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region.
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will)
   be different on each PET.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation
   provided by <TT>farray</TT> directly or will copy the data from
   <TT>farray</TT> into a new memory allocation. Valid options are
   <TT>ESMF_DATACOPY_REFERENCE</TT> (default) or <TT>ESMF_DATACOPY_VALUE</TT>.
   Depending on the specific situation the <TT>ESMF_DATACOPY_REFERENCE</TT> option
   may be unsafe when specifying an array slice for <TT>farray</TT>.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the <TT>localarrayList</TT> elements
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the <TT>localarrayList</TT> elements in sequence, i.e.
   <TT>distgridToArrayMap = (/1, 2, .../)</TT>.
   Unmapped dimensions in the <TT>localarrayList</TT> elements are not
   decomposed dimensions and form a tensor of
   rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   By default lbound is 1.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   By default ubound is equal to the extent of the corresponding
   dimension in <TT>localarrayList</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05055900000000000000">
24.5.9 ESMF_ArrayCreate - Create Array object from typekind (allocate memory)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocate(distgrid, typekind, indexflag, &amp;
     distgridToArrayMap, computationalEdgeLWidth, computationalEdgeUWidth, &amp;
     computationalLWidth, computationalUWidth, totalLWidth, totalUWidth, &amp;
     undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_TypeKind_Flag), intent(in) :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateAllocate
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to typekind and distgrid. The Array rank is indirectly determined
   by the incoming information. Each PET must issue this call in unison in order
   to create a consistent Array object. DE-local allocations are made according
   to the total region defined by the <TT>distgrid</TT> and the optional <TT>Width</TT>
   arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Array.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node2.html#const:indexflag">9.24</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. <TT>distgridToArrayMap =
   (/1, 2, .../)</TT>.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the computational region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the computational region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551000000000000000">
24.5.10 ESMF_ArrayCreate - Create Array object from typekind (allocate memory) w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateArb(distgrid, typekind, &amp;
     haloSeqIndexList, distgridToArrayMap, &amp;
     undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_TypeKind_Flag), intent(in) :: typekind
        integer, intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateAllocateArb
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to typekind and distgrid. The Array rank is indirectly determined
   by the incoming information. Each PET must issue this call in unison in order
   to create a consistent Array object. DE-local allocations are made according
   to the total region defined by the <TT>distgrid</TT> and <TT>haloSeqIndexList</TT>
   arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>The typekind of the Array.
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region.
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will)
   be different on each PET.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. <TT>distgridToArrayMap =
   (/1, 2, .../)</TT>.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551100000000000000">
24.5.11 ESMF_ArrayCreate - Create Array object from ArraySpec (allocate memory)</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateAS(distgrid, arrayspec, indexflag, &amp;
     distgridToArrayMap, computationalEdgeLWidth, computationalEdgeUWidth, &amp;
     computationalLWidth, computationalUWidth, totalLWidth, totalUWidth, &amp;
     undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_Index_Flag), intent(in), optional :: indexflag
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: computationalEdgeLWidth(:)
        integer, intent(in), optional :: computationalEdgeUWidth(:)
        integer, intent(in), optional :: computationalLWidth(:)
        integer, intent(in), optional :: computationalUWidth(:)
        integer, intent(in), optional :: totalLWidth(:)
        integer, intent(in), optional :: totalUWidth(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateAllocateAS
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to arrayspec and distgrid. Each PET must issue
   this call with identical arguments in order to create a consistent Array
   object. DE-local allocations are made according to the total region defined
   by the arguments to this call: <TT>distgrid</TT> and the optional <TT>Width</TT>
   arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicate how DE-local indices are defined. By default, the exclusive
   region of each DE is placed to start at the local index space origin,
   i.e. (1, 1, ..., 1). Alternatively the DE-local index space can be
   aligned with the global index space, if a global index space is well
   defined by the associated DistGrid. See section <A HREF="node2.html#const:indexflag">9.24</A>
   for a list of valid indexflag options.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. <TT>distgridToArrayMap =
   (/1, 2, .../)</TT>.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[computationalEdgeLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalEdgeUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region for DEs
   that are located on the edge of a tile.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the computational
   region with respect to the lower corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the computational
   region with respect to the upper corner of the exclusive region.
   The default is a zero vector.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the lower corner of the total memory
   region with respect to the lower corner of the computational region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>This vector argument must have dimCount elements, where dimCount is
   specified in distgrid. It specifies the upper corner of the total memory
   region with respect to the upper corner of the computational region.
   The default is to accommodate the union of exclusive and computational
   region.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551200000000000000">
24.5.12 ESMF_ArrayCreate - Create Array object from ArraySpec (allocate memory) w/ arbitrary seqIndices for halo</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateAllocateASArb(distgrid, arrayspec, &amp;
     haloSeqIndexList, distgridToArrayMap, &amp;
     undistLBound, undistUBound, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid), intent(in) :: distgrid
        type(ESMF_ArraySpec), intent(in) :: arrayspec
        integer, intent(in) :: haloSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer, intent(in), optional :: distgridToArrayMap(:)
        integer, intent(in), optional :: undistLBound(:)
        integer, intent(in), optional :: undistUBound(:)
        character (len=*), intent(in), optional :: name
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateAllocateASArb
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object and allocate uninitialized data space
   according to arrayspec and distgrid. Each PET must issue this call in unison
   in order to create a consistent Array object. DE-local allocations are made
   according to the total region defined by the arguments to this call:
   <TT>distgrid</TT> and <TT>haloSeqIndexList</TT> arguments.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
   distributed over DEs. The dimCount of distgrid must be smaller or equal
   to the rank specified in arrayspec, otherwise a runtime ESMF error will be
   raised.
   
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information.
   
</DD>
<DT><STRONG>haloSeqIndexList</STRONG></DT>
<DD>One dimensional array containing sequence indices of local halo region.
   The size (and content) of <TT>haloSeqIndexList</TT> can (and typically will)
   be different on each PET.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>List that contains as many elements as is indicated by
   <TT>distgrids</TT>'s dimCount. The list elements map each dimension of
   the DistGrid object to a dimension in the newly allocated Array object
   by specifying the appropriate Array dimension index. The default is
   to map all of <TT>distgrid</TT>'s dimensions against the lower dimensions
   of the Array object in sequence, i.e. <TT>distgridToArrayMap =
   (/1, 2, .../)</TT>.
   Unmapped dimensions in the Array object are not decomposed dimensions
   and form a tensor of rank = Array.rank - DistGrid.dimCount.
   All <TT>distgridToArrayMap</TT> entries must be greater than or equal
   to zero and smaller than or equal to the Array rank. It is erroneous
   to specify the same entry multiple times unless it is zero.
   If the Array rank is less than the DistGrid dimCount then the default
   distgridToArrayMap will contain zeros for the dimCount - rank
   rightmost entries. A zero entry in the <TT>distgridToArrayMap</TT>
   indicates that the particular DistGrid dimension will be replicating
   the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Lower bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upper bounds for the array dimensions that are not distributed.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551300000000000000">
24.5.13 ESMF_ArrayCreate - Create Array object as copy of existing Array object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayCreate()
   function ESMF_ArrayCreateCopy(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Array) :: ESMF_ArrayCreateCopy
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Array</TT> object as the copy of an existing Array.

<P>
The return value is the newly created <TT>ESMF_Array</TT> object.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object to be copied.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551400000000000000">
24.5.14 ESMF_ArrayDestroy - Release resources associated with an Array object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayDestroy(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(inout) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMF_Array</TT>, releasing the resources associated with
   the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050551500000000000000">
24.5.15 ESMF_ArrayGather - Gather a Fortran array from an ESMF_Array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayGather(array, farray, rootPet, tile, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array 
   &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(out), target :: farray(&lt;rank&gt;) 
   integer, intent(in) :: rootPet 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: tile 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gather the data of an ESMF_Array object into the <TT>farray</TT> located on 
   <TT>rootPET</TT>. A single DistGrid tile of <TT>array</TT> must be 
   gathered into <TT>farray</TT>. The optional <TT>tile</TT> 
   argument allows selection of the tile. For Arrays defined on a single 
   tile DistGrid the default selection (tile 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the tile in Array. 

<P>
If the Array contains replicating DistGrid dimensions data will be 
   gathered from the numerically higher DEs. Replicated data elements in 
   numericaly lower DEs will be ignored. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object from which data will be gathered. 
   
</DD>
<DT><STRONG>{farray}</STRONG></DT>
<DD>The Fortran array into which to gather data. Only root 
   must provide a valid <TT>farray</TT>, the other PETs may treat 
   <TT>farray</TT> as an optional argument. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid destination array, i.e. <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The DistGrid tile in <TT>array</TT> from which to gather <TT>farray</TT>. 
   By default <TT>farray</TT> will be gathered from tile 1. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050551600000000000000">
24.5.16 ESMF_ArrayGet - Access to Array internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetDefault(array, arrayspec, typekind, &amp;
     rank, localarrayList, indexflag, distgridToArrayMap, &amp;
     distgridToPackedArrayMap, arrayToDistGridMap, undistLBound, &amp;
     undistUBound, exclusiveLBound, exclusiveUBound, computationalLBound, &amp;
     computationalUBound, totalLBound, totalUBound, computationalLWidth, &amp;
     computationalUWidth, totalLWidth, totalUWidth, distgrid, dimCount, &amp;
     tileCount, minIndexPTile, maxIndexPTile, deToTileMap, indexCountPDe, &amp;
     delayout, deCount, localDeCount, localDeList, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_ArraySpec), intent(out), optional :: arrayspec
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer, intent(out), optional :: rank
     type(ESMF_LocalArray), target, intent(out), optional :: localarrayList(:)
     type(ESMF_Index_Flag), intent(out), optional :: indexflag
     integer, target, intent(out), optional :: distgridToArrayMap(:)
     integer, target, intent(out), optional :: distgridToPackedArrayMap(:)
     integer, target, intent(out), optional :: arrayToDistGridMap(:)
     integer, target, intent(out), optional :: undistLBound(:)
     integer, target, intent(out), optional :: undistUBound(:)
     integer, target, intent(out), optional :: exclusiveLBound(:,:)
     integer, target, intent(out), optional :: exclusiveUBound(:,:)
     integer, target, intent(out), optional :: computationalLBound(:,:)
     integer, target, intent(out), optional :: computationalUBound(:,:)
     integer, target, intent(out), optional :: totalLBound(:,:)
     integer, target, intent(out), optional :: totalUBound(:,:)
     integer, target, intent(out), optional :: computationalLWidth(:,:)
     integer, target, intent(out), optional :: computationalUWidth(:,:)
     integer, target, intent(out), optional :: totalLWidth(:,:)
     integer, target, intent(out), optional :: totalUWidth(:,:)
     type(ESMF_DistGrid), intent(out), optional :: distgrid
     integer, intent(out), optional :: dimCount
     integer, intent(out), optional :: tileCount
     integer, intent(out), optional :: minIndexPTile(:,:)
     integer, intent(out), optional :: maxIndexPTile(:,:)
     integer, intent(out), optional :: deToTileMap(:)
     integer, intent(out), optional :: indexCountPDe(:,:)
     type(ESMF_DELayout), intent(out), optional :: delayout
     integer, intent(out), optional :: deCount
     integer, intent(out), optional :: localDeCount
     integer, intent(out), optional :: localDeList(:)
     character(len=*), intent(out), optional :: name
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal information.

<P>
This interface works for any number of DEs per PET.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[arrayspec]</STRONG></DT>
<DD><TT>ESMF_ArraySpec</TT> object containing the type/kind/rank information
   of the Array object.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind of the Array object.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Rank of the Array object.
   
</DD>
<DT><STRONG>[localarrayList]</STRONG></DT>
<DD>Upon return this holds a list of the associated <TT>ESMC_LocalArray</TT>
   objects. <TT>localarrayList</TT> must be allocated to be of size
   <TT>localDeCount</TT>, i.e. the number of DEs associated with the calling
   PET.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Upon return this flag indicates how the DE-local indices are defined.
   See section <A HREF="node2.html#const:indexflag">9.24</A> for a list of possible return values.
   
</DD>
<DT><STRONG>[distgridToArrayMap]</STRONG></DT>
<DD>Upon return this list holds the Array dimensions against which the
   DistGrid dimensions are mapped. <TT>distgridToArrayMap</TT> must be allocated
   to be of size <TT>dimCount</TT>. An entry of zero indicates that the
   respective DistGrid dimension is replicating the Array across the DEs
   along this direction.
   
</DD>
<DT><STRONG>[distgridToPackedArrayMap]</STRONG></DT>
<DD>Upon return this list holds the indices of the Array dimensions in packed
   format against which the DistGrid dimensions are mapped.
   <TT>distgridToPackedArrayMap</TT> must be allocated to be of size
   <TT>dimCount</TT>. An entry of zero indicates that the respective DistGrid
   dimension is replicating the Array across the DEs along this direction.
   
</DD>
<DT><STRONG>[arrayToDistGridMap]</STRONG></DT>
<DD>Upon return this list holds the DistGrid dimensions against which the
   Array dimensions are mapped. <TT>arrayToDistGridMap</TT> must be allocated
   to be of size <TT>rank</TT>. An entry of zero indicates that the respective
   Array dimension is not decomposed, rendering it a tensor dimension.
   
</DD>
<DT><STRONG>[undistLBound]</STRONG></DT>
<DD>Upon return this array holds the lower bounds of the undistributed
   dimensions of the Array. <TT>UndistLBound</TT> must be allocated to be
   of size <TT>rank-dimCount</TT>.

</DD>
<DT><STRONG>[undistUBound]</STRONG></DT>
<DD>Upon return this array holds the upper bounds of the undistributed
   dimensions of the Array. <TT>UndistUBound</TT> must be allocated to be
   of size <TT>rank-dimCount</TT>.

</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive regions for
   all PET-local DEs. <TT>exclusiveLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.

</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive regions for
   all PET-local DEs. <TT>exclusiveUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.

</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational regions for
   all PET-local DEs. <TT>computationalLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational regions for
   all PET-local DEs. <TT>computationalUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total regions for
   all PET-local DEs. <TT>totalLBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total regions for
   all PET-local DEs. <TT>totalUBound</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>Upon return this holds the lower width of the computational regions for
   all PET-local DEs. <TT>computationalLWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>Upon return this holds the upper width of the computational regions for
   all PET-local DEs. <TT>computationalUWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.
   
</DD>
<DT><STRONG>[totalLWidth]</STRONG></DT>
<DD>Upon return this holds the lower width of the total memory regions for
   all PET-local DEs. <TT>totalLWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.

</DD>
<DT><STRONG>[totalUWidth]</STRONG></DT>
<DD>Upon return this holds the upper width of the total memory regions for
   all PET-local DEs. <TT>totalUWidth</TT> must be allocated to be
   of size <TT>(dimCount, localDeCount)</TT>.

</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>Upon return this holds the associated <TT>ESMF_DistGrid</TT> object.
   
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of dimensions (rank) of <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[tileCount]</STRONG></DT>
<DD>Number of tiles in <TT>distgrid</TT>.
   
</DD>
<DT><STRONG>[minIndexPTile]</STRONG></DT>
<DD>Lower index space corner per <TT>dim</TT>, per <TT>tile</TT>, with
   <TT>size(minIndexPTile) == (/dimCount, tileCount/)</TT>.
   
</DD>
<DT><STRONG>[maxIndexPTile]</STRONG></DT>
<DD>Upper index space corner per <TT>dim</TT>, per <TT>tile</TT>, with
   <TT>size(maxIndexPTile) == (/dimCount, tileCount/)</TT>.
   
</DD>
<DT><STRONG>[deToTileMap]</STRONG></DT>
<DD>List of tile id numbers, one for each DE, with
   <TT>size(deToTileMap) == (/deCount/)</TT>
   
</DD>
<DT><STRONG>[indexCountPDe]</STRONG></DT>
<DD>Array of extents per <TT>dim</TT>, per <TT>de</TT>, with
   <TT>size(indexCountPDe) == (/dimCount, deCount/)</TT>.

</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Upon return this holds the associated <TT>ESMF_DELayout</TT> object.
   
</DD>
<DT><STRONG>[deCount]</STRONG></DT>
<DD>Upon return this holds the total number of DEs defined in the DELayout
   associated with the Array object.
   
</DD>
<DT><STRONG>[localDeCount]</STRONG></DT>
<DD>Upon return this holds the number of PET-local DEs defined in the
   DELayout associated with the Array object.
   
</DD>
<DT><STRONG>[localDeList]</STRONG></DT>
<DD>Upon return this holds the list of DE ids for the PET-local
   DEs defined in the DELayout associated with the Array object.
   The provided argument must be of size <TT>localDeCount</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the Array object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551700000000000000">
24.5.17 ESMF_ArrayGet - Access to Array internals per dim per local DE</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetPLocalDePDim(array, dim, localDe, &amp;
     indexCount, indexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
     integer, intent(in) :: dim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: localDe
     integer, intent(out), optional :: indexCount
     integer, intent(out), optional :: indexList(:)
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal information per local DE, per dim.

<P>
This interface works for any number of DEs per PET.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension for which information is requested. <TT>[1,..,dimCount]</TT>
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>[indexCount]</STRONG></DT>
<DD>DistGrid indexCount associated with <TT>localDe, dim</TT>.
   
</DD>
<DT><STRONG>[indexList]</STRONG></DT>
<DD>List of DistGrid tile-local indices for <TT>localDe</TT> along dimension
   <TT>dim</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050551800000000000000">
24.5.18 ESMF_ArrayGet - Access to PET-local Array tile via Fortran array pointer </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet() 
   subroutine ESMF_ArrayGetFPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(array, localDe, &amp; 
   farrayPtr, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(in) :: array 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: localDe 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Access Fortran array pointer to the specified DE-local memory allocation of 
   the Array object. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object. 
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>. 
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted, 
   in which case it will default to <TT>localDe=0</TT>. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>Upon return, <TT>farrayPtr</TT> points to the DE-local data allocation of 
   <TT>localDe</TT> in <TT>array</TT>. It depends on the specific entry point 
   of <TT>ESMF_ArrayCreate()</TT> used during <TT>array</TT> creation, which 
   Fortran operations are supported on the returned <TT>farrayPtr</TT>. See 
   <A HREF="node5.html#Array:rest">24.3</A> for more details. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050551900000000000000">
24.5.19 ESMF_ArrayGet - Access to PET-local Array tile via LocalArray object.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayGet()
   subroutine ESMF_ArrayGetLocalArray(array, localDe, localarray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in) :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: localDe
     type(ESMF_LocalArray), intent(inout) :: localarray
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Provide access to <TT>ESMF_LocalArray</TT> object that holds data for
   the specified local DE.

<P>
The arguments are:
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Queried <TT>ESMF_Array</TT> object.
   
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>.
   For <TT>localDeCount==1</TT> the <TT>localDe</TT> argument may be omitted,
   in which case it will default to <TT>localDe=0</TT>.
   
</DD>
<DT><STRONG>localarray</STRONG></DT>
<DD>Upon return <TT>localarray</TT> refers to the DE-local data allocation of
   <TT>array</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050552000000000000000">
24.5.20 ESMF_ArrayHalo - Execute an Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayHalo(array, routehandle, &amp;
     routesyncflag, finishedflag, cancelledflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),          intent(inout)         :: array
     type(ESMF_RouteHandle),    intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag), intent(in),  optional :: routesyncflag
     logical,                   intent(out), optional :: finishedflag
     logical,                   intent(out), optional :: cancelledflag
     logical,                   intent(in),  optional :: checkflag
     integer,                   intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array halo operation for <TT>array</TT>. The <TT>array</TT>
     argument must be weakly congruent and typekind conform to the Array used
     during <TT>ESMF_ArrayHaloStore()</TT>.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
See <TT>ESMF_ArrayHaloStore()</TT> on how to precompute <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> containing data to be haloed.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[routesyncflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_ROUTESYNC_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node2.html#const:routesync">9.38</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>, or a final call with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT>. For all other <TT>routesyncflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.

</DD>
<DT><STRONG>[cancelledflag]</STRONG></DT>
<DD>A value of <TT>.true.</TT> indicates that were cancelled communication
       operations. In this case the data in the <TT>dstArray</TT> must be considered
       invalid. It may have been partially modified by the call. A value of
       <TT>.false.</TT> indicates that none of the communication operations was
       cancelled. The data in <TT>dstArray</TT> is valid if <TT>finishedflag</TT> 
       returns equal <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552100000000000000">
24.5.21 ESMF_ArrayHaloRelease - Release resources associated with Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayHaloRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Array halo operation. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552200000000000000">
24.5.22 ESMF_ArrayHaloStore - Precompute an Array halo operation</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_ArrayHaloStore(array, routehandle, &amp;
       startregion, haloLDepth, haloUDepth, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),            intent(inout)         :: array
     type(ESMF_RouteHandle),      intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_StartRegion_Flag), intent(in),  optional ::startregion
     integer,                     intent(in),  optional :: haloLDepth(:)
     integer,                     intent(in),  optional :: haloUDepth(:)
     integer,                     intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Store an Array halo operation over the data in <TT>array</TT>. By default,
     i.e. without specifying <TT>startregion</TT>, <TT>haloLDepth</TT> and
     <TT>haloUDepth</TT>, all elements in the total Array region that lie outside
     the exclusive region will be considered potential destination elements for
     halo. However, only those elements that have a corresponding halo source
     element, i.e. an exclusive element on one of the DEs, will be updated under
     the halo operation. Elements that have no associated source remain 
     unchanged under halo.

<P>
Specifying <TT>startregion</TT> allows to change the shape of the 
     effective halo region from the inside. Setting this flag to
     <TT>ESMF_STARTREGION_COMPUTATIONAL</TT> means that only elements outside 
     the computational region of the Array are considered for potential
     destination elements for halo. The default is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>.

<P>
The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> arguments allow to reduce
     the extent of the effective halo region. Starting at the region specified
     by <TT>startregion</TT>, the <TT>haloLDepth</TT> and <TT>haloUDepth</TT>
     define a halo depth in each direction. Note that the maximum halo region is
     limited by the total Array region, independent of the actual
     <TT>haloLDepth</TT> and <TT>haloUDepth</TT> setting. The total Array region is
     local DE specific. The <TT>haloLDepth</TT> and <TT>haloUDepth</TT> are interpreted
     as the maximum desired extent, reducing the potentially larger region
     available for halo.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayHalo()</TT> on any Array that is weakly congruent
     and typekind conform to <TT>array</TT>.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> containing data to be haloed. The data in the halo
       region may be destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[startregion]</STRONG></DT>
<DD>The start of the effective halo region on every DE. The default
       setting is <TT>ESMF_STARTREGION_EXCLUSIVE</TT>, rendering all non-exclusive
       elements potential halo destination elments.
       See section <A HREF="node2.html#const:startregion">9.41</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[haloLDepth]</STRONG></DT>
<DD>This vector specifies the lower corner of the effective halo
       region with respect to the lower corner of <TT>startregion</TT>.
       The size of <TT>haloLDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[haloUDepth]</STRONG></DT>
<DD>This vector specifies the upper corner of the effective halo
       region with respect to the upper corner of <TT>startregion</TT>.
       The size of <TT>haloUDepth</TT> must equal the number of distributed Array
       dimensions.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552300000000000000">
24.5.23 ESMF_ArrayPrint - Print Array internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayPrint(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMF_Array</TT> object. 
<BR>
<P>
The arguments are:
     <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552400000000000000">
24.5.24 ESMF_ArrayRead - Read Array data from a file</A>
</H3>

<P>
<A NAME="api:ArrayRead"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayRead(array, file, variableName, &amp;
     timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),     intent(inout)         :: array
     character(*),         intent(in)            :: file
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*),         intent(in),  optional :: variableName
     integer,              intent(in),  optional :: timeslice
     type(ESMF_IOFmtFlag), intent(in),  optional :: iofmt
     integer,              intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Read Array data from file and put it into an <TT>ESMF_Array</TT> object.
     For this API to be functional, the environment variable <TT>ESMF_PIO</TT>
     should be set to "internal" when the ESMF library is built.
     Please see the section on Data I/O,&nbsp;<A HREF="node5.html#io:dataio">32.3</A>.

<P>
Limitations:
     
<UL>
<LI>Only 1 DE per PET supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object in which the read data is returned.
     
</DD>
<DT><STRONG>file</STRONG></DT>
<DD>The name of the file from which Array data is read.
     
</DD>
<DT><STRONG>[variableName]</STRONG></DT>
<DD>Variable name in the file; default is the "name" of Array.
      Use this argument only in the IO format (such as NetCDF) that
      supports variable name. If the IO format does not support this 
      (such as binary format), ESMF will return an error code.
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>The time-slice number of the variable read from file.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format.  Please see Section&nbsp;<A HREF="node2.html#opt:iofmtflag">9.25</A> for the list 
      of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552500000000000000">
24.5.25 ESMF_ArrayRedist - Execute an Array redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayRedist(srcArray, dstArray, routehandle, &amp;
     routesyncflag, finishedflag, cancelledflag, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),          intent(in),    optional :: srcArray
     type(ESMF_Array),          intent(inout), optional :: dstArray
     type(ESMF_RouteHandle),    intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag), intent(in),    optional  :: routesyncflag
     logical,                   intent(out),   optional :: finishedflag
     logical,                   intent(out),   optional :: cancelledflag
     logical,                   intent(in),    optional :: checkflag
     integer,                   intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array redistribution from <TT>srcArray</TT> to
     <TT>dstArray</TT>. Both <TT>srcArray</TT> and <TT>dstArray</TT> must be
     weakly congruent and typekind conform with the respective Arrays used 
     during <TT>ESMF_ArrayRedistStore()</TT>.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
See <TT>ESMF_ArrayRedistStore()</TT> on how to precompute 
     <TT>routehandle</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>[dstArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[routesyncflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_ROUTESYNC_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node2.html#const:routesync">9.38</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>, or a final call with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT>. For all other <TT>routesyncflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.

</DD>
<DT><STRONG>[cancelledflag]</STRONG></DT>
<DD>A value of <TT>.true.</TT> indicates that were cancelled communication
       operations. In this case the data in the <TT>dstArray</TT> must be considered
       invalid. It may have been partially modified by the call. A value of
       <TT>.false.</TT> indicates that none of the communication operations was
       cancelled. The data in <TT>dstArray</TT> is valid if <TT>finishedflag</TT> 
       returns equal <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552600000000000000">
24.5.26 ESMF_ArrayRedistRelease - Release resources associated with Array redistribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayRedistRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Array redistribution. After this call
     <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552700000000000000">
24.5.27 ESMF_ArrayRedistStore - Precompute Array redistribution with local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayRedistStore()
   subroutine ESMF_ArrayRedistStore&lt;type&gt;&lt;kind&gt;(srcArray, dstArray, &amp;
     routehandle, factor, srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),         intent(in)            :: srcArray
     type(ESMF_Array),         intent(inout)         :: dstArray
     type(ESMF_RouteHandle),   intent(inout)         :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), intent(in)            :: factor
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(in),  optional :: srcToDstTransposeMap(:)
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="ArrayRedistStoreTK"></A>   <TT>ESMF_ArrayRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArrayRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArrayRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node5.html#ArrayRedistStoreTK">24.5.27</A> and
   <A HREF="node5.html#ArrayRedistStoreNF">24.5.28</A>, is described in the following paragraphs as a whole.

<P>
Store an Array redistribution operation from <TT>srcArray</TT> to <TT>dstArray</TT>.
   Interface <A HREF="node5.html#ArrayRedistStoreTK">24.5.27</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="node5.html#ArrayRedistStoreNF">24.5.28</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Array, destination Array, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Arrays may differ in shape,
   however, the number of elements must match. 

<P>
If <TT>srcToDstTransposeMap</TT> is not specified the redistribution corresponds
   to an identity mapping of the sequentialized source Array to the
   sequentialized destination Array. If the <TT>srcToDstTransposeMap</TT>
   argument is provided it must be identical on all PETs. The
   <TT>srcToDstTransposeMap</TT> allows source and destination Array dimensions to
   be transposed during the redistribution. The number of source and destination
   Array dimensions must be equal under this condition and the size of mapped
   dimensions must match.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
   <TT>dstArray</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayRedist()</TT> on any pair of Arrays that are weakly congruent
     and typekind conform with the <TT>srcArray</TT>, <TT>dstArray</TT> pair. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This method is overloaded for:
<BR>
   <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
   <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
   <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factor</STRONG></DT>
<DD>Factor by which to multipy source data.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcArray</TT>. Each
       entry maps the corresponding <TT>srcArray</TT> dimension against the 
       specified <TT>dstArray</TT> dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050552800000000000000">
24.5.28 ESMF_ArrayRedistStore - Precompute Array redistribution without local factor argument</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArrayRedistStore()
   subroutine ESMF_ArrayRedistStoreNF(srcArray, dstArray, routehandle, &amp;
     srcToDstTransposeMap, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(in)            :: srcArray
     type(ESMF_Array),       intent(inout)         :: dstArray
     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: srcToDstTransposeMap(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="ArrayRedistStoreNF"></A>   <TT>ESMF_ArrayRedistStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArrayRedistStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArrayRedistStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node5.html#ArrayRedistStoreTK">24.5.27</A> and
   <A HREF="node5.html#ArrayRedistStoreNF">24.5.28</A>, is described in the following paragraphs as a whole.

<P>
Store an Array redistribution operation from <TT>srcArray</TT> to <TT>dstArray</TT>.
   Interface <A HREF="node5.html#ArrayRedistStoreTK">24.5.27</A> allows PETs to specify a <TT>factor</TT>
   argument. PETs not specifying a <TT>factor</TT> argument call into interface
   <A HREF="node5.html#ArrayRedistStoreNF">24.5.28</A>. If multiple PETs specify the <TT>factor</TT> argument,
   its type and kind, as well as its value must match across all PETs. If none
   of the PETs specify a <TT>factor</TT> argument the default will be a factor of
   1. The resulting factor is applied to all of the source data during
   redistribution, allowing scaling of the data, e.g. for unit transformation.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized 
   vectors. The sequence is defined by the order of DistGrid dimensions and the
   order of tiles within the DistGrid or by user-supplied arbitrary sequence
   indices. See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition
   of <EM>sequence indices</EM>.

<P>
Source Array, destination Array, and the factor may be of different
   &lt;type&gt;&lt;kind&gt;. Further, source and destination Arrays may differ in shape,
   however, the number of elements must match. 

<P>
If <TT>srcToDstTransposeMap</TT> is not specified the redistribution corresponds
   to an identity mapping of the sequentialized source Array to the
   sequentialized destination Array. If the <TT>srcToDstTransposeMap</TT>
   argument is provided it must be identical on all PETs. The
   <TT>srcToDstTransposeMap</TT> allows source and destination Array dimensions to
   be transposed during the redistribution. The number of source and destination
   Array dimensions must be equal under this condition and the size of mapped
   dimensions must match.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
   <TT>dstArray</TT> arguments. 

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArrayRedist()</TT> on any pair of Arrays that are weakly congruent
     and typekind conform with the <TT>srcArray</TT>, <TT>dstArray</TT> pair.
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the sizes of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, are permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.  

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[srcToDstTransposeMap]</STRONG></DT>
<DD>List with as many entries as there are dimensions in <TT>srcArray</TT>. Each
       entry maps the corresponding <TT>srcArray</TT> dimension against the 
       specified <TT>dstArray</TT> dimension. Mixing of distributed and
       undistributed dimensions is supported.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050552900000000000000">
24.5.29 ESMF_ArrayScatter - Scatter a Fortran array across the ESMF_Array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayScatter(array, farray, rootPet, tile, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_Array), intent(inout) :: array 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), intent(in), target :: farray(&lt;rank&gt;) 
   integer, intent(in) :: rootPet 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   integer, intent(in), optional :: tile 
   type(ESMF_VM), intent(in), optional :: vm 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Scatter the data of <TT>farray</TT> located on <TT>rootPET</TT> 
   across an ESMF_Array object. A single <TT>farray</TT> must be 
   scattered across a single DistGrid tile in Array. The optional <TT>tile</TT> 
   argument allows selection of the tile. For Arrays defined on a single 
   tile DistGrid the default selection (tile 1) will be correct. The 
   shape of <TT>farray</TT> must match the shape of the tile in Array. 

<P>
If the Array contains replicating DistGrid dimensions data will be 
   scattered across all of the replicated pieces. 

<P>
This version of the interface implements the PET-based blocking paradigm: 
   Each PET of the VM must issue this call exactly once for <EM>all</EM> of its 
   DEs. The call will block until all PET-local data objects are accessible. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object across which data will be scattered. 
   
</DD>
<DT><STRONG>{farray}</STRONG></DT>
<DD>The Fortran array that is to be scattered. Only root 
   must provide a valid <TT>farray</TT>, the other PETs may treat 
   <TT>farray</TT> as an optional argument. 
   
</DD>
<DT><STRONG>rootPet</STRONG></DT>
<DD>PET that holds the valid data in <TT>farray</TT>. 
   
</DD>
<DT><STRONG>[tile]</STRONG></DT>
<DD>The DistGrid tile in <TT>array</TT> into which to scatter <TT>farray</TT>. 
   By default <TT>farray</TT> will be scattered into tile 1. 
   
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the 
   VM of the current context will lower the method's overhead. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050553000000000000000">
24.5.30 ESMF_ArraySet - Set Array properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySet()
   subroutine ESMF_ArraySetDefault(array, computationalLWidth, &amp;
     computationalUWidth, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),   intent(inout)         :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: computationalLWidth(:,:)
     integer,            intent(in),  optional :: computationalUWidth(:,:)
     character(len = *), intent(in),  optional :: name
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets adjustable settings in an <TT>ESMF_Array</TT> object. Arrays with
       tensor dimensions will set values for <EM>all</EM> tensor components.

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object for which to set properties.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The Array name.
       
</DD>
<DT><STRONG>[computationalLWidth]</STRONG></DT>
<DD>This argument must have of size <TT>(dimCount, localDeCount)</TT>.
         <TT>computationalLWidth</TT> specifies the lower corner of the
         computational region with respect to the lower corner of the exclusive
         region for all local DEs.

</DD>
<DT><STRONG>[computationalUWidth]</STRONG></DT>
<DD>This argument must have of size <TT>(dimCount, localDeCount)</TT>.
         <TT>computationalUWidth</TT> specifies the upper corner of the
         computational region with respect to the upper corner of the exclusive
         region for all local DEs.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553100000000000000">
24.5.31 ESMF_ArraySet - Set Array properties</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySet()
   subroutine ESMF_ArraySetPLocalDe(array, localDe, rimSeqIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),   intent(inout)         :: array
     integer,            intent(in)            :: localDe
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,            intent(in),  optional :: rimSeqIndex(:)
     integer,            intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets adjustable settings in an <TT>ESMF_Array</TT> object for a specific
       localDe.

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMF_Array</TT> object for which to set properties.
       
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which to set values.
       
</DD>
<DT><STRONG>[rimSeqIndex]</STRONG></DT>
<DD>Sequence indices in the halo rim of localDe.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553200000000000000">
24.5.32 ESMF_ArraySMM - Execute an Array sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySMM(srcArray, dstArray, routehandle, &amp;
     routesyncflag, finishedflag, cancelledflag, zeroregion, checkflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),          intent(in),    optional :: srcArray
     type(ESMF_Array),          intent(inout), optional :: dstArray
     type(ESMF_RouteHandle),    intent(inout)           :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_RouteSync_Flag), intent(in),    optional :: routesyncflag
     logical,                   intent(out),   optional :: finishedflag
     logical,                   intent(out),   optional :: cancelledflag
     type(ESMF_Region_Flag),    intent(in),    optional :: zeroregion
     logical,                   intent(in),    optional :: checkflag
     integer,                   intent(out),   optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Execute a precomputed Array sparse matrix multiplication from <TT>srcArray</TT>
     to <TT>dstArray</TT>. Both <TT>srcArray</TT> and <TT>dstArray</TT> must be weakly
     congruent and typekind conform to the respective Arrays used during 
     <TT>ESMF_ArraySMMStore()</TT>.
     
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the size of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, is permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
See <TT>ESMF_ArraySMMStore()</TT> on how to precompute 
     <TT>routehandle</TT>. See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the
     operation <TT>ESMF_ArraySMM()</TT> performs.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>[srcArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>[dstArray]</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[routesyncflag]</STRONG></DT>
<DD>Indicate communication option. Default is <TT>ESMF_ROUTESYNC_BLOCKING</TT>,
       resulting in a blocking operation.
       See section <A HREF="node2.html#const:routesync">9.38</A> for a complete list of valid settings.
     
</DD>
<DT><STRONG>[finishedflag]</STRONG></DT>
<DD>Used in combination with <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>.
       Returned <TT>finishedflag</TT> equal to <TT>.true.</TT> indicates that all
       operations have finished. A value of <TT>.false.</TT> indicates that there
       are still unfinished operations that require additional calls with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBTESTFINISH</TT>, or a final call with
       <TT>routesyncflag = ESMF_ROUTESYNC_NBWAITFINISH</TT>. For all other <TT>routesyncflag</TT>
       settings the returned value in <TT>finishedflag</TT> is always <TT>.true.</TT>.

</DD>
<DT><STRONG>[cancelledflag]</STRONG></DT>
<DD>A value of <TT>.true.</TT> indicates that were cancelled communication
       operations. In this case the data in the <TT>dstArray</TT> must be considered
       invalid. It may have been partially modified by the call. A value of
       <TT>.false.</TT> indicates that none of the communication operations was
       cancelled. The data in <TT>dstArray</TT> is valid if <TT>finishedflag</TT> 
       returns equal <TT>.true.</TT>.
     
</DD>
<DT><STRONG>[zeroregion]</STRONG></DT>
<DD>If set to <TT>ESMF_REGION_TOTAL</TT> <EM>(default)</EM> the total regions of
       all DEs in <TT>dstArray</TT> will be initialized to zero before updating the 
       elements with the results of the sparse matrix multiplication. If set to
       <TT>ESMF_REGION_EMPTY</TT> the elements in <TT>dstArray</TT> will not be
       modified prior to the sparse matrix multiplication and results will be
       added to the incoming element values. Setting <TT>zeroregion</TT> to 
       <TT>ESMF_REGION_SELECT</TT> will only zero out those elements in the 
       destination Array that will be updated by the sparse matrix
       multiplication. See section <A HREF="node2.html#const:region">9.36</A> for a complete list of
       valid settings.

</DD>
<DT><STRONG>[checkflag]</STRONG></DT>
<DD>If set to <TT>.TRUE.</TT> the input Array pair will be checked for
       consistency with the precomputed operation provided by <TT>routehandle</TT>.
       If set to <TT>.FALSE.</TT> <EM>(default)</EM> only a very basic input check
       will be performed, leaving many inconsistencies undetected. Set
       <TT>checkflag</TT> to <TT>.FALSE.</TT> to achieve highest performance.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553300000000000000">
24.5.33 ESMF_ArraySMMRelease - Release resources associated with Array sparse matrix multiplication</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySMMRelease(routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Release resouces associated with an Array sparse matrix multiplication. 
     After this call <TT>routehandle</TT> becomes invalid.

<P>
<DL>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553400000000000000">
24.5.34 ESMF_ArraySMMStore - Precompute Array sparse matrix multiplication with local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStore&lt;type&gt;&lt;kind&gt;(srcArray, dstArray, &amp;
     routehandle, factorList, factorIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),                 intent(in)    :: srcArray
     type(ESMF_Array),                 intent(inout) :: dstArray
     type(ESMF_RouteHandle),           intent(inout) :: routehandle
     &lt;type&gt;(ESMF_KIND_&lt;kind&gt;), target, intent(in)    :: factorList(:)
     integer,                          intent(in)    :: factorIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="ArraySMMStoreTK"></A>   <TT>ESMF_ArraySMMStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArraySMMStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArraySMMStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node5.html#ArraySMMStoreTK">24.5.34</A> and
   <A HREF="node5.html#ArraySMMStoreNF">24.5.35</A>, is described in the following paragraphs as a whole.

<P>
Store an Array sparse matrix multiplication operation from <TT>srcArray</TT>
     to <TT>dstArray</TT>. PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the
     definition of <EM>sequence indices</EM>.

<P>
Source and destination Arrays, as well as the supplied <TT>factorList</TT>
     argument, may be of different &lt;type&gt;&lt;kind&gt;. Further source and
     destination Arrays may differ in shape and number of elements.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArraySMM()</TT> on any pair of Arrays that are weakly congruent
     and typekind conform with the <TT>srcArray</TT>, <TT>dstArray</TT> pair. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the size of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, is permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.

<P>
This method is overloaded for:
<BR>
     <TT>ESMF_TYPEKIND_I4</TT>, <TT>ESMF_TYPEKIND_I8</TT>,
<BR>
     <TT>ESMF_TYPEKIND_R4</TT>, <TT>ESMF_TYPEKIND_R8</TT>.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>factorList</STRONG></DT>
<DD>List of non-zero coefficients.
     
</DD>
<DT><STRONG>factorIndexList</STRONG></DT>
<DD>Pairs of sequence indices for the factors stored in <TT>factorList</TT>.

<P>
The second dimension of <TT>factorIndexList</TT> steps through the list of
       pairs, i.e. <TT>size(factorIndexList,2) == size(factorList)</TT>. The first
       dimension of <TT>factorIndexList</TT> is either of size 2 or size 4.

<P>
In the <EM>size 2 format</EM> <TT>factorIndexList(1,:)</TT> specifies the
       sequence index of the source element in the <TT>srcArray</TT> while
       <TT>factorIndexList(2,:)</TT> specifies the sequence index of the
       destination element in <TT>dstArray</TT>. For this format to be a valid
       option source and destination Arrays must have matching number of
       tensor elements (the product of the sizes of all Array tensor dimensions).
       Under this condition an identiy matrix can be applied within the space of
       tensor elements for each sparse matrix factor.

<P>
The <EM>size 4 format</EM> is more general and does not require a matching
       tensor element count. Here the <TT>factorIndexList(1,:)</TT> specifies the
       sequence index while <TT>factorIndexList(2,:)</TT> specifies the tensor
       sequence index of the source element in the <TT>srcArray</TT>. Further
       <TT>factorIndexList(3,:)</TT> specifies the sequence index and
       <TT>factorIndexList(4,:)</TT> specifies the tensor sequence index of the 
       destination element in the <TT>dstArray</TT>.

<P>
See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the definition of 
       Array <EM>sequence indices</EM> and <EM>tensor sequence indices</EM>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553500000000000000">
24.5.35 ESMF_ArraySMMStore - Precompute Array sparse matrix multiplication without local factors</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_ArraySMMStore()
   subroutine ESMF_ArraySMMStoreNF(srcArray, dstArray, routehandle, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),       intent(in)            :: srcArray
     type(ESMF_Array),       intent(inout)         :: dstArray
     type(ESMF_RouteHandle), intent(inout)         :: routehandle
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="ArraySMMStoreNF"></A>   <TT>ESMF_ArraySMMStore()</TT> is a collective method across all PETs of the
   current Component. The interface of the method is overloaded, allowing 
   - in principle - each PET to call into <TT>ESMF_ArraySMMStore()</TT>
   through a different entry point. Restrictions apply as to which combinations
   are sensible. All other combinations result in ESMF run time errors. The
   complete semantics of the <TT>ESMF_ArraySMMStore()</TT> method, as provided
   through the separate entry points shown in <A HREF="node5.html#ArraySMMStoreTK">24.5.34</A> and
   <A HREF="node5.html#ArraySMMStoreNF">24.5.35</A>, is described in the following paragraphs as a whole.

<P>
Store an Array sparse matrix multiplication operation from <TT>srcArray</TT>
     to <TT>dstArray</TT>. PETs that specify non-zero matrix coefficients must use
     the &lt;type&gt;&lt;kind&gt; overloaded interface and provide the <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments. Providing <TT>factorList</TT> and
     <TT>factorIndexList</TT> arguments with <TT>size(factorList) = (/0/)</TT> and
     <TT>size(factorIndexList) = (/2,0/)</TT> or <TT>(/4,0/)</TT> indicates that a 
     PET does not provide matrix elements. Alternatively, PETs that do not 
     provide matrix elements may also call into the overloaded interface
     <EM>without</EM> <TT>factorList</TT> and <TT>factorIndexList</TT> arguments.

<P>
Both <TT>srcArray</TT> and <TT>dstArray</TT> are interpreted as sequentialized
     vectors. The sequence is defined by the order of DistGrid dimensions and 
     the order of tiles within the DistGrid or by user-supplied arbitrary
     sequence indices. See section <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> for details on the
     definition of <EM>sequence indices</EM>.

<P>
Source and destination Arrays, as well as the supplied <TT>factorList</TT>
     argument, may be of different &lt;type&gt;&lt;kind&gt;. Further source and
     destination Arrays may differ in shape and number of elements.

<P>
It is erroneous to specify the identical Array object for <TT>srcArray</TT> and
     <TT>dstArray</TT> arguments.

<P>
The routine returns an <TT>ESMF_RouteHandle</TT> that can be used to call 
     <TT>ESMF_ArraySMM()</TT> on any pair of Arrays that are weakly congruent
     and typekind conform with the <TT>srcArray</TT>, <TT>dstArray</TT> pair. 
     Congruent Arrays possess matching DistGrids, and the shape of the local
     array tiles matches between the Arrays for every DE. For weakly congruent
     Arrays the size of the undistributed dimensions, that vary faster with
     memory than the first distributed dimension, is permitted to be different.
     This means that the same <TT>routehandle</TT> can be applied to a large class
     of similar Arrays that differ in the number of elements in the left most
     undistributed dimensions.
     <BR>

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>srcArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with source data.
     
</DD>
<DT><STRONG>dstArray</STRONG></DT>
<DD><TT>ESMF_Array</TT> with destination data. The data in this Array may be
       destroyed by this call.
     
</DD>
<DT><STRONG>routehandle</STRONG></DT>
<DD>Handle to the precomputed Route.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553600000000000000">
24.5.36 ESMF_ArrayValidate - Validate Array internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayValidate(array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array), intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>Array</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>array</STRONG></DT>
<DD>Specified <TT>ESMF_Array</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050553700000000000000">
24.5.37 ESMF_ArrayWrite - Write Array data into a file</A>
</H3>

<P>
<A NAME="api:ArrayWrite"></A>
<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArrayWrite(array, file, &amp;
      variableName, append, timeslice, iofmt, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Array),     intent(in)            :: array
     character(*),         intent(in)            :: file
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     character(*),         intent(in),  optional :: variableName
     logical,              intent(in),  optional :: append
     integer,              intent(in),  optional :: timeslice
     type(ESMF_IOFmtFlag), intent(in),  optional :: iofmt
     integer,              intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write Array data into a file. For this API to be functional, the 
     environment variable <TT>ESMF_PIO</TT> should be set to "internal" when 
     the ESMF library is built.  Please see the section on 
     Data I/O,&nbsp;<A HREF="node5.html#io:dataio">32.3</A>. 

<P>
Limitations:
     
<UL>
<LI>Only 1 DE per PET supported.
</LI>
<LI>Not supported in <TT>ESMF_COMM=mpiuni</TT> mode.
     
</LI>
</UL>

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD>The <TT>ESMF_Array</TT> object that contains data to be written.
     
</DD>
<DT><STRONG>file</STRONG></DT>
<DD>The name of the output file to which Array data is written.
     
</DD>
<DT><STRONG>[variableName]</STRONG></DT>
<DD>Variable name in the output file; default is the "name" of Array.
      Use this argument only in the IO format (such as NetCDF) that
      supports variable name. If the IO format does not support this 
      (such as binary format), ESMF will return an error code.
     
</DD>
<DT><STRONG>[append]</STRONG></DT>
<DD>Logical: if .true., data (with attributes) is appended to an
      existing file; default is .false.
     
</DD>
<DT><STRONG>[timeslice]</STRONG></DT>
<DD>Some IO formats (e.g. NetCDF) support the output of data in form of
      time slices. The <TT>timeslice</TT> argument provides access to this
      capability. Usage of this feature requires that the first slice is
      written with a positive <TT>timeslice</TT> value, and that subsequent slices
      are written with a <TT>timeslice</TT> argument that increments by one each
      time. By default, i.e. by omitting the <TT>timeslice</TT> argument, no
      provisions for time slicing are made in the output file.
     
</DD>
<DT><STRONG>[iofmt]</STRONG></DT>
<DD>The IO format. Please see Section&nbsp;<A HREF="node2.html#opt:iofmtflag">9.25</A> for the list 
      of options. If not present, defaults to <TT>ESMF_IOFMT_NETCDF</TT>.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05060000000000000000">
25 LocalArray Class</A>
</H1>

<P>

<H2><A NAME="SECTION05061000000000000000">
25.1 Description</A>
</H2>

<P>
The <TT>ESMF_LocalArray</TT> class provides a language independent 
representation of data in array format. One of the major functions 
of the LocalArray class is to bridge the Fortran/C/C++ language 
difference that exists with respect to array representation. All 
ESMF Field and Array data is internally stored in ESMF LocalArray 
objects allowing transparent access from Fortran and C/C++.

<P>
In the ESMF Fortran API the LocalArray becomes visible in those cases 
where a local PET may be associated with multiple pieces of an Array, 
e.g. if there are multiple DEs associated with a single PET. The Fortran 
language standard does not provide an array of arrays construct, however 
arrays of derived types holding arrays are possible. ESMF calls use 
arguments that are of type <TT>ESMF_LocalArray</TT> with <TT>dimension</TT> 
attributes where necessary.

<P>

<H2><A NAME="SECTION05062000000000000000">
25.2 Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>The TKR (type/kind/rank) overloaded LocalArray interfaces declare the dummy Fortran array arguments with the pointer attribute. The advantage of doing this is that it allows ESMF to inquire information about the provided Fortran array. The disadvantage of this choice is that actual Fortran arrays passed into these interfaces <EM>must</EM> also be defined with pointer attribute in the user code.
</LI>
</UL>

<P>

<H2><A NAME="SECTION05063000000000000000">
25.3 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05063100000000000000">
25.3.1 ESMF_LocalArrayAssignment(=) - LocalArray assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface assignment(=)
   localarray1 = localarray2
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray) :: localarray1
   type(ESMF_LocalArray) :: localarray2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign localarray1 as an alias to the same ESMF LocalArray object in memory
   as localarray2. If localarray2 is invalid, then localarray1 will be equally invalid after
   the assignment.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray1</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the left hand side of the assignment.
   
</DD>
<DT><STRONG>localarray2</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the right hand side of the assignment.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063200000000000000">
25.3.2 ESMF_LocalArrayOperator(==) - LocalArray equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
   if (localarray1 == localarray2) then ... endif
   OR
   result = (localarray1 == localarray2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray), intent(in) :: localarray1
   type(ESMF_LocalArray), intent(in) :: localarray2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether localarray1 and localarray2 are valid aliases to the same ESMF
   LocalArray object in memory. For a more general comparison of two ESMF LocalArrays,
   going beyond the simple alias test, the ESMF_LocalArrayMatch() function (not yet
   implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray1</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the left hand side of the equality
   operation.
   
</DD>
<DT><STRONG>localarray2</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the right hand side of the equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063300000000000000">
25.3.3 ESMF_LocalArrayOperator(/=) - LocalArray not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
   if (localarray1 /= localarray2) then ... endif
   OR
   result = (localarray1 /= localarray2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray), intent(in) :: localarray1
   type(ESMF_LocalArray), intent(in) :: localarray2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether localarray1 and localarray2 are <I>not</I> valid aliases to the
   same ESMF LocalArray object in memory. For a more general comparison of two ESMF
   LocalArrays, going beyond the simple alias test, the ESMF_LocalArrayMatch() function
   (not yet implemented) must be used.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray1</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the left hand side of the non-equality
   operation.
   
</DD>
<DT><STRONG>localarray2</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> object on the right hand side of the non-equality
   operation.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063400000000000000">
25.3.4 ESMF_LocalArrayCreate - Create a LocalArray by explicitly specifying typekind and rank arguments</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateByTKR(typekind, rank, totalCount, &amp;
     totalLBound, totalUBound, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateByTKR
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_TypeKind_Flag), intent(in) :: typekind
     integer, intent(in) :: rank
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: totalCount(:)
     integer, intent(in), optional :: totalLBound(:)
     integer, intent(in), optional :: totalUBound(:)
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_LocalArray</TT> and allocate data space, which remains
   uninitialized. The return value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind. See section <A HREF="node2.html#const:typekind">9.45</A> for valid values.
   
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality, 1D, 2D, etc). Maximum allowed is 7D.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D
   integer array the same length as the rank. The <TT>count</TT> argument may
   be omitted if both <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments are present.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>An integer array of length rank, with the lower index for each dimension.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>An integer array of length rank, with the upper index for each dimension.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063500000000000000">
25.3.5 ESMF_LocalArrayCreate - Create a LocalArray by specifying an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateBySpec(arrayspec, totalCount, &amp;
     totalLBound, totalUBound, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateBySpec
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in) :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(in), optional :: totalCount(:)
     integer, intent(in), optional :: totalLBound(:)
     integer, intent(in), optional :: totalUBound(:)
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new <TT>ESMF_LocalArray</TT> and allocate data space, which remains
   uninitialized. The return value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>ArraySpec object specifying typekind and rank.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D
   integer array the same length as the rank. The <TT>count</TT> argument may
   be omitted if both <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments are present.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>An integer array of length rank, with the lower index for each dimension.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>An integer array of length rank, with the upper index for each dimension.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063600000000000000">
25.3.6 ESMF_LocalArrayCreate - Create a LocalArray from pre-existing LocalArray</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate()
   function ESMF_LocalArrayCreateCopy(localarray, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_LocalArray) :: ESMF_LocalArrayCreateCopy
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(in) :: localarray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Perform a deep copy of an existing <TT>ESMF_LocalArray</TT> object. The return
   value is a new LocalArray.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD>Existing LocalArray to be copied.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05063700000000000000">
25.3.7 ESMF_LocalArrayCreate - Create a LocalArray from a Fortran pointer (associated or unassociated) </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayCreate() 
   function ESMF_LocalArrCreateByPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(farrayPtr, &amp; 
   datacopyflag, totalCount, totalLBound, totalUBound, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_LocalArray) :: ESMF_LocalArrCreateByPtr&lt;rank&gt;&lt;type&gt;&lt;kind&gt;
</PRE><EM>ARGUMENTS:</EM>
<PRE>   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr(&lt;rank&gt;) 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(in), optional :: totalCount(:) 
   integer, intent(in), optional :: totalLBound(:) 
   integer, intent(in), optional :: totalUBound(:) 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates an <TT>ESMF_LocalArray</TT> based on a Fortran array pointer. 
   Two cases must be distinguished. 

<P>
First, if <TT>farrayPtr</TT> is associated 
   the optional <TT>datacopyflag</TT> argument may be used to indicate whether the 
   associated data is to be copied or referenced. For associated <TT>farrayPtr</TT> 
   the optional <TT>totalCount</TT>, <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments need 
   not be specified. However, all present arguments will be checked against 
   <TT>farrayPtr</TT> for consistency. 

<P>
Second, if <TT>farrayPtr</TT> is unassociated the optional argument <TT>datacopyflag</TT> 
   must not be specified. However, in this case a complete set of totalCount and 
   bounds information must be provided. Any combination of present <TT>totalCount</TT> 
   <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments that provides a complete 
   specification is valid. All input information will be checked for 
   consistency. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>A Fortran array pointer (associated or unassociated). 
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Indicate copy vs. reference behavior in case of associated <TT>farrayPtr</TT>. 
   This argument must <EM>not</EM> be present for unassociated <TT>farrayPtr</TT>. 
   Default to <TT>ESMF_DATACOPY_REFERENCE</TT>, makes the <TT>ESMF_LocalArray</TT> 
   reference the associated data array. If set to <TT>ESMF_DATACOPY_VALUE</TT> this 
   routine allocates new memory and copies the data from the pointer into 
   the new LocalArray allocation. 
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>The number of items in each dimension of the array. This is a 1D 
   integer array the same length as the rank. The <TT>count</TT> argument may 
   be omitted if both <TT>totalLBound</TT> and <TT>totalUBound</TT> arguments are present. 
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>An integer array of lower index values. Must be the same length as the rank. 
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>An integer array of upper index values. Must be the same length as the rank. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05063800000000000000">
25.3.8 ESMF_LocalArrayDestroy - Release resources associated with a LocalArray</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_LocalArrayDestroy(localarray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(inout) :: localarray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_LocalArray</TT>, releasing all resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD>Destroy contents of this <TT>ESMF_LocalArray</TT>.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05063900000000000000">
25.3.9 ESMF_LocalArrayGet - Return LocalArray information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayGet()
   subroutine ESMF_LocalArrayGetDefault(localarray, &amp;
     typekind, rank, totalCount, totalLBound, totalUBound, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocalArray), intent(in) :: localarray
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer, intent(out), optional :: rank
     integer, intent(out), optional :: totalCount(:)
     integer, intent(out), optional :: totalLBound(:)
     integer, intent(out), optional :: totalUBound(:)
     integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information about the <TT>ESMF_LocalArray</TT>.

<P>
The arguments are:
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD>Queried <TT>ESMF_LocalArray</TT> object.
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>TypeKind of the LocalArray object.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Rank of the LocalArray object.
   
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Count per dimension.
   
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Lower bound per dimension.
   
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upper bound per dimension.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050631000000000000000">
25.3.10 ESMF_LocalArrayGet - Get access to data in a LocalArray object </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocalArrayGet() 
   subroutine ESMF_LocalArrayGetData&lt;rank&gt;&lt;type&gt;&lt;kind&gt;(localarray, farrayPtr, &amp; 
   datacopyflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>   type(ESMF_LocalArray) :: localarray 
   &lt;type&gt; (ESMF_KIND_&lt;kind&gt;), pointer :: farrayPtr 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
   type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag 
   integer, intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Return a Fortran pointer to the data buffer, or return a Fortran pointer 
   to a new copy of the data. 

<P>
The arguments are: 
   <DL>
<DT><STRONG>localarray</STRONG></DT>
<DD>The <TT>ESMF_LocalArray</TT> to get the value from. 
   
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>An unassociated or associated Fortran pointer correctly allocated.
   
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>An optional copy flag which can be specified. 
   Can either make a new copy of the data or reference existing data. 
   See section <A HREF="node2.html#const:datacopyflag">9.12</A> for a list of possible values. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
   
</DD>
</DL> 

<P>

<P>

<P>

<P>

<P>

<P>

<H1><A NAME="SECTION05070000000000000000">
26 ArraySpec Class</A>
</H1>

<P>

<H2><A NAME="SECTION05071000000000000000">
26.1 Description</A>
</H2>

<P>
An ArraySpec is a very simple class that contains type, kind, and
rank information about an Array.  This information is stored in two
parameters.  <B>TypeKind</B> describes the data type of the elements
in the Array and their precision.  <B>Rank</B> is the number of dimensions
in the Array.

<P>
The only methods that are associated with the ArraySpec class are those 
that allow you to set and retrieve this information.

<P>

<P>

<H2><A NAME="SECTION05072000000000000000">
26.2 Use and Examples</A>
</H2>

<P>
The ArraySpec is passed in as an argument at Field and 
FieldBundle creation in order to describe an Array that will 
be allocated or attached at a later time.  There are any
number of situations in which this approach is useful.  
One common example is a case in which the user wants to create
a very flexible export State with many diagnostic variables 
predefined, but only a subset desired and consequently 
allocated for a particular run.  

<P>

<P>

<P>

<P>
<PRE>
! !PROGRAM: ESMF_ArraySpecEx - ArraySpec manipulation examples
!
! !DESCRIPTION:
!
! This program shows examples of ArraySpec set and get usage
!-----------------------------------------------------------------------------

      ! ESMF Framework module
      use ESMF
      implicit none

      ! local variables 
      type(ESMF_ArraySpec) :: arrayDS
      integer :: myrank
      type(ESMF_TypeKind_Flag) :: mytypekind


      ! return code
      integer:: rc
</PRE>

<P>
<PRE>
      ! initialize ESMF framework
      call ESMF_Initialize(defaultlogfilename="ArraySpecEx.Log", &amp;
                    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
</PRE>

<P>

<P>

<H3><A NAME="SECTION05072100000000000000">
26.2.1 Set ArraySpec values</A>
</H3>

<P>
This example shows how to set values in an <TT>ESMF_ArraySpec</TT>. 

<P>
<PRE>
      call ESMF_ArraySpecSet(arrayDS, rank=2, &amp;
                             typekind=ESMF_TYPEKIND_R8, rc=rc)
</PRE>

<P>

<P>

<H3><A NAME="SECTION05072200000000000000">
26.2.2 Get ArraySpec values</A>
</H3>

<P>
This example shows how to query an <TT>ESMF_ArraySpec</TT>. 

<P>
<PRE>
      call ESMF_ArraySpecGet(arrayDS, rank=myrank, &amp;
        typekind=mytypekind, rc=rc)
      print *, "Returned values from ArraySpec:"
      print *, "rank =", myrank
</PRE>

<P>
<PRE>
      ! finalize ESMF framework
      call ESMF_Finalize(rc=rc)
</PRE>

<P>
<PRE>
      end program ESMF_ArraySpecEx
</PRE>

<P>

<P>

<H2><A NAME="SECTION05073000000000000000">
26.3 Restrictions and Future Work</A>
</H2>

<P>

<OL>
<LI><B>Limit on rank.</B>  The values for type, kind and rank passed 
into the ArraySpec
class are subject to the same limitations as Arrays.  The maximum
array rank is 7, which is the highest rank supported by Fortran.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION05074000000000000000">
26.4 Design and Implementation Notes</A>
</H2>

<P>
The information contained in an <TT>ESMF_ArraySpec</TT> is used to create 
<TT>ESMF_Array</TT> objects. 

<P>
<TT>ESMF_ArraySpec</TT> is a shallow class, and only set and get methods
are needed.  They do not need to be created or destroyed.

<P>

<H2><A NAME="SECTION05075000000000000000">
26.5 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05075100000000000000">
26.5.1 ESMF_ArraySpecAssignment(=) - Assign an ArraySpec to another ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface assignment(=)
     arrayspec1 = arrayspec2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec) :: arrayspec1
     type(ESMF_ArraySpec) :: arrayspec2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Set <TT>arrayspec1</TT> equal to <TT>arrayspec2</TT>. This is the default 
     Fortran assignment, which creates a complete, independent copy of 
     <TT>arrayspec2</TT> as <TT>arrayspec1</TT>. If <TT>arrayspec2</TT> is an 
     invalid <TT>ESMF_ArraySpec</TT> object then <TT>arrayspec1</TT> will be 
     equally invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec1</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to be set.
     
</DD>
<DT><STRONG>arrayspec2</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to be copied.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075200000000000000">
26.5.2 ESMF_ArraySpecOperator(==) - Test if ArraySpec 1 is equal to ArraySpec 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (arrayspec1 == arrayspec2) then ... endif
                  OR
     result = (arrayspec1 == arrayspec2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in) :: arrayspec1
     type(ESMF_ArraySpec), intent(in) :: arrayspec2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (==) operator for the <TT>ESMF_ArraySpec</TT> class to return 
     <TT>.true.</TT> if <TT>arrayspec1</TT> and <TT>arrayspec2</TT> specify the same
     type, kind and rank, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec1</STRONG></DT>
<DD>First <TT>ESMF_ArraySpec</TT> in comparison.
     
</DD>
<DT><STRONG>arrayspec2</STRONG></DT>
<DD>Second <TT>ESMF_ArraySpec</TT> in comparison.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075300000000000000">
26.5.3 ESMF_ArraySpecOperator(/=) - Test if ArraySpec 1 is not equal to ArraySpec 2</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (arrayspec1 /= arrayspec2) then ... endif
                  OR
     result = (arrayspec1 /= arrayspec2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in) :: arrayspec1
     type(ESMF_ArraySpec), intent(in) :: arrayspec2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Overloads the (/=) operator for the <TT>ESMF_ArraySpec</TT> class to return 
     <TT>.true.</TT> if <TT>arrayspec1</TT> and <TT>arrayspec2</TT> do not specify the
     same type, kind or rank, and <TT>.false.</TT> otherwise.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec1</STRONG></DT>
<DD>First <TT>ESMF_ArraySpec</TT> in comparison.
     
</DD>
<DT><STRONG>arrayspec2</STRONG></DT>
<DD>Second <TT>ESMF_ArraySpec</TT> in comparison.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075400000000000000">
26.5.4 ESMF_ArraySpecGet - Get values from an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecGet(arrayspec, rank, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec),     intent(in)            :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: rank
     type(ESMF_TypeKind_Flag), intent(out), optional :: typekind
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information about the contents of an <TT>ESMF_ArraySpec</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to query.
     
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum possible is 7D.
     
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>Array typekind.  See section <A HREF="node2.html#const:typekind">9.45</A> for valid values.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075500000000000000">
26.5.5 ESMF_ArraySpecPrint - Print information of ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecPrint(arrayspec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in)            :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Print ArraySpec internals. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Specified <TT>ESMF_ArraySpec</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075600000000000000">
26.5.6 ESMF_ArraySpecSet - Set values for an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecSet(arrayspec, rank, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec),     intent(out)           :: arrayspec
     integer,                  intent(in)            :: rank
     type(ESMF_TypeKind_Flag), intent(in)            :: typekind
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                  intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a description of the data - the typekind, the rank,
     and the dimensionality.

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMF_ArraySpec</TT> to set.
     
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum allowed is 7D.
     
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind.  See section <A HREF="node2.html#const:typekind">9.45</A> for valid values.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05075700000000000000">
26.5.7 ESMF_ArraySpecValidate - Validate ArraySpec internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_ArraySpecValidate(arrayspec, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_ArraySpec), intent(in)            :: arrayspec
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>arrayspec</TT> is internally consistent.
     The method returns an error code if problems are found.  

<P>
The arguments are:
     <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>Specified <TT>ESMF_ArraySpec</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05080000000000000000">
27 Grid Class</A>
</H1>

<P>

<H2><A NAME="SECTION05081000000000000000">
27.1 Description</A>
</H2>

<P>
The ESMF Grid class is used to describe the geometry and discretization
of logically rectangular physical grids.  It also contains the
description of the grid's underlying topology and the decomposition
of the physical grid across the available computational resources.
The most frequent use of the Grid class is to describe physical grids
in user code so that sufficient information is available to perform ESMF
methods such as regridding.  

<P>
<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Representation of grids formed by logically rectangular regions,
including uniform and rectilinear grids (e.g. lat-lon grids),
curvilinear grids (e.g. displaced pole grids), and grids formed
by connected logically rectangular regions (e.g. cubed sphere grids).</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Support for 1D, 2D, 3D, and higher dimension grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Distribution of grids across computational resources for parallel
operations - users set which grid dimensions are distributed.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Grids can be created already distributed, so that no single
resource needs global information during the creation process.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options to define periodicity and other edge connectivities either 
explicitly or implicitly via shape shortcuts.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for users to define grid coordinates themselves or call
prefabricated coordinate generation routines for standard grids
[NO GENERATION ROUTINES YET].</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for incremental construction of grids.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Options for using a set of pre-defined stagger locations or for setting
custom stagger locations.</TD>
</TR>
</TABLE>
</DIV>

<P>

<H3><A NAME="SECTION05081100000000000000">
27.1.1 Grid Representation in ESMF</A>
</H3>

<P>
ESMF Grids are based on the concepts described in <I>A Standard
Description of Grids Used in Earth System Models</I> [Balaji 2006].  In this document
Balaji introduces the mosaic concept as a means of describing
a wide variety of Earth system model grids.  A <B>mosaic</B> is
composed of grid tiles connected at their edges.  Mosaic grids
includes simple, single tile grids as a special case.  

<P>
The ESMF Grid class is a representation of a mosaic grid.  Each ESMF
Grid is constructed of one or more logically rectangular <B>Tiles</B>.
A Tile will usually have some physical significance (e.g. the region
of the world covered by one face of a cubed sphere grid).

<P>
The piece of a Tile that resides on one DE (for simple cases, a DE
can be thought of as a processor - see section on the DELayout)
is called a <B>LocalTile</B>.  For example, the six faces of a cubed
sphere grid are each Tiles, and each Tile can be divided into many
LocalTiles.  

<P>
Every ESMF Grid contains a DistGrid object, which defines the Grid's
index space, topology, distribution, and connectivities.  It enables
the user to define the complex edge relationships of tripole and other
grids.  The DistGrid can be created explicitly and passed into a Grid
creation routine, or it can be created implicitly if the user takes
a Grid creation shortcut. The DistGrid used
in Grid creation describes the properties of the Grid cells. In addition
to this one, the Grid internally creates DistGrids for each stagger location. 
These stagger DistGrids are related to the original DistGrid, but may 
contain extra padding to represent the extent of the index space of
the stagger. These DistGrids are what are used when a Field is created 
on a Grid. 

<P>

<H3><A NAME="SECTION05081200000000000000">
27.1.2 Supported Grids</A>
</H3>

<P>
The range of supported grids in ESMF can be defined by:

<UL>
<LI>Types of topologies and shapes supported.  ESMF supports one or
more logically rectangular grid Tiles with connectivities specified
between cells.  For more details see section <A HREF="node5.html#sec:ShapeShortcut">27.1.3</A>.
</LI>
<LI>Types of distributions supported.  ESMF supports  regular,
irregular, or arbitrary distributions of data.  
For more details see section <A HREF="node5.html#sec:desc:dist">27.1.4</A>.
</LI>
<LI>Types of coordinates supported.  ESMF supports uniform, rectilinear,
and curvilinear coordinates.  For more details see section <A HREF="node5.html#sec:coordspec">27.1.5</A>.
</LI>
</UL>

<P>

<H3><A NAME="SECTION05081300000000000000"></A>
<A NAME="sec:ShapeShortcut"></A>
<BR>
27.1.3 Grid Topologies and Periodicity
</H3>

ESMF has shortcuts for the creation of standard Grid topologies 
or <B>shapes</B> up to 3D.  In many cases, these enable the user to
bypass the step of creating a DistGrid before creating the Grid. 
There are two sets of methods which allow the user to do this. These two sets of methods cover the same set of topologies, but
allow the user to specify them in different ways.

<P>
The first set of these are a group of overloaded
calls broken up by the number of periodic dimensions they specify. With these the user can pick 
the method which creates a Grid with the number of periodic dimensions they need, and then specify other connectivity 
options via arguments to the method. The following is a description of these methods:

<P>

<P>
<BR>

<P>
<DL>
<DT><STRONG>ESMF_GridCreateNoPeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with no edge connections, for example, a regional Grid with closed boundaries.

<P>
</DD>
<DT><STRONG>ESMF_GridCreate1PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 1 periodic dimension and supports a range of options for what to do at the pole (see&nbsp;Section&nbsp;<A HREF="node5.html#const:polekind">27.2.6</A>. Some examples of Grids which can be created here are tripole spheres, bipole spheres, cylinders with open poles. 

<P>
</DD>
<DT><STRONG>ESMF_GridCreate2PeriDim()</STRONG></DT>
<DD>Allows the user to create a Grid with 2 periodic dimensions, for example a torus, or a regional Grid with
doubly periodic boundaries. 
</DD>
</DL>

<P>
More detailed information can be found in the API description of each.

<P>

<P>
<BR>

<P>
The second set of shortcut methods is a set of methods overloaded under the name <TT>ESMF_GridCreate()</TT>. These methods
allow the user to specify the connectivites at the end of each dimension, by using the ESMF_GridConn_Flag flag. The table below shows the ESMF_GridConn_Flag settings used to create 
standard shapes in 2D using the ESMF_GridCreate() call.  Two values
are specified for each dimension, one for the low end and one for 
the high end of the dimension's index values.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">2D Shape</TD>
<TD ALIGN="CENTER"><B>connflagDim1(1)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim1(2)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim2(1)</B></TD>
<TD ALIGN="CENTER"><B>connflagDim2(2)</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Rectangle</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Bipole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Tripole Sphere</B></TD>
<TD ALIGN="CENTER">POLE</TD>
<TD ALIGN="CENTER">BIPOLE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Cylinder</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>Torus</B></TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
<TD ALIGN="CENTER">PERIODIC</TD>
</TR>
</TABLE>

<P>
<BR>

<P>
If the user's grid shape is too complex for an ESMF shortcut routine,
or involves more than three dimensions, a DistGrid can be created
to specify the shape in detail.  This DistGrid is then passed
into a Grid create call.

<P>

<H3><A NAME="SECTION05081400000000000000"></A>
<A NAME="sec:desc:dist"></A>
<BR>
27.1.4 Grid Distribution
</H3>

<P>
ESMF Grids have several options for data distribution (also referred to
as decomposition).  As ESMF Grids are cell based, these 
options are all specified  in terms of how the cells in the Grid
are broken up between DEs. 

<P>
The main distribution options are regular, irregular, and arbitrary.
A <B>regular</B> distribution is one in which the same number of
contiguous grid cells are assigned to each DE in the
distributed dimension.  A <B>irregular</B> distribution is one in which
unequal numbers of contiguous grid cells are assigned to each
DE in the distributed dimension.  An <B>arbitrary</B> distribution is
one in which any grid cell can be assigned to any DE.  Any of these
distribution options can be applied to any of the grid shapes (i.e.,
rectangle) or types (i.e., rectilinear).  Support for arbitrary distribution 
is limited in v5.2.0, See section <A HREF="node5.html#example:ArbGridWithUndistDim">27.3.7</A> for
more detail descriptions.

<P>
Figure <A HREF="node5.html#fig:GridDecomps">13</A> illustrates options for distribution.

<DIV ALIGN="CENTER"><A NAME="fig:GridDecomps"></A><A NAME="36633"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 13:</STRONG>
Examples of regular and irregular decomposition of
a grid <B>a</B> that is 6x6, and an arbitrary decomposition of
a grid <B>b</B> that is 6x3.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{GridDecomps}}$
 -->
<IMG
 WIDTH="726" HEIGHT="220" ALIGN="BOTTOM" BORDER="0"
 SRC="img56.png"
 ALT="\scalebox{0.9}{\includegraphics{GridDecomps}}"></TD></TR>
</TABLE>
</DIV>

<P>
A distribution can also be specified using the DistGrid, by passing
object into a Grid create call.

<P>

<H3><A NAME="SECTION05081500000000000000"></A>
<A NAME="sec:coordspec"></A>
<BR>
27.1.5 Grid Coordinates
</H3>
Grid Tiles can have uniform, rectilinear, or curvilinear
coordinates.  The coordinates of <B>uniform</B> grids are equally spaced along
their axes, and can be fully specified by the coordinates of the two opposing points
that define the grid's physical span.  The coordinates of <B>rectilinear</B> grids
are unequally spaced along their axes, and can be fully specified by giving
the spacing of grid points along each axis.  The coordinates of <B>curvilinear 
grids</B> must be specified by giving the explicit set of coordinates for each
grid point.  Curvilinear grids are often uniform or rectilinear grids that 
have been warped; for example, to place a pole over a land mass so that it
does not affect the computations performed on an ocean model grid.  Figure
<A HREF="node5.html#fig:LogRectGrids">14</A> shows examples of each type of grid.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:LogRectGrids"></A><A NAME="36608"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 14:</STRONG>
Types of logically rectangular grid tiles.  Red circles show the
values needed to specify grid coordinates for each type.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{LogRectGrids}}$
 -->
<IMG
 WIDTH="726" HEIGHT="219" ALIGN="BOTTOM" BORDER="0"
 SRC="img57.png"
 ALT="\scalebox{0.9}{\includegraphics{LogRectGrids}}"></TD></TR>
</TABLE>
</DIV>

<P>
Each of these coordinate types can be set for each of the standard grid shapes
described in section <A HREF="node5.html#sec:ShapeShortcut">27.1.3</A>.  

<P>
The table below shows how examples of common single Tile grids fall 
into this shape and coordinate taxonomy.  Note that any
of the grids in the table can have a regular or arbitrary distribution.

<P>

<P>
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Uniform</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Rectilinear</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115><B>Curvilinear</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58><B>Sphere</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Global uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Gaussian grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Displaced pole grid</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=58><B>Rectangle</B></TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Regional uniform lat-lon grid</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Gaussian grid section</TD>
<TD ALIGN="LEFT" VALIGN="TOP" WIDTH=115>Polar stereographic grid section</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION05081600000000000000">
27.1.6 Coordinate Specification and Generation</A>
</H3>

<P>
There are two ways of specifying coordinates in ESMF.  The
first way is for the user to <B>set</B> the coordinates.  The second 
way is to take a shortcut and have the framework <B>generate</B>
the coordinates.  

<P>
No ESMF generation routines are currently available.

<P>
See Section&nbsp;<A HREF="node5.html#sec:usage:staggerloc">27.3.10</A> for more description and examples of
setting coordinates.

<P>

<H3><A NAME="SECTION05081700000000000000">
27.1.7 Staggering</A>
</H3>

<P>
<B>Staggering</B> is a finite difference technique in which the values 
of different physical quantities are placed at different locations
within a grid cell. 

<P>
The ESMF Grid class supports a variety of stagger locations, including
cell centers, corners, and edge centers. The default stagger location in 
ESMF is the cell center, and cell counts in Grid are based on this assumption.
Combinations of the 2D ESMF stagger locations are sufficient to specify any of the
Arakawa staggers.  ESMF also supports staggering in 3D and higher dimensions.
There are shortcuts for standard staggers, and interfaces through which users 
can create custom staggers.  

<P>
As a default the ESMF Grid class provides symmetric staggering, so
that cell centers are enclosed by cell perimeter (e.g. corner) 
stagger locations. This means the coordinate arrays for stagger
locations other than the center will have an additional element of 
padding in order to enclose the cell center locations.
However, to achieve other types of staggering, the user may alter 
or eliminate this padding by using the appropriate options when adding
coordinates to a Grid. 

<P>
In v5.2.0, only the cell center stagger location is supported for an
arbitrarily distributed grid. For examples and a full description of the stagger interface 
see Section&nbsp;<A HREF="node5.html#sec:usage:staggerloc">27.3.10</A>. 

<P>

<H2><A NAME="SECTION05082000000000000000">
27.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05082100000000000000"></A>
<A NAME="const:coordsys"></A>
<BR>
27.2.1 ESMF_COORDSYS
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
 A set of values which indicates in which system the coordinates in the Grid are. This value is useful both to indicate to 
other users the type of the coordinates, but also to control how the coordinates are interpreted in regridding methods 
(e.g. <TT>ESMF_FieldRegridStore()</TT>).

<P>
The type of this flag is:

<P>
<TT>type(ESMF_CoordSys_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_COORDSYS_CART</STRONG></DT>
<DD>Cartesian coordinate system. 

<P>
</DD>
<DT><STRONG>ESMF_COORDSYS_SPH_DEG</STRONG></DT>
<DD>Spherical coordinates in degrees.

<P>
</DD>
<DT><STRONG>ESMF_COORDSYS_SPH_RAD</STRONG></DT>
<DD>Spherical coordinates in radians.
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082200000000000000"></A>
<A NAME="const:gridconn"></A>
<BR>
27.2.2 ESMF_GRIDCONN
</H3>

<P>
<I>DESCRIPTION:
<BR></I>

The <TT>ESMF_GridCreateShapeTile</TT> command has three specific arguments
<TT>connflagDim1</TT>, <TT>connflagDim2</TT>, and <TT>connflagDim3</TT>. These can be used
to setup different types of connections at the ends of each dimension
of a Tile.  Each of these parameters is a two element array. The first
element is the connection type at the minimum end of the dimension
and the second is the connection type at the maximum end. The default
value for all the connections is ESMF_GRIDCONN_NONE, specifying no
connection.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GridConn_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDCONN_NONE</STRONG></DT>
<DD>No connection.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_PERIODIC</STRONG></DT>
<DD>Periodic connection.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_POLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element i+n/2.

<P>
</DD>
<DT><STRONG>ESMF_GRIDCONN_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i-1.
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082300000000000000"></A>
<A NAME="const:griditem"></A>
<BR>
27.2.3 ESMF_GRIDITEM
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
The ESMF Grid can contain other kinds of data besides coordinates. 
This data is referred to as Grid ``items''. Some items may be used
by ESMF for calculations involving the Grid. The following
are the valid values of ESMF_GridItem_Flag.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GridItem_Flag)</TT>

<P>
The valid values are:
<BR>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Item Label</TD>
<TD ALIGN="CENTER"><B>Type Restriction</B></TD>
<TD ALIGN="CENTER"><B>Type Default</B></TD>
<TD ALIGN="CENTER"><B>ESMF Uses</B></TD>
<TD ALIGN="CENTER"><B>Controls</B></TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_GRIDITEM_MASK</B></TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_I4</TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_I4</TD>
<TD ALIGN="CENTER">YES</TD>
<TD ALIGN="CENTER">Masking in Regrid</TD>
</TR>
<TR><TD ALIGN="LEFT"><B>ESMF_GRIDITEM_AREA</B></TD>
<TD ALIGN="CENTER">NONE</TD>
<TD ALIGN="CENTER">ESMF_TYPEKIND_R8</TD>
<TD ALIGN="CENTER">NO</TD>
<TD ALIGN="CENTER">N/A</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION05082400000000000000"></A>
<A NAME="const:gridmatch"></A>
<BR>
27.2.4 ESMF_GRIDMATCH
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
 This type is used to indicate the level to which two grids match.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GridMatch_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDMATCH_INVALID:</STRONG></DT>
<DD>Indicates a non-valid matching level. Returned
      if an error occurs in the matching function. If a higher matching level
      is returned then no error occurred.
</DD>
<DT><STRONG>ESMF_GRIDMATCH_NONE:</STRONG></DT>
<DD>The lowest level of grid matching. 
      This indicates that the Grid's don't match at any of the higher levels. 
</DD>
<DT><STRONG>ESMF_GRIDMATCH_EXACT:</STRONG></DT>
<DD>All the pieces of the Grid (e.g. distgrids, 
      coordinates, etc.) except the name, match between the two Grids. 
</DD>
<DT><STRONG>ESMF_GRIDMATCH_ALIAS:</STRONG></DT>
<DD>Both Grid variables are aliases to the exact
      same Grid object in memory. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082500000000000000"></A>
<A NAME="const:gridstatus"></A>
<BR>
27.2.5 ESMF_GRIDSTATUS
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
The ESMF Grid class can exist in two states. These states are
present so that the library code can detect if a Grid has been
appropriately setup for the task at hand. The following
are the valid values of ESMF_GRIDSTATUS.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_GridStatus_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_GRIDSTATUS_EMPTY:</STRONG></DT>
<DD>Status after a Grid has been created with 
      <TT>ESMF_GridEmptyCreate</TT>.  A Grid object container is allocated but
      space for internal objects is not.  Topology information and coordinate
      information is incomplete.  This object can be used in <TT>ESMF_GridEmptyComplete()</TT>
      methods in which additional information is added to the Grid.
</DD>
<DT><STRONG>ESMF_GRIDSTATUS_COMPLETE:</STRONG></DT>
<DD>The Grid has a specific topology and
      distribution, but incomplete coordinate arrays.  The Grid can be used
      as the basis for allocating a Field, and coordinates can be added
      via <TT>ESMF_GridCoordAdd()</TT> to allow other functionality. 
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082600000000000000"></A>
<A NAME="const:polekind"></A>
<BR>
27.2.6 ESMF_POLEKIND
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
This type describes the type of connection that occurs at the pole when a Grid is 
created with <TT>ESMF_GridCreate1PeriodicDim()</TT>.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_PoleKind_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_POLEKIND_NONE</STRONG></DT>
<DD>No connection at pole.

<P>
</DD>
<DT><STRONG>ESMF_POLEKIND_MONOPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, then element i is connected to
element i+n/2.

<P>
</DD>
<DT><STRONG>ESMF_POLEKIND_BIPOLE</STRONG></DT>
<DD>This edge is connected to itself. Given
that the edge is n elements long, element i is connected to element n-i-1.
</DD>
</DL>

<P>

<H3><A NAME="SECTION05082700000000000000"></A>
<A NAME="const:staggerloc"></A>
<BR>
27.2.7 ESMF_STAGGERLOC
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
 In the ESMF Grid class, data can be located at different positions in a
 Grid cell.  When setting or retrieving coordinate data the stagger location is
 specified to tell the Grid method  from where in the cell to get the data. 
 Although the user may define their own custom stagger locations, 
 ESMF provides a set of predefined locations for ease of use. The
following are the valid predefined stagger locations. 

<P>

<P>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridstaggerloc2d"></A><A NAME="36855"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 15:</STRONG>
2D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}$
 -->
<IMG
 WIDTH="561" HEIGHT="345" ALIGN="BOTTOM" BORDER="0"
 SRC="img58.png"
 ALT="\scalebox{0.75}{\includegraphics{GridStaggerLoc2D}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The 2D predefined stagger locations (illustrated in figure&nbsp;<A HREF="node5.html#fig:gridstaggerloc2d">15</A>) are:
<BR><DL>
<DT><STRONG>ESMF_STAGGERLOC_CENTER:</STRONG></DT>
<DD>The center of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER:</STRONG></DT>
<DD>The corners of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1:</STRONG></DT>
<DD>The edges offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2:</STRONG></DT>
<DD>The edges offset from the center in the 2nd dimension.
</DD>
</DL>

<P>

<P>
<BR>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridstaggerloc3d"></A><A NAME="36866"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 16:</STRONG>
3D Predefined Stagger Locations</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}$
 -->
<IMG
 WIDTH="532" HEIGHT="417" ALIGN="BOTTOM" BORDER="0"
 SRC="img59.png"
 ALT="\scalebox{1.0}{\includegraphics{GridStaggerLoc3D}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The 3D predefined stagger locations (illustrated in figure&nbsp;<A HREF="node5.html#fig:gridstaggerloc3d">16</A>) are:
<BR><DL>
<DT><STRONG>ESMF_STAGGERLOC_CENTER_VCENTER:</STRONG></DT>
<DD>The center of the 3D cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER_VCENTER:</STRONG></DT>
<DD>Half way up the vertical edges of the cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 1 and the vertical dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2_VCENTER:</STRONG></DT>
<DD>The center of the face bounded by edge 2 and the vertical dimension. 
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CORNER_VFACE:</STRONG></DT>
<DD>The corners of the 3D cell.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE1_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 1st dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_EDGE2_VFACE:</STRONG></DT>
<DD>The center of the edges of the 3D cell parallel offset from the center in the 2nd dimension.
</DD>
<DT><STRONG>ESMF_STAGGERLOC_CENTER_VFACE:</STRONG></DT>
<DD>The center of the top and bottom face. The face bounded by the 1st and 2nd dimensions. 
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION05083000000000000000">
27.3 Use and Examples</A>
</H2>

<P>
This section describes the use of the ESMF Grid class. It first discusses
the more user friendly shape specific interface to the Grid. 
During this discussion it covers creation and options, 
adding stagger locations, coordinate data access, and other grid 
functionality. After this initial phase the document discusses 
the more advanced options which the user can employ should they
need more customized interaction with the Grid class.

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION05083100000000000000">
27.3.1 Create single-tile Grid shortcut method</A>
</H3>

<P>
The set of methods <TT>ESMF_GridCreateNoPeriDim()</TT>, <TT>ESMF_GridCreate1PeriDim()</TT>,
   <TT>ESMF_GridCreate2PeriDim()</TT>, <TT>ESMF_GridCreate()</TT> are shortcuts
   for building single tile logically rectangular Grids up to 
   three dimensions.

<P>
In v5.1.0, these methods support 
   all three types of distributions described in 
   Section&nbsp;<A HREF="node5.html#sec:desc:dist">27.1.4</A>: regular, irregular and arbitrary.

<P>
The ESMF Grid is cell based and so for all distribution 
   options the methods take as input the number of cells to describe
   the total index space and the number of cells to specify distribution. 

<P>
To create a Grid 
   with a regular distribution the user specifies the global
   maximum and minimum ranges of the Grid cell index space (<TT>maxIndex</TT> and
   <TT>minIndex</TT>), and the number of pieces in which to partition
   each dimension (via a <TT>regDecomp</TT> argument).
   ESMF then divides the index space as evenly as possible 
   into the specified number of pieces. If there are cells
   left over then they are distributed one per DE starting from
   the first DE until they are gone.

<P>
If <TT>minIndex</TT> is 
   not specified, then the bottom of the Grid cell index range is assumed
   to be (1,1,...,1). If <TT>regDecomp</TT> is not specified, then
   by default ESMF creates a distribution that partitions the
   grid cells in the first dimension (e.g. NPx1x1...1) as evenly 
   as possible by  the number of processors NP.
   The remaining dimensions are not partitioned.
   The dimension of the Grid is the size of <TT>maxIndex</TT>. 
   The following is an example of creating a 10x20x30 3D grid
   where the first dimensions is broken into 2 pieces, the second
   is broken into 4 pieces, and the third is "distributed" across only one processor.  

<P>
<PRE>
  grid3D=ESMF_GridCreateNoPeriDim(regDecomp=(/2,4,1/), maxIndex=(/10,20,30/), &amp;
           rc=rc)
</PRE>

<P>
Irregular distribution requires the user to specify the
   exact number of Grid cells per DE in each dimension.  In the
   <TT>ESMF_GridCreateNoPeriDim()</TT> call the <TT>countsPerDEDim1</TT>,
   <TT>countsPerDim2</TT>, and <TT>countsPerDim3</TT>
   arguments are used to specify a rectangular distribution
   containing size(countsPerDEDim1) by size(countsPerDEDim2) by
   size(countsPerDEDim3) DEs. The entries in each of these arrays
   specify the number of grid cells per DE in that dimension.
   The dimension of the grid is determined by the presence of
   <TT>countsPerDEDim3</TT>.  If it's present the Grid
   will be 3D. If just <TT>countsPerDEDim1</TT> and 
   <TT>countsPerDEDim2</TT> are specified the Grid 
   will be 2D.

<P>
The following call illustrates the creation of 
   a 10x20 two dimensional rectangular Grid distributed across six DEs
   that are arranged 2x3.  In the first dimension there are 3 grid
   cells on the first DE and 7 cells on the second DE.  The second 
   dimension has 3 DEs with 11,2, and 7 cells, respectively. 

<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/3,7/), &amp;
          countsPerDEDim2=(/11,2,7/), rc=rc)
</PRE>

<P>
To add a distributed third dimension of size 30, broken up into
   two groups of 15, the above call would be altered as follows.  

<P>
<PRE>
   grid3d=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/3,7/), &amp;
          countsPerDEDim2=(/11,2,7/), countsPerDEDim3=(/15,15/), rc=rc)
</PRE>

<P>
To make a third dimension distributed across only 1 DE, then 
   <TT>countsPerDEDim3</TT> in the call should only have a single term. 

<P>
<PRE>
   grid3D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/3,7/),  &amp;
          countsPerDEDim2=(/11,2,7/), countsPerDEDim3=(/30/), rc=rc)
</PRE>

<P>
The <TT>petMap</TT> parameter may be used to specify on to which specific PETs 
   the DEs in the Grid are assigned. Note that this parameter is only available for the 
   regular and irregular distribution types. The <TT>petMap</TT> 
   array is a 3D array, for a 3D Grid each of its dimensions correspond to a
   Grid dimension. If the Grid is 2D, then the first two dimensions correspond
   to Grid dimensions and the last dimension should be of size 1. 
   The size of each <TT>petMap</TT> dimension is
   the number of DE's along that dimension in the Grid. For a 
   regular Grid, the size is equal to the number in regDecomp 
   (i.e. <TT>size(petMap,d)=regDecomp(d)</TT> for all dimensions <TT>d</TT> in the Grid). For
   an irregular Grid the size is equal to the number of items in
   the corresponding <TT>countsPerDEDim</TT> variable (i.e. 
   <TT>size(petMap,d)=size(countsPerDEDimd)</TT> for all dimensions <TT>d</TT> in the Grid).

<P>
The <TT>petMap</TT> parameter may be used to specify on to which specific PETs 
   Each entry in <TT>petMap</TT> specifies to which PET the corresponding
   DE should be assigned. For example, <TT>petMap(3,2)=4</TT> tells the Grid
   create call to put the DE located at column 3 row 2 on PET 4.

<P>
The <TT>petMap</TT> parameter may be used to specify on to which specific PETs 
   The following example demonstrates how to specify the PET to DE association 
   for an <TT>ESMF_GridCreateNoPeriDim()</TT> call.

<P>
<PRE>
   ! allocate memory for petMap
   allocate( petMap(2,2,1) )

   ! Set petMap
   petMap(:,1,1) = (/3,2/) ! DE (1,1,1) on PET 3 and DE (2,1,1) on PET 2
   petMap(:,2,1) = (/1,0/) ! DE (1,2,1) on PET 1 and DE (2,2,1) on PET 0


   ! Let the 3D grid be be distributed only in the first two dimensions.
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/3,7/), &amp;
           countsPerDEDim2=(/7,6/), petMap=petMap, rc=rc)
</PRE>

<P>
To create an grid with arbitrary distribution, the user specifies the global minimum and maximum
   ranges of the index space with the
   arguments <TT>minIndex</TT> and <TT>maxIndex</TT>, the total number of cells and their index space locations 
   residing on the local PET through a <TT>localArbIndexCount</TT> and a <TT>localArbIndex</TT>
   argument. <TT>localArbIndex</TT> is a 2D array with size <TT>(localArbIndexCount, n)</TT> where n is the total number
   dimensions distributed arbitrarily.    
   Again, if <TT>minIndex</TT> is  not specified, then the bottom of the 
   index range is assumed to be (1,1,...). 
   The dimension of the Grid is equal to the size of <TT>maxIndex</TT>. 
   If n (number of arbitrarily distributed dimension) is less than the grid dimension, an optional
   argument <TT>distDim</TT> is used to specify which of the grid dimension is arbitrarily distributed.
   If not given, the first n dimensions are assumed to be distributed.

<P>
The following example creates a 2D Grid of dimensions 5x5, and places
   the diagonal elements (i.e. indices (i,i) where i goes from 1 to 5)
   on the local PET. The remaining PETs would individually declare
   the remainder of the Grid locations.  

<P>
<PRE>
   ! allocate memory for localArbIndex
   allocate( localArbIndex(5,2) )
   ! Set local indices
   localArbIndex(1,:)=(/1,1/)
   localArbIndex(2,:)=(/2,2/)
   localArbIndex(3,:)=(/3,3/)
   localArbIndex(4,:)=(/4,4/)
   localArbIndex(5,:)=(/5,5/)

   ! Create a 2D Arbitrarily distributed Grid
   grid2D=ESMF_GridCreateNoPeriDim(maxIndex=(/5,5/), &amp; 
         arbIndexList=localArbIndex, arbIndexCount=5, rc=rc)
</PRE>

<P>
To create a 3D Grid of dimensions 5x6x5 with the first and the third dimensions distributed arbitrarily,
   <TT>distDim</TT> is used. 

<P>
<PRE>
   ! Create a 3D Grid with the 1st and 3rd dimension arbitrarily distributed
   grid3D=ESMF_GridCreateNoPeriDim(maxIndex=(/5,6,5/), &amp; 
         arbIndexList=localArbIndex, arbIndexCount=5, &amp;
         distDim=(/1,3/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05083200000000000000"></A>
   <A NAME="example:2DRegUniGrid"></A>
<BR>
27.3.2 Create a 2D regularly distributed rectilinear Grid
                    with uniformly spaced coordinates
</H3>

<P>
The following is an example of creating a simple rectilinear grid 
   and loading in a set of coordinates. It illustrates a straightforward use
   of the <TT>ESMF_GridCreateNoPeriDim()</TT> call described in the previous section. 
   This code creates a 10x20 2D grid with uniformly spaced coordinates varying from (10,10) to (100,200).
   The grid is partitioned using a regular distribution. The first dimension
   is divided into two pieces, and the second dimension is divided into 3.
   This example assumes that the code is being run with a 1-1 mapping between 
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs. 
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! topology and distribution of the Grid, and specify that it 
   ! will have global indices.  Note that here aperiodic bounds are
   ! specified by the argument name. In this call the minIndex hasn't 
   ! been set, so it defaults to (1,1,...). The default is to 
   ! divide the index range as equally as possible among the DEs
   ! specified in regDecomp. This behavior can be changed by 
   ! specifying decompFlag. 
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateNoPeriDim(          &amp;
         ! Define a regular distribution
         maxIndex=(/10,20/), &amp; ! define index space
         regDecomp=(/2,3/),  &amp; ! define how to divide among DEs
         coordSys=ESMF_COORDSYS_CART, &amp;
         ! Specify mapping of coords dim to Grid dim
         coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
         coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
         indexflag=ESMF_INDEX_GLOBAL, &amp;
         rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp; 
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)

   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.   
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordX, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
        coordX(i) = i*10.0
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordY, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
        coordY(j) = j*10.0
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083300000000000000"></A>
   <A NAME="example:2DPeriRegUniGrid"></A>
<BR>
27.3.3 Create a periodic 2D regularly distributed rectilinear Grid
</H3>

<P>
The following is an example of creating a simple rectilinear grid 
   with a periodic dimension and loading in a set of coordinates. It illustrates a straightforward use
   of the <TT>ESMF_GridCreate1PeriDim()</TT> call described in the previous section. 
   This code creates a 10x20 2D grid with uniformly spaced coordinates varying from (1,1) to (360,180).
   The grid is partitioned using a regular distribution. The first dimension
   is divided into two pieces, and the second dimension is divided into 3.
   This example assumes that the code is being run with a 1-1 mapping between 
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs. 
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! topology and distribution of the Grid, and specify that it 
   ! will have global indices.  Note that here a single periodic connection
   ! is specified by the argument name. In this call the minIndex hasn't 
   ! been set, so it defaults to (1,1,...). The default is to 
   ! divide the index range as equally as possible among the DEs
   ! specified in regDecomp. This behavior can be changed by 
   ! specifying decompFlag. Since the coordinate system is
   ! not specified, it defaults to ESMF_COORDSYS_SPH_DEG.
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreate1PeriDim(          &amp;
         ! Define a regular distribution
         maxIndex=(/360,180/), &amp; ! define index space
         regDecomp=(/2,3/),  &amp; ! define how to divide among DEs
         ! Specify mapping of coords dim to Grid dim
         coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
         coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
         indexflag=ESMF_INDEX_GLOBAL, &amp;
         rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp; 
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)

   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.   
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordX, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
        coordX(i) = i*1.0
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordY, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
        coordY(j) = j*1.0
   enddo
</PRE>

<P>
The remaining examples in this section will use the irregular 
   distribution because of its greater generality. To create code similar to these, but
   using a regular distribution, replace the <TT>countsPerDEDim</TT> arguments
   in the Grid create with the appropriate <TT>maxIndex</TT> and <TT>regDecomp</TT> arguments. 

<P>

<H3><A NAME="SECTION05083400000000000000"></A>
   <A NAME="example:2DIrregUniGrid"></A>
<BR>
27.3.4 Create a 2D irregularly distributed rectilinear Grid
                    with uniformly spaced coordinates
</H3>

<P>
This example serves as an illustration of the difference between using
   a regular and irregular distribution. It repeats the previous example
   except using an irregular distribution to give the user more control
   over how the cells are divided between the DEs. As before, this code
   creates a 10x20 2D Grid with uniformly spaced coordinates  varying from (10,10) to (100,200).
   In this example, the Grid is partitioned using an irregular distribution. The first dimension
   is divided into two pieces, the first with 3 Grid cells per
   DE and the second with 7 Grid cells per DE. In the second dimension,
   the Grid is divided into 3 pieces, with 11, 2, and 7 cells per DE respectively.
   This example assumes that the code is being run with a 1-1 mapping between 
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs. 
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! topology and distribution of the Grid, and specify that it 
   ! will have global coordinates.  Note that aperiodic bounds are
   ! indicated by the method name. In this call the minIndex hasn't 
   ! been set, so it defaults to (1,1,...).
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateNoPeriDim(          &amp;
            ! Define an irregular distribution
            countsPerDEDim1=(/3,7/),    &amp;
            countsPerDEDim2=(/11,2,7/), &amp;
            ! Specify mapping of coords dim to Grid dim
            coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
            coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
            indexflag=ESMF_INDEX_GLOBAL, &amp; 
            rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp; 
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)

   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.   
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordX, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
        coordX(i) = i*10.0
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordY, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
        coordY(j) = j*10.0
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083500000000000000"></A>
   <A NAME="example:2DIrregCurviGrid"></A>
<BR>
27.3.5 Create a 2D irregularly distributed Grid
                    with curvilinear coordinates
</H3>

<P>
The following is an example of creating a simple curvilinear Grid and
   loading in a set of coordinates. It creates a 10x20
   2D Grid where the coordinates vary along every dimension. 
   The Grid is partitioned using an irregular distribution. The first dimension
   is divided into two pieces, the first with 3 Grid cells per
   DE and the second with 7 Grid cells per DE. In the second dimension,
   the Grid is divided into 3 pieces, with 11, 2, and 7 cells per DE respectively.
   This example assumes that the code is being run with a 1-1 mapping between 
   PETs and DEs because we are only accessing the first DE on each PET (localDE=0).
   Because we have 6 DEs (2x3), this example would only work when run on 6 PETs. 
   The Grid is created with global indices. After Grid creation the
   local bounds and native Fortran arrays are retrieved and the
   coordinates are set by the user. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object, define the
   ! distribution of the Grid, and specify that it 
   ! will have global indices.  Note that aperiodic bounds are
   ! indicated by the method name. If periodic bounds were desired they
   ! could be specified by using the ESMF_GridCreate1PeriDim() call.
   ! In this call the minIndex hasn't been set, so it defaults to (1,1,...).
   !-------------------------------------------------------------------
   grid2D=ESMF_GridCreateNoPeriDim(      &amp;
        ! Define an irregular distribution
        countsPerDEDim1=(/3,7/),     &amp;
        countsPerDEDim2=(/11,2,7/),   &amp;
        ! Specify mapping of coords dim to Grid dim
        coordDep1=(/1,2/), &amp; ! 1st coord is 2D and depends on both Grid dim
        coordDep2=(/1,2/), &amp; ! 2nd coord is 1D and depends on both Grid dim
        indexflag=ESMF_INDEX_GLOBAL, &amp;
        rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage and associate it with the center
   ! stagger location.  Since no coordinate values are specified in
   ! this call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D,  &amp; 
          staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)

   !-------------------------------------------------------------------
   ! Get the pointer to the first coordinate array and the bounds
   ! of its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=1, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordX2D, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension [10-100].
   !-------------------------------------------------------------------
   do j=lbnd(2),ubnd(2)
   do i=lbnd(1),ubnd(1)
        coordX2D(i,j) = i+j
   enddo
   enddo

   !-------------------------------------------------------------------
   ! Get the pointer to the second coordinate array and the bounds of 
   ! its global indices on the local DE.
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=coordY2D, rc=rc)

   !-------------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension [10-200]
   !-------------------------------------------------------------------
   do j=lbnd(2),ubnd(2)
   do i=lbnd(1),ubnd(1)
        coordY2D(i,j) = j-i/100.0
   enddo
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083600000000000000"></A>
   <A NAME="example:CurviGridWithUndistDim"></A>
<BR>
27.3.6 Create an irregularly distributed rectilinear Grid with
                  a non-distributed vertical dimension
</H3>

<P>
This example demonstrates how a user can build a rectilinear 
   horizontal Grid with a non-distributed vertical dimension. The Grid 
   contains both the center and corner stagger locations (i.e. Arakawa 
   B-Grid). In contrast to the previous examples, this example doesn't
   assume that the code is being run with a 1-1 mapping between 
   PETs and DEs. It should work when run on any number of PETs.

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object.  The
   ! Grid is defined to be 180 Grid cells in the first dimension
   ! (e.g. longitude), 90 Grid cells in the second dimension 
   ! (e.g. latitude), and 40 Grid cells in the third dimension 
   ! (e.g. height).  The first dimension is decomposed over 4 DEs, 
   ! the second over 3 DEs, and the third is not distributed.  
   ! The connectivities in each dimension are set to aperiodic 
   ! by this method. In this call the minIndex hasn't been set, 
   ! so it defaults to (1,1,...). 
   !-------------------------------------------------------------------
   grid3D=ESMF_GridCreateNoPeriDim( &amp;
            ! Define an irregular distribution
            countsPerDEDim1=(/45,75,40,20/), &amp;
            countsPerDEDim2=(/30,40,20/),    &amp;
            countsPerDEDim3=(/40/),          &amp;
            ! Specify mapping of coords dim to Grid dim
            coordDep1=(/1/), &amp; ! 1st coord is 1D and depends on 1st Grid dim
            coordDep2=(/2/), &amp; ! 2nd coord is 1D and depends on 2nd Grid dim
            coordDep3=(/3/), &amp; ! 3rd coord is 1D and depends on 3rd Grid dim
            indexflag=ESMF_INDEX_GLOBAL,     &amp; ! Use global indices
            rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage for both center and corner stagger
   ! locations.  Since no coordinate values are specified in this
   ! call no coordinate values are set yet.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER, rc=rc)
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER_VCENTER, rc=rc)


   !-------------------------------------------------------------------
   ! Get the number of DEs on this PET, so that the program
   ! can loop over them when accessing data.
   !-------------------------------------------------------------------
   call ESMF_GridGet(grid3D, localDECount=localDECount, rc=rc)

   !-------------------------------------------------------------------
   ! Loop over each localDE when accessing data
   !-------------------------------------------------------------------
   do lDE=0,localDECount-1

    !------------------------------------------------------------------
    ! Fill in the coordinates for the corner stagger location first.
    !------------------------------------------------------------------
      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the first
      ! coordinate array on the local DE. If the number of PETs
      ! is less than the total number of DEs then the rest of this
      ! example would be in a loop over the local DEs.  Also get the
      ! pointer to the first coordinate array. 
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=lDE, &amp;
             staggerLoc=ESMF_STAGGERLOC_CORNER_VCENTER,       &amp;
             computationalLBound=lbnd_corner,                 &amp;
             computationalUBound=ubnd_corner,                 &amp;
             farrayPtr=cornerX, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set coordinates in the first dimension.
      !----------------------------------------------------------------
      do i=lbnd_corner(1),ubnd_corner(1)
         cornerX(i) = (i-1)*(360.0/180.0)
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the second
      ! coordinate array on the local DE.  Also get the pointer to the
      ! second coordinate array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=lDE,   &amp;
             staggerLoc=ESMF_STAGGERLOC_CORNER_VCENTER,         &amp;
             computationalLBound=lbnd_corner,                   &amp;
             computationalUBound=ubnd_corner,                   &amp;
             farrayPtr=cornerY, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set coordinates in the second dimension.
      !----------------------------------------------------------------
      do j=lbnd_corner(1),ubnd_corner(1)
         cornerY(j) = (j-1)*(180.0/90.0)
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the third
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=lDE,   &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,         &amp;
             computationalLBound=lbnd, computationalUBound=ubnd,&amp;
             farrayPtr=cornerZ, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set the vertical coordinates
      !----------------------------------------------------------------
      do k=lbnd(1),ubnd(1)
         cornerZ(k) = 4000.0*( (1./39.)*(k-1)  )**2
      enddo

    !------------------------------------------------------------------
    ! Now fill the coordinates for the center stagger location with
    ! the average of the corner coordinate location values.
    !------------------------------------------------------------------
      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the first 
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=lDE,    &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,          &amp;
             computationalLBound=lbnd, computationalUBound=ubnd, &amp;
             farrayPtr=centerX, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set coordinates in the first dimension.
      !----------------------------------------------------------------
      do i=lbnd(1),ubnd(1)
         centerX(i) = 0.5*(i-1 + i)*(360.0/180.0) 
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the second
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
       call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=lDE,    &amp;
              staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,          &amp;
              computationalLBound=lbnd, computationalUBound=ubnd, &amp;
              farrayPtr=centerY, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set coordinates in the second dimension.
      !----------------------------------------------------------------
      do j=lbnd(1),ubnd(1)
         centerY(j) = 0.5*(j-1 + j)*(180.0/90.0) 
      enddo

      !----------------------------------------------------------------
      ! Get the local bounds of the global indexing for the third
      ! coordinate array on the local DE, and the pointer to the array.
      !----------------------------------------------------------------
      call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=lDE,   &amp;
             staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER,         &amp;
             computationalLBound=lbnd, computationalUBound=ubnd,&amp;
             farrayPtr=centerZ, rc=rc)

      !----------------------------------------------------------------
      ! Calculate and set the vertical coordinates
      !----------------------------------------------------------------
      do k=lbnd(1),ubnd(1)
         centerZ(k) = 4000.0*( (1./39.)*(k-1)  )**2
      enddo

   !-------------------------------------------------------------------
   ! End of loop over DEs
   !-------------------------------------------------------------------
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083700000000000000"></A>
   <A NAME="example:ArbGridWithUndistDim"></A>
<BR>
27.3.7 Create an arbitrarily distributed rectilinear Grid with
                  a non-distributed vertical dimension
</H3>

<P>
There are more restrictions in defining an arbitrarily distributed grid.  
   First, there is always one DE per PET.  Secondly, only local index (<TT>ESMF_INDEX_LOCAL</TT>)
   is supported. Third, only one stagger location, i.e. <TT>ESMF_STAGGERLOC_CENTER</TT> is allowed
   and last there is no extra paddings on the edge of the grid.

<P>
This example demonstrates how a user can build a 3D grid with its rectilinear 
   horizontal Grid distributed arbitrarily and a non-distributed vertical dimension.

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Set up the local index array:  Assuming the grid is 360x180x10.  First
   ! calculate the localArbIndexCount and localArbIndex array for each PET 
   ! based on the total number of PETS. The cells are evenly distributed in 
   ! all the PETs. If the total number of cells are not divisible by the 
   ! total PETs, the remaining cells are assigned to the last PET.  The 
   ! cells are card dealed to each PET in y dimension first, 
   ! i.e. (1,1) -&gt; PET 0, (1,2)-&gt;  PET 1, (1,3)-&gt; PET 2, and so forth.  
   !-------------------------------------------------------------------
   xdim = 360
   ydim = 180
   zdim = 10
   localArbIndexCount = (xdim*ydim)/petCount
   remain = (xdim*ydim)-localArbIndexCount*petCount
   if (localPet == petCount-1) localArbIndexCount = localArbIndexCount+remain

   allocate(localArbIndex(localArbIndexCount,2))
   ind = localPet
   do i=1, localArbIndexCount
      localArbIndex(i,1)=mod(ind,ydim)+1
      localArbIndex(i,2)=ind/ydim + 1
      ind = ind + petCount
   enddo
   if (localPet == petCount-1) then
      ind = xdim*ydim-remain+1
      do i=localArbIndexCount-remain+1,localArbIndexCount
         localArbIndex(i,1)=mod(ind,ydim)+1
         localArbIndex(i,2)=ind/ydim+1
         ind = ind + 1
      enddo
   endif

   !-------------------------------------------------------------------
   ! Create the Grid:  Allocate space for the Grid object.  
   ! the minIndex hasn't been set, so it defaults to (1,1,...). The
   ! default coordDep1 and coordDep2 are (/ESMF_DIM_ARB/) where 
   ! ESMF_DIM_ARB represents the collapsed dimension for the 
   ! arbitrarily distributed grid dimensions.  For the undistributed
   ! grid dimension, the default value for coordDep3 is (/3/).  The
   ! default values for coordDepX in the arbitrary distribution are
   ! different from the non-arbitrary distributions.
   !-------------------------------------------------------------------
   grid3D=ESMF_GridCreateNoPeriDim( &amp;
	    maxIndex = (/xdim, ydim, zdim/), &amp;
            arbIndexList = localArbIndex, &amp;
            arbIndexCount = localArbIndexCount, &amp;
            rc=rc)

   !-------------------------------------------------------------------
   ! Allocate coordinate storage for the center stagger location, the 
   ! only stagger location supported for the arbitrary distribution.
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid3D, &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER_VCENTER, rc=rc)

   !------------------------------------------------------------------
   ! Fill in the coordinates for the center stagger location. There is
   ! always one DE per PET, so localDE is always 0
   !------------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=1, localDE=0, &amp;
          staggerLoc=ESMF_STAGGERLOC_CENTER,       &amp;
          computationalLBound=lbnd,                 &amp;
          computationalUBound=ubnd,                 &amp;
          farrayPtr=centerX, rc=rc)


   !----------------------------------------------------------------
   ! Calculate and set coordinates in the first dimension.
   !----------------------------------------------------------------
   do i=lbnd(1),ubnd(1)
      centerX(i) = (localArbIndex(i,1)-0.5)*(360.0/xdim)
   enddo


   !----------------------------------------------------------------
   ! Get the local bounds of the global indexing for the second
   ! coordinate array on the local DE, and the pointer to the array.
   !----------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=2, localDE=0,    &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER,                  &amp;
          computationalLBound=lbnd, computationalUBound=ubnd, &amp;
          farrayPtr=centerY, rc=rc)

   !----------------------------------------------------------------
   ! Calculate and set coordinates in the second dimension.
   !----------------------------------------------------------------
   do j=lbnd(1),ubnd(1)
      centerY(j) = (localArbIndex(j,2)-0.5)*(180.0/ydim)-90.0 
   enddo

   !----------------------------------------------------------------
   ! Get the local bounds of the global indexing for the third
   ! coordinate array on the local DE, and the pointer to the array.
   !----------------------------------------------------------------
   call ESMF_GridGetCoord(grid3D, coordDim=3, localDE=0,   &amp;
          staggerloc=ESMF_STAGGERLOC_CENTER,               &amp;
          computationalLBound=lbnd, computationalUBound=ubnd,&amp;
          farrayPtr=centerZ, rc=rc)

   !----------------------------------------------------------------
   ! Calculate and set the vertical coordinates
   !----------------------------------------------------------------
   do k=lbnd(1),ubnd(1)
      centerZ(k) = 4000.0*( (1./zdim)*(k-1))**2
   enddo
</PRE>

<P>

<H3><A NAME="SECTION05083800000000000000"></A><A NAME="sec:example:2DLogRecFromScrip"></A>
<BR>
27.3.8 Create a curvilinear Grid using the coordinates defined 
   in a SCRIP file
</H3>

<P>
ESMF supports the creation of a 2D curvilinear Grid using the coordinates 
   defined in a SCRIP format Grid file&nbsp;[<A
 HREF="node8.html#ref:SCRIP">13</A>]. The grid contained in the 
   file must be a 2D logically rectangular grid with <TT>grid_rank</TT> in the file set
   to 2.  The center coordinates variables <TT>grid_center_lat</TT> and <TT>grid_center_lon</TT> in the file
   are placed in the ESMF_STAGGERLOC_CENTER location.  If the parameter <TT>addCornerStagger</TT>
   in the <TT>ESMF_GridCreate</TT> call is set to .true., then 
   the variables <TT>grid_corner_lat</TT> and <TT>grid_corner_lon</TT> in the file
   are used to set the ESMF_STAGGERLOC_CORNER coordinates, otherwise they are ignored.
   The values in the <TT>grid_imask</TT> variable in the file are used to set the ESMF_GRIDITEM_MASK in the Grid.

<P>
The following example code shows you how to create a 2D Grid with both center and corner coordinates
   using a SCRIP file and a row only regular distribution: 

<P>
<PRE>
   grid2D = ESMF_GridCreate(filename="data/T42_grid.nc", &amp;
              regDecomp=(/PetCount,1/), addCornerStagger=.true., rc=rc)
</PRE>

<P>
Where T42_grid.nc is a 2D global grid of size (128x64) and the resulting Grid is distributed
    by partitioning the rows evenly over all the PETs. 

<P>

<H3><A NAME="SECTION05083900000000000000"></A><A NAME="sec:usage:setcommit"></A>
<BR>
27.3.9 Create an empty Grid in a parent Component 
   for completion in a child Component
</H3>

<P>
ESMF Grids can be created incrementally. To do this,
   the user first calls <TT>ESMF_GridEmptyCreate()</TT> to allocate the shell of
   a Grid. Next, we use the <TT>ESMF_GridEmptyComplete()</TT>
   call that fills in the Grid and does an internal commit to make it usable.
   For consistency's sake the <TT>ESMF_GridSetCommitShapeTile()</TT>
   call must occur on the same or a subset of the PETs as the
    <TT>ESMF_GridEmptyCreate()</TT> call. The 
   <TT>ESMF_GridEmptyComplete()</TT> call uses the VM for
   the context in which it's executed and the "empty" Grid contains
   no information about the VM in which its create was run.  This
   means that if the <TT>ESMF_GridEmptyComplete()</TT> call occurs
   in a subset of the PETs in which the <TT>ESMF_GridEmptyCreate()</TT> was 
   executed that the Grid is created only in that subset. Inside the subset
   the Grid will be fine, but outside the subset the Grid objects will
   still be "empty" and not usable. The following example uses the
   incremental technique to create a rectangular 10x20 Grid with coordinates at
   the center and corner stagger locations.

<P>
<PRE>
!---------------------------------------------------------------------------
! IN THE PARENT COMPONENT:
! Create an empty Grid in the parent component for use in a child component.
! The parent may be defined on more PETs than the child component.  
! The child's [vm or pet list] is passed into the create call so that
! the Grid is defined on the appropriate subset of the parent's PETs. 
!---------------------------------------------------------------------------
   grid2D=ESMF_GridEmptyCreate(rc=rc)

!---------------------------------------------------------------------------
! IN THE CHILD COMPONENT:
! Set the Grid topology.  Here we define an irregularly distributed 
! rectangular Grid.
!---------------------------------------------------------------------------
   call ESMF_GridEmptyComplete(grid2D,             &amp;
                          countsPerDEDim1=(/6,4/),      &amp;
                          countsPerDEDim2=(/10,3,7/), rc=rc)

!---------------------------------------------------------------------------
! Add Grid coordinates at the cell center location.
!---------------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CENTER, rc=rc)

!---------------------------------------------------------------------------
! Add Grid coordinates at the corner stagger location.
!---------------------------------------------------------------------------
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831000000000000000"></A>
  <A NAME="sec:usage:staggerloc"></A>
<BR>
27.3.10 Grid stagger locations
</H3>

<P>
A useful finite difference technique is to place different physical 
   quantities at different locations within a grid cell. This
   <EM>staggering</EM> of the physical variables on the mesh is introduced so
   that the difference of a field is naturally defined at the location of 
   another variable. This method was first formalized by Mesinger and Arakawa 
   (1976).

<P>
To support the staggering of variables, the Grid provides
   the idea of <EM>stagger locations</EM>. 
   Stagger locations refer to the places in a Grid cell that 
   can contain coordinates or other data and once a Grid is associated with a 
   Field object, field data. Typically Grid data can be located
   at the cell center, at the cell corners, or at the cell faces, in 2D, 3D, and
   higher dimensions. (Note that any Arakawa stagger can be constructed
   of a set of Grid stagger locations.)  There are predefined stagger locations
   (see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A>), or,
   should the user wish to specify their own, there
   is also a set of methods for generating custom locations 
   (See Section&nbsp;<A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>).
   Users can put Grid data (e.g. coordinates) 
   at multiple stagger locations in a Grid. In addition, the user can create a Field
   at any of the stagger locations in a Grid. 

<P>
By default the Grid data array at the center stagger location
   starts at the bottom index of the Grid (default (1,1..,1)) and extends
   up to the maximum cell index in the Grid (e.g. given by the <TT>maxIndex</TT> argument).
   Other stagger locations also start at the bottom index of the Grid, however, 
   they can extend to +1 element beyond the center in some dimensions to allow
   for the extra space to surround the center elements. See Section&nbsp;<A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>
   for a description of this extra space and how to adjust if it necessary. 
   There are <TT>ESMF_GridGet</TT> subroutines (e.g. <TT>ESMF_GridGetCoord()</TT> or <TT>ESMF_GridGetItem()</TT>)
   which can be used to retrieve the stagger bounds for the piece of Grid data 
   on a particular DE.  

<P>

<H3><A NAME="SECTION050831100000000000000">
27.3.11 Associate coordinates with stagger locations</A>
</H3>

<P>
The primary type of data the Grid is resposible for storing is coordinates. 
   The coordinate values in a Grid can be employed by the user in calculations or
   to describe the geometry of a Field. The Grid coordinate values are also used by 
   <TT>ESMF_FieldRegridStore()</TT> when calculating the interpolation
   matrix between two Fields. The user can allocate coordinate arrays without setting coordinate values 
   using the <TT>ESMF_GridAddCoord()</TT> call. (See Section&nbsp;<A HREF="node5.html#sec:usage:coords:accessing">27.3.13</A> for a discussion of
   setting/getting coordinate values.) When adding or accessing
   coordinate data, the stagger location is specified to tell the Grid method 
   where in the cell to get the data. The different stagger locations may also have slightly different
   index ranges and sizes.  Please see Section&nbsp;<A HREF="node5.html#sec:usage:staggerloc">27.3.10</A> for a discussion of 
   Grid stagger locations. 

<P>
The following example adds coordinate storage to the corner stagger location in a Grid using one 
   of the predefined stagger locations. 

<P>
<PRE>
   call ESMF_GridAddCoord(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, rc=rc)
</PRE>

<P>
Note only the center stagger location <TT>ESMF_STAGGERLOC_CENTER</TT> is supported 
   in an arbitrarily distributed Grid. 

<P>

<H3><A NAME="SECTION050831200000000000000">
27.3.12 Specify the relationship of coordinate Arrays
                 to index space dimensions</A>
</H3>

<P>
To specify how the coordinate arrays are mapped to the 
   index dimensions the arguments <TT>coordDep1</TT>, 
   <TT>coordDep2</TT>, and <TT>coordDep3</TT> are used, each 
   of which is a Fortran array. The values of the elements
   in a <TT>coordDep</TT> array specify which index dimension
   the corresponding coordinate dimension
   maps to.  For example, <TT>coordDep1=(/1,2/)</TT> means that
   the first dimension of coordinate 1 maps to index
   dimension 1 and the second maps to index dimension 2. 
   For a grid with non-arbitrary distribution, the default
   values for <TT>coordDep1</TT>, <TT>coordDep2</TT> and <TT>coordDep3</TT>
   are <TT>/1,2..,gridDimCount/</TT>.  This default  
   thus specifies a curvilinear grid.  

<P>
The following call demonstrates the creation of a
   10x20 2D rectilinear grid where the first coordinate
   component is mapped to the second index dimension
   (i.e. is of size 20) and the second coordinate component
   is mapped to the first index dimension (i.e. is of size
   10). 

<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/5,5/), &amp;
          countsPerDEDim2=(/7,7,6/),                    &amp;
          coordDep1=(/2/),                              &amp;
          coordDep2=(/1/), rc=rc)
</PRE>

<P>
The following call demonstrates the creation of a
   10x20x30 2D plus 1 curvilinear grid where 
   coordinate component 1 and 2 are still 10x20, but
   coordinate component 3 is mapped just to the 
   third index dimension. 

<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/6,4/), &amp;
          countsPerDEDim2=(/10,7,3/), countsPerDEDim3=(/30/), &amp;
          coordDep1=(/1,2/), coordDep2=(/1,2/), &amp;
          coordDep3=(/3/), rc=rc)
</PRE>

<P>
By default the local piece of the array on each PET starts at 
   (1,1,..), however, the indexing for each grid coordinate array  
   on each DE may be shifted to the global indices by using the <TT>indexflag</TT>.
   For example, the following call switches the grid to use global indices.  

<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/6,4/), &amp;
           countsPerDEDim2=(/10,7,3/), indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
For an arbitrarily distributed grid, the default value of a coordinate
   array dimension is <TT>ESMF_DIM_ARB</TT> if the index dimension is arbitrarily
   distributed and is <TT>n</TT> where <TT>n</TT> is the index dimension itself when it is not
   distributed. The following call is equivalent to the example in 
   Section <A HREF="node5.html#example:ArbGridWithUndistDim">27.3.7</A>  

<P>
<PRE>
   grid3D=ESMF_GridCreateNoPeriDim( &amp;
	    maxIndex = (/xdim, ydim, zdim/), &amp;
            arbIndexList = localArbIndex, &amp;
            arbIndexCount = localArbIndexCount,	 &amp;
 	    coordDep1 = (/ESMF_DIM_ARB/), &amp;
	    coordDep2 = (/ESMF_DIM_ARB/), &amp;
	    coordDep3 = (/3/), &amp;
            rc=rc)
</PRE>

<P>
The following call uses non-default <TT>coordDep1</TT>, <TT>coordDep2</TT>, 
   and <TT>coordDep3</TT> to create a 3D curvilinear grid with its horizontal
   dimensions arbitrarily distributed.  

<P>
<PRE>
   grid3D=ESMF_GridCreateNoPeriDim( &amp;
	    maxIndex = (/xdim, ydim, zdim/), &amp;
            arbIndexList = localArbIndex, &amp;
            arbIndexCount = localArbIndexCount,	 &amp;
 	    coordDep1 = (/ESMF_DIM_ARB, 3/), &amp;
	    coordDep2 = (/ESMF_DIM_ARB, 3/), &amp;
	    coordDep3 = (/ESMF_DIM_ARB, 3/), &amp;
            rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831300000000000000"></A>
  <A NAME="sec:usage:coords:accessing"></A>
<BR>
27.3.13 Access coordinates
</H3>

<P>
Once a Grid has been created, the user has several options to access
   the Grid coordinate data. The first of these, <TT>ESMF_GridSetCoord()</TT>, 
   enables the user to use ESMF Arrays to set data 
   for one stagger location across the whole Grid. 
   For example, the following sets the coordinates in the first dimension 
   (e.g. x) for the corner stagger location to 
   those in the ESMF Array <TT>arrayCoordX</TT>. 

<P>
<PRE>
   call ESMF_GridSetCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          coordDim=1, array=arrayCoordX, rc=rc)
</PRE>

<P>
The method <TT>ESMF_GridGetCoord()</TT> allows the user
   to obtain a reference to an ESMF Array which
   contains the coordinate data for a stagger location in a Grid. The user
   can then employ any of the standard <TT>ESMF_Array</TT> tools to operate
   on the data. The following copies the coordinates from the second 
   component of the corner and puts it into the ESMF Array <TT>arrayCoordY</TT>.  

<P>
<PRE>
   call ESMF_GridGetCoord(grid2D,    &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,    &amp;
          coordDim=2,                           &amp;
          array=arrayCoordY, rc=rc)
</PRE>

<P>
Alternatively, the call <TT>ESMF_GridGetCoord()</TT> gets a Fortran pointer to 
   the coordinate data. The user can then operate on this array in the usual
   manner. The following call gets a reference to the
   Fortran array which holds the data for the second coordinate (e.g. y).  

<P>
<PRE>
   call ESMF_GridGetCoord(grid2D, coordDim=2, localDE=0, &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER, farrayPtr=coordY2D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831400000000000000"></A>
  <A NAME="sec:usage:items"></A>
<BR>
27.3.14 Associate items with stagger locations
</H3>

<P>
The ESMF Grids contain the ability to store other kinds of 
   data beyond coordinates. These kinds of data are referred to 
   as "items". Although the user is free to use this
   data as they see fit, the user should be aware that
   this data may also be used by other parts of ESMF (e.g. the 
   ESMF_GRIDITEM_MASK item is used in regridding). 
   Please see Section&nbsp;<A HREF="node5.html#const:griditem">27.2.3</A> for a list of valid
   items.

<P>
Like coordinates items are also created on stagger locations.
   When adding or accessing item data, the stagger location is specified to tell the Grid method 
   where in the cell to get the data. The different stagger locations may also have slightly different
   index ranges and sizes.  Please see Section&nbsp;<A HREF="node5.html#sec:usage:staggerloc">27.3.10</A> for a discussion of 
   Grid stagger locations.  The user can 
   allocate item arrays without setting item values using the <TT>ESMF_GridAddItem()</TT> call. 
   (See Section&nbsp;<A HREF="node5.html#sec:usage:items:accessing">27.3.15</A> for a discussion of setting/getting item values.) 

<P>
The following example adds mask item storage to the corner stagger location in a grid. 

<P>
<PRE>
   call ESMF_GridAddItem(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          itemflag=ESMF_GRIDITEM_MASK, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831500000000000000"></A>
  <A NAME="sec:usage:items:accessing"></A>
<BR>
27.3.15 Access items
</H3>
   
   Once an item has been added to a Grid, the user has several options to access
   the data. The first of these, <TT>ESMF_GridSetItem()</TT>, 
   enables the user to use ESMF Arrays to set data for one stagger location across the whole Grid. 
   For example, the following sets the mask item in the corner stagger location to 
   those in the ESMF Array <TT>arrayMask</TT>.

<P>
<PRE>
   call ESMF_GridSetItem(grid2D,             &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          itemflag=ESMF_GRIDITEM_MASK, array=arrayMask, rc=rc)
</PRE>

<P>
The method <TT>ESMF_GridGetItem()</TT> allows the user
   to get a reference to the Array which
   contains item data for a stagger location on a Grid. The user
   can then employ any of the standard <TT>ESMF_Array</TT> tools to operate
   on the data. The following gets the mask data from the corner 
   and puts it into the ESMF Array <TT>arrayMask</TT>.  

<P>
<PRE>
   call ESMF_GridGetItem(grid2D,             &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          itemflag=ESMF_GRIDITEM_MASK,           &amp;
          array=arrayMask, rc=rc)
</PRE>

<P>
Alternatively, the call <TT>ESMF_GridGetItem()</TT> gets a Fortran pointer to 
   the item data. The user can then operate on this array in the usual
   manner. The following call gets a reference to the
   Fortran array which holds the data for the mask data.  

<P>
<PRE>
   call ESMF_GridGetItem(grid2D, localDE=0,   &amp;
          staggerloc=ESMF_STAGGERLOC_CORNER,  &amp;
          itemflag=ESMF_GRIDITEM_MASK, farrayPtr=mask2D, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831600000000000000"></A>
  <A NAME="sec:grid:usage:bounds"></A>
<BR>
27.3.16 Grid regions and bounds
</H3>

<P>
Like an Array or a Field, the index space of each 
   stagger location in the Grid contains an exclusive region, a 
   computational region and a total region. Please 
   see Section&nbsp;<A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A>
   for an in depth description of these regions.

<P>
The exclusive region is the index space defined by the 
   distgrid of each stagger location of the Grid. This region 
   is the region which is owned by the DE and is the region 
   operated on by communication methods such as <TT>ESMF_FieldRegrid()</TT>.
   The exclusive region for a stagger location is based on the 
   exclusive region defined by the DistGrid used to create the Grid.
   The size of the stagger exclusive region is the index space for the 
   Grid cells, plus the stagger padding.

<P>
The default stagger padding depends on the topology of the Grid. 
   For an unconnected dimension the stagger padding is a width
   of 1 on the upper side (i.e. <TT>gridEdgeUWidth=(1,1,1,1...)</TT>).
   For a periodic dimension there is no stagger padding.
   By adjusting <TT>gridEdgeLWidth</TT> and <TT>gridEdgeUWidth</TT>, the 
   user can set the stagger padding for the whole Grid and
   thus the exclusive region can be adjusted at will around the 
   index space corresponding to the cells. The user can
   also use <TT>staggerEdgeLWidth</TT> and <TT>staggerEdgeUWidth</TT> to
   adjust individual stagger location padding within the
   Grid's padding (Please see Section&nbsp;<A HREF="node5.html#sec:usage:staggerpadding:adv">27.3.23</A> for
   further discussion of customizing the stagger padding).

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridexreg"></A><A NAME="37298"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 17:</STRONG>
An example of a Grid's exclusive region for the corner stagger</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridExclusiveReg}}$
 -->
<IMG
 WIDTH="669" HEIGHT="324" ALIGN="BOTTOM" BORDER="0"
 SRC="img60.png"
 ALT="\scalebox{0.75}{\includegraphics{GridExclusiveReg}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
Figure&nbsp;<A HREF="node5.html#fig:gridexreg">17</A> shows an example of a Grid exclusive region for the
   <TT>ESMF_STAGGERLOC_CORNER</TT> stagger with default
   stagger padding. This exclusive region would be for a Grid generated by either of the
   following calls: 

<P>
<PRE>
  grid2D=ESMF_GridCreateNoPeriDim(regDecomp=(/2,4/), maxIndex=(/5,15/), &amp;
           indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
<PRE>
  grid2D=ESMF_GridCreateNoPeriDim(countsPerDEDim1=(/4,4,4,3/), &amp;
           countsPerDEDim2=(/3,2/), indexflag=ESMF_INDEX_GLOBAL, rc=rc)
</PRE>

<P>
Each rectangle in this diagram represents a DE and the numbers along the sides
   are the index values of the locations in the DE. Note that the exclusive region 
   has one extra index location in each dimension than the number of cells
   because of the padding for the larger corner stagger location. 

<P>
The computational region is a user setable region which can be used
   to distinguish a particular area for computation. The Grid doesn't
   currently contain functionality to let the user set the computational
   region so it defaults to the exclusive region, however, if the
   user sets an Array holding different computational bounds into the 
   Grid then that Array's computational bounds will be used.

<P>
The total region is the outermost boundary of the memory allocated 
   on each DE to hold the data for the stagger location on that DE. This region 
   can be as small as the exclusive region, but may be larger to 
   include space for halos, memory padding, etc. The total region is
   what is enlarged to include space for halos, and the total region 
   must be large enough to contain the maximum halo operation on the
   Grid. The Grid doesn't currently contain functionality to let the 
   user set the total region so it defaults to the exclusive region,
   however, if the
   user sets an Array holding different total bounds into the 
   Grid then that Array's total bounds will be used.

<P>
The user can retrieve a set of bounds for each index space region 
   described above: exclusive bounds, computational bounds, 
   and total bounds. Note that although some of these are similar
   to bounds provided by ESMF_Array subroutines 
   (see Section&nbsp;<A HREF="node5.html#Array_regions_and_default_bounds">24.2.6</A>) 
   the format here is different. The Array bounds are only for
   distributed dimensions and are ordered to correspond 
   to the dimension order in the associated DistGrid. The bounds
   provided by the Grid are ordered according to the order of dimensions of the data
   in question. This means that the bounds provided should be usable
   "as is" to access the data. 

<P>
Each of the three types of bounds refers to the maximum and minimum
   per dimension of the index ranges of a particular region. The paramters
   referring to the maximums contain a 'U' for upper. The parameters referring 
   to the minimums contain an 'L' for lower. The bounds and associated
   quantities are almost always given on a per DE basis. The three types of
   bounds <TT>exclusiveBounds</TT>, <TT>computationalBounds</TT>, and <TT>totalBounds</TT> refer
   to the ranges of the exlusive region, the computational region, and the
   total region. Each of these bounds also has a corresponding count parameter
   which gives the number of items across that region (on a DE) in each dimension.
   (e.g. <TT>totalCount(d)=totallUBound(i)-totalLBound(i)+1</TT>). Width parameters
   give the spacing between two different types of region. The
   <TT>computationalWidth</TT> argument gives the spacing between the exclusive
   region and the computational region. The <TT>totalWidth</TT> argument gives the 
   spacing between the total region and the computational region. Like the 
   other bound information these are typically on a per DE basis, for example
   specifying <TT>totalLWidth=(1,1)</TT> makes the bottom of the total
   region one lower in each dimension than the computational region on
   each DE. The exceptions to the per DE rule are
   <TT>staggerEdgeWidth</TT>, and <TT>gridEdgeWidth</TT>
   which give the spacing only on the DEs along the boundary of the Grid.

<P>
All the above bound discussions only apply to the grid with non-arbitrary distributions,
   i.e., regular or irregular distributions.  For an arbitrarily distributed grid, 
   only center stagger location is supported and there is no padding around the grid.
   Thus, the exclusive bounds, the total bounds and the computational bounds are identical 
   and <TT>staggerEdgeWidth</TT>, and <TT>gridEdgeWidth</TT> are all zeros. 

<P>

<H3><A NAME="SECTION050831700000000000000">
27.3.17 Get Grid coordinate bounds</A>
</H3>

<P>
When operating on coordinates the user may often wish to 
   retrieve the bounds of the piece of coordinate data on
   a particular local DE. This is useful for iterating through the
   data to set coordinates, retrieve coordinates, or do calculations. 
   The method <TT>ESMF_GridGetCoord</TT> allows the user
   to retrieve bound information for a particular coordinate
   array. 

<P>
As described in the previous section there are three types of bounds the user can 
   get: exclusive bounds, computational bounds, 
   and total bounds. The bounds
   provided by <TT>ESMF_GridGetCoordBounds</TT> are for both distributed
   and undistributed dimensions and are ordered according to the
   order of dimensions in the  coordinate. This means that the bounds
    provided should be usable
   "as is" to access data in the coordinate array. In the case
   of factorized coordinate Arrays where a coordinate may
   have a smaller dimension than its associated Grid, then
   the dimension of the coordinate's bounds are the dimension of
   the coordinate, not the Grid. 

<P>
The following is an example of retrieving the bounds for localDE 0 for the first
   coordinate array from the corner stagger location.   

<P>
<PRE>
   call ESMF_GridGetCoordBounds(grid2D, coordDim=1, localDE=0,  &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,                         &amp;
          exclusiveLBound=elbnd, exclusiveUBound=eubnd,              &amp;
          computationalLBound=clbnd, computationalUBound=cubnd,      &amp; 
          totalLBound=tlbnd, totalUBound=tubnd, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831800000000000000">
27.3.18 Get Grid stagger location bounds</A>
</H3>

<P>
When operating on data stored at a particular stagger
   in a Grid the user may find it useful to be able
   to retrieve the bounds of the data on a particular local DE. 
   This is useful for iterating through the
   data for computations or allocating arrays to hold the data. 
   The method <TT>ESMF_GridGet</TT> allows the user
   to retrieve bound information for a particular stagger location. 

<P>
As described in Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> there are three types of bounds 
   the user can typically get, however, the Grid doesn't hold data at
   a stagger location (that is the job of the Field), and so 
   no Array is contained there and so no total region exists, so the 
   user may only retrieve exclusive and computational bounds from
   a stagger location.  The bounds
   provided by <TT>ESMF_GridGet</TT> are ordered according to the
   order of dimensions in the Grid. 

<P>
The following is an example of retrieving the bounds for localDE 0
   from the corner stagger location.  

<P>
<PRE>
   call ESMF_GridGet(grid2D, localDE=0,                         &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER,                    &amp;
          exclusiveLBound=elbnd, exclusiveUBound=eubnd,         &amp;
          computationalLBound=clbnd, computationalUBound=cubnd, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050831900000000000000">
27.3.19 Get Grid stagger location information</A>
</H3>

<P>
In addition to the per DE information that can be accessed about
   a stagger location there is some global information that can
   accessed by using <TT>ESMF_GridGet</TT> without specifying a
   localDE. One of the uses of this information is to create
   an ESMF Array to hold data for a stagger location. 

<P>
The information currently available from a stagger
   location is the <TT>distgrid</TT>. The <TT>distgrid</TT> gives the 
   distgrid which describes the size and distribution of the elements in the stagger location.

<P>
The following is an example of retrieving information for localDE 0
   from the corner stagger location.  

<P>
<PRE>
    ! Get info about staggerloc
    call ESMF_GridGet(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER,  &amp;
           distgrid=staggerDistgrid, &amp;
           rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832000000000000000">
27.3.20 Create an Array at a stagger location</A>
</H3>

<P>
In order to create an Array to correspond to a Grid stagger location
   several pieces of information need to be obtained from both the 
   Grid and the stagger location in the Grid. 

<P>
The information that needs to be obtained from the Grid
   is the <TT>distgridToGridMap</TT> to ensure that the new Array
   has its  dimensions are mapped correctly to the Grid. These
   are obtained using the <TT>ESMF_GridGet</TT> method. 

<P>
The information that needs to be obtained from the stagger
   location is the distgrid that describes the size and distribution
   of the elements in the stagger location. This information can 
   be obtained using the stagger location specific <TT>ESMF_GridGet</TT> method. 

<P>
The following is an example of using information from a 2D Grid with non-arbitrary 
   distribution to create an Array corresponding to a stagger location.

<P>
<PRE>
    ! Get info from Grid
    call ESMF_GridGet(grid2D, distgridToGridMap=distgridToGridMap, rc=rc)

    ! Get info about staggerloc
    call ESMF_GridGet(grid2D, staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
           distgrid=staggerDistgrid, &amp;
           rc=rc)

    ! construct ArraySpec
    call ESMF_ArraySpecSet(arrayspec, rank=2, typekind=ESMF_TYPEKIND_R8, rc=rc)

    ! Create an Array based on info from grid
    array=ESMF_ArrayCreate(arrayspec=arrayspec, &amp;
            distgrid=staggerDistgrid, distgridToArrayMap=distgridToGridMap, &amp;
            rc=rc)
</PRE>

<P>
Creating an Array for a Grid with arbitrary distribution is different. 
   For a 2D Grid with both dimension arbitrarily distributed, the Array dimension
   is 1.  For a 3D Grid with two arbitrarily distributed dimensions and one
   undistributed dimension, the Array dimension is 2.  In general,
   if the Array does not have any ungridded dimension, the Array dimension 
   should be 1 plus the number of undistributed dimensions of the Grid.

<P>
The following is an example of creating an Array for a 3D Grid with 2 
   arbitrarily distributed dimensions such as the one defined in Section&nbsp;<A HREF="node5.html#example:ArbGridWithUndistDim">27.3.7</A>. 

<P>
<PRE>
    ! Get distGrid from Grid
    call ESMF_GridGet(grid3D, distgrid=distgrid, rc=rc)

    ! construct ArraySpec
    call ESMF_ArraySpecSet(arrayspec, rank=2, typekind=ESMF_TYPEKIND_R8, rc=rc)

    ! Create an Array based on the presence of distributed dimensions
    array=ESMF_ArrayCreate(arrayspec=arrayspec,distgrid=distgrid, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832100000000000000"></A>
  <A NAME="sec:usage:adv:create"></A>
<BR>
27.3.21 Create more complex Grids using DistGrid
</H3>

<P>
Besides the shortcut methods for creating a Grid object such as
   <TT>ESMF_GridCreateNoPeriDim()</TT>, there is
   a set of methods which give the user more control over the
   specifics of the grid.  The following describes the more 
   general interface, using DistGrid.
   The basic idea is to first create an ESMF DistGrid object describing
   the distribution and shape of the Grid, and then to employ that to either directly
   create the Grid or first create Arrays and then create the Grid from those. 
   This method gives the user maximum control over the topology and distribution of the Grid. 
   See the DistGrid documentation in Section&nbsp;<A HREF="node5.html#sec:DistGrid">31.1</A> for an 
   in-depth description of its interface and use. 

<P>
As an example, the following call constructs
   a 10x20 Grid with a lower bound of (1,2). 

<P>
<PRE>
   ! Create DistGrid
   distgrid2D = ESMF_DistGridCreate(minIndex=(/1,2/), maxIndex=(/11,22/), &amp;
           rc=rc)  

   ! Create Grid
   grid3D=ESMF_GridCreate(distGrid=distgrid2D, rc=rc)
</PRE>

<P>
To alter which dimensions are distributed, the <TT>distgridToGridMap</TT> 
   argument can be used. The <TT>distgridToGridMap</TT> is used to set
   which dimensions of the Grid are mapped to the dimensions
   described by <TT>maxIndex</TT>. In other words, it describes how the dimensions of 
   the underlying default DistGrid are mapped to the Grid. Each entry
   in <TT>distgridToGridMap</TT> contains the Grid dimension to which the cooresponding
   DistGrid dimension should be mapped. 
   The following example illustrates the creation of a Grid where the largest
   dimension is first. To accomplish this the two dimensions are swapped.

<P>
<PRE>
   ! Create DistGrid
   distgrid2D = ESMF_DistGridCreate(minIndex=(/1,2/), maxIndex=(/11,22/), &amp;
        rc=rc)  

   ! Create Grid
   grid2D=ESMF_GridCreate(distGrid=distgrid2D, distgridToGridMap=(/2,1/), &amp;
        rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832200000000000000"></A>
  <A NAME="sec:usage:staggerloc:adv"></A>
<BR>
27.3.22 Specify custom stagger locations
</H3>

<P>
Although ESMF provides a set of predefined stagger locations (See Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A>),
   the user may need one outside this set. This section describes the construction of
   custom stagger locations. 

<P>
To completely specify stagger for an arbitrary number of dimensions, we define the 
   stagger location in terms of a set of cartesian coordinates. The cell is represented
   by a n-dimensional cube with sides of length 2, and the coordinate origin located at
   the center of the cell. The geometry of the cell is for reference purposes only, 
   and does not literally represent the actual shape of the cell. Think of this method
   instead as an easy way to specify a part (e.g. center, corner, face) of a higher 
   dimensional cell which is extensible to any number of dimensions. 

<P>
To illustrate this approach, consider a 2D cell. In 2 dimensions
   the cell is represented by a square. An xy axis is placed at its center, with the 
   positive x-axis oriented <EM>East</EM> and the positive y-axis oriented <EM>North</EM>.
   The resulting coordinate for the lower left corner is at <IMG
 WIDTH="66" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$(-1,-1)$">, and upper right
   corner at <IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$(1,1)$">.
   However, because our staggers are symmetric they don't need to distinguish between
   the <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img63.png"
 ALT="$-1$">, and the <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="$1$">, so we only need concern ourselves with the first quadrant of
   this cell. We only need to use the <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="$1$">, and the <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$0$">, and many of the cell locations
   collapse together (e.g. we only need to represent one corner). See figure&nbsp;<A HREF="node5.html#fig:gridcuststaggerloc">18</A>
   for an illustration of these concepts.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridcuststaggerloc"></A><A NAME="37372"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 18:</STRONG>
An example of specifying 2D stagger locations using coordinates.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridCustStaggerLoc}}$
 -->
<IMG
 WIDTH="626" HEIGHT="356" ALIGN="BOTTOM" BORDER="0"
 SRC="img65.png"
 ALT="\scalebox{0.75}{\includegraphics{GridCustStaggerLoc}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The cell center is represented by the coordinate pair <IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img66.png"
 ALT="$(0,0)$"> indicating the origin.
   The cell corner is <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$+1$"> in each direction, giving a coordinate pair of <IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$(1,1)$">.
   The edges are each <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$+1$"> in one dimension and <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$0$"> in the other indicating that 
   they're even with the center in one dimension and offset in the other. 

<P>
For three dimensions, the vertical component of the stagger location can be added by 
   simply adding an additional coordinate. The three dimensional generalization of the
   cell center becomes <IMG
 WIDTH="56" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img68.png"
 ALT="$(0,0,0)$"> and the cell corner becomes <IMG
 WIDTH="56" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img69.png"
 ALT="$(1,1,1)$">. The rest of
   the 3D stagger locations are combinations of <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$+1$"> offsets from the center. 

<P>
To generalize this to <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="$d$"> dimensions, to represent a <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="$d$"> dimensional stagger
   location. A set of <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img70.png"
 ALT="$d$"> <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$0$"> and <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="$1$"> is used to specify for each dimension
   whether a stagger location is aligned with the cell center in that dimension (<IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img64.png"
 ALT="$0$">),
   or offset by <IMG
 WIDTH="26" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img67.png"
 ALT="$+1$"> in that dimension (<IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="$1$">). Using this scheme we can represent
   any symmetric stagger location.  

<P>
To construct a custom stagger location in ESMF the subroutine 
   <TT>ESMF_StaggerLocSet()</TT> is used to specify, 
   for each dimension, whether the stagger is located at the interior (0) 
   or on the boundary (1) of the cell. This method allows users
   to construct stagger locations for which
   there is no predefined value. In this example, it's used to 
   set the 4D center and 4D corner locations. 

<P>
<PRE>
   ! Set Center
   call ESMF_StaggerLocSet(staggerLoc,loc=(/0,0,0,0/),rc=rc)
   call ESMF_GridAddCoord(grid4D, staggerLoc=staggerLoc, rc=rc)

   ! Set Corner
   call ESMF_StaggerLocSet(staggerLoc,loc=(/1,1,1,1/),rc=rc)
   call ESMF_GridAddCoord(grid4D, staggerLoc=staggerLoc, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832300000000000000"></A>
  <A NAME="sec:usage:staggerpadding:adv"></A>
<BR>
27.3.23 Specify custom stagger padding
</H3>

<P>
There is an added complication with the data (e.g. coordinates) stored at stagger locations in 
  that they can require different amounts of storage depending
  on the underlying Grid type. 

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:gridcellsandcorners"></A><A NAME="37385"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 19:</STRONG>
An example 2D Grid with cell centers and corners.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.75}{\includegraphics{GridCellsAndCorners}}$
 -->
<IMG
 WIDTH="432" HEIGHT="259" ALIGN="BOTTOM" BORDER="0"
 SRC="img71.png"
 ALT="\scalebox{0.75}{\includegraphics{GridCellsAndCorners}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
Consider the example 2D grid in figure&nbsp;<A HREF="node5.html#fig:gridcellsandcorners">19</A>, where the dots represent the cell corners
   and the ``+'' represents the cell centers. For the corners to completely
   enclose the cell centers (symmetric stagger), the number of corners in each 
   dimension needs to be one greater then the number of cell centers. In the above 
   figure, there are two rows and three columns of cell centers. To enclose the 
   cell centers, there must be three rows and four columns of cell corners.
   This is true in general for Grids without periodicity or
   other connections.  In fact, for a symmetric stagger, given that the center
   location requires n x m storage, the corresponding corner location
   requires n+1 x m+1, and the edges, depending on the side, require n+1 x m or
   m+1 x n.  In order to add the extra storage, a new DistGrid is
   created at each stagger location. This Distgrid is similar to the DistGrid
   used to create the Grid, but has an extra set of elements added to hold the 
   index locations for the stagger padding.
   By default, when the coordinate arrays are created, one extra
   layer of padding is added to the index space to create symmetric staggers 
   (i.e. the center location is surrounded). The default is to add this padding 
   on the positive side, and to only add this padding where needed 
   (e.g. no padding for the center, padding
   on both dimensions for the corner, in only one dimension for the 
   edge in 2D.) There are two ways for the user to change
   these defaults. 

<P>
One way is to use the <TT>GridEdgeWidth</TT> or <TT>GridAlign</TT> arguments
   when creating a Grid. These arguments can be used to change the default padding
   around the Grid cell index space. This extra padding is used by default
   when setting the padding for a stagger location. 

<P>
The <TT>gridEdgeLWidth</TT> and 
   <TT>gridEdgeUWidth</TT> arguments are both 1D arrays of the
   same size as the Grid dimension. The entries in the arrays
   give the extra offset from the outer boundary of
   the grid cell index space. The following example shows the
   creation of a Grid with all the extra space to hold stagger padding
   on the negative side of a Grid. This is the reverse of
   the default behavior. The resulting Grid will have
   an exclusive region which extends from <IMG
 WIDTH="66" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img61.png"
 ALT="$(-1,-1)$"> to
   <IMG
 WIDTH="57" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$(10,10)$">, however, the cell center stagger location
   will still extend from <IMG
 WIDTH="41" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img62.png"
 ALT="$(1,1)$"> to <IMG
 WIDTH="57" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img72.png"
 ALT="$(10,10)$">. 

<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(minIndex=(/1,1/),maxIndex=(/10,10/), &amp;
            gridEdgeLWidth=(/1,1/), gridEdgeUWidth=(/0,0/), rc=rc)
</PRE>

<P>
To indicate how the data in a Grid's stagger locations are aligned with the 
   cell centers, the optional <TT>gridAlign</TT> parameter 
   may be used. This parameter indicates which stagger elements 
   in a cell share the same index values as the cell center. 
   For example, in a 2D cell, it would indicate which of the four corners has
   the same index value as the center. To set <TT>gridAlign</TT>,  
   the values -1,+1 are used to indicate the alignment in
   each dimension. This parameter is mostly 
   informational, however, if the <TT>gridEdgeWidth</TT> parameters 
   are not set then its value determines where the default padding
   is placed. If not specified, then the default is to align all 
   staggers to the most negative, so the padding is on the positive side. 
   The following code illustrates creating a Grid aligned to the reverse of
   default (with everything to the positive side). This creates a
   Grid identical to that created in the previous example.  

<P>
<PRE>
   grid2D=ESMF_GridCreateNoPeriDim(minIndex=(/1,1/),maxIndex=(/10,10/), &amp;
            gridAlign=(/1,1/), rc=rc)
</PRE>

<P>
The <TT>gridEdgeWidth</TT> and <TT>gridAlign</TT> arguments both
   allow the user to set the default padding to be used
   by stagger locations in a Grid. By default, stagger locations
   allocated in a Grid set their stagger padding based on these
   values.  A stagger location's padding in each dimension is
   equal to the value of <TT>gridEdgeWidth</TT> (or the value implied
   by <TT>gridAlign</TT>), unless the stagger location is centered
   in a dimension in which case the stagger padding is 0. For example,
   the cell center stagger location has 0 stagger padding in all
   dimensions, whereas the edge stagger location lower padding
   is equal to <TT>gridEdgeLWidth</TT> and the upper padding is equal
   to <TT>gridEdgeUWidth</TT> in one dimension, but both are 0 in the other,
   centered, dimension.  If the user wishes to set the stagger padding
   individually for each stagger location they may use the
   <TT>staggerEdgeWidth</TT> and <TT>staggerAlign</TT> arguments.

<P>
The <TT>staggerEdgeLWidth</TT> and 
   <TT>staggerEdgeUWidth</TT> arguments are both 1D arrays of the
   same size as the Grid dimension. The entries in the arrays
   give the extra offset from the Grid cell index space
   for a stagger location. The following example shows the
   addition of two stagger locations. The
   corner location has no extra boundary and the 
   center has a single layer of extra padding on 
   the negative side and none on the positive.  This is the reverse of
   the default behavior. 

<P>
<PRE>
   grid2D=ESMF_GridCreate(distgrid=distgrid2D, &amp;
            gridEdgeLWidth=(/1,1/), gridEdgeUWidth=(/0,0/), rc=rc)

   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, &amp;
          staggerEdgeLWidth=(/0,0/), staggerEdgeUWidth=(/0,0/), rc=rc)

   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CENTER, &amp;
          staggerEdgeLWidth=(/1,1/), staggerEdgeUWidth=(/0,0/), rc=rc)
</PRE>

<P>
To indicate how the data at a particular stagger location is aligned with the 
   cell center, the optional <TT>staggerAlign</TT> parameter 
   may be used. This parameter indicates which stagger elements 
   in a cell share the same index values as the cell center. 
   For example, in a 2D cell, it would indicate which of the four corners has
   the same index value as the center. To set <TT>staggerAlign</TT>,  
   the values -1,+1 are used to indicate the alignment in
   each dimension. If a stagger location is 
   centered in a dimension (e.g. an edge in 2D), then that
   dimension is ignored in the alignment. This parameter is mostly 
   informational, however, if the <TT>staggerEdgeWidth</TT> parameters 
   are not set then its value determines where the default padding
   is placed. If not specified, then the default is to align all 
   staggers to the most negative, so the padding is on the positive side. 
   The following code illustrates aligning the positive (northeast in 2D) 
   corner with the center.  

<P>
<PRE>
   call ESMF_GridAddCoord(grid2D, &amp;
          staggerLoc=ESMF_STAGGERLOC_CORNER, staggerAlign=(/1,1/), rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050832400000000000000"></A> 
   <A NAME="example:GridCrFromFile"></A>
<BR>
27.3.24 Create a 2D regularly distributed rectilinear Grid from file
</H3>

<P>
This example shows how to read an ESMF GridSpec Attribute Package from an
   XML file and use it to create a grid.  The XML file contains Attribute values
   filled-in by the user.  The standard GridSpec Attribute Package is supplied
   with ESMF and is defined in an XSD file, which is used to validate the
   XML file. See
   <DL>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Grid/etc/esmf_grid_shape_tile.xml (Attribute Package values) and
   
</DD>
<DT></DT>
<DD>ESMF_DIR/src/Infrastructure/Grid/etc/esmf_grid.xsd (Attribute Package definition).
   
</DD>
</DL>

<P>
The following XML attributes, from the file mentioned above, specifies a
   two dimensional, 10x20 single-tile rectilinear grid that is regularly
   distributed into 2 DEs in the first dimension and 3 DEs in the second
   dimension, for a total of 6 DEs (2x3):

<P>
<PRE>
  &lt;?xml version="1.0"?&gt;
  &lt;GridSpec&gt;
    &lt;Mosaic&gt;
      &lt;attribute_package convention="ESMF" purpose="General"&gt;
        &lt;NX&gt;10&lt;/NX&gt;
        &lt;NY&gt;20&lt;/NY&gt;
      &lt;/attribute_package&gt;
      &lt;RegDecompX&gt;2&lt;/RegDecompX&gt;
      &lt;RegDecompY&gt;3&lt;/RegDecompY&gt;
    &lt;/Mosaic&gt;
  &lt;/GridSpec&gt;
</PRE> 

<P>
Read the file and create the grid, 

<P>
<PRE>
   ! Read an XML file containing user-filled-in values for a GridSpec 
   ! Attribute package and use it to create a grid.  The file is 
   ! validated against an internal, ESMF-supplied XSD file defining 
   ! the standard GridSpec Attribute package (see file pathnames above).

   grid2D=ESMF_GridCreate("esmf_grid_shape_tile.xml", rc=rc)
</PRE>

<P>
then show that the minimum and maximum global indices of the Grid are
   (1,1) <IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$\sim$"> (11,21) (one extra default stagger pad in each dimension): 

<P>
<PRE>
   call ESMF_GridGet(grid2D, tile=1, minIndex=minIndex, maxIndex=maxIndex, &amp;
     staggerloc=ESMF_STAGGERLOC_CENTER, rc=rc)
   print *, "minIndex(1), minIndex(2) = ", minIndex(1), minIndex(2)
   print *, "maxIndex(1), maxIndex(2) = ", maxIndex(1), maxIndex(2)
</PRE>

<P>
Get the resulting computational bounds for each local DE within the local PET,
   for center stagger locations: 

<P>
<PRE>
   call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
   print *, "localPet = ", localPet, "petCount = ", petCount

   call ESMF_GridGet(grid2D, localDECount=localDECount, rc=rc)
   print *, "localDECount = ", localDECount
</PRE>

<P>
<PRE>
   do i=0,localDECount-1
     call ESMF_GridGet(grid2D, localDE=i,  &amp;
                       staggerLoc=ESMF_STAGGERLOC_CENTER, &amp;
                       computationalLBound=clbnd, computationalUBound=cubnd, &amp; 
                       rc=rc)
       print *, "clbnd,cubnd = ", clbnd(1), ", ", clbnd(2), " ", &amp;
                                  cubnd(1), ", ", cubnd(2)
       print *, " "
   enddo
</PRE>

<P>
For a 4 PET run, this will show the following (lower) <IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$\sim$"> (upper)
   computational bounds per DE, 6 DEs total (2x3):

<P>
<PRE>
    PET 0:
      local DE 0 - (1,1)  ~ (5,7)
      local DE 1 - (1,15) ~ (5,20)
    PET 1:
      local DE 0 - (6,1)  ~ (10,7)
      local DE 1 - (6,15) ~ (10,20)
    PET 2:
      local DE 0 - (1,8)  ~ (5,14)
    PET 3:
      local DE 0 - (6,8)  ~ (10,14)
</PRE>

<P>
For a 1 PET run, the distribution will be

<P>
<PRE>
      local DE 0 - (1,1)  ~ (5,7)
      local DE 1 - (6,1)  ~ (10,7)
      local DE 2 - (1,8)  ~ (5,14)
      local DE 3 - (6,8)  ~ (10,14)
      local DE 4 - (1,15) ~ (5,20)
      local DE 5 - (6,15) ~ (10,20)
</PRE>

<P>
The Grid and its distribution, represented graphically:

<P>
<PRE>
      -------------------------------------------------------&gt; 2nd dim
      |
      |  (1,1)-------(1,7)(1,8)------(1,14)(1,15)-----(1,20)
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  (5,1)-------(5,7)(5,8)------(5,14)(5,15)-----(5,20)
      |  (6,1)-------(6,7)(6,8)------(6,14)(6,15)-----(6,20)
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  |               ||              ||                |
      |  (10,1)-----(10,7)(10,8)----(10,14)(10,15)---(10,20)
      |
      |
      v
     1st dim
</PRE> 

<P>
Write the attributes back out to an xml file. 

<P>
<PRE>
   ! Write an XML file 
   call ESMF_AttributeWrite(grid2D, 'ESMF', 'General', &amp;
                            attwriteflag=ESMF_ATTWRITE_XML, rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION05084000000000000000">
27.4 Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI><B>7D limit.</B>  Only grids up to 7D will be supported.

<P>
</LI>
<LI><B>During the first development phase only single
tile grids are supported.</B>  In the near future, support
for mosaic grids will be added.  The initial implementation 
will be to create mosaics that contain tiles of the same
grid type, e.g. rectilinear.

<P>
</LI>
<LI><B>Future adaptation.</B>  Currently Grids
are created and then remain unchanged. In the future, it would
be useful to provide support for the various forms of grid
adaptation. This would allow the grids to dynamically change
their resolution to more closely match what is needed at a particular
time and postion during a computation for front tracking or adaptive meshes.

<P>
</LI>
<LI><B>Future Grid generation.</B> This class for now only contains
the basic functionality for operating on the grid. In the future
methods will be added to enable the automatic generation of various types of
grids. 

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION05085000000000000000">
27.5 Design and Implementation Notes</A>
</H2>

<P>

<H3><A NAME="SECTION05085100000000000000">
27.5.1 Grid Topology</A>
</H3> 

<P>
The <TT>ESMF_Grid</TT> class depends upon the <TT>ESMF_DistGrid</TT> class
for the specification of its topology. That is, when 
creating a Grid, first an <TT>ESMF_DistGrid</TT> is created to describe the 
appropriate index space topology. This decision was
made because it seemed redundant to have a system for doing this
in both classes. It also seems most appropriate for
the machinary for topology creation to be located at the lowest
level possible so that it can be used by other
classes (e.g. the <TT>ESMF_Array</TT> class). Because of this, however,
the authors recommend that as a natural part of the 
implementation of subroutines to generate standard grid shapes
(e.g. <TT>ESMF_GridGenSphere</TT>) a set of standard
topology generation subroutines be implemented (e.g. <TT>ESMF_DistGridGenSphere</TT>) for users who want to create a standard topology, but a custom geometry.

<P>

<P>

<H2><A NAME="SECTION05086000000000000000">
27.6 Class API: General Grid Methods</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05086100000000000000">
27.6.1 ESMF_GridAssignment(=) - Grid assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     grid1 = grid2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid) :: grid1
     type(ESMF_Grid) :: grid2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign grid1 as an alias to the same ESMF Grid object in memory
     as grid2. If grid2 is invalid, then grid1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086200000000000000">
27.6.2 ESMF_GridOperator(==) - Grid equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (grid1 == grid2) then ... endif
               OR
     result = (grid1 == grid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid1
     type(ESMF_Grid), intent(in) :: grid2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether grid1 and grid2 are valid aliases to the same ESMF
     Grid object in memory. For a more general comparison of two ESMF Grids,
     going beyond the simple alias test, the ESMF_GridMatch() function (not yet
     fully implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086300000000000000">
27.6.3 ESMF_GridOperator(/=) - Grid not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (grid1 /= grid2) then ... endif
               OR
     result = (grid1 /= grid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in) :: grid1
     type(ESMF_Grid), intent(in) :: grid2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether grid1 and grid2 are <I>not</I> valid aliases to the
     same ESMF Grid object in memory. For a more general comparison of two ESMF
     Grids, going beyond the simple alias test, the ESMF_GridMatch() function
     (not yet fully implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD>The <TT>ESMF_Grid</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086400000000000000">
27.6.4 ESMF_GridAddCoord - Allocate coordinate arrays but don't set their values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridAddCoord()
      subroutine ESMF_GridAddCoordNoValues(grid, staggerloc,  &amp;
        staggerEdgeLWidth, staggerEdgeUWidth, staggerAlign, &amp;
        staggerLBound,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: staggerEdgeLWidth(:)
       integer,                intent(in),  optional :: staggerEdgeUWidth(:)
       integer,                intent(in),  optional :: staggerAlign(:)
       integer,                intent(in),  optional :: staggerLBound(:)      
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
When a Grid is created all of its potential stagger locations can hold coordinate
    data, but none of them have storage allocated. This call allocates coordinate
    storage (creates internal ESMF_Arrays and associated memory) for  a particular
    stagger location. Note that this
    call doesn't assign any values to the storage, it only allocates it. The
    remaining options <TT>staggerEdgeLWidth</TT>, etc. allow the user to adjust the 
    padding on the coordinate arrays.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to allocate coordinate storage in.  
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to add. Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
   
</DD>
<DT><STRONG>[staggerEdgeLWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerEdgeUWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerAlign]</STRONG></DT>
<DD>This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example, 
        for a 2D cell with corner stagger it specifies which 
        of the 4 corners has the same index as the center. 
        If this is set and either staggerEdgeUWidth or staggerEdgeLWidth is not,
        this determines the default array padding for a stagger. 
        If not set, then this defaults to all negative. (e.g. 
        The most negative part of the stagger in a cell is aligned with the 
        center and the padding is all on the postive side.) 
   
</DD>
<DT><STRONG>[staggerLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this staggerloc in this Grid. 
        Only used when Grid indexflag is <TT>ESMF_INDEX_USER</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086500000000000000">
27.6.5 ESMF_GridAddItem - Allocate item array but don't set their values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridAddItem()
      subroutine ESMF_GridAddItemNoValues(grid, itemflag,  &amp;
        staggerloc, itemTypeKind, staggerEdgeLWidth, staggerEdgeUWidth, &amp;
        staggerAlign, staggerLBound,rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),           intent(in)             :: grid 
       type (ESMF_GridItem_Flag), intent(in)             :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc)  ,  intent(in),  optional  :: staggerloc
       type (ESMF_TypeKind_Flag), intent(in),  optional  :: itemTypeKind
       integer,                   intent(in),  optional  :: staggerEdgeLWidth(:)
       integer,                   intent(in),  optional  :: staggerEdgeUWidth(:)
       integer,                   intent(in),  optional  :: staggerAlign(:)
       integer,                   intent(in),  optional  :: staggerLBound(:)      
       integer,                   intent(out), optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
When a Grid is created all of its potential stagger locations can hold item
    data, but none of them have storage allocated. This call allocates item
    storage (creates an internal ESMF_Array and associated memory) for  a particular
    stagger location. Note that this
    call doesn't assign any values to the storage, it only allocates it. The
    remaining options <TT>staggerEdgeLWidth</TT>, etc. allow the user to adjust the 
    padding on the item array.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to allocate coordinate storage in.  
   
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The grid item to add. Please see Section&nbsp;<A HREF="node5.html#const:griditem">27.2.3</A> for a list of valid items. 
   
</DD>
<DT><STRONG>[staggerloc]</STRONG></DT>
<DD>The stagger location to add. Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
        of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
   
</DD>
<DT><STRONG>[itemTypeKind]</STRONG></DT>
<DD>The typekind of the  item to add. 
   
</DD>
<DT><STRONG>[staggerEdgeLWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the lower corner of the stagger
        region with respect to the lower corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerEdgeUWidth]</STRONG></DT>
<DD>This array should be the same dimCount as the grid. It specifies the upper corner of the stagger
        region with respect to the upper corner of the exclusive region.
   
</DD>
<DT><STRONG>[staggerAlign]</STRONG></DT>
<DD>This array is of size  grid dimCount.
        For this stagger location, it specifies which element
        has the same index value as the center. For example, 
        for a 2D cell with corner stagger it specifies which 
        of the 4 corners has the same index as the center. 
        If this is set and either staggerEdgeUWidth or staggerEdgeLWidth is not,
        this determines the default array padding for a stagger. 
        If not set, then this defaults to all negative. (e.g. 
        The most negative part of the stagger in a cell is aligned with the 
        center and the padding is all on the postive side.) 
   
</DD>
<DT><STRONG>[staggerLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this staggerloc in this Grid. 
        Only used when Grid indexflag is <TT>ESMF_INDEX_USER</TT>. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086600000000000000">
27.6.6 ESMF_GridCreate - Create a copy of a Grid with a new DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateCopyFromNewDG(grid, distgrid, &amp;
         name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateCopyFromNewDG
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Grid),       intent(in)              :: grid
        type(ESMF_DistGrid),   intent(in)              :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        character (len=*),     intent(in),   optional  :: name
        integer,               intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This call allows the user to copy of an existing ESMF Grid, but with a new distribution. 
   All internal data from the old Grid (coords, items) is redistributed to the new Grid. 

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to copy.
   
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object which describes how the Grid is decomposed and
        distributed over DEs. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the new Grid. If not specified, a new unique name will be created 
        for the Grid.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086700000000000000">
27.6.7 ESMF_GridCreate - Create a copy of a Grid with a different regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateCopyFromReg(grid, &amp;
         regDecomp, decompFlag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateCopyFromReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_Grid),        intent(in)              :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                intent(in),   optional  :: regDecomp(:)
        type(ESMF_Decomp_Flag), intent(in),   optional  :: decompflag(:)
        character (len=*),      intent(in),   optional  :: name
        integer,                intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a copy of an existing Grid, the new Grid is 
   regularly distributed (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the new distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to copy.
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1. 
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#const:decompflag">9.13</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the new Grid. If not specified, a new unique name will be 
        created for the Grid.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086800000000000000">
27.6.8 ESMF_GridCreate - Create a Grid with user set edge connections and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnI(minIndex,         &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         connflagDim1, connflagDim2, connflagDim3,                     &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnI
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                    intent(in),  optional :: minIndex(:)
        integer,                    intent(in)            :: countsPerDEDim1(:)
        integer,                    intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                    intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_GridConn_Flag),   intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag),   intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag),   intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag),   intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),   intent(in),  optional :: coordTypeKind
        integer,                    intent(in),  optional :: coordDep1(:)
        integer,                    intent(in),  optional :: coordDep2(:)
        integer,                    intent(in),  optional :: coordDep3(:)
        integer,                    intent(in),  optional :: gridEdgeLWidth(:)
        integer,                    intent(in),  optional :: gridEdgeUWidth(:)
        integer,                    intent(in),  optional :: gridAlign(:)
        integer,                    intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),      intent(in),  optional :: indexflag
        integer,                    intent(in),  optional :: petMap(:,:,:)
        character (len=*),          intent(in),  optional :: name 
        integer,                    intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>) without a periodic dimension. 
   To specify the irregular distribution, the user passes in an array 
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.   Up to three dimensions can be specified, 
   using the countsPerDEDim1, countsPerDEDim2, countsPerDEDim3 arguments.
   The index of each array element corresponds to a DE number.  The 
   array value at the index is the number of grid cells on the DE in 
   that dimension.  The dimCount of the grid is equal to the number of 
   countsPerDEDim arrays that are specified. 

<P>
Section <A HREF="node5.html#example:2DIrregUniGrid">27.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced 
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location). 
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).  
       If not specified  then grid is 2D. 
   
</DD>
<DT><STRONG>[connflagDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connflagDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connflagDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05086900000000000000">
27.6.9 ESMF_GridCreate - Create a Grid with user set edge connections and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnR(regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                    &amp;
         connflagDim1, connflagDim2, connflagDim3,                       &amp;
         coordSys, coordTypeKind,                            &amp;
         coordDep1, coordDep2, coordDep3,                    &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,          &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                  intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),   intent(in),  optional :: decompflag(:)
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name 
        integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
The arguments are:
   <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1. 
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#const:decompflag">9.13</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[connflagDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connflagDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connflagDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
        If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.   
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861000000000000000">
27.6.10 ESMF_GridCreate - Create a Grid with user set edge connections and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateEdgeConnA(minIndex, maxIndex,  &amp;
         arbIndexCount, arbIndexList,                         &amp;
         connflagDim1, connflagDim2, connflagDim3,                     &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         distDim, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateEdgeConnA
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
        integer,                  intent(in)            :: arbIndexCount
        integer,                  intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connflagDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: distDim(:)
        character (len=*),        intent(in),  optional :: name 
        integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the arbitrary distribution, the user passes in an 2D array 
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The 
   size of <TT>distDim</TT> has to agree with the size of the second dimension of 
   <TT>localArbIndex</TT>. 

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.  
   
</DD>
<DT><STRONG>[arbIndexList]</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The 
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[connflagDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connflagDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connflagDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
        Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861100000000000000">
27.6.11 ESMF_GridCreate - Create a Grid from a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateFrmDistGrid(distgrid, &amp;
         distgridToGridMap, &amp;
         coordSys, coordTypeKind, coordDimCount, coordDimMap, &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign, &amp;
         gridMemLBound, indexflag, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFrmDistGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid),      intent(in)             :: distgrid
        integer,                  intent(in),  optional  :: distgridToGridMap(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional  :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional  :: coordTypeKind
        integer,                  intent(in),  optional  :: coordDimCount(:)
        integer,                  intent(in),  optional  :: coordDimMap(:,:)
        integer,                  intent(in),  optional  :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional  :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional  :: gridAlign(:)
        integer,                  intent(in),  optional  :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional  :: indexflag
        character (len=*),        intent(in),  optional  :: name
        integer,                  intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This is the most general form of creation for an <TT>ESMF_Grid</TT>
   object. It allows the user to fully specify the topology and index space
   using the DistGrid methods and then build a grid out
   of the resulting DistGrid. Note that since the Grid created by this call 
   uses <TT>distgrid</TT> as a description of its index space, the resulting Grid 
   will have exactly the same number of dimensions (i.e. the same dimCount) as 
   <TT>distgrid</TT>. The <TT>distgridToGridMap</TT> argument
   specifies how the Grid dimensions are mapped to the <TT>distgrid</TT>. 
   The <TT>coordDimCount</TT> and <TT>coordDimMap</TT> arguments
   allow the user to specify how the coordinate arrays should map to the grid
   dimensions. (Note, though, that creating a grid does not allocate coordinate
   storage. A method such as <TT>ESMF_GridAddCoord()</TT> must be called
   before adding coordinate values.)

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
        distributed over DEs. 
   
</DD>
<DT><STRONG>[distgridToGridMap]</STRONG></DT>
<DD>List that has dimCount elements.
        The elements map each dimension of distgrid to a dimension in the grid.
         (i.e. the values should range from 1 to dimCount). If not specified, the default
         is to map all of distgrid's dimensions against the dimensions of the
         grid in sequence. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_CART.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals.  
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>List that has dimCount elements.
        Gives the dimension of each component (e.g. x) array. This is 
        to allow factorization of the coordinate arrays. If not specified
        all arrays are the same size as the grid. 
   
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size dimCount x  dimCount. This array describes the
        map of each component array's dimensions onto the grids
        dimensions. Each entry <TT>coordDimMap(i,j)</TT> tells which
        grid dimension component i's, jth dimension maps to. 
        Note that if j is bigger than <TT>coordDimCount(i)</TT> it is ignored.        
        The default for each row i is <TT>coordDimMap(i,:)=(1,2,3,4,...)</TT>.        
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861200000000000000">
27.6.12 ESMF_GridCreate - Create a Arbitrary Grid from a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
       function ESMF_GridCreateFrmDistGridArb(distgrid, &amp;
         indexArray, distDim, &amp;
         coordSys, coordTypeKind, coordDimCount, coordDimMap, &amp;
         name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFrmDistGridArb
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_DistGrid),      intent(in)              :: distgrid
        integer,                  intent(in)              :: indexArray(:,:)
        integer,                  intent(in),   optional  :: distDim(:)
        type(ESMF_CoordSys_Flag), intent(in),   optional  :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),   optional  :: coordTypeKind
        integer,                  intent(in),   optional  :: coordDimCount(:)
        integer,                  intent(in),   optional  :: coordDimMap(:,:)
        character (len=*),        intent(in),   optional  :: name
        integer,                  intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This is the lower level function to create an arbitrailiy distributed <TT>ESMF_Grid</TT>
   object. It allows the user to fully specify the topology and index space
   (of the distributed dimensions) using the DistGrid methods and then build a grid out
   of the resulting <TT>distgrid</TT>.  The <TT>indexArray(2,dimCount)</TT>, 
   argument is required to specifies the topology of the grid.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
        distributed over DEs. 
   
</DD>
<DT><STRONG>[indexArray]</STRONG></DT>
<DD>The minIndex and maxIndex array of size <TT>2</TT> x <TT>dimCount</TT>
        <TT>indexArray(1,:)</TT> is the minIndex and <TT>indexArray(2,:)</TT> is the maxIndex
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, the default is that all dimensions will be arbitrarily
         distributed.  
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_CART.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals.  
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>List that has dimCount elements.
        Gives the dimension of each component (e.g. x) array. This is 
        to allow factorization of the coordinate arrays. If not specified
        each component is assumed to be size 1. Note, the default value is different
        from the same argument for a non-arbitrarily distributed grid. 
   
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size dimCount x dimCount. This array describes the
        map of each coordinate array's dimensions onto the grids
        dimensions.  <TT>coordDimMap(i,j)</TT> is the grid dimension of the jth dimension
        of the i'th coordinate array.  If not specified, the default value of
        <TT>coordDimMap(i,1)</TT> is /ESMF_DIM_ARB/ if the ith dimension of the grid is
        arbitrarily distributed, or <TT>i</TT> if the ith dimension is not distributed.
        Note that if j is bigger than <TT>coordDimCount(i)</TT> then it's ignored.
        Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861300000000000000">
27.6.13 ESMF_GridCreate - Create a Grid from a file</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
      function ESMF_GridCreateFrmFile(fileName, &amp;
        convention, purpose, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_Grid) :: ESMF_GridCreateFrmFile
</PRE><EM>ARGUMENTS:</EM>
<PRE>        character (len=*), intent(in)            :: fileName
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        character (len=*), intent(in),  optional :: convention
        character (len=*), intent(in),  optional :: purpose
        integer,           intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_Grid</TT> object from specifications in a file 
   containing an ESMF GridSpec Attribute package in XML format. Currently limited
   to creating a 2D regularly distributed rectilinear Grid; in the future more
   dimensions, grid types and distributions will be supported.
   See Section&nbsp;<A HREF="node5.html#example:GridCrFromFile">27.3.24</A> for an example, as well as the
   accompanying file
   ESMF_DIR/src/Infrastructure/Grid/etc/esmf_grid_shape_tile.xml.

<P>
Requires the third party Xerces C++ XML Parser library to be installed.
   For more details, see the "ESMF Users Guide",
   "Building and Installing the ESMF, Third Party Libraries, Xerces" and
   the website http://xerces.apache.org/xerces-c.

<P>
The arguments are:
   <DL>
<DT><STRONG>fileName</STRONG></DT>
<DD>The name of the XML file to be read, containing ESMF GridSpec Attributes.
   
</DD>
<DT><STRONG>[convention]</STRONG></DT>
<DD>The convention of a grid Attribute package. [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[purpose]</STRONG></DT>
<DD>The purpose of a grid Attribute package.    [CURRENTLY NOT IMPLEMENTED]
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
        Equals <TT>ESMF_RC_LIB_NOT_PRESENT</TT> if Xerces is not present.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861400000000000000">
27.6.14 ESMF_GridCreate - Create a Grid from a SCRIP grid file and a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
   function ESMF_GridCreateFrmScripDistGrd(distgrid, filename, &amp;
     rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFrmScripDistGrd
</PRE><EM>ARGUMENTS:</EM>
<PRE>  
     type(ESMF_DistGrid), intent(in)             :: distgrid
     character(len=*),    intent(in)             :: filename
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This function creates a <TT>ESMF_Grid</TT> object using the grid definition from
   a SCRIP grid file. The grid distribution is defined by a DistGrid object. The
   distrgrid has to match the grid  defined in the file.  This means the distgrid 
   should consist of one 2D tile with the same size in each dimension as the grid in the file.
   The grid defined in the file has to be a 2D logically rectangular grid (i.e. <TT>grid_rank</TT>
   in the file needs to be 2).

<P>
This call is <EM>collective</EM> across the current VM.

<P>
The arguments are:
   <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object that describes how the array is decomposed and
        distributed over DEs. 
   
</DD>
<DT><STRONG>[filename]</STRONG></DT>
<DD>The SCRIP Grid filename.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861500000000000000">
27.6.15 ESMF_GridCreate - Create a Grid from a SCRIP grid file with a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate()
   function ESMF_GridCreateFrmScripReg(filename, regDecomp, &amp;
     decompflag, isSphere, addCornerStagger, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateFrmScripReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>  
     character(len=*),       intent(in)             :: filename
     integer,                intent(in)             :: regDecomp(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Decomp_Flag), intent(in),  optional  :: decompflag(:)
     logical,                intent(in),  optional  :: isSphere
     logical,                intent(in),  optional  :: addCornerStagger
     integer,                intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This function creates a <TT>ESMF_Grid</TT> object using the grid definition from
   a SCRIP grid file. 
   To specify the distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. The array <TT>decompflag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.
   The grid defined in the file has to be a 2D logically rectangular
   grid (i.e. <TT>grid_rank</TT> in the file needs to be 2).

<P>
This call is <EM>collective</EM> across the current VM.

<P>
The arguments are:
   <DL>
<DT><STRONG>[filename]</STRONG></DT>
<DD>The SCRIP Grid filename.
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>A 2 element array specifying how the grid is decomposed.
        Each entry is the number of decounts for that dimension.
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#const:decompflag">9.13</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[isSphere]</STRONG></DT>
<DD>If .true. is a spherical grid, if .false. is regional. Defaults to .true.
   
</DD>
<DT><STRONG>[addCornerStagger]</STRONG></DT>
<DD>Uses the information in the SCRIP file to add the Corner stagger to 
        the Grid. If not specified, defaults to false. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861600000000000000">
27.6.16 ESMF_GridCreate1PeriDim - Create a Grid with one periodic dim and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimI(minIndex,         &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         polekindflag, periodicDim, poleDim,                   &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimI
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>) without a periodic dimension. 
   To specify the irregular distribution, the user passes in an array 
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.   Up to three dimensions can be specified, 
   using the countsPerDEDim1, countsPerDEDim2, countsPerDEDim3 arguments.
   The index of each array element corresponds to a DE number.  The 
   array value at the index is the number of grid cells on the DE in 
   that dimension.  The dimCount of the grid is equal to the number of 
   countsPerDEDim arrays that are specified. 

<P>
Section <A HREF="node5.html#example:2DIrregUniGrid">27.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced 
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location). 
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).  
       If not specified  then grid is 2D. 
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. polekindflag(1)             
        the connection that occurs at the minimum end of the index dimension. polekindflag(2)                       
        the connection that occurs at the maximum end of the index dimension. Please see                        
        Section&nbsp;<A HREF="node5.html#const:polekind">27.2.6</A> for a full list of options. If not specified,                            
        the default is <TT>ESMF_POLETYPE_MONOPOLE</TT> for both.                                                 
   
</DD>
<DT><STRONG>[periodicDim]</STRONG></DT>
<DD>The periodic dimension. If not specified, defaults to 1.                                                
   
</DD>
<DT><STRONG>[poleDim]</STRONG></DT>
<DD>The dimension at who's ends the poles are located. If not specified defaults to 2.         
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861700000000000000">
27.6.17 ESMF_GridCreate1PeriDim - Create a Grid with one periodic dim and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimR(regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                    &amp;
         polekindflag, periodicDim, poleDim,                        &amp;
         coordSys, coordTypeKind,                               &amp;
         coordDep1, coordDep2, coordDep3,                       &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,             &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
The arguments are:
   <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1. 
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#const:decompflag">9.13</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. polekindflag(1)             
        the connection that occurs at the minimum end of the index dimension. polekindflag(2)                       
        the connection that occurs at the maximum end of the index dimension. Please see                        
        Section&nbsp;<A HREF="node5.html#const:polekind">27.2.6</A> for a full list of options. If not specified,                            
        the default is <TT>ESMF_POLETYPE_MONOPOLE</TT> for both.                                                 
   
</DD>
<DT><STRONG>[periodicDim]</STRONG></DT>
<DD>The periodic dimension. If not specified, defaults to 1.                                                
   
</DD>
<DT><STRONG>[poleDim]</STRONG></DT>
<DD>The dimension at who's ends the poles are located. If not specified defaults to 2.         
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
        If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.   
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861800000000000000">
27.6.18 ESMF_GridCreate1PeriDim - Create a Grid with one periodic dim and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate1PeriDim()
       function ESMF_GridCreate1PeriDimA(minIndex, maxIndex,  &amp;
         arbIndexCount, arbIndexList,                         &amp;
         polekindflag, periodicDim, poleDim,                      &amp;
         coordSys, coordTypeKind,                             &amp;
         coordDep1, coordDep2, coordDep3,                     &amp;
         distDim, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate1PeriDimA
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)   	        :: arbIndexCount
        integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_PoleKind_Flag),  intent(in),  optional :: polekindflag(2)
        integer,                   intent(in),  optional :: periodicDim
        integer,                   intent(in),  optional :: poleDim
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the arbitrary distribution, the user passes in an 2D array 
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The 
   size of <TT>distDim</TT> has to agree with the size of the second dimension of 
   <TT>localArbIndex</TT>. 

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.  
   
</DD>
<DT><STRONG>[arbIndexList]</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The 
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[polekindflag]</STRONG></DT>
<DD>Two item array which specifies the type of connection which occurs at the pole. polekindflag(1)             
        the connection that occurs at the minimum end of the index dimension. polekindflag(2)                       
        the connection that occurs at the maximum end of the index dimension. Please see                        
        Section&nbsp;<A HREF="node5.html#const:polekind">27.2.6</A> for a full list of options. If not specified,                            
        the default is <TT>ESMF_POLETYPE_MONOPOLE</TT> for both.                                                 
   
</DD>
<DT><STRONG>[periodicDim]</STRONG></DT>
<DD>The periodic dimension. If not specified, defaults to 1.                                                
   
</DD>
<DT><STRONG>[poleDim]</STRONG></DT>
<DD>The dimension at who's ends the poles are located. If not specified defaults to 2.         
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050861900000000000000">
27.6.19 ESMF_GridCreate2PeriDim - Create a Grid with two periodic dims and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimI(minIndex,         &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimI
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>) without a periodic dimension. 
   To specify the irregular distribution, the user passes in an array 
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.   Up to three dimensions can be specified, 
   using the countsPerDEDim1, countsPerDEDim2, countsPerDEDim3 arguments.
   The index of each array element corresponds to a DE number.  The 
   array value at the index is the number of grid cells on the DE in 
   that dimension.  The dimCount of the grid is equal to the number of 
   countsPerDEDim arrays that are specified. 

<P>
Section <A HREF="node5.html#example:2DIrregUniGrid">27.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced 
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location). 
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).  
       If not specified  then grid is 2D. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862000000000000000">
27.6.20 ESMF_GridCreate2PeriDim - Create a Grid with two periodic dims and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimR(regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                    &amp;
         coordSys, coordTypeKind,                               &amp;
         coordDep1, coordDep2, coordDep3,                       &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,             &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
The arguments are:
   <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1. 
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#const:decompflag">9.13</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
        If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.   
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862100000000000000">
27.6.21 ESMF_GridCreate2PeriDim - Create a Grid with two periodic dims and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreate2PeriDim()
       function ESMF_GridCreate2PeriDimA(minIndex, maxIndex, &amp;
         arbIndexCount, arbIndexList,                        &amp;
         coordSys, coordTypeKind,                            &amp;
         coordDep1, coordDep2, coordDep3,                    &amp;
         distDim, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreate2PeriDimA
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)   	        :: arbIndexCount
        integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the arbitrary distribution, the user passes in an 2D array 
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The 
   size of <TT>distDim</TT> has to agree with the size of the second dimension of 
   <TT>localArbIndex</TT>. 

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.  
   
</DD>
<DT><STRONG>[arbIndexList]</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The 
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862200000000000000">
27.6.22 ESMF_GridCreateNoPeriDim - Create a Grid with no periodic dim and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateNoPeriDim()
       function ESMF_GridCreateNoPeriDimI(minIndex,        &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimI
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: countsPerDEDim1(:)
        integer,                   intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                   intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, irregularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>) without a periodic dimension. 
   To specify the irregular distribution, the user passes in an array 
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.   Up to three dimensions can be specified, 
   using the countsPerDEDim1, countsPerDEDim2, countsPerDEDim3 arguments.
   The index of each array element corresponds to a DE number.  The 
   array value at the index is the number of grid cells on the DE in 
   that dimension.  The dimCount of the grid is equal to the number of 
   countsPerDEDim arrays that are specified. 

<P>
Section <A HREF="node5.html#example:2DIrregUniGrid">27.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced 
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location). 
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).  
       If not specified  then grid is 2D. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862300000000000000">
27.6.23 ESMF_GridCreateNoPeriDim - Create a Grid with no periodic dim and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateNoPeriDim()
       function ESMF_GridCreateNoPeriDimR(regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                     &amp;
         coordSys, coordTypeKind,                                &amp;
         coordDep1, coordDep2, coordDep3,                        &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,              &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimR
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),    intent(in),  optional :: decompflag(:)
        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: gridEdgeLWidth(:)
        integer,                   intent(in),  optional :: gridEdgeUWidth(:)
        integer,                   intent(in),  optional :: gridAlign(:)
        integer,                   intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
        integer,                   intent(in),  optional :: petMap(:,:,:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, regularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
The arguments are:
   <DL>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1. 
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#const:decompflag">9.13</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
        If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.   
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862400000000000000">
27.6.24 ESMF_GridCreateNoPeriDim - Create a Grid with no periodic dim and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridCreateNoPeriodic()
       function ESMF_GridCreateNoPeriDimA(minIndex, maxIndex, &amp;
         arbIndexCount, arbIndexList,                         &amp;
         coordSys, coordTypeKind,                             &amp;
         coordDep1, coordDep2, coordDep3,                     &amp;
         distDim, name, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_Grid) :: ESMF_GridCreateNoPeriDimA
</PRE><EM>ARGUMENTS:</EM>
<PRE>        integer,                   intent(in),  optional :: minIndex(:)
        integer,                   intent(in)            :: maxIndex(:)
        integer,                   intent(in)   	        :: arbIndexCount
        integer,                   intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_CoordSys_Flag),  intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag),  intent(in),  optional :: coordTypeKind
        integer,                   intent(in),  optional :: coordDep1(:)
        integer,                   intent(in),  optional :: coordDep2(:)
        integer,                   intent(in),  optional :: coordDep3(:)
        integer,                   intent(in),  optional :: distDim(:)
        character (len=*),         intent(in),  optional :: name 
        integer,                   intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method creates a single tile, arbitrarily distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the arbitrary distribution, the user passes in an 2D array 
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The 
   size of <TT>distDim</TT> has to agree with the size of the second dimension of 
   <TT>localArbIndex</TT>. 

<P>
The arguments are:
   <DL>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.  
   
</DD>
<DT><STRONG>[arbIndexList]</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The 
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_DIM_ARB/ where
       /ESMF_DIM_ARB/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_DIM_ARB/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_DIM_ARB.        
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862500000000000000">
27.6.25 ESMF_GridDestroy - Release resources associated with a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_GridDestroy(grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid), intent(inout)         :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,         intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_Grid</TT> object and related internal structures. 
   This call does destroy internally created DistGrid and DELayout classes, 
   for example those created by <TT>ESMF_GridCreateShapeTile()</TT>. It also 
   destroys internally created coordinate/item Arrays, for example those 
   created by <TT>ESMF_GridAddCoord()</TT>. However, if the user uses an 
   externally created class, for example creating an Array and setting it 
   using <TT>ESMF_GridSetCoord()</TT>, then that class is not destroyed by 
   this method.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD><TT>ESMF_Grid</TT> to be destroyed.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862600000000000000">
27.6.26 ESMF_GridEmptyComplete - Complete a Grid with user set edge connections and an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridEmptyComplete()
       subroutine ESMF_GridEmptyCompleteEConnI(grid, minIndex,         &amp;
         countsPerDEDim1,countsPerDeDim2,                  &amp;
         countsPerDEDim3,                                  &amp;
         connDim1, connDim2, connDim3,                     &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,        &amp;
         gridMemLBound, indexflag, petMap, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: countsPerDEDim1(:)
        integer,                  intent(in)            :: countsPerDEDim2(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,                  intent(in),  optional :: countsPerDEDim3(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name 
        integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method takes in an empty Grid created by <TT>ESMF_GridEmptyCreate()</TT>.
   It then completes the grid to form a single tile, irregularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>). To specify the irregular distribution, the user passes in an array 
   for each grid dimension, where the length of the array is the number
   of DEs in the dimension.   Up to three dimensions can be specified, 
   using the countsPerDEDim1, countsPerDEDim2, countsPerDEDim3 arguments.
   The index of each array element corresponds to a DE number.  The 
   array value at the index is the number of grid cells on the DE in 
   that dimension.  The dimCount of the grid is equal to the number of 
   countsPerDEDim arrays that are specified. 

<P>
Section <A HREF="node5.html#example:2DIrregUniGrid">27.3.4</A> shows an example
   of using this method to create a 2D Grid with uniformly spaced 
   coordinates.  This creation method can also be used as the basis for
   grids with rectilinear coordinates or curvilinear coordinates.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The empty <TT>ESMF_Grid</TT> to set information into and then commit.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>countsPerDEDim1</STRONG></DT>
<DD>This arrays specifies the number of cells per DE for index dimension 1
       for the exclusive region (the center stagger location).
   
</DD>
<DT><STRONG>countsPerDEDim2</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 2
       for the exclusive region (center stagger location). 
   
</DD>
<DT><STRONG>[countsPerDEDim3]</STRONG></DT>
<DD>This array specifies the number of cells per DE for index dimension 3
       for the exclusive region (center stagger location).  
       If not specified  then grid is 2D. 
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size size(countsPerDEDim1) x size(countsPerDEDim2) x
         size(countsPerDEDim3). If countsPerDEDim3 isn't present, then
         the last dimension is of size 1.

</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862700000000000000">
27.6.27 ESMF_GridEmptyComplete - Complete a Grid with user set edge connections and a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridEmptyComplete()
      subroutine ESMF_GridEmptyCompleteEConnR(grid, regDecomp, decompFlag, &amp;
         minIndex, maxIndex,                                    &amp;
         connDim1, connDim2, connDim3,                       &amp;
         coordSys, coordTypeKind,                            &amp;
         coordDep1, coordDep2, coordDep3,                    &amp;
         gridEdgeLWidth, gridEdgeUWidth, gridAlign,          &amp;
         gridMemLBound, indexflag, petMap, name, rc)
 
  !
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: regDecomp(:)
        type(ESMF_Decomp_Flag),   intent(in),  optional :: decompflag(:)
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: gridEdgeLWidth(:)
        integer,                  intent(in),  optional :: gridEdgeUWidth(:)
        integer,                  intent(in),  optional :: gridAlign(:)
        integer,                  intent(in),  optional :: gridMemLBound(:)
        type(ESMF_Index_Flag),    intent(in),  optional :: indexflag
        integer,                  intent(in),  optional :: petMap(:,:,:)
        character (len=*),        intent(in),  optional :: name 
        integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method takes in an empty Grid created by <TT>ESMF_GridEmptyCreate()</TT>.
   It then completes the grid to form a single tile, regularly distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the distribution, the user passes in an array 
   (<TT>regDecomp</TT>) specifying the number of DEs to divide each 
   dimension into. The array <TT>decompFlag</TT> indicates how the division into DEs is to
   occur.  The default is to divide the range as evenly as possible.

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The empty <TT>ESMF_Grid</TT> to set information into and then commit.
   
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List that has the same number of elements as <TT>maxIndex</TT>.
        Each entry is the number of decounts for that dimension.
        If not specified, the default decomposition will be petCountx1x1..x1. 
   
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
        tile is to be divided between the DEs. The default setting
        is <TT>ESMF_DECOMP_HOMOGEN</TT> in all dimensions. Please see
        Section&nbsp;<A HREF="node2.html#const:decompflag">9.13</A> for a full description of the 
        possible options. 
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>The bottom extent of the grid array. If not given then the value defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The upper extent of the grid array.
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
        If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>This array specifies the dependence of the first 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the first
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank. 
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>This array specifies the dependence of the second 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the second
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>This array specifies the dependence of the third 
       coordinate component on the three index dimensions
       described by <TT>coordsPerDEDim1,2,3</TT>. The size of the 
       array specifies the number of dimensions of the third
       coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. If not present the default is 1,2,...,grid rank.  
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. This padding is between
        the index space corresponding to the cells and the boundary of the 
        the exclusive region. This extra space is to contain the extra
        padding for non-center stagger locations, and should be big enough
        to hold any stagger in the grid. It is an error for this to be non-zero 
        for a periodic dimension. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space (can be overridden by the individual staggerAligns). If
       the <TT>gridEdgeWidths</TT> are not specified than this parameter
       implies the EdgeWidths.
   
</DD>
<DT><STRONG>[gridMemLBound]</STRONG></DT>
<DD>Specifies the lower index range of the memory of every DE in this Grid. 
        Only used when indexflag is <TT>ESMF_INDEX_USER</TT>. May be overridden
        by staggerMemLBound. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates the indexing scheme to be used in the new Grid. Please see
        Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. If not present,
        defaults to ESMF_INDEX_DELOCAL.
   
</DD>
<DT><STRONG>[petMap]</STRONG></DT>
<DD>Sets the mapping of pets to the created DEs. This 3D
         should be of size regDecomp(1) x regDecomp(2) x regDecomp(3)
         If the Grid is 2D, then the last dimension is of size 1.   
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862800000000000000">
27.6.28 ESMF_GridEmptyComplete - Complete a Grid with user set edge connections and an arbitrary distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridEmptyComplete()
       subroutine ESMF_GridEmptyCompleteEConnA(grid, minIndex, maxIndex,  &amp;
         arbIndexCount, arbIndexList,                         &amp;
         connDim1, connDim2, connDim3,                     &amp;
         coordSys, coordTypeKind,                          &amp;
         coordDep1, coordDep2, coordDep3,                  &amp;
         distDim, name, rc)
  !
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type (ESMF_Grid)                                :: grid
        integer,                  intent(in),  optional :: minIndex(:)
        integer,                  intent(in)            :: maxIndex(:)
        integer,                  intent(in)            :: arbIndexCount
        integer,                  intent(in)            :: arbIndexList(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim1(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim2(:)
        type(ESMF_GridConn_Flag), intent(in),  optional :: connDim3(:)
        type(ESMF_CoordSys_Flag), intent(in),  optional :: coordSys
        type(ESMF_TypeKind_Flag), intent(in),  optional :: coordTypeKind
        integer,                  intent(in),  optional :: coordDep1(:)
        integer,                  intent(in),  optional :: coordDep2(:)
        integer,                  intent(in),  optional :: coordDep3(:)
        integer,                  intent(in),  optional :: distDim(:)
        character (len=*),        intent(in),  optional :: name 
        integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method takes in an empty Grid created by <TT>ESMF_GridEmptyCreate()</TT>.
   It then completes the grid to form a single tile, arbitrarily distributed grid 
   (see Figure <A HREF="node5.html#fig:GridDecomps">13</A>).
   To specify the arbitrary distribution, the user passes in an 2D array 
   of local indices, where the first dimension is the number of local grid cells
   specified by <TT>localArbIndexCount</TT> and the second dimension is the number of distributed
   dimensions.

<P>
<TT>distDim</TT> specifies which grid dimensions are arbitrarily distributed. The 
   size of <TT>distDim</TT> has to agree with the size of the second dimension of 
   <TT>localArbIndex</TT>. 

<P>
The arguments are:
   <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The empty <TT>ESMF_Grid</TT> to set information into and then commit.
   
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Tuple to start the index ranges at. If not present, defaults
        to /1,1,1,.../.
   
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>The upper extend of the grid index ranges.
   
</DD>
<DT><STRONG>arbIndexCount</STRONG></DT>
<DD>The number of grid cells in the local DE. It is okay to have 0
        grid cell in a local DE.  
   
</DD>
<DT><STRONG>[arbIndexList]</STRONG></DT>
<DD>This 2D array specifies the indices of the PET LOCAL grid cells.  The 
        dimensions should be arbIndexCount * number of Distributed grid dimensions
        where arbIndexCount is the input argument specified below
   
</DD>
<DT><STRONG>[connDim1]</STRONG></DT>
<DD>Fortran array describing the index dimension 1 connections.
        The first element represents the minimum end of dimension 1.
        The second element represents the maximum end of dimension 1.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connDim2]</STRONG></DT>
<DD>Fortran array describing the index dimension 2 connections.
        The first element represents the minimum end of dimension 2.
        The second element represents the maximum end of dimension 2.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[connDim3]</STRONG></DT>
<DD>Fortran array describing the index dimension 3 connections.
        The first element represents the minimum end of dimension 3.
        The second element represents the maximum end of dimension 3.
        If array is only one element long, then that element is used
        for both the minimum and maximum end. 
        Please see Section&nbsp;<A HREF="node5.html#const:gridconn">27.2.2</A> for a list of valid 
        options. If not present, defaults to ESMF_GRIDCONN_NONE. 
   
</DD>
<DT><STRONG>[coordSys]</STRONG></DT>
<DD>The coordinate system of the grid coordinate data. 
       For a full list of options, please see Section&nbsp;<A HREF="node5.html#const:coordsys">27.2.1</A>. 
       If not specified then defaults to ESMF_COORDSYS_SPH_DEG.  
   
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
       If not specified then the type/kind will be 8 byte reals. 
   
</DD>
<DT><STRONG>[coordDep1]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       first coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if the first dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=1)
        Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_GRID_ARBDIM.        
   
</DD>
<DT><STRONG>[coordDep2]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       second coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=2)
       Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_GRID_ARBDIM.        
   
</DD>
<DT><STRONG>[coordDep3]</STRONG></DT>
<DD>The size of the array specifies the number of dimensions of the 
       third coordinate component array. The values specify which
       of the index dimensions the corresponding coordinate
       arrays map to. The format should be /ESMF_GRID_ARBDIM/ where
       /ESMF_GRID_ARBDIM/ is mapped to the collapsed 1D dimension from all
       the arbitrarily distributed dimensions.  n is the dimension that 
       is not distributed (if exists).  
       If not present the default is /ESMF_GRID_ARBDIM/ if this dimension
       is arbitararily distributed, or /n/ if not distributed (i.e. n=3)
        Please see Section&nbsp;<A HREF="node2.html#const:arbdim">9.2</A> for a definition of ESMF_GRID_ARBDIM.        
   
</DD>
<DT><STRONG>[distDim]</STRONG></DT>
<DD>This array specifies which dimensions are arbitrarily distributed.
         The size of the array specifies the total distributed dimensions.
         if not specified, defaults is all dimensions will be arbitrarily
         distributed.  The size has to agree with the size of the second
         dimension of <TT>localArbIndex</TT>.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050862900000000000000">
27.6.29 ESMF_GridEmptyCreate - Create a Grid that has no contents</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>      function ESMF_GridEmptyCreate(rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>      type(ESMF_Grid) :: ESMF_GridEmptyCreate
</PRE><EM>ARGUMENTS:</EM>
<PRE> -- The following arguments require argument keyword syntax (e.g. rc=rc). --
        integer,  intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Partially create an <TT>ESMF_Grid</TT> object. This function allocates 
   an <TT>ESMF_Grid</TT> object, but doesn't allocate any coordinate storage or other
   internal structures. The <TT>ESMF_GridEmptyComplete()</TT> calls
   can be used to set the values in the grid object and to construct the 
   internal structure. 

<P>
The arguments are:
   <DL>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863000000000000000">
27.6.30 ESMF_GridGet - Get information about a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetDefault(grid, coordTypeKind, &amp;
         dimCount, tileCount, staggerlocCount, localDECount, distgrid, &amp;
         distgridToGridMap, coordDimCount, coordDimMap, arbDim, &amp;
         rank, arbDimCount, gridEdgeLWidth, gridEdgeUWidth, gridAlign,  &amp;
         indexFlag, status, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),            intent(in)            :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_TypeKind_Flag),   intent(out), optional :: coordTypeKind
       integer,                    intent(out), optional :: dimCount
       integer,                    intent(out), optional :: tileCount
       integer,                    intent(out), optional :: staggerlocCount
       integer,                    intent(out), optional :: localDECount
       type(ESMF_DistGrid),        intent(out), optional :: distgrid
       integer,       target,      intent(out), optional :: distgridToGridMap(:)
       integer,       target,      intent(out), optional :: coordDimCount(:)
       integer,       target,      intent(out), optional :: coordDimMap(:,:)
       integer,                    intent(out), optional :: arbDim
       integer,                    intent(out), optional :: rank
       integer,                    intent(out), optional :: arbDimCount
       integer,       target,      intent(out), optional :: gridEdgeLWidth(:)
       integer,       target,      intent(out), optional :: gridEdgeUWidth(:)
       integer,       target,      intent(out), optional :: gridAlign(:)
       type(ESMF_Index_Flag),      intent(out), optional :: indexflag
       type(ESMF_GridStatus_Flag), intent(out), optional :: status
       character (len=*),          intent(out), optional :: name
       integer,                    intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Gets various types of information about a grid. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>[coordTypeKind]</STRONG></DT>
<DD>The type/kind of the grid coordinate data. 
     If not specified then the type/kind will be 8 byte reals.  
  
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>DimCount of the Grid object.
  
</DD>
<DT><STRONG>[tileCount]</STRONG></DT>
<DD>The number of logically rectangular tiles in the grid. 
  
</DD>
<DT><STRONG>[staggerlocCount]</STRONG></DT>
<DD>The number of stagger locations.
  
</DD>
<DT><STRONG>[localDECount]</STRONG></DT>
<DD>The number of DEs in this grid on this PET.
  
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The structure describing the distribution of the grid. 
  
</DD>
<DT><STRONG>[distgridToGridMap]</STRONG></DT>
<DD>List that has as many elements as the distgrid dimCount. This array describes
     mapping between the grids dimensions and the distgrid.
   
</DD>
<DT><STRONG>[coordDimCount]</STRONG></DT>
<DD>List that has as many elements as the grid dimCount (from arrayspec).
     Gives the dimension of each component (e.g. x) array. This is 
     to allow factorization of the coordinate arrays. If not specified
     all arrays are the same size as the grid. 
  
</DD>
<DT><STRONG>[coordDimMap]</STRONG></DT>
<DD>2D list of size grid dimCount x grid dimCount. This array describes the
     map of each component array's dimensions onto the grids
     dimensions.
   
</DD>
<DT><STRONG>[arbDim]</STRONG></DT>
<DD>The distgrid dimension that is mapped by the arbitrarily distributed grid dimensions.
   
</DD>
<DT><STRONG>[rank]</STRONG></DT>
<DD>The count of the memory dimensions, it is the same as dimCount for a non-arbitrarily distributed grid,
     and equal or less for a arbitrarily distributed grid.
   
</DD>
<DT><STRONG>[arbDimCount]</STRONG></DT>
<DD>The number of dimensions distributed arbitrarily for an arbitrary grid, 0 if the grid is non-arbitrary.
   
</DD>
<DT><STRONG>[gridEdgeLWidth]</STRONG></DT>
<DD>The padding around the lower edges of the grid. The array should
     be of size greater or equal to the Grid dimCount.
   
</DD>
<DT><STRONG>[gridEdgeUWidth]</STRONG></DT>
<DD>The padding around the upper edges of the grid. The array should
     be of size greater or equal to the Grid dimCount. 
   
</DD>
<DT><STRONG>[gridAlign]</STRONG></DT>
<DD>Specification of how the stagger locations should align with the cell
       index space. The array should be of size greater or equal to the Grid dimCount. 
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag indicating the indexing scheme being used in the Grid. Please
      see Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A> for the list of options. 
   
</DD>
<DT><STRONG>[status]</STRONG></DT>
<DD>Flag indicating the status of the Grid. Please
      see Section&nbsp;<A HREF="node5.html#const:gridstatus">27.2.5</A> for the list of options. 
  
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD><TT>ESMF_Grid</TT> name.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863100000000000000">
27.6.31 ESMF_GridGet - Get information about a particular DE in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPLocalDe(grid, localDe, &amp;
         isLBound,isUBound, arbIndexCount, arbIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: localDe
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       logical,                intent(out), optional :: isLBound(:)
       logical,                intent(out), optional :: isUBound(:)
       integer,                intent(out), optional :: arbIndexCount
       integer,        target, intent(out), optional :: arbIndexList(:,:)
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This call gets information about a particular local DE in a Grid. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDeCount-1]</TT> 
  
</DD>
<DT><STRONG>[isLBound]</STRONG></DT>
<DD>Upon return, for each dimension this indicates if the DE is a lower bound of the Grid.
       <TT>isLBound</TT> must be allocated to be of size equal to the Grid dimCount.
  
</DD>
<DT><STRONG>[isUBound]</STRONG></DT>
<DD>Upon return, for each dimension this indicates if the DE is an upper bound of the Grid.
       <TT>isUBound</TT> must be allocated to be of size equal to the Grid dimCount.
   
</DD>
<DT><STRONG>[arbIndexCount]</STRONG></DT>
<DD>The number of local cells for an arbitrarily distributed grid
   
</DD>
<DT><STRONG>[arbIndexList]</STRONG></DT>
<DD>The 2D array storing the local cell indices for an arbitrarily distributed grid. The size of the array 
     is arbIndexCount * arbDimCount 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863200000000000000">
27.6.32 ESMF_GridGet - Get information about a particular DE in a stagger location in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPLocalDePSloc(grid, staggerloc, localDE, &amp;
         exclusiveLBound, exclusiveUBound, exclusiveCount,  &amp;
         computationalLBound, computationalUBound, computationalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: localDe
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a 
    particular stagger location occupies. This call differs from the coordinate 
    bound calls (e.g. <TT>ESMF_GridGetCoord</TT>) in that a given coordinate 
    array may only occupy a subset of the Grid's dimensions, and
    so these calls may not give all the bounds of the stagger location. 
    The bounds from this call are the full bounds, and so
    for example, give the appropriate bounds for allocating a Fortran array to hold 
    data residing on the stagger location.
    Note that unlike the output from the Array, these values also include the 
    undistributed dimensions and are
    ordered to reflect the order of the indices in the Grid. This call will 
    still give correct values even if the stagger location does not contain
    coordinate arrays (e.g. if  <TT>ESMF_GridAddCoord</TT> hasn't yet 
    been called on the stagger location).

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
       of predefined stagger locations.
  
</DD>
<DT><STRONG>[localDe]</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDeCount-1]</TT> 
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items,<TT>exclusiveUBound-exclusiveLBound+1</TT>,
       in the exclusive region per dimension.
       <TT>exclusiveCount</TT> must
       be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension.
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT> must
        be allocated to be of size equal to the Grid dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863300000000000000">
27.6.33 ESMF_GridGet - Get information about a particular stagger location in a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPSloc(grid, staggerloc, &amp;
         distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type(ESMF_DistGrid),    intent(out), optional :: distgrid
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about a particular stagger location. 
    This information is useful for creating an ESMF Array to hold
    the data at the stagger location. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
       of predefined stagger locations. 
  
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The structure describing the distribution of this staggerloc in this grid. 
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863400000000000000">
27.6.34 ESMF_GridGet - Get information about a particular stagger location and tile </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGet()
       subroutine ESMF_GridGetPSlocPTile(grid, tile, staggerloc, &amp;
         minIndex, maxIndex, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: tile
       type (ESMF_StaggerLoc), intent(in)            :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,        target, intent(out), optional :: minIndex(:)
       integer,        target, intent(out), optional :: maxIndex(:)
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about a particular stagger location. 
    This information is useful for creating an ESMF Array to hold
    the data at the stagger location. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>tile</STRONG></DT>
<DD>The tile number to get the data from. Tile numbers range from 1 to TileCount. 
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
       of predefined stagger locations. 
  
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Upon return this holds the global lower index of this stagger location.
       <TT>minIndex</TT> must be allocated to be of size equal to the grid DimCount.
       Note that this value is only for the first Grid tile, as multigrid support
       is added, this interface will likely be changed or moved to adapt.  
  
</DD>
<DT><STRONG>[maxIndex]</STRONG></DT>
<DD>Upon return this holds the global upper index of this stagger location.
       <TT>maxIndex</TT> must be allocated to be of size equal to the grid DimCount.
       Note that this value is only for the first Grid tile, as multigrid support
       is added, this interface will likely be changed or moved to adapt.  
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863500000000000000">
27.6.35 ESMF_GridGetCoord - Get a Fortran pointer to Grid coord data and coord bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_GridGetCoord(grid, coordDim,    &amp;
          staggerloc, localDE, &lt;pointer argument&gt;,                       &amp;
          exclusiveLBound, exclusiveUBound, exclusiveCount,              &amp;
          computationalLBound, computationalUBound, computationalCount,  &amp;
          totalLBound, totalUBound, totalCount,                          &amp;
          datacopyflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),       intent(in)            :: grid
       integer,               intent(in)            :: coordDim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc) intent(in),  optional :: staggerloc
       integer,               intent(in),  optional :: localDE
       &lt;pointer argument&gt;, see below for supported values
       integer,               intent(out), optional :: exclusiveLBound(:)
       integer,               intent(out), optional :: exclusiveUBound(:)
       integer,               intent(out), optional :: exclusiveCount(:)
       integer,               intent(out), optional :: computationalLBound(:)
       integer,               intent(out), optional :: computationalUBound(:)
       integer,               intent(out), optional :: computationalCount(:)
       integer,               intent(out), optional :: totalLBound(:)
       integer,               intent(out), optional :: totalUBound(:)
       integer,               intent(out), optional :: totalCount(:)
       type(ESMF_DataCopy_Flag), intent(in),  optional :: datacopyflag
       integer,               intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
       coordinate data on the local DE for the given coordinate dimension and stagger
       locations. 
       This is useful, for example, for setting the coordinate values in a Grid, or
       for reading the coordinate values.  Currently this method supports up to three
       coordinate dimensions, of either R4 or R8 datatype.  See below for specific 
       supported values.  If the coordinates that you are trying to retrieve are of
       higher dimension, use the <TT>ESMF_GetCoord()</TT> interface that returns coordinate
       values in an <TT>ESMF_Array</TT> instead.  That interface supports the retrieval of
       coordinates up to 7D. 

<P>
Supported values for the &lt;pointer argument&gt; are: 
       <DL>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:,:)     
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:,:)     
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:,:,:)
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the data from (e.g. 1=x).
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
            Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>The pointer to the coordinate data.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
            <TT>exclusiveLBound</TT> must be allocated to be of size equal to the coord dimCount.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>,
            in the exclusive region per dimension.
            <TT>exclusiveCount</TT> must
            be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
            <TT>computationalLBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
            must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
            <TT>totalLBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
            <TT>totalUBound</TT> must be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
            (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
            be allocated to be of size equal to the coord dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATACOPY_REFERENCE</TT>, in this case
            farrayPtr is a reference to the data in the Grid coordinate arrays. 
            Please see Section&nbsp;<A HREF="node2.html#const:datacopyflag">9.12</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863600000000000000">
27.6.36 ESMF_GridGetCoord - Get coordinates and put in an Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordIntoArray(grid, coordDim, staggerloc, &amp;
         array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       type(ESMF_Array),       intent(out)           :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method allows the user to get access to the ESMF Array holding
      coordinate data at a particular stagger location. This is useful, for example, 
      to set the coordinate values. To have an Array to access, the coordinate Arrays
      must have already been allocated, for example by <TT>ESMF_GridAddCoord</TT> or
      <TT>ESMF_GridSetCoord</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The grid to get the coord array from. 
       
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the data from (e.g. 1=x).
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location from which to get the arrays. 
            Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array into which to put the coordinate infomation. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863700000000000000">
27.6.37 ESMF_GridGetCoord - Get coordinates from a specific index location</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordR4(grid, staggerloc, localDe, &amp;
         index, coord, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,                intent(in)            :: index(:)
       real(ESMF_KIND_R4),     intent(out)           :: coord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Given a specific index location in a Grid, this method returns the full set
     of coordinates from that index location. This method will eventually be overloaded
     to support the full complement of types supported by the Grid. 

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
            Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
            of predefined stagger locations. If not present, defaults to
            ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>index</STRONG></DT>
<DD>This array holds the index location to be queried in the Grid. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>coord</STRONG></DT>
<DD>This array will be filled with the coordinate data. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863800000000000000">
27.6.38 ESMF_GridGetCoord - Get coordinates from a specific index location</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetCoord()
       subroutine ESMF_GridGetCoordR8(grid, staggerloc, localDE, &amp;
         index, coord, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,                intent(in)            :: index(:)
       real(ESMF_KIND_R8),     intent(out)           :: coord(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Given a specific index location in a Grid, this method returns the full set
     of coordinates from that index location. This method will eventually be overloaded
     to support the full complement of types supported by the Grid. 

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
            Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
            of predefined stagger locations. If not present, defaults to
            ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>index</STRONG></DT>
<DD>This array holds the index location to be queried in the Grid. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>coord</STRONG></DT>
<DD>This array will be filled with the coordinate data. This array must
            at least be of the size Grid rank.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050863900000000000000">
27.6.39 ESMF_GridGetCoordBounds - Get Grid coordinate bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_GridGetCoordBounds(grid, coordDim,   &amp;
         staggerloc, localDE, exclusiveLBound, exclusiveUBound, &amp;
         exclusiveCount, computationalLBound, computationalUBound , &amp; 
         computationalCount, totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,        target, intent(out), optional :: totalLBound(:)
       integer,        target, intent(out), optional :: totalUBound(:)
       integer,        target, intent(out), optional :: totalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a particular
    piece of coordinate data occupies.  In other words, this method returns the 
    bounds of the coordinate arrays.  Note that unlike the output from the 
    Array, these values also include the undistributed dimensions and are
    ordered to reflect the order of the indices in the coordinate. So, for example,
    <TT>totalLBound</TT> and <TT>totalUBound</TT> should match the bounds of the Fortran array
    retrieved by <TT>ESMF_GridGetCoord</TT>. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to get the information for (e.g. 1=x). 
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
       of predefined stagger locations. If not present, defaults to
       ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>[localDE]</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDeCount-1]</TT>
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>,
       in the exclusive region per dimension.
       <TT>exclusiveCount</TT> must
       be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
        must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       <TT>totalLBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       <TT>totalUBound</TT> must be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
       (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
        be allocated to be of size equal to the coord dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050864000000000000000">
27.6.40 ESMF_GridGetItem - Get a Fortran pointer to Grid item data and item bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>        subroutine ESMF_GridGetItem(grid, itemflag,  &amp;
          staggerloc, localDE, &lt;pointer argument&gt;, 
          exclusiveLBound, exclusiveUBound, exclusiveCount, &amp;
          computationalLBound, computationalUBound, computationalCount,  &amp;
          totalLBound, totalUBound, totalCount,                          &amp;
          datacopyflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),      intent(in)            :: grid
       type (ESMF_GridItem_Flag),intent(in)        :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,              intent(in),  optional :: localDE
       &lt;pointer argument&gt;, see below for supported values
       integer,              intent(out), optional :: exclusiveLBound(:)
       integer,              intent(out), optional :: exclusiveUBound(:)
       integer,              intent(out), optional :: exclusiveCount(:)
       integer,              intent(out), optional :: computationalLBound(:)
       integer,              intent(out), optional :: computationalUBound(:)
       integer,              intent(out), optional :: computationalCount(:)
       integer,              intent(out), optional :: totalLBound(:)
       integer,              intent(out), optional :: totalUBound(:)
       integer,              intent(out), optional :: totalCount(:)
       type(ESMF_DataCopy_Flag), intent(in),  optional :: datacopyflag
       integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
       item data on the local DE for the given stagger locations. 
       This is useful, for example, for setting the item values in a Grid, or
       for reading the item values.  Currently this method supports up to three
       grid dimensions, but is limited to the I4 datatype.  See below for specific 
       supported values.  If the item values that you are trying to retrieve are of
       higher dimension, use the <TT>ESMF_GetItem()</TT> interface that returns coordinate
       values in an <TT>ESMF_Array</TT> instead.  That interface supports the retrieval of
       coordinates up to 7D. 

<P>
Supported values for the &lt;pointer argument&gt; are: 
       <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: farrayPtr(:,:)     
       
</DD>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: farrayPtr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:,:)     
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farrayPtr(:,:,:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:)
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:,:)     
       
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farrayPtr(:,:,:)
       
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
       
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item to get the information for. Please see Section&nbsp;<A HREF="node5.html#const:griditem">27.2.3</A> for a 
            list of valid items.  
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
            Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>farrayPtr</STRONG></DT>
<DD>The pointer to the item data.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
            <TT>exclusiveLBound</TT> must be allocated to be of size equal to the grid dimCount.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the grid dimCount.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region per dimension
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT> must
            be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
            <TT>computationalLBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
            <TT>exclusiveUBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
            must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
            <TT>totalLBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
            <TT>totalUBound</TT> must be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts. 
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
            (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
            be allocated to be of size equal to the grid dimCount.
            Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
            of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATACOPY_REFERENCE</TT>, in this case
            farrayPtr is a reference to the data in the Grid item arrays. 
            Please see Section&nbsp;<A HREF="node2.html#const:datacopyflag">9.12</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050864100000000000000">
27.6.41 ESMF_GridGetItem - Get item and put into an Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_GridGetItem()
       subroutine ESMF_GridGetItemIntoArray(grid, itemflag,  staggerloc, &amp;
         array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),           intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)            :: itemflag
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc
       type(ESMF_Array),          intent(out)           :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method allows the user to get access to the ESMF Array holding
      item data at a particular stagger location. This is useful, for example, 
      to set the item values. To have an Array to access, the item Array
      must have already been allocated, for example by <TT>ESMF_GridAddItem</TT> or
      <TT>ESMF_GridSetItem</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item from which to get the arrays. Please see Section&nbsp;<A HREF="node5.html#const:griditem">27.2.3</A> for a 
            list of valid items.  
       
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location from which to get the arrays. 
            Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
            of predefined stagger locations. If not present, defaults to ESMF_STAGGERLOC_CENTER.
       
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array into which to put the item infomation. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050864200000000000000">
27.6.42 ESMF_GridGetItemBounds - Get Grid item bounds</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_GridGetItemBounds(grid, itemflag,  &amp;
         staggerloc, localDE, &amp;
         exclusiveLBound, exclusiveUBound, exclusiveCount, &amp;
         computationalLBound, computationalUBound, computationalCount,  &amp;
         totalLBound, totalUBound, totalCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)         :: itemflag
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       integer,                intent(in),  optional :: localDE
       integer,        target, intent(out), optional :: exclusiveLBound(:)
       integer,        target, intent(out), optional :: exclusiveUBound(:)
       integer,        target, intent(out), optional :: exclusiveCount(:)
       integer,        target, intent(out), optional :: computationalLBound(:)
       integer,        target, intent(out), optional :: computationalUBound(:)
       integer,        target, intent(out), optional :: computationalCount(:)
       integer,        target, intent(out), optional :: totalLBound(:)
       integer,        target, intent(out), optional :: totalUBound(:)
       integer,        target, intent(out), optional :: totalCount(:)
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets information about the range of index space which a particular
    piece of item data occupies.  In other words, this method returns the 
    bounds of the item arrays.  Note that unlike the output from the 
    Array, these values also include the undistributed dimensions and are
    ordered to reflect the order of the indices in the item. So, for example,
    <TT>totalLBound</TT> and <TT>totalUBound</TT> should match the bounds of the Fortran array
    retrieved by <TT>ESMF_GridGetItem</TT>. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Grid to get the information from.
  
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item to get the information for. Please see Section&nbsp;<A HREF="node5.html#const:griditem">27.2.3</A> for a 
            list of valid items.   
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location to get the information for. 
       Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
       of predefined stagger locations. If not present, defaults to
       ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE from which to get the information. <TT>[0,..,localDeCount-1]</TT>
  
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       <TT>exclusiveLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       <TT>exclusiveUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items, <TT>exclusiveUBound-exclusiveLBound+1</TT>,
       in the exclusive region per dimension.
       <TT>exclusiveCount</TT> must
       be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the stagger region.
       <TT>computationalLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the stagger region.
       <TT>computationalUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region per dimension
       (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>
        must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       <TT>totalLBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       <TT>totalUBound</TT> must be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts. 
  
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region per dimension
       (i.e. <TT>totalUBound-totalLBound+1</TT>). <TT>totalCount</TT> must
        be allocated to be of size equal to the item dimCount.
       Please see Section&nbsp;<A HREF="node5.html#sec:grid:usage:bounds">27.3.16</A> for a description
       of the regions and their associated bounds and counts.

</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050864300000000000000">
27.6.43 ESMF_GridMatch - Check if two Grid objects match</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_GridMatch(grid1, grid2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_GridMatch_Flag) :: ESMF_GridMatch
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid),  intent(in)              :: grid1
     type(ESMF_Grid),  intent(in)              :: grid2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out),  optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Check if <TT>grid1</TT> and <TT>grid2</TT> match. Returns a range of values of type
    ESMF_GridMatch indicating how closely the Grids match. For a description of
    the possible return values, please see&nbsp;<A HREF="node5.html#const:gridmatch">27.2.4</A>. 
    Please also note that this call returns the match for the piece of the Grids on
    the local PET only. It's entirely possible for this call to return a different match
    on different PETs for the same Grids. The user is responsible for computing the 
    global match across the set of PETs. 

<P>
The arguments are:
       <DL>
<DT><STRONG>grid1</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>grid2</STRONG></DT>
<DD><TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050864400000000000000">
27.6.44 ESMF_GridSetCoord - Set coordinates using Arrays</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_GridSetCoordFromArray(grid, coordDim, staggerloc, &amp;
         array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),        intent(in)            :: grid
       integer,                intent(in)            :: coordDim
       type (ESMF_StaggerLoc), intent(in),  optional :: staggerloc
       type(ESMF_Array),       intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method sets the passed in Array as the holder of the coordinate data
     for stagger location <TT>staggerloc</TT> and coordinate <TT>coord</TT>. If the location
     already contains an Array, then this one overwrites it. 

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The grid to set the coord in.
  
</DD>
<DT><STRONG>coordDim</STRONG></DT>
<DD>The coordinate dimension to put the data in (e.g. 1=x).
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location into which to copy the arrays. 
      Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
      of predefined stagger locations. If not present, defaults to
      ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array to set the grid coordinate information from.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050864500000000000000">
27.6.45 ESMF_GridSetItem - Set an item using an Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_GridSetItemFromArray(grid, itemflag,  staggerloc, &amp;
         array, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_Grid),           intent(in)            :: grid
       type (ESMF_GridItem_Flag), intent(in)            :: itemflag
       type (ESMF_StaggerLoc),    intent(in),  optional :: staggerloc 
       type(ESMF_Array),          intent(in)            :: array
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,                   intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This method sets the passed in Array as the holder of the item data
     for stagger location <TT>staggerloc</TT> and coordinate <TT>coord</TT>. If the location
     already contains an Array, then this one overwrites it. 

<P>
Eventually there should be an Add, Get,... like for the Coords to make things
     easy for the user (except restricted to just I4??)

<P>
The arguments are:
  <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>The grid in which to set the array.
  
</DD>
<DT><STRONG>itemflag</STRONG></DT>
<DD>The item into which to copy the arrays. Please see Section&nbsp;<A HREF="node5.html#const:griditem">27.2.3</A> for a 
            list of valid items.   
  
</DD>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The stagger location into which to copy the arrays. 
      Please see Section&nbsp;<A HREF="node5.html#const:staggerloc">27.2.7</A> for a list 
      of predefined stagger locations. If not present, defaults to
      ESMF_STAGGERLOC_CENTER.
  
</DD>
<DT><STRONG>array</STRONG></DT>
<DD>An array to set the grid item information from.
  
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
  
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050864600000000000000">
27.6.46 ESMF_GridValidate - Validate Grid internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_GridValidate(grid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Grid), intent(in)              :: grid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,         intent(out),  optional  :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>Grid</TT> is internally consistent.
        Note that one of the checks that the Grid validate does
        is the Grid status. Currently, the validate will return
        an error if the grid is not at least 
        <TT>ESMF_GRIDSTATUS_COMPLETE</TT>. This means that
        if a Grid was created with the <TT>ESMF_GridEmptyCreate</TT>
        method, it must also have been finished with
        <TT>ESMF_GridEmptyComplete()</TT>
        to be valid. If a Grid was created with another create
        call it should automatically have the correct status level
        to pass the status part of the validate. 
        The Grid validate at this time doesn't check for the presence
        or consistency of the Grid coordinates.  
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>grid</STRONG></DT>
<DD>Specified <TT>ESMF_Grid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION05087000000000000000">
27.7 Class API: StaggerLoc Methods</A>
</H2>&nbsp;<A NAME="ref:stagsub"></A>
<P>

<P>

<P>

<H3><A NAME="SECTION05087100000000000000">
27.7.1 ESMF_StaggerLocSet - Set a StaggerLoc to a particular position in the cell</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StaggerLocSet() 
      subroutine ESMF_StaggerLocSetAllDim(staggerloc, loc, keywordenforcer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(inout) :: staggerloc
       integer,                intent(in)    :: loc(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional                     :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets a custom <TT>staggerloc</TT> to a position in a cell by using the array
      <TT>loc</TT>. The values in the array should only be 0,1. If loc(i) is 0 it 
      means the position should be in the center in that dimension. If loc(i) is 1 then
      for dimension i, the position should be on the side of the cell. 
      Please see Section&nbsp;<A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>
      for diagrams and further discussion of custom stagger locations. 

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Grid location to be initialized
       
</DD>
<DT><STRONG>loc</STRONG></DT>
<DD>Array holding position data. Each entry in <TT>loc</TT> should only
            be  0 or 1. note that dimensions beyond those specified are set to 0. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05087200000000000000">
27.7.2 ESMF_StaggerLocSet - Set one dimension of a StaggerLoc to a particular position</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_StaggerLocSet() 
       subroutine ESMF_StaggerLocSetDim(staggerloc, dim, loc, keywordenforcer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(inout) :: staggerloc
       integer,                intent(in)    :: dim
       integer,                intent(in)    :: loc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional                     :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Sets a particular dimension of a custom <TT>staggerloc</TT> to a position in a cell 
      by using the variable <TT>loc</TT>. The variable <TT>loc</TT> should only be 0,1. 
      If <TT>loc</TT> is 0 it means the position 
      should be in the center in that dimension. If <TT>loc</TT> is +1 then
      for the dimension, the position should be on the positive side of the cell. 
      Please see Section&nbsp;<A HREF="node5.html#sec:usage:staggerloc:adv">27.3.22</A>
      for diagrams and further discussion of custom stagger locations. 

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>Stagger location to be initialized
       
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension to be changed (1-7).
       
</DD>
<DT><STRONG>loc</STRONG></DT>
<DD>Position data should be either 0,1.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05087300000000000000">
27.7.3 ESMF_StaggerLocString - Return a StaggerLoc as a string</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StaggerLocString(staggerloc, string, keywordenforcer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_StaggerLoc), intent(in)  :: staggerloc
       character (len = *),   intent(out) :: string
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional,     intent(out) :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Return an <TT>ESMF_StaggerLoc</TT> as a printable string.

<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>The <TT>ESMF_StaggerLoc</TT> to be turned into a string.
       
</DD>
<DT><STRONG>string</STRONG></DT>
<DD>Return string.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05087400000000000000">
27.7.4 ESMF_StaggerLocPrint - Print information of a StaggerLoc object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_StaggerLocPrint(staggerloc, keywordenforcer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type (ESMF_StaggerLoc), intent(in)  :: staggerloc
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer, optional,      intent(out) :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Print the internal data members of an <TT>ESMF_StaggerLoc</TT> object. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>staggerloc</STRONG></DT>
<DD>ESMF_StaggerLoc object as the method input
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05090000000000000000">
28 LocStream Class</A>
</H1>

<P>

<H2><A NAME="SECTION05091000000000000000">
28.1 Description</A>
</H2>

<P>
A location stream (LocStream) is used to represent the locations of
a set of data points.  The values of the data points are stored within
a Field or FieldBundle created using the LocStream.

<P>
In the data assimilation world, LocStreams can
be thought of as a set of observations.  Their locations are generally
described using Cartesian (x, y, z), or (lat, lon, height) coordinates.
There is no assumption of any regularity in the positions of the points.
To make the concept more general, the locations for each data point are
represented using a construct called <I>keys</I>, which can include other
descriptors besides location.

<P>
Although keys are similar in concept to ESMF Attributes they have important
differences. First, keys always occur as vectors, never as scalars.
Second, keys are local to the DE: each DE can have a different key
list with a different number of of elements. Third, the local key 
list always has the same number of elements as there are local observations
on that DE.  Finally, keys may be used for the distribution of LocStreams.
As such, they must be defined before the LocStream is distributed.

<P>
LocStreams can be very large. Data assimilation systems might use
LocStreams with up to <IMG
 WIDTH="29" HEIGHT="20" ALIGN="BOTTOM" BORDER="0"
 SRC="img74.png"
 ALT="$10^{8}$"> observations, so efficiency is critical.

<P>
Common operations involving LocStreams are similar to those involving Grids.
In data assimilation, for example, there is an immediate need to:

<P>

<OL>
<LI>Create a Field or FieldBundle on a LocStream
</LI>
<LI>Redistribute data between Fields defined on LocStreams
</LI>
<LI>Gather or scatter a FieldBundle defined on a LocStream from/to a root DE
</LI>
<LI>Halo region exchange for a Field defined by a haloed LocStream
</LI>
<LI>Extract Fortran array from Field which was defined by a LocStream
</LI>
</OL>

<P>
The operations on the Fortran arrays underlying LocStreams are usually simple numerical ones. However,
it is necessary to sort them in place, and access only portions of the them. It would
not be efficient to continually create new LocStreams to reflect this sorting. Instead,
the sorting is managed by the application through permutation arrays while keeping
the data in place. Locations can become inactive, e.g., if the quality control asserts that
observation is invalid. This can be managed again by the application through masks.

<P>
A LocStream differs from a Grid in that no topological structure is
maintained between the points
(e.g. the class contains no information about which point is the neighbor
of which other point).

<P>
A LocStream is similar to a Mesh consists in that both are collections of irregularly positioned 
points.  However, the two structures differ in that a Mesh has connectivity
also: each data point has a set of neighboring data points. There is no requirement that the
points in a LocStream have connectivity, in fact there is no requirement that a point has 
any particular spatial relationship to another.

<P>

<H2><A NAME="SECTION05092000000000000000">
28.2 Use and Examples</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05092100000000000000">
28.2.1 Create a LocStream with user allocated memory</A>
</H3>

<P>
The following is an example of creating a LocStream object.
   After creation, key data is added, and a Field is created to hold data
   (temperature) at each location. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate and set example location information
   !-------------------------------------------------------------------
   allocate(lon(numLocationsOnThisPet))
   allocate(lat(numLocationsOnThisPet))

   do i=1,numLocationsOnThisPet
      lon(i)=360.0/numLocationsOnThisPet
      lat(i)=0.0
   enddo

   !-------------------------------------------------------------------
   ! Allocate and set example Field data
   !-------------------------------------------------------------------
   allocate(temperature(numLocationsOnThisPet))

   do i=1,numLocationsOnThisPet
      temperature(i)=90.0
   enddo


   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Equatorial Measurements",   &amp;
                                  localCount=numLocationsOnThisPet, &amp;
                                  rc=rc)

   !-------------------------------------------------------------------
   ! Add key data, referencing a user data pointer. By changing the 
   ! datacopyflag to ESMF_DATACOPY_VALUE an internally allocated copy of the 
   ! user data may also be set.  
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,              &amp;
                             keyName="Lat",          &amp;
                             farray=lat,             &amp;
                             datacopyflag=ESMF_DATACOPY_REFERENCE, &amp;
                             keyUnits="Degrees",     &amp;
                             keyLongName="Latitude", rc=rc)

   call ESMF_LocStreamAddKey(locstream,              &amp;
                             keyName="Lon",          &amp;
                             farray=lon,             &amp;
                             datacopyflag=ESMF_DATACOPY_REFERENCE, &amp;
                             keyUnits="Degrees",     &amp;
                             keyLongName="Longitude", rc=rc)

   !-------------------------------------------------------------------
   ! Create a Field on the Location Stream. In this case the 
   ! Field is created from a user array, but any of the other
   ! Field create methods (e.g. from ArraySpec) would also apply.
   !-------------------------------------------------------------------       
   field_temperature=ESMF_FieldCreate(locstream,   &amp;
                                   temperature, &amp;
                                   name="temperature", &amp;
                                   rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05092200000000000000">
28.2.2 Create a LocStream with internally allocated memory</A>
</H3>

<P>
The following is an example of creating a LocStream object.
   After creation, key data is internally allocated,
   the pointer is retrieved, and the data is set.
   A Field is also created on the LocStream to hold data
   (temperature) at each location. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Allocate and set example Field data
   !-------------------------------------------------------------------
   allocate(temperature(numLocationsOnThisPet))

   do i=1,numLocationsOnThisPet
      temperature(i)=80.0
   enddo


   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Equatorial Measurements", &amp;
                                  localCount=numLocationsOnThisPet, &amp;
                                  rc=rc)

   !-------------------------------------------------------------------
   ! Add key data (internally allocating memory).
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="Lat",                &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Latitude", rc=rc)

   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="Lon",                &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Longitude", rc=rc)


   !-------------------------------------------------------------------
   ! Get key data. 
   !-------------------------------------------------------------------
   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             localDE=0,                    &amp;
                             keyName="Lat",                &amp;
                             farray=lat,                   &amp;
                             rc=rc)

   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             localDE=0,                    &amp;
                             keyName="Lon",                &amp;
                             farray=lon,                   &amp;
                             rc=rc)

   !-------------------------------------------------------------------
   ! Set key data. 
   !-------------------------------------------------------------------
   do i=1,numLocationsOnThisPet
      lon(i)=360.0/numLocationsOnThisPet
      lat(i)=0.0
   enddo


   !-------------------------------------------------------------------
   ! Create a Field on the Location Stream. In this case the 
   ! Field is created from a user array, but any of the other
   ! Field create methods (e.g. from ArraySpec) would also apply.
   !-------------------------------------------------------------------    
   field_temperature=ESMF_FieldCreate(locstream,   &amp;
                                 temperature, &amp;
                                 name="temperature", &amp;
                                 rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION05092300000000000000">
28.2.3 Create a LocStream from a background Grid</A>
</H3>

<P>
The following is an example of creating a LocStream object from another LocStream object 
   using a background Grid. The new LocStream contains the data present in the old LocStream, 
   but is redistributed so that entries with a given set of coordinates are on the same PET 
   as the piece of the background Grid which contains those coordinates. 

<P>
<PRE>
   !-------------------------------------------------------------------
   ! Create the LocStream:  Allocate space for the LocStream object, 
   ! define the number and distribution of the locations. 
   !-------------------------------------------------------------------
   locstream=ESMF_LocStreamCreate(name="Equatorial Measurements", &amp;
                                  localCount=numLocationsOnThisPet, &amp;
                                  rc=rc)
   !-------------------------------------------------------------------
   ! Add key data (internally allocating memory).
   !-------------------------------------------------------------------
   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="Lon",                &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Longitude", rc=rc)

   call ESMF_LocStreamAddKey(locstream,                    &amp;
                             keyName="Lat",                &amp;
                             KeyTypeKind=ESMF_TYPEKIND_R8, &amp;
                             keyUnits="Degrees",           &amp;
                             keyLongName="Latitude", rc=rc)


   !-------------------------------------------------------------------
   ! Get Fortran arrays which hold the key data, so that it can be set. 
   ! Using localDE=0, because the locstream was created with 1 DE per PET. 
   !-------------------------------------------------------------------
   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             localDE=0,                    &amp;
                             keyName="Lon",                &amp;
                             farray=lon,                   &amp;
                             rc=rc)

   call ESMF_LocStreamGetKey(locstream,                    &amp;
                             localDE=0,                    &amp;
                             keyName="Lat",                &amp;
                             farray=lat,                   &amp;
                             rc=rc)

   !-------------------------------------------------------------------
   ! Set the longitude and latitude coordinates of the points in the 
   ! LocStream. Each PET contains points scattered around the equator. 
   !-------------------------------------------------------------------
   do i=1,numLocationsOnThisPet
      lon(i)=0.5+REAL(i-1)*360.0/numLocationsOnThisPet
      lat(i)=0.0
   enddo

   !-------------------------------------------------------------------
   ! Create a Grid to use as the background. The Grid is 
   ! GridLonSize by GridLatSize with the default distribution 
   ! (The first dimension split across the PETs). The coordinate range
   ! is  0 to 360 in longitude and -90 to 90 in latitude. Note that we 
   ! use indexflag=ESMF_INDEX_GLOBAL for the Grid creation. At this time 
   ! this is required for a Grid to be usable as a background Grid.
   ! Note that here the points are treated as cartesian.
   !-------------------------------------------------------------------
   grid=ESMF_GridCreateNoPeriDim(maxIndex=(/GridLonSize,GridLatSize/), &amp;
                                 coordSys=ESMF_COORDSYS_CART, &amp;
                                 indexflag=ESMF_INDEX_GLOBAL, &amp;
                                 rc=rc)

   !-------------------------------------------------------------------
   ! Allocate the corner stagger location in which to put the coordinates. 
   ! (The corner stagger must be used for the Grid to be usable as a
   !  background Grid.)
   !-------------------------------------------------------------------
   call ESMF_GridAddCoord(grid, staggerloc=ESMF_STAGGERLOC_CORNER, rc=rc)


   !-------------------------------------------------------------------
   ! Get access to the Fortran array pointers that hold the Grid 
   ! coordinate information and then set the coordinates to be uniformly 
   ! distributed around the globe. 
   !-------------------------------------------------------------------
   call ESMF_GridGetCoord(grid, localDE=0,                       &amp;
                          staggerLoc=ESMF_STAGGERLOC_CORNER,     &amp;
                          coordDim=1, computationalLBound=clbnd, &amp;
                          computationalUBound=cubnd,             &amp; 
                          farrayPtr=farrayPtrLonC, rc=rc)

   call ESMF_GridGetCoord(grid, localDE=0,                       &amp;
                         staggerLoc=ESMF_STAGGERLOC_CORNER,      &amp;
                          coordDim=2, farrayPtr=farrayPtrLatC, rc=rc)

   do i1=clbnd(1),cubnd(1)
   do i2=clbnd(2),cubnd(2)
      ! Set Grid longitude coordinates as 0 to 360
      farrayPtrLonC(i1,i2) = REAL(i1-1)*360.0/REAL(GridLonSize)

      ! Set Grid latitude coordinates as -90 to 90
      farrayPtrLatC(i1,i2) = -90. + REAL(i2-1)*180.0/REAL(GridLatSize) + &amp;
                                      0.5*180.0/REAL(GridLatSize)
   enddo
   enddo


   !-------------------------------------------------------------------
   ! Create newLocstream on the background Grid using the 
   ! "Lon" and "Lat" keys as the coordinates for the entries in 
   ! locstream. The entries in newLocstream with coordinates (lon,lat)
   ! are on the same PET as the piece of grid which contains (lon,lat). 
   !-------------------------------------------------------------------
   newLocstream=ESMF_LocStreamCreate(locstream, coordKeyNames="Lon:Lat", &amp;
                  background=grid, rc=rc)

   !-------------------------------------------------------------------
   ! A Field can now be created on newLocstream and 
   ! ESMF_FieldRedist() can be used to move data between Fields built 
   ! on locstream and Fields built on newLocstream.
   !-------------------------------------------------------------------
</PRE>

<P>

<P>

<H2><A NAME="SECTION05093000000000000000">
28.3 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05093100000000000000">
28.3.1 ESMF_LocStreamAssignment(=) - LocStream assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     locstream1 = locstream2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream) :: locstream1
     type(ESMF_LocStream) :: locstream2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign locstream1 as an alias to the same ESMF LocStream object in memory
     as locstream2. If locstream2 is invalid, then locstream1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>locstream1</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>locstream2</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05093200000000000000">
28.3.2 ESMF_LocStreamOperator(==) - LocStream equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (locstream1 == locstream2) then ... endif
               OR
     result = (locstream1 == locstream2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream1
     type(ESMF_LocStream), intent(in) :: locstream2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether locstream1 and locstream2 are valid aliases to the same ESMF
     LocStream object in memory. For a more general comparison of two ESMF LocStreams,
     going beyond the simple alias test, the ESMF_LocStreamMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>locstream1</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>locstream2</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05093300000000000000">
28.3.3 ESMF_LocStreamOperator(/=) - LocStream not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (locstream1 /= locstream2) then ... endif
               OR
     result = (locstream1 /= locstream2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_LocStream), intent(in) :: locstream1
     type(ESMF_LocStream), intent(in) :: locstream2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether locstream1 and locstream2 are <I>not</I> valid aliases to the
     same ESMF LocStream object in memory. For a more general comparison of two ESMF
     LocStreams, going beyond the simple alias test, the ESMF_LocStreamMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>locstream1</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>locstream2</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05093400000000000000">
28.3.4 ESMF_LocStreamAddKey - Add a key Array and allocate the internal memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyAlloc(locstream, keyName, keyTypeKind, &amp;
                keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream),     intent(in)            :: locstream
     character (len=*),        intent(in)            :: keyName
     type(ESMF_TypeKind_Flag), intent(in),  optional :: keyTypeKind
     character (len=*),        intent(in),  optional :: keyUnits 
     character (len=*),        intent(in),  optional :: keyLongName 
     integer,                  intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream. Once a key has been added its internal data
   can be retrieved and used to set key values. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>[keyTypeKind]</STRONG></DT>
<DD>The type/kind of the key data. 
   If not specified then the type/kind will default to 8 byte reals.  
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05093500000000000000">
28.3.5 ESMF_LocStreamAddKey - Add a key Array </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
   subroutine ESMF_LocStreamAddKeyArray(locstream, keyName, keyArray, &amp;
                destroyKey, keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)             :: locstream
     character (len=*),    intent(in)             :: keyName
     type(ESMF_Array),     intent(in)             :: keyArray
     logical,              intent(in),  optional  :: destroyKey
     character (len=*),    intent(in),  optional  :: keyUnits 
     character (len=*),    intent(in),  optional  :: keyLongName 
     integer,              intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream. Once a key has been added its internal data
   can be retrieved and used to set key values. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
   
</DD>
<DT><STRONG>keyArray</STRONG></DT>
<DD>An ESMF Array which contains the key data
   
</DD>
<DT><STRONG>[destroyKey]</STRONG></DT>
<DD>if .true. destroy this key array when the locstream is destroyed.
   Defaults to .false.
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05093600000000000000">
28.3.6 ESMF_LocStreamAddKey - Add a key Array created around user memory </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamAddKey()
    subroutine ESMF_LocStreamAddKeyI4(locstream, keyName, farray, &amp;
                 datacopyflag, keyUnits, keyLongName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>      type(ESMF_Locstream), intent(in) :: locstream
      character (len=*), intent(in) :: keyName
      &lt;farray&gt;
      type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
      character (len=*), intent(in), optional :: keyUnits
      character (len=*), intent(in), optional :: keyLongName
      integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a key to a locstream. Once a key has been added its internal data
      can be retrieved and used to set key values. 

<P>
Supported values for &lt;farray&gt; are:
      <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), intent(in) :: farray(:)
      
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4),    intent(in) :: farray(:)
      
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8),    intent(in) :: farray(:)
      
</DD>
</DL>

<P>
The arguments are:
      <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to add key to.
      
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to add. 
      
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>Valid native Fortran array, i.e. memory must be associated with the 
      actual argument. The type/kind/rank information of <TT>farray</TT> will be 
      used to set the key Array's properties accordingly. 
      
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>Specifies whether the Array object will reference the memory allocation 
      provided by <TT>farray</TT> directly or will copy the data from 
      <TT>farray</TT> into a new memory allocation. Valid options are 
      <TT>ESMF_DATACOPY_REFERENCE</TT> (default) or <TT>ESMF_DATACOPY_VALUE</TT>. 
      Depending on the specific situation the <TT>ESMF_DATACOPY_REFERENCE</TT> option 
      may be unsafe when specifying an array slice for <TT>farray</TT>. 
      
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
      If not specified, then the item remains blank.  
      
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
      If not specified, then the item remains blank.  
      
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
      
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION05093700000000000000">
28.3.7 ESMF_LocStreamCreate - Create a new LocStream by projecting onto a Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateByBkgGrid(locstream, name, &amp;
                  coordKeyNames, background, maskValues, &amp;
                  unmappedaction, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateByBkgGrid
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),           intent(in)            :: locstream
       character (len=*),              intent(in),  optional :: name
       character (len=*),              intent(in)            :: coordKeyNames
       type(ESMF_Grid),                intent(in)            :: background
       integer(ESMF_KIND_I4),          intent(in),  optional :: maskValues(:)
       type(ESMF_UnmappedAction_Flag), intent(in),  optional :: unmappedaction
       integer,                        intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an location stream from an existing one in accordance with 
       the distribution of the background Grid.  The entries
       in the new location stream are redistributed, so that they lie on the same PET
       as the piece of Grid which contains the coordinates of the entries. The coordinates
       of the entries are the data in the keys named by <TT>coordKeyNames</TT>. To copy data in
       Fields or FieldBundles built on <TT>locstream</TT> to the new one simply use <TT>ESMF_FieldRedist()</TT>
       or <TT>ESMF_FieldBundleRedist()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>Location stream from which the new location stream is to be created
        
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the resulting location stream
        
</DD>
<DT><STRONG>coordKeyNames</STRONG></DT>
<DD>Names of the keys used to determine the link to background Grid.
            The first key in this list matches up with the first coordinate of the 
            Grid, the second key in this list matches up with the second coordinate
            of the Grid, and so on. The key names should be separated by the : character. 
        
</DD>
<DT><STRONG>background</STRONG></DT>
<DD>Background Grid which determines the distribution of the entries in the new location stream.
            The background Grid 
            needs to have the same number of dimensions as the number of keys in <TT>coordKeyNames</TT>.  
            Note also that this subroutine uses the corner stagger location in the Grid for determining 
            where a point lies, because this is the stagger location which fully contains the cell. 
            A Grid must have coordinate data in this stagger location to be used in this subroutine. 
            For a 2D Grid this stagger location is ESMF_STAGGERLOC_CORNER for a 3D Grid this 
            stagger location is ESMF_STAGGERLOC_CORNER_VFACE. Note that currently the background 
            Grid also needs to have been created with indexflag=ESMF_INDEX_GLOBAL to be usable here. 
       
</DD>
<DT><STRONG>[maskValues]</STRONG></DT>
<DD>List of values that indicate a background grid point should be masked out. 
             If not specified, no masking will occur. 
        
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Options are 
             <TT>ESMF_UNMAPPEDACTION_ERROR</TT> or 
             <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> [NOT IMPLEMENTED]. If not specified, defaults 
             to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. 
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05093800000000000000">
28.3.8 ESMF_LocStreamCreate - Create a new LocStream by projecting onto a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name; call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateByBkgMesh(locstream, name, &amp;
                  coordKeyNames, background, unmappedaction, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateByBkgMesh
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),           intent(in)           :: locstream
       character (len=*),              intent(in), optional :: name
       character (len=*),              intent(in)           :: coordKeyNames
       type(ESMF_Mesh),                intent(in)           :: background
       type(ESMF_UnmappedAction_Flag), intent(in), optional :: unmappedaction
       integer,                        intent(out),optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an location stream from an existing one in accordance with 
       the distribution of the background Mesh.  The entries
       in the new location stream are redistributed, so that they lie on the same PET
       as the piece of Mesh which contains the coordinates of the entries. The coordinates
       of the entries are the data in the keys named by <TT>coordKeyNames</TT>. To copy data in
       Fields or FieldBundles built on <TT>locstream</TT> to the new one simply use <TT>ESMF_FieldRedist()</TT>
       or <TT>ESMF_FieldBundleRedist()</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>Location stream from which the new location stream is to be created
        
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of the resulting location stream
        
</DD>
<DT><STRONG>coordKeyNames</STRONG></DT>
<DD>Names of the keys used to determine the link to background Mesh.
            The first key in this list matches up with the first coordinate of the 
            Mesh, the second key in this list matches up with the second coordinate
            of the Mesh, and so on. The key names should be separated by the : character. 
        
</DD>
<DT><STRONG>background</STRONG></DT>
<DD>Background Mesh which determines the distribution of entries in the new locatiion stream.
            The Mesh must have the same spatial dimension as the number of keys in
            <TT>coordKeyNames</TT>. 
        
</DD>
<DT><STRONG>[unmappedaction]</STRONG></DT>
<DD>Specifies what should happen if there are destination points that
             can't be mapped to a source cell. Options are 
             <TT>ESMF_UNMAPPEDACTION_ERROR</TT> or 
             <TT>ESMF_UNMAPPEDACTION_IGNORE</TT> [NOT IMPLEMENTED]. If not specified, defaults 
             to <TT>ESMF_UNMAPPEDACTION_ERROR</TT>. 
        
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05093900000000000000">
28.3.9 ESMF_LocStreamCreate - Create a new LocStream from a distgrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateFromDG(name, distgrid, &amp;
                  destroyDistgrid, indexflag, rc )
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateFromDG
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*),     intent(in),  optional :: name
       type(ESMF_DistGrid),   intent(in)            :: distgrid
       logical,               intent(in), optional  :: destroyDistgrid
       type(ESMF_Index_Flag),  intent(in), optional  :: indexflag    
       integer,               intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types. 

<P>
The arguments are:
       <DL>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Distgrid specifying size and distribution. Only 1D distgrids are allowed.
       
</DD>
<DT><STRONG>[destroyDistgrid]</STRONG></DT>
<DD>If .true. the locstream is responsible for destroying the distgrid.
            Defaults to .false. 
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050931000000000000000">
28.3.10 ESMF_LocStreamCreate - Create a new LocStream from an irregular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateIrreg(name, minIndex, countsPerDE, &amp;
                   indexflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateIrreg
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*), intent(in), optional         :: name
       integer, intent(in), optional                   :: minIndex
       integer, intent(in)                             :: countsPerDE(:)
       type(ESMF_Index_Flag), intent(in), optional      :: indexflag
       integer, intent(out), optional                  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. 

<P>
The arguments are:
       <DL>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[minIndex]</STRONG></DT>
<DD>Number to start the index ranges at. If not present, defaults
            to 1.
       
</DD>
<DT><STRONG>countsPerDE</STRONG></DT>
<DD>This array specifies the number of locations per DE.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050931100000000000000">
28.3.11 ESMF_LocStreamCreate - Create a new LocStream from a local count</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateFromLocal(name, localCount, indexflag, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateFromLocal
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*), intent(in), optional         :: name
       integer, intent(in)                             :: localCount
       type(ESMF_Index_Flag), intent(in), optional      :: indexflag
       integer, intent(out), optional                  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. 

<P>
The arguments are:
       <DL>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>localCount</STRONG></DT>
<DD>Number of grid cells to be distributed to this DE.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050931200000000000000">
28.3.12 ESMF_LocStreamCreate - Create a new LocStream using a regular distribution</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       ! Private name: call using ESMF_LocStreamCreate()
       function ESMF_LocStreamCreateReg(name, &amp;
                  regDecomp, decompFlag, minIndex, maxIndex, indexflag, rc )
</PRE><EM>RETURN VALUE:</EM>
<PRE>       type(ESMF_LocStream) :: ESMF_LocStreamCreateReg
</PRE><EM>ARGUMENTS:</EM>
<PRE>       character (len=*),     intent(in),  optional  :: name
       integer,               intent(in),  optional  :: regDecomp
       type(ESMF_Decomp_Flag), intent(in),  optional  :: decompflag
       integer,               intent(in),  optional  :: minIndex
       integer,               intent(in)             :: maxIndex
       type(ESMF_Index_Flag),  intent(in),  optional  :: indexflag
       integer,               intent(out), optional  :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Allocates memory for a new <TT>ESMF_LocStream</TT> object, constructs its
       internal derived types.  The <TT>ESMF_DistGrid</TT> is set up, indicating
       how the LocStream is distributed. 
       at a later time. 

<P>
The arguments are:
       <DL>
<DT><STRONG>name</STRONG></DT>
<DD>Name of the location stream
       
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>Specify into how many chunks to divide the locations. 
            If not specified, defaults to the number of PETs.
       
</DD>
<DT><STRONG>[decompFlag]</STRONG></DT>
<DD>Specify what to do with leftover locations after division.
            If not specified, defaults to <TT>ESMF_DECOMP_BALANCED</TT>. Please
            see Section&nbsp;<A HREF="node2.html#const:decompflag">9.13</A> for a full description of the 
            possible options.

</DD>
<DT></DT>
<DD>[[minIndex]]
            The minimum index across all PETs. If not set defaults to 1. 
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>The maximum index across all PETs.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Flag that indicates how the DE-local indices are to be defined.
            Defaults to <TT>ESMF_INDEX_DELOCAL</TT>, which indicates
            that the index range on each DE starts at 1. See Section&nbsp;<A HREF="node2.html#const:indexflag">9.24</A>
            for the full range of options. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050931300000000000000">
28.3.13 ESMF_LocStreamDestroy - Release resources associated with a LocStream </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamDestroy(locstream, keywordenforcer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(inout)          :: locstream 
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
       integer,              intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Deallocate an <TT>ESMF_LocStream</TT> object and appropriate 
       internal structures.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>locstream to destroy
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050931400000000000000">
28.3.14 ESMF_LocStreamGet - Return info associated with a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGet()
   subroutine ESMF_LocStreamGetDefault(locstream, distgrid, keyCount, &amp;
                keyNames, localDECount, indexflag, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)             :: locstream
     type(ESMF_DistGrid), intent(out),  optional  :: distgrid
     integer, intent(out),optional                :: keyCount
     character(len=ESMF_MAXSTR),optional          :: keyNames(:) 
     integer, intent(out),optional                :: localDECount
     type(ESMF_Index_Flag), intent(out), optional  :: indexflag
     character(len=*), intent(out),     optional  :: name
     integer, intent(out), optional               :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query an <TT>ESMF_LocStream</TT> for various information. All arguments after
   the <TT>locstream</TT> are optional. 

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to query.
   
</DD>
<DT><STRONG>[distgrid]</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object that descibes 
   
</DD>
<DT><STRONG>[keyCount]</STRONG></DT>
<DD>Number of keys in the <TT>locstream</TT>.
   
</DD>
<DT><STRONG>[keyNames]</STRONG></DT>
<DD>The names of the keys in the <TT>locstream</TT>. Keynames should
   be an array of character strings. The character strings should
   be of length ESMF_MAXSTR and the array's length should be
   at least keyCount. 
   
</DD>
<DT><STRONG>[localDECount]</STRONG></DT>
<DD>Number of DEs on this PET in the <TT>locstream</TT>.
   
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>The indexflag for this indexflag.
   
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>Name of queried item.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050931500000000000000">
28.3.15 ESMF_LocStreamGetKey - Get an Array associated with a key</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
   subroutine ESMF_LocStreamGetKeyArray(locstream, keyName, keyArray, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)            :: locstream
     character (len=*),    intent(in)            :: keyName
     type(ESMF_Array),     intent(out)            :: keyArray
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get ESMF Array associated with key.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to get key from.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to get. 
   
</DD>
<DT><STRONG>keyArray</STRONG></DT>
<DD>Array associated with key.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050931600000000000000">
28.3.16 ESMF_LocStreamGetKey - Get the bounds of a key Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
       subroutine ESMF_LocStreamGetKeyBounds(locstream, localDE, keyName, &amp; 
           exclusiveLBound, exclusiveUBound, exclusiveCount,     &amp;
           computationalLBound, computationalUBound, computationalCount,     &amp;
           totalLBound, totalUBound, totalCount,     &amp;
           rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),   intent(in)       :: locstream
       integer,                intent(in)                  :: localDE
       character (len=*),   intent(in)                :: keyName
       integer,                intent(out), optional :: exclusiveLBound
       integer,                intent(out), optional :: exclusiveUBound
       integer,                intent(out), optional :: exclusiveCount
       integer,                intent(out), optional :: computationalLBound
       integer,                intent(out), optional :: computationalUBound
       integer,                intent(out), optional :: computationalCount
       integer,                intent(out), optional :: totalLBound
       integer,                intent(out), optional :: totalUBound
       integer,                intent(out), optional :: totalCount
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets the bounds of a localDE for a locstream.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region <BR>
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region <BR>
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region
            (i.e. <TT>totalUBound-totalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050931700000000000000">
28.3.17 ESMF_LocStreamGetKey - Get info associated with a key</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
   subroutine ESMF_LocStreamGetKeyInfo(locstream, keyName, keyUnits, &amp;
                 keyLongName, typekind, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Locstream), intent(in)              :: locstream
     character (len=*),    intent(in)              :: keyName
     character (len=*),    intent(out), optional   :: keyUnits 
     character (len=*),    intent(out), optional   :: keyLongName 
     type(ESMF_TypeKind_Flag), intent(out), optional    :: typekind
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get ESMF Array associated with key.

<P>
The arguments are:
   <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>The <TT>ESMF_LocStream</TT> object to get key from.
   
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The name of the key to get. 
   
</DD>
<DT><STRONG>[keyUnits]</STRONG></DT>
<DD>The units of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[keyLongName]</STRONG></DT>
<DD>The long name of the key data. 
   If not specified, then the item remains blank.  
   
</DD>
<DT><STRONG>[typekind]</STRONG></DT>
<DD>The typekind of the key data
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL> 

<P>

<P>

<H3><A NAME="SECTION050931800000000000000">
28.3.18 ESMF_LocStreamGetKey - Get a pointer to key values</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGetKey()
        subroutine ESMF_LocStreamGetKeyI4(locstream, localDE, keyName,    &amp;
            exclusiveLBound, exclusiveUBound, exclusiveCount,             &amp;
            computationalLBound, computationalUBound, computationalCount, &amp;
            totalLBound, totalUBound, totalCount,                         &amp;
            farray, datacopyflag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>        type(ESMF_LocStream), intent(in) :: locstream
        integer, intent(in) :: localDE
        character (len=*),    intent(in)              :: keyName
        integer,                intent(out), optional :: exclusiveLBound
        integer,                intent(out), optional :: exclusiveUBound
        integer,                intent(out), optional :: exclusiveCount
        integer,                intent(out), optional :: computationalLBound
        integer,                intent(out), optional :: computationalUBound
        integer,                intent(out), optional :: computationalCount
        integer,                intent(out), optional :: totalLBound
        integer,                intent(out), optional :: totalUBound
        integer,                intent(out), optional :: totalCount
        &lt;farray&gt;
        type(ESMF_DataCopy_Flag), intent(in), optional :: datacopyflag
        integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets a Fortran pointer to the piece of memory which holds the 
      key data for a particular key on the given local DE. 
      This is useful, for example, for setting the key values in a LocStream, or
      for reading the values. 

<P>
Supported values for &lt;farray&gt; are:
      <DL>
<DT></DT>
<DD>integer(ESMF_KIND_I4), pointer :: farray(:)
      
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R4), pointer :: farray(:)
      
</DD>
<DT></DT>
<DD>real(ESMF_KIND_R8), pointer :: farray(:)
      
</DD>
</DL>

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>keyName</STRONG></DT>
<DD>The key to get the information from.
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region <BR>
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
            <BR>
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). 
       
</DD>
<DT><STRONG>[totalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the total region.
       
</DD>
<DT><STRONG>[totalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the total region.
       
</DD>
<DT><STRONG>[totalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the total region
            (i.e. <TT>totalUBound-totalLBound+1</TT>). 
       
</DD>
<DT><STRONG>farray</STRONG></DT>
<DD>The pointer to the coordinate data.
       
</DD>
<DT><STRONG>[datacopyflag]</STRONG></DT>
<DD>If not specified, default to <TT>ESMF_DATACOPY_REFERENCE</TT>, in this case
            farray is a reference to the data in the Grid coordinate arrays. 
            Please see Section&nbsp;<A HREF="node2.html#const:datacopyflag">9.12</A> for further description and a
            list of valid values. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050931900000000000000">
28.3.19 ESMF_LocStreamGet - Get the local bounds of a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_LocStreamGet()
       subroutine ESMF_LocStreamGetBounds(locstream, localDE, &amp; 
           exclusiveLBound, exclusiveUBound, exclusiveCount,     &amp;
           computationalLBound, computationalUBound, computationalCount,     &amp;
           rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream),   intent(in) :: locstream
       integer,                intent(in) :: localDE
       integer,                intent(out), optional :: exclusiveLBound
       integer,                intent(out), optional :: exclusiveUBound
       integer,                intent(out), optional :: exclusiveCount
       integer,                intent(out), optional :: computationalLBound
       integer,                intent(out), optional :: computationalUBound
       integer,                intent(out), optional :: computationalCount
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This method gets the bounds of a localDE for a locstream.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>LocStream to get the information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>The local DE to get the information for. <TT>[0,..,localDeCount-1]</TT>
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the exclusive region.
       
</DD>
<DT><STRONG>[exclusiveCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the exclusive region
  	   <BR>
            (i.e. <TT>exclusiveUBound-exclusiveLBound+1</TT>). <TT>exclusiveCount</TT>.
       
</DD>
<DT><STRONG>[computationalLBound]</STRONG></DT>
<DD>Upon return this holds the lower bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalUBound]</STRONG></DT>
<DD>Upon return this holds the upper bounds of the computational region.
       
</DD>
<DT><STRONG>[computationalCount]</STRONG></DT>
<DD>Upon return this holds the number of items in the computational region
  	   <BR>
            (i.e. <TT>computationalUBound-computationalLBound+1</TT>). <TT>computationalCount</TT>.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050932000000000000000">
28.3.20 ESMF_LocStreamPrint - Print the contents of a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamPrint(locstream, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(inout) :: locstream 
       character (len = *), intent(in), optional :: options
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Prints information about the <TT>locstream</TT> to <TT>stdout</TT>.
    This subroutine goes through the internal data members of a locstream
    data type and prints information of each data member.

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD>
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Print options are not yet supported.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050932100000000000000">
28.3.21 ESMF_LocStreamValidate - Check validity of a LocStream</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_LocStreamValidate(locstream, options, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>       type(ESMF_LocStream), intent(inout) :: locstream 
       character (len = *), intent(in), optional :: options 
       integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>locstream</TT> is internally consistent.
        Currently this method determines if the <TT>locstream</TT> is uninitialized 
        or already destroyed. 

<P>
The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>locstream</STRONG></DT>
<DD><TT>ESMF_LocStream</TT> to validate.
       
</DD>
<DT><STRONG>[options]</STRONG></DT>
<DD>Validation options are not yet supported.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if the <TT>locstream</TT> 
             is valid.
       
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION050100000000000000000">
29 Mesh Class</A>
</H1>

<P>

<H2><A NAME="SECTION050101000000000000000">
29.1 Description</A>
</H2>

<P>
Unstructured grids are commonly used in the computational solution of partial differential 
equations.  These are especially useful for problems that involve complex geometry, where 
using the less flexible structured grids can result in grid representation of regions 
where no computation is needed.  Finite element and finite volume methods map naturally 
to unstructured grids and are used commonly in hydrology, ocean modeling, and many other 
applications.

<P>
In order to provide support for application codes using unstructured grids, the ESMF library 
provides a class for representing unstructured grids called the <B>Mesh</B>. Fields can be 
created on a Mesh to hold data. Fields created on a Mesh can also be used as either the 
source or destination or both of an interpolaton (i.e. an <TT>ESMF_FieldRegridStore()</TT> call) 
which allows data to be moved between unstructured grids. This section describes the Mesh 
and how to create and use them in ESMF. 

<P>

<H3><A NAME="SECTION050101100000000000000">
29.1.1 Mesh representation in ESMF</A>
</H3>

<P>
A Mesh in ESMF is described in terms of <B>nodes</B> and <B>elements</B>. A node is a point 
in space which represents where the coordinate information in a Mesh is located. An element 
is a higher dimensional shape constructed of nodes. Elements give a Mesh its shape and define 
the relationship of the nodes to one another. Field data may be located on either the nodes
or elements of a Mesh. 

<P>

<H3><A NAME="SECTION050101200000000000000">
29.1.2 Supported Meshes</A>
</H3>

<P>
The range of Meshes supported by ESMF are defined by several factors: dimension, element 
types, and distribution.

<P>
ESMF currently only supports Meshes whose number of coordinate dimensions (spatial dimension) 
is 2 or 3. The dimension of the elements in a Mesh (parametric dimension) must be less than 
or equal to the spatial dimension, but also must be either 2 or 3. This means that a Mesh may 
be either 2D elements in 2D space, 3D elements in 3D space, or a manifold constructed of 2D 
elements embedded in 3D space. 

<P>
ESMF currently supports two types of elements for each Mesh parametric dimension. For a 
parametric dimension of 2, the supported element types are triangles or quadralaterals. For 
a parametric dimension of 3, the supported element types are tetrahedrons
and hexahedrons. See Section&nbsp;<A HREF="node5.html#const:meshelemtype">29.2.1</A> for diagrams of these. The Mesh 
supports any combination of element types within a particular dimension, but types from 
different dimensions may not be mixed.  For example, a Mesh cannot be constructed of both 
quadralaterals and tetrahedra.

<P>
ESMF currently only supports distributions where every node on a PET must be a part of an 
element on that PET. In other words, there must not be nodes without a corresponding element 
on any PET.

<P>

<H2><A NAME="SECTION050102000000000000000">
29.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION050102100000000000000"></A>
<A NAME="const:meshelemtype"></A>
<BR>
29.2.1 ESMF_MESHELEMTYPE
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
 An ESMF Mesh can be constructed from a combination of different elements. The type of elements that can
be used in a Mesh depends on the Mesh's parameteric dimension, which is set during Mesh creation. The
following are the valid Mesh element types for each valid Mesh parametric dimension (2D or 3D) .

<P>

<P>
<BR>

<P>
<PRE>
                     3                          4 ---------- 3
                    / \                         |            |  
                   /   \                        |            |
                  /     \                       |            |
                 /       \                      |            |
                /         \                     |            |
               1 --------- 2                    1 ---------- 2

           ESMF_MESHELEMTYPE_TRI            ESMF_MESHELEMTYPE_QUAD

     2D element types (numbers are the order for elementConn during Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 2 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_TRI</TD>
<TD ALIGN="CENTER">3</TD>
<TD ALIGN="LEFT">A triangle</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_QUAD</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A quadrilateral (e.g. a rectangle)</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<BR>

<P>
<PRE>
                                            
                 3                               8---------------7
                /|\                             /|              /|
               / | \                           / |             / |
              /  |  \                         /  |            /  |
             /   |   \                       /   |           /   |
            /    |    \                     5---------------6    |
           4-----|-----2                    |    |          |    |
            \    |    /                     |    4----------|----3
             \   |   /                      |   /           |   /
              \  |  /                       |  /            |  /
               \ | /                        | /             | /
                \|/                         |/              |/
                 1                          1---------------2

       ESMF_MESHELEMTYPE_TETRA             ESMF_MESHELEMTYPE_HEX  

  3D element types (numbers are the order for elementConn during Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 3 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_TETRA</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A tetrahedron (CAN'T BE USED IN REGRID)</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMF_MESHELEMTYPE_HEX</TD>
<TD ALIGN="CENTER">8</TD>
<TD ALIGN="LEFT">A hexahedron (e.g. a cube)</TD>
</TR>
</TABLE>

<P>

<H3><A NAME="SECTION050102200000000000000"></A>
<A NAME="const:fileformat"></A>
<BR>
29.2.2 ESMF_FILEFORMAT
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
This option is used by <TT>ESMF_MeshCreate</TT> to specify the type of the input grid file.  See 
section&nbsp;<A HREF="node5.html#sec:example:UnstructFromFile">29.3.5</A> for more detailed description of the two file formats.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_FileFormat_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_FILEFORMAT_SCRIP</STRONG></DT>
<DD>SCRIP format grid file. The SCRIP format is the format accepted by the SCRIP regridding tool&nbsp;[<A
 HREF="node8.html#ref:SCRIP">13</A>].   For Mesh creation, files of this type only work when the <TT>grid_rank</TT> in the file is equal to 1.

<P>
</DD>
<DT><STRONG>ESMF_FILEFORMAT_ESMFMESH</STRONG></DT>
<DD>ESMF unstructured grid file format. This format was developed by the ESMF team to match the capabilities of the Mesh class and to be efficient to convert to that class. 
</DD>
</DL>

<P>

<H2><A NAME="SECTION050103000000000000000">
29.3 Use and Examples</A>
</H2>

<P>

<P>

<P>
This section describes the use of the ESMF Mesh class. It starts with an explanation and examples of 
   creating a Mesh and then goes through other Mesh methods. This set of sections covers the use of the 
   Mesh class interfaces, for further detail which applies to using a Field specifically on created on a Mesh, please see 
   Section&nbsp;<A HREF="node5.html#sec:field:usage:create_mesh_arrayspec">22.3.18</A>.

<P>

<H3><A NAME="SECTION050103100000000000000"></A>
  <A NAME="sec:mesh:usage:meshCreation"></A>
<BR>
29.3.1 Mesh creation
</H3>

<P>
To create a Mesh we need to set some properties of the Mesh as a whole,  some properties of each node in the mesh and 
   then some properties of each element which connects the nodes. 

<P>
For the Mesh as a whole we set its parametric dimension (<TT>parametricDim</TT>) and spatial dimension (<TT>spatialDim</TT>). 
   The parametric dimension of a Mesh is the dimension of the topology of the Mesh, this can be thought of as the dimension of 
   the elements which make up the Mesh. For example, a Mesh composed of triangles would have a parametric dimension of 2, whereas
   a Mesh composed of tetrahedra would have a parametric dimension of 3. A Mesh's spatial dimension, on the other hand, is the 
   dimension of the space the Mesh is embedded in, in other words the number of coordinate dimensions needed to describe the 
   location of the nodes making up the Mesh. For example, a Mesh constructed of squares on a plane would have a parametric 
   dimension of 2 and a spatial dimension of 2, whereas if that same Mesh were used to represent the 2D surface of a sphere 
   then the Mesh would still have a parametric dimension of 2, but now its spatial dimension would be 3. 

<P>
The structure of the per node and element information used to create a Mesh is influenced by the Mesh distribution strategy. 
   The Mesh class is distributed by elements. This means that a node must be present on any PET that contains an element 
   associated with that node, but not on any other PET (a node can't be on a PET without an element ""home"). Since a node may be used
   by two or more elements located on different PETs, a node may be duplicated on muliple PETs. When a node is duplicated in this manner, 
   one and only one of the PETs that contain the node must "own" the node. The user sets this ownership when they define the nodes during Mesh creation.
   When a Field is created on a Mesh (i.e. on  the Mesh nodes), on each PET the Field is only created on the nodes which are owned by that PET.
   This means that the size of the Field memory on the PET can be smaller than the number of nodes used to create the Mesh on 
   that PET. Please see Section&nbsp;<A HREF="node5.html#sec:field:usage:create_mesh_arrayspec">22.3.18</A> in Field for further explanation and examples of this
   issue and others in working with Fields on Meshes. 

<P>
For each node in the Mesh we set three properties: the global id of the node (<TT>nodeIds</TT>), node coordinates 
   (<TT>nodeCoords</TT>), and which PET owns the node (<TT>nodeOwners</TT>). The node id is a unique (across all PETs) integer 
   attached to the particular node. It is used to indicate which nodes are the same when connecting together pieces of the 
   Mesh on different processors. The node coordinates indicate the location of a node in space and are used in the
   <TT>ESMF_FieldRegrid()</TT> functionality when interpolating. The node owner indicates which PET is in charge of the node. This
   is used when creating a Field on the Mesh to indicate which PET should contain a Field location for the data.

<P>
For each element in the Mesh we set three properties: the global id of the element (<TT>elementIds</TT>), the topology type of
   the element (<TT>elementTypes</TT>), and which nodes are connected together to form the element (<TT>elementConn</TT>). The element id is
   a unique (across all PETs) integer attached to the particular element. The element type describes the topology of the element 
   (e.g. a triangle vs. a quadralateral). The range of choices for the topology of the elements in a Mesh are restricted by the 
   Mesh's parametric dimension (e.g. a Mesh can't contain a 2D element like a triangle, when its parametric dimension is 3D), but it can contain
   any combination of elements appropriate to its dimension. The element connectivity indicates which nodes are to be connected together to
   form the element. The number of nodes connected together for each element is implied by the elements topology type (<TT>elementTypes</TT>). 
   It is IMPORTANT to note, that the entries in this list are NOT the global ids of the nodes, but are indices into the PET local lists of
   node info used in the Mesh Create. In other words, the element connectivity isn't specified in terms of the global list of nodes, but instead
   is specified in terms of the locally described node info. One other important point about connectivities is that the order of the nodes in the 
   connectivity list of an element is important. Please see Section&nbsp;<A HREF="node5.html#const:meshelemtype">29.2.1</A> for diagrams illustrating the correct order of
   nodes in an element. 

<P>
Mesh creation may either be performed as a one step process using the full <TT>ESMF_MeshCreate()</TT> call, or may be done in three steps. The
   three step process starts with a more minimal <TT>ESMF_MeshCreate()</TT> call. It is then followed by the <TT>ESMF_MeshAddNodes()</TT> to 
   specify nodes, and then the <TT>ESMF_MeshAddElements()</TT> call to specify elements. This three step sequence is useful to conserve memory
   because the node arrays being used for the <TT>ESMF_MeshAddNodes()</TT> call can be deallocated before creating the arrays to be used in the <TT>ESMF_MeshAddElements()</TT> call.

<P>

<H3><A NAME="SECTION050103200000000000000"></A><A NAME="sec:mesh:1pet1step"></A>
<BR>
29.3.2 Create a small single PET Mesh in one step
</H3>

<P>
<PRE>
  
   
    2.0   7 ------- 8 ------- 9
          |         |         |
          |    4    |    5    |
          |         |         |
    1.0   4 ------- 5 ------- 6
          |         |  \   3  |
          |    1    |    \    |
          |         |  2   \  |
    0.0   1 ------- 2 ------- 3
  
         0.0       1.0        2.0 
   
          Node Id labels at corners
         Element Id labels in centers
         (Everything owned by PET 0)
</PRE>

<P>
This example is intended to illustrate the creation of a small Mesh on one PET. The reason for starting with a single PET
   case is so that the user can start to familiarize themselves with the concepts of Mesh creation without the added complication of 
   multiple processors. Later examples illustrate the multiple processor case. This example creates the small 2D Mesh which can be 
   seen in the figure above. Note that this Mesh consists of 9 nodes and 5 elements, where the elements are a mixture of 
   quadralaterals and triangles.  The coordinates of the nodes in the Mesh range from 0.0 to 2.0 in both dimensions. The node ids are 
   in the corners of the elements whereas the element ids are in the centers. The following section of code illustrates the creation of
   this Mesh. 

<P>
<PRE>
  ! Set number of nodes
  numNodes=9

  ! Allocate and fill the node id array.
  allocate(nodeIds(numNodes))
  nodeIds=(/1,2,3,4,5,6,7,8,9/) 

  ! Allocate and fill node coordinate array.
  ! Since this is a 2D Mesh the size is 2x the
  ! number of nodes.
  allocate(nodeCoords(2*numNodes))
  nodeCoords=(/0.0,0.0, &amp; ! node id 1
               1.0,0.0, &amp; ! node id 2
               2.0,0.0, &amp; ! node id 3
               0.0,1.0, &amp; ! node id 4
               1.0,1.0, &amp; ! node id 5
               2.0,1.0, &amp; ! node id 6
               0.0,2.0, &amp; ! node id 7
               1.0,2.0, &amp; ! node id 8
               2.0,2.0 /) ! node id 9

  ! Allocate and fill the node owner array.
  ! Since this Mesh is all on PET 0, it's just set to all 0.
  allocate(nodeOwners(numNodes))
  nodeOwners=0 ! everything on PET 0


  ! Set the number of each type of element, plus the total number.
  numQuadElems=3
  numTriElems=2
  numTotElems=numQuadElems+numTriElems


  ! Allocate and fill the element id array.
  allocate(elemIds(numTotElems))
  elemIds=(/1,2,3,4,5/) 


  ! Allocate and fill the element topology type array.
  allocate(elemTypes(numTotElems))
  elemTypes=(/ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 1
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 2
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 3
              ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 4
              ESMF_MESHELEMTYPE_QUAD/)  ! elem id 5


  ! Allocate and fill the element connection type array.
  ! Note that entries in this array refer to the 
  ! positions in the nodeIds, etc. arrays and that
  ! the order and number of entries for each element
  ! reflects that given in the Mesh options 
  ! section for the corresponding entry
  ! in the elemTypes array. The number of 
  ! entries in this elemConn array is the
  ! number of nodes in a quad. (4) times the 
  ! number of quad. elements plus the number
  ! of nodes in a triangle (3) times the number
  ! of triangle elements. 
  allocate(elemConn(4*numQuadElems+3*numTriElems))
  elemConn=(/1,2,5,4, &amp;  ! elem id 1
             2,3,5,   &amp;  ! elem id 2
             3,6,5,   &amp;  ! elem id 3
             4,5,8,7, &amp;  ! elem id 4
             5,6,9,8/)   ! elem id 5


  ! Create Mesh structure in 1 step
  mesh=ESMF_MeshCreate(parametricDim=2,spatialDim=2, &amp;
         nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
         nodeOwners=nodeOwners, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)


  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! Set arrayspec for example field create
  ! Use a dimension of 1, because Mesh data is linearized 
  ! into a one dimensional array. 
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=localrc)

  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, arrayspec,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103300000000000000"></A><A NAME="sec:mesh:1pet3step"></A>
<BR>
29.3.3 Create a small single PET Mesh in three steps
</H3>

<P>
This example is intended to illustrate the creation of a small Mesh in three steps on one PET. The Mesh being created is exactly
   the same one as in the last example (Section&nbsp;<A HREF="node5.html#sec:mesh:1pet1step">29.3.2</A>), but the three step process allows the creation to occur in 
   a more memory efficient manner. 

<P>
<PRE>
  ! Create the mesh structure setting the dimensions
  mesh = ESMF_MeshCreate(parametricDim=2,spatialDim=2, rc=localrc)

  ! Set number of nodes
  numNodes=9

  ! Allocate and fill the node id array.
  allocate(nodeIds(numNodes))
  nodeIds=(/1,2,3,4,5,6,7,8,9/) 

  ! Allocate and fill node coordinate array.
  ! Since this is a 2D Mesh the size is 2x the
  ! number of nodes.
  allocate(nodeCoords(2*numNodes))
  nodeCoords=(/0.0,0.0, &amp; ! node id 1
               1.0,0.0, &amp; ! node id 2
               2.0,0.0, &amp; ! node id 3
               0.0,1.0, &amp; ! node id 4
               1.0,1.0, &amp; ! node id 5
               2.0,1.0, &amp; ! node id 6
               0.0,2.0, &amp; ! node id 7
               1.0,2.0, &amp; ! node id 8
               2.0,2.0 /) ! node id 9

  ! Allocate and fill the node owner array.
  ! Since this Mesh is all on PET 0, it's just set to all 0.
  allocate(nodeOwners(numNodes))
  nodeOwners=0 ! everything on PET 0

  ! Add the nodes to the Mesh
  call ESMF_MeshAddNodes(mesh, nodeIds=nodeIds, &amp;
         nodeCoords=nodeCoords, nodeOwners=nodeOwners, rc=localrc)

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! HERE IS THE POINT OF THE THREE STEP METHOD
  ! WE CAN DELETE THESE NODE ARRAYS BEFORE 
  ! ALLOCATING THE ELEMENT ARRAYS, THEREBY
  ! REDUCING THE AMOUNT OF MEMORY NEEDED 
  ! AT ONE TIME. 
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)


  ! Set the number of each type of element, plus the total number.
  numQuadElems=3
  numTriElems=2
  numTotElems=numQuadElems+numTriElems

  ! Allocate and fill the element id array.
  allocate(elemIds(numTotElems))
  elemIds=(/1,2,3,4,5/) 

  ! Allocate and fill the element topology type array.
  allocate(elemTypes(numTotElems))
  elemTypes=(/ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 1
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 2
              ESMF_MESHELEMTYPE_TRI,  &amp; ! elem id 3
              ESMF_MESHELEMTYPE_QUAD, &amp; ! elem id 4
              ESMF_MESHELEMTYPE_QUAD/)  ! elem id 5


  ! Allocate and fill the element connection type array.
  ! Note that entries in this array refer to the 
  ! positions in the nodeIds, etc. arrays and that
  ! the order and number of entries for each element
  ! reflects that given in the Mesh options 
  ! section for the corresponding entry
  ! in the elemTypes array. The number of 
  ! entries in this elemConn array is the
  ! number of nodes in a quad. (4) times the 
  ! number of quad. elements plus the number
  ! of nodes in a triangle (3) times the number
  ! of triangle elements. 
  allocate(elemConn(4*numQuadElems+3*numTriElems))
  elemConn=(/1,2,5,4, &amp;  ! elem id 1
             2,3,5,   &amp;  ! elem id 2
             3,6,5,   &amp;  ! elem id 3
             4,5,8,7, &amp;  ! elem id 4
             5,6,9,8/)   ! elem id 5


  ! Finish the creation of the Mesh by adding the elements
  call ESMF_MeshAddElements(mesh, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)

  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! Set arrayspec for example field create
  ! Use a dimension of 1, because Mesh data is linearized 
  ! into a one dimensional array. 
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=localrc)

  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, arrayspec,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103400000000000000">
29.3.4 Create a small Mesh on 4 PETs in one step</A>
</H3>

<P>
<PRE>
  
    2.0   7 ------- 8        [8] ------ 9          
          |         |         |         |
          |    4    |         |    5    |
          |         |         |         |
    1.0  [4] ----- [5]       [5] ----- [6]
          
         0.0       1.0       1.0       2.0
  
             PET 2               PET 3
  
  
    1.0   4 ------- 5        [5] ------ 6
          |         |         |  \   3  |
          |    1    |         |    \    |
          |         |         | 2    \  |
    0.0   1 ------- 2        [2] ------ 3
  
         0.0       1.0       1.0      2.0 
   
             PET 0               PET 1
  
                 Node Id labels at corners
                Element Id labels in centers
</PRE>

<P>
This example is intended to illustrate the creation of a small Mesh on multiple PETs. This example creates the same small 2D Mesh as the 
   previous two examples (See Section&nbsp;<A HREF="node5.html#sec:mesh:1pet1step">29.3.2</A> for a diagram), however, in this case the Mesh is broken up across 4 PETs. 
   The figure above illustrates the distribution of the Mesh across the PETs. As in the previous diagram, the node ids are in
   the corners of the elements and the element ids are in the centers. In this figure '[' and ']' around a character indicate a node which
   is owned by another PET. The nodeOwner parameter indicates which PET owns the node.  Note that the three step creation 
   illustrated in Section&nbsp;<A HREF="node5.html#sec:mesh:1pet3step">29.3.3</A> could also be used in a parallel Mesh creation such as this by simply interleaving 
   the three calls in the appropriate places between the node and element array definitions. 

<P>
<PRE>
 ! Break up what's being set by PET
 if (localPET .eq. 0) then !!! This part only for PET 0
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/1,2,4,5/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/0.0,0.0, &amp; ! node id 1
                 1.0,0.0, &amp; ! node id 2
                 0.0,1.0, &amp; ! node id 4
                 1.0,1.0 /) ! node id 5

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 1
                 0, &amp; ! node id 2
                 0, &amp; ! node id 4
                 0/)  ! node id 5

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/1/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 1

    ! Allocate and fill the element connection type array.
    ! Note that entry are local indices
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 1

  else if (localPET .eq. 1) then !!! This part only for PET 1
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/2,3,5,6/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/1.0,0.0, &amp; ! node id 2
                 2.0,0.0, &amp; ! node id 3
                 1.0,1.0, &amp; ! node id 5
                 2.0,1.0 /) ! node id 6

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 2
                 1, &amp; ! node id 3
                 0, &amp; ! node id 5
                 1/)  ! node id 6

    ! Set the number of each type of element, plus the total number.
    numQuadElems=0
    numTriElems=2
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/2,3/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_TRI, &amp; ! elem id 2
                ESMF_MESHELEMTYPE_TRI/)  ! elem id 3

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,3, &amp; ! elem id 2
               2,4,3/)  ! elem id 3

  else if (localPET .eq. 2) then !!! This part only for PET 2
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/4,5,7,8/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/0.0,1.0, &amp; ! node id 4
                 1.0,1.0, &amp; ! node id 5
                 0.0,2.0, &amp; ! node id 7
                 1.0,2.0 /) ! node id 8

    ! Allocate and fill the node owner array.
    ! Since this Mesh is all on PET 0, it's just set to all 0.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 4
                 0, &amp; ! node id 5
                 2, &amp; ! node id 7
                 2/)  ! node id 8

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/4/) 

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 4

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 4

  else if (localPET .eq. 3) then !!! This part only for PET 3
    ! Set number of nodes
     numNodes=4

    ! Allocate and fill the node id array.
    allocate(nodeIds(numNodes))
    nodeIds=(/5,6,8,9/) 

    ! Allocate and fill node coordinate array.
    ! Since this is a 2D Mesh the size is 2x the
    ! number of nodes.
    allocate(nodeCoords(2*numNodes))
    nodeCoords=(/1.0,1.0, &amp;  ! node id 5
                 2.0,1.0, &amp;  ! node id 6
                 1.0,2.0, &amp;  ! node id 8
                 2.0,2.0 /)  ! node id 9

    ! Allocate and fill the node owner array.
    allocate(nodeOwners(numNodes))
    nodeOwners=(/0, &amp; ! node id 5
                 1, &amp; ! node id 6
                 2, &amp; ! node id 8
                 3/)  ! node id 9

    ! Set the number of each type of element, plus the total number.
    numQuadElems=1
    numTriElems=0
    numTotElems=numQuadElems+numTriElems

    ! Allocate and fill the element id array.
    allocate(elemIds(numTotElems))
    elemIds=(/5/)  

    ! Allocate and fill the element topology type array.
    allocate(elemTypes(numTotElems))
    elemTypes=(/ESMF_MESHELEMTYPE_QUAD/) ! elem id 5

    ! Allocate and fill the element connection type array.
    allocate(elemConn(4*numQuadElems+3*numTriElems))
    elemConn=(/1,2,4,3/) ! elem id 5
  endif

  
  ! Create Mesh structure in 1 step
  mesh=ESMF_MeshCreate(parametricDim=2, spatialDim=2, &amp;
         nodeIds=nodeIds, nodeCoords=nodeCoords, &amp;
         nodeOwners=nodeOwners, elementIds=elemIds,&amp;
         elementTypes=elemTypes, elementConn=elemConn, &amp;
         rc=localrc)


  ! After the creation we are through with the arrays, so they may be
  ! deallocated.
  deallocate(nodeIds)
  deallocate(nodeCoords)
  deallocate(nodeOwners)
  deallocate(elemIds)
  deallocate(elemTypes)
  deallocate(elemConn)


  ! Set arrayspec for example field create
  ! Use a dimension of 1, because Mesh data is linearized 
  ! into a one dimensional array. 
  call ESMF_ArraySpecSet(arrayspec, 1, ESMF_TYPEKIND_R8, rc=localrc)

  ! At this point the mesh is ready to use. For example, as is 
  ! illustrated here, to have a field created on it. Note that 
  ! the Field only contains data for nodes owned by the current PET.
  ! Please see Section "Create a Field from a Mesh" under Field
  ! for more information on creating a Field on a Mesh. 
  field = ESMF_FieldCreate(mesh, arrayspec,  rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103500000000000000"></A>
  <A NAME="sec:example:UnstructFromFile"></A>
<BR>
29.3.5 Create a Mesh from a SCRIP Grid file or an ESMF unstructured Grid file
</H3>

<P>
ESMF supports the creation of a Mesh from a 2D unstructured grid defined in a SCRIP format
   grid file&nbsp;[<A
 HREF="node8.html#ref:SCRIP">13</A>] or an ESMF format grid file.  Both the SCRIP grid file and the
   ESMF grid file are in NetCDF format. Here is a sample header from a SCRIP unstructured
   grid file:
  <PRE>
  netcdf ne4np4-pentagons {
  dimensions:
  	grid_size = 866 ;
  	grid_corners = 5 ;
  	grid_rank = 1 ;
  variables:
  	double grid_area(grid_size) ;
  		grid_area:units = "radians^2" ;
  		grid_area:long_name = "area weights" ;
  	double grid_center_lat(grid_size) ;
  		grid_center_lat:units = "degrees" ;
  	double grid_center_lon(grid_size) ;
  		grid_center_lon:units = "degrees" ;
  	double grid_corner_lon(grid_size, grid_corners) ;
  		grid_corner_lon:units = "degrees" ;
  		grid_corner_lon:_FillValue = -9999. ;
  	double grid_corner_lat(grid_size, grid_corners) ;
  		grid_corner_lat:units = "degrees" ;
  		grid_corner_lat:_FillValue = -9999. ;
  	double grid_imask(grid_size) ;
  		grid_imask:_FillValue = -9999. ;
  	int grid_dims(grid_rank) ;
  }
</PRE>

<P>
The grid cells are organized as a one dimensional array (<TT>grid_rank = 1</TT>). The
   cell connection is defined using <TT>grid_corner_lat</TT> and <TT>grid_corner_lon</TT> with
   the maximum number of corners defined in <TT>grid_corners</TT>. <TT>grid_imask</TT> is not used 
   in the Mesh object in the current implementation.  
   The data is located at the center of the grid cell in a SCRIP grid; whereas
   the data is located at the corner of a cell in an ESMF Mesh object.  Therefore,
   we create a Mesh object by default by constructing a "dual" mesh using <TT>grid_center_lat</TT> and
   <TT>grid_center_lon</TT>.  
   If the user wishes to not construct the dual mesh, the optional argument <TT>convertToDual</TT> may be 
   used to control this behavior. When <TT>comvertToDual</TT> is 
   set to .false. the Mesh constructed from the file will not be the dual. This is necessary when using the 
   Mesh as part of a conservative regridding operation in the <TT>ESMF_FieldRegridStore()</TT> call, so the
   weights are properly generated for the cell centers in the file. 

<P>
The following example code depicts how to create a Mesh using a SCRIP file. Note that
   you have to set the filetypeflag to ESMF_FILEFORMAT_SCRIP.  If the optional argument <TT>convert3D</TT>
   is set to .true., the coordinates will be converted into 3D Cartesian first.  If the grid
   is a global grid and will be used in a regrid operation, this flag should be set to .true. 

<P>
<PRE>
   mesh = ESMF_MeshCreate(filename="data/ne4np4-pentagons.nc", &amp;
	   filetypeflag=ESMF_FILEFORMAT_SCRIP, convert3D=.true., rc=localrc)
</PRE>

<P>
In addition to the SCRIP format, ESMF also supports a more general unstructured grid file format for describing meshes.
   In the ESMF file format, the node coordinates are defined in a separate array
   <TT>nodeCoords</TT> and indices to the <TT>nodeCoords</TT> array are used in the element
   connectivity array <TT>elementConn</TT>.  While in the SCRIP format, the two are combined into 
   <TT>grid_corner_lat</TT> and <TT>grid_corner_lon</TT> arrays.  The ESMF file format works
   better with the methods used to create an ESMF Mesh object, so less conversion needs to be done to create a Mesh. 
   The ESMF format is also more general than the SCRIP format because it supports higher dimension coordinates and more general
   topologies.  Currently, ESMF_MeshCreate() does not support conversion to a dual mesh for this format. All regrid methods
   are supported on Meshes in this format.  The following is a sample header of a mesh described in the ESMF format.

<P>
<PRE>
   netcdf ne4np4-esmf {
   dimensions:	
  	nodeCount = 866 ;
  	elementCount = 936 ;
  	maxNodePElement = 4 ;
  	coordDim = 2 ;
  variables:	
  	double 	nodeCoords(numNode, coordDim);
  		nodeCoords:units = "degrees,degrees" ;
  	int elementConn(numElement, maxNodePElement) ;
  		elementConn:long_name = "Node Indices that define the element connectivity";
  		elementConn:_FillValue = -1 ;	
  	byte numElementConn(numElement) ;
  		numElementConn:long_name = "Number of nodes per element" ;
  	double centerCoords(numElement, coordDim) ;
  		centerCoords:units = "degrees" ;
  	double elementArea(numElement) ;
  		elementArea:units = "radians^2" ;
  		elementArea:long_name = "area weights" ;
  	int  elementMask(numElement) ;
  		elementMask:_FillValue = -9999. ;
  // global attributes:
  		:gridType="unstructured";
  		:version = "0.9" ;
  		:inputFile = "ne4np4-pentagons.nc" ;
  		:timeGenerated = "Fri Apr 16 16:05:24 2010" ;
  }
</PRE>

<P>
Here is an example of creating a Mesh from an ESMF unstructured grid file. Note that you have to set the filetypeflag to
   ESMF_FILEFORMAT_ESMFMESH.  As with the previous example, we set <TT>convert3D</TT> to true because this is a
   global grid. 

<P>
<PRE>
   mesh = ESMF_MeshCreate(filename="data/ne4np4-esmf.nc", &amp;
            filetypeflag=ESMF_FILEFORMAT_ESMFMESH, convert3D=.true., rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050103600000000000000">
29.3.6 Remove Mesh memory</A>
</H3>

<P>
There are two different levels that the memory in a Mesh can be removed. The first of these is the standard destroy call, 
   <TT>ESMF_MeshDestroy()</TT>. As with other classes, this call removes all memory associated with the object, and afterwards  
   the object can not be used further (i.e. should not be used in any methods). The second, which is unique to Mesh, is the 
   <TT>ESMF_MeshFreeMemory()</TT> call. This call removes the connection and coordinate information associated with the Mesh, but
   leaves the distgrid information. The coordinate and connection information held in the Mesh can consume a large amount of memory
   for a big Mesh, so using this call can very significantly reduce the amount of memory used. However, once this method
   has been used on a Mesh there are some restriction on what may be done with it. Once a Mesh has had its memory freed using this method, 
   any Field built on the Mesh can no longer be used as part of an <TT>ESMF_FieldRegridStore()</TT> call. However, because the distgrid 
   information is still part of the Mesh, Fields built on such a Mesh can still be part of an <TT>ESMF_FieldRegrid()</TT>
   call (where the routehandle was generated previous to the <TT>ESMF_MeshFreeMemory()</TT> operation). Fields may also 
   still be created on these Meshes. The following short piece of code illustrates the use of this call.

<P>
<PRE>
   ! Here a Field built on a mesh may be used
   ! as part of a ESMF_FieldRegridStore() call

   ! This call removes connection and coordinate 
   ! information, significantly reducing the memory used by
   ! mesh, but limiting what can be done with it.
   call ESMF_MeshFreeMemory(mesh, rc=localrc)

   ! Here a new Field may be built on mesh, or
   ! a field built on a mesh may be used as part
   ! of an ESMF_FieldRegrid() call

   ! Destroy the mesh
   call ESMF_MeshDestroy(mesh, rc=localrc)

   ! Here mesh can't be used for anything
</PRE>

<P>

<P>

<H2><A NAME="SECTION050104000000000000000">
29.4 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050104100000000000000">
29.4.1 ESMF_MeshAssignment(=) - Mesh assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     mesh1 = mesh2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh) :: mesh1
     type(ESMF_Mesh) :: mesh2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign mesh1 as an alias to the same ESMF Mesh object in memory
     as mesh2. If mesh2 is invalid, then mesh1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>mesh1</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>mesh2</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104200000000000000">
29.4.2 ESMF_MeshOperator(==) - Mesh equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (mesh1 == mesh2) then ... endif
               OR
     result = (mesh1 == mesh2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh1
     type(ESMF_Mesh), intent(in) :: mesh2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether mesh1 and mesh2 are valid aliases to the same ESMF
     Mesh object in memory. For a more general comparison of two ESMF Meshes,
     going beyond the simple alias test, the ESMF_MeshMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>mesh1</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>mesh2</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104300000000000000">
29.4.3 ESMF_MeshOperator(/=) - Mesh not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (mesh1 /= mesh2) then ... endif
               OR
     result = (mesh1 /= mesh2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(in) :: mesh1
     type(ESMF_Mesh), intent(in) :: mesh2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether mesh1 and mesh2 are <I>not</I> valid aliases to the
     same ESMF Mesh object in memory. For a more general comparison of two ESMF
     Meshes, going beyond the simple alias test, the ESMF_MeshMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>mesh1</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>mesh2</STRONG></DT>
<DD>The <TT>ESMF_Mesh</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104400000000000000"></A><A NAME="sec:mesh:api:meshaddelements"></A>
<BR>
29.4.4 ESMF_MeshAddElements - Add elements to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_MeshAddElements(mesh, elementIds, elementTypes, &amp;
                  elementConn, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)         :: mesh
     integer,         intent(in) 	   :: elementIds(:)
     integer,         intent(in) 	   :: elementTypes(:)
     integer,         intent(in) 	   :: elementConn(:)
     integer,         intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the third and last part of the three part mesh create
     sequence and should be called after the mesh is created with <TT>ESMF_MeshCreate()</TT> 
     (<A HREF="node5.html#sec:mesh:api:meshcreate">29.4.6</A>)
     and after the nodes are added with <TT>ESMF_MeshAddNodes()</TT> (<A HREF="node5.html#sec:mesh:api:meshaddnodes">29.4.5</A>).
     This call adds the elements to the 
     mesh and finalizes the create. After this call the Mesh is usable, for
     example a Field may be built on the created Mesh object and 
     this Field may be used in a <TT>ESMF_FieldRegridStore()</TT> call.

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementConn</TT> describe the elements to be created. The description 
     for a particular element lies at the same index location in <TT>elementIds</TT> 
     and <TT>elementTypes</TT>. Each entry in <TT>elementConn</TT> consists of the list of
     nodes used to create that element, so the connections for element <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$e$"> in the 
     <TT>elementIds</TT> array will start at <!-- MATH
 $number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
     \cdots + number\_of\_nodes\_in\_element(e-1) + 1$
 -->
<IMG
 WIDTH="842" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img76.png"
 ALT="$number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
\cdots + number\_of\_nodes\_in\_element(e-1) + 1$"> in <TT>elementConn</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>elementIds</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET. 
            This input consists of a 1D array the size of the number of elements on this PET.
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="node5.html#const:meshelemtype">29.2.1</A> for the list of options. This input consists of 
            a 1D array the size of the number of elements on this PET.  
     
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids, 
           but rather each entry is a local index (1 based) into the list of nodes which were
           created on this PET by the previous <TT>ESMF_MeshAddNodes()</TT> call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. passed into the
           <TT>ESMF_MeshAddNodes()</TT> call on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="node5.html#const:meshelemtype">29.2.1</A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with 
           a total size equal to the sum of the number of nodes in each element on
           this PET. The number of nodes in each element is implied by its element type in 
           <TT>elementTypes</TT>. The nodes for each element 
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.). 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104500000000000000"></A><A NAME="sec:mesh:api:meshaddnodes"></A>
<BR>
29.4.5 ESMF_MeshAddNodes - Add nodes to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     subroutine ESMF_MeshAddNodes(mesh, nodeIds, nodeCoords, nodeOwners, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh),    intent(inout)         :: mesh
     integer,            intent(in)            :: nodeIds(:)
     real(ESMF_KIND_R8), intent(in)            :: nodeCoords(:)
     integer,            intent(in)            :: nodeOwners(:)
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the second part of the three part mesh create
     sequence and should be called after the mesh's dimensions are set
     using <TT>ESMF_MeshCreate()</TT> (<A HREF="node5.html#sec:mesh:api:meshcreate">29.4.6</A>).
     This call adds the nodes to the 
     mesh. The next step is to call <TT>ESMF_MeshAddElements()</TT> (<A HREF="node5.html#sec:mesh:api:meshaddelements">29.4.4</A>).

<P>
The parameters to this call <TT>nodeIds</TT>, <TT>nodeCoords</TT>, and 
     <TT>nodeOwners</TT> describe the nodes to be created on this PET. 
     The description for a particular node lies at the same index location in 
     <TT>nodeIds</TT> and <TT>nodeOwners</TT>. Each entry
     in <TT>nodeCoords</TT> consists of spatial dimension coordinates, so the coordinates
     for node <IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="$n$"> in the <TT>nodeIds</TT> array will start at <!-- MATH
 $(n-1)*spatialDim+1$
 -->
<IMG
 WIDTH="179" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="$(n-1)*spatialDim+1$">. 

<P>
<DL>
<DT><STRONG>nodeIds</STRONG></DT>
<DD>An array containing the global ids of the nodes to be created on this PET. 
           This input consists of a 1D array the size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>nodeCoords</STRONG></DT>
<DD>An array containing the physical coordinates of the nodes to be created on this
            PET. This input consists of a 1D array the size of the number of nodes on this PET times the Mesh's 
            spatial dimension (<TT>spatialDim</TT>). The coordinates in this array are ordered
            so that the coordinates for a node lie in sequence in memory. (e.g. for a 
            Mesh with spatial dimension 2, the coordinates for node 1 are in nodeCoords(0) and
            nodeCoords(1), the coordinates for node 2 are in nodeCoords(2) and nodeCoords(3), 
            etc.). 
     
</DD>
<DT><STRONG>nodeOwners</STRONG></DT>
<DD>An array containing the PETs that own the nodes to be created on this PET. 
           If the node is shared with another PET, the value
           may be a PET other than the current one. Only nodes owned by this PET
           will have PET local entries in a Field created on the Mesh. This input consists of 
           a 1D array the size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104600000000000000"></A><A NAME="sec:mesh:api:meshcreate"></A>
<BR>
29.4.6 ESMF_MeshCreate - Create a Mesh as a 3 step process 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreate3Part(parametricDim, spatialDim, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)         :: ESMF_MeshCreate3Part
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                intent(in)            :: parametricDim
     integer,                intent(in)            :: spatialDim
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the first part of the three part mesh create
     sequence. This call sets the dimension of the elements in the mesh
     (<TT>parametricDim</TT>) and the number of coordinate dimensions in the mesh
     (<TT>spatialDim</TT>). The next step is to call <TT>ESMF_MeshAddNodes()</TT> (<A HREF="node5.html#sec:mesh:api:meshaddnodes">29.4.5</A>) 
     to add the nodes and then <TT>ESMF_MeshAddElements()</TT> (<A HREF="node5.html#sec:mesh:api:meshaddelements">29.4.4</A>) to add 
     the elements and finalize the mesh.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
           have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
           of 3.)
     
</DD>
<DT><STRONG>spatialDim</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes 
           making up the Mesh. For a manifold, the spatial dimesion can be larger than the 
           parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller. 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104700000000000000">
29.4.7 ESMF_MeshCreate - Create a Mesh all at once</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreate1Part(parametricDim, spatialDim, &amp;
                          nodeIds, nodeCoords, nodeOwners, &amp;
                          elementIds, elementTypes, elementConn, &amp;
                          rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)                           :: ESMF_MeshCreate1Part
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,            intent(in)            :: parametricDim
     integer,            intent(in)            :: spatialDim
     integer,            intent(in)            :: nodeIds(:)
     real(ESMF_KIND_R8), intent(in)            :: nodeCoords(:)
     integer,            intent(in) 	      :: nodeOwners(:)
     integer,            intent(in) 	      :: elementIds(:)
     integer,            intent(in) 	      :: elementTypes(:)
     integer,            intent(in) 	      :: elementConn(:)
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create a Mesh object in one step. After this call the Mesh is usable, for
     example, a Field may be built on the created Mesh object and 
     this Field may be used in a <TT>ESMF_FieldRegridStore()</TT> call.

<P>
This call sets the dimension of the elements in the mesh
     (<TT>parametricDim</TT>) and the number of coordinate dimensions in the mesh
     (<TT>spatialDim</TT>). It then creates the nodes, and 
     then creates the elements by connecting together the nodes.

<P>
The parameters to this call <TT>nodeIds</TT>, <TT>nodeCoords</TT>, and 
     <TT>nodeOwners</TT> describe the nodes to be created on this PET. 
     The description for a particular node lies at the same index location in 
     <TT>nodeIds</TT> and <TT>nodeOwners</TT>. Each entry
     in <TT>nodeCoords</TT> consists of spatial dimension coordinates, so the coordinates
     for node <IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="$n$"> in the <TT>nodeIds</TT> array will start at <!-- MATH
 $(n-1)*spatialDim+1$
 -->
<IMG
 WIDTH="179" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img78.png"
 ALT="$(n-1)*spatialDim+1$">. 

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementConn</TT> describe the elements to be created. The description 
     for a particular element lies at the same index location in <TT>elementIds</TT> 
     and <TT>elementTypes</TT>. Each entry in <TT>elementConn</TT> consists of the list of
     nodes used to create that element, so the connections for element <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img75.png"
 ALT="$e$"> in the 
     <TT>elementIds</TT> array will start at <!-- MATH
 $number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
     \cdots + number\_of\_nodes\_in\_element(e-1) + 1$
 -->
<IMG
 WIDTH="842" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img76.png"
 ALT="$number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
\cdots + number\_of\_nodes\_in\_element(e-1) + 1$"> in <TT>elementConn</TT>.

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
           have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
           of 3.)
     
</DD>
<DT><STRONG>spatialDim</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes 
           making up the Mesh. For a manifold, the spatial dimesion can be larger than the 
           parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller. 
     
</DD>
<DT><STRONG>nodeIds</STRONG></DT>
<DD>An array containing the global ids of the nodes to be created on this PET. 
           This input consists of a 1D array the size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>nodeCoords</STRONG></DT>
<DD>An array containing the physical coordinates of the nodes to be created on this
            PET. This input consists of a 1D array the size of the number of nodes on this PET times the Mesh's 
            spatial dimension (<TT>spatialDim</TT>). The coordinates in this array are ordered
            so that the coordinates for a node lie in sequence in memory. (e.g. for a 
            Mesh with spatial dimension 2, the coordinates for node 1 are in nodeCoords(0) and
            nodeCoords(1), the coordinates for node 2 are in nodeCoords(2) and nodeCoords(3), 
            etc.). 
     
</DD>
<DT><STRONG>nodeOwners</STRONG></DT>
<DD>An array containing the PETs that own the nodes to be created on this PET. 
           If the node is shared with another PET, the value
           may be a PET other than the current one. Only nodes owned by this PET
           will have PET local entries in a Field created on the Mesh. This input consists of 
           a 1D array the size of the number of nodes on this PET.
     
</DD>
<DT><STRONG>elementIds</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET. 
            This input consists of a 1D array the size of the number of elements on this PET.
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="node5.html#const:meshelemtype">29.2.1</A> for the list of options. This input consists of 
            a 1D array the size of the number of elements on this PET.  
     
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids, 
           but rather each entry is a local index (1 based) into the list of nodes to be 
           created on this PET by this call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="node5.html#const:meshelemtype">29.2.1</A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with 
           a total size equal to the sum of the number of nodes contained in each element on
           this PET. The number of nodes in each element is implied by its element type in 
           <TT>elementTypes</TT>. The nodes for each element 
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.). 
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104800000000000000">
29.4.8 ESMF_MeshCreate - Create a Mesh from a file</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_MeshCreate()
     function ESMF_MeshCreateFromFile(filename, filetypeflag, convert3D, &amp;
                  convertToDual, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Mesh)         :: ESMF_MeshCreateFromFile
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(len=*),           intent(in)            :: filename
     type(ESMF_FileFormat_Flag), intent(in)            :: filetypeflag
     logical,                    intent(in),  optional :: convert3D
     logical,                    intent(in),  optional :: convertToDual
     integer,                    intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create a Mesh from a file. Provides options to convert to 3D and in the case of SCRIP
     format files, allows the dual of the mesh to be created. 

<P>
This call is <EM>collective</EM> across the current VM.

<P>
<DL>
<DT><STRONG>filename</STRONG></DT>
<DD>The name of the grid file
     
</DD>
<DT><STRONG>filetypeflag</STRONG></DT>
<DD>The file type of the grid file to be read, please see Section&nbsp;<A HREF="node5.html#const:fileformat">29.2.2</A>
           for a list of valid options. 
     
</DD>
<DT><STRONG>convert3D</STRONG></DT>
<DD>if TRUE, the node coordinates will be converted into 3D Cartisian, which
           is required for a global grid
     
</DD>
<DT><STRONG>convertToDual</STRONG></DT>
<DD>if TRUE, the mesh will be converted to its dual. If not specified,
           defaults to true. Converting to dual is not supported with
           file type <TT>ESMF_FILEFORMAT_ESMFMESH</TT>, so when using that file type
           this parameter has no effect.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050104900000000000000">
29.4.9 ESMF_MeshDestroy - Release resources associated with a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_MeshDestroy(mesh, keywordenforcer, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)          :: mesh
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,         intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
This call removes internal memory associated with <TT>mesh</TT>. 
    After this call <TT>mesh</TT> will no longer be usable.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object to be destroyed.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041000000000000000">
29.4.10 ESMF_MeshFreeMemory - Remove a Mesh and its memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_MeshFreeMemory(mesh, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh), intent(inout)        :: mesh
     integer,        intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call removes the portions of <TT>mesh</TT> which contain connection and coordinate
      information. After this call, Fields build on <TT>mesh</TT> will no longer be usable
      as part of an <TT>ESMF_FieldRegridStore()</TT> operation. However, after this call 
      Fields built on <TT>mesh</TT> can still be used in an <TT>ESMF_FieldRegrid()</TT> 
      operation if the routehandle was generated beforehand. New Fields may also
      be built on <TT>mesh</TT> after this call.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object whose memory is to be freed. 
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501041100000000000000">
29.4.11 ESMF_MeshGet - Get information from a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>       subroutine ESMF_MeshGet(mesh, parametricDim, spatialDim, &amp;
                    nodalDistgrid, elementDistgrid, &amp;
                    numOwnedNodes, ownedNodeCoords, &amp;
                    numOwnedElements, isMemFreed, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Mesh),     intent(inout)         :: mesh
     integer,             intent(out), optional :: parametricDim
     integer,             intent(out), optional :: spatialDim
     type(ESMF_DistGrid), intent(out), optional :: nodalDistgrid
     type(ESMF_DistGrid), intent(out), optional :: elementDistgrid
     integer,             intent(out), optional :: numOwnedNodes
     real(ESMF_KIND_R8),  intent(out), optional :: ownedNodeCoords(:)
     integer,             intent(out), optional :: numOwnedElements
     logical,             intent(out), optional :: isMemFreed
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get various information from a mesh.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object to retrieve information from.
   
</DD>
<DT><STRONG>[parametricDim]</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would
   have a parametric dimension of 2, whereas a Mesh constructed of cubes would have one
   of 3.)
   
</DD>
<DT><STRONG>[spatialDim]</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes 
   making up the Mesh. For a manifold, the spatial dimesion can be larger than the 
   parametric dim (e.g. the 2D surface of a sphere in 3D space), but it can't be smaller. 
   
</DD>
<DT><STRONG>[nodalDistgrid]</STRONG></DT>
<DD>A 1D arbitrary distgrid describing the distribution of the nodes across the PETs. Note that
   on each PET the distgrid will only contain entries for nodes owned by that PET.
   This is the DistGrid that would be used to construct the Array in a Field that is constructed
   on <TT>mesh</TT>.
   
</DD>
<DT><STRONG>[elementDistgrid]</STRONG></DT>
<DD>A 1D arbitrary distgrid describing the distribution of elements across the PETs. Note that
   on each PET the distgrid will only contain entries for elements owned by that PET.
   
</DD>
<DT><STRONG>[numOwnedNodes]</STRONG></DT>
<DD>The number of local nodes which are owned by this PET. This is the number of PET local entries in
   the nodalDistgrid.
   
</DD>
<DT><STRONG>[ownedNodeCoords]</STRONG></DT>
<DD>The coordinates for the local nodes. These coordinates will be in the proper order to correspond
   with the nodes in the <TT>nodalDistgrid</TT> returned by this call, and hence with a Field built on 
   <TT>mesh</TT>. The size of the input array should be the spatial dim of <TT>mesh</TT> times 
   <TT>numOwnedNodes</TT>.
   
</DD>
<DT><STRONG>[numOwnedElements]</STRONG></DT>
<DD>The number of local elements which are owned by this PET. Note that every element is owned by 
   the PET it resides on, so unlike for nodes, <TT>numOwnedElements</TT> is identical to the number of elements on
   the PET. It is also the number of PET local entries in the elementDistgrid. 
   
</DD>
<DT><STRONG>[isMemFreed]</STRONG></DT>
<DD>Indicates if the coordinate and connection memory been freed from <TT>mesh</TT>. If so, it
   can no longer be used as part of an <TT>ESMF_FieldRegridStore()</TT> call.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION050110000000000000000">
30 XGrid Class</A>
</H1>

<P>

<H2><A NAME="SECTION050111000000000000000">
30.1 Description</A>
</H2>

<P>
An exchange grid represents the 2D boundary layer usually between the
atmosphere on one side and ocean and land on the other in an Earth
system model. There are dynamical and thermodynamical processes on
either side of the boundary layer and on the boundary layer itself.
The boundary layer exchanges fluxes from either side and adjusts
boundary conditions for the model components involved. For climate modeling,
it is critical that the fluxes transferred by the boundary layer are
conservative.

<P>
The exchange grid is implemented as a collection of the intersected cells
between atmosphere and ocean/land[<A
 HREF="node8.html#BalajiXGrid">22</A>]. These cells can have irregular shapes
and can be broken down into triangles facilitating a finite element
approach. In practice, there is a threshold of minimum cell area below
which intersections are discarded.

<P>

<H2><A NAME="SECTION050112000000000000000">
30.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION050112100000000000000"></A>
<A NAME="const:xgridside"></A>
<BR>
30.2.1 ESMF_XGRIDSIDE
</H3>

<P>
<I>DESCRIPTION:
<BR></I>  
Specify which side of the <TT>ESMF_XGrid</TT> the current operation is taking place.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_XGridSide_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_XGRIDSIDE_A</STRONG></DT>
<DD>A side of the eXchange Grid, corresponding to the A side of the Grids used to create an XGrid.
</DD>
<DT><STRONG>ESMF_XGRIDSIDE_B</STRONG></DT>
<DD>B side of the eXchange Grid, corresponding to the B side of the Grids used to create an XGrid.
</DD>
<DT><STRONG>ESMF_XGRIDSIDE_BALANCED</STRONG></DT>
<DD>The internally generated balanced side of the eXchange Grid in the middle.
</DD>
</DL>

<P>

<H2><A NAME="SECTION050113000000000000000">
30.3 Use and Examples</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050113100000000000000"></A>
  <A NAME="sec:xgrid:usage:xgrid_createraw"></A>
<BR>
30.3.1 Create an XGrid from user input data then use it for regridding
</H3>

<P>
XGrid can be created from user input data, such as Grids on either side,
   area and centroid information of XGrid cells, sparse matrix matmul information
   such as factorList and factorIndexList. The functionalities provided by the
   XGrid object is constrained by the user supplied input during its creation time.

<P>
In this example, we will set up a simple XGrid from overlapping Grids on
   either side of the XGrid. Then we perform a flux exchange from one side
   to the other side of the XGrid. The Grids are laid out in the following figure:
  <DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xgridsimple"></A><A NAME="44271"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 20:</STRONG>
Grid layout for simple XGrid creation example. Overlapping of 3 Grids
  (Green 2x2, Red 2x1, Blue 2x2). Green and red Grids on side A, blue Grid on side
  B, black indicates the resulting XGrid. Color coded sequence indices are shown.
  Physical coordinates are the tuples in parenthese, e.g. at the four 
  corners of rectangular computational domain.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.6}{\includegraphics{XGridEx1}}$
 -->
<IMG
 WIDTH="683" HEIGHT="458" ALIGN="BOTTOM" BORDER="0"
 SRC="img79.png"
 ALT="\scalebox{0.6}{\includegraphics{XGridEx1}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
We start by creating the Grids on both sides and associate coordinates with
   the Grids. For details of Grid creation and coordinate use, please refer to
   Grid class documentation. 

<P>
<PRE>
    sideA(1) = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/2,2/), &amp;
        coordDep1=(/1/), &amp;
        coordDep2=(/2/), &amp;
        name='source Grid 1 on side A', rc=localrc)
</PRE>

<P>
<PRE>
    sideA(2) = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/2,1/), &amp;
        coordDep1=(/1/), &amp;
        coordDep2=(/2/), &amp;
        name='source Grid 2 on side A', rc=localrc)
</PRE>

<P>
<PRE>
    do i = 1, 2
        call ESMF_GridAddCoord(sideA(i), staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
            rc=localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
						endflag=ESMF_END_ABORT)
    enddo
</PRE>

<P>
Coordinate for the Grids on sideA, refer to the Grid layout diagram for the 
   interpretation of the coordinate values: 

<P>
<PRE>
    ! SideA first grid
    centroidA1X=(/0.5, 1.5/)
    centroidA1Y=(/0.5, 1.5/)
    call ESMF_GridGetCoord(sideA(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=1, &amp;
        farrayPtr=coordX, rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    coordX = centroidA1X
    call ESMF_GridGetCoord(sideA(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=2, &amp;
        farrayPtr=coordY, rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
         endflag=ESMF_END_ABORT)
    coordY = centroidA1Y

    ! SideA second grid
    centroidA2X=(/0.5, 1.5/)
    centroidA2Y=(/2.5/)
    call ESMF_GridGetCoord(sideA(2), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=1, &amp;
        farrayPtr=coordX, rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
        endflag=ESMF_END_ABORT)
    coordX = centroidA2X
    call ESMF_GridGetCoord(sideA(2), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=2, &amp;
        farrayPtr=coordY, rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    coordY = centroidA2Y
</PRE>

<P>
Create the destination grid on side B, only one Grid exists on side B. Also associate
   coordinate with the Grid: 

<P>
<PRE>
    sideB(1) = ESMF_GridCreateNoPeriDim(minIndex=(/1,1/), maxIndex=(/2,2/), &amp;
        coordDep1=(/1/), coordDep2=(/2/), &amp;
        name='destination Grid on side B', rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    do i = 1, 1
        call ESMF_GridAddCoord(sideB(i), staggerloc=ESMF_STAGGERLOC_CENTER, &amp;
            rc=localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    enddo

    ! SideB grid
    centroidBX=(/0.75, 1.75/)
    centroidBY=(/0.75, 2.25/)
    call ESMF_GridGetCoord(sideB(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=1, farrayPtr=coordX, &amp;
                rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    coordX = centroidBX
    call ESMF_GridGetCoord(sideB(1), localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, coordDim=2, farrayPtr=coordY, &amp;
                rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    coordY = centroidBY
</PRE>

<P>
Set up the mapping indices and weights from A side to the XGrid. For details of 
   sequence indices, factorIndexList, and factorList, please see section 
   <A HREF="node5.html#Array:SparseMatMul">24.2.17</A> in the reference manual. Please refer to the figure above
   for interpretation of the sequence indices used here.

<P>
In order to compute the destination flux on sideB through the XGrid as an mediator, 
   we need to set up the factorList (weights) and factorIndexList (indices) 
   for sparse matrix matmul in this formulation:
   dst_flux = W'*W*src_flux, where W' is the weight matrix from the XGrid to 
   destination; and W is the weight matrix from source to the XGrid. The weight matrix
   is generated using destination area weighted algorithm. Please refer to figure 
   <A HREF="node5.html#fig:xgridsimple">20</A> for details.

<P>
<PRE>
    ! Set up mapping from A1 -&gt; X
    sparseMatA2X(1)%factorIndexList(1,1)=1    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,2)=2    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,3)=2    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,4)=3    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,5)=4    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,6)=4    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,7)=3    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,8)=4    ! src seq index (green)
    sparseMatA2X(1)%factorIndexList(1,9)=4    ! src seq index (green)

    sparseMatA2X(1)%factorIndexList(2,1)=1    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,2)=2    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,3)=3    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,4)=4    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,5)=5    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,6)=6    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,7)=7    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,8)=8    ! dst seq index (black)
    sparseMatA2X(1)%factorIndexList(2,9)=9    ! dst seq index (black)

    ! Set up mapping from A2 -&gt; X
    sparseMatA2X(2)%factorIndexList(1,1)=1    ! src seq index (red)
    sparseMatA2X(2)%factorIndexList(1,2)=2    ! src seq index (red)
    sparseMatA2X(2)%factorIndexList(1,3)=2    ! src seq index (red)

    sparseMatA2X(2)%factorIndexList(2,1)=10   ! dst seq index (black)
    sparseMatA2X(2)%factorIndexList(2,2)=11   ! dst seq index (black)
    sparseMatA2X(2)%factorIndexList(2,3)=12   ! dst seq index (black)
 </PRE>

<P>
Set up the mapping weights from side A to the XGrid: 

<P>
<PRE>
    ! Note that the weights are dest area weighted, they are ratio 
    ! of areas with destination area as the denominator.
    ! Set up mapping weights from A1 -&gt; X
    sparseMatA2X(1)%factorList(:)=1.

    ! Set up mapping weights from A2 -&gt; X
    sparseMatA2X(2)%factorList(:)=1.
 </PRE>

<P>
Set up the mapping indices and weights from the XGrid to B side: 

<P>
<PRE>
    ! Set up mapping from X -&gt; B
    sparseMatX2B(1)%factorIndexList(1,1)=1    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,2)=2    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,3)=3    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,4)=4    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,5)=5    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,6)=6    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,7)=7    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,8)=8    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,9)=9    ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,10)=10  ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,11)=11  ! src seq index (black)
    sparseMatX2B(1)%factorIndexList(1,12)=12  ! src seq index (black)

    sparseMatX2B(1)%factorIndexList(2,1)=1    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,2)=1    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,3)=2    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,4)=1    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,5)=1    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,6)=2    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,7)=3    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,8)=3    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,9)=4    ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,10)=3   ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,11)=3   ! dst seq index (blue)
    sparseMatX2B(1)%factorIndexList(2,12)=4   ! dst seq index (blue)

    ! Set up mapping weights from X -&gt; B
    sparseMatX2B(1)%factorList(1)=4./9.
    sparseMatX2B(1)%factorList(2)=2./9.
    sparseMatX2B(1)%factorList(3)=2./3.
    sparseMatX2B(1)%factorList(4)=2./9.
    sparseMatX2B(1)%factorList(5)=1./9.
    sparseMatX2B(1)%factorList(6)=1./3.
    sparseMatX2B(1)%factorList(7)=2./9.
    sparseMatX2B(1)%factorList(8)=1./9.
    sparseMatX2B(1)%factorList(9)=1./3.
    sparseMatX2B(1)%factorList(10)=4./9.
    sparseMatX2B(1)%factorList(11)=2./9.
    sparseMatX2B(1)%factorList(12)=2./3.
 </PRE>

<P>
Optionally the area can be setup to compute surface area weighted flux integrals: 

<P>
<PRE>
    ! Set up destination areas to adjust weighted flux
    xgrid_area(1) = 1.
    xgrid_area(2) = 0.5
    xgrid_area(3) = 0.5
    xgrid_area(4) = 0.5
    xgrid_area(5) = 0.25
    xgrid_area(6) = 0.25
    xgrid_area(7) = 0.5
    xgrid_area(8) = 0.25
    xgrid_area(9) = 0.25
    xgrid_area(10) = 1.
    xgrid_area(11) = 0.5
    xgrid_area(12) = 0.5
</PRE>

<P>
Create an XGrid based on the user supplied regridding parameters: 

<P>
<PRE>
    xgrid = ESMF_XGridCreate(sideA, sideB, offline=.true., area=xgrid_area, &amp;
        centroid=centroid, sparseMatA2X=sparseMatA2X, &amp;
        sparseMatX2B=sparseMatX2B, rc=localrc)
</PRE>

<P>
Create an <TT>ESMF_Field</TT> on the XGrid: 

<P>
<PRE>
    field = ESMF_FieldCreate(xgrid, typekind=ESMF_TYPEKIND_R8, &amp;
                rc=localrc)
</PRE>

<P>
Query the Field for its Fortran data pointer and its exclusive bounds: 

<P>
<PRE>
    call ESMF_FieldGet(field, farrayPtr=xfarrayPtr, &amp;
        exclusiveLBound=xlb, exclusiveUBound=xub, rc=localrc)
</PRE>

<P>
Setup and initialize src and dst Fields on side A and side B Grids, 
   source Fields have different source flux: 

<P>
<PRE>
    do i = 1, 2
        srcField(i) = ESMF_FieldCreate(sideA(i), &amp;
                typekind=ESMF_TYPEKIND_R8, rc=localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
        call ESMF_FieldGet(srcField(i), farrayPtr=farrayPtr, rc=localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
        farrayPtr = i
    enddo
    do i = 1, 1
        dstField(i) = ESMF_FieldCreate(sideB(i), &amp;
                typekind=ESMF_TYPEKIND_R8, rc=localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
        call ESMF_FieldGet(dstField(i), farrayPtr=farrayPtr, rc=localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
        farrayPtr = 0.0
    enddo
</PRE>

<P>
The current implementation requires that Grids used to generate the XGrid
   must not match, i.e. they are different either topologically or geometrically or both.
   In this example, the first source Grid is topologically identical to the destination
   Grid but their geometric coordinates are different. This requirement will be relaxed
   in a future release.

<P>
First we compute the regrid routehandles, these routehandles can be used repeatedly
   afterwards. Then we initialize the values in the Fields. Finally we execute the Regrid.

<P>
<PRE>
    ! Compute regrid routehandles. The routehandles can be used 
    ! repeatedly afterwards.
    ! From A -&gt; X
    do i = 1, 2
        call ESMF_FieldRegridStore(xgrid, srcField(i), field, &amp;
		routehandle=rh_src2xgrid(i), rc = localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    enddo
    ! from X -&gt; B
    do i = 1, 1
        call ESMF_FieldRegridStore(xgrid, field, dstField(i), &amp;
		routehandle=rh_xgrid2dst(i), rc = localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    enddo

    ! Initialize values in the source Fields on side A
    do i = 1, 2
        call ESMF_FieldGet(srcField(i), farrayPtr=farrayPtr, rc=localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
        farrayPtr = i
    enddo
    ! Initialize values in the destination Field on XGrid
    xfarrayPtr = 0.0
    ! Initialize values in the destination Field on Side B
    do i = 1, 1
        call ESMF_FieldGet(dstField(i), farrayPtr=farrayPtr, rc=localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
        farrayPtr = 0.0
    enddo
</PRE>

<P>
First we regrid from the Fields on side A to the Field on the XGrid: 

<P>
<PRE>
    ! Execute regrid from A -&gt; X
    do i = 1, 2
        call ESMF_FieldRegrid(srcField(i), field, &amp;
            routehandle=rh_src2xgrid(i), &amp;
            zeroregion=ESMF_REGION_SELECT, rc = localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    enddo
</PRE>

<P>
Next we regrid from the Field on XGrid to the destination Field on side B: 

<P>
<PRE>
    ! Execute the regrid store
    do i = 1, 1
        call ESMF_FieldRegrid(field, dstField(i), &amp;
            routehandle=rh_xgrid2dst(i), rc = localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    enddo
</PRE>

<P>
In the above example, we first set up all the required paramters to create an XGrid from user
   supplied input. Then we create Fields on the XGrid and the Grids on either side. Finally
   we use the <TT>ESMF_FieldRegrid()</TT> interface to perform a flux exchange from the source side
   to the destination side. 

<P>

<H3><A NAME="SECTION050113200000000000000"></A>
  <A NAME="sec:xgrid:usage:xgrid_get"></A>
<BR>
30.3.2 Query the XGrid for its internal information
</H3>
   One can query the XGrid for its internal information: 

<P>
<PRE>
    call ESMF_XGridGet(xgrid, &amp;
        ngridA=ngridA, &amp;    ! number of Grids on side A
        ngridB=ngridB, &amp;    ! number of Grids on side B
        sideA=l_sideA, &amp;    ! list of Grids on side A
        sideB=l_sideB, &amp;    ! list of Grids on side B
        area=l_area, &amp;      ! list of area of XGrid
        centroid=l_centroid, &amp;  ! list of centroid of XGrid
        distgridA=l_sideAdg, &amp;  ! list of Distgrids on side A
        distgridM = distgrid, &amp; ! balanced distgrid
        sparseMatA2X=l_sparseMatA2X, &amp; !sparse matrix matmul parameters A to X
        sparseMatX2B=l_sparseMatX2B, &amp; !sparse matrix matmul parameters X to B
        rc=localrc)
</PRE>

<P>
<PRE>
    call ESMF_XGridGet(xgrid, localDe=0, &amp;
        elementCount=eleCount, &amp;    ! elementCount on the localDE
        exclusiveCount=ec, &amp;        ! exclusive count
        exclusiveLBound=elb, &amp;      ! exclusive lower bound
        exclusiveUBound=eub, &amp;      ! exclusive upper bound
        rc=localrc)
</PRE>

<P>
<PRE>
    call ESMF_XGridGet(xgrid, &amp;
        xgridSide=ESMF_XGRIDSIDE_A, &amp; ! side of the XGrid to query
        gridIndex=1, &amp;              ! index of the distgrid
        distgrid=distgrid, &amp;        ! the distgrid returned
        rc=localrc)
</PRE>

<P>

<H3><A NAME="SECTION050113300000000000000"></A>
  <A NAME="sec:xgrid:usage:xgrid_destroy"></A>
<BR>
30.3.3 Destroying the XGrid and other resources
</H3>
   Clean up the resources by destroy the XGrid and other objects: 

<P>
<PRE>
    ! After the regridding is successful. 
    ! Clean up all the allocated resources:
    call ESMF_FieldDestroy(field, rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)

    call ESMF_XGridDestroy(xgrid, rc=localrc)
    if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)

    do i = 1, 2
        call ESMF_FieldDestroy(srcField(i), rc = localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
        call ESMF_GridDestroy(sideA(i), rc = localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    enddo

    do i = 1, 1
        call ESMF_FieldDestroy(dstField(i), rc = localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
        call ESMF_GridDestroy(sideB(i), rc = localrc)
        if(localrc /= ESMF_SUCCESS) call ESMF_Finalize(rc=localrc, &amp;
		endflag=ESMF_END_ABORT)
    enddo

    deallocate(sparseMatA2X(1)%factorIndexList, sparseMatA2X(1)%factorList)
    deallocate(sparseMatA2X(2)%factorIndexList, sparseMatA2X(2)%factorList)
    deallocate(sparseMatX2B(1)%factorIndexList, sparseMatX2B(1)%factorList)
 </PRE>

<P>

<P>

<H2><A NAME="SECTION050114000000000000000">
30.4 Restrictions and Future Work</A>
</H2>

<P>

<H3><A NAME="SECTION050114100000000000000">
30.4.1 Restrictions and Future Work</A>
</H3>

<P>

<A NAME="XGrid:rest"></A>

<OL>
<LI><B>CAUTION:</B> The XGrid class and its APIs are only tested in a 
uni-processor setup, however in principle it should also work multi-processor. 
This limitation will be removed in a future release.
</LI>
<LI>More convenient <TT>ESMF_XGridCreate()</TT> API will be provided in
the future that will not require a user to supply the interpolation matrix.

<P>
</LI>
</OL>

<P>

<P>

<H2><A NAME="SECTION050115000000000000000">
30.5 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>The XGrid class is implemented in Fortran, and as such is
defined inside the framework by a XGrid derived type and a set of 
subprograms (functions and subroutines) which operate on that derived type.  
The XGrid class contains information needed to create Grid, Field, and
Sparse Matrix MatMul.

<P>
</LI>
<LI>XGrids follow the framework-wide convention of the
<I>unison</I> creation and operation rule: All PETs which are
part of the currently executing VM must create the
same XGrids at the same point in their execution.  Since an early
user request was that global object creation not impose the overhead of
a barrier or synchronization point, XGrid creation does no inter-PET
communication.  For this to work, each PET must query the total number
of PETs in this VM, and which local PET number it is.  It can then
compute which DE(s) are part of the local decomposition, and any
global information can be computed in unison by all PETs independently
of the others.  In this way the overhead of communication is avoided,
at the cost of more difficulty in diagnosing program bugs which result
from not all PETs executing the same create calls.

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION050116000000000000000">
30.6 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050116100000000000000">
30.6.1 ESMF_XGridAssignment(=) - XGrid assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     xgrid1 = xgrid2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid) :: xgrid1
     type(ESMF_XGrid) :: xgrid2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Assign xgrid1 as an alias to the same ESMF XGrid object in memory
     as xgrid2. If xgrid2 is invalid, then xgrid1 will be equally invalid after
     the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>xgrid1</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>xgrid2</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116200000000000000">
30.6.2 ESMF_XGridOperator(==) - XGrid equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface operator(==)
     if (xgrid1 == xgrid2) then ... endif
               OR
     result = (xgrid1 == xgrid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid1
     type(ESMF_XGrid), intent(in) :: xgrid2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether xgrid1 and xgrid2 are valid aliases to the same ESMF
     XGrid object in memory. For a more general comparison of two ESMF XGrids,
     going beyond the simple alias test, the ESMF_XGridMatch() function (not yet
     implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>xgrid1</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>xgrid2</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116300000000000000">
30.6.3 ESMF_XGridOperator(/=) - XGrid not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface operator(/=)
     if (xgrid1 /= xgrid2) then ... endif
               OR
     result = (xgrid1 /= xgrid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(in) :: xgrid1
     type(ESMF_XGrid), intent(in) :: xgrid2
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether xgrid1 and xgrid2 are <I>not</I> valid aliases to the
     same ESMF XGrid object in memory. For a more general comparison of two ESMF
     XGrids, going beyond the simple alias test, the ESMF_XGridMatch() function
     (not yet implemented) must be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>xgrid1</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>xgrid2</STRONG></DT>
<DD>The <TT>ESMF_XGrid</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116400000000000000">
30.6.4 ESMF_XGridCreate - Create an XGrid from user input</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> 
 function ESMF_XGridCreate(sideA, sideB, &amp;
 &amp;
 sideAToXGridScheme, sideBToXGridScheme, &amp;
 sideAPriority, sideBPriority, &amp;
 sideAMaskValues, sideBMaskValues, &amp;
 storeOverlay, &amp;
 offline, &amp;
 sparseMatA2X, sparseMatX2A, sparseMatB2X, sparseMatX2B, &amp;
 area, centroid, &amp;
 name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> type(ESMF_Grid), intent(in)                 :: sideA(:), sideB(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
 integer, intent(in), optional               :: sideAToXGridScheme
 integer, intent(in), optional               :: sideBToXGridScheme
 integer, intent(in), optional               :: sideAPriority(:)
 integer, intent(in), optional               :: sideBPriority(:)
 integer(ESMF_KIND_I4), intent(in), optional :: sideAMaskValues(:)
 integer(ESMF_KIND_I4), intent(in), optional :: sideBMaskValues(:)
 logical, intent(in), optional               :: storeOverlay
 logical, intent(in), optional               :: offline
 type(ESMF_XGridSpec), intent(in), optional  :: sparseMatA2X(:)
 type(ESMF_XGridSpec), intent(in), optional  :: sparseMatX2A(:)
 type(ESMF_XGridSpec), intent(in), optional  :: sparseMatB2X(:)
 type(ESMF_XGridSpec), intent(in), optional  :: sparseMatX2B(:)
 real(ESMF_KIND_R8), intent(in), optional    :: area(:)
 real(ESMF_KIND_R8), intent(in), optional    :: centroid(:,:)
 character(len=*), intent(in), optional      :: name
 integer, intent(out), optional              :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>   type(ESMF_XGrid)              :: ESMF_XGridCreate
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an XGrid from user input

<P>
The arguments are:
       <DL>
<DT><STRONG>sideA</STRONG></DT>
<DD>2D Grids on side A
       
</DD>
<DT><STRONG>sideB</STRONG></DT>
<DD>2D Grids on side B
       
</DD>
<DT><STRONG>[sideAToXGridScheme]</STRONG></DT>
<DD>Specify the geometry and unit of metric of the Grids on A side. 
       
</DD>
<DT><STRONG>[sideBToXGridScheme]</STRONG></DT>
<DD>Specify the geometry and unit of metric of the Grids on B side. 
       
</DD>
<DT><STRONG>[sideAPriority]</STRONG></DT>
<DD>Priority array of Grids on sideA during overlay generation.
             The priority arrays describe the priorities of Grids at the overlapping region.
             Flux contributions at the overlapping region are computed from the Grid of the
             highest priority.
       
</DD>
<DT><STRONG>[sideBPriority]</STRONG></DT>
<DD>priority of Grids on sideB during overlay generation
             The priority arrays describe the priorities of Grids at the overlapping region.
             Flux contributions at the overlapping region are computed from the Grid of the
             highest priority.
       
</DD>
<DT><STRONG>[storeOverlay]</STRONG></DT>
<DD>Setting the storeOverlay optional argument to .false. (default) 
             allows a user to bypass internal calculation of the fully 
             unstructured grid and its storage.
       
</DD>
<DT><STRONG>[offline]</STRONG></DT>
<DD>Turn on offline XGrid creation and will use user supplied Sparse
             MatMul, area, centroid information.
       
</DD>
<DT><STRONG>[sparseMatA2X]</STRONG></DT>
<DD>indexlist from a Grid index space on side A to xgrid index space;
             indexFactorlist from a Grid index space on side A to xgrid index space.
       
</DD>
<DT><STRONG>[sparseMatX2A]</STRONG></DT>
<DD>indexlist from xgrid index space to a Grid index space on side A;
             indexFactorlist from xgrid index space to a Grid index space on side A.
       
</DD>
<DT><STRONG>[sparseMatB2X]</STRONG></DT>
<DD>indexlist from a Grid index space on side B to xgrid index space;
             indexFactorlist from a Grid index space on side B to xgrid index space.
       
</DD>
<DT><STRONG>[sparseMatX2B]</STRONG></DT>
<DD>indexlist from xgrid index space to a Grid index space on side B;
             indexFactorlist from xgrid index space to a Grid index space on side B.
       
</DD>
<DT><STRONG>[area]</STRONG></DT>
<DD>area of the xgrid cells.
       
</DD>
<DT><STRONG>[centroid]</STRONG></DT>
<DD>coordinates at the area weighted center of the xgrid cells.
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>name of the xgrid object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> only if the <TT>ESMF_XGrid</TT> 
             is created.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116500000000000000">
30.6.5 ESMF_XGridDestroy - Release resources associated with an XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> 
   subroutine ESMF_XGridDestroy(xgrid, keywordenforcer, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_XGrid), intent(inout)          :: xgrid       
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,          intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_XGrid</TT>, releasing the resources associated
   with the object.

<P>
The arguments are:
   <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD><TT>ESMF_XGrid</TT> object.
   
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
   
</DD>
</DL>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION050116600000000000000">
30.6.6 ESMF_XGridGet - Get default information from an XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_XGridGet()
 
 subroutine ESMF_XGridGetDefault(xgrid, &amp;
     sideA, sideB, ngridA, ngridB, area, centroid, &amp;
     distgridA, distgridB, distgridM, &amp;
     dimCount, localDECount, &amp;
     sparseMatA2X, sparseMatX2A, sparseMatB2X, sparseMatX2B, &amp;
     name, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> type(ESMF_XGrid), intent(in)                :: xgrid
 type(ESMF_Grid), intent(out), optional      :: sideA(:), sideB(:)
 integer, intent(out), optional              :: ngridA, ngridB
 real*8, intent(out), optional               :: area(:)
 real*8, intent(out), optional               :: centroid(:,:)
 type(ESMF_DistGrid), intent(out), optional  :: distgridA(:)
 type(ESMF_DistGrid), intent(out), optional  :: distgridB(:)
 type(ESMF_DistGrid), intent(out), optional  :: distgridM
 integer, intent(out), optional              :: dimCount
 integer, intent(out), optional              :: localDECount
 type(ESMF_XGridSpec), intent(out), optional :: sparseMatA2X(:)
 type(ESMF_XGridSpec), intent(out), optional :: sparseMatX2A(:)
 type(ESMF_XGridSpec), intent(out), optional :: sparseMatB2X(:)
 type(ESMF_XGridSpec), intent(out), optional :: sparseMatX2B(:)
 character (len=*), intent(out), optional    :: name
 integer, intent(out), optional              :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get information about XGrid

<P>
The arguments are:
       <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The xgrid object used to retrieve information from.
       
</DD>
<DT><STRONG>[sideA]</STRONG></DT>
<DD>2D Grids on side A
       
</DD>
<DT><STRONG>[sideB]</STRONG></DT>
<DD>2D Grids on side B
       
</DD>
<DT><STRONG>[ngridA]</STRONG></DT>
<DD>Number of grids on the A side
       
</DD>
<DT><STRONG>[ngridB]</STRONG></DT>
<DD>Number of grids on the B side
       
</DD>
<DT><STRONG>[area]</STRONG></DT>
<DD>area of the xgrid cells
       
</DD>
<DT><STRONG>[centroid]</STRONG></DT>
<DD>coordinates at the area weighted center of the xgrid cells
       
</DD>
<DT><STRONG>[distgridA]</STRONG></DT>
<DD>list of distgrids whose sequence index list is an overlap between a Grid
             on sideA and the xgrid object.
       
</DD>
<DT><STRONG>[distgridB]</STRONG></DT>
<DD>list of distgrids whose sequence index list is an overlap between a Grid
             on sideB and the xgrid object.
       
</DD>
<DT><STRONG>[distgridM]</STRONG></DT>
<DD>the distgrid whose sequence index list fully describes the xgrid object.
       
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>dimension of the xgrid 
       
</DD>
<DT><STRONG>[localDECount]</STRONG></DT>
<DD>number of local DEs on local PET
       
</DD>
<DT><STRONG>[sparseMatA2X]</STRONG></DT>
<DD>indexlist from a Grid index space on side A to xgrid index space
             indexFactorlist from a Grid index space on side A to xgrid index space
       
</DD>
<DT><STRONG>[sparseMatX2A]</STRONG></DT>
<DD>indexlist from xgrid index space to a Grid index space on side A
             indexFactorlist from xgrid index space to a Grid index space on side A
       
</DD>
<DT><STRONG>[sparseMatB2X]</STRONG></DT>
<DD>indexlist from a Grid index space on side B to xgrid index space
             indexFactorlist from a Grid index space on side B to xgrid index space
       
</DD>
<DT><STRONG>[sparseMatX2B]</STRONG></DT>
<DD>indexlist from xgrid index space to a Grid index space on side B
             indexFactorlist from xgrid index space to a Grid index space on side B
       
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>name of the xgrid object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> only if the <TT>ESMF_XGrid</TT> 
             is created.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116700000000000000">
30.6.7 ESMF_XGridGet - Get an individual DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_XGridGet()
 
 subroutine ESMF_XGridGetDG(xgrid, distgrid, xgridside, gridindex, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> type(ESMF_XGrid), intent(in)                 :: xgrid
 type(ESMF_DistGrid), intent(out)             :: distgrid
 type(ESMF_XGridSide_Flag), intent(in), optional   :: xgridside
 integer, intent(in), optional                :: gridindex
 integer, intent(out), optional               :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get a distgrid from XGrid from a specific side. 

<P>
The arguments are:
       <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The xgrid object used to retrieve information from.
       
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Distgrid whose sequence index list is an overlap between gridIndex-th Grid
         on xgridSide and the xgrid object.
       
</DD>
<DT><STRONG>[xgridside]</STRONG></DT>
<DD>Which side of the XGrid to retrieve the distgrid from (either ESMF_XGRIDSIDE_A,
         ESMF_XGRIDSIDE_B, or ESMF_XGRIDSIDE_BALANCED). If not passed in then
         defaults to ESMF_XGRIDSIDE_BALANCED.

</DD>
<DT><STRONG>[gridindex]</STRONG></DT>
<DD>If xgridSide is ESMF_XGRIDSIDE_A or ESMF_XGRIDSIDE_B then this index 
         selects the Distgrid associated with the Grid on
         that side. If not provided, defaults to 1. 
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> only if the <TT>ESMF_XGrid</TT> 
         is created.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050116800000000000000">
30.6.8 ESMF_XGridGet - Get information about an XGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_XGridGet()
 
 subroutine ESMF_XGridGetEle(xgrid, &amp;
     localDE, elementCount, &amp;
     exclusiveCount, exclusiveLBound, exclusiveUBound, &amp;
     rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE> type(ESMF_XGrid), intent(in)                 :: xgrid
 integer, intent(in)                          :: localDE
 integer, intent(out), optional               :: elementCount
 integer, intent(out), optional               :: exclusiveCount
 integer, intent(out), optional               :: exclusiveLBound
 integer, intent(out), optional               :: exclusiveUBound
 integer, intent(out), optional               :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get localDE specific information about XGrid

<P>
The arguments are:
       <DL>
<DT><STRONG>xgrid</STRONG></DT>
<DD>The xgrid object used to retrieve information from.
       
</DD>
<DT><STRONG>localDE</STRONG></DT>
<DD>Local DE for which information is requested.
            [0,..,localDeCount-1]
       
</DD>
<DT><STRONG>[elementCount]</STRONG></DT>
<DD>Number of elements in exclusive region per DE
       
</DD>
<DT><STRONG>[exclusiveLBound]</STRONG></DT>
<DD>Lower bound of sequence indices in exclusive region per DE
       
</DD>
<DT><STRONG>[exclusiveUBound]</STRONG></DT>
<DD>Upper bound of sequence indices in exclusive region per DE
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> only if the <TT>ESMF_XGrid</TT> 
             is created.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<P>

<P>

<H1><A NAME="SECTION050120000000000000000">
31 DistGrid Class</A>
</H1>

<P>

<H2><A NAME="SECTION050121000000000000000">
31.1 Description</A>
</H2>

<P>
<A NAME="sec:DistGrid"></A>The ESMF DistGrid class sits on top of the DELayout class and holds domain
information in index space. A DistGrid object captures the index space topology
and describes its decomposition in terms of DEs. Combined with DELayout and VM
the DistGrid defines the data distribution of a domain decomposition across the
computational resources of an ESMF Component.

<P>
The global domain is defined as the union or ``tilework'' of logically
rectangular (LR) sub-domains or <EM>tiles</EM>. The DistGrid create methods allow
the specification of such a tilework global domain and its decomposition into
exclusive, DE-local LR regions according to various degrees of user specified
constraints. Complex index space topologies can be constructed by specifying
connection relationships between tiles during creation.

<P>
The DistGrid class holds domain information for all DEs. Each DE is associated
with a local LR region. No overlap of the regions is allowed. The DistGrid
offers query methods that allow DE-local topology information to be extracted,
e.g. for the construction of halos by higher classes.

<P>
A DistGrid object only contains decomposable dimensions. The minimum rank for a
DistGrid object is 1. A maximum rank does not exist for DistGrid objects, 
however, ranks greater than 7 may lead to difficulties with respect to the
Fortran API of higher classes based on DistGrid. The rank of a DELayout object
contained within a DistGrid object must be equal to the DistGrid rank. Higher
class objects that use the DistGrid, such as an Array object, may be of
different rank than the associated DistGrid object. The higher class object
will hold the mapping information between its dimensions and the DistGrid
dimensions.

<P>

<H2><A NAME="SECTION050122000000000000000">
31.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION050122100000000000000"></A>
<A NAME="const:distgridmatch"></A>
<BR>
31.2.1 ESMF_DISTGRIDMATCH
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
Indicates the level to which two DistGrid variables match.

<P>
The type of this flag is:

<P>
<TT>type(ESMF_DistGridMatch_Flag)</TT>

<P>
The valid values are:
<DL>
<DT><STRONG>ESMF_DISTGRIDMATCH_INVALID:</STRONG></DT>
<DD>Indicates a non-valid matching level.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_NONE:</STRONG></DT>
<DD>The lowest valid level of DistGrid matching. 
  This indicates that the DistGrid variables don't match at any of the higher
  levels.
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_EXACT:</STRONG></DT>
<DD>All the DistGrid pieces except the name
  match between the two DistGrid variables. 
</DD>
<DT><STRONG>ESMF_DISTGRIDMATCH_ALIAS:</STRONG></DT>
<DD>Both DistGrid variables are aliases to the
  exact same DistGrid object in memory.
</DD>
</DL>

<P>

<H2><A NAME="SECTION050123000000000000000">
31.3 Use and Examples</A>
</H2>

<P>
The following examples demonstrate how to create, use and destroy DistGrid objects. In order to produce complete and valid DistGrid objects all of the <TT>ESMF_DistGridCreate()</TT> calls require to be called in unison i.e. on <EM>all</EM> PETs of a component with a complete set of valid arguments.

<P>

<P>

<P>

<H3><A NAME="SECTION050123100000000000000">
31.3.1 Single tile DistGrid with regular decomposition</A>
</H3>

<P>
The minimum information required to create an <TT>ESMF_DistGrid</TT> object
   for a single tile with default decomposition are the corners of the tile
   in index space. The following call will create a 1D DistGrid for a 
   1D index space tile with elements from 1 through 1000. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1/), maxIndex=(/1000/), rc=rc)
</PRE>

<P>
A default DELayout with 1 DE per PET will be created during 
   <TT>ESMF_DistGridCreate()</TT>. The 1000 elements of the specified 1D tile will
   then be block decomposed across the available DEs, i.e. across all PETs. 
   Hence, for 4 PETs the (min) <IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$\sim$"> (max) corners of the DE-local LR regions
   will be:
   <PRE>
     DE 0 - (1) ~ (250)
     DE 1 - (251) ~ (500)
     DE 2 - (501) ~ (750)
     DE 3 - (751) ~ (1000)
</PRE>

<P>
DistGrids with rank &gt; 1 can also be created with default decompositions,
   specifying only the corners of the tile. The following will create a
   2D DistGrid for a 5x5 tile with default decomposition. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), rc=rc)
</PRE>

<P>
The default decomposition for a DistGrid of rank <IMG
 WIDTH="21" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img80.png"
 ALT="$N$"> will be <!-- MATH
 $(nDEs \times 1
   \times ... \times 1)$
 -->
<IMG
 WIDTH="149" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img81.png"
 ALT="$ (nDEs \times 1
\times ... \times 1) $">, where <IMG
 WIDTH="49" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img82.png"
 ALT="$nDEs$"> is the number of DEs in the DELayout
   and there are <IMG
 WIDTH="48" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img83.png"
 ALT="$N-1$"> factors of <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img53.png"
 ALT="$1$">. For the 2D example above this means
   a <IMG
 WIDTH="41" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img84.png"
 ALT="$4 \times 1$"> regular decomposition if executed on 4 PETs and will result
   in the following DE-local LR regions:
   <PRE>
     DE 0 - (1,1) ~ (2,5)
     DE 1 - (3,1) ~ (3,5)
     DE 2 - (4,1) ~ (4,5)
     DE 3 - (5,1) ~ (5,5)
</PRE>

<P>
In many cases the default decomposition will not suffice for higher rank
   DistGrids (rank &gt; 1). For this reason a decomposition descriptor 
   <TT>regDecomp</TT> argument is available during <TT>ESMF_DistGridCreate()</TT>. The
   following call creates a DistGrid on the same 2D tile as before, but now with
   a user specified regular decomposition of <!-- MATH
 $2 \times 3 = 6$
 -->
<IMG
 WIDTH="71" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img85.png"
 ALT="$2 \times 3 = 6 $"> DEs. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
The default DE labeling sequence follows column major order for the
   <TT>regDecomp</TT> argument:
   <PRE>
     -----------&gt; 2nd dimension
     |  0  2  4
     |  1  3  5
     v
    1st dimension
</PRE>

<P>
By default grid points along all dimensions are homogeneously divided between
   the DEs. The maximum element count difference between DEs along any dimension
   is 1. The (min) <IMG
 WIDTH="18" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img73.png"
 ALT="$\sim$"> (max) corners of the DE-local LR domains of the above
   example are as follows:
   <PRE>
     DE 0 - (1,1) ~ (3,2)
     DE 1 - (4,1) ~ (5,2)
     DE 2 - (1,3) ~ (3,4)
     DE 3 - (4,3) ~ (5,4)
     DE 4 - (1,5) ~ (3,5)
     DE 5 - (4,5) ~ (5,5)
</PRE>

<P>
The specifics of the tile decomposition into DE-local LR domains can be
   modified by the optional <TT>decompflag</TT> argument. The following line shows
   how this argument is used to keep ESMF's default decomposition in the first
   dimension but move extra grid points of the second dimension to the last DEs
   in that direction. Extra elements occur if the number of DEs for a certain
   dimension does not evenly divide its extent. In this example there are
   2 extra grid points for the second dimension because its extent is 5 but there
   are 3 DEs along this index space axis. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), decompflag=(/ESMF_DECOMP_DEFAULT, &amp;
    ESMF_DECOMP_RESTLAST/), rc=rc)
</PRE>

<P>
Now DE 4 and DE 5 will hold the extra elements along the 2nd dimension.
   <PRE>
     DE 0 - (1,1) ~ (3,1)
     DE 1 - (4,1) ~ (5,1)
     DE 2 - (1,2) ~ (3,2)
     DE 3 - (4,2) ~ (5,2)
     DE 4 - (1,3) ~ (3,5)
     DE 5 - (4,3) ~ (5,5)
</PRE>

<P>
An alternative way of indicating the DE-local LR regions is to list the 
   index space coordinate as given by the associated DistGrid tile for each
   dimension. For this 2D example there are two lists (dim 1) / (dim 2) for each
   DE:
   <PRE>
     DE 0 - (1,2,3) / (1)
     DE 1 - (4,5)   / (1)
     DE 2 - (1,2,3) / (2)
     DE 3 - (4,5)   / (2)
     DE 4 - (1,2,3) / (3,4,5)
     DE 5 - (4,5)   / (3,4,5)
</PRE>

<P>
Information about DE-local LR regions in the latter format can be obtained 
   from the DistGrid object by use of <TT>ESMF_DistGridGet()</TT> methods:

<P>
<PRE>
  allocate(dimExtent(2, 0:5)) ! (dimCount, deCount)
  call ESMF_DistGridGet(distgrid, delayout=delayout, &amp;
    indexCountPDe=dimExtent, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  call ESMF_DELayoutGet(delayout, localDeCount=localDeCount, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  allocate(localDeList(0:localDeCount-1))
  call ESMF_DELayoutGet(delayout, localDeList=localDeList, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  do localDe=0, localDeCount-1
    de = localDeList(localDe)
    do dim=1, 2
      allocate(localIndexList(dimExtent(dim, de))) ! allocate list 
                                                   ! to hold indices
      call ESMF_DistGridGet(distgrid, localDe=localDe, dim=dim, &amp;
        indexList=localIndexList, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
      print *, "local DE ", localDe," - DE ",de, &amp;
        " localIndexList along dim=", dim," :: ", localIndexList
      deallocate(localIndexList)
    enddo
  enddo
  deallocate(localDeList)
  deallocate(dimExtent)
</PRE>

<P>
The advantage of the <TT>localIndexList</TT> format over the min-/max-corner 
   format is that it can be used directly for DE-local to tile index 
   dereferencing. Furthermore the <TT>localIndexList</TT> allows to express very
   general decompositions such as the cyclic decompositions in the first
   dimension generated by the following call: 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), &amp;
    decompflag=(/ESMF_DECOMP_CYCLIC,ESMF_DECOMP_RESTLAST/), rc=rc)
</PRE>

<P>
with decomposition:
   <PRE>
     DE 0 - (1,3,5) / (1)
     DE 1 - (2,4)   / (1)
     DE 2 - (1,3,5) / (2)
     DE 3 - (2,4)   / (2)
     DE 4 - (1,3,5) / (3,4,5)
     DE 5 - (2,4)   / (3,4,5)
</PRE>

<P>
Finally, a DistGrid object is destroyed by calling 

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050123200000000000000">
31.3.2 DistGrid and DELayout</A>
</H3>

<P>
The examples of this section use the 2D DistGrid of the previous section 
   to show the interplay between DistGrid and DELayout. By default, i.e.
   without specifying the <TT>delayout</TT> argument, a DELayout will be created
   during DistGrid creation that provides as many DEs as the DistGrid
   object requires. The implicit call to <TT>ESMF_DELayoutCreate()</TT> is issued
   with a fixed number of DEs and default settings in all other aspects. The
   resulting DE to PET mapping depends on the number of PETs of the current VM
   context. Assuming 6 PETs in the VM 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), rc=rc)
</PRE>

<P>
will result in the following domain decomposition in terms of DEs
   <PRE>
     0  2  4
     1  3  5
</PRE>
   and their layout or distribution over the available PETs:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 1
     DE 2  -&gt; PET 2
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 4
     DE 5  -&gt; PET 5
</PRE>

<P>
Running the same example on a 4 PET VM will not change the domain 
   decomposition into 6 DEs as specified by
   <PRE>
     0  2  4
     1  3  5
</PRE>
   but the layout across PETs will now contain multiple DE-to-PET mapping with 
   default cyclic distribution:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 1
     DE 2  -&gt; PET 2
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 0
     DE 5  -&gt; PET 1
</PRE>

<P>
Sometimes it may be desirable for performance tuning to construct a DELayout
   with specific characteristics. For instance, if the 6 PETs of the above 
   example are running on 3 nodes of a dual-SMP node cluster and there is a 
   higher communication load along the first dimension of the model than along 
   the second dimension it would be sensible to place DEs according to this 
   knowledge. 

<P>
The following example first creates a DELayout 
   with 6 DEs where groups of 2 DEs are to be in fast connection. This DELayout 
   is then used to create a DistGrid. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=6, deGrouping=(/(i/2,i=0,5)/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), delayout=delayout, rc=rc)
</PRE>

<P>
This will ensure a distribution of DEs across the cluster resource 
   in the following way:
   <PRE>
     0   2   4
     1   3   5
    SMP SMP SMP
</PRE>

<P>
The interplay between DistGrid and DELayout may at first seem complicated.
   The simple but important rule to understand is that DistGrid describes a 
   domain decomposition and each domain is labeled with a DE number. The DELayout
   describes how these DEs are laid out over the compute resources of the VM, 
   i.e. PETs. The DEs are purely logical elements of decomposition and may be 
   relabeled to fit the algorithm or legacy code better. The following 
   example demonstrates this by describing the exact same distribution of the 
   domain data across the fictitious cluster of SMP-nodes with a different 
   choice of DE labeling: 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(deCount=6, deGrouping=(/(mod(i,3),i=0,5)/), &amp;
    rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), deLabelList=(/0,3,1,4,2,5/), delayout=delayout, rc=rc)
</PRE>

<P>
Here the <TT>deLabelList</TT> argument changes the default DE label sequence from
   column major to row major. The DELayout compensates for this change in DE
   labeling by changing the <TT>deGrouping</TT> argument to map the first dimension
   to SMP nodes as before. The decomposition and layout now looks as follows:
   <PRE>
     0   1   2
     3   4   5
    SMP SMP SMP
</PRE>

<P>
Finally, in order to achieve a completely user-defined distribution of the
   domain data across the PETs of the VM a DELayout may be created from a
   <TT>petMap</TT> before using it in the creation of a DistGrid. If for
   instance the desired distribution of a 2 x 3 decomposition puts the DEs of 
   the first row onto 3 separate PETs (PET 0, 1, 2) and groups the DEs of 
   the second row onto PET 3 a <TT>petMap</TT> must first be setup that
   takes the DE labeling of the DistGrid into account.The following lines of 
   code result in the desired distribution using column major DE labeling by 
   first create a DELayout and then using it in the DistGrid creation. 

<P>
<PRE>
  delayout = ESMF_DELayoutCreate(petMap=(/0,3,1,3,2,3/), rc=rc)
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    regDecomp=(/2,3/), delayout=delayout, rc=rc)
</PRE>

<P>
This decomposes the global domain into
   <PRE>
     0   2   4
     1   3   5
</PRE>
   and associates the DEs to the following PETs:
   <PRE>
     DE 0  -&gt; PET 0
     DE 1  -&gt; PET 3
     DE 2  -&gt; PET 1
     DE 3  -&gt; PET 3
     DE 4  -&gt; PET 2
     DE 5  -&gt; PET 3
</PRE> 

<P>

<H3><A NAME="SECTION050123300000000000000">
31.3.3 Single tile DistGrid with decomposition by DE blocks</A>
</H3>

<P>
The examples of the previous sections showed how DistGrid objects with
   regular decompositions are created. However, in some cases a regular 
   decomposition may not be specific enough. The following example shows how 
   the <TT>deBlockList</TT> argument is used to create a DistGrid object with 
   completely user-defined decomposition.

<P>
A single 5x5 LR domain is to be decomposed into 6 DEs. To this end a list is
   constructed that holds the min and max corners of all six DE
   LR blocks. The DE-local LR blocks are arranged as to cover the whole tile 
   domain without overlap. 

<P>
<PRE>
  allocate(deBlockList(2, 2, 6))  ! (dimCount, 2, deCount)
  deBlockList(:,1,1) = (/1,1/)  ! minIndex  1st deBlock
  deBlockList(:,2,1) = (/3,2/)  ! maxIndex  1st deBlock
  deBlockList(:,1,2) = (/4,1/)  ! minIndex  2nd deBlock
  deBlockList(:,2,2) = (/5,2/)  ! maxIndex  2nd deBlock
  deBlockList(:,1,3) = (/1,3/)
  deBlockList(:,2,3) = (/2,4/)
  deBlockList(:,1,4) = (/3,3/)
  deBlockList(:,2,4) = (/5,4/)
  deBlockList(:,1,5) = (/1,5/)
  deBlockList(:,2,5) = (/3,5/)
  deBlockList(:,1,6) = (/4,5/)  ! minIndex  6th deBlock
  deBlockList(:,2,6) = (/5,5/)  ! maxInbex  6th deBlock
</PRE>

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    deBlockList=deBlockList, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION050123400000000000000">
31.3.4 Single tile DistGrid with periodic boundaries</A>
</H3>

<P>
By default the edges of all tiles have solid wall boundary conditions. 
   Periodic boundary conditions can be imposed by specifying connections between
   tiles. For the single LR domain of the last section periodic boundaries 
   along the first dimension are imposed by adding a <TT>connectionList</TT> 
   argument with only one element to the create call. 

<P>
<PRE>
  allocate(connectionList(1))
</PRE>

<P>
The connection element holds information about <TT>tileIndex_A</TT>, 
   <TT>tileIndex_B</TT>, <TT>positionVector</TT>, and <TT>orientationVector/)</TT>. 

<P>
<PRE>
  call ESMF_DistGridConnectionSet(connection=connectionList(1), &amp;
     tileIndexA=1, tileIndexB=1, &amp;
     positionVector=(/5, 0/), &amp;
     orientationVector=(/1, 2/), &amp;
     rc=rc)
</PRE>

<P>
The <TT>tileIndexA</TT> and <TT>tileIndexB</TT> arguments specify that this is a
   connection within tile 1. The <TT>positionVector</TT> indicates that there is no
   offset between tileB and tileA along the second dimension, but there is
   an offset of 5 along the first dimension (which in this case is the length of
   dimension 1). This aligns tileB (which is tile 1) right next to tileA
   (which is also tile 1).

<P>
The <TT>orientationVector</TT> fixes the orientation of the tileB index space to
   be the same as the orientation of tileA (it maps index 1 of tileA to index 1
   of tileB and the same for index 2). The <TT>orientationVector</TT> could have
   been omitted in this case which corresponds to the default orientation.

<P>
The <TT>connectionList</TT> can now be used to create a <TT>DistGrid</TT> object 
   with the desired boundary conditions. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndex=(/1,1/), maxIndex=(/5,5/), &amp;
    deBlockList=deBlockList, connectionList=connectionList, rc=rc)
</PRE>

<P>
<PRE>
  deallocate(connectionList)
</PRE>

<P>
This closes the tile along the first dimension on itself, thus imposing
   periodic boundaries along this direction. 

<P>

<H3><A NAME="SECTION050123500000000000000">
31.3.5 2D tilework DistGrid with regular decomposition</A>
</H3>

<P>
Creating a DistGrid from a list of LR domains is a straight forward
   extension of the case with a single LR domain. The first four 
   arguments of <TT>ESMF_DistGridCreate()</TT> are promoted to rank 2, the 
   second dimension being the tile count index.

<P>
The following 2D tilework domain consisting of 3 LR tiles will 
   be used in the examples of this section:
   <PRE>
     ----------------------------------------&gt; 2nd dim
     |
     |                   (1,11)-----(1,20)
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   |               | 
     |                   (10,11)---(10,20)
     |  (11,1)----(11,10)(11,11)---(11,20)
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  |               ||               |
     |  (20,1)----(20,10)(20,11)---(20,20)
     |
     |
     v
    1st dim
</PRE>

<P>
The first step in creating a tilework global domain is to construct the
   <TT>minIndex</TT> and <TT>maxIndex</TT> arrays. 

<P>
<PRE>
  allocate(minIndex(2,3))    ! (dimCount, number of tiles)
  allocate(maxIndex(2,3))    ! (dimCount, number of tiles)
  minIndex(:,1) = (/11,1/)
  maxIndex(:,1) = (/20,10/)
  minIndex(:,2) = (/11,11/)
  maxIndex(:,2) = (/20,20/)
  minIndex(:,3) = (/1,11/)
  maxIndex(:,3) = (/10,20/)
</PRE>

<P>
Next the regular decomposition for each tile is set up in the
   <TT>regDecomp</TT> array. In this example each tile is associated with a
   single DE. 

<P>
<PRE>
  allocate(regDecomp(2,3))    ! (dimCount, number of tiles)
  regDecomp(:,1) = (/1,1/)    ! one DE
  regDecomp(:,2) = (/1,1/)    ! one DE
  regDecomp(:,3) = (/1,1/)    ! one DE
</PRE>

<P>
Finally the DistGrid can be created by calling 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndex, &amp;
    maxIndexPTile=maxIndex, regDecompPTile=regDecomp, rc=rc)
</PRE>

<P>
The default DE labeling sequence is identical to the tile labeling sequence
   and follows the sequence in which the tiles are defined during the create
   call. However, DE labels start at 0 whereas tile labels start at 1. In this 
   case the DE labels look as:
   <PRE>
           2
       0   1
</PRE>

<P>
Each tile can be decomposed differently into DEs. The default DE labeling 
   follows the column major order for each tile. This is demonstrated in the
   following case where the tilework global domain is decomposed into 9 DEs, 

<P>
<PRE>
  regDecomp(:,1) = (/2,2/)    ! 4 DEs
  regDecomp(:,2) = (/1,3/)    ! 3 DEs
  regDecomp(:,3) = (/2,1/)    ! 2 DEs
  
  distgrid = ESMF_DistGridCreate(minIndexPTile=minIndex, &amp;
    maxIndexPTile=maxIndex, regDecompPTile=regDecomp, rc=rc)
</PRE>

<P>
resulting in the following decomposition:
   <PRE>
             +-------+
             |   7   |
             |       |
             |   8   |
     +-------+-------+
     | 0   2 |       |
     |       | 4 5 6 |
     | 1   3 |       |
     +-------+-------+
</PRE>

<P>
<PRE>
     DE 0 - (11,1)  ~ (15,5)
     DE 1 - (16,1)  ~ (20,5)
     DE 2 - (11,6)  ~ (15,10)
     DE 3 - (16,6)  ~ (20,10)
     DE 4 - (11,11) ~ (20,14)
     DE 5 - (11,15) ~ (20,17)
     DE 6 - (11,18) ~ (20,20)
     DE 7 - (1,11)  ~ (5,20)
     DE 8 - (6,11)  ~ (10,20)
</PRE>

<P>
The <TT>decompflag</TT> and <TT>deLabelList</TT> arguments can be used much like
   in the single LR domain case to overwrite the default grid decomposition 
   (per tile) and to change the overall DE labeling sequence, respectively. 

<P>

<H3><A NAME="SECTION050123600000000000000"></A>
   <A NAME="DistGrid:ArbitrarySeqInd"></A>
<BR>
31.3.6 Arbitrary DistGrids with user-supplied sequence indices
</H3>

<P>
The DistGrid class supports the communication methods of higher classes, 
   like Array and Field, by associating a unique <EM>sequence index</EM> with each
   DistGrid index tuple. This sequence index can be used to address every Array
   or Field element. By default, the DistGrid does not actually generate and
   store the sequence index of each element. Instead a default sequence through
   the elements is implemented in the DistGrid code. This default sequence 
   is used internally when needed.

<P>
The DistGrid class provides two <TT>ESMF_DistGridCreate()</TT> calls that 
   allow the user to specify arbitrary sequence indices, overriding the use of
   the default sequence index scheme. The user sequence indices are passed to
   the DistGrid in form of 1d Fortran arrays, one array on each PET. The local
   size of this array on each PET determines the number of DistGrid elements on
   the PET. The supplied sequence indices must be unique across all PETs. 

<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet ! initialize unique 
                                                   ! seq. indices
  enddo
</PRE>

<P>
A default DELayout will be created automatically during 
   <TT>ESMF_DistGridCreate()</TT>, associating 1 DE per PET. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, rc=rc)
</PRE>

<P>
The user provided sequence index array can be deallocated once it has
   been used. 

<P>
<PRE>
  deallocate(arbSeqIndexList)
</PRE>

<P>
The <TT>distgrid</TT> object can be used just like any other DistGrid object.
   The "arbitrary" nature of <TT>distgrid</TT> will only become visible during
   Array or Field communication methods, where source and destination objects
   map elements according to the sequence indices provided by the associated
   DistGrid objects. 

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>
The second <TT>ESMF_DistGridCreate()</TT> call, that accepts the 
   <TT>arbSeqIndexList</TT> argument, allows the user to specify additional,
   regular DistGrid dimensions. These additional DistGrid dimensions are not
   decomposed across DEs, but instead are simply "added" or "multiplied" to the
   1D arbitrary dimension.

<P>
The same <TT>arbSeqIndexList</TT> array as before is used to define the 
   user supplied sequence indices. 

<P>
<PRE>
  allocate(arbSeqIndexList(10))   ! each PET will have 10 elements
  
  do i=1, 10
    arbSeqIndexList(i) = (i-1)*petCount + localPet  ! initialize unique 
                                                    ! seq. indices
  enddo
</PRE>

<P>
The additional DistGrid dimensions are specified in the usual manner using
   <TT>minIndex</TT> and <TT>maxIndex</TT> arguments. The <TT>dimCount</TT> of the
   resulting DistGrid is the size of the <TT>minIndex</TT> and <TT>maxIndex</TT>
   arguments plus 1 for the arbitrary dimension. The <TT>arbDim</TT> argument is
   used to indicate which or the resulting DistGrid dimensions
   is associated with the arbitrary sequence indices provided by the user. 

<P>
<PRE>
  distgrid = ESMF_DistGridCreate(arbSeqIndexList=arbSeqIndexList, &amp;
    arbDim=1, minIndexPTile=(/1,1/), maxIndexPTile=(/5,7/), rc=rc)
</PRE>

<P>
<PRE>
  deallocate(arbSeqIndexList)
</PRE>

<P>
<PRE>
  call ESMF_DistGridDestroy(distgrid, rc=rc)
</PRE>

<P>

<P>

<H2><A NAME="SECTION050124000000000000000">
31.4 Restrictions and Future Work</A>
</H2>

<P>

<UL>
<LI>Multi-tile DistGrids from deBlockList are not yet supported.
</LI>
<LI>The fastAxis feature has not been implemented yet.
</LI>
</UL>

<P>

<H2><A NAME="SECTION050125000000000000000">
31.5 Design and Implementation Notes</A>
</H2>

<P>
<EM>This section will be updated as the implementation of the DistGrid class
nears completion.</EM>

<P>

<H2><A NAME="SECTION050126000000000000000">
31.6 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050126100000000000000">
31.6.1 ESMF_DistGridAssignment(=) - DistGrid assignment</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>     interface assignment(=)
     distgrid1 = distgrid2
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid) :: distgrid1
     type(ESMF_DistGrid) :: distgrid2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Assign distgrid1 as an alias to the same ESMF DistGrid object in memory
     as distgrid2. If distgrid2 is invalid, then distgrid1 will be equally
     invalid after the assignment.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the left hand side of the assignment.
     
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the right hand side of the assignment.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050126200000000000000">
31.6.2 ESMF_DistGridOperator(==) - DistGrid equality operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(==)
     if (distgrid1 == distgrid2) then ... endif
               OR
     result = (distgrid1 == distgrid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid), intent(in) :: distgrid1
     type(ESMF_DistGrid), intent(in) :: distgrid2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether distgrid1 and distgrid2 are valid aliases to the same ESMF
     DistGrid object in memory. For a more general comparison of two 
     ESMF DistGrids, going beyond the simple alias test, the 
     <TT>ESMF_DistGridMatch()</TT> function (not yet fully implemented) must 
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the left hand side of the equality
       operation.
     
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the right hand side of the equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050126300000000000000">
31.6.3 ESMF_DistGridOperator(/=) - DistGrid not equal operator</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   interface operator(/=)
     if (distgrid1 /= distgrid2) then ... endif
               OR
     result = (distgrid1 /= distgrid2)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: result
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid), intent(in) :: distgrid1
     type(ESMF_DistGrid), intent(in) :: distgrid2
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Test whether distgrid1 and distgrid2 are <I>not</I> valid aliases to the
     same ESMF DistGrid object in memory. For a more general comparison of two
     ESMF DistGrids, going beyond the simple alias test, the
     <TT>ESMF_DistGridMatch()</TT> function (not yet fully implemented) must 
     be used.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the left hand side of the non-equality
       operation.
     
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD>The <TT>ESMF_DistGrid</TT> object on the right hand side of the non-equality
       operation.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050126400000000000000">
31.6.4 ESMF_DistGridCreate - Create DistGrid object from DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDG(distgrid, &amp;
     firstExtra, lastExtra, indexflag, connectionList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),           intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, target,               intent(in),  optional :: firstExtra(:)
     integer, target,               intent(in),  optional :: lastExtra(:)
     type(ESMF_Index_Flag),         intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection), intent(in),  optional :: connectionList(:)
     integer,                       intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDG
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new DistGrid from an existing DistGrid, keeping the decomposition
       unchanged. The <TT>firstExtra</TT> and <TT>lastExtra</TT> arguments allow extra
       elements to be added at the first/last edge DE in each dimension. The 
       method also allows the <TT>indexflag</TT> to be set. Further, if the 
       <TT>connectionList</TT> argument is provided it will be used to set 
       connections in the newly created DistGrid, otherwise the connections of
       the incoming DistGrid will be used.
       If neither <TT>firstExtra</TT>, <TT>lastExtra</TT>, <TT>indexflag</TT>, nor 
       <TT>connectionList</TT> arguments are specified, the method reduces to a 
       deep copy of the incoming DistGrid object.

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Incoming DistGrid object.
       
</DD>
<DT><STRONG>[firstExtra]</STRONG></DT>
<DD>Extra elements on the edge of the first DEs along each dimension.
            The default is a zero vector.
       
</DD>
<DT><STRONG>[lastExtra]</STRONG></DT>
<DD>Extra elements on the edge of the last DEs along each dimension.
            The default is a zero vector.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are to be interpreted to form a global
            index space or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node2.html#const:indexflag">9.24</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="node5.html#api:DistGridConnectionSet">31.7.1</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050126500000000000000">
31.6.5 ESMF_DistGridCreate - Create DistGrid object from DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDGT(distgrid, firstExtraPTile, &amp;
     lastExtraPTile, indexflag, connectionList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),        intent(in)            :: distgrid
     integer, target,            intent(in)            :: firstExtraPTile(:,:)
     integer, target,            intent(in)            :: lastExtraPTile(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_Index_Flag),      intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection), intent(in),  optional :: connectionList(:)
     integer,                    intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDGT
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create a new DistGrid from an existing DistGrid, keeping the decomposition
       unchanged. The <TT>firstExtraPTile</TT> and <TT>lastExtraPTile</TT> arguments allow extra
       elements to be added at the first/last edge DE in each dimension. The 
       method also allows the <TT>indexflag</TT> to be set. Further, if the 
       <TT>connectionList</TT> argument provided in it will be used to set 
       connections in the newly created DistGrid, otherwise the connections of
       the incoming DistGrid will be used.
       If neither <TT>firstExtraPTile</TT>, <TT>lastExtraPTile</TT>, <TT>indexflag</TT>, nor 
       <TT>connectionList</TT> arguments are specified, the method reduces to a 
       deep copy of the incoming DistGrid object.

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Incoming DistGrid object.
       
</DD>
<DT><STRONG>firstExtraPTile</STRONG></DT>
<DD>Extra elements on the edge of the first DEs along each dimension.
       
</DD>
<DT><STRONG>lastExtraPTile</STRONG></DT>
<DD>Extra elements on the edge of the last DEs along each dimension.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are to be interpreted to form a global
            index space or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node2.html#const:indexflag">9.24</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="node5.html#api:DistGridConnectionSet">31.7.1</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050126600000000000000">
31.6.6 ESMF_DistGridCreate - Create DistGrid object with regular decomposition</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateRD(minIndex, maxIndex, regDecomp, &amp;
     decompflag, regDecompFirstExtra, regDecompLastExtra, deLabelList, &amp;
     indexflag, connectionList, delayout, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                   intent(in)            :: minIndex(:)
     integer,                   intent(in)            :: maxIndex(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,      target,      intent(in),  optional :: regDecomp(:)
     type(ESMF_Decomp_Flag), target, intent(in),  optional :: decompflag(:)
     integer,      target,      intent(in),  optional :: regDecompFirstExtra(:)
     integer,      target,      intent(in),  optional :: regDecompLastExtra(:)
     integer,      target,      intent(in),  optional :: deLabelList(:)
     type(ESMF_Index_Flag),     intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection),  intent(in),  optional :: connectionList(:)
     type(ESMF_DELayout),       intent(in),  optional :: delayout
     type(ESMF_VM),             intent(in),  optional :: vm
     integer,                   intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateRD
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from a single logically rectangular (LR) 
       tile with regular decomposition. A regular decomposition is of the same 
       rank as the tile and decomposes each dimension into a fixed number of 
       DEs. A regular decomposition of a single tile is expressed by a 
       single <TT>regDecomp</TT> list of DE counts in each dimension.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Global coordinate tuple of the lower corner of the tile.
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Global coordinate tuple of the upper corner of the tile.
       
</DD>
<DT><STRONG>[regDecomp]</STRONG></DT>
<DD>List of DE counts for each dimension. The default decomposition will
            be <TT>deCount</TT><!-- MATH
 $\times 1 \times ... \times 1$
 -->
<IMG
 WIDTH="87" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img86.png"
 ALT="$ \times 1 \times ... \times 1$">. The value of
            <TT>deCount</TT> for a default DELayout equals <TT>petCount</TT>, i.e. the
            default decomposition will be into as many DEs as there are 
            PETs and the distribution will be 1 DE per PET.
       
</DD>
<DT><STRONG>[decompflag]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of the
            tile is to be divided between the DEs. The default setting
            is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions. See section
            <A HREF="node2.html#const:decompflag">9.13</A> for a list of valid decomposition options.
       
</DD>
<DT><STRONG>[regDecompFirstExtra]</STRONG></DT>
<DD>Extra elements on the first DEs along each dimension in a regular
            decomposition. The default is a zero vector.
       
</DD>
<DT><STRONG>[regDecompLastExtra]</STRONG></DT>
<DD>Extra elements on the last DEs along each dimension in a regular
            decomposition. The default is a zero vector.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecomp</TT>
            argument.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are to be interpreted to form a global
            index space or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node2.html#const:indexflag">9.24</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="node5.html#api:DistGridConnectionSet">31.7.1</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with the correct number of DEs. If
            a DELayout object is specified its number of DEs must match the 
            number indicated by <TT>regDecomp</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050126700000000000000">
31.6.7 ESMF_DistGridCreate - Create DistGrid object with DE blocks</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDB(minIndex, maxIndex, deBlockList, &amp;
     deLabelList, indexflag, connectionList, delayout, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,                       intent(in)            :: minIndex(:)
     integer,                       intent(in)            :: maxIndex(:)
     integer,                       intent(in)            :: deBlockList(:,:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                       intent(in),  optional :: deLabelList(:)
     type(ESMF_Index_Flag),         intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection), intent(in),  optional ::connectionList(:)
     type(ESMF_DELayout),           intent(in),  optional :: delayout
     type(ESMF_VM),                 intent(in),  optional :: vm
     integer,                       intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDB
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from a single logically rectangular (LR) 
       tile with decomposition specified by <TT>deBlockList</TT>.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Global coordinate tuple of the lower corner of the tile.
       
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Global coordinate tuple of the upper corner of the tile.
       
</DD>
<DT><STRONG>deBlockList</STRONG></DT>
<DD>List of DE-local LR blocks. The third index of <TT>deBlockList</TT>
            steps through the deBlock elements, which are defined by the first
            two indices. The first index must be of size <TT>dimCount</TT> and the 
            second index must be of size 2. Each 2D element of <TT>deBlockList</TT>
            defined by the first two indices hold the following information.
            <PRE>
                     +---------------------------------------&gt; 2nd index
                     |    1               2           
                     | 1  minIndex(1)    maxIndex(1)
                     | 2  minIndex(2)    maxIndex(2)
                     | .  minIndex(.)    maxIndex(.)
                     | .
                     v
                    1st index
</PRE>
            It is required that there be no overlap between the LR segments
            defined by deBlockList.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecomp</TT>
            argument.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are to be interpreted to form a global
            index space or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node2.html#const:indexflag">9.24</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="node5.html#api:DistGridConnectionSet">31.7.1</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with the correct number of DEs. If
            a DELayout object is specified its number of DEs must match the 
            number indicated by <TT>regDecomp</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050126800000000000000">
31.6.8 ESMF_DistGridCreate - Create DistGrid object from tilework with regular decomposition</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateRDT(minIndexPTile, maxIndexPTile, &amp;
     regDecompPTile, decompflagPTile, regDecompFirstExtraPTile,&amp;
     regDecompLastExtraPTile, deLabelList, indexflag, connectionList, &amp;
     delayout, vm, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,             intent(in)            :: minIndexPTile(:,:)
     integer,             intent(in)            :: maxIndexPTile(:,:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(in),  optional :: regDecompPTile(:,:)
     type(ESMF_Decomp_Flag), target, intent(in),  optional ::decompflagPTile(:,:)
     integer,     target, intent(in),  optional :: regDecompFirstExtraPTile(:,:)
     integer,     target, intent(in),  optional :: regDecompLastExtraPTile(:,:)
     integer,             intent(in),  optional :: deLabelList(:)
     type(ESMF_Index_Flag), intent(in),  optional :: indexflag
     type(ESMF_DistGridConnection), intent(in),  optional :: connectionList(:)
     type(ESMF_DELayout), intent(in),  optional :: delayout
     type(ESMF_VM),       intent(in),  optional :: vm
     integer,             intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateRDT
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> from a tilework of logically 
       rectangular (LR) tiles with regular decomposition. A regular
       decomposition is of the same rank as the tile and decomposes
       each dimension into a fixed number of DEs. A regular decomposition of a
       tilework of tiles is expressed by a list of DE count vectors, one
       vector for each tile. Each vector contained in the 
       <TT>regDecompPTile</TT> argument ascribes DE counts for each dimension. It is 
       erroneous to provide more tiles than there are DEs.

<P>
The arguments are:
       <DL>
<DT><STRONG>minIndexPTile</STRONG></DT>
<DD>The first index provides the global coordinate tuple of the lower 
            corner of a tile. The second index indicates the tile number.
       
</DD>
<DT><STRONG>maxIndexPTile</STRONG></DT>
<DD>The first index provides the global coordinate tuple of the upper
            corner of a tile. The second index indicates the tile number.
       
</DD>
<DT><STRONG>[regDecompPTile]</STRONG></DT>
<DD>List of DE counts for each dimension. The second 
            index indicates the tile number. The default decomposition will
            be <TT>deCount</TT><!-- MATH
 $\times 1 \times ... \times 1$
 -->
<IMG
 WIDTH="87" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img86.png"
 ALT="$ \times 1 \times ... \times 1$">. The value of
            <TT>deCount</TT> for a default DELayout equals <TT>petCount</TT>, i.e. the
            default decomposition will be into as many DEs as there are 
            PETs and the distribution will be 1 DE per PET.
       
</DD>
<DT><STRONG>[decompflagPTile]</STRONG></DT>
<DD>List of decomposition flags indicating how each dimension of each
            tile is to be divided between the DEs. The default setting
            is <TT>ESMF_DECOMP_BALANCED</TT> in all dimensions for all tiles. 
            See section <A HREF="node2.html#const:decompflag">9.13</A> for a list of valid decomposition
            flag options. The second index indicates the tile number.
       
</DD>
<DT><STRONG>[regDecompFirstExtraPTile]</STRONG></DT>
<DD>Extra elements on the first DEs along each dimension in a regular
            decomposition. The default is a zero vector. The second index 
            indicates the tile number.
       
</DD>
<DT><STRONG>[regDecompLastExtraPTile]</STRONG></DT>
<DD>Extra elements on the last DEs along each dimension in a regular
            decomposition. The default is a zero vector. The second index 
            indicates the tile number.
       
</DD>
<DT><STRONG>[deLabelList]</STRONG></DT>
<DD>List assigning DE labels to the default sequence of DEs. The default
            sequence is given by the column major order of the <TT>regDecompPTile</TT>
            elements in the sequence as they appear following the tile index.
       
</DD>
<DT><STRONG>[indexflag]</STRONG></DT>
<DD>Indicates whether the indices provided by the <TT>minIndex</TT> and
            <TT>maxIndex</TT> arguments are to be interpreted to form a global
            index space or not. The default is <TT>ESMF_INDEX_DELOCAL</TT>.
            See section <A HREF="node2.html#const:indexflag">9.24</A> for a complete list of options.
       
</DD>
<DT><STRONG>[connectionList]</STRONG></DT>
<DD>List of <TT>ESMF_DistGridConnection</TT> objects, defining connections
            between DistGrid tiles in index space.
            See section <A HREF="node5.html#api:DistGridConnectionSet">31.7.1</A> for the associated Set()
            method.
       
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD>Optional <TT>ESMF_DELayout</TT> object to be used. By default a new
            DELayout object will be created with the correct number of DEs. If
            a DELayout object is specified its number of DEs must match the 
            number indicated by <TT>regDecompPTile</TT>.
       
</DD>
<DT><STRONG>[vm]</STRONG></DT>
<DD>Optional <TT>ESMF_VM</TT> object of the current context. Providing the
            VM of the current context will lower the method's overhead.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION050126900000000000000">
31.6.9 ESMF_DistGridCreate - Create 1D DistGrid object from user's arbitray index list</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBAI1D(arbSeqIndexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(in)            :: arbSeqIndexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBAI1D
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> of <TT>dimCount</TT> 1 from a PET-local list
       of sequence indices. The PET-local size of the <TT>arbSeqIndexList</TT>
       argument determines the number of local elements in the created DistGrid.
       The sequence indices must be unique across all PETs. A default
       DELayout with 1 DE per PET across all PETs of the current VM is 
       automatically created.

<P>
The arguments are:
       <DL>
<DT><STRONG>arbSeqIndexList</STRONG></DT>
<DD>List of arbitrary sequence indices that reside on the local PET.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501261000000000000000">
31.6.10 ESMF_DistGridCreate - Create (1+n)D DistGrid object from user's arbitray index list and minIndexPTile/maxIndexPTile</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridCreate()
   function ESMF_DistGridCreateDBAI(arbSeqIndexList, arbDim, &amp;
     minIndexPTile, maxIndexPTile, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer, intent(in)            :: arbSeqIndexList(:)
     integer, intent(in)            :: arbDim
     integer, intent(in)            :: minIndexPTile(:)
     integer, intent(in)            :: maxIndexPTile(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer, intent(out), optional :: rc
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGrid) :: ESMF_DistGridCreateDBAI
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMF_DistGrid</TT> of <TT>dimCount</TT> <IMG
 WIDTH="43" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img87.png"
 ALT="$1+n$">, where 
       <IMG
 WIDTH="32" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img88.png"
 ALT="$n=$"> <TT>size(minIndexPTile)</TT> = <TT>size(maxIndexPTile)</TT>.

<P>
The resulting DistGrid will have a 1D distribution determined by the
       PET-local <TT>arbSeqIndexList</TT>. The PET-local size of the
       <TT>arbSeqIndexList</TT> argument determines the number of local elements 
       along the arbitrarily distributed dimension in the created DistGrid. The
       sequence indices must be unique across all PETs. The associated,
       automatically created DELayout will have 1 DE per PET across all PETs of
       the current VM.

<P>
In addition to the arbitrarily distributed dimension, regular DistGrid
       dimensions can be specified in <TT>minIndexPTile</TT> and <TT>maxIndexPTile</TT>. The
       <IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img77.png"
 ALT="$n$"> dimensional subspace spanned by the regular dimensions is "multiplied"
       with the arbitrary dimension on each DE, to form a <IMG
 WIDTH="43" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img87.png"
 ALT="$1+n$"> dimensional
       total index space described by the DistGrid object. The <TT>arbDim</TT>
       argument allows to specify which dimension in the resulting DistGrid
       corresponds to the arbitrarily distributed one.

<P>
The arguments are:
       <DL>
<DT><STRONG>arbSeqIndexList</STRONG></DT>
<DD>List of arbitrary sequence indices that reside on the local PET.
       
</DD>
<DT><STRONG>arbDim</STRONG></DT>
<DD>Dimension of the arbitrary distribution.
       
</DD>
<DT><STRONG>minIndexPTile</STRONG></DT>
<DD>Global coordinate tuple of the lower corner of the tile. The 
            arbitrary dimension is <EM>not</EM> included in this tile
       
</DD>
<DT><STRONG>maxIndexPTile</STRONG></DT>
<DD>Global coordinate tuple of the upper corner of the tile. The
            arbitrary dimension is <EM>not</EM> included in this tile
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501261100000000000000">
31.6.11 ESMF_DistGridDestroy - Release resources associated with a DistGrid </A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridDestroy(distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid), intent(inout)          :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,             intent(out),  optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Destroys an <TT>ESMF_DistGrid</TT>, releasing the resources associated
     with the object.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object to be destroyed.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501261200000000000000">
31.6.12 ESMF_DistGridGet - Get information about DistGrid object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetDefault(distgrid, delayout, dimCount, &amp;
     tileCount, minIndexPTile, maxIndexPTile, elementCountPTile, &amp;
     minIndexPDe, maxIndexPDe, elementCountPDe, deToTileMap, &amp;
     indexCountPDe, collocation, regDecompFlag, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),    intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     type(ESMF_DELayout),    intent(out), optional :: delayout
     integer,                intent(out), optional :: dimCount
     integer,                intent(out), optional :: tileCount
     integer,        target, intent(out), optional :: minIndexPTile(:,:)
     integer,        target, intent(out), optional :: maxIndexPTile(:,:)
     integer,        target, intent(out), optional :: elementCountPTile(:)
     integer,        target, intent(out), optional :: minIndexPDe(:,:)
     integer,        target, intent(out), optional :: maxIndexPDe(:,:)
     integer,        target, intent(out), optional :: elementCountPDe(:)
     integer,        target, intent(out), optional :: deToTileMap(:)
     integer,        target, intent(out), optional :: indexCountPDe(:,:)
     integer,        target, intent(out), optional :: collocation(:)
     logical,                intent(out), optional :: regDecompFlag
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>[delayout]</STRONG></DT>
<DD><TT>ESMF_DELayout</TT> object associated with <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[dimCount]</STRONG></DT>
<DD>Number of dimensions (rank) of <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[tileCount]</STRONG></DT>
<DD>Number of tiles in <TT>distgrid</TT>.
     
</DD>
<DT><STRONG>[minIndexPTile]</STRONG></DT>
<DD>Lower index space corner per <TT>dim</TT>, per <TT>tile</TT>, with
       <TT>size(minIndexPTile) == (/dimCount, tileCount/)</TT>.
     
</DD>
<DT><STRONG>[maxIndexPTile]</STRONG></DT>
<DD>Upper index space corner per <TT>dim</TT>, per <TT>tile</TT>, with
       <TT>size(minIndexPTile) == (/dimCount, tileCount/)</TT>.
     
</DD>
<DT><STRONG>[elementCountPTile]</STRONG></DT>
<DD>Number of elements in exclusive region per tile, with
       <TT>size(elementCountPTile) == (/tileCount/)</TT>
     
</DD>
<DT><STRONG>[minIndexPDe]</STRONG></DT>
<DD>Lower index space corner per <TT>dim</TT>, per <TT>De</TT>, with
       <TT>size(minIndexPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[maxIndexPDe]</STRONG></DT>
<DD>Upper index space corner per <TT>dim</TT>, per <TT>de</TT>, with
       <TT>size(minIndexPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[elementCountPDe]</STRONG></DT>
<DD>Number of elements in exclusive region per DE, with
       <TT>size(elementCountPDe) == (/deCount/)</TT>
     
</DD>
<DT><STRONG>[deToTileMap]</STRONG></DT>
<DD>List of tile id numbers, one for each DE, with
       <TT>size(deToTileMap) == (/deCount/)</TT>
     
</DD>
<DT><STRONG>[indexCountPDe]</STRONG></DT>
<DD>Array of extents per <TT>dim</TT>, per <TT>de</TT>, with
       <TT>size(indexCountPDe) == (/dimCount, deCount/)</TT>.
     
</DD>
<DT><STRONG>[collocation]</STRONG></DT>
<DD>List of collocation id numbers, one for each dim, with
       <TT>size(collocation) == (/dimCount/)</TT>
     
</DD>
<DT><STRONG>[regDecompFlag]</STRONG></DT>
<DD>Flag equal to <TT>ESMF_TRUE</TT> for regular decompositions
       and equal to <TT>ESMF_FALSE</TT> otherwise.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501261300000000000000">
31.6.13 ESMF_DistGridGet - Get DE local information about DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetPLocalDe(distgrid, localDe, &amp;
     collocation, arbSeqIndexFlag, seqIndexList, elementCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),    intent(in)            :: distgrid
     integer,                intent(in)            :: localDe
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(in),  optional :: collocation
     logical,                intent(out), optional :: arbSeqIndexFlag
     integer,        target, intent(out), optional :: seqIndexList(:)
     integer,                intent(out), optional :: elementCount
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>
     
</DD>
<DT><STRONG>[collocation]</STRONG></DT>
<DD>Collocation for which information is requested. Default to first
       collocation in <TT>collocationPDim</TT> list.
     
</DD>
<DT><STRONG>[arbSeqIndexFlag]</STRONG></DT>
<DD>Indicates whether collocation is associated with arbitrary sequence
       indices.
     
</DD>
<DT><STRONG>[seqIndexList]</STRONG></DT>
<DD>List of DistGrid tile-local sequence indices for <TT>localDe</TT>, with
       <TT>size(seqIndexList) == (/elementCountPDe(localDe)/)</TT>.

</DD>
<DT><STRONG>[elementCount]</STRONG></DT>
<DD>Number of elements in the localDe, i.e. identical to
       elementCountPDe(localDe).
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501261400000000000000">
31.6.14 ESMF_DistGridGet - Get DE local information for dimension about DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using ESMF_DistGridGet()
   subroutine ESMF_DistGridGetPLocalDePDim(distgrid, localDe, dim, &amp;
            indexList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),    intent(in)            :: distgrid
     integer,                intent(in)            :: localDe
     integer,                intent(in)            :: dim
     integer,        target, intent(out)           :: indexList(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Get internal DistGrid information.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Queried <TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>
     
</DD>
<DT><STRONG>dim</STRONG></DT>
<DD>Dimension for which information is requested. <TT>[1,..,dimCount]</TT>
     
</DD>
<DT><STRONG>indexList</STRONG></DT>
<DD>Upon return this holds the list of DistGrid tile-local indices
       for <TT>localDe</TT> along dimension <TT>dim</TT>. The supplied variable 
       must be at least of size <TT>indexCountPDimPDe(dim, de(localDe))</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501261500000000000000">
31.6.15 ESMF_DistGridMatch - Check if two DistGrid objects match</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function ESMF_DistGridMatch(distgrid1, distgrid2, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_DistGridMatch_Flag) :: ESMF_DistGridMatch
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)            :: distgrid1
     type(ESMF_DistGrid),  intent(in)            :: distgrid2
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Determine to which level <TT>distgrid1</TT> and <TT>distgrid2</TT> match. 

<P>
Returns a range of values of type <TT>ESMF_DistGridMatch_Flag</TT>,
     indicating how closely the DistGrids match. For a description of the
     possible return values, see&nbsp;<A HREF="node5.html#const:distgridmatch">31.2.1</A>. 
     Note that this call only performs PET local matching. Different return values
     may be returned on different PETs for the same DistGrid pair.

<P>
The arguments are:
     <DL>
<DT><STRONG>distgrid1</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>distgrid2</STRONG></DT>
<DD><TT>ESMF_DistGrid</TT> object.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501261600000000000000">
31.6.16 ESMF_DistGridPrint - Print DistGrid internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridPrint(distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Prints internal information about the specified <TT>ESMF_DistGrid</TT> 
       object to <TT>stdout</TT>. 
<BR>
<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Specified <TT>ESMF_DistGrid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION0501261700000000000000">
31.6.17 ESMF_DistGridValidate - Validate DistGrid internals</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridValidate(distgrid, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGrid),  intent(in)            :: distgrid
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,              intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
Validates that the <TT>distgrid</TT> is internally consistent.
        The method returns an error code if problems are found.  

<P>
The arguments are:
       <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD>Specified <TT>ESMF_DistGrid</TT> object.
       
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
       
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION050127000000000000000"></A>
<A NAME="ref:distgridconnection"></A>
<BR>
31.7 Class API: DistGridConnection Methods
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION050127100000000000000">
31.7.1 ESMF_DistGridConnectionSet - Set DistGridConnetion</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine ESMF_DistGridConnectionSet(connection, tileIndexA, tileIndexB, &amp;
     positionVector, orientationVector, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_DistGridConnection), intent(out)           :: connection
     integer,                       intent(in)            :: tileIndexA
     integer,                       intent(in)            :: tileIndexB
     integer,                       intent(in)            :: positionVector(:)
 -- The following arguments require argument keyword syntax (e.g. rc=rc). --
     integer,                       intent(in),  optional :: orientationVector(:)
     integer,                       intent(out), optional :: rc
</PRE>
<I>STATUS:</I>
   Backward compatible starting with ESMF 5.2.0r.
<BR>
<P>
<I>DESCRIPTION:
<BR></I>

<P>
<A NAME="api:DistGridConnectionSet"></A>     Set an <TT>ESMF_DistGridConnection</TT> object to represent a connection 
     according to the provided index space information.

<P>
The arguments are:
     <DL>
<DT><STRONG>connection</STRONG></DT>
<DD>DistGridConnection object.
     
</DD>
<DT><STRONG>tileIndexA</STRONG></DT>
<DD>Index of one of the two tiles that are to be connected.
     
</DD>
<DT><STRONG>tileIndexB</STRONG></DT>
<DD>Index of one of the two tiles that are to be connected.
     
</DD>
<DT><STRONG>positionVector</STRONG></DT>
<DD>Position of tile B's minIndex with respect to tile A's minIndex.
     
</DD>
<DT><STRONG>[orientationVector]</STRONG></DT>
<DD>Associates each dimension of tile A with a dimension in tile B's 
       index space. Negative index values may be used to indicate a 
       reversal in index orientation. It is erroneous to associate multiple
       dimensions of tile A with the same index in tile B. By default
       <TT>orientationVector = (/1,2,3,.../)</TT>, i.e. same orientation as tile A.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION050130000000000000000">
32 IO Capability</A>
</H1>

<P>

<H2><A NAME="SECTION050131000000000000000">
32.1 Description</A>
</H2>

<P>
The ESMF IO provides an unified interface for input and output of
high level ESMF objects such as Fields.  In the current release, the ESMF IO 
capability is integrated with third-party software such as 
<A NAME="tex2html32"
  HREF="http://code.google.com/p/parallelio/">Parallel IO (PIO)</A>
to read and write Fortran array data in MPI_IO binary or NetCDF format, and 
<A NAME="tex2html33"
  HREF="http://xerces.apache.org/xerces-c/">Xerces</A>
Library to read and write Attribute data in XML format.  Other file IO
functionalities, such as writing of error and log messages, input of
configuration parameters from an ASCII file, and lower-level IO utilites are 
covered in different sections of this document.  See the Log Class 
<A HREF="node6.html#sec:Log">43.1</A>, the Config Class <A HREF="node6.html#sec:Config">42.1</A>, and the Fortran 
I/O Utilities, <A HREF="node6.html#sec:IOUtil">46.1</A> respectively.

<P>

<H2><A NAME="SECTION050132000000000000000"></A>
<A NAME="io:attributeio"></A>
<BR>
32.2 Attribute I/O
</H2>

<P>
Metadata IO is handled via the ESMF Attribute class. The third
party software Xerces C++ Library is used by ESMF to provide
the ability to read and write Attribute data in XML file format.
To enable this capability, the environment variable ESMF_XERCES must be
set. Details can be found in the ESMF User Guide, "Building and Installing the ESMF", "Third Party Libraries".

<P>
In the current release, the following methods support Attribute XML I/O using Xerces:

<P>
<DL>
<DT></DT>
<DD><TT>ESMF_AttributeRead()</TT>, section <A HREF="node6.html#api:AttributeRead">35.10.23</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_AttributeWrite()</TT>, section <A HREF="node6.html#api:AttributeWrite">35.10.28</A>.
</DD>
</DL>

<P>

<H2><A NAME="SECTION050133000000000000000"></A>
<A NAME="io:dataio"></A>
<BR>
32.3 Data I/O
</H2>

<P>
ESMF provides interfaces for high performance, parallel I/O using ESMF data
objects such as Arrays and Fields.  Currently ESMF supports I/O of binary and
NetCDF files.  The current ESMF implementation relies on the 
<A NAME="tex2html34"
  HREF="http://code.google.com/p/parallelio/">Parallel I/O (PIO)</A>
library developed as a collaboration between NCAR and DOE 
laboratories.  PIO is built as part of the ESMF build when the environment 
variable ESMF_PIO is set to "internal"; by default it is not set.
When PIO is built with ESMF, the ESMF methods internally call the PIO 
interfaces.  When PIO is not built with ESMF, the ESMF methods are 
non-operable (no-op) stubs that simply return with a return code of
ESMF_RC_LIB_NOT_PRESENT.  Details about the environment variables can be 
found in ESMF User Guide, "Building and Installing the ESMF", 
"Third Party Libraries".

<P>
In the current release, the following methods support parallel data I/O using PIO:

<P>
<DL>
<DT></DT>
<DD><TT>ESMF_FieldBundleRead()</TT>, section <A HREF="node5.html#api:FieldBundleRead">21.5.15</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_FieldBundleWrite()</TT>, section <A HREF="node5.html#api:FieldBundleWrite">21.5.30</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_FieldRead()</TT>, section <A HREF="node5.html#api:FieldRead">22.6.46</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_FieldWrite()</TT>, section <A HREF="node5.html#api:FieldWrite">22.6.48</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_ArrayBundleRead()</TT>, section <A HREF="node5.html#api:ArrayBundleRead">23.5.15</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_ArrayBundleWrite()</TT>, section <A HREF="node5.html#api:ArrayBundleWrite">23.5.26</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_ArrayRead()</TT>, section <A HREF="node5.html#api:ArrayRead">24.5.24</A>.
</DD>
<DT></DT>
<DD><TT>ESMF_ArrayWrite()</TT>, section <A HREF="node5.html#api:ArrayWrite">24.5.37</A>.
</DD>
</DL>

<P>

<H2><A NAME="SECTION050134000000000000000">
32.4 Data formats</A>
</H2>

<P>
Two formats are supported, namely, NetCDF and binary (through MPI_IO). 
The environment variables that are enabled when ESMF is built determine the 
format.  The environment variables ESMF_NETCDF or/and ESMF_PNETCDF should be 
set to "standard" to enable NetCDF IO format.  If neither ESMF_NETCDF nor 
ESMF_PNETCDF are set, and MPI_IO is enabled in MPI, the format will be 
binary.  Details about the environment variables can be found in ESMF User 
Guide, "Building and Installing the ESMF", "Third Party Libraries".

<P>
<DL>
<DT><STRONG><B>NetCDF</B></STRONG></DT>
<DD>Network Common Data Form (NetCDF) is an interface for 
array-oriented data access. The NetCDF library provides an
implementation of the interface. It also defines a 
machine-independent format for representing scientific data. Together,
the interface, library, and format support the creation, access, and
sharing of scientific data. The NetCDF software was developed at the
Unidata Program Center in Boulder, Colorado. See [<A
 HREF="node8.html#NetCDF3_UsersGuide_C">18</A>].
In geoscience, NetCDF can be naturally used for represenation of fields 
defined on logically rectangular grids. NetCDF use in geosciences is 
specified by CF conventions mentioned above [<A
 HREF="node8.html#NetCDF_CF_v1_beta3">17</A>]. 

<P>
To the extent that data on unstructured grids (or even observations) can be 
represented as one-dimensional arrays, NetCDF can also be used to store these 
data. However, it does not provide a high-level abstraction for this type of 
data. 

<P>
</DD>
<DT><STRONG><B>IEEE Binary Streams</B></STRONG></DT>
<DD>A natural way for a machine to represent data is to use a native
binary data representation. There are two choices of ordering of bytes
(so-called <I>Big Endian</I> and <I>Little Endian</I>), and a lot of
ambiguity in representing floating point data. The latter, however, is
specified, if IEEE Floating Point Standard 754 is satisfied.
([<A
 HREF="node8.html#IEEE-Floating-Point">9</A>], [<A
 HREF="node8.html#Kahan-IEEE-754">14</A>]). 
[<A
 HREF="node8.html#XML-W3C">7</A>].

<P>
</DD>
</DL>

<P>

<P>

<H2><A NAME="SECTION050135000000000000000">
32.5 Restrictions and Future Work</A>
</H2>

<P>
Currently a small fraction of the anticipated data formats is implemented by 
ESMF.  The data IO uses NetCDF and MPI_IO binary formats, and ESMF Attribute
IO uses XML format.  Different libraries are employed for these 
different formats.  In future development, a more centralized IO technique
will likely be defined to provide efficient utilities with a set of standard
APIs that will allow manipulation of multiple standard formats.  Also, the 
ability to automatically detect file formats at runtime will be developed.

<P>

<P>

<H2><A NAME="SECTION050136000000000000000">
32.6 Design and Implementation Notes</A>
</H2>

<P>
For data IO, the ESMF IO capability relies on the 
<A NAME="tex2html35"
  HREF="http://code.google.com/p/parallelio">PIO</A>, 
<A NAME="tex2html36"
  HREF="http://www.unidata.ucar.edu/software/netcdf">NetCDF</A>, 
<A NAME="tex2html37"
  HREF="http://trac.mcs.anl.gov/projects/parallel-netcdf">PNetCDF</A>
and MPI_IO libraries.  For Attribute IO, the ESMF IO capability uses the 
<A NAME="tex2html38"
  HREF="http://xerces.apache.org/xerces-c">Xerces</A>
library to 
perform reading and writing of XML files.  PIO is included with the ESMF 
distribution; the other libraries must be installed on the machine of interest.

<P>

<P>

<P>

<H1><A NAME="SECTION050140000000000000000">
33 Overview of Distributed Data Methods</A>
</H1>

<P>
FieldBundles, Fields, and Arrays all have versions of the following
data communication methods.  In these objects, data is communicated 
between DEs.  Depending on the underlying communication 
mechanism, this may translate within the framework to a data 
copy, an MPI call, or something else.  
The ESMF goal of providing
performance portability means the framework will in the future
attempt to select the
fastest communication strategy on each hardware platform transparently 
to the user code.  (The current implementation uses MPI for communication.)

<P>
Communication patterns, meaning exactly which bytes need to be copied 
or sent from one PET to another to perform the requested operation,
can be precomputed during an initialization phase and then later 
executed repeatedly.
There is a common object handle, an <TT>ESMF_RouteHandle</TT>, which
identifies these stored communication patterns. 
Only the <TT>ESMF_RouteHandle</TT> and the source and destination 
data pointers must be supplied at runtime to minimize execution overhead.

<P>

<H2><A NAME="SECTION050141000000000000000">
33.1 Higher Level Functions</A>
</H2>
The following three methods are intended to map closely to 
needs of applications programs.  They represent higher level
communications and are described in more detail in the following
sections.  They are:

<P>

<UL>
<LI><B>Halo</B>
Update ghost-cell or halo regions at the boundaries
of a local data decomposition.
</LI>
<LI><B>Regrid</B>
Transform data from one Grid to another, performing
any necessary data interpolation.
</LI>
<LI><B>Redist</B>
Copy data associated with a single Grid from
one decomposition to another.  No data interpolation is necessary.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION050142000000000000000">
33.2 Lower Level Functions</A>
</H2>
The following methods correspond closely to the lower level
MPI communications primitives.  They are:

<P>

<UL>
<LI><B>Gather</B>
Reassembling data which is decomposed over a set of DEs into a single
block of data on one DE.
</LI>
<LI><B>AllGather</B>
Reassembling data which is decomposed over a set of DEs into multiple
copies of a single block of data, one copy per original DE.
</LI>
<LI><B>Scatter</B>
Spreading an undecomposed block of data on one DE over a set of DEs,
decomposing that single block into smaller subsets of data, one
data decomposition per DE.
</LI>
<LI><B>AlltoAll</B>
Spreading an undecomposed block of data from multiple DEs onto
each of the other DEs in the set, resulting in a set of multiple decomposed 
data blocks per DE, one from each of the original source DEs.
</LI>
<LI><B>Broadcast</B>
Spreading an undecomposed block of data from one DE onto all other
DEs, where the resulting data is still undecomposed and simply
copied to all other DEs.
</LI>
<LI><B>Reduction</B>
Computing a single data value, e.g. the data maximum, minimum, sum, etc
from a group of decomposed data blocks across a set of DEs, where the
result is delivered to a single DE.
</LI>
<LI><B>AllReduce</B>
Computing a single data value, e.g. the data maximum, minimum, sum, etc
from a group of decomposed data blocks across a set of DEs, where the
result is delivered to all DEs in the set.

<P>
</LI>
</UL>

<P>

<H2><A NAME="SECTION050143000000000000000"></A>
<A NAME="sec:routeoptions"></A>
<BR>
33.3 Common Options
</H2>

<P>
ESMF will select an appropriate default for the
internal communication strategy for executing the communications.  
However, additional control is available
to the user by specifying the following route options.
(For more details on exactly what changes with the various options,
see Section <A HREF="node5.html#sec:routeimpl">33.4</A>.)

<P>

<H2><A NAME="SECTION050144000000000000000"></A>
<A NAME="sec:routeimpl"></A>
<BR>
33.4 Design and Implementation Notes
</H2>

<P>

<OL>
<LI><P>
There is an internal <TT>ESMC_Route</TT> class which supports the 
distributed communication methods.  There are 4 additional internal-only
classes which support <TT>ESMC_Route</TT>: <TT>ESMC_AxisIndex</TT>, 
<TT>ESMC_XPacket</TT>, <TT>ESMC_CommTable</TT>, and <TT>ESMC_RTable</TT>;
and a public <TT>ESMF_RouteHandle</TT> class which is what the user 
sets and gets.  The implementation is in C++, with interfaces in Fortran 90.

<P>
The general communication strategy is that each
DE computes its own communication information independently,
in parallel, and adds entries to a per-PET route table
which contains all needed sends and receives (or gets and puts) 
stored in terms relative to itself.  (Implementation note: this
code will need to be made thread-safe if multiple threads are
trying to add information to the same route table.)

<P>
AxisIndex is a small helper class which contains an index minimum
and maximum for each dimension and is used to describe an n-dimensional
hypercube of information in index space.  These are associated with 
logically rectangular grids and local data arrays.  
There are usually multiple instances of them, for example the local
data chunk, and the overall global index-space grid this data is
a subset of.  Within each of the local or global categories, there are
also multiple instances to describe the allocated space, the total area,
the computational area, and the exclusive area.
(Implementation note: the allocated space is only partially implemented
internally and has no external user API yet.)

<P>
An Exchange Packet (XPacket) describes groups of memory addresses
which constitute an n-dimensional hypercube of data.
Each XPacket has an offset from a base address, 
a contiguous run length, 
a stride (or number of items to skip) per dimension,
and a repeat count per dimension. 
See Figure <A HREF="node5.html#fig:xpacketbasic">21</A> for a diagram of how the XPacket
describes memory.
The actual unit size stored in an XPacket is an item count, 
so before using an XPacket to address bytes of memory
the item size must be known and the
counts multiplied by the number of bytes per item.  This allows
the same XPacket to describe different data types which have the
same memory layout, for example 4 byte integers and 8 byte reals/doubles.
The XPacket methods include basic set/get, how to turn
a list of AxisIndex objects into an XPacket, compute a local XPacket from one
in global (undecomposed grid) space, and a method to compute the intersection
of 2 XPackets and produce a 3rd XPacket describing that region.  

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xpacketbasic"></A><A NAME="47081"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 21:</STRONG>
How an Exchange Packet (XPacket) describes the memory
layout for a rectangular hypercube of data.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.8}{\includegraphics{Basic_xpacket}}$
 -->
<IMG
 WIDTH="734" HEIGHT="459" ALIGN="BOTTOM" BORDER="0"
 SRC="img89.png"
 ALT="\scalebox{0.8}{\includegraphics{Basic_xpacket}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The Communication Table (CommTable) class encapsulates which other PETs this
PET needs to talk to, and in what order.  There are create and destroy
methods, methods to set that a PET has data either to
send or receive, and query routines that return an answer
to the question 'which PET should I exchange data with next'.  

<P>
The Route Table (RTable) class contains a list of
XPackets to be sent and received from other PETs.
It has create/destroy methods, methods to add XPackets to the list for 
each PET, and methods to retrieve the XPackets from any list.

<P>
The top level class is a Route.  A Route object contains a send RTable, 
a recv RTable, a CommTable, and a pointer to a Virtual Machine.   
The VM must include all PETs which are participating
in this communication.
The Route methods
include create/destroy, setting a send or recv XPacket
for a particular PET,
and some higher level functions specific to each
type of communication, for example RoutePrecomputeHalo
or RoutePrecomputeRedist.  These latter functions
are where the XPackets are actually computed and added to
the Route table.  Each DE computes its own set of intersections,
either source or destination, and fills its own corresponding PET table.
The Route methods also include a RouteRun method which executes the code
which actually traverses the table and sends the information between PETs.

<P>
A RouteHandle class is a small helper class which is returned through
the public API to the user when a Route is created, and passed back in
through the API to select which precomputed Route is to be executed.
A RouteHandle contains a handle type and a pointer to a Route object.
In addition, for use only by the Regrid code, there is an additional Route
pointer and a TransformValues pointer.  (TransformValues is an internal
class only used by the Regridding code.)  If the RouteHandle describes the
Route for a FieldBundle, then the RouteHandle can contain a list of Routes,
one for each Field in the FieldBundle, and for Regrid use, a list of additional
Routes instead of a single Route.  There is also a flag to indicate whether
a single Route is applicable to all Fields in a FieldBundle or whether there
are multiple Routes.
The RouteHandle methods are fairly basic; mostly accessor methods
for getting and setting values.

<P>
</LI>
<LI><P>
While intended for any distributed data communication method,
the current implementation only builds a Route object for
the halo, redist, and regrid methods.  Scatter, Gather,
AllGather, and AlltoAll 
should have the option of building a Route for operations
which are executed repeatedly.  This should only require
writing a Precompute method for each one; the existing 
RouteRun can be invoked for these operations.
(This is a lack-of-implementation-time issue, not a design
or architecture issue.)

<P>
</LI>
<LI><P>
The original design included automatic detection of different
Routes and internal caching, so the user API did not have to
include a RouteHandle object to identify which Route was
being invoked.  However, users requested that the framework
not cache and that explicit RouteHandle arguments be created
and required to invoke the distributed data methods.
Nothing prevents this code from being revived from the CVS
repository and reinstated in the system, should automatic
caching be desired by future users.

<P>
</LI>
<LI><P>
The current distributed methods have 2 related but distinct
interfaces which differ in what information they require
and whether they use RouteHandles:

<P>
<DL COMPACT>
<DT>Precompute/Run/Release</DT>
<DD>This is the most frequently used interface set.
It contains 3 distinct phases: precomputing which bytes must
be moved, actually executing the communications operation,
and releasing the stored information.  This is intended for
any communication pattern which will be executed more than once.
</DD>
<DT>All-in-One</DT>
<DD>For a communication which will only be executed once, or in
any situation in which the user does not want to save a RouteHandle,
there are interfaces which do not have RouteHandles as part of
the argument list.  Internally the code computes a Route,
executes it, and releases the resources before returning.
</DD>
</DL>

<P>
</LI>
<LI><P>
The current CommTable code executes one very specific communication
strategy based on input from a user who did extensive timing
measurements on several different hardware platforms.  Rather than
broadcasting all data at once asychronously, it selects combinations
of pairs of processors and has them execute a SendRecv operation, which
does both a data send and a data receive in a single call.
At each step in the execution, different pairs of processors
exchange data until all pair combinations have been selected.

<P>
The table itself must be a power of 2 in size; the number of
PETs is rounded up to the next power of 2 and then all entries
for PETs larger than the actual number are marked as no-ops.

<P>
There are many alternative execution strategies, including a
completely asynchronous execution, in numeric PET order, without
computing processor pairs.  Also single-direction communications 
are possible (only the Send XPackets are processed, or only
the Receive XPackets) in either a synchronous or asynchronous mode.  
This would not require any changes to the XPacket or RTable classes,
but would require writing a set of alternative RouteRun methods.

<P>
</LI>
<LI><P>
The current RouteRun routine has many possible performance options for how
to make the tradeoff between time spent packing disjoint memory
blocks into a single buffer to minimize the number of sends,
verses simply sending the contiguous blocks without the pack overhead.
The tradeoffs are not expected to be the same on all systems;
hardware latency verses bandwith characteristics will differ,
plus the underlying communication software (MPI, shared memory, etc)
will change the performance.  Also the size of the data blocks
to be sent, the amount of contiguity, and limits on the number 
of outstanding communication buffers all affect what options are best.

<P>
The <TT>ESMF_RouteOptions</TT> are listed in <A HREF="node5.html#sec:routeoptions">33.3</A>; 
the following description contains more implementation detail 
about what each of the options
controls inside the execution of a Route.  Note that the options
do not affect the creation of a Route, nor any of the Precompute
code, and can optionally be changed each time the Route is run.

<P>
Packing options:
<DL COMPACT>
<DT>By Buffer</DT>
<DD>If multiple memory addresses are provided to RouteRun (from
bundle-level communications, for example), then this option
packs data across all buffers/blocks as specified by the other
packing flags before sending or receiving.
Note: unlike the other packing flags, this is handled in the
code at a higher level by either passing down multiple addresses
into the route run routine or not.  If multiple addresses are
passed into the run routine, they will be packed.  The "no-packing"
option at this level would be identical to looping at the outermost
level in the RouteRun code and therefore there is no disadvantage
to calling this routine once per address (and the advantage is
not adding yet another coding loop inside the already complex
RouteRun code).  The higher level list-of-address code can be
disabled by clearing this flag (which is on by default).
</DD>
<DT>By PET</DT>
<DD>All data from a single block
intended for a remote PET is packed into a single send
buffer, and sent in a single VM communications call.  
A buffer large enough to receive all data 
coming from that remote PET is allocated, the data is received,
and then the data is copied into the final location.
See <A HREF="node5.html#fig:routepackall">26</A>.
</DD>
<DT>By XP</DT>
<DD>All data described by a single XPacket (which is a n-dimensional
hyperslab of memory) is packed into a single buffer for sending,
and a single buffer large enough to receive an XPacket is 
allocated for receiving the data.
See <A HREF="node5.html#fig:routepack">25</A>.
</DD>
<DT>No Packing</DT>
<DD>A VM communication call is made for each single contiguous strip
of memory, regardless of how long or short.
</DD>
<DT>MPI Vector</DT>
<DD>MPI implements a set of interfaces for sending and receiving which
allows certain strided memory patterns to be sent in a single call.
The actual implementation is up to the MPI library itself.  But no
user-level data copy is needed in this case. (Not implemented yet.)
</DD>
</DL>
Note that in all packing options, if the XPacket describes a
chunk of memory which is completely contiguous, then the code
does not allocate a packing or unpacking buffer but supplies the
actual data address to the communications call so the data is
read or written in place.

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xpacketpack"></A><A NAME="47097"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 22:</STRONG>
A common XPacket pattern which generally benefits from
packing; the overlap region between 2 DEs during a halo update
are often short in the contiguous dimension and have a high 
repeat count.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Basic_xpacket_pack}}$
 -->
<IMG
 WIDTH="742" HEIGHT="582" ALIGN="BOTTOM" BORDER="0"
 SRC="img90.png"
 ALT="\scalebox{0.9}{\includegraphics{Basic_xpacket_pack}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xpacket2up"></A><A NAME="47105"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 23:</STRONG>
When there are multiple XPackets destined for the
same remote PET there are more options for how to order the
contiguous pieces into a packed buffer.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.8}{\includegraphics{Basic_xpacket_2up}}$
 -->
<IMG
 WIDTH="737" HEIGHT="459" ALIGN="BOTTOM" BORDER="0"
 SRC="img91.png"
 ALT="\scalebox{0.8}{\includegraphics{Basic_xpacket_2up}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:xpacketcontig"></A><A NAME="47111"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 24:</STRONG>
When the XPacket describes memory which is physically
a single contiguous region, there is no need to copy the data
into another buffer; it can be communicated inplace.  There is
a flag in the XPacket which marks how many of the dimensions
are contiguous.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.8}{\includegraphics{Basic_xpacket_contig}}$
 -->
<IMG
 WIDTH="737" HEIGHT="459" ALIGN="BOTTOM" BORDER="0"
 SRC="img92.png"
 ALT="\scalebox{0.8}{\includegraphics{Basic_xpacket_contig}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:routepack"></A><A NAME="47121"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 25:</STRONG>
Often the overhead of making multiple communication calls 
outweighs the cost of copying non-contiguous data into a contiguous buffer,
sending it in a single operation, and then copying it to the final
memory locations on the receiving side.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.9}{\includegraphics{Basic_pack_route}}$
 -->
<IMG
 WIDTH="828" HEIGHT="620" ALIGN="BOTTOM" BORDER="0"
 SRC="img93.png"
 ALT="\scalebox{0.9}{\includegraphics{Basic_pack_route}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
<DIV ALIGN="CENTER">
</DIV>
<DIV ALIGN="CENTER"><A NAME="fig:routepackall"></A><A NAME="47129"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 26:</STRONG>
Once there is more than a single XPacket to pack, there
are many more interleave options.  For example, packing in the
order: 1, 4, 2, 5, 3, 6 would also be possible here.  However
the code becomes more complicated when the XPackets have different
repeat counts, and has no real performance advantage over the
straightforward packing of each XPacket in sequence.  Note that
this packing is the same whether it refers to multiple XPackets
from the same memory buffer or from multiple buffers.</CAPTION>
<TR><TD><!-- MATH
 $\scalebox{0.8}{\includegraphics{Basic_2up_route}}$
 -->
<IMG
 WIDTH="736" HEIGHT="477" ALIGN="BOTTOM" BORDER="0"
 SRC="img94.png"
 ALT="\scalebox{0.8}{\includegraphics{Basic_2up_route}}"></TD></TR>
</TABLE>
</DIV>
<DIV ALIGN="CENTER">
</DIV>

<P>
The following options refer to the internal strategy for 
executing the route and not to whether the user-level API call
returns before the route has finished executing.  The current
system only implements user-synchronous calls; asynchronous calls
are on the to-be-written list.

<P>
<DL COMPACT>
<DT>Sync</DT>
<DD>Each pair of processors exchanges data with the VM
equivalent of an MPI_SendRecv() call, which does not return until
both the send and receive have completed.

<P>
</DD>
<DT>Async</DT>
<DD>Each processor executes both an asynchronous send
and asychronous receive to the other processor and does not wait
for completion before moving on to the next communication in the
CommTable.  Then in a separate loop through the RTables, each
call is waited for in turn and when all outstanding communication
calls have completed, then the API call returns to the user.

<P>
</DD>
</DL>
(Note that in the Async case it makes much more sense to iterate
throught the Route table in PET order instead of the complication
of computing communication pairs and iterating in a non-sequential
order.  The code is as it is now for reasons of implementation speed
and not for any other design reason.  This would require a slightly
simpler, but separate, version of the RouteRun() subroutine.)

<P>
</LI>
<LI><P>
FieldBundle-level communication calls have additional packing options
under certain circumstances.  FieldBundles are groups of Fields which
share the same Grid, but they are not required to share the same
data types, data ranks, nor relative data locations.  FieldBundles
in which these things are the same in all Fields are marked inside the
bundle code as being <B>congruent</B>.  At communication store time
FieldBundles which have congruent data in all the Fields have the option
of packing all Field data together into fewer communication calls
which generally is expected to give better performance.   
Fields where the data is not of the same type or perhaps not
the same number of items (e.g. different rank, vertex-centered data
vs. cell centered data) can in theory also be packed but in fact
the code becomes more complicated, and in the case of differing
data types may cause system errors because of accessing data
on non-standard byte offsets or putting mixing integer data
with floating data and causing NaN (not a number) exceptions.
In this case, the conservative implementation strategy is to construct 
a separate Route object for each Field, all enclosed in the same
RouteHandle.  Inside the FieldBundle communication code the execution
for both types of FieldBundles is identical for the caller, but inside
the congruent FieldBundle code calls the <TT>ESMF_RouteRun()</TT> code
once and all communication for all Fields in the FieldBundle is done
when it returns.  The non-congruent FieldBundles execute a separate
<TT>ESMF_RouteRun()</TT> call for each Field and return to the user 
when all Field data have been sent/received.

<P>
There are comments in the code for an intermediate level of
optimization in which the FieldBundle code determines the smallest
number of unique types of Fields in the FieldBundle, and all same types
share the same Route object, but this has not been implemented
at this time.  Once the existing code has been in use for a while,
whether this is useful or needed may become more clear.

<P>
</LI>
<LI><P>
The precompute code for all operations must have enough
information to compute which parts of the data arrays
are expected to be sent to remote PETs and also what
remote data is expected to be received by this PET.

<P>
These computations depend heavily on what type of distributed
method is being executed.  The regridding methods are described
in detail separately in the Regrid Design and Implementation Notes
section.  The halo and redistribution operations are described here.

<P>
<DL COMPACT>
<DT>Halo</DT>
<DD>The total array area, which includes any halo regions,
are intersected with the computational
area of other DEs. The overlap regions are converted from index
space into memory space and stored as XPackets in the RTables.
This code must be aware of: whether the grid was defined as
periodic in any or all of the dimensions since that affects
which halo regions overlap at the grid edges; if the data
is only decomposed into a single block in any dimension (which
means it halos with itself); and if the halo region is large
enough that a halo operation may require intersection with
the N+1 neighbor in any dimension.  

<P>
</DD>
<DT>Redistribute</DT>
<DD>Each DE computes the overlap
between its own computational region and all DEs in the 
remote Grid, again only working in computational area.  
The overlap regions are converted from index
space into memory space and stored as XPackets in the RTables.
After execution a redistribution, a halo operation may be required
to populate any halo regions with consistent data.

<P>
</DD>
</DL>
(Note: the Redistribution code has been reimplemented to intersect
the DEs in index space and then convert the overlap region to an XPacket
representation.  Halo still converts the regions from AxisIndex to 
XPackets and then intersects the XPackets, but this code needs to be
changed to intersect in AxisIndex space and once the overlap is computed
then convert to XPackets.  Intersecting AxisIndex objects is very 
much simpler, both to understand and to execute, and more easily 
extensible to multiple dimensions than intersecting XPackets.)

<P>
</LI>
</OL>

<P>

<H2><A NAME="SECTION050145000000000000000">
33.5 Object Model</A>
</H2>

<P>
The following is a simplified UML diagram showing the structure of the public
RouteHandle class.  See Appendix A, <I>A Brief Introduction to UML</I>, for a
translation table that lists the symbols in the diagram and their meaning.

<P>
<DIV ALIGN="CENTER">
<IMG
 WIDTH="771" HEIGHT="316" ALIGN="BOTTOM" BORDER="0"
 SRC="img95.png"
 ALT="\includegraphics[]{RouteHandle_obj}">

</DIV>

<P>

<P>

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html1768"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1764"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1758"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1766"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1769"
  HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html1765"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1759"
  HREF="node4.html">3 Superstructure</A>
 &nbsp <B>  <A NAME="tex2html1767"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
