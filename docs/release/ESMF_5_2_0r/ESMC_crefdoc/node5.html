<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>4 Infrastructure: Fields and Grids</TITLE>
<META NAME="description" CONTENT="4 Infrastructure: Fields and Grids">
<META NAME="keywords" CONTENT="ESMC_crefdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMC_crefdoc.css">

<LINK REL="next" HREF="node6.html">
<LINK REL="previous" HREF="node4.html">
<LINK REL="up" HREF="ESMC_crefdoc.html">
<LINK REL="next" HREF="node6.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html441"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html437"
  HREF="ESMC_crefdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html431"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html439"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html442"
  HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html438"
  HREF="ESMC_crefdoc.html">ESMC_crefdoc</A>
<B> Previous:</B> <A NAME="tex2html432"
  HREF="node4.html">3 Superstructure</A>
 &nbsp <B>  <A NAME="tex2html440"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html443"
  HREF="node5.html#SECTION05010000000000000000">15 Overview of Infrastructure Data Handling</A>
<UL>
<LI><A NAME="tex2html444"
  HREF="node5.html#SECTION05011000000000000000">15.1 Infrastructure Data Classes</A>
<LI><A NAME="tex2html445"
  HREF="node5.html#SECTION05012000000000000000">15.2 Design and Implementation Notes</A>
</UL>
<LI><A NAME="tex2html446"
  HREF="node5.html#SECTION05020000000000000000">16 Field Class</A>
<UL>
<LI><A NAME="tex2html447"
  HREF="node5.html#SECTION05021000000000000000">16.1 Description</A>
<UL>
<LI><A NAME="tex2html448"
  HREF="node5.html#SECTION05021100000000000000">16.1.1 Field create and destroy</A>
</UL>
<LI><A NAME="tex2html449"
  HREF="node5.html#SECTION05022000000000000000">16.2 Class API</A>
<UL>
<LI><A NAME="tex2html450"
  HREF="node5.html#SECTION05022100000000000000">16.2.1 ESMC_FieldCreate</A>
<LI><A NAME="tex2html451"
  HREF="node5.html#SECTION05022200000000000000">16.2.2 ESMC_FieldDestroy</A>
<LI><A NAME="tex2html452"
  HREF="node5.html#SECTION05022300000000000000">16.2.3 ESMC_FieldGetArray</A>
<LI><A NAME="tex2html453"
  HREF="node5.html#SECTION05022400000000000000">16.2.4 ESMC_FieldGetMesh</A>
<LI><A NAME="tex2html454"
  HREF="node5.html#SECTION05022500000000000000">16.2.5 ESMC_FieldGetPtr</A>
<LI><A NAME="tex2html455"
  HREF="node5.html#SECTION05022600000000000000">16.2.6 ESMC_FieldPrint</A>
</UL>
</UL>
<LI><A NAME="tex2html456"
  HREF="node5.html#SECTION05030000000000000000">17 Array Class</A>
<UL>
<LI><A NAME="tex2html457"
  HREF="node5.html#SECTION05031000000000000000">17.1 Description</A>
<LI><A NAME="tex2html458"
  HREF="node5.html#SECTION05032000000000000000">17.2 Class API</A>
<UL>
<LI><A NAME="tex2html459"
  HREF="node5.html#SECTION05032100000000000000">17.2.1 ESMC_ArrayCreate</A>
<LI><A NAME="tex2html460"
  HREF="node5.html#SECTION05032200000000000000">17.2.2 ESMC_ArrayDestroy</A>
<LI><A NAME="tex2html461"
  HREF="node5.html#SECTION05032300000000000000">17.2.3 ESMC_ArrayGetName</A>
<LI><A NAME="tex2html462"
  HREF="node5.html#SECTION05032400000000000000">17.2.4 ESMC_ArrayGetPtr</A>
<LI><A NAME="tex2html463"
  HREF="node5.html#SECTION05032500000000000000">17.2.5 ESMC_ArrayPrint</A>
</UL>
</UL>
<LI><A NAME="tex2html464"
  HREF="node5.html#SECTION05040000000000000000">18 ArraySpec Class</A>
<UL>
<LI><A NAME="tex2html465"
  HREF="node5.html#SECTION05041000000000000000">18.1 Description</A>
<LI><A NAME="tex2html466"
  HREF="node5.html#SECTION05042000000000000000">18.2 Class API</A>
<UL>
<LI><A NAME="tex2html467"
  HREF="node5.html#SECTION05042100000000000000">18.2.1 ESMC_ArraySpecGet</A>
<LI><A NAME="tex2html468"
  HREF="node5.html#SECTION05042200000000000000">18.2.2 ESMC_ArraySpecSet</A>
</UL>
</UL>
<LI><A NAME="tex2html469"
  HREF="node5.html#SECTION05050000000000000000">19 Mesh Class</A>
<UL>
<LI><A NAME="tex2html470"
  HREF="node5.html#SECTION05051000000000000000">19.1 Description</A>
<UL>
<LI><A NAME="tex2html471"
  HREF="node5.html#SECTION05051100000000000000">19.1.1 Mesh Representation in ESMF</A>
<LI><A NAME="tex2html472"
  HREF="node5.html#SECTION05051200000000000000">19.1.2 Supported Meshes</A>
</UL>
<LI><A NAME="tex2html473"
  HREF="node5.html#SECTION05052000000000000000">19.2 Constants</A>
<UL>
<LI><A NAME="tex2html474"
  HREF="node5.html#SECTION05052100000000000000">19.2.1 ESMC_MESHELEMTYPE</A>
</UL>
<LI><A NAME="tex2html475"
  HREF="node5.html#SECTION05053000000000000000">19.3 Class API</A>
<UL>
<LI><A NAME="tex2html476"
  HREF="node5.html#SECTION05053100000000000000">19.3.1 ESMC_MeshAddElements</A>
<LI><A NAME="tex2html477"
  HREF="node5.html#SECTION05053200000000000000">19.3.2 ESMC_MeshAddNodes</A>
<LI><A NAME="tex2html478"
  HREF="node5.html#SECTION05053300000000000000">19.3.3 ESMC_MeshCreate</A>
<LI><A NAME="tex2html479"
  HREF="node5.html#SECTION05053400000000000000">19.3.4 ESMC_MeshDestroy</A>
<LI><A NAME="tex2html480"
  HREF="node5.html#SECTION05053500000000000000">19.3.5 ESMC_MeshFreeMemory</A>
<LI><A NAME="tex2html481"
  HREF="node5.html#SECTION05053600000000000000">19.3.6 ESMC_MeshGetLocalElementCount</A>
<LI><A NAME="tex2html482"
  HREF="node5.html#SECTION05053700000000000000">19.3.7 ESMC_MeshGetLocalNodeCount</A>
</UL>
</UL>
<LI><A NAME="tex2html483"
  HREF="node5.html#SECTION05060000000000000000">20 DistGrid Class</A>
<UL>
<LI><A NAME="tex2html484"
  HREF="node5.html#SECTION05061000000000000000">20.1 Description</A>
<LI><A NAME="tex2html485"
  HREF="node5.html#SECTION05062000000000000000">20.2 Class API</A>
<UL>
<LI><A NAME="tex2html486"
  HREF="node5.html#SECTION05062100000000000000">20.2.1 ESMC_DistGridCreate</A>
<LI><A NAME="tex2html487"
  HREF="node5.html#SECTION05062200000000000000">20.2.2 ESMC_DistGridDestroy</A>
<LI><A NAME="tex2html488"
  HREF="node5.html#SECTION05062300000000000000">20.2.3 ESMC_DistGridPrint</A>
</UL></UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION05000000000000000000">
4 Infrastructure:  Fields and Grids</A>
</H1>

<P>

<P>

<H1><A NAME="SECTION05010000000000000000">
15 Overview of Infrastructure Data Handling</A>
</H1>

The ESMF infrastructure data classes are part of the framework's 
hierarchy of structures for handling Earth system model data and 
metadata on parallel platforms.  The hierarchy is in complexity; the 
simplest data class in the infrastructure represents a distributed data
array and the most complex data class represents a bundle of physical 
fields that are discretized on the same grid.  However, the current C API 
does not support bundled data structures yet. Array and Field are the two
data classes offered by the ESMF C language binding.  Data class methods 
are called both from user-written code and from other classes 
internal to the framework. 

Data classes are distributed over <B>DE</B>s, or <B>Decomposition Elements</B>.  
A DE represents a piece of a decomposition.  A DELayout is a collection
of DEs with some associated connectivity that describes a specific 
distribution.  For example, the distribution of a grid divided 
into four segments in the x-dimension would be expressed in ESMF as
a DELayout with four DEs lying along an x-axis. This abstract concept 
enables a data decomposition to be defined in 
terms of threads, MPI processes, virtual decomposition elements, or
combinations of these without changes to user code.  This is a
primary strategy for ensuring optimal performance and portability
for codes using the ESMF for communications.

ESMF data classes are useful because they provide a standard, 
convenient way for developers to collect together information 
related to model or observational data.  The information assembled 
in a data class includes a data pointer, a set of attributes 
(e.g. units, although attributes can also be user-defined), and a 
description of an associated grid.  The same set of information within 
an ESMF data object can be used by the framework to arrange 
intercomponent data transfers, to perform I/O, for communications
such as gathers and scatters, for simplification of interfaces 
within user code, for debugging, and for other functions.  
This unifies and organizes codes overall so that the user need not
define different representations of metadata for the same field 
for I/O and for component coupling.  

Since it is critical that users be able to introduce ESMF into their
codes easily and incrementally, ESMF data classes can be created based 
on native Fortran pointers.  Likewise, there are methods for retrieving 
native Fortran pointers from within ESMF data objects.  This allows
the user to perform allocations using ESMF, and to retrieve Fortran
arrays later for optimized model calculations.  The ESMF data classes 
do not have associated differential operators or other mathematical 
methods.

For flexibility, it is not necessary to build an ESMF data object 
all at once.  For example, it's possible to create a 
field but to defer allocation of the associated field data until 
a later time.

<DIV ALIGN="CENTER">
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>
<BR>
<B>Key Features</B></TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Hierarchy of data structures designed specifically for the Earth 
system domain and high performance, parallel computing.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Multi-use ESMF structures simplify user code overall.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Data objects support incremental construction and deferred allocation.</TD>
</TR>
<TR><TD ALIGN="LEFT" VALIGN="TOP" WIDTH=432>Native Fortran arrays can be associated with or retrieved from ESMF data
objects, for ease of adoption, convenience, and performance.</TD>
</TR>
</TABLE>
</DIV>
<H2><A NAME="SECTION05011000000000000000">
15.1 Infrastructure Data Classes</A>
</H2>

The main classes that are used for model and observational data manipulation
are as follows:

<UL>
<LI><B>Array</B>  An ESMF Array contains a data pointer, 
information about its associated datatype, precision, and 
dimension.  

Data elements in Arrays are partitioned into categories 
defined by the role the data element plays in distributed halo 
operations.  Haloing - sometimes called ghosting - is the 
practice of copying portions of array data to multiple memory 
locations to ensure that data dependencies can be satisfied 
quickly when performing a calculation.  ESMF Arrays contain 
an <B>exclusive</B> domain, which contains data elements
updated exclusively and definitively by a given DE; a 
<B>computational</B> domain, which contains all data elements
with values that are updated by the DE in computations; and 
a <B>total</B> domain, which includes both the computational 
domain and data elements from other DEs which may be read 
but are not updated in computations.

</LI>
<LI><B>Field</B>  A Field holds model and/or observational 
data together with its underlying grid or set of spatial 
locations.  It provides methods for configuration, 
initialization, setting and retrieving data values, 
data I/O, data regridding, and manipulation of attributes.

</LI>
</UL>


<P>

<P>

<H2><A NAME="SECTION05012000000000000000">
15.2 Design and Implementation Notes</A>
</H2>

<P>

<OL>
<LI>In communication methods such as Regrid, Redist, Scatter, etc. 
the Field code cascades down through the Array code, so 
that the actual implementation exist in only one place in the source.

<P>
</LI>
</OL>

<P>

<P>

<P>

<H1><A NAME="SECTION05020000000000000000">
16 Field Class</A>
</H1>

<P>

<H2><A NAME="SECTION05021000000000000000">
16.1 Description</A>
</H2>

<P>
An ESMF Field represents a physical field, such as temperature.
The motivation for including Fields in ESMF is that bundles of 
Fields are the entities that are normally exchanged when coupling
Components.  

<P>
The ESMF Field class contains distributed and discretized field data, a reference 
to its associated grid, and metadata.  The Field class stores the grid <I>staggering</I>
for that physical field.
This is the relationship of how the data array of a field maps onto a grid 
(e.g. one item per
cell located at the cell center, one item per cell located at the NW
corner,  one item per cell vertex, etc.).  This means that different Fields
which are on the same underlying ESMF Grid but have different
staggerings can share the same Grid object without needing to replicate
it multiple times. 

<P>
Fields can be added to States for use in inter-Component
data communications.

<P>
Field communication capabilities include: data redistribution, regridding, scatter,
gather, sparse-matrix multiplication, and halo update.  These are discussed
in more detail in the documentation for the specific method calls.  
ESMF does not currently support vector fields, so the components of 
a vector field must be stored as separate Field objects.  

<P>

<P>
A Field serves as an annotator of data, since it carries 
a description of the grid it is associated with and metadata 
such as name and units.  Fields can be used in this capacity
alone, as convenient, descriptive containers into which arrays 
can be placed and retrieved.  However, for most codes the primary 
use of Fields is in the context of import and export States,
which are the objects that carry coupling information between 
Components.  Fields enable data to be self-describing, and a
State holding ESMF Fields contains data in a standard format
that can be queried and manipulated.  

<P>
The sections below go into more detail about Field usage.

<P>

<H3><A NAME="SECTION05021100000000000000">
16.1.1 Field create and destroy</A>
</H3>

<P>
Fields can be created and destroyed at any time during 
application execution.  However, these Field methods require 
some time to complete.  We do not recommend that the user
create or destroy Fields inside performance-critical 
computational loops.

<P>
All versions of the <TT>ESMC_FieldCreate()</TT> 
routines require a Mesh object as input.
The Mesh contains the information needed to know which 
Decomposition Elements (DEs) are participating in 
the processing of this Field, and which subsets of the data
are local to a particular DE.

<P>
The details of how the create process happens depends 
on which of the variants of the <TT>ESMC_FieldCreate()</TT> 
call is used.

<P>
When finished with an <TT>ESMC_Field</TT>, the <TT>ESMC_FieldDestroy</TT> method
removes it.  However, the objects inside the <TT>ESMC_Field</TT>
created externally should be destroyed separately, 
since objects can be added to
more than one <TT>ESMC_Field</TT>.  For example, the same <TT>ESMF_Mesh</TT>
can be referenced by multiple <TT>ESMC_Field</TT>s.  In this case the
internal Mesh is not deleted by the <TT>ESMC_FieldDestroy</TT> call.

<P>

<H2><A NAME="SECTION05022000000000000000">
16.2 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05022100000000000000">
16.2.1 ESMC_FieldCreate - Create a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> ESMC_Field ESMC_FieldCreate(
   ESMC_Mesh mesh,                           // in
   ESMC_ArraySpec arrayspec,                 // in
   ESMC_InterfaceInt gridToFieldMap,         // in
   ESMC_InterfaceInt ungriddedLBound,        // in
   ESMC_InterfaceInt ungriddedUBound,        // in
   const char *name,                         // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Field object.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates a <TT>ESMC_Field</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>A <TT>ESMC_Mesh</TT> object.
    
</DD>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>A <TT>ESMC_ArraySpec</TT> object describing data type and kind specification.
    
</DD>
<DT><STRONG>gridToFieldMap</STRONG></DT>
<DD>List with number of elements equal to the grid's dimCount. The list
      elements map each dimension of the grid to a dimension in the field by
      specifying the appropriate field dimension index. The default is to map all of
      the grid's dimensions against the lowest dimensions of the field in sequence,
      i.e. gridToFieldMap = (/1,2,3,.../). The values of all gridToFieldMap entries
      must be greater than or equal to one and smaller than or equal to the field
      rank. It is erroneous to specify the same gridToFieldMap entry multiple times.
      The total ungridded dimensions in the field  are the total field dimensions
      less the dimensions in the grid. Ungridded dimensions must be in the same order
      they are stored in the field. If the Field dimCount is less than the Mesh
      dimCount then the default gridToFieldMap will contain zeros for the rightmost
      entries. A zero entry in the gridToFieldMap indicates that the particular Mesh
      dimension will be replicating the Field across the DEs along this direction.
    
</DD>
<DT><STRONG>ungriddedLBound</STRONG></DT>
<DD>Lower bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedLBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>ungriddedUBound</STRONG></DT>
<DD>Upper bounds of the ungridded dimensions of the field. The number of elements
      in the ungriddedUBound is equal to the number of ungridded dimensions in the
      field. All ungridded dimensions of the field are also undistributed. When field
      dimension count is greater than grid dimension count, both ungriddedLBound and
      ungriddedUBound must be specified. When both are specified the values are
      checked for consistency. Note that the the ordering of these ungridded
      dimensions is the same as their order in the field.  
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the newly created field.  If not specified, i.e. NULL,
      a default unique name will be generated: "FieldNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05022200000000000000">
16.2.2 ESMC_FieldDestroy - Destroy a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_FieldDestroy(
   ESMC_Field *field     // inout
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Releases all resources associated with this <TT>ESMC_Field</TT>.
      Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Destroy contents of this <TT>ESMC_Field</TT>.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05022300000000000000">
16.2.3 ESMC_FieldGetArray - Get the internal Array stored in the Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> ESMC_Array ESMC_FieldGetArray(
   ESMC_Field field,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The ESMC_Array object stored in the ESMC_Field.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get the internal Array stored in the <TT>ESMC_Field</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Get the internal Array stored in this <TT>ESMC_Field</TT>.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05022400000000000000">
16.2.4 ESMC_FieldGetMesh - Get the internal Mesh stored in the Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> ESMC_Mesh ESMC_FieldGetMesh(
   ESMC_Field field,     // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The ESMC_Mesh object stored in the ESMC_Field.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get the internal Mesh stored in the <TT>ESMC_Field</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Get the internal Mesh stored in this <TT>ESMC_Field</TT>.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05022500000000000000">
16.2.5 ESMC_FieldGetPtr - Get the internal Fortran data pointer stored in the Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> void *ESMC_FieldGetPtr(
   ESMC_Field field,     // in
   int localDe,          // in
   int *rc               // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    The Fortran data pointer stored in the ESMC_Field.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get the internal Fortran data pointer stored in the <TT>ESMC_Field</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Get the internal Fortran data pointer stored in this <TT>ESMC_Field</TT>.
    
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local DE for which information is requested. <TT>[0,..,localDeCount-1]</TT>. 
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05022600000000000000">
16.2.6 ESMC_FieldPrint - Print the internal information of a Field</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_FieldPrint(
   ESMC_Field field      // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print the internal information within this <TT>ESMC_Field</TT>.
      Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.

<P>
The arguments are:
    <DL>
<DT><STRONG>field</STRONG></DT>
<DD>Print contents of this <TT>ESMC_Field</TT>.
    
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05030000000000000000">
17 Array Class</A>
</H1>

<P>

<H2><A NAME="SECTION05031000000000000000">
17.1 Description</A>
</H2>

<P>
The Array class is an alternative to the Field class for representing 
distributed, structured data.  Unlike Fields, which are built to carry 
grid coordinate information, Arrays can only carry information about the 
<I>indices</I> associated with grid cells.  Since they do not have coordinate 
information, Arrays cannot be used to calculate interpolation weights.  
However, if the user can supply interpolation weights, the Array sparse 
matrix multiply operation can be used to apply the weights and transfer 
data to the new grid.  Arrays can also perform redistribution, scatter, 
and gather communication operations.

<P>
Like Fields, Arrays can be added to a State and used in inter-Component 
data communications.

<P>
From a technical standpoint, the ESMF Array class is an index space 
based, distributed data storage class. It provides DE-local memory allocations 
within DE-centric index regions and defines the relationship to the index 
space described by the ESMF DistGrid. The Array class offers common 
communication patterns within the index space formalism.

<P>

<H2><A NAME="SECTION05032000000000000000">
17.2 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05032100000000000000">
17.2.1 ESMC_ArrayCreate - Create an Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> ESMC_Array ESMC_ArrayCreate(
   ESMC_ArraySpec arrayspec,   // in
   ESMC_DistGrid distgrid,     // in
   const char* name,           // in
   int *rc                     // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_Array object.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD><TT>ESMC_ArraySpec</TT> object containing the type/kind/rank information.
    
</DD>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMC_DistGrid</TT> object that describes how the Array is decomposed and
      distributed over DEs. The dimCount of distgrid must be smaller or equal
      to the rank specified in arrayspec, otherwise a runtime ESMF error will be
      raised.
    
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The name for the Array object. If not specified, i.e. NULL,
      a default unique name will be generated: "ArrayNNN" where NNN
      is a unique sequence number from 001 to 999.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05032200000000000000">
17.2.2 ESMC_ArrayDestroy - Destroy an Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_ArrayDestroy(
   ESMC_Array *array           // inout
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMC_Array</TT> object to be destroyed.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05032300000000000000">
17.2.3 ESMC_ArrayGetName - Get the name of an Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> const char *ESMC_ArrayGetName(
   ESMC_Array array,           // in
   int *rc                     // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Pointer to the Array name string.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get the name of the specified <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMC_Array</TT> object to be queried.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05032400000000000000">
17.2.4 ESMC_ArrayGetPtr - Get pointer to Array data.</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> void *ESMC_ArrayGetPtr(
   ESMC_Array array,           // in
   int localDe,                // in
   int *rc                     // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Pointer to the Array data.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Get pointer to the data of the specified <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMC_Array</TT> object to be queried.
    
</DD>
<DT><STRONG>localDe</STRONG></DT>
<DD>Local De for which to data pointer is queried.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05032500000000000000">
17.2.5 ESMC_ArrayPrint - Print an Array</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_ArrayPrint(
   ESMC_Array array            // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMC_Array</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>array</STRONG></DT>
<DD><TT>ESMC_Array</TT> object to be printed.
    
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05040000000000000000">
18 ArraySpec Class</A>
</H1>

<P>

<H2><A NAME="SECTION05041000000000000000">
18.1 Description</A>
</H2>

<P>
An ArraySpec is a very simple class that contains type, kind, and
rank information about an Array.  This information is stored in two
parameters.  <B>TypeKind</B> describes the data type of the elements
in the Array and their precision.  <B>Rank</B> is the number of dimensions
in the Array.

<P>
The only methods that are associated with the ArraySpec class are those 
that allow you to set and retrieve this information.

<P>

<P>

<H2><A NAME="SECTION05042000000000000000">
18.2 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05042100000000000000">
18.2.1 ESMC_ArraySpecGet - Get values from an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_ArraySpecGet(
   ESMC_ArraySpec arrayspec,         // inout
   int *rank,                        // in
   enum ESMC_TypeKind *typekind      // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns information about the contents of an <TT>ESMC_ArraySpec</TT>.

<P>
The arguments are:
    <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMC_ArraySpec</TT> to query.
    
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum allowed is 7D.
    
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind. See section ?? for valid values.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05042200000000000000">
18.2.2 ESMC_ArraySpecSet - Set values for an ArraySpec</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_ArraySpecSet(
   ESMC_ArraySpec *arrayspec,         // inout 
   int rank,                          // in
   enum ESMC_TypeKind typekind        // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set an Array specification - typekind, and rank.

<P>
The arguments are:
    <DL>
<DT><STRONG>arrayspec</STRONG></DT>
<DD>The <TT>ESMC_ArraySpec</TT> to set.
    
</DD>
<DT><STRONG>rank</STRONG></DT>
<DD>Array rank (dimensionality - 1D, 2D, etc). Maximum allowed is 7D.
    
</DD>
<DT><STRONG>typekind</STRONG></DT>
<DD>Array typekind. See section ?? for valid values.
    
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05050000000000000000">
19 Mesh Class</A>
</H1>

<P>

<H2><A NAME="SECTION05051000000000000000">
19.1 Description</A>
</H2>

<P>
Unstructured grids are commonly used in the computational solution of Partial Differential equations.  These are especially useful for problems that involve complex geometry, where using the less flexible structured grids can
result in grid representation of regions where no computation is needed.  Finite
element and finite volume methods map naturally to unstructured grids and are used commonly
in hydrology, ocean modeling, and many other applications.

<P>
In order to provide support for application codes using unstructured grids, the ESMF library provides a class for representing 
unstructured grids called the <B>Mesh</B>. Fields can be created on a Mesh to hold data. In Fortran, Fields created on a Mesh can also be used 
as either the source or destination or both of an interpolaton (i.e. an <TT>ESMF_FieldRegridStore()</TT> call). This capability is currently
not supported with the C interface, however, if the C Field is passed via a State to a component written in Fortran then the regridding
can be performed there. The rest of this section describes the Mesh class and how to create and use them in ESMF. 

<P>

<H3><A NAME="SECTION05051100000000000000">
19.1.1 Mesh Representation in ESMF</A>
</H3>

<P>
A Mesh in ESMF is described in terms of <B>nodes</B> and <B>elements</B>. A node is a point in space which represents where the coordinate 
information in a Mesh is located. An element is a higher dimensional shape constructed of nodes. Elements give a Mesh its shape and define the relationship of the nodes to one another. Field data may be located on a Mesh's nodes. 

<P>

<H3><A NAME="SECTION05051200000000000000">
19.1.2 Supported Meshes</A>
</H3>

<P>
The range of Meshes supported by ESMF are defined by several factors: dimension, element types, and distribution.

<P>
ESMF currently only supports Meshes whose number of coordinate dimensions (spatial dimension) is 2 or 3. The dimension of the elements in a Mesh
(parametric dimension) must be less than or equal to the spatial dimension, but also must be either 2 or 3. This means that an ESMF mesh may be
either 2D elements in 2D space, 3D elements in 3D space, or a manifold constructed of 2D elements embedded in 3D space. 

<P>
ESMF currently supports two types of elements for each Mesh parametric dimension. For a parametric dimension of 2 the 
supported element types are triangles or quadralaterals. For a parametric dimension of 3 the supported element types are tetrahedrons
and hexahedrons. See Section&nbsp;<A HREF="node5.html#const:meshelemtype">19.2.1</A> for diagrams of these. The Mesh supports any combination of element types within a particular
dimension, but types from different dimensions may not be mixed, for example, a Mesh cannot be constructed of both quadralaterals and tetrahedra.

<P>
ESMF currently only supports distributions where every node on a PET must be a part of an element on that PET. In other words, there 
must not be nodes without an element on a PET. 

<P>

<H2><A NAME="SECTION05052000000000000000">
19.2 Constants</A>
</H2>

<P>

<H3><A NAME="SECTION05052100000000000000"></A>
<A NAME="const:meshelemtype"></A>
<BR>
19.2.1 ESMC_MESHELEMTYPE
</H3>

<P>
<I>DESCRIPTION:
<BR></I>
 An ESMF Mesh can be constructed from a combination of different elements. The type of elements that can
be used in a Mesh depends on the Mesh's parameteric dimension, which is set during Mesh creation. The
following are the valid Mesh element types for each valid Mesh parametric dimension (2D or 3D) .

<P>

<P>
<BR>

<P>
<PRE>
                     3                          4 ---------- 3
                    / \                         |            |  
                   /   \                        |            |
                  /     \                       |            |
                 /       \                      |            |
                /         \                     |            |
               1 --------- 2                    1 ---------- 2

           ESMC_MESHELEMTYPE_TRI            ESMC_MESHELEMTYPE_QUAD

2D element types (numbers are the order for elementConn during 
                  Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 2 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMC_MESHELEMTYPE_TRI</TD>
<TD ALIGN="CENTER">3</TD>
<TD ALIGN="LEFT">A triangle</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMC_MESHELEMTYPE_QUAD</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A quadrilateral (e.g. a rectangle)</TD>
</TR>
</TABLE>

<P>

<P>
<BR>

<P>
<BR>

<P>
<PRE>
                                            
                 3                               8---------------7
                /|\                             /|              /|
               / | \                           / |             / |
              /  |  \                         /  |            /  |
             /   |   \                       /   |           /   |
            /    |    \                     5---------------6    |
           4-----|-----2                    |    |          |    |
            \    |    /                     |    4----------|----3
             \   |   /                      |   /           |   /
              \  |  /                       |  /            |  /
               \ | /                        | /             | /
                \|/                         |/              |/
                 1                          1---------------2

       ESMC_MESHELEMTYPE_TETRA             ESMC_MESHELEMTYPE_HEX  

3D element types (numbers are the order for elementConn during 
                  Mesh create)
</PRE>

<P>
For a Mesh with parametric dimension of 3 the valid element types (illustrated above) are:

<P>

<P></P>

<P>
<TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Element Type</TD>
<TD ALIGN="CENTER">Number of Nodes</TD>
<TD ALIGN="LEFT">Description</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMC_MESHELEMTYPE_TETRA</TD>
<TD ALIGN="CENTER">4</TD>
<TD ALIGN="LEFT">A tetrahedron (CAN'T BE USED IN REGRID)</TD>
</TR>
<TR><TD ALIGN="LEFT">ESMC_MESHELEMTYPE_HEX</TD>
<TD ALIGN="CENTER">8</TD>
<TD ALIGN="LEFT">A hexahedron (e.g. a cube)</TD>
</TR>
</TABLE>

<P>

<P>

<H2><A NAME="SECTION05053000000000000000">
19.3 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05053100000000000000"></A><A NAME="sec:mesh:capi:meshaddelements"></A>
<BR>
19.3.1 ESMC_MeshAddElements - Add elements to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_MeshAddElements(
   ESMC_Mesh mesh,           // inout 
   int  elementCount,        // in
   int *elementIds,          // in
   int *elementTypes,        // in
   int *elementConn          // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the third and last part of the three part mesh create
     sequence and should be called after the mesh is created with <TT>ESMF_MeshCreate()</TT>
     (<A HREF="node5.html#sec:mesh:capi:meshcreate">19.3.3</A>)
     and after the nodes are added with <TT>ESMF_MeshAddNodes()</TT> (<A HREF="node5.html#sec:mesh:capi:meshaddnodes">19.3.2</A>).
     This call adds the elements to the
     mesh and finalizes the create. After this call the Mesh is usable, for
     example a Field may be built on the created Mesh object and
     this Field may be used in a <TT>ESMF_FieldRegridStore()</TT> call.

<P>
The parameters to this call <TT>elementIds</TT>, <TT>elementTypes</TT>, and
     <TT>elementConn</TT> describe the elements to be created. The description
     for a particular element lies at the same index location in <TT>elementIds</TT>
     and <TT>elementTypes</TT>. Each entry in <TT>elementConn</TT> consists of the list of
     nodes used to create that element, so the connections for element <IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img8.png"
 ALT="$e$"> in the
     <TT>elementIds</TT> array will start at <!-- MATH
 $number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
     \cdots + number\_of\_nodes\_in\_element(e-1) + 1$
 -->
<IMG
 WIDTH="842" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$number\_of\_nodes\_in\_element(1) + number\_of\_nodes\_in\_element(2) +
\cdots + number\_of\_nodes\_in\_element(e-1) + 1$"> in <TT>elementConn</TT>.

<P>
<DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object.        
     
</DD>
<DT><STRONG>elementCount</STRONG></DT>
<DD>The number of elements on this PET. 
     
</DD>
<DT><STRONG>elementIds</STRONG></DT>
<DD>An array containing the global ids of the elements to be created on this PET.
            This input consists of a 1D array of size <TT>elementCount</TT>.
     
</DD>
<DT><STRONG>elementTypes</STRONG></DT>
<DD>An array containing the types of the elements to be created on this PET. The types used
            must be appropriate for the parametric dimension of the Mesh. Please see
            Section&nbsp;<A HREF="#sec:mesh:opt:elemtype"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for the list of options. This 
            input consists of a 1D array of size <TT>elementCount</TT>.
     
</DD>
<DT><STRONG>elementConn</STRONG></DT>
<DD>An array containing the indexes of the sets of nodes to be connected together to form the
           elements to be created on this PET. The entries in this list are NOT node global ids,
           but rather each entry is a local index (1 based) into the list of nodes which were
           created on this PET by the previous <TT>ESMC_MeshAddNodes()</TT> call.
           In other words, an entry of 1 indicates that this element contains the node
           described by <TT>nodeIds(1)</TT>, <TT>nodeCoords(1)</TT>, etc. passed into the
           <TT>ESMC_MeshAddNodes()</TT> call on this PET. It is also
           important to note that the order of the nodes in an element connectivity list
           matters. Please see Section&nbsp;<A HREF="#sec:mesh:opt:elemtype"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]" SRC="crossref.png"></A> for diagrams illustrating
           the correct order of nodes in a element. This input consists of a 1D array with
           a total size equal to the sum of the number of nodes in each element on
           this PET. The number of nodes in each element is implied by its element type in
           <TT>elementTypes</TT>. The nodes for each element
           are in sequence in this array (e.g. the nodes for element 1 are elementConn(1),
           elementConn(2), etc.).
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05053200000000000000"></A><A NAME="sec:mesh:capi:meshaddnodes"></A>
<BR>
19.3.2 ESMC_MeshAddNodes - Add nodes to a Mesh 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_MeshAddNodes(
   ESMC_Mesh mesh,          // inout
   int nodeCount,           // in
   int *nodeIds,            // in
   double *nodeCoords,      // in
   int *nodeOwners          // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the second part of the three part mesh create
     sequence and should be called after the mesh's dimensions are set
     using <TT>ESMC_MeshCreate()</TT>.
     This call adds the nodes to the
     mesh. The next step is to call <TT>ESMC_MeshAddElements()</TT> (<A HREF="node5.html#sec:mesh:capi:meshcreate">19.3.3</A>).

<P>
The parameters to this call <TT>nodeIds</TT>, <TT>nodeCoords</TT>, and
     <TT>nodeOwners</TT> describe the nodes to be created on this PET.
     The description for a particular node lies at the same index location in
     <TT>nodeIds</TT> and <TT>nodeOwners</TT>. Each entry
     in <TT>nodeCoords</TT> consists of spatial dimension coordinates, so the coordinates
     for node <IMG
 WIDTH="16" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img10.png"
 ALT="$n$"> in the <TT>nodeIds</TT> array will start at <!-- MATH
 $(n-1)*spatialDim+1$
 -->
<IMG
 WIDTH="179" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$(n-1)*spatialDim+1$">.

<P>
<DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object.
     
</DD>
<DT><STRONG>nodeCount</STRONG></DT>
<DD>The number of nodes on this PET. 
     
</DD>
<DT><STRONG>nodeIds</STRONG></DT>
<DD>An array containing the global ids of the nodes to be created on this PET. 
          This input consists of a 1D array the size of the number of nodes on this PET (i.e. <TT>nodeCount</TT>).
     
</DD>
<DT><STRONG>nodeCoords</STRONG></DT>
<DD>An array containing the physical coordinates of the nodes to be created on this
            PET. The coordinates in this array are ordered
            so that the coordinates for a node lie in sequence in memory. (e.g. for a
            Mesh with spatial dimension 2, the coordinates for node 1 are in nodeCoords(0) and
            nodeCoords(1), the coordinates for node 2 are in nodeCoords(2) and nodeCoords(3),
            etc.). This input consists of a 1D array the size of <TT>nodeCount</TT> times the Mesh's
            spatial dimension (<TT>spatialDim</TT>).
     
</DD>
<DT><STRONG>nodeOwners</STRONG></DT>
<DD>An array containing the PETs that own the nodes to be created on this PET.
           If the node is shared with another PET, the value
           may be a PET other than the current one. Only nodes owned by this PET
           will have PET local entries in a Field created on the Mesh. This 
           input consists of a 1D array the size of the number of nodes on this PET (i.e. <TT>nodeCount</TT>).
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05053300000000000000"></A><A NAME="sec:mesh:capi:meshcreate"></A>
<BR>
19.3.3 ESMC_MeshCreate - Create a Mesh as a 3 step process 
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> ESMC_Mesh ESMC_MeshCreate(
   int parametricDim,         // in
   int spatialDim,            // in
   int *rc                    // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    type(ESMC_Mesh)         :: ESMC_MeshCreate
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call is the first part of the three part mesh create sequence. This call sets the dimension of the elements 
    in the mesh (<TT>parametricDim</TT>) and the number of coordinate dimensions in the mesh (<TT>spatialDim</TT>). 
    The next step is to call <TT>ESMC_MeshAddNodes()</TT> (<A HREF="node5.html#sec:mesh:capi:meshaddnodes">19.3.2</A>) to add the nodes and then 
    <TT>ESMC_MeshAddElements(</TT>)  (<A HREF="node5.html#sec:mesh:capi:meshaddelements">19.3.1</A>) 
    to add the elements and finalize the mesh. 

<P>
The arguments are:
    <DL>
<DT><STRONG>parametricDim</STRONG></DT>
<DD>Dimension of the topology of the Mesh. (E.g. a mesh constructed of squares would have a parametric dimension 
      of 2, whereas a Mesh constructed of cubes would have one of 3.)
    
</DD>
<DT><STRONG>spatialDim</STRONG></DT>
<DD>The number of coordinate dimensions needed to describe the locations of the nodes making up the Mesh. For a 
    manifold, the spatial dimesion can be larger than the parametric dim (e.g. the 2D 
    surface of a sphere in 3D space), 
     but it can't be smaller. 
    
</DD>
<DT><STRONG>rc</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors. 
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05053400000000000000">
19.3.4 ESMC_MeshDestroy - Destroy a Mesh</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_MeshDestroy(
   ESMC_Mesh *mesh             // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy the Mesh. This call removes all internal memory associated with <TT>mesh</TT>. After this call mesh will no longer be usable. 

<P>
The arguments are:
    <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object whose memory is to be freed. 
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05053500000000000000">
19.3.5 ESMC_MeshFreeMemory - Remove a Mesh and its memory</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_MeshFreeMemory(
   ESMC_Mesh mesh            // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
This call removes the portions of <TT>mesh</TT> which contain connection and coordinate
      information. After this call, Fields build on <TT>mesh</TT> will no longer be usable
      as part of an <TT>ESMF_FieldRegridStore()</TT> operation. However, after this call
      Fields built on <TT>mesh</TT> can still be used in an <TT>ESMF_FieldRegrid()</TT>
      operation if the routehandle was generated beforehand. New Fields may also
      be built on <TT>mesh</TT> after this call.

<P>
The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>Mesh object whose memory is to be freed.
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05053600000000000000">
19.3.6 ESMC_MeshGetLocalElementCount - Get the number of elements in a Mesh owned by the current PET</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_MeshGetLocalElementCount(
   ESMC_Mesh mesh,           // in
   int *elementCount         // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query the number of elements in a mesh owned by the local PET.
   The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>The mesh
   
</DD>
<DT><STRONG>elementCount</STRONG></DT>
<DD>The number of elements on this PET. 
   
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05053700000000000000">
19.3.7 ESMC_MeshGetLocalNodeCount - Get the number of nodes in a Mesh owned by the current PET</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_MeshGetLocalNodeCount(
   ESMC_Mesh mesh,          // in
   int *nodeCount           // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Query the number of nodes in a mesh owned by the local PET.
   The arguments are:
   <DL>
<DT><STRONG>mesh</STRONG></DT>
<DD>The mesh
   
</DD>
<DT><STRONG>nodeCount</STRONG></DT>
<DD>The number of nodes on this PET. 
   
</DD>
</DL>

<P>

<P>

<P>

<H1><A NAME="SECTION05060000000000000000">
20 DistGrid Class</A>
</H1>

<P>

<H2><A NAME="SECTION05061000000000000000">
20.1 Description</A>
</H2>

<P>
<A NAME="sec:DistGrid"></A>The ESMF DistGrid class sits on top of the DELayout class (not currently
directly accessible through the ESMF C API) and holds domain
information in index space. 
A DistGrid object captures the index space topology
and describes its decomposition in terms of DEs. Combined with DELayout and VM
the DistGrid defines the data distribution of a domain decomposition across the
computational resources of an ESMF Component.

<P>
The global domain is defined as the union or ``tilework'' of logically
rectangular (LR) sub-domains or <EM>tiles</EM>. The DistGrid create methods allow
the specification of such a tilework global domain and its decomposition into
exclusive, DE-local LR regions according to various degrees of user specified
constraints. Complex index space topologies can be constructed by specifying
connection relationships between tiles during creation.

<P>
The DistGrid class holds domain information for all DEs. Each DE is associated
with a local LR region. No overlap of the regions is allowed. The DistGrid
offers query methods that allow DE-local topology information to be extracted,
e.g. for the construction of halos by higher classes.

<P>
A DistGrid object only contains decomposable dimensions. The minimum rank for a
DistGrid object is 1. A maximum rank does not exist for DistGrid objects, 
however, ranks greater than 7 may lead to difficulties with respect to the
Fortran API of higher classes based on DistGrid. The rank of a DELayout object
contained within a DistGrid object must be equal to the DistGrid rank. Higher
class objects that use the DistGrid, such as an Array object, may be of
different rank than the associated DistGrid object. The higher class object
will hold the mapping information between its dimensions and the DistGrid
dimensions.

<P>

<H2><A NAME="SECTION05062000000000000000">
20.2 Class API</A>
</H2>

<P>

<P>

<P>

<H3><A NAME="SECTION05062100000000000000">
20.2.1 ESMC_DistGridCreate - Create a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> ESMC_DistGrid ESMC_DistGridCreate(
   ESMC_InterfaceInt minIndexInterfaceArg,   // in
   ESMC_InterfaceInt maxIndexInterfaceArg,   // in
   int *rc                                   // out
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Newly created ESMC_DistGrid object.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Create an <TT>ESMC_DistGrid</TT> from a single logically rectangular (LR) 
    tile with default decomposition. The default decomposition is 
    <TT>deCount</TT><!-- MATH
 $\times 1 \times ... \times 1$
 -->
<IMG
 WIDTH="87" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img12.png"
 ALT="$ \times 1 \times ... \times 1$">, where <TT>deCount</TT> is the
    number of DEs in a default DELayout, equal to <TT>petCount</TT>. This means
    that the default decomposition will be into as many DEs as there are PETs,
    with 1 DE per PET.

<P>
The arguments are:
    <DL>
<DT><STRONG>minIndex</STRONG></DT>
<DD>Global coordinate tuple of the lower corner of the tile.
    
</DD>
<DT><STRONG>maxIndex</STRONG></DT>
<DD>Global coordinate tuple of the upper corner of the tile.
    
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05062200000000000000">
20.2.2 ESMC_DistGridDestroy - Destroy a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_DistGridDestroy(
   ESMC_DistGrid *distgrid         // inout
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Destroy an <TT>ESMC_DistGrid</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMC_DistGrid</TT> object to be destroyed.
    
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION05062300000000000000">
20.2.3 ESMC_DistGridPrint - Print a DistGrid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE> int ESMC_DistGridPrint(
   ESMC_DistGrid distgrid          // in
 );
</PRE><EM>RETURN VALUE:</EM>
<PRE>    Return code; equals ESMF_SUCCESS if there are no errors.
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Print internal information of the specified <TT>ESMC_DistGrid</TT> object.

<P>
The arguments are:
    <DL>
<DT><STRONG>distgrid</STRONG></DT>
<DD><TT>ESMC_DistGrid</TT> object to be destroyed.
    
</DD>
</DL>

<P>

<P>

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html441"
  HREF="node6.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html437"
  HREF="ESMC_crefdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html431"
  HREF="node4.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html439"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html442"
  HREF="node6.html">5 Infrastructure: Utilities</A>
<B> Up:</B> <A NAME="tex2html438"
  HREF="ESMC_crefdoc.html">ESMC_crefdoc</A>
<B> Previous:</B> <A NAME="tex2html432"
  HREF="node4.html">3 Superstructure</A>
 &nbsp <B>  <A NAME="tex2html440"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
