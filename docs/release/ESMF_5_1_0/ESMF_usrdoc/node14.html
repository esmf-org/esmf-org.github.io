<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002 (1.67)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>13 ESMF COUPLED_FLOW Demonstration Code Details</TITLE>
<META NAME="description" CONTENT="13 ESMF COUPLED_FLOW Demonstration Code Details">
<META NAME="keywords" CONTENT="ESMF_usrdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2002">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_usrdoc.css">

<LINK REL="next" HREF="node15.html">
<LINK REL="previous" HREF="node13.html">
<LINK REL="up" HREF="ESMF_usrdoc.html">
<LINK REL="next" HREF="node15.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html488"
  HREF="node15.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html484"
  HREF="ESMF_usrdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html478"
  HREF="node13.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html486"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html489"
  HREF="node15.html">14 How to Adapt</A>
<B> Up:</B> <A NAME="tex2html485"
  HREF="ESMF_usrdoc.html">ESMF_usrdoc</A>
<B> Previous:</B> <A NAME="tex2html479"
  HREF="node13.html">12 ESMF COUPLED_FLOW Demonstration</A>
 &nbsp <B>  <A NAME="tex2html487"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html490"
  HREF="node14.html#SECTION000141000000000000000">13.1 Fortran:  Module Interface CoupledFlowApp.F90 - Main program source file for demo (Source File: CoupledFlowApp.F90)</A>
<UL>
<LI><A NAME="tex2html491"
  HREF="node14.html#SECTION000141100000000000000">13.1.1 Namelist Input Parameters for CoupledFlowApp:</A>
<LI><A NAME="tex2html492"
  HREF="node14.html#SECTION000141200000000000000">13.1.2 Example of Initializing the Framework:</A>
<LI><A NAME="tex2html493"
  HREF="node14.html#SECTION000141300000000000000">13.1.3 Example of Calendar and Clock Creation and Usage:</A>
<LI><A NAME="tex2html494"
  HREF="node14.html#SECTION000141400000000000000">13.1.4 Example of Grid Creation:</A>
<LI><A NAME="tex2html495"
  HREF="node14.html#SECTION000141500000000000000">13.1.5 Example of State Creation:</A>
<LI><A NAME="tex2html496"
  HREF="node14.html#SECTION000141600000000000000">13.1.6 Example of Initialize, Run, and Finalize:</A>
<LI><A NAME="tex2html497"
  HREF="node14.html#SECTION000141700000000000000">13.1.7 Example of Object Destruction:</A>
<LI><A NAME="tex2html498"
  HREF="node14.html#SECTION000141800000000000000">13.1.8 Example of ESMF Finalize:</A>
</UL>
<BR>
<LI><A NAME="tex2html499"
  HREF="node14.html#SECTION000142000000000000000">13.2 Fortran:  Module Interface CoupledFlowDemo.F90 - Top level Gridded Component source (Source File: CoupledFlowDemo.F90)</A>
<UL>
<LI><A NAME="tex2html500"
  HREF="node14.html#SECTION000142100000000000000">13.2.1 Example of Set Services Usage:</A>
<LI><A NAME="tex2html501"
  HREF="node14.html#SECTION000142200000000000000">13.2.2 Example of Component Creation:</A>
<LI><A NAME="tex2html502"
  HREF="node14.html#SECTION000142300000000000000">13.2.3 Example of State Creation:</A>
<LI><A NAME="tex2html503"
  HREF="node14.html#SECTION000142400000000000000">13.2.4 Example of Time Stepping Loop:</A>
<LI><A NAME="tex2html504"
  HREF="node14.html#SECTION000142500000000000000">13.2.5 Example of Clock Destruction:</A>
</UL>
<BR>
<LI><A NAME="tex2html505"
  HREF="node14.html#SECTION000143000000000000000">13.3 Fortran:  Module Interface FlowSolverMod.F90 - Source file for Flow Solver Component (Source File: FlowSolverMod.F90)</A>
<UL>
<LI><A NAME="tex2html506"
  HREF="node14.html#SECTION000143100000000000000">13.3.1 Namelist Input Parameters for Flowsolver:</A>
<LI><A NAME="tex2html507"
  HREF="node14.html#SECTION000143200000000000000">13.3.2 Example of FieldHalo Usage:</A>
</UL>
<BR>
<LI><A NAME="tex2html508"
  HREF="node14.html#SECTION000144000000000000000">13.4 Fortran:  Module Interface FlowArraysMod.F90 - Source file for Data for Flow Solver (Source File: FlowArraysMod.F90)</A>
<UL>
<LI><A NAME="tex2html509"
  HREF="node14.html#SECTION000144100000000000000">13.4.1 Example of Field Creation and Array Usage:</A>
</UL>
<BR>
<LI><A NAME="tex2html510"
  HREF="node14.html#SECTION000145000000000000000">13.5 Fortran:  Module Interface CouplerMod.F90 - Source for 2-way Coupler Component (Source File: CouplerMod.F90)</A>
<UL>
<LI><A NAME="tex2html511"
  HREF="node14.html#SECTION000145100000000000000">13.5.1 Example of Redist Usage:</A>
</UL>
<BR>
<LI><A NAME="tex2html512"
  HREF="node14.html#SECTION000146000000000000000">13.6 Fortran:  Module Interface InjectorMod - Fluid Injection Component (Source File: InjectorMod.F90)</A>
<UL>
<LI><A NAME="tex2html513"
  HREF="node14.html#SECTION000146100000000000000">13.6.1 Namelist Input Parameters for Injector:</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION000140000000000000000">
13 ESMF COUPLED_FLOW Demonstration Code Details</A>
</H1>

<P>

<P>

<P>

<P>

<H2><A NAME="SECTION000141000000000000000">
13.1 Fortran:  Module Interface CoupledFlowApp.F90 - Main program source file for demo (Source File: CoupledFlowApp.F90)</A>
</H2>

<P>
ESMF Application Wrapper for Coupled Flow Demo.  This file contains the
    main program, and creates a top level ESMF Gridded Component to contain
    all other Components.

<P>

<H3><A NAME="SECTION000141100000000000000">
13.1.1 Namelist Input Parameters for CoupledFlowApp:</A>
</H3>
       The following variables must be input to the CoupledFlow Application to
       run.  They are located in a file called "coupled_app_input."

<P>
The variables are:
       <DL>
<DT><STRONG>i_max</STRONG></DT>
<DD>Global number of cells in the first grid direction.
       
</DD>
<DT><STRONG>j_max</STRONG></DT>
<DD>Global number of cells in the second grid direction.
       
</DD>
<DT><STRONG>x_min</STRONG></DT>
<DD>Minimum grid coordinate in the first direction.
       
</DD>
<DT><STRONG>x_max</STRONG></DT>
<DD>Maximum grid coordinate in the first direction.
       
</DD>
<DT><STRONG>y_min</STRONG></DT>
<DD>Minimum grid coordinate in the second direction.
       
</DD>
<DT><STRONG>y_max</STRONG></DT>
<DD>Maximum grid coordinate in the second direction.
       
</DD>
<DT><STRONG>s_month</STRONG></DT>
<DD>Simulation start time month (integer).
       
</DD>
<DT><STRONG>s_day</STRONG></DT>
<DD>Simulation start time day (integer).
       
</DD>
<DT><STRONG>s_hour</STRONG></DT>
<DD>Simulation start time hour (integer).
       
</DD>
<DT><STRONG>s_min</STRONG></DT>
<DD>Simulation start time minute (integer).
       
</DD>
<DT><STRONG>e_month</STRONG></DT>
<DD>Simulation end time month (integer).
       
</DD>
<DT><STRONG>e_day</STRONG></DT>
<DD>Simulation end time day (integer).
       
</DD>
<DT><STRONG>e_hour</STRONG></DT>
<DD>Simulation end time hour (integer).
       
</DD>
<DT><STRONG>e_min</STRONG></DT>
<DD>Simulation end time minute (integer).
       
</DD>
</DL>

<P>

<H3><A NAME="SECTION000141200000000000000">
13.1.2 Example of Initializing the Framework:</A>
</H3>

<P>
The first call to ESMF must be the initialize method.   As part of
       initialization the default Calendar can be specified, some options
       for logging can be set, and the default global VM can be returned.
       Here we are setting the default Calendar to be Gregorian, and getting
       back the global VM: 

<P>
<PRE>
    ! Initialize ESMF, get the default Global VM, and set
    ! the default calendar to be Gregorian.
    call ESMF_Initialize(vm=vm, defaultCalendar=ESMF_CAL_GREGORIAN, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>
<PRE>
    ! Create the top level Gridded Component.
    compGridded = ESMF_GridCompCreate(name="Coupled Flow Demo", rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION000141300000000000000">
13.1.3 Example of Calendar and Clock Creation and Usage:</A>
</H3>

<P>
The following piece of code provides an example of Clock creation used in
       the Demo.  Note that the Gregorian calendar was set as the default in
       the ESMF_Initialize() call above.  As shown in this example, we first
       initialize a time interval (timestep) to 2 seconds: 

<P>
<PRE>
      call ESMF_TimeIntervalSet(timeStep, s=2, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      !And then we set the start time and stop time to input values for the month,
      !day, and hour (assuming the year to be 2003):
      call ESMF_TimeSet(startTime, yy=2003, mm=s_month, dd=s_day, &amp;
                        h=s_hour, m=s_min, s=0, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

      call ESMF_TimeSet(stopTime, yy=2003, mm=e_month, dd=e_day, &amp;
                        h=e_hour, m=e_min, s=0, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      !With the time interval, start time, and stop time set above, the Clock can
      !now be created:
      clock = ESMF_ClockCreate(timeStep=timeStep, startTime=startTime, &amp;
                               stopTime=stopTime, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      !Subsequent calls to ESMF\_ClockAdvance with this clock will increment the
      !current time from the start time by the timestep.
</PRE>

<P>

<H3><A NAME="SECTION000141400000000000000">
13.1.4 Example of Grid Creation:</A>
</H3>

<P>
The following piece of code provides an example of Grid creation used in
    the Demo.  The extents of the Grid were previously read in from an input
    file, but the rest of the Grid parameters are set here by default.  The
    Grid spans the Application's PET list, while the type of the Grid is 
    assumed to be horizontal and Cartesian x-y with an Arakawa C staggering.  
    The Grid name is set to "source grid": 

<P>
<PRE>
      counts(1) = i_max
      counts(2) = j_max
      g_min(1) = x_min
      g_min(2) = y_min
      g_max(1) = x_max
      g_max(2) = y_max
      grid = ESMF_GridCreateShapeTile(maxIndex=counts, &amp;
                             coordDep1=(/1/), &amp;
                             coordDep2=(/2/), &amp;
                             gridEdgeLWidth=(/0,0/), &amp;
                             name="source grid", rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      ! u
      call ESMF_GridAddCoord(grid, staggerLoc=ESMF_STAGGERLOC_EDGE1, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      ! v
      call ESMF_GridAddCoord(grid, staggerLoc=ESMF_STAGGERLOC_EDGE2, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      ! sie, p, q, rho, flag
      call ESMF_GridAddCoord(grid, staggerLoc=ESMF_STAGGERLOC_CENTER, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      ! Get pointer reference to internal coordinate array
      ! Compute center stagger coordinate values
      call ESMF_GridGetCoord(grid, localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, &amp;
        coordDim=1, fptr=CoordX, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      call ESMF_GridGetCoord(grid, localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_CENTER, &amp;
        coordDim=2, fptr=CoordY, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

      dx = (x_max-x_min)/i_max
      dy = (y_max-y_min)/j_max
      coordX(1) = x_min + dx/2
      coordY(1) = y_min + dy/2
      do i = 2, i_max
        coordX(i) = coordX(i-1) + dx
      enddo
      do j = 2, j_max
        coordY(j) = coordY(j-1) + dy
      enddo

      ! Get pointer reference to internal coordinate for U
      ! Compute east stagger (U) coordinate values
      call ESMF_GridGetCoord(grid, localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_EDGE1, &amp;
        coordDim=1, fptr=CoordX, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      call ESMF_GridGetCoord(grid, localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_EDGE1, &amp;
        coordDim=2, fptr=CoordY, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

      dx = (x_max-x_min)/i_max
      dy = (y_max-y_min)/j_max
      coordX(1) = x_min + dx
      coordY(1) = y_min + dy/2
      do i = 2, i_max
        coordX(i) = coordX(i-1) + dx
      enddo
      do j = 2, j_max
        coordY(j) = coordY(j-1) + dy
      enddo

      ! Get pointer reference to internal coordinate for V
      ! Compute north stagger (V) coordinate values
      call ESMF_GridGetCoord(grid, localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_EDGE2, &amp;
        coordDim=1, fptr=CoordX, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      call ESMF_GridGetCoord(grid, localDE=0, &amp;
        staggerLoc=ESMF_STAGGERLOC_EDGE2, &amp;
        coordDim=2, fptr=CoordY, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

      dx = (x_max-x_min)/i_max
      dy = (y_max-y_min)/j_max
      coordX(1) = x_min + dx/2
      coordY(1) = y_min + dy
      do i = 2, i_max
        coordX(i) = coordX(i-1) + dx
      enddo
      do j = 2, j_max
        coordY(j) = coordY(j-1) + dy
      enddo

      !The Grid can then be attached to the Gridded Component with a set call:
      call ESMF_GridCompSet(compGridded, grid=grid, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION000141500000000000000">
13.1.5 Example of State Creation:</A>
</H3>

<P>
Create and initialize a dummy State to use for both import and export. 

<P>
<PRE>
      flowstate = ESMF_StateCreate("Coupled Flow State", rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION000141600000000000000">
13.1.6 Example of Initialize, Run, and Finalize:</A>
</H3>

<P>
Init, Run, and Finalize sections of the Coupled Flow Component: 

<P>
<PRE>
      call ESMF_GridCompInitialize(compGridded, flowstate, flowstate, &amp;
                                                                 clock, rc=rc, userRc=urc)
      print *, "Coupled Flow Component Initialize finished, rc =", rc, urc
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      if(urc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=urc)

      call ESMF_GridCompRun(compGridded, flowstate, flowstate, clock, rc=rc, userRc=urc)
      print *, "Coupled Flow Component Run finished, rc =", rc, urc
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      if(urc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=urc)
 
      call ESMF_GridCompFinalize(compGridded, flowstate, flowstate, clock, rc=rc, userRc=urc)
      print *, "Coupled Flow Component Finalize finished, rc =", rc, urc
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      if(urc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=urc)
</PRE>

<P>

<H3><A NAME="SECTION000141700000000000000">
13.1.7 Example of Object Destruction:</A>
</H3>

<P>
Near the end of the application, call object destroy methods to 
       clean up the objects previously created: 

<P>
<PRE>
      call ESMF_StateDestroy(flowstate, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

      call ESMF_GridDestroy(grid, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

      call ESMF_ClockDestroy(clock, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

      call ESMF_GridCompDestroy(compGridded, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION000141800000000000000">
13.1.8 Example of ESMF Finalize:</A>
</H3>

<P>
<PRE>
      !Call ESMF_Finalize at the end of an ESMF application:
      call ESMF_Finalize(rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<P>

<H2><A NAME="SECTION000142000000000000000">
13.2 Fortran:  Module Interface CoupledFlowDemo.F90 - Top level Gridded Component source (Source File: CoupledFlowDemo.F90)</A>
</H2>

<P>
ESMF Coupled Flow Demo - A Gridded Component which can be called either 
     directly from an Application Driver or nested in a larger application.
     It contains 2 nested subcomponents and 1 Coupler Component which does 
     two-way coupling between the subcomponents.

<P>

<H3><A NAME="SECTION000142100000000000000">
13.2.1 Example of Set Services Usage:</A>
</H3>

<P>
The following code registers with ESMF 
     the subroutines to be called to Init, Run, and Finalize this component. 

<P>
<PRE>
    ! Register the callback routines.

    call ESMF_GridCompSetEntryPoint(comp, ESMF_SETINIT, userRoutine=coupledflow_init, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
    call ESMF_GridCompSetEntryPoint(comp, ESMF_SETRUN, userRoutine=coupledflow_run, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
    call ESMF_GridCompSetEntryPoint(comp, ESMF_SETFINAL, userRoutine=coupledflow_final, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION000142200000000000000">
13.2.2 Example of Component Creation:</A>
</H3>

<P>
The following code creates 2 Gridded Components on the same set of PETs 
     (persistent execution threads) as the top level Component, but each 
     of the Grids useds by these Components will have a different connectivity.
     It also creates a Coupler Component on the same PET set. Each gridded
     component has a Grid attached internally.

<P>
<PRE>
    cnameIN = "Injector model"
    INcomp = ESMF_GridCompCreate(name=cnameIN, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

    cnameFS = "Flow Solver model"
    FScomp = ESMF_GridCompCreate(name=cnameFS, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

    cplname = "Two-way coupler"
    cpl = ESMF_CplCompCreate(name=cplname, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>
Create the Injector Grid: 

<P>
<PRE>
    gridIN = ESMF_GridCreateShapeTile(minIndex=minIndex, maxIndex=maxIndex, &amp;
                             regDecomp=(/ mid, by2 /), &amp;
                             coordDep1=(/1/), &amp;
                             coordDep2=(/2/), &amp;
                             gridEdgeLWidth=(/0,0/), &amp;
                             name="Injector grid", rc=rc)
</PRE>

<P>
Set the Injector Grid in the Injector Component: 

<P>
<PRE>
    call ESMF_GridCompSet(INcomp, grid=gridIN, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>
Create the FlowSolver Grid: 

<P>
<PRE>
    gridFS = ESMF_GridCreateShapeTile(minIndex=minIndex, maxIndex=maxIndex, &amp;
                             regDecomp=(/ quart, by4 /), &amp;
                             coordDep1=(/1/), &amp;
                             coordDep2=(/2/), &amp;
                             gridEdgeLWidth=(/0,0/), &amp;
                             name="Flow Solver grid", rc=rc)
</PRE>

<P>
Set the FlowSolver Grid in the FlowSolver Component: 

<P>
<PRE>
    call ESMF_GridCompSet(FScomp, grid=gridFS, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION000142300000000000000">
13.2.3 Example of State Creation:</A>
</H3>

<P>
The following code creates Import and Export States for the
     Injection subcomponent.  All information being passed between
     subcomponents will be described by these States.

<P>
<PRE>
    INimp = ESMF_StateCreate(statename="Injection Input", statetype=ESMF_STATE_IMPORT, &amp;
        rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
    INexp = ESMF_StateCreate(statename="Injection Feedback", statetype=ESMF_STATE_EXPORT, &amp;
        rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION000142400000000000000">
13.2.4 Example of Time Stepping Loop:</A>
</H3>

<P>
Advancing in time with ESMF clock, the coupled flow component calls
   the run methods of the gridded components and coupler component sequentially: 

<P>
<PRE>
     ! Make our own local copy of the clock
     localclock = ESMF_ClockCreate(clock, rc=rc)
     if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

     print *, "Run Loop Start time"
     call ESMF_ClockPrint(localclock, "currtime string", rc=rc)
     if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)

     do while (.not. ESMF_ClockIsStopTime(localclock, rc))

        ! Run FlowSolver Component
        call ESMF_GridCompRun(FScomp, FSimp, FSexp, localclock, rc=rc, userRc=urc)
        if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
        if(urc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=urc)

        ! Couple export state of FlowSolver to import of Injector
        call ESMF_CplCompRun(cpl, FSexp, INimp, localclock, rc=rc, userRc=urc)
        if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
        if(urc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=urc)
  
        ! Run Injector Component
        call ESMF_GridCompRun(INcomp, INimp, INexp, localclock, rc=rc, userRc=urc)
        if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
        if(urc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=urc)
  
        ! Couple export state of Injector to import of FlowSolver
        call ESMF_CplCompRun(cpl, INexp, FSimp, localclock, rc=rc, userRc=urc)
        if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
        if(urc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=urc)
  
        ! Advance the time
        call ESMF_ClockAdvance(localclock, rc=rc)
        if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
      
        ! This demo runs a lot of time steps and only outputs files
        ! every N iterations.  This print statement, if commented in,
        ! generates a lot of output.
        !call ESMF_ClockPrint(localclock, "currtime string", rc)

     enddo

     print *, "Run Loop End time"
     call ESMF_ClockPrint(localclock, "currtime string", rc=rc)
     if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<H3><A NAME="SECTION000142500000000000000">
13.2.5 Example of Clock Destruction:</A>
</H3>

<P>
At the end of run method, destroy the clock used to iterate through time: 

<P>
<PRE>
     call ESMF_ClockDestroy(localclock, rc)
     if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<P>

<H2><A NAME="SECTION000143000000000000000">
13.3 Fortran:  Module Interface FlowSolverMod.F90 - Source file for Flow Solver Component (Source File: FlowSolverMod.F90)</A>
</H2>

<P>
This component does a finite difference solution of the PDE's for
    semi-compressible fluid flow.  It uses an explicit solution
    method on a staggered mesh with velocities and momentum located at cell
    faces and other physical quantities at cell centers.  The component
    assumes a logically rectangular two-dimensional Cartesian mesh with
    constant cell spacing.  It also employs a donor-cell advection scheme.
    Although the algorithm is general, the boundary conditions are coded to
    assume constant inflow on the left, outflow on the right, and free-slip
    insulated boundaries on the top and bottom.  This component will allow
    the user to construct flow obstacles with different energies, and it
    accepts a second inflow from the bottom boundary that can be controlled
    by a second component.  For material properties, this component uses an
    ideal gas equation of state, and assumes constant ratio of specific
    heats, thermal conductivity, and specific heat capacity.  There is no
    system of units assumed by the component - it is up to the user to
    ensure dimensional consistency.

<P>
The following are the semi-compressible flow equations used in this 
    component.

<P>
<!-- MATH
 $\frac{\partial \rho}{\partial t} + \frac{\partial \rho u}{\partial x}
  + \frac{\partial \rho v}{\partial y} = 0$
 -->
<IMG
 WIDTH="142" HEIGHT="40" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.png"
 ALT="$\frac{\partial \rho}{\partial t} + \frac{\partial \rho u}{\partial x}
+ \frac{\partial \rho v}{\partial y} = 0 $">

<P>
<!-- MATH
 $\frac{\partial \rho u}{\partial t} + \frac{\partial \rho u^{2}}{\partial x} 
  + \frac{\partial \rho u v}{\partial y} = - \frac{\partial(p + q)}{\partial x}$
 -->
<IMG
 WIDTH="212" HEIGHT="44" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$\frac{\partial \rho u}{\partial t} + \frac{\partial \rho u^{2}}{\partial x}
+ \frac{\partial \rho u v}{\partial y} = - \frac{\partial(p + q)}{\partial x}$">

<P>
<!-- MATH
 $\frac{\partial \rho v}{\partial t} + \frac{\partial \rho u v}{\partial x} 
  + \frac{\partial \rho v^{2}}{\partial y} = - \frac{\partial(p + q)}{\partial y}$
 -->
<IMG
 WIDTH="210" HEIGHT="44" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$\frac{\partial \rho v}{\partial t} + \frac{\partial \rho u v}{\partial x}
+ \frac{\partial \rho v^{2}}{\partial y} = - \frac{\partial(p + q)}{\partial y}$">

<P>
<!-- MATH
 $\frac{\partial p I}{\partial t} + \frac{\partial \rho u I}{\partial x} +
  \frac{\partial \rho v I}{\partial y} = -(p + q)\left(\frac{\partial u}
  {\partial x} + \frac{\partial v}{\partial y}\right) + \frac{k}{b}\left(
  \frac{\partial^{2}I}{\partial x^{2}} + \frac{\partial^{2}I}{\partial y^{2}}\right)$
 -->
<IMG
 WIDTH="412" HEIGHT="47" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.png"
 ALT="$\frac{\partial p I}{\partial t} + \frac{\partial \rho u I}{\partial x} +
\frac...
...ac{\partial^{2}I}{\partial x^{2}} + \frac{\partial^{2}I}{\partial y^{2}}\right)$">

<P>
<!-- MATH
 $p = (\gamma - 1)\rho I$
 -->
<IMG
 WIDTH="101" HEIGHT="34" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$p = (\gamma - 1)\rho I$">

<P>
<!-- MATH
 $q = -q_{o}\rho u_{in}(dx^{2} + dy^{2})^{1/2} \left(\frac{\partial u}
  {\partial x} + \frac{\partial v}{\partial y}\right)$
 -->
<IMG
 WIDTH="270" HEIGHT="47" ALIGN="MIDDLE" BORDER="0"
 SRC="img12.png"
 ALT="$q = -q_{o}\rho u_{in}(dx^{2} + dy^{2})^{1/2} \left(\frac{\partial u}
{\partial x} + \frac{\partial v}{\partial y}\right)$">

<P>
<!-- MATH
 $if q < 0 set q = 0$
 -->
<IMG
 WIDTH="115" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img13.png"
 ALT="$if q &lt; 0 set q = 0$">

<P>
Where
  <TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img14.png"
 ALT="$\rho$"></TD>
<TD ALIGN="LEFT">density</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="12" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img15.png"
 ALT="$t$"></TD>
<TD ALIGN="LEFT">time</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img16.png"
 ALT="$u$"></TD>
<TD ALIGN="LEFT">x-component of velocity</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img17.png"
 ALT="$v$"></TD>
<TD ALIGN="LEFT">y-component of velocity</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img18.png"
 ALT="$p$"></TD>
<TD ALIGN="LEFT">pressure</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="14" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img19.png"
 ALT="$q$"></TD>
<TD ALIGN="LEFT">artificial velocity</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="14" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img20.png"
 ALT="$I$"></TD>
<TD ALIGN="LEFT">standard internal energy</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="15" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img21.png"
 ALT="$\gamma$"></TD>
<TD ALIGN="LEFT">ratio of specific heats</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="15" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img22.png"
 ALT="$k$"></TD>
<TD ALIGN="LEFT">thermal conductivity</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="13" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img23.png"
 ALT="$b$"></TD>
<TD ALIGN="LEFT">specific heat capacity</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="20" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img24.png"
 ALT="$q_{o}$"></TD>
<TD ALIGN="LEFT">artificial viscosity coefficient, dimensionless</TD>
</TR>
<TR><TD ALIGN="LEFT"><IMG
 WIDTH="28" HEIGHT="32" ALIGN="MIDDLE" BORDER="0"
 SRC="img25.png"
 ALT="$u_{in}$"></TD>
<TD ALIGN="LEFT">inflow velocity (representative velocity)</TD>
</TR>
</TABLE>

<P>

<P>

<H3><A NAME="SECTION000143100000000000000">
13.3.1 Namelist Input Parameters for Flowsolver:</A>
</H3>
       The following variables must be input to the FlowSolver Component to run.
       They are located in a file called "coupled_flow_input."

<P>
The variables are:
       <DL>
<DT><STRONG>uin</STRONG></DT>
<DD>Inflow velocity at left boundary.
       
</DD>
<DT><STRONG>rhoin</STRONG></DT>
<DD>Inflow density at left boundary.
       
</DD>
<DT><STRONG>siein</STRONG></DT>
<DD>Inflow specific internal energy at left boundary.
       
</DD>
<DT><STRONG>gamma</STRONG></DT>
<DD>Ratio of specific heats for the fluid (assumed constant).
       
</DD>
<DT><STRONG>akb</STRONG></DT>
<DD>Thermal conductivity over specific heat capacity (assumed
             constant).
       
</DD>
<DT><STRONG>q0</STRONG></DT>
<DD>Dimensionless linear artificial viscosity coefficient
             (should be between 0.1 and 0.2).
       
</DD>
<DT><STRONG>u0</STRONG></DT>
<DD>Initial velocity in the first grid direction.
       
</DD>
<DT><STRONG>v0</STRONG></DT>
<DD>Initial velocity in the second grid direction.
       
</DD>
<DT><STRONG>sie0</STRONG></DT>
<DD>Initial specific internal energy.
       
</DD>
<DT><STRONG>rho0</STRONG></DT>
<DD>Initial density.
       
</DD>
<DT><STRONG>printout</STRONG></DT>
<DD>Number of cycles between graphical output files.
       
</DD>
<DT><STRONG>sieobs</STRONG></DT>
<DD>Specific internal energy of the obstacles.
       
</DD>
<DT><STRONG>nobsdesc</STRONG></DT>
<DD>Number of obstacle descriptors.  Each descriptor defines a
             block of cells that will serve as an obstacle and not allow
             fluid flow.
       
</DD>
<DT><STRONG>iobs_min</STRONG></DT>
<DD>Minimum global cell number in the first grid direction defining
             a block of cells to be an obstacle.  Must be [nobsdesc] number
             of these.
       
</DD>
<DT><STRONG>iobs_max</STRONG></DT>
<DD>Maximum global cell number in the first grid direction defining
             a block of cells to be an obstacle.  Must be [nobsdesc] number
             of these.
       
</DD>
<DT><STRONG>jobs_min</STRONG></DT>
<DD>Minimum global cell number in the second grid direction defining
             a block of cells to be an obstacle.  Must be [nobsdesc] number
             of these.
       
</DD>
<DT><STRONG>jobs_max</STRONG></DT>
<DD>Maximum global cell number in the second grid direction defining
             a block of cells to be an obstacle.  Must be [nobsdesc] number
             of these.
       
</DD>
<DT><STRONG>iflo_min</STRONG></DT>
<DD>Minimum global grid cell number for the second inflow along the
             bottom boundary.
       
</DD>
<DT><STRONG>iflo_max</STRONG></DT>
<DD>Maximum global grid cell number for the second inflow along the
             bottom boundary.
       
</DD>
</DL>

<P>

<H3><A NAME="SECTION000143200000000000000">
13.3.2 Example of FieldHalo Usage:</A>
</H3>

<P>
The following piece of code provides an example of haloing the data in a
       Field.  Currently the Field halo routine assumes the entire halo is 
       updated completely; i.e. the user cannot specify halo width or side 
       separately.
       Field halo uses a Route object to transfer data from the exclusive
       domain of one DE to the halo region of another. 

<P>
<PRE>
      call ESMF_FieldHalo(field_rhou, halohandle, rc=status)
      if(status .NE. ESMF_SUCCESS) then
        print *, "ERROR in FlowRhoVel:  rhou halo"
        if(present(rc)) rc = status
        return
      endif
</PRE>

<P>

<P>

<P>

<P>

<P>

<H2><A NAME="SECTION000144000000000000000">
13.4 Fortran:  Module Interface FlowArraysMod.F90 - Source file for Data for Flow Solver (Source File: FlowArraysMod.F90)</A>
</H2>

<P>
Allocate and deallocate ESMF objects which handle data arrays
    including ESMF_Fields, ESMF_Grids,  and ESMF_Arrays.

<P>

<H3><A NAME="SECTION000144100000000000000">
13.4.1 Example of Field Creation and Array Usage:</A>
</H3>

<P>
The following piece of code provides an example of Field creation used in
       the demo.  In this example we create a Field from an ArraySpec, which
       designates the rank, type, and kind of the data.  First initialize the
       ArraySpec with rank 2 for a two-dimensional array
       and kind ESMF_KIND_R4: 

<P>
<PRE>
      call ESMF_ArraySpecSet(arrayspec, rank=2, typekind=ESMF_TYPEKIND_R4, rc=status)
      if(status /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=status)
</PRE>

<P>
<PRE>
      field_sie  = ESMF_FieldCreate(grid, arrayspec, &amp;
                   maxHaloLWidth=haloLWidth, maxHaloUWidth=haloUWidth, name="SIE", rc=status)
      if(status /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=status)
</PRE>

<P>
<PRE>
      call ESMF_FieldGet(field_sie, farrayPtr=sie, rc=status)
      if(status /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=status)
</PRE>

<P>

<P>

<P>

<P>

<P>

<H2><A NAME="SECTION000145000000000000000">
13.5 Fortran:  Module Interface CouplerMod.F90 - Source for 2-way Coupler Component (Source File: CouplerMod.F90)</A>
</H2>

<P>
The Coupler Component provides two-way coupling between the Injector
    and FlowSolver Models.  During initialization this Component is
    responsible for setting that data "is needed" from the export state
    of each model.  In its run routine it calls route to transfer the
    needed data directly from one Component's export state to the other
    Component's import state.

<P>

<H3><A NAME="SECTION000145100000000000000">
13.5.1 Example of Redist Usage:</A>
</H3>

<P>
The following piece of code provides an example of calling the data
     redistribution routine  between two Fields in the Coupler Component.  
     Unlike regrid, which translates between
     different Grids, redist translates between different DELayouts on
     the same Grid.   The first two lines get the Fields from the 
     States, each corresponding to a different subcomponent.  One is
     an Export State and the other is an Import State.

<P>
<PRE>
           call ESMF_StateGet(importState, datanames(i), srcfield, rc=rc)
           if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
           call ESMF_StateGet(exportState, datanames(i), dstfield, rc=rc)
           if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>
<PRE>
           call ESMF_FieldRedist(srcfield, dstfield, routehandle, rc=rc)
           if(rc /= ESMF_SUCCESS) call ESMF_Finalize(terminationflag=ESMF_ABORT, rc=rc)
</PRE>

<P>

<P>

<P>

<P>

<P>

<H2><A NAME="SECTION000146000000000000000">
13.6 Fortran:  Module Interface InjectorMod - Fluid Injection Component (Source File: InjectorMod.F90)</A>
</H2>

<P>
This is a user-supplied fluid injection component which interacts 
     with a separate fluid flow model component by altering the inflow 
     boundary conditions during a user-specifed time interval.
     The energy, velocity, and density of the inflow fluid during
     the injection time interval are user-specified.  
     The location of the inflow is 
     determined by the fluid flow model component through a set of
     boundary condition flags which are supplied to this component
     in the import state.  The energy, velocity, and density fields
     of the calculation are updated by this component and returned
     to the fluid flow solver for the next computational time step
     in the export state.

<P>

<H3><A NAME="SECTION000146100000000000000">
13.6.1 Namelist Input Parameters for Injector:</A>
</H3>
       The following variables must be input to the Injector Component to run.
       They are located in a file called "coupled_inject_input."

<P>
The variables are:
       <DL>
<DT><STRONG>on_month</STRONG></DT>
<DD>Injector start time month (integer).
       
</DD>
<DT><STRONG>on_day</STRONG></DT>
<DD>Injector start time day (integer).
       
</DD>
<DT><STRONG>on_hour</STRONG></DT>
<DD>Injector start time hour (integer).
       
</DD>
<DT><STRONG>on_min</STRONG></DT>
<DD>Injector start time minute (integer).
       
</DD>
<DT><STRONG>off_month</STRONG></DT>
<DD>Injector stop time month (integer).
       
</DD>
<DT><STRONG>off_day</STRONG></DT>
<DD>Injector stop time day (integer).
       
</DD>
<DT><STRONG>off_hour</STRONG></DT>
<DD>Injector stop time hour (integer).
       
</DD>
<DT><STRONG>off_min</STRONG></DT>
<DD>Injector stop time minute (integer).
       
</DD>
<DT><STRONG>in_energy</STRONG></DT>
<DD>Standard internal energy of the injector flow.
       
</DD>
<DT><STRONG>in_velocity</STRONG></DT>
<DD>Vertical velocity of the injector flow.
       
</DD>
<DT><STRONG>in_rho</STRONG></DT>
<DD>Density of the injector flow.
       
</DD>
</DL>

<P>

<P>

<P>

<P>

<P>

<P>

<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html488"
  HREF="node15.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html484"
  HREF="ESMF_usrdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html478"
  HREF="node13.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html486"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html489"
  HREF="node15.html">14 How to Adapt</A>
<B> Up:</B> <A NAME="tex2html485"
  HREF="ESMF_usrdoc.html">ESMF_usrdoc</A>
<B> Previous:</B> <A NAME="tex2html479"
  HREF="node13.html">12 ESMF COUPLED_FLOW Demonstration</A>
 &nbsp <B>  <A NAME="tex2html487"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
