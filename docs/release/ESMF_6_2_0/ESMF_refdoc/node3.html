<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>2 Applications</TITLE>
<META NAME="description" CONTENT="2 Applications">
<META NAME="keywords" CONTENT="ESMF_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ESMF_refdoc.css">

<LINK REL="next" HREF="node4.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="ESMF_refdoc.html">
<LINK REL="next" HREF="node4.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html1668"
  HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1664"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1658"
  HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1666"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1669"
  HREF="node4.html">3 Superstructure</A>
<B> Up:</B> <A NAME="tex2html1665"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1659"
  HREF="node2.html">1 ESMF Overview</A>
 &nbsp; <B>  <A NAME="tex2html1667"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><UL>
<LI><A NAME="tex2html1670"
  HREF="node3.html#SECTION03010000000000000000">11 ESMF_Info</A>
<UL>
<LI><A NAME="tex2html1671"
  HREF="node3.html#SECTION03011000000000000000">11.1 Description</A>
</UL>
<LI><A NAME="tex2html1672"
  HREF="node3.html#SECTION03020000000000000000">12 ESMF_RegridWeightGen</A>
<UL>
<LI><A NAME="tex2html1673"
  HREF="node3.html#SECTION03021000000000000000">12.1 Description</A>
<LI><A NAME="tex2html1674"
  HREF="node3.html#SECTION03022000000000000000">12.2 Usage</A>
<LI><A NAME="tex2html1675"
  HREF="node3.html#SECTION03023000000000000000">12.3 Examples</A>
<LI><A NAME="tex2html1676"
  HREF="node3.html#SECTION03024000000000000000">12.4 SCRIP Grid File Format</A>
<LI><A NAME="tex2html1677"
  HREF="node3.html#SECTION03025000000000000000">12.5 ESMF Unstructured Grid File Format</A>
<LI><A NAME="tex2html1678"
  HREF="node3.html#SECTION03026000000000000000">12.6 CF Convention GRIDSPEC File Format</A>
<LI><A NAME="tex2html1679"
  HREF="node3.html#SECTION03027000000000000000">12.7 CF Convention UGRID File Format</A>
<UL>
<LI><A NAME="tex2html1680"
  HREF="node3.html#SECTION03027100000000000000">12.7.1 2D UGRID Example</A>
<LI><A NAME="tex2html1681"
  HREF="node3.html#SECTION03027200000000000000">12.7.2 3D UGRID Example</A>
</UL>
<LI><A NAME="tex2html1682"
  HREF="node3.html#SECTION03028000000000000000">12.8 Regrid Interpolation Weight File Format</A>
<LI><A NAME="tex2html1683"
  HREF="node3.html#SECTION03029000000000000000">12.9 ESMF_RegridWeightGenCheck</A>
</UL></UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION03000000000000000000">
2 Applications</A>
</H1>

<P>
<A NAME="part:Applications"></A>
<P>

<P>
The main product delivered by ESMF is the ESMF library that allows application
developers to write programs based on the ESMF API. In addition to the 
programming library, ESMF distributions come with a small set of applications
that are of general interest to the community. These applications utilize
the ESMF library to implement features such as printing general information
about the ESMF installation, or generating regrid weight files. The provided
ESMF applications are intended to be used as standard command line tools.

<P>
The bundled ESMF applications are built and installed during the usual ESMF 
installation process, which is described in detail in the ESMF User's Guide 
section "Building and Installing the ESMF". After the installation the 
applications will be located in the <TT>ESMF_APPSDIR</TT> directory, which can 
be found as a Makefile variable in the <TT>esmf.mk</TT> file. The <TT>esmf.mk</TT> 
file can be found in the <TT>ESMF_INSTALL_LIBDIR</TT> directory after a 
successful installation.  The ESMF User's Guide discusses the <TT>esmf.mk</TT> 
mechanism to access the bundled applications in more detail in section 
"Using Bundled ESMF Applications".

<P>
The following sections provide in-depth documentation of the bundled ESMF 
applications. In addition, each application supports the standard 
<code> --help </code> command line argument, providing a brief description of how 
to invoke the program.

<P>

<P>

<H1><A NAME="SECTION03010000000000000000"></A>
<A NAME="sec:ESMF_Info"></A>
<BR>
11 ESMF_Info
</H1>

<P>

<H2><A NAME="SECTION03011000000000000000">
11.1 Description</A>
</H2>

<P>
The <TT>ESMF_Info</TT> application prints basic information about the ESMF 
installation to <TT>stdout</TT>.

<P>
The application usage is as follows:

<P>
<PRE>
ESMF_Info  [--help]

where
  --help     prints a brief usage message
</PRE>

<P>

<P>

<H1><A NAME="SECTION03020000000000000000"></A>
<A NAME="sec:ESMF_RegridWeightGen"></A>
<BR>
12 ESMF_RegridWeightGen
</H1>

<P>

<H2><A NAME="SECTION03021000000000000000">
12.1 Description</A>
</H2>

<P>
This section describes the offline regrid weight generation application provided by ESMF (for a description of ESMF regridding in general see Section&nbsp;<A HREF="node5.html#sec:regrid">22.2</A>). Regridding, also called remapping or interpolation, is the process of changing the grid that underlies data values while preserving qualities of the original data. Different kinds of transformations are appropriate for different problems. Regridding may be needed when communicating data between Earth system model components such as land and atmosphere, or between different data sets to support operations such as visualization. 

<P>
Regridding can be broken into two stages. The first stage is generation of an interpolation weight matrix that describes how points in
the source grid contribute to points in the destination grid. The second stage is the multiplication of values on the source grid by the
interpolation weight matrix to produce values on the destination grid. This occurs through a parallel sparse matrix multiply.

<P>
There are two options for accessing ESMF regridding functionality: integrated and offline. Integrated regridding is a process whereby interpolation
weights are generated via subroutine calls during the execution of the user's code. The integrated regridding can also perform the parallel sparse
matrix multiply. In other words, ESMF integrated regridding allows a user to perform the whole process of interpolation within their code.
For a further description of ESMF integrated regridding please see Section&nbsp;<A HREF="node5.html#sec:fieldregrid">24.3.24</A>. 
In contrast to integrated regridding,
offline regridding is a process whereby interpolation weights are generated by a separate ESMF application, not within the user code. The ESMF offline
regridding application also only generates the interpolation matrix, the user is responsible for reading in this matrix and doing the actual interpolation
(multiplication by the sparse matrix) in their code. The rest of this section further describes ESMF offline regridding.

<P>
For a discussion of installing and accessing ESMF applications such as this one please see the beginning of this part of the refernce manual (Section&nbsp;<A HREF="#part:Applications">II</A>) or for the quickest approach to just building and accessing the applications please refer to the "Building and using bundled ESMF applications" Section in the ESMF User's Guide.

<P>
As described above, this tool reads in
two grid files and outputs weights for interpolation
between the two grids. The input and output files are all in NetCDF format. The grid files can be defined in four
different formats:  the SCRIP format&nbsp;<A HREF="#sec:fileformat:scrip">12.4</A> as is used as an input to SCRIP&nbsp;[<A
 HREF="node8.html#ref:SCRIP">14</A>], the GRIDSPEC Tile grid file&nbsp;<A HREF="#sec:fileformat:gridspec">12.6</A> following the
<A NAME="tex2html10"
  HREF="http://cf-pcmdi.llnl.gov">CF metadata conventions</A>,
the ESMF unstructured grid format&nbsp;<A HREF="#sec:fileformat:esmf">12.5</A> or the proposed CF unstructured grid data model (UGRID)&nbsp;<A HREF="#sec:fileformat:ugrid">12.7</A>
in the current ESMF release.  GRIDSPEC is a proposed CF extension for the annotation of complex Earth system grids.  In the current ESMF release, we only support a single tile grid file for rectangular lat/lon grid.  For UGRID, we support the 2D flexible mesh topology with mixed triangles and quadrilaterals and fully 3D unstructured mesh topology with hexahedrons and tetrahedrons.

<P>
The weight file is the same format&nbsp;<A HREF="#sec:weightfileformat">12.8</A> as is
output by SCRIP. The interpolation weights can be generated with
the bilinear, patch, or first order conservative methods decribed below. Masking is supported for 2D logically rectangular (i.e. with grid_rank=2) grids in the SCRIP format. This application
can do regrid weight generation from a global or regional source grid to a global or regional destination grid.
It assumes that the source and destination grids are on a sphere and that the coordinates given in
the files are latitude and longitude values. The coordinates can either be in degrees or radians (this is indicated by the "units" attribute attached to the value).
As is true with many global models, this application currently assumes the latitude and longitude refer to positions on a perfect sphere, as opposed to a more complex
and accurate representation of the earth's true shape such as would be used in a GIS system. (ESMF's current user base doesn't require this level of detail in representing the earth's shape, but it could be added in the future if necessary.)  This file based regrid weight generation application
is parallel.

<P>
This application requires the NetCDF libary to read the grid files and to write out the weight files in NetCDF format.  To compile ESMF with
the NetCDF library, please refer to the "Third Party Libraries" Section in the ESMF User's Guide for more information.

<P>
Internally this application uses the ESMF public API to generate the interpolation weights.
If a source or destination grid is logically rectangular, then <TT>ESMF_GridCreate()</TT>
&nbsp;<A HREF="node5.html#sec:example:2DLogRecFromScrip">29.3.8</A>
is used to create an ESMF_Grid object. The cell center
coordinates of the input grid are put into the center stagger location (<TT>ESMF_STAGGERLOC_CENTER</TT>).
In addition, the corner coordinates are also put into the corner stagger location
(<TT>ESMF_STAGGERLOC_CORNER</TT>) for conservative regridding.  The method
<TT>ESMF_MeshCreate()</TT>
&nbsp;<A HREF="node5.html#sec:example:UnstructFromFile">31.3.6</A>
is used to create an ESMF_Mesh object, if the
source or destination grid is a cubed sphere grid or an unstructured grid. When making this call,
the flag <TT>convert3D</TT> is set to <TT>TRUE</TT> to convert the 2D coordinates into 3D Cartesian coordinates. Currently, ESMF only supports
triangle or quadrilateral element types for a 2D Mesh.  Therefore, when the cells in an unstructured grid contain more than four edges, they are broken into multiple triangle elements before <TT>ESMF_MeshCreate()</TT> is called to create the ESMF_Mesh object. After the calculation of the weight matrix based on the broken up
cells, the matrix entries for the triangles are merged together, so that the output matrix is in terms of the original cells.
Internally <TT>ESMF_FieldRegridStore()</TT> is used to generate the weight table and indices table representing the interpolation matrix.

<P>
The regridding occurs in 3D to avoid
problems with periodicity and with the pole singularity. This application
supports four options for handling the pole region (i.e. the empty area above the top row of the source grid or below
the bottom row of the source grid).  Note that all of these pole options currently only work for logically rectangular grids (i.e. SCRIP format grids with grid_rank=2 or GRIDSPEC format grids). The first option is to leave the pole region empty ("-p none"), in this
case if a destination point lies above or below the
top row of the source grid, it will fail to map, yielding an error (unless "-i" is specified).
With the next two options, the pole region is handled by constructing
an artificial pole in the center of the top and bottom row of grid points and then filling
in the region from this pole to the edges of the source grid with triangles.
The pole is located at the average of the position of the points surrounding
it, but moved outward to be at the same radius as the rest of the points
in the grid. The difference between these two artificial pole options is what value is used at the pole.
The default pole option ("-p all") sets the value at the pole to be the average of the values
of all of the grid points surrounding the pole. For the other option ("-p N"), the user chooses
a number N from 1 to the number of source grid points around the pole. For
each destination point, the value at the pole is then the average of the N source points
surrounding that destination point. For the last pole option ("-p teeth") no artificial pole is constructed, instead the
pole region is covered by connecting points across the top and bottom row of the source Grid into triangles. As
this makes the top and bottom of the source sphere flat, for a big enough difference between the size of
the source and destination pole regions, this can still result in unmapped destination points.
Only pole option "none" is currently supported with the conservative interpolation method ("-m conserve") and with the
nearest neighbor interpolation methods ("-m nearestdtos" and "-m neareststod").

<P>
Masking is supported for both the logically rectangular grids and the unstructured grids.
If the grid file is in the SCRIP format, the variable "grid_imask" is used as the mask.
If the value is set to 0 for a grid point, then that point is considered masked out and
won't be used in the weights generated by the application. If the grid file is in the ESMF format, the variable "elementMask" is used as the mask.  For a grid defined in the GRIDSPEC
Tile grid or in the UGRID convention, there is no mask variable defined.
However, a GRIDSPEC or a UGRID file may contain both the grid definition and the data.
The grid mask is usually constructed using the missing values defined in the data variable.
The regridding application provides the argument "<code>--</code>src_missingvalue" or
"<code>--</code>dst_missingvalue" for users to specify the variable name from where the mask can be
constructed.

<P>
If a destination point can't be mapped because it falls outside the unmasked source grid, then the default behavior of the application is to stop with an error. By specifying "-i" or the equivalent "<code>--</code>ignore_unmapped" the user can cause the application to ignore unmapped destination points. In this case, the output matrix won't contain entries for the unmapped destination points. Note, that the unmapped point detection doesn't
currently work for nearest destination to source method ("-m nearestdtos"), so when using that method it is as if ``-i'' is always on.

<P>
This regridding application can be used to generate bilinear, patch, nearest neighbor, or first-order conservative interpolation weights. The following is a description of these interpolation methods as relevant to the offline weight generation application, for a more in-depth description see Section&nbsp;<A HREF="node5.html#sec:regrid">22.2</A>.

<P>
The default interpolation method for the weight generation application is bilinear. The algorithm used by this application to 
generate the bilinear weights is the standard one found in many textbooks.  Each destination point is mapped to a location
in the source Mesh, the position of the destination point relative
to the source points surrounding it is used to calculate the interpolation weights.

<P>
This application can also be used to generate patch interpolation weights. Patch
interpolation is the ESMF version of a technique called "patch recovery" commonly
used in finite element modeling&nbsp;[<A
 HREF="node8.html#PatchInterp1">6</A>]&nbsp;[<A
 HREF="node8.html#PatchInterp2">11</A>]. It typically results in better approximations to values and derivatives when compared to bilinear interpolation.
Patch interpolation works by constructing multiple polynomial patches to represent
the data in a source element. For 2D grids, these polynomials
are currently 2nd degree 2D polynomials. The interpolated value at the destination point
is the weighted average of the values of the patches at that point.

<P>
The patch interpolation process works as follows.
For each source element containing a destination point
we construct a patch for each corner node that makes up the element (e.g. 4 patches for
quadrilateral elements, 3 for triangular elements). To construct a polynomial patch for
 a corner node we gather all the elements around that node.
(Note that this means that the patch interpolation weights depends on the source
element's nodes, and the nodes of all elements neighboring the source element.)
We then use a least squares fitting algorithm to choose the set of coefficients
for the polynomial that produces the best fit for the data in the elements.
This polynomial will give a value at the destination point that fits the source data
in the elements surrounding the corner node. We then repeat this process for each
corner node of the source element generating a new polynomial for each set of elements.
To calculate the value at the destination point we do a weighted average of the values
of each of the corner polynomials evaluated at that point. The weight for a corner's
polynomial is the bilinear weight of the destination point with regard to that corner.
The patch method has a larger stencil than the bilinear, for this reason the patch weight matrix can be correspondingly larger
than the bilinear matrix (e.g. for a quadrilateral grid the patch matrix is around 4x the size of
the bilinear matrix). This can be an issue when performing a regrid weight generation operation close to the memory
limit on a machine.

<P>
The nearest neighbor interpolation options work by associating a point in one set with the closest point in another set. If two points are equally
close then the point with the smallest index is arbitrarily used (i.e. the point with that would have the smallest index in the weight matrix). There are two
versions of this type of interpolation available in the regrid weight generation application. One of these is the nearest source to destination
method ("-m neareststod"). In this method each destination point is mapped to the closest source point. The other of these is the
nearest destination to source method ("-m nearestdtos"). In this method each source point is mapped to the closest destination point. Note,
that with this method the unmapped destination point detection doesn't work, so no error will be returned even if there destination points
which don't map to any source point.

<P>
First-order conservative interpolation&nbsp;[<A
 HREF="node8.html#ConservativeOrder1">20</A>] is also available as a regridding method. This method will typically have
a larger local interpolation error than the previous two methods, but will do a much better job of preserving the value of the
integral of data between the source and destination grid. In this method the value across each source cell
is treated as a constant. The weights for a particular destination cell are the area of intersection of each
source cell with the destination cell divided by the area of the destination cell.
Areas in this case are calculated by connecting the corner coordinates of each grid cell (obtained from the grid file) with great circles. If the user doesn't specify
the user area's option ("<code>--</code>user_areas"), then the conservation will hold for the great circle areas calculated by
ESMF (and these are output to the weight file). This means the following equation will hold:  sum-over-all-source-cells(Vsi*Asi) = sum-over-all-destination-cells(Vdj*A'dj), where
V is the variable being regridded and A' is the area of a cell as calculated by ESMF.  The subscripts s and d refer to source and destination values, and the i and j are the source
and destination grid cell indices (flattening the arrays to 1 dimension). If the user does specify the user area's option, then the conservation will be adjusted to work for the areas
provided by the user in the grid files (and these areas are output to the weight file). This means the following equation will hold:  sum-over-all-source-cells(Vsi*Asi) = sum-over-all-destination-cells(Vdj*Adj), where A is the area of a cell as provided by the user.

<P>
Note that since the conservative assumes great circle edges to cells, the edges of a cell won't necessarily be
the same as a straight line in latitude longitude. For small edges, this difference will be small, but for long edges it could be significant. This means if
the user expects cell edges as straight lines in latitude longitude space, they should avoid using one large cell with long edges to compute an average over a region (e.g. over an ocean basin). The
user should also avoid using cells which contain one edge that runs half way or more around the earth, because the regrid weight calculation assumes the
edge follows the shorter great circle path. Also, there isn't a unique great circle edge defined between points on the exact opposite side of the earth from one another (antipodal points).
However, the user can work around both of these problem by breaking the long edge into two smaller edges by inserting an extra node, or by breaking the large target grid cells into two or more smaller grid cells.
This allows the application to resolve the ambiguity in edge direction. One other unexpected case which might cause problems is a grid 
containing a concave cell with exactly four sides, this will cause the application to return an error. The application will work for a
grid containing concave cells as long as all of them have more than four sides. 

<P>
It is important to note that the current implementation of conservative regridding doesn't normalize the interpolation weights by the destination fraction.
This means that for a destination grid which only partially overlaps the source grid the destination field which is output from the regrid operation should
be divided by the corresponding destination fraction to yield the true interpolated values for cells which are only partially covered by the source grid.
The fraction also needs to be included when computing the total source and destination integrals.

<P>
The following pseudo-code shows how to adjust a destination field (<TT>dst_field</TT>) by the destination fraction (<TT>dst_frac</TT>) called <TT>frac_b</TT> in the weight file:

<P>
<PRE>
 for each destination element i
    if (dst_frac(i) not equal to 0.0) then
       dst_field(i)=dst_field(i)/dst_frac(i)
    end if
 end for
</PRE>

<P>
The following pseudo-code shows how to compute the total destination integral (<TT>dst_total</TT>) given the destination field values (<TT>dst_field</TT>) resulting
from the sparse matrix multiply of the weights in the weight file by the source field, the destination area (<TT>dst_area</TT>) called <TT>area_b</TT> in the
weight file, and the destination fraction (<TT>dst_frac</TT>) called <TT>frac_b</TT> in the weight file. As in the previous paragraph, it also
shows how to adjust the destination field (<TT>dst_field</TT>) resulting from the sparse matrix multiply by the fraction
(<TT>dst_frac</TT>) called <TT>frac_b</TT> in the weight file:

<P>
<PRE>
 dst_total=0.0
 for each destination element i
    if (dst_frac(i) not equal to 0.0) then
       dst_total=dst_total+dst_field(i)*dst_area(i)
       dst_field(i)=dst_field(i)/dst_frac(i)
       ! If mass computed here after dst_field adjust, would need to be:
       ! dst_total=dst_total+dst_field(i)*dst_area(i)*dst_frac(i)
    end if
 end for
</PRE>

<P>
The following pseudo-code shows how to compute the total source integral (<TT>src_total</TT>) given the source field values (<TT>src_field</TT>), the source area (<TT>src_area</TT>) called <TT>area_a</TT> in the weight file, and the source fraction (<TT>src_frac</TT>) called <TT>frac_a</TT> in the weight file:

<P>
<PRE>
 src_total=0.0
 for each source element i
    src_total=src_total+src_field(i)*src_area(i)*src_frac(i)
 end for
</PRE>

<P>
The interpolation weights generated by this application are output to a NetCDF file (specified by the "-w" or "<code>--</code>weight"
keywords). The format of this file is the same as that generated by SCRIP. See Section&nbsp;<A HREF="#sec:weightfileformat">12.8</A> for a description of the format.
Note that the sequence of the weights in the file can
vary with the number of processors used to run the application. This means that two weight files generated by using different
numbers of processors can contain exactly the same interpolation matrix, but can appear different in a direct line by line
comparison (such as would be done by ncdiff).

<P>

<H2><A NAME="SECTION03022000000000000000"></A><A NAME="sec:regridusage"></A>
<BR>
12.2 Usage
</H2>

<P>
The command line arguments are all keyword based.  Both the long keyword prefixed with <code> '--' </code> or the
one character short keyword prefixed with <TT>'-'</TT> are supported.  The format to run the application is
as follows:

<P>
<PRE>
ESMF_RegridWeightGen  
	[--help]
        [--version]
        [--source|-s] src_grid_filename
        [--destination|-d] dst_grid_filename
        [--weight|-w] out_weight_file
        [--method|-m] [bilinear|patch|nearestdtos|neareststod|conserve]
        [--pole|-p] [none|all|teeth|1|2|..]
        [--ignore_unmapped|-i]
        --src_type [SCRIP|GRIDSPEC|ESMF|UGRID]
        --dst_type [SCRIP|GRIDSPEC|ESMF|UGRID]
        -t [SCRIP|GRIDSPEC|ESMF|UGRID]
        -r
        --src_regional
        --dst_regional
	--64bit_offset
        --netcdf4
        --src_meshname dummy_var_name
	--dst_meshname dummy_var_name
	--src_missingvalue var_name
	--dst_missingvalue var_name
	--src_coordinates lon_name,lat_name
	--dst_coordinates lon_name,var_name
        --user_areas
where
  --help              - Print the usage message and exit.
  --version           - Print ESMF version and license information and exit.
  --source or -s      - a required argument specifying the source grid
                        file name

  --destination or -d - a required argument specifying the destination
                        grid file name

  --weight or -w      - a required argument specifying the output regridding
                        weight file name

  --method or -m      - an optional argument specifying which interpolation
                        method is used. The value can be one of the following:

                        bilinear  - for bilinear interpolation, also the
                                    default method if not specified.
                        patch     - for patch recovery interpolation
                        conserve  - for first-order conservative interpolation

  --pole or -p        - an optional argument indicating what to do with
                        the pole.
                        The value can be one of the following:

                        none  - No pole, the source grid ends at the top
                                (and bottom) row of nodes specified in
                                &lt;source grid&gt;.
                        all   - Construct an artificial pole placed in the
                                center of the top (or bottom) row of nodes,
                                but projected onto the sphere formed by the
                                rest of the grid. The value at this pole is
                                the average of all the pole values. This
                                is the default option.

                        teeth - No new pole point is constructed, instead
                                the holes at the poles are filled by
                                constructing triangles across the top and
                                bottom row of the source Grid. This can be
                                useful because no averaging occurs, however,
                                because the top and bottom of the sphere are
                                now flat, for a big enough mismatch between
                                the size of the destination and source pole
                                regions, some destination points may still
                                not be able to be mapped to the source Grid.

                        &lt;N&gt;   - Construct an artificial pole placed in the
                                center of the top (or bottom) row of nodes,
                                but projected onto the sphere formed by the
                                rest of the grid. The value at this pole is
                                the average of the N source nodes next to
                                the pole and surrounding the destination
                                point (i.e.  the value may differ for each
                                destination point. Here N ranges from 1 to
                                the number of nodes around the pole.
    --ignore_unmapped
           or
           -i         - ignore unmapped destination points. If not specified
                        the default is to stop with an error if an unmapped
                        point is found.

    --src_type        - an optional argument specifying the source grid file
                        type.  The value could be one of SCRIP, GRIDSPEC, ESMF
			or UGRID. The SCRIP file can be either structured or
 			unstructured grid.  The GRIDSPEC is the only for the
			structured grid defined in the CF convention.
                        The ESMF and UGRID file types are only available for
                        the unstructured grid. The default option is SCRIP.

    --dst_type        - an optional argument specifying the destination grid
                        file type. The value could be one of SCRIP, GRIDSPEC,
			ESMF or UGRID.  The SCRIP file can be either structured
 			or unstructured grid.  The GRIDSPEC is the only for the
			structured grid defined in the CF convention.
                        UGRID.  The ESMF and UGRID file types are only
			available for the unstructured grid. The default
			option is SCRIP.

    -t                - an optional argument specifying the file types for
                        both the source and the destination grid files. The
                        default option is SCRIP.  If both -t and --src_type
                        or --dst_type are given at the same time and they
                        disagree with each other, an error message will be
                        generated.

    -r                - an optional argument specifying that the source and
                        destination grids are regional grids.  If the argument
                        is not given, the grids are assumed to be global.

    --src_regional    - an optional argument specifying that the source is
                        a regional grid and the destination is a global grid.

    --dst_regional    - an optional argument specifying that the destination
                        is a regional grid and the source is a global grid.

    --64bit_offset    - an optional argument specifying that the weight file
			will be created in the NetCDF 64-bit offset format
			to allow variables larger than 2GB.  Note the 64-bit
			offset format is not supported in the NetCDF version
			earlier than 3.6.0.  An error message will be generated
			if this flag is specified while the application is
			linked with a NetCDF library earlier than 3.6.0.

    --netcdf4         - an optional argument specifying that the output weight
                        will be created in the NetCDF4 format.  This option 
                        only works with NetCDF library version 4.1 and above that
                        was compiled with the NetCDF4 file format enabled (with 
                        HDF5 compression). An error message will be generated if
                        these conditions are not met.

    --src_meshname    - this argument is required if the source grid type is
                        UGRID. It defines the dummy variable name that has all
                        the topology information stored in its attributes.

    --dst_meshname    - this argument is required if the destination grid type
			is UGRID. It defines the dummy variable name that has
			all the topology information stored in its attributes.

    --src_missingvalue - an optional argument that defines the variable name 
                         in the source grid file if the file type is GRIDSPEC.
                         The regridder will generate a mask using the missing
			 values of the data variable.  The missing value is defined
			 using an attribute called "_FillValue" or "missing_value"

    --dst_missingvalue - an optional argument that defines the variable name
			 in the destination grid file if the file type is
			 GRIDSPEC.  The regridder will generate a mask using
			 the missing values of the data variable.  The missing
			 value is defined using an attribute called "_FillValue"
			 or "missing_value"

    --src_coordinates - an optional argument that defines the longitude and
			 latitude variable names in the source grid file if
			 the file type is GRIDSPEC.  The variable names are
			 separated by comma.  This argument is required in case
			 there are multiple sets of coordinate variables defined
			 in the file.  Without this argument, the offline regrid
			 application will terminate with an error mesasge when
			 multiple coordinate variables are found in the file.

    --dst_coordinates - an optional argument that defines the longitude and
			 latitude variable names in the destination grid file
			 if the file type is GRIDSPEC.  The variable names are
			 separated by comma.  This argument is required in case
			 there are multiple sets of coordinate variables defined
			 in the file.  Without this argument, the offline regrid
			 application will terminate with an error mesasge when
			 multiple coordinate variables
			 are found in the file.

    --user_areas      - an optional argument specifying that the conservation
                        is adjusted to hold for the user areas provided in
                        the grid files. If not specified, then the 
                        conservation will hold for the ESMF calculated 
                        (great circle) areas.
                        Whichever areas the conservation holds for are output
                        to the weight file.
</PRE>

<P>

<H2><A NAME="SECTION03023000000000000000">
12.3 Examples</A>
</H2>

<P>
The example below shows the command to generate a set of conservative interpolation weights between a global
SCRIP format source grid file (src.nc) and a global SCRIP format destination grid file (dst.nc). The weights
are written into file w.nc. In this case the
ESMF library and applications have been compiled using an MPI parallel communication library
(e.g. setting ESMF_COMM to openmpi) to enable it to run in parallel. To demonstrate running in parallel
the mpirun script is used to run the application in parallel on 4 processors.

<P>
<PRE>
  mpirun -np 4 ./ESMF_RegridWeightGen -s src.nc -d dst.nc -m conserve -w w.nc
</PRE>

<P>
The next example below shows the command to do the same thing as the previous example except for three changes. The first
change is this time the source grid is regional ("<TT><code>--</code>src_regional</TT>"). The second change is that
for this example bilinear interpolation ("<TT>-m bilinear</TT>") is being used. Because bilinear is the default, we could also
omit the "<TT>-m bilinear</TT>". The third change is that in this example some of the destination points are expected to
not be found in the source grid, but the user is ok with that and just wants those points to not appear in the weight file instead of causing an error ("<TT>-i</TT>").

<P>
<PRE>
  mpirun -np 4 ./ESMF_RegridWeightGen -i --src_regional -s src.nc -d dst.nc \
                 -m bilinear -w w.nc
</PRE>

<P>
The default grid file format is SCRIP, to use a grid file in another grid format, you
need to use the switches "<TT><code>--</code>src_type</TT>", "<TT><code>--</code>dst_type</TT>" or "<TT>-t</TT>".  For example, if the
source grid is in UGRID format and the destination grid is in GRIDSPEC format, the command
to run the application is:

<P>
<PRE>
  mpirun -np 4 ./ESMF_RegridWeightGen -s src.nc -d dst.nc \
                 -m conserve -w w.nc --src_type UGRID --dst_type GRIDSPEC \
		 --src_meshname mesh_dummy
</PRE>

<P>
Since the source grid is a UGRID, an additional argument "<TT><code>--</code>src_meshname</TT>" needs to be provided.  This is the dummy variable used to define all the mesh topology information in the
grid file.

<P>
The last example shows how to use the missing values of a data variable to generate the
grid mask for a GRIDSPEC file, how to specify the coordinate variable names
using "<TT><code>--</code>src_coordinates</TT>"
 and use user defined area for the conservative regridding.

<P>
<PRE>
  mpirun -np 4 ./ESMF_RegridWeightGen -s src.nc -d dst.nc -m conserve \
                 -w w.nc --src_type GRIDSPEC --src_missingvalue datavar \
                 --src_coordinates lon,lat --user_areas
</PRE>

<P>
In the above example, "datavar" is the variable name defined in the source grid that will
 be used to construct the mask using its missing values.  In addition, "<TT>lon</TT>" and "<TT>lat</TT>" are the
variable names for the longitude and latitude values, respectively.

<P>

<H2><A NAME="SECTION03024000000000000000"></A><A NAME="sec:fileformat:scrip"></A>
<BR>
12.4 SCRIP Grid File Format
</H2>

<P>
A SCRIP format grid file is a NetCDF file for describing grids. This format is the same as is used by the SCRIP&nbsp;[<A
 HREF="node8.html#ref:SCRIP">14</A>]
package, and so grid files which work with that package should also work here.  SCRIP format files are capable of storing either 2D logically rectangular
grids or 2D unstructured grids. The basic format for both of these grids is the same and they are distinguished by the
value of the <TT>grid_rank</TT> variable. Logically rectangular grids have <TT>grid_rank</TT> set to 2,
whereas unstructured grids have this variable set to 1.

<P>
The following is a sample header of a logically rectangular grid file:

<P>
<PRE>
netcdf remap_grid_T42 {
dimensions:
      grid_size = 8192 ;
      grid_corners = 4 ;
      grid_rank = 2 ;

variables:
      int grid_dims(grid_rank) ;
      double grid_center_lat(grid_size) ;
         grid_center_lat:units = "radians";
      double grid_center_lon(grid_size) ;
         grid_center_lon:units = "radians" ;
      int grid_imask(grid_size) ;
         grid_imask:units = "unitless" ;
      double grid_corner_lat(grid_size, grid_corners) ;
         grid_corner_lat:units = "radians" ;
      double grid_corner_lon(grid_size, grid_corners) ;
         grid_corner_lon:units ="radians" ;

// global attributes:
         :title = "T42 Gaussian Grid" ;
}
</PRE>

<P>
The <TT>grid_size</TT> dimension is the total number of cells in the grid; <TT>grid_rank</TT> refers to the
number of dimensions. In this case <TT>grid_rank</TT> is 2 for a 2D logically rectangular grid.
The integer array <TT>grid_dims</TT> gives the number of grid cells along each dimension.
The number of corners (vertices) in each grid cell is given by <TT>grid_corners</TT>.
The grid corner coordinates need to be listed in an order such that the corners are in counter-clockwise
order.  Also, note that if your grid has a variable number of corners on grid cells, then
you should set <TT>grid_corners</TT> to be the highest value and use redundant points
on cells with fewer corners.

<P>
The integer array <TT>grid_imask</TT> is used to mask out grid cells which should
not participate in the regridding. The array should by zero for any points
that do not participate in the regridding and one for all other points.
Coordinate arrays provide the latitudes and longitudes of cell centers
and cell corners. The unit of the coordinates can be either "<TT>radians</TT>" or "<TT>degrees</TT>".

<P>
Here is a sample header from a SCRIP unstructured grid file:

<P>
<PRE>
netcdf ne4np4-pentagons {
dimensions:
      grid_size = 866 ;
      grid_corners = 5 ;
      grid_rank = 1 ;
variables:
      int grid_dims(grid_rank) ;
      double grid_center_lat(grid_size) ;
         grid_center_lat:units = "degrees" ;
      double grid_center_lon(grid_size) ;
         grid_center_lon:units = "degrees" ;
      double grid_corner_lon(grid_size, grid_corners) ;
         grid_corner_lon:units = "degrees";
         grid_corner_lon:_FillValue = -9999. ;
      double grid_corner_lat(grid_size, grid_corners) ;
         grid_corner_lat:units = "degrees" ;
         grid_corner_lat:_FillValue = -9999. ;
      int grid_imask(grid_size) ;
         grid_imask:_FillValue = -9999. ;
      double grid_area(grid_size) ;
         grid_area:units = "radians^2" ;
         grid_area:long_name = "area weights" ;
}
</PRE>

<P>
The variables are the same as described above, however, here (<TT>grid_rank = 1</TT>). In this format there
is no notion of which cells are next to which, so to construct the unstructured mesh the connection between
cells is defined by searching for cells with the same corner coordinates. (e.g. the same <TT>grid_corner_lat</TT>
and <TT>grid_corner_lon</TT> values).

<P>
Both the SCRIP grid file format and the SCRIP weight file format work with the SCRIP 1.4 tools.

<P>

<H2><A NAME="SECTION03025000000000000000"></A><A NAME="sec:fileformat:esmf"></A>
<BR>
12.5 ESMF Unstructured Grid File Format
</H2>

<P>
ESMF supports a custom unstructured grid file format for describing meshes. This format is more compatible than the SCRIP format with the methods used to create an ESMF Mesh object, so less conversion needs to be done to create a Mesh.
The ESMF format is thus more efficient than SCRIP when used with ESMF codes (e.g. the ESMF_RegridWeightGen application). However, this
format doesn't currently support conversion to a dual mesh which means that non-conservative regridding (e.g. Bilinear) is only supported on nodes.

<P>
The following is a sample header in the ESMF format followed by a description:

<P>
<PRE>
netcdf mesh-esmf {
dimensions:
     nodeCount = 9 ;
     elementCount = 5 ;
     maxNodePElement = 4 ;
     coordDim = 2 ;
variables:
     double nodeCoords(nodeCount, coordDim);
            nodeCoords:units = "degrees" ;
     int elementConn(elementCount, maxNodePElement) ;
            elementConn:long_name = "Node Indices that define the element /
                                     connectivity";
            elementConn:_FillValue = -1 ;
     byte numElementConn(elementCount) ;
            numElementConn:long_name = "Number of nodes per element" ;
     double centerCoords(elementCount, coordDim) ;
            centerCoords:units = "degrees" ;
     double elementArea(elementCount) ;
            elementArea:units = "radians^2" ;
            elementArea:long_name = "area weights" ;
     int elementMask(elementCount) ;
            elementMask:_FillValue = -9999. ;
// global attributes:
            :gridType="unstructured";
            :version = "0.9" ;
</PRE>

<P>
In the ESMF format the netCDF dimensions have the following meanings. The <TT>nodeCount</TT> dimension is the number of nodes in the mesh.
 The <TT>elementCount</TT> dimension is the number of elements in the mesh. The <TT>maxNodePElement</TT> dimension is the maximum number
 of nodes in any element in the mesh. For example, in a mesh containing just triangles, then <TT>maxNodePElement</TT> would be 3. However,
 if the mesh contained one quadrilateral then <TT>maxNodePElement</TT> would need to be 4. The <TT>coordDim</TT> dimension is the number of dimensions
 of the points making up the mesh (i.e. the spatial dimension of the mesh). For example, a 2D planar mesh would have <TT>coordDim</TT> equal to 2.

<P>
In the ESMF format the netCDF variables have the following meanings. The <TT>nodeCoords</TT> variable contains the coordinates for each node.
 <TT>nodeCoords</TT> is a two-dimensional array of dimension <TT>(nodeCount,coordDim)</TT>.
 For a 2D Grid, <TT>coordDim</TT> is 2. <TT>nodeCoords(:,1)</TT> contains the longitude coordinates and
 <TT>nodeCoords(:,2)</TT> contains the latitude coordinates.  The same order applies to <TT>centerCoords</TT>.
 <TT>elementConn</TT> variable describes how the nodes are connected together to form each element. For each element (i.e. each iteration of the first
 dimension of the variable), this variable contains a list of 1-based indices into the <TT>nodeCoords</TT> variable pointing to the nodes which make up that
 element. For example, if <TT>elementConn(2,1..3)</TT> contains (1,2,4), then that means that the second element consists of the nodes whose coordinates are
 described by <TT>nodeCoords(1)</TT>, <TT>nodeCoords(2)</TT>, and <TT>nodeCoords(4)</TT>. The order of the indices describing the element is important.
 The proper order for elements available in an ESMF mesh can be found in Section&nbsp;<A HREF="node5.html#const:meshelemtype">31.2.1</A>. The file format does support 2D polygons with more
 corners than those in that section, but internally these are broken into triangles. For these polygons, the corners should
 be listed such that they are in counter-clockwise order around the element.  Because variables have to be rectangular, the second
 dimension of
 the <TT>elementConn</TT> variable has to be the size of the largest number of nodes in any element (i.e. <TT>maxNodePElement</TT>), the actual number of
 nodes in an element is given by the <TT>numElementConn</TT> variable. For a given dimension (i.e. <TT>coordDim</TT>) the number of nodes in the element
 indicates the element shape, for example in 2D, if <TT>numElementConn</TT> is 4 then the element is a quadrilateral. In 3D, if <TT>numElementConn</TT> is 8
 then the element is a hexahedron.

<P>
The rest of the variables in the format are optional. The <TT>centerCoords</TT> variable gives the coordinates of the center of the corresponding element.
 This variable is currently not used by ESMF. The <TT>elementArea</TT> variable gives the area (or volume in 3D) of the corresponding element. This
 area is used by ESMF during conservative interpolation. If not specified, ESMF calculates the area (or volume) based on the coordinates of the nodes
 making up the element. The final variable is the <TT>elementMask</TT> variable. This variable allows the user to specify a mask value for
 the corresponding element. If the value is 1, then the element is unmasked and if the value is 0 the element is masked.
 If not specified, ESMF assumes that no elements are masked.

<P>
The following is a picture of a small example mesh and a sample ESMF format header using non-optional variables describing that mesh:

<P>
<PRE>
  2.0   7 ------- 8 ------- 9
        |         |         |
        |    4    |    5    |
        |         |         |
  1.0   4 ------- 5 ------- 6
        |         |  \   3  |
        |    1    |    \    |
        |         |  2   \  |
  0.0   1 ------- 2 ------- 3

       0.0       1.0        2.0

        Node indices at corners
       Element indices in centers

netcdf mesh-esmf {
dimensions:
        nodeCount = 9 ;
        elementCount = 5 ;
        maxNodePElement = 4 ;
        coordDim = 2 ;
variables:
        double  nodeCoords(nodeCount, coordDim);
                nodeCoords:units = "degrees" ;
        int elementConn(elementCount, maxNodePElement) ;
                elementConn:long_name = "Node Indices that define the element /
                                         connectivity";
                elementConn:_FillValue = -1 ;
        byte numElementConn(elementCount) ;
                numElementConn:long_name = "Number of nodes per element" ;
// global attributes:
                :gridType="unstructured";
                :version = "0.9" ;
data:
    nodeCoords=
        0.0, 0.0,
        1.0, 0.0,
        2.0, 0.0,
        0.0, 1.0,
        1.0, 1.0,
        2.0, 1.0,
        0.0, 2.0,
        1.0, 2.0,
        2.0, 2.0 ;

    elementConn=
        1, 2, 5,  4,
        2, 3, 5, -1,
        3, 6, 5, -1,
        4, 5, 8,  7,
        5, 6, 9,  8 ;

    numElementConn= 4, 3, 3, 4, 4 ;
}
</PRE>

<P>

<H2><A NAME="SECTION03026000000000000000"></A><A NAME="sec:fileformat:gridspec"></A>
<BR>
12.6 CF Convention GRIDSPEC File Format
</H2>

<P>
ESMF_RegridWeightGen supports NetCDF files that follow the CF GRIDSPEC convention for logically rectangular lat/lon grids.

<P>
GRIDSPEC is a draft proposal to extend the Climate and Forecast (CF) metadata conventions for the representation of gridded data for Earth System Models.  The original GRIDSPEC standard was proposed by V. Balaji and Z. Liang of GFDL.  It was further developed by D. Kinley and A. Pletzer of Tech X (see <A NAME="tex2html11"
  HREF="https://ice.txcorp.com/trac/modave/wiki/CFProposalGridspec">ref</A>).  The ESMF implementation is based on the GRIDSPEC document last updated on 02/09/2012.

<P>
GRIDSPEC extends the current CF convention to support grid  mosaics, i.e., a grid consisting of multiple logically
rectangular grid tiles. It also provides a mechanism for storing a grid dataset in multiple files.  Therefore,
it introduces different types of files, such as a mosaic file that defines the multiple tiles and their
connectivity, a host file that aggregrates the grid mosiac and the data files, and a tile file for a single tile
grid defination.

<P>
Currently, ESMF only supports the Grid creation and regridding from a single tile grid file.  A tile file
is a CF compliant NetCDF file for a logically rectangular lat/lon grid based on the
<A NAME="tex2html12"
  HREF="http://cf-pcmdi.llnl.gov/documents/cf-conventions/1.6/cf-conventions.html">CF Metadata Conventions V1.6</A>.   An example grid file is shown below.
The cell center coordinate variables are determined by the value of its attribute <TT>units</TT>.  The longitude
variable has the attribute value set to either <TT>degrees_east</TT>, <TT>degree_east</TT>, <TT>degrees_E</TT>, <TT>degree_E</TT>,
<TT>degreesE</TT> or <TT>degreeE</TT>.  The latitude variable has the attribute value set to <TT>degrees_north</TT>, <TT>degree_north</TT>, <TT>degrees_N</TT>,
<TT>degree_N</TT>, <TT>degreesN</TT> or <TT>degreeN</TT>.   The latitude and the longitude variables are one-dimensional arrays if the grid is a regular lat/lon grid, two-dimensional arrays if the grid is curvilinear. The bound coordinate
variables define the bound or the corner coordinates of a cell.  The bound variable name is specified in the
<TT>bounds</TT> attribute of the latitude and longitude variables.  In the following example, the latitude bound
variable is <TT>lat_bnds</TT> and the longitude bound variable is <TT>lon_bnds</TT>.  The bound variables are 2D
arrays for a regular lat/lon grid and a 3D array for a curvilinear grid.  The first dimension of the bound
array is 2 for a regular lat/lon grid and 4 for a curvilinear grid.  The bound coordinates for a curvilinear
grid is defined in counterclockwise order.  In the example below, the grid is a regular lat/lon
grid, thus the coordinate variables are 1D and the bound variables are 2D with the first dimension equal to 2.
The bound coordinates will be read in and stored in a ESMF Grid object as the corner stagger coordinates when doing a conservative regrid.  In case there are multiple sets of coordinate variables defined in a grid file,
the offline regrid application will return an error for duplicate latitude or longitude variables unless the user
uses "<TT><code>--</code>src_coordinates</TT>" or "<TT><code>--</code>src_coordinates</TT>" to specifiy the coordinate variable names
to be used in the regrid.

<P>
Since a GRIDSPEC tile file does not have a way to specify the grid mask, the mask is usually derived by the missing values stored in a data variable.  ESMF_RegridWeightGen provides an option for users to
derive the grid mask from a data variable's missing values.  The value of the missing value is defined by the
variable attribue <TT>missing_value</TT> or <TT>_FillValue</TT>.  If the value of the data point is equal to the
missing value, the grid mask for that grid point is set to 0, otherwise, it is set to 1.   In the following
grid, the variable <TT>so</TT> can be used to derive the grid mask.  A data variable could be a 2D, 3D or 4D.
For example, it may have additional depth and time dimensions.
It is assumed that the first and the second dimensions of the data variable should be the longitude and the
latitude dimension.  ESMF_RegridWeightGen will use the first 2D data values to derive the grid mask.

<P>
<PRE>
netcdf single_tile_grid {
dimensions:
	time = 1 ;
	bound = 2 ;
	lat = 181 ;
	lon = 360 ;
variables:
	double lat(lat) ;
		lat:bounds = "lat_bnds" ;
		lat:units = "degrees_north" ;
		lat:long_name = "latitude" ;
		lat:standard_name = "latitude" ;
	double lat_bnds(lat, bound) ;
	double lon(lon) ;
		lon:bounds = "lon_bnds" ;
		lon:long_name = "longitude" ;
		lon:standard_name = "longitude" ;
		lon:units = "degrees_east" ;
	double lon_bnds(lon, bound) ;
	float so(time, lat, lon) ;
		so:standard_name = "sea_water_salinity" ;
		so:units = "psu" ;
		so:missing_value = 1.e+20f ;
}
</PRE>

<P>

<H2><A NAME="SECTION03027000000000000000"></A><A NAME="sec:fileformat:ugrid"></A>
<BR>
12.7 CF Convention UGRID File Format
</H2>

<P>
ESMF_RegridWeightGen supports NetCDF files that follow the CF UGRID convention for unstructured grids.

<P>
The UGRID file format is a proposed extension to the CF metadata conventions for the unstructured grid data model. The latest proposal can be found at <A NAME="tex2html13"
  HREF="http://bit.ly/ugrid_cf">http://bit.ly/ugrid_cf</A>.  The proposal is still evolving, the Mesh creation API and ESMF_RegridWeightGen in the current ESMF release is based on the version updated on 02/28/2013.

<P>
In the UGRID proposal, a 1D, 2D, or 3D mesh topology can be defined for an unstructured grid.  Currently, ESMF
supports two types of meshes: (1) the 2D flexible mesh topology where each cell (a.k.a. "face" as defined in the UGRID document) in the mesh is either a triangle or a quadrilateral, and (2) the fully 3D unstructured mesh topology where each cell (a.k.a. "volume" as defined in the UGRID document) in the mesh
is either a tetrahedron or a hexahedron.  Pyramids and wedges are not currently supported in ESMF, but they
can be defined as degenerate hexahedrons.   

<P>
The main addition of the UGRID extension is a dummy variable that defines the mesh
topology.  This additional variable has a required attribute <TT>cf_role</TT> with value <TT>"mesh_topology"</TT>.  In addition, it has two more required attributes: <TT>topology_dimension</TT>
and <TT>node_coordinates</TT>.  If it is a 2D mesh (i.e., <TT>topology_dimension</TT> equals to 2), an additional attribute
<TT>face_node_connectivity</TT> is required.  If it is a 3D mesh (i.e., <TT>topology_dimension</TT> equals to 3), two additional attributes <TT>volume_node_connectivity</TT> and <TT>volume_shape_type</TT> are required.
The value of attribute <TT>node_coordinates</TT> is a list of the names of the node longitude and latitude variables,
plus the elevation variable if it is a 3D mesh.
The value of attribute <TT>face_node_connectivity</TT> or <TT>volume_node_connectivity</TT> is the variable name that defines the corner node indices for each mesh cell. The additional attribute <TT>volume_shape_type</TT> for the
3D mesh points to a flag variable that specifies the shape type of each cell in the mesh.

<P>

<H3><A NAME="SECTION03027100000000000000">
12.7.1 2D UGRID Example</A>
</H3>

<P>
Below is a sample 2D mesh called. <TT>FVCOM_grid2d</TT>. the dummy mesh topology variable is <TT>fvcom_mesh</TT>.  As described above, its <TT>cf_role</TT> attribute has to be <TT>mesh_topology</TT>
and <TT>topology_dimension</TT> attribute has to be 2 for a 2D mesh.  It defines
the node coordinate variable names to be <TT>lon</TT> and <TT>lat</TT>.  It also specifies the face/node connectivity variable name as <TT>nv</TT>.

<P>
The variable <TT>nv</TT> is a two-dimensional array that defines the node indices of each face. The first dimension
defines the maximal number of nodes for each face. In this example, it is a
triangle mesh so the number of nodes per face is 3.  Since each face may have different number of corner nodes,
some of the cells may have fewer nodes than the specified dimension. In that case, it is filled with the
missing values defined by the attribute <TT>_FillValue</TT>.  The nodes are in counter clockwise order.  An optional attribute
<TT>start_index</TT> defines whether the node index is 1-based or 0-based.

<P>
The coordinate variables follows the CF metadata convention for coordinates.  They are 1D array with attribute
<TT>standard_name</TT> being either <TT>latitutde</TT> or <TT>longitude</TT>.  The units of the coordinates can be either <TT>degrees</TT> or <TT>radians</TT>.

<P>
The UGRID files may also contain data variables.  The data may be located at the nodes or at the faces.  Two additional attributes are introduced in the UGRID extension for the data variables:  <TT>location</TT> and <TT>mesh</TT>.  The <TT>location</TT>
attribute defines where the data is located, it can be either <TT>face</TT> or <TT>node</TT>.  The <TT>mesh</TT> attribute defines which mesh topology this variable belongs to since multiple mesh topologies may be defined in one
file.  ESMF_RegridWeightGen uses the data variable on the face to derive the masks for the mesh cells
in the same way as for a GRIDSPEC file.  Currently, ESMF only supports mask on the cells, not on the nodes.

<P>
When creating a ESMF Mesh from a UGRID file, user has to provide the mesh topology mesh variable name to <TT>ESMF_MeshCreate()</TT>.

<P>
<PRE>
netcdf FVCOM_grid2d {
dimensions:
	node = 417642 ;
	nele = 826866 ;
	three = 3 ;
        time  = 1 ;

variables:
// Mesh topology
	int fvcom_mesh;
		fvcom_mesh:standard_name = "mesh_topology" ;
		fvcom_mesh:dimension = 2. ;
		fvcom_mesh:node_coordinates = "lon lat" ;
		fvcom_mesh:face_node_connectivity = "nv" ;
	int nv(nele, three) ;
		nv:standard_name = "face_node_connectivity" ;
		nv:start_index = 1. ;

// Mesh node coordinates
	float lon(node) ;
                lon:standard_name = "longitude" ;
	        lon:units = "degrees_east" ;
	float lat(node) ;
                lat:standard_name = "latitude" ;
		lat:units = "degrees_north" ;

// Data variable
	float ua(time, nele) ;
		ua:standard_name = "barotropic_eastward_sea_water_velocity" ;
		ua:missing_value = -999. ;
		ua:location = "face" ;
		ua:mesh = "fvcom_mesh" ;
	float va(time, nele) ;
		va:standard_name = "barotropic_northward_sea_water_velocity" ;
		va:missing_value = -999. ;
		va:location = "face" ;
		va:mesh = "fvcom_mesh" ;
}
</PRE>

<P>

<H3><A NAME="SECTION03027200000000000000">
12.7.2 3D UGRID Example</A>
</H3>

<P>
Following is a sample 3D UGRID file containing hexahedron cells. the dummy mesh topology variable is <TT>fvcom_mesh</TT>. Its <TT>cf_role</TT> attribute has to be <TT>mesh_topology</TT>
and <TT>topology_dimension</TT> attribute has to be 3 for a 3D mesh.  There are two additional required attributes:
<TT>volume_node_connectivity</TT> specifies a variable name that defines the corner indices of the mesh cells and
<TT>volume_shape_type</TT> specifies a variable name that defines the type of the mesh cells.

<P>
The node coordinates are defined by variables <TT>nodelon</TT>, <TT>nodelat</TT> and <TT>height</TT>. Currently, the units
attribute for the height variable is either <TT>kilometers</TT>, <TT>km</TT> or <TT>meters</TT>.
The variable <TT>vertids</TT> is a two-dimensional array that defines the corner node indices of each mesh cell. The first dimension
defines the maximal number of nodes for each cell. There is only one type of cells in the sample grid, i.e. hexahedrons, so the maximal number
of nodes is 8.  The node order is defined in&nbsp;<A HREF="node5.html#const:meshelemtype">31.2.1</A>.  The index can be either 1-based or 0-based and
the default is 0-based.
 Setting an optional attribute <TT>start_index</TT> to 1 changed it to 1-based index scheme.
The variable <TT>meshtype</TT> is a one-dimensional integer array that defines the shape type of each cell.  Currently, ESMF only
supports tetrahedron and hexahedron shapes. There are three attributes in <TT>meshtype</TT>: <TT>flag_range</TT>, <TT>flag_values</TT>, and <TT>flag_meanings</TT> representing the range of the flag values, all the possible flag values, and the meaning of each flag value, respectively.  <TT>flag_range</TT> and <TT>flag_values</TT> are either a scaler or an array of integers.  <TT>flag_meanings</TT> is a text string containing a list of shape types separated by space. In this example, there
is only one shape type, thus, the values of <TT>meshtype</TT> are all 1.

<P>
<PRE>
netcdf wam_ugrid100_110 {
dimensions:
	nnodes = 78432 ;
	ncells = 66030 ;
	eight = 8 ;
variables:
	int mesh ;
		mesh:cf_role = "mesh_topology" ;
		mesh:topology_dimension = 3. ;
		mesh:node_coordinates = "nodelon nodelat height" ;
		mesh:volume_node_connectivity = "vertids" ;
		mesh:volume_shape_type = "meshtype" ;
	double nodelon(nnodes) ;
		nodelon:standard_name = "longitude" ;
		nodelon:units = "degrees_east" ;
	double nodelat(nnodes) ;
		nodelat:standard_name = "latitude" ;
		nodelat:units = "degrees_north" ;
	double height(nnodes) ;
		height:standard_name = "elevation" ;
		height:units = "kilometers" ;
	int vertids(ncells, eight) ;
		vertids:cf_role = "volume_node_connectivity" ;
		vertids:start_index = 1. ;
	int meshtype(ncells) ;
		meshtype:cf_role = "volume_shape_type" ;
		meshtype:flag_range = 1. ;
		meshtype:flag_values = 1. ;
		meshtype:flag_meanings = "hexahedron" ;
}
</PRE>

<P>

<H2><A NAME="SECTION03028000000000000000"></A><A NAME="sec:weightfileformat"></A>
<BR>
12.8 Regrid Interpolation Weight File Format
</H2>

<P>
The regridding weight output file is in NetCDF format and contain some grid
information from each grid as well as the regridding indices and weights.
Following is the header of a sample output weight file that was generated by
regridding a logically rectangular 2D grid to a triangle mesh unstructured grid:

<P>
<PRE>
netcdf t42mpas-bilinear {
dimensions:
	n_a = 8192 ;
	n_b = 20480 ;
	n_s = 42456 ;
	nv_a = 4 ;
	nv_b = 3 ;
	num_wgts = 1 ;
	src_grid_rank = 2 ;
	dst_grid_rank = 1 ;
variables:
	int src_grid_dims(src_grid_rank) ;
	int dst_grid_dims(dst_grid_rank) ;
	double yc_a(n_a) ;
		yc_a:units = "degrees" ;
	double yc_b(n_b) ;
		yc_b:units = "radians" ;
	double xc_a(n_a) ;
		xc_a:units = "degrees" ;
	double xc_b(n_b) ;
		xc_b:units = "radians" ;
	double yv_a(n_a, nv_a) ;
		yv_a:units = "degrees" ;
	double xv_a(n_a, nv_a) ;
		xv_a:units = "degrees" ;
	double yv_b(n_b, nv_b) ;
		yv_b:units = "radians" ;
	double xv_b(n_b, nv_b) ;
		xv_b:units = "radians" ;
	int mask_a(n_a) ;
		mask_a:units = "unitless" ;
	int mask_b(n_b) ;
		mask_b:units = "unitless" ;
	double area_a(n_a) ;
		area_a:units = "square radians" ;
	double area_b(n_b) ;
		area_b:units = "square radians" ;
	double frac_a(n_a) ;
		frac_a:units = "unitless" ;
	double frac_b(n_b) ;
		frac_b:units = "unitless" ;
	int col(n_s) ;
	int row(n_s) ;
	double S(n_s) ;

// global attributes:
		:title = "ESMF Offline Regridding Weight Generator" ;
		:normalization = "destarea" ;
		:map_method = "Bilinear remapping" ;
		:conventions = "NCAR-CSM" ;
		:domain_a = "T42_grid.nc" ;
		:domain_b = "grid-dual.nc" ;
		:grid_file_src = "T42_grid.nc" ;
		:grid_file_dst = "grid-dual.nc" ;
		:CVS_revision = "5.3.0 beta snapshot" ;
}
</PRE>

<P>
Variables ended with "<TT>_a</TT>" are the variables for the source grid and the ones ended with "<TT>_b</TT>"
are the variables for the destination grid. For instance, <TT>xc_a</TT> and <TT>yc_a</TT> are corresponding
to the <TT>grid_center_lon</TT> and <TT>grid_center_lat</TT> variables in the source grid file.
The grid information includes the center and corner coordinates and the grid mask
arrays (<TT>mask_a</TT> and <TT>mask_b</TT>) from the input grid files.
The grid areas (<TT>area_a</TT> and <TT>area_b</TT>) are either provided by the user or computed by
<TT>ESMF_RegridWeightGen</TT>. The grid area array is only output when the conservative remapping
option is used. The values of the area array are set to zero for bilinear and patch remappings.
The grid frac arrays (<TT>frac_a</TT> and <TT>frac_b</TT>) are calculated by <TT>ESMF_RegridWeightGen</TT>.
For conservative remapping, the grid frac array
returns the area fraction of the grid cell which participates in the remapping.
For bilinear and patch remapping, the
destination grid frac array is one where the grid point participates in the remapping
and zero otherwise. For bilinear and patch remapping, the source grid frac array
is always set to zero.

<P>
The <TT>indices</TT> and <TT>weights</TT> generated by <TT>ESMF_FieldRegridStore()</TT> are stored in the output
file as variables <TT>col</TT>, <TT>row</TT> and <TT>S</TT>. Where <TT>col</TT> and <TT>row</TT> are the indices to the
source and the destination grid cells.  These are a one-dimension array with length defined by dimension
<TT>n_s</TT>. <TT>S</TT> is the weight which is multiplied by the source value indicated by <TT>col</TT> and then
summed with the destination value indicated by <TT>row</TT> to build the final interpolated value of the
destination.

<P>
The global attributes in the interpolation weight file describe some information about the process
which generated the weights. The <TT>title</TT> is always fixed at ``ESMF Offline Regridding Weight Generator'' for
a weight file generated by the ESMF offline weight generation application. The
<TT>normalization</TT> attribute describes how the conservative weights are calculated, currently this is always
set to ``destarea'' because this is the only option which we currently support. The setting ``destarea''
means that the conservative  weights are calculated by dividing the area of the intersection of the source
and destination cells by the area of the
destination cell. This is set even when the weights are not conservative in which case it can be ignored.
The <TT>map_method</TT> attribute indicates the interpolation type. The format of the interpolation weight file was developed
by a group outside of ESMF, because of its use by utilities outside of ESMF control, the range of some of the
meta data is constrained. The <TT>map_method</TT> is one of these. Because of this constraint, there is no
map method corresponding to patch interpolation. A weight file generated with the ``patch''
interpolation method will have <TT>map_method</TT> set to ``Bilinear remapping''.
 The <TT>conventions</TT> attribute indicates the format of the weight file, currently only ``NCAR-CSM'' is
 supported. The attributes <TT>domain_a</TT> and <TT>grid_file_src</TT> both indicate the source
grid file name.
The attributes <TT>domain_b</TT> and <TT>grid_file_dst</TT> both indicate the destination grid file name.
<TT>CVS_revision</TT> indicates the version of ESMF containing the application which was used to generate the
weight file.

<P>
The following code shows how to apply the weights in the weight file to interpolate a source field (src_field) defined 
over the source grid to a destination field (dst_field) defined over the destination grid. The variables <TT>n_s</TT>, <TT>n_b</TT>, 
<TT>row</TT>, <TT>col</TT>, and <TT>S</TT> are from the weight file. 

<P>
<PRE>
 ! Initialize destination field to 0.0
 do i=1, n_b
   dst_field(i)=0.0
 enddo

 ! Apply weights
 do i=1, n_s
   dst_field(row(i))=dst_field(row(i))+S(i)*src_field(col(i))
 enddo
</PRE>

<P>
If the first-order conservative interpolation method was specified ("-m conserve") then the destination field may need to be adjusted by the destination fraction (<TT>frac_b</TT>) if the destination grid extends outside the unmasked source grid. (If it isn't known if the destination extends outside the source, then it doesn't hurt to apply the destination fraction in either case. If it doesn't extend outside, then the fraction will be 1.0 everywhere anyway.) The following code shows how to adjust an already interpolated destination field (dst_field) by the destination fraction. The variables <TT>n_b</TT>, and <TT>frac_b</TT> are from the weight file:

<P>
<PRE>
 ! Adjust destination field by fraction
 do i=1, n_b
   if (frac_b(i) .ne. 0.0) then
      dst_field(i)=dst_field(i)/frac_b(i)
   endif
 enddo
</PRE>

<P>

<H2><A NAME="SECTION03029000000000000000"></A><A NAME="sec:regridweightgencheck"></A>
<BR>
12.9 ESMF_RegridWeightGenCheck
</H2>

<P>
The ESMF_RegridWeightGen application is used in the
<A NAME="tex2html14"
  HREF="http://www.earthsystemmodeling.org/users/code_examples/external_demos/external_demos.shtml">ESMF_RegridWeightGenCheck external demo</A>
to generate interpolation weights.  These weights are then tested by using them for a regridding operation and then comparing them against an analytic function on the destination grid.  This external demo is also used to regression test ESMF regridding, and it is run nightly on over 60 combinations of structured and unstructured, regional and global grids with each of the available regridding methods.

<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html1668"
  HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html1664"
  HREF="ESMF_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html1658"
  HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html1666"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html1669"
  HREF="node4.html">3 Superstructure</A>
<B> Up:</B> <A NAME="tex2html1665"
  HREF="ESMF_refdoc.html">ESMF_refdoc</A>
<B> Previous:</B> <A NAME="tex2html1659"
  HREF="node2.html">1 ESMF Overview</A>
 &nbsp; <B>  <A NAME="tex2html1667"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
