<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>3 API</TITLE>
<META NAME="description" CONTENT="3 API">
<META NAME="keywords" CONTENT="NUOPC_refdoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="NUOPC_refdoc.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="up" HREF="NUOPC_refdoc.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY BGCOLOR=white LINK=#083194 VLINK=#21004A>
<!--Navigation Panel-->
<A NAME="tex2html189"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html185"
  HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html179"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html187"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html190"
  HREF="node5.html">About this document ...</A>
<B> Up:</B> <A NAME="tex2html186"
  HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A NAME="tex2html180"
  HREF="node3.html">2 Design and Implementation</A>
 &nbsp; <B>  <A NAME="tex2html188"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html191"
  HREF="node4.html#SECTION00041000000000000000">3.1 Generic Component: NUOPC_Driver</A>
<LI><A NAME="tex2html192"
  HREF="node4.html#SECTION00042000000000000000">3.2 Generic Component: NUOPC_DriverAtmOcn</A>
<LI><A NAME="tex2html193"
  HREF="node4.html#SECTION00043000000000000000">3.3 Generic Component: NUOPC_DriverAtmOcnMed</A>
<LI><A NAME="tex2html194"
  HREF="node4.html#SECTION00044000000000000000">3.4 Generic Component: NUOPC_ModelBase</A>
<LI><A NAME="tex2html195"
  HREF="node4.html#SECTION00045000000000000000">3.5 Generic Component: NUOPC_Model</A>
<LI><A NAME="tex2html196"
  HREF="node4.html#SECTION00046000000000000000">3.6 Generic Component: NUOPC_Mediator</A>
<LI><A NAME="tex2html197"
  HREF="node4.html#SECTION00047000000000000000">3.7 Generic Component: NUOPC_Connector</A>
<LI><A NAME="tex2html198"
  HREF="node4.html#SECTION00048000000000000000">3.8 Utility Class: NUOPC_RunSequence</A>
<UL>
<LI><A NAME="tex2html199"
  HREF="node4.html#SECTION00048100000000000000">3.8.1 NUOPC_RunElementAdd</A>
<LI><A NAME="tex2html200"
  HREF="node4.html#SECTION00048200000000000000">3.8.2 NUOPC_RunElementPrint</A>
<LI><A NAME="tex2html201"
  HREF="node4.html#SECTION00048300000000000000">3.8.3 NUOPC_RunSequenceAdd</A>
<LI><A NAME="tex2html202"
  HREF="node4.html#SECTION00048400000000000000">3.8.4 NUOPC_RunSequenceDeallocate</A>
<LI><A NAME="tex2html203"
  HREF="node4.html#SECTION00048500000000000000">3.8.5 NUOPC_RunSequenceDeallocate</A>
<LI><A NAME="tex2html204"
  HREF="node4.html#SECTION00048600000000000000">3.8.6 NUOPC_RunSequenceIterate</A>
<LI><A NAME="tex2html205"
  HREF="node4.html#SECTION00048700000000000000">3.8.7 NUOPC_RunSequencePrint</A>
<LI><A NAME="tex2html206"
  HREF="node4.html#SECTION00048800000000000000">3.8.8 NUOPC_RunSequencePrint</A>
<LI><A NAME="tex2html207"
  HREF="node4.html#SECTION00048900000000000000">3.8.9 NUOPC_RunSequenceSet</A>
</UL>
<BR>
<LI><A NAME="tex2html208"
  HREF="node4.html#SECTION00049000000000000000">3.9 Utility Routines</A>
<UL>
<LI><A NAME="tex2html209"
  HREF="node4.html#SECTION00049100000000000000">3.9.1 NUOPC_ClockCheckSetClock</A>
<LI><A NAME="tex2html210"
  HREF="node4.html#SECTION00049200000000000000">3.9.2 NUOPC_ClockInitialize</A>
<LI><A NAME="tex2html211"
  HREF="node4.html#SECTION00049300000000000000">3.9.3 NUOPC_ClockPrintCurrTime</A>
<LI><A NAME="tex2html212"
  HREF="node4.html#SECTION00049400000000000000">3.9.4 NUOPC_ClockPrintStartTime</A>
<LI><A NAME="tex2html213"
  HREF="node4.html#SECTION00049500000000000000">3.9.5 NUOPC_ClockPrintStopTime</A>
<LI><A NAME="tex2html214"
  HREF="node4.html#SECTION00049600000000000000">3.9.6 NUOPC_CplCompAreServicesSet</A>
<LI><A NAME="tex2html215"
  HREF="node4.html#SECTION00049700000000000000">3.9.7 NUOPC_CplCompAttributeAdd</A>
<LI><A NAME="tex2html216"
  HREF="node4.html#SECTION00049800000000000000">3.9.8 NUOPC_CplCompAttributeGet</A>
<LI><A NAME="tex2html217"
  HREF="node4.html#SECTION00049900000000000000">3.9.9 NUOPC_CplCompAttributeSet</A>
<LI><A NAME="tex2html218"
  HREF="node4.html#SECTION000491000000000000000">3.9.10 NUOPC_FieldAttributeAdd</A>
<LI><A NAME="tex2html219"
  HREF="node4.html#SECTION000491100000000000000">3.9.11 NUOPC_FieldAttributeGet</A>
<LI><A NAME="tex2html220"
  HREF="node4.html#SECTION000491200000000000000">3.9.12 NUOPC_FieldAttributeSet</A>
<LI><A NAME="tex2html221"
  HREF="node4.html#SECTION000491300000000000000">3.9.13 NUOPC_FieldBundleUpdateTime</A>
<LI><A NAME="tex2html222"
  HREF="node4.html#SECTION000491400000000000000">3.9.14 NUOPC_FieldDictionaryAddEntry</A>
<LI><A NAME="tex2html223"
  HREF="node4.html#SECTION000491500000000000000">3.9.15 NUOPC_FieldDictionaryGetEntry</A>
<LI><A NAME="tex2html224"
  HREF="node4.html#SECTION000491600000000000000">3.9.16 NUOPC_FieldDictionaryHasEntry</A>
<LI><A NAME="tex2html225"
  HREF="node4.html#SECTION000491700000000000000">3.9.17 NUOPC_FieldDictionarySetup</A>
<LI><A NAME="tex2html226"
  HREF="node4.html#SECTION000491800000000000000">3.9.18 NUOPC_FieldIsAtTime</A>
<LI><A NAME="tex2html227"
  HREF="node4.html#SECTION000491900000000000000">3.9.19 NUOPC_FillCplList</A>
<LI><A NAME="tex2html228"
  HREF="node4.html#SECTION000492000000000000000">3.9.20 NUOPC_GridCompAreServicesSet</A>
<LI><A NAME="tex2html229"
  HREF="node4.html#SECTION000492100000000000000">3.9.21 NUOPC_GridCompAttributeAdd</A>
<LI><A NAME="tex2html230"
  HREF="node4.html#SECTION000492200000000000000">3.9.22 NUOPC_GridCompCheckSetClock</A>
<LI><A NAME="tex2html231"
  HREF="node4.html#SECTION000492300000000000000">3.9.23 NUOPC_GridCompSetClock</A>
<LI><A NAME="tex2html232"
  HREF="node4.html#SECTION000492400000000000000">3.9.24 NUOPC_GridCreateSimpleXY</A>
<LI><A NAME="tex2html233"
  HREF="node4.html#SECTION000492500000000000000">3.9.25 NUOPC_IsCreated</A>
<LI><A NAME="tex2html234"
  HREF="node4.html#SECTION000492600000000000000">3.9.26 NUOPC_StateAdvertiseField</A>
<LI><A NAME="tex2html235"
  HREF="node4.html#SECTION000492700000000000000">3.9.27 NUOPC_StateBuildStdList</A>
<LI><A NAME="tex2html236"
  HREF="node4.html#SECTION000492800000000000000">3.9.28 NUOPC_StateIsAllConnected</A>
<LI><A NAME="tex2html237"
  HREF="node4.html#SECTION000492900000000000000">3.9.29 NUOPC_StateIsAtTime</A>
<LI><A NAME="tex2html238"
  HREF="node4.html#SECTION000493000000000000000">3.9.30 NUOPC_StateIsFieldConnected</A>
<LI><A NAME="tex2html239"
  HREF="node4.html#SECTION000493100000000000000">3.9.31 NUOPC_StateIsUpdated</A>
<LI><A NAME="tex2html240"
  HREF="node4.html#SECTION000493200000000000000">3.9.32 NUOPC_StateRealizeField</A>
<LI><A NAME="tex2html241"
  HREF="node4.html#SECTION000493300000000000000">3.9.33 NUOPC_StateSetTimestamp</A>
<LI><A NAME="tex2html242"
  HREF="node4.html#SECTION000493400000000000000">3.9.34 NUOPC_StateUpdateTimestamp</A>
<LI><A NAME="tex2html243"
  HREF="node4.html#SECTION000493500000000000000">3.9.35 NUOPC_TimePrint</A>
</UL></UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00040000000000000000">
3 API</A>
</H1>

<P>

<H2><A NAME="SECTION00041000000000000000">
3.1 Generic Component: NUOPC_Driver</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_Driver
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Driver component that drives model and connector components. The default is to use explicit time stepping. Each driver time step, the same sequence of model and connector components' <TT>Run</TT> methods are called. The run sequence is fully customizable.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  ESMF_GridComp
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine routine_SetServices(gcomp, rc)
    type(ESMF_GridComp)   :: gcomp
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4</A> for a precise definition), with the following mapping:
    
<UL>
<LI>IPDv00p1 = phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>phase 1: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv00p1)
  
<UL>
<LI>Allocate and initialize the internal state.
</LI>
<LI>If the internal clock is not yet set, set the default internal clock to be a copy of the incoming clock, if the incoming clock is valid.
</LI>
<LI><I>Required specialization</I> to set number of model components, <TT>modelCount</TT>, in the internal state: <TT>label_SetModelCount</TT>.
</LI>
<LI>Allocate internal storage according to <TT>modelCount</TT>.
</LI>
<LI><I>Optional specialization</I> to provide Model and Connector <TT>petList</TT> members in the internal state: <TT>label_SetModelPetList</TT>.
</LI>
<LI>Create Model components with their import and export States.
</LI>
<LI>Attach standard NUOPC Model Component metadata.
</LI>
<LI>Create Connector components.
</LI>
<LI>Attach standard NUOPC Connector Component metadata.
</LI>
<LI>Initialize the default run sequence.
</LI>
<LI><I>Required specialization</I> to set component services: <TT>label_SetModelServices</TT>. 
  
<UL>
<LI>Call into SetServices() for all Model and Connector components.
</LI>
<LI>Optionally replace the default clock. 
</LI>
<LI>Optionally replace the default run sequence.
  
</LI>
</UL>
</LI>
<LI>Implement the initialize sequence for the child components, compatible with up to IPD version 01, as documented in section <A HREF="node3.html#IPD">2.4</A>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>If the incoming clock is valid, set the internal stop time to one time step interval on the incoming clock.
</LI>
<LI>Time stepping loop, from current time to stop time, incrementing by time step.
</LI>
<LI>For each time step iteration, the Model and Connector components Run() methods are being called according to the run sequence.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to finalize driver component: <TT>label_Finalize</TT>.
</LI>
<LI>Execute all Connector components' Finalize() methods in order.
</LI>
<LI>Execute all Model components' Finalize() methods in order.
</LI>
<LI>Destroy all Model components and their import and export states.
</LI>
<LI>Destroy all Connector components.
</LI>
<LI>Deallocate the run sequence.
</LI>
<LI>Deallocate the internal state.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>INTERNALSTATE:</I>
<PRE>  label_InternalState

  type type_InternalState
    type(type_InternalStateStruct), pointer :: wrap
  end type

  type type_InternalStateStruct
    integer                          :: modelCount
    type(type_PetList),  pointer     :: modelPetLists(:)
    type(type_PetList),  pointer     :: connectorPetLists(:,:)
    !--- private members ----------------------------------------
    type(ESMF_GridComp), pointer     :: modelComp(:)
    type(ESMF_State),    pointer     :: modelIS(:), modelES(:)
    type(ESMF_CplComp),  pointer     :: connectorComp(:,:)
    type(NUOPC_RunSequence), pointer :: runSeq(:)! size may increase dynamic.
    integer                          :: runPhaseToRunSeqMap(10)
    type(ESMF_Clock)                 :: driverClock  ! clock of the parent
  end type

  type type_PetList
    integer, pointer :: petList(:) !lists that are set here transfer ownership
  end type
</PRE>

<P>

<H2><A NAME="SECTION00042000000000000000">
3.2 Generic Component: NUOPC_DriverAtmOcn</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_DriverAtmOcn
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
This is a specialization of the <TT>NUOPC_Driver</TT> generic component, driving a coupled Atmosphere-Ocean model. The default is to use explicit time stepping. Each driver time step, the same sequence of Atmosphere, Ocean and connector <TT>Run</TT> methods are called. The run sequence is fully customizable for cases where explicit time stepping is not suitable.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  NUOPC_Driver
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine routine_SetServices(gcomp, rc)
    type(ESMF_GridComp)   :: gcomp
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4</A> for a precise definition), with the following mapping:
    
<UL>
<LI>IPDv00p1 = phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>phase 1: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv00p1)
  
<UL>
<LI>Allocate and initialize the internal state.
</LI>
<LI>If the internal clock is not yet set, set the default internal clock to be a copy of the incoming clock, if the incoming clock is valid.
</LI>
<LI>Set the number of model components to 2.
</LI>
<LI>Allocate internal storage according to <TT>modelCount = 2</TT>.
</LI>
<LI><I>Optional specialization</I> to provide Model and Connector <TT>petList</TT> members in the internal state: <TT>label_SetModelPetList</TT>.
</LI>
<LI>Create <TT>atm</TT> and <TT>ocn</TT> Model components with their import and export States.
</LI>
<LI>Attach standard NUOPC Model Component metadata.
</LI>
<LI>Create <TT>atm2ocn</TT> and <TT>ocn2atm</TT> Connector components.
</LI>
<LI>Attach standard NUOPC Connector Component metadata.
</LI>
<LI>Initialize the default run sequence.
</LI>
<LI><I>Required specialization</I> to set component services: <TT>label_SetModelServices</TT>. 
  
<UL>
<LI>Call into SetServices() for the <TT>atm</TT>, <TT>ocn</TT>, <TT>atm2ocn</TT>, and <TT>ocn2atm</TT> components.
</LI>
<LI>Optionally replace the default clock. 
</LI>
<LI>Optionally replace the default run sequence.
  
</LI>
</UL>
</LI>
<LI>Implement the initialize sequence for the child components, compatible with up to IPD version 01, as documented in section <A HREF="node3.html#IPD">2.4</A>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>If the incoming clock is valid, set the internal stop time to one time step interval on the incoming clock.
</LI>
<LI>Time stepping loop, from current time to stop time, incrementing by time step.
</LI>
<LI>For each time step iteration, the Run() methods for <TT>atm</TT>, <TT>ocn</TT>, <TT>atm2ocn</TT>, and <TT>ocn2atm</TT> are being called according to the run sequence.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to finalize driver component: <TT>label_Finalize</TT>.
</LI>
<LI>Execute Finalize() for <TT>atm2ocn</TT> and <TT>ocn2atm</TT>.
</LI>
<LI>Execute Finalize() for <TT>atm</TT> and <TT>ocn</TT>.
</LI>
<LI>Destroy <TT>atm</TT> and <TT>ocn</TT> and their import and export States.
</LI>
<LI>Destroy <TT>atm2ocn</TT> and <TT>ocn2atm</TT>.
</LI>
<LI>Deallocate the run sequence.
</LI>
<LI>Deallocate the internal state.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>INTERNALSTATE:</I>
<PRE>  label_InternalState

  type type_InternalState
    type(type_InternalStateStruct), pointer :: wrap
  end type

  type type_InternalStateStruct
    integer, pointer                  :: atmPetList(:)
    integer, pointer                  :: ocnPetList(:)
    type(ESMF_GridComp)               :: atm
    type(ESMF_GridComp)               :: ocn
    type(ESMF_State)                  :: atmIS, atmES
    type(ESMF_State)                  :: ocnIS, ocnES
    integer, pointer                  :: atm2ocnPetList(:)
    integer, pointer                  :: ocn2atmPetList(:)
    type(ESMF_CplComp)                :: atm2ocn, ocn2atm
    type(NUOPC_RunSequence), pointer  :: runSeq(:)
  end type
</PRE>

<P>

<H2><A NAME="SECTION00043000000000000000">
3.3 Generic Component: NUOPC_DriverAtmOcnMed</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_DriverAtmOcnMed
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
This is a specialization of the <TT>NUOPC_Driver</TT> generic component, driving a coupled Atmosphere-Ocean-Mediator model. The default is to use explicit time stepping. Each driver time step, the same sequence of Atmosphere, Ocean, Mediator, and the connector <TT>Run</TT> methods are called. The run sequence is fully customizable for cases where explicit time stepping is not suitable.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  NUOPC_Driver
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine routine_SetServices(gcomp, rc)
    type(ESMF_GridComp)   :: gcomp
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4</A> for a precise definition), with the following mapping:
    
<UL>
<LI>IPDv00p1 = phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>phase 1: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv00p1)
  
<UL>
<LI>Allocate and initialize the internal state.
</LI>
<LI>If the internal clock is not yet set, set the default internal clock to be a copy of the incoming clock, if the incoming clock is valid.
</LI>
<LI>Set the number of model components to 3.
</LI>
<LI>Allocate internal storage according to <TT>modelCount = 3</TT>.
</LI>
<LI><I>Optional specialization</I> to provide Model and Connector <TT>petList</TT> members in the internal state: <TT>label_SetModelPetList</TT>.
</LI>
<LI>Create <TT>atm</TT>, <TT>ocn</TT>, and <TT>med</TT> components with their import and export States.
</LI>
<LI>Attach standard NUOPC Model Component metadata.
</LI>
<LI>Create <TT>atm2ocn</TT>, atm2med, <TT>ocn2atm</TT>, <TT>ocn2atm</TT>, <TT>med2atm</TT>, and <TT>med2ocn</TT> Connector components.
</LI>
<LI>Attach standard NUOPC Connector Component metadata.
</LI>
<LI>Initialize the default run sequence.
</LI>
<LI><I>Required specialization</I> to set component services: <TT>label_SetModelServices</TT>. 
  
<UL>
<LI>Call into SetServices() for the <TT>atm</TT>, <TT>ocn</TT>, <TT>med</TT>, <TT>atm2ocn</TT>, atm2med, <TT>ocn2atm</TT>, <TT>ocn2atm</TT>, <TT>med2atm</TT>, and <TT>med2ocn</TT> components.
</LI>
<LI>Optionally replace the default clock. 
</LI>
<LI>Optionally replace the default run sequence.
  
</LI>
</UL>
</LI>
<LI>Implement the initialize sequence for the child components, compatible with up to IPD version 01, as documented in section <A HREF="node3.html#IPD">2.4</A>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>If the incoming clock is valid, set the internal stop time to one time step interval on the incoming clock.
</LI>
<LI>Time stepping loop, from current time to stop time, incrementing by time step.
</LI>
<LI>For each time step iteration, the Run() methods for <TT>atm</TT>, <TT>ocn</TT>, <TT>med</TT>, <TT>atm2ocn</TT>, atm2med, <TT>ocn2atm</TT>, <TT>ocn2atm</TT>, <TT>med2atm</TT>, and <TT>med2ocn</TT> are being called according to the run sequence.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to finalize driver component: <TT>label_Finalize</TT>.
</LI>
<LI>Execute Finalize() for <TT>atm2ocn</TT>, atm2med, <TT>ocn2atm</TT>, <TT>ocn2atm</TT>, <TT>med2atm</TT>, and <TT>med2ocn</TT>.
</LI>
<LI>Execute Finalize() for <TT>atm</TT>, <TT>ocn</TT>, and <TT>med</TT>.
</LI>
<LI>Destroy <TT>atm</TT>, <TT>ocn</TT>, and <TT>med</TT> and their import and export States.
</LI>
<LI>Destroy <TT>atm2ocn</TT>, atm2med, <TT>ocn2atm</TT>, <TT>ocn2atm</TT>, <TT>med2atm</TT>, and <TT>med2ocn</TT>.
</LI>
<LI>Deallocate the run sequence.
</LI>
<LI>Deallocate the internal state.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>INTERNALSTATE:</I>
<PRE>  label_InternalState

  type type_InternalState
    type(type_InternalStateStruct), pointer :: wrap
  end type

  type type_InternalStateStruct
    integer, pointer                  :: atmPetList(:)
    integer, pointer                  :: ocnPetList(:)
    integer, pointer                  :: medPetList(:)
    type(ESMF_GridComp)               :: atm
    type(ESMF_GridComp)               :: ocn
    type(ESMF_GridComp)               :: med
    type(ESMF_State)                  :: atmIS, atmES
    type(ESMF_State)                  :: ocnIS, ocnES
    type(ESMF_State)                  :: medIS, medES
    integer, pointer                  :: atm2medPetList(:)
    integer, pointer                  :: ocn2medPetList(:)
    integer, pointer                  :: med2atmPetList(:)
    integer, pointer                  :: med2ocnPetList(:)
    type(ESMF_CplComp)                :: atm2med, ocn2med
    type(ESMF_CplComp)                :: med2atm, med2ocn
    type(NUOPC_RunSequence), pointer  :: runSeq(:)
  end type
</PRE>

<P>

<H2><A NAME="SECTION00044000000000000000">
3.4 Generic Component: NUOPC_ModelBase</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Model component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called the model integrates one timeStep forward on the provided Clock. The Clock must be advanced between <TT>Run</TT> calls. The component's <TT>Run</TT> method flags incompatibility if the current time of the incoming Clock does not match the current time of the model.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  ESMF_GridComp
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine routine_SetServices(gcomp, rc)
    type(ESMF_GridComp)   :: gcomp
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4</A> for a precise definition), with the following mapping:
    
<UL>
<LI>IPDv00p1 = phase 1: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p2 = phase 2: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p3 = phase 3: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p4 = phase 4: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Allocate internal state memory.
</LI>
<LI>Assign the <TT>driverClock</TT> member in the internal state as an alias to the incoming clock.
</LI>
<LI><I>Optional specialization</I> to check and set the internal clock against the incoming clock: <TT>label_SetRunClock</TT>.
</LI>
<LI>Alternatively use the default specialization: check that internal clock and incoming clock agree on current time and that the time step of the incoming clock is a multiple of the internal clock time step. Under these conditions set the internal stop time to one time step interval on the incoming clock. Otherwise exit with error, flagging incompatibility.
</LI>
<LI><I>Optional specialization</I> to check Fields in import State: <TT>label_CheckImport</TT>.
</LI>
<LI>Alternatively use the default specialization: check that all import Fields are at the current time of the internal clock.
</LI>
<LI>Model time stepping loop, starting at current time, running to stop time on the internal clock using the internal Clock time step. Timestamp the Fields in the export State at the beginning of each iteration.
</LI>
<LI><I>Required specialization</I> to advance the model each time step: <TT>label_Advance</TT>.
</LI>
<LI><I>Optional specialization</I> to timestamp the Fields in the export State: <TT>label_TimestampExport</TT>.
</LI>
<LI>Deallocate internal state memory.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Optionally overwrite the provided NOOP with model finalization code.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>INTERNALSTATE:</I>
<PRE>  label_InternalState

  type type_InternalState
    type(type_InternalStateStruct), pointer :: wrap
  end type

  type type_InternalStateStruct
    type(ESMF_Clock)      :: driverClock
  end type
</PRE>

<P>

<H2><A NAME="SECTION00045000000000000000">
3.5 Generic Component: NUOPC_Model</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_Model
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Model component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called the model integrates one timeStep forward on the provided Clock. The Clock must be advanced between <TT>Run</TT> calls. The component's <TT>Run</TT> method flags incompatibility if the current time of the incoming Clock does not match the current time of the model.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine routine_SetServices(gcomp, rc)
    type(ESMF_GridComp)   :: gcomp
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4</A> for a precise definition), with the following mapping:
    
<UL>
<LI>IPDv00p1 = phase 1: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p2 = phase 2: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p3 = phase 3: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv00p4 = phase 4: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>phase 3: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv00p3, IPDv01p4, IPDv02p4)
  
<UL>
<LI>If the model internal clock is found to be not set, then set the model internal clock as a copy of the incoming clock. 
</LI>
<LI><I>Optional specialization</I> to set the internal clock and/or alarms: <TT>label_SetClock</TT>.
</LI>
<LI>Check compatibility, ensuring all advertised import Fields are connected.
  
</LI>
</UL>  
</LI>
<LI>phase 4: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv00p4, IPDv01p5)
  
<UL>
<LI><I>Optional specialization</I> to initialize export Fields: <TT>label_DataInitialize</TT>
</LI>
<LI>Time stamp Fields in export State for compatibility checking.
  
</LI>
</UL>    
</LI>
<LI>phase 5: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv02p5)
  
<UL>
<LI><I>Optional specialization</I> to initialize export Fields: <TT>label_DataInitialize</TT>
</LI>
<LI>Time stamp Fields in export State for compatibility checking.
</LI>
<LI>Set Component metadata used to resolve initialize data dependencies.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Allocate internal state memory.
</LI>
<LI>Assign the <TT>driverClock</TT> member in the internal state as an alias to the incoming clock.
</LI>
<LI><I>Optional specialization</I> to check and set the internal clock against the incoming clock: <TT>label_SetRunClock</TT>.
</LI>
<LI>Alternatively use the default specialization: check that internal clock and incoming clock agree on current time and that the time step of the incoming clock is a multiple of the internal clock time step. Under these conditions set the internal stop time to one time step interval on the incoming clock. Otherwise exit with error, flagging incompatibility.
</LI>
<LI><I>Optional specialization</I> to check Fields in import State: <TT>label_CheckImport</TT>.
</LI>
<LI>Alternatively use the default specialization: check that all import Fields are at the current time of the internal clock.
</LI>
<LI>Model time stepping loop, starting at current time, running to stop time on the internal clock using the internal Clock time step.
</LI>
<LI><I>Required specialization</I> to advance the model each time step: <TT>label_Advance</TT>.
</LI>
<LI>Timestamp all export Fields at the current time of the internal clock.
</LI>
<LI>Deallocate internal state memory.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Optionally overwrite the provided NOOP with model finalization code.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>INTERNALSTATE:</I>
<PRE>  label_InternalState

  type type_InternalState
    type(type_InternalStateStruct), pointer :: wrap
  end type

  type type_InternalStateStruct
    type(ESMF_Clock)      :: driverClock
  end type
</PRE>

<P>

<H2><A NAME="SECTION00046000000000000000">
3.6 Generic Component: NUOPC_Mediator</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_Mediator
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Mediator component with a default <EM>explicit</EM> time dependency. Each time the <TT>Run</TT> method is called, the time stamp on the imported Fields must match the current time (on both the incoming and internal Clock). Before returning, the Mediator time stamps the exported Fields with the same current time, before advancing the internal Clock one timeStep forward.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  NUOPC_ModelBase
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine routine_SetServices(gcomp, rc)
    type(ESMF_GridComp)   :: gcomp
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 00 (see section <A HREF="node3.html#IPD">2.4</A> for a precise definition), with the following mapping:
    
<UL>
<LI>IPDv00p1 = phase 1: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Advertise Fields in import and export States.
      
</LI>
</UL>
</LI>
<LI>IPDv00p2 = phase 2: (R<SMALL>EQUIRED, </SMALL>I<SMALL>MPLEMENTOR </SMALL>P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Realize advertised Fields in import and export States.
      
</LI>
</UL>  
</LI>
<LI>IPDv00p3 = phase 3: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Additional initialization phase.
      
</LI>
</UL>
</LI>
<LI>IPDv00p4 = phase 4: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
      
<UL>
<LI>Additional initialization phase.
      
</LI>
</UL>
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>phase 3: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Set the Mediator internal clock as a copy of the incoming clock. 
</LI>
<LI>Check compatibility, ensuring all advertised import Fields are connected.
  
</LI>
</UL>  
</LI>
<LI>phase 4: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to initialize export Fields: <TT>label_DataInitialize</TT>
</LI>
<LI>Time stamp Fields in import and export States for compatibility checking.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Allocate internal state memory.
</LI>
<LI>Assign the <TT>driverClock</TT> member in the internal state as an alias to the incoming clock.
</LI>
<LI>Check that internal clock and incoming clock agree on current time and that the time step of the incoming clock is a multiple of the internal clock time step (remember that the generic InitializePhase2 set the Mediator internal clock identical to the incoming clock). Under these conditions, set the internal stop time to one time step interval on the incoming clock. Otherwise exit with error, flagging incompatibility.
</LI>
<LI><I>Optional specialization</I> to check Fields in import State: <TT>label_CheckImport</TT>.
</LI>
<LI>Alternatively use the default specialization: check that all import Fields are at the current time of the internal clock.
</LI>
<LI>Timestamp all export Fields at the current time of the internal clock, i.e. the current time of the incoming clock.
</LI>
<LI>Mediator time step forward on the internal Clock, which is the same time step as on the incoming Clock. This prepares the internal clock for the next iteration.
</LI>
<LI><I>Required specialization</I> to mediate the Fields: <TT>label_Advance</TT>.
</LI>
<LI>Deallocate internal state memory.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Optionally overwrite the provided NOOP with Mediator finalization code.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>INTERNALSTATE:</I>
<PRE>  label_InternalState

  type type_InternalState
    type(type_InternalStateStruct), pointer :: wrap
  end type

  type type_InternalStateStruct
    type(ESMF_Clock)      :: driverClock
  end type
</PRE>

<P>

<H2><A NAME="SECTION00047000000000000000">
3.7 Generic Component: NUOPC_Connector</A>
</H2>

<P>

<P>

<P>

<P>

<P><P>
<BR>
<I>MODULE:</I>
<PRE>  module NUOPC_Connector
</PRE>

<P>

<P><P>
<BR>
<I>DESCRIPTION:
<BR></I>
Connector component that uses a default bilinear regrid method during <TT>Run</TT> to transfer data from the connected import Fields to the connected export Fields.

<P>

<P><P>
<BR>
<I>SUPER:</I>
<PRE>  ESMF_CplComp
</PRE>

<P>

<P><P>
<BR>
<I>USE DEPENDENCIES:</I>
<PRE>  use ESMF
</PRE>

<P>

<P><P>
<BR>
<I>SETSERVICES:</I>
<PRE>  subroutine routine_SetServices(cplcomp, rc)
    type(ESMF_CplComp)    :: cplcomp
    integer, intent(out)  :: rc
</PRE>

<P>

<P><P>
<BR>
<I>INITIALIZE:</I>

<UL>
<LI>phase 0: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI>Initialize the <TT>InitializePhaseMap</TT> Attribute according to the NUOPC Initialize Phase Definition (IPD) version 01 (see section <A HREF="node3.html#IPD">2.4</A> for a precise definition), with the following mapping:
    
<UL>
<LI>IPDv01p1 = phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv01p2 = phase 2: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
</LI>
<LI>IPDv01p3 = phase 3: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
    
</LI>
</UL>
</LI>
</UL>  
</LI>
<LI>phase 1: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv01p1, IPDv02p1)
  
<UL>
<LI>Construct a list of matching Field pairs between import and export State based on the <TT>StandardName</TT> Field metadata. 
</LI>
<LI>Store this list of <TT>StandardName</TT> entries in the <TT>CplList</TT> attribute of the Connector Component metadata.
  
</LI>
</UL>
</LI>
<LI>phase 2: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv01p2, IPDv02p2)
  
<UL>
<LI>Allocate and initialize the internal state.
</LI>
<LI>Use the <TT>CplList</TT> attribute to construct <TT>srcFields</TT> and <TT>dstFields</TT> FieldBundles in the internal state that hold matched Field pairs.
</LI>
<LI>Set the <TT>Connected</TT> attribute to <TT>true</TT> in the Field metadata for each Field that is added to the <TT>srcFields</TT> and <TT>dstFields</TT> FieldBundles.
  
</LI>
</UL>  
</LI>
<LI>phase 3: (NUOPC P<SMALL>ROVIDED</SMALL>, suitable for: IPDv01p3, IPDv02p3)
  
<UL>
<LI>Use the <TT>CplList</TT> attribute to construct <TT>srcFields</TT> and <TT>dstFields</TT> FieldBundles in the internal state that hold matched Field pairs.
</LI>
<LI>Set the <TT>Connected</TT> attribute to <TT>true</TT> in the Field metadata for each Field that is added to the <TT>srcFields</TT> and <TT>dstFields</TT> FieldBundles.
</LI>
<LI><I>Optional specialization</I> to precompute a Connector operation: <TT>label_ComputeRouteHandle</TT>. Simple custom implementations store the precomputed communication RouteHandle in the <TT>rh</TT> member of the internal state. More complex implementations use the <TT>state</TT> member in the internal state to store auxiliary Fields, FieldBundles, and RouteHandles.
</LI>
<LI>By default (if <TT>label_ComputeRouteHandle</TT> was <EM>not</EM> provided) precompute the Connector RouteHandle as a bilinear Regrid operation between <TT>srcFields</TT> and <TT>dstFields</TT>, with <TT>unmappedaction</TT> set to <TT>ESMF_UNMAPPEDACTION_IGNORE</TT>. The resulting RouteHandle is stored in the <TT>rh</TT> member of the internal state.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>RUN:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to execute a Connector operation: <TT>label_ExecuteRouteHandle</TT>. Simple custom implementations access the <TT>srcFields</TT>, <TT>dstFields</TT>, and <TT>rh</TT> members of the internal state to implement the required data transfers. More complex implementations access the <TT>state</TT> member in the internal state, which holds the auxiliary Fields, FieldBundles, and RouteHandles that potentially were added during the optional <TT>label_ComputeRouteHandle</TT> method during initialize.
</LI>
<LI>By default (if <TT>label_ExecuteRouteHandle</TT> was <EM>not</EM> provided) execute the precomputed Connector RouteHandle between <TT>srcFields</TT> and <TT>dstFields</TT>.
</LI>
<LI>Update the time stamp on the Fields in <TT>dstFields</TT> to match the time stamp on the Fields in <TT>srcFields</TT>.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>FINALIZE:</I>

<UL>
<LI>phase 1: (R<SMALL>EQUIRED, </SMALL>NUOPC P<SMALL>ROVIDED</SMALL>)
  
<UL>
<LI><I>Optional specialization</I> to release a Connector operation: <TT>label_ReleaseRouteHandle</TT>.
</LI>
<LI>By default (if <TT>label_ReleaseRouteHandle</TT> was <EM>not</EM> provided) release the precomputed Connector RouteHandle.
</LI>
<LI>Destroy the internal state members.
</LI>
<LI>Deallocate the internal state.
  
</LI>
</UL>
</LI>
</UL>

<P>

<P><P>
<BR>
<I>INTERNALSTATE:</I>
<PRE>  label_InternalState

  type type_InternalState
    type(type_InternalStateStruct), pointer :: wrap
  end type

  type type_InternalStateStruct
    type(ESMF_FieldBundle)  :: srcFields
    type(ESMF_FieldBundle)  :: dstFields
    type(ESMF_RouteHandle)  :: rh
    type(ESMF_State)        :: state
  end type
</PRE>

<P>

<P>

<H2><A NAME="SECTION00048000000000000000">
3.8 Utility Class: NUOPC_RunSequence</A>
</H2>

<P>
The <TT>NUOPC_RunSequence</TT> class provides a unified data structure that allows simple as well as complex time loops to be encoded and executed. There are entry points that allow different run phases to be mapped against distinctly different time loops.

<P>
Figure <A HREF="#fig:NUOPCRunSequence">2</A> depicts the data structures surrounding the <TT>NUOPC_RunSequence</TT>, starting with the InternalState of the <TT>NUOPC_Driver</TT> generic component.

<DIV ALIGN="CENTER"><A NAME="fig:NUOPCRunSequence"></A><A NAME="2387"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 2:</STRONG>
NUOPC_RunSequence class as it relates to the surrounding data structures.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER">
<!-- MATH
 $\scalebox{0.6}{\includegraphics{NUOPC_RunSequence}}$
 -->
<IMG
 WIDTH="755" HEIGHT="523" ALIGN="BOTTOM" BORDER="0"
 SRC="img2.png"
 ALT="\scalebox{0.6}{\includegraphics{NUOPC_RunSequence}}">
</DIV></TD></TR>
</TABLE>
</DIV>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00048100000000000000">
3.8.1 NUOPC_RunElementAdd - Add a RunElement to the end of a RunSequence</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_RunElementAdd(runSeq, i, j, phase, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunSequence), intent(inout), target :: runSeq
     integer,                 intent(in)            :: i, j, phase
     integer, optional,       intent(out)           :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Add a new RunElement at the end of a RunSequence. The RunElement is set to
     the values provided for <TT>i</TT>, <TT>j</TT>, <TT>phase</TT>. 

<P>

<P>

<H3><A NAME="SECTION00048200000000000000">
3.8.2 NUOPC_RunElementPrint - Print info about a RunElement object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_RunElementPrint(runElement, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunElement),  intent(in)  :: runElement
     integer, optional,       intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write information about <TT>runElement</TT> into the default log file. 

<P>

<P>

<H3><A NAME="SECTION00048300000000000000">
3.8.3 NUOPC_RunSequenceAdd - Add more RunSequences to a RunSequence vector</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_RunSequenceAdd(runSeq, addCount, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunSequence), pointer     :: runSeq(:)
     integer,                 intent(in)  :: addCount
     integer, optional,       intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
The incoming RunSequence vector <TT>runSeq</TT> is extended by <TT>addCount</TT>
     more RunSequence objects. The existing RunSequence objects are copied to the
     front of the new vector before the old vector is deallocated. 

<P>

<P>

<H3><A NAME="SECTION00048400000000000000">
3.8.4 NUOPC_RunSequenceDeallocate - Deallocate an entire RunSequence vector</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_RunSequenceDeallocate()
   subroutine NUOPC_RunSequenceArrayDeall(runSeq, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunSequence), pointer     :: runSeq(:)
     integer, optional,       intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Deallocate all of the RunElements in all of the RunSequence defined in the
     <TT>runSeq</TT> vector. 

<P>

<P>

<H3><A NAME="SECTION00048500000000000000">
3.8.5 NUOPC_RunSequenceDeallocate - Deallocate a single RunSequence object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_RunSequenceDeallocate()
   subroutine NUOPC_RunSequenceSingleDeall(runSeq, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunSequence), intent(inout)  :: runSeq
     integer, optional,       intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Deallocate all of the RunElements in the RunSequence defined by <TT>runSeq</TT>. 

<P>

<P>

<H3><A NAME="SECTION00048600000000000000">
3.8.6 NUOPC_RunSequenceIterate - Iterate through a RunSequence</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_RunSequenceIterate(runSeq, runSeqIndex, runElement, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_RunSequenceIterate
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunSequence), pointer     :: runSeq(:)
     integer,                 intent(in)  :: runSeqIndex
     type(NUOPC_RunElement),  pointer     :: runElement
     integer, optional,       intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Iterate through the RunSequence that is in position <TT>runSeqIndex</TT> in the
     <TT>runSeq</TT> vector. If <TT>runElement</TT> comes in <EM>unassociated</EM>, the
     iteration starts from the beginning. Otherwise this call takes one forward
     step relative to the incoming <TT>runElement</TT>, returning the next
     RunElement in <TT>runElement</TT>. In either case, 
     the logical function return value is <TT>.true.</TT> if the end of iteration
     has not been reached by the forward step, and <TT>.false.</TT> if the end of 
     iteration has been
     reached. The returned <TT>runElement</TT> is only valid for a function return
     value of <TT>.true.</TT>. 

<P>

<P>

<H3><A NAME="SECTION00048700000000000000">
3.8.7 NUOPC_RunSequencePrint - Print info about a single RunSequence object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_RunSequencePrint()
   subroutine NUOPC_RunSequenceSinglePrint(runSeq, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunSequence), intent(in)  :: runSeq
     integer, optional,       intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write information about <TT>runSeq</TT> into the default log file. 

<P>

<P>

<H3><A NAME="SECTION00048800000000000000">
3.8.8 NUOPC_RunSequencePrint - Print info about a RunSequence vector</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! Private name; call using NUOPC_RunSequencePrint()
   subroutine NUOPC_RunSequenceArrayPrint(runSeq, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunSequence), pointer     :: runSeq(:)
     integer, optional,       intent(out) :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write information about the whole <TT>runSeq</TT> vector into the default log 
     file. 

<P>

<P>

<H3><A NAME="SECTION00048900000000000000">
3.8.9 NUOPC_RunSequenceSet - Set values inside a RunSequence object</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_RunSequenceSet(runSeq, clock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(NUOPC_RunSequence), intent(inout) :: runSeq
     type(ESMF_Clock),        intent(in)    :: clock
     integer, optional,       intent(out)   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the Clock member in <TT>runSeq</TT>.


<P>

<P>

<H2><A NAME="SECTION00049000000000000000">
3.9 Utility Routines</A>
</H2>

<P>

<P>

<P>

<P>

<H3><A NAME="SECTION00049100000000000000">
3.9.1 NUOPC_ClockCheckSetClock - Check a Clock for compatibility</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_ClockCheckSetClock(setClock, checkClock, &amp;
     setStartTimeToCurrent, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock),        intent(inout)         :: setClock
     type(ESMF_Clock),        intent(in)            :: checkClock
     logical,                 intent(in),  optional :: setStartTimeToCurrent
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compares <TT>setClock</TT> to <TT>checkClock</TT> to make sure they match in
     their current Time. Further ensures that <TT>checkClock</TT>'s timeStep is a
     multiple of <TT>setClock</TT>'s timeStep. If both these condition are satisfied
     then the stopTime of the <TT>setClock</TT> is set one <TT>checkClock</TT>'s
     timeStep ahead of the current Time, taking into account the direction of 
     the Clock.

<P>
By default the startTime of the <TT>setClock</TT> is not modified. However, if
     <TT>setStartTimeToCurrent == .true.</TT> the startTime of <TT>setClock</TT> is set
     to the currentTime of <TT>checkClock</TT>. 

<P>

<P>

<H3><A NAME="SECTION00049200000000000000">
3.9.2 NUOPC_ClockInitialize - Initialize a new Clock from Clock and stabilityTimeStep</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_ClockInitialize(externalClock, stabilityTimeStep, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Clock) :: NUOPC_ClockInitialize
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock)                               :: externalClock
     type(ESMF_TimeInterval), intent(in),  optional :: stabilityTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns a new Clock instance that is a copy of the incoming Clock, but
     potentially with a smaller timestep. The timestep is chosen so that the
     timestep of the incoming Clock (<TT>externalClock</TT>) is a multiple of the
     new Clock's timestep, and at the same time the new timestep is &lt;= 
     the <TT>stabilityTimeStep</TT>. 

<P>

<P>

<H3><A NAME="SECTION00049300000000000000">
3.9.3 NUOPC_ClockPrintCurrTime - Formatted print ot current time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_ClockPrintCurrTime(clock, string, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock), intent(in)            :: clock
     character(*),     intent(in),  optional :: string
     character(*),     intent(out), optional :: unit
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Writes the formatted current time of <TT>clock</TT> to <TT>unit</TT>. Prepends 
     <TT>string</TT> if provided. If <TT>unit</TT> is present it must be an internal
     unit, i.e. a string variable. If <TT>unit</TT> is not present then the output
     is written to the default external unit (typically that would be stdout). 

<P>

<P>

<H3><A NAME="SECTION00049400000000000000">
3.9.4 NUOPC_ClockPrintStartTime - Formatted print ot start time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_ClockPrintStartTime(clock, string, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock), intent(in)            :: clock
     character(*),     intent(in),  optional :: string
     character(*),     intent(out), optional :: unit
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Writes the formatted start time of <TT>clock</TT> to <TT>unit</TT>. Prepends 
     <TT>string</TT> if provided. If <TT>unit</TT> is present it must be an internal
     unit, i.e. a string variable. If <TT>unit</TT> is not present then the output
     is written to the default external unit (typically that would be stdout). 

<P>

<P>

<H3><A NAME="SECTION00049500000000000000">
3.9.5 NUOPC_ClockPrintStopTime - Formatted print ot stop time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_ClockPrintStopTime(clock, string, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock), intent(in)            :: clock
     character(*),     intent(in),  optional :: string
     character(*),     intent(out), optional :: unit
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Writes the formatted stop time of <TT>clock</TT> to <TT>unit</TT>. Prepends 
     <TT>string</TT> if provided. If <TT>unit</TT> is present it must be an internal
     unit, i.e. a string variable. If <TT>unit</TT> is not present then the output
     is written to the default external unit (typically that would be stdout). 

<P>

<P>

<H3><A NAME="SECTION00049600000000000000">
3.9.6 NUOPC_CplCompAreServicesSet - Check if SetServices was called</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_CplCompAreServicesSet(comp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_CplCompAreServicesSet
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: comp
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if SetServices has been called for <TT>comp</TT>.
     Otherwise returns <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION00049700000000000000">
3.9.7 NUOPC_CplCompAttributeAdd - Add the NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_CplCompAttributeAdd(comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: comp
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Adds standard NUOPC Attributes to a Coupler Component. Checks the provided
     importState and exportState arguments for matching Fields and adds the list
     as "CplList" Attribute.

<P>
This adds the standard NUOPC Coupler Attribute package: convention="NUOPC", 
     purpose="General" to the Field. The NUOPC Coupler Attribute package extends
     the ESG Component Attribute package: convention="ESG", purpose="General".

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object to which the Attributes are added.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION00049800000000000000">
3.9.8 NUOPC_CplCompAttributeGet - Get a NUOPC CplComp Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_CplCompAttributeGet(comp, cplList, cplListSize, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(in)            :: comp
     character(*),       intent(out), optional :: cplList(:)
     integer,            intent(out), optional :: cplListSize
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Accesses the "CplList" Attribute inside of <TT>comp</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>General</TT>. Returns with error if
     the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION00049900000000000000">
3.9.9 NUOPC_CplCompAttributeSet - Set the NUOPC CplComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_CplCompAttributeSet(comp, importState, exportState, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_CplComp), intent(inout)         :: comp
     type(ESMF_State),   intent(in)            :: importState
     type(ESMF_State),   intent(in)            :: exportState
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Checks the provided importState and exportState arguments for matching Fields
     and sets the coupling list as "CplList" Attribute in <TT>comp</TT>.

<P>
The arguments are:
     <DL>
<DT><STRONG>comp</STRONG></DT>
<DD>The <TT>ESMF_CplComp</TT> object to which the Attributes are set.
     
</DD>
<DT><STRONG>importState</STRONG></DT>
<DD>Import State.
     
</DD>
<DT><STRONG>exportState</STRONG></DT>
<DD>Export State.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491000000000000000">
3.9.10 NUOPC_FieldAttributeAdd - Add the NUOPC Field Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldAttributeAdd(field, StandardName, Units, LongName, &amp;
     ShortName, Connected, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field)                      :: field
     character(*), intent(in)              :: StandardName
     character(*), intent(in),  optional   :: Units
     character(*), intent(in),  optional   :: LongName
     character(*), intent(in),  optional   :: ShortName
     character(*), intent(in),  optional   :: Connected
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Adds standard NUOPC Attributes to a Field object. Checks the provided
     arguments against the NUOPC Field Dictionary. Omitted optional
     information is filled in using defaults out of the NUOPC Field Dictionary.

<P>
This adds the standard NUOPC Field Attribute package: convention="NUOPC", 
     purpose="General" to the Field. The NUOPC Field Attribute package extends
     the ESG Field Attribute package: convention="ESG", purpose="General". 

<P>
The arguments are:
     <DL>
<DT><STRONG>field</STRONG></DT>
<DD>The <TT>ESMF_Field</TT> object to which the Attributes are added.
     
</DD>
<DT><STRONG>StandardName</STRONG></DT>
<DD>The StandardName of the Field. Must be a StandardName found in
       the  NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[Units]</STRONG></DT>
<DD>The Units of the Field. Must be convertible to the canonical
       units specified in the NUOPC Field Dictionary for the specified
       StandardName.
       If omitted, the default is to use the canonical units associated with
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[LongName]</STRONG></DT>
<DD>The LongName of the Field. NUOPC does not restrict the value
       of this variable.
       If omitted, the default is to use the LongName associated with 
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[ShortName]</STRONG></DT>
<DD>The ShortName of the Field. NUOPC does not restrict the value
       of this variable.
       If omitted, the default is to use the ShortName associated with 
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[Connected]</STRONG></DT>
<DD>The connection status of the Field. Must be one of the NUOPC supported
       values: <TT>false</TT> or <TT>true</TT>.
       If omitted, the default is a connected status of <TT>false</TT>.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000491100000000000000">
3.9.11 NUOPC_FieldAttributeGet - Get a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldAttributeGet(field, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     character(*),     intent(in)            :: name
     character(*),     intent(out)           :: value
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Accesses the Attribute <TT>name</TT> inside of <TT>field</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>General</TT>. Returns with error if
     the Attribute is not present or not set. 

<P>

<P>

<H3><A NAME="SECTION000491200000000000000">
3.9.12 NUOPC_FieldAttributeSet - Set a NUOPC Field Attribute</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldAttributeSet(field, name, value, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field)                      :: field
     character(*), intent(in)              :: name
     character(*), intent(in)              :: value
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Set the Attribute <TT>name</TT> inside of <TT>field</TT> using the
     convention <TT>NUOPC</TT> and purpose <TT>General</TT>. 

<P>

<P>

<H3><A NAME="SECTION000491300000000000000">
3.9.13 NUOPC_FieldBundleUpdateTime - Update the time stamp on all Fields in a FieldBundle</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldBundleUpdateTime(srcFields, dstFields, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_FieldBundle), intent(in)            :: srcFields
     type(ESMF_FieldBundle), intent(inout)         :: dstFields
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Updates the time stamp on all Fields in the <TT>dstFields</TT> FieldBundle to
     be the same as in the <TT>dstFields</TT> FieldBundle. 

<P>

<P>

<H3><A NAME="SECTION000491400000000000000">
3.9.14 NUOPC_FieldDictionaryAddEntry - Add an entry to the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionaryAddEntry(standardName, canonicalUnits, &amp;
     defaultLongName, defaultShortName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     character(*),                 intent(in)            :: canonicalUnits
     character(*),                 intent(in),  optional :: defaultLongName
     character(*),                 intent(in),  optional :: defaultShortName
     integer,                      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Adds an entry to the NUOPC Field dictionary. If necessary the dictionary is
     first set up. 

<P>

<P>

<H3><A NAME="SECTION000491500000000000000">
3.9.15 NUOPC_FieldDictionaryGetEntry - Get information about a NUOPC Field dictionary entry</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionaryGetEntry(standardName, canonicalUnits, &amp;
     defaultLongName, defaultShortName, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     character(*),                 intent(out), optional :: canonicalUnits
     character(*),                 intent(out), optional :: defaultLongName
     character(*),                 intent(out), optional :: defaultShortName
     integer,                      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns the canonical units, the default LongName and the default ShortName
     that the NUOPC Field dictionary associates with a StandardName. 

<P>

<P>

<H3><A NAME="SECTION000491600000000000000">
3.9.16 NUOPC_FieldDictionaryHasEntry - Check whether the NUOPC Field dictionary has a specific entry</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_FieldDictionaryHasEntry(standardName, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_FieldDictionaryHasEntry
</PRE><EM>ARGUMENTS:</EM>
<PRE>     character(*),                 intent(in)            :: standardName
     integer,                      intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the NUOPC Field dictionary has an entry with the
     specified StandardName, <TT>.false.</TT> otherwise. 

<P>

<P>

<H3><A NAME="SECTION000491700000000000000">
3.9.17 NUOPC_FieldDictionarySetup - Setup the NUOPC Field dictionary</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FieldDictionarySetup(rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Setup the NUOPC Field dictionary. 

<P>

<P>

<H3><A NAME="SECTION000491800000000000000">
3.9.18 NUOPC_FieldIsAtTime - Check if the Field is at the given Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_FieldIsAtTime(field, time, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_FieldIsAtTime
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Field), intent(in)            :: field
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the Field has a timestamp 
     that matches <TT>time</TT>. Otherwise returns <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION000491900000000000000">
3.9.19 NUOPC_FillCplList - Fill the cplList according to matching Fields</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_FillCplList(importState, exportState, cplList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),       intent(in)            :: importState
     type(ESMF_State),       intent(in)            :: exportState
     character(ESMF_MAXSTR), pointer               :: cplList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Constructs a list of matching StandardNames of Fields in the 
     <TT>importState</TT> and <TT>exportState</TT>. Returns this list in <TT>cplList</TT>.

<P>
The pointer argument <TT>cplList</TT> must enter this method unassociated. On
     return, the deallocation of the potentially associated pointer becomes the
     user responsibility. 

<P>

<P>

<H3><A NAME="SECTION000492000000000000000">
3.9.20 NUOPC_GridCompAreServicesSet - Check if SetServices was called</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_GridCompAreServicesSet(comp, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_GridCompAreServicesSet
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp), intent(in)            :: comp
     integer,             intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if SetServices has been called for <TT>comp</TT>. 
     Otherwise returns <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION000492100000000000000">
3.9.21 NUOPC_GridCompAttributeAdd - Add the NUOPC GridComp Attributes</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_GridCompAttributeAdd(comp, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp)                   :: comp
     integer,      intent(out), optional   :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Adds standard NUOPC Attributes to a Gridded Component.

<P>
This adds the standard NUOPC GridComp Attribute package: convention="NUOPC",
     purpose="General" to the Gridded Component. The NUOPC GridComp Attribute
     package extends the CIM Component Attribute package: convention="CIM 1.5",
     purpose="ModelComp".

<P>

<P>

<H3><A NAME="SECTION000492200000000000000">
3.9.22 NUOPC_GridCompCheckSetClock - Check Clock compatibility and set stopTime</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_GridCompCheckSetClock(comp, externalClock, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Compares <TT>externalClock</TT> to the Component internal Clock to make sure
     they match in their current Time. Further ensures that the external Clock's
     timeStep is a multiple of the internal Clock's timeStep. If both
     these condition are satisfied then the stopTime of the internal Clock is
     set to be reachable in one timeStep of the external Clock, taking into
     account the direction of the Clock. 

<P>

<P>

<H3><A NAME="SECTION000492300000000000000">
3.9.23 NUOPC_GridCompSetClock - Initialize and set the internal Clock of a GridComp</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_GridCompSetClock(comp, externalClock, stabilityTimeStep, &amp;
                                      rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_GridComp),     intent(inout)         :: comp
     type(ESMF_Clock),        intent(in)            :: externalClock
     type(ESMF_TimeInterval), intent(in),  optional :: stabilityTimeStep
     integer,                 intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the Component internal Clock as a copy of <TT>externalClock</TT>, but
     with a timeStep that is less than or equal to the stabilityTimeStep.
     At the same time ensures that the timeStep of the external Clock is
     a multiple of the internal Clock's timeStep. If the stabilityTimeStep
     argument is not provided then the internal Clock will simply be set
     as a copy of the externalClock. 

<P>

<P>

<H3><A NAME="SECTION000492400000000000000">
3.9.24 NUOPC_GridCreateSimpleXY - Create a simple XY cartesian Grid</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_GridCreateSimpleXY(x_min, y_min, x_max, y_max, &amp;
     i_count, j_count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     type(ESMF_Grid):: NUOPC_GridCreateSimpleXY
</PRE><EM>ARGUMENTS:</EM>
<PRE>     real(ESMF_KIND_R8), intent(in)            :: x_min, x_max, y_min, y_max
     integer,            intent(in)            :: i_count, j_count
     integer,            intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Creates and returns a very simple XY cartesian Grid. 

<P>

<P>

<H3><A NAME="SECTION000492500000000000000">
3.9.25 NUOPC_IsCreated - Check whether an ESMF object has been created</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   ! call using generic interface: NUOPC_IsCreated
   function NUOPC_ClockIsCreated(clock, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_ClockIsCreated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Clock)               :: clock
     integer, intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if the ESMF object (here <TT>clock</TT>) is in the
     created state, <TT>.false.</TT> otherwise. 

<P>

<P>

<H3><A NAME="SECTION000492600000000000000">
3.9.26 NUOPC_StateAdvertiseField - Advertise a Field in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_StateAdvertiseField(state, StandardName, Units, &amp;
     LongName, ShortName, name, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     character(*),     intent(in)            :: StandardName
     character(*),     intent(in),  optional :: Units
     character(*),     intent(in),  optional :: LongName
     character(*),     intent(in),  optional :: ShortName
     character(*),     intent(in),  optional :: name
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Advertises a Field in a State. This call checks the provided
     information against the NUOPC Field Dictionary. Omitted optional
     information is filled in using defaults out of the NUOPC Field Dictionary.

<P>
The arguments are:
     <DL>
<DT><STRONG>state</STRONG></DT>
<DD>The <TT>ESMF_State</TT> object through which the Field is advertised.
     
</DD>
<DT><STRONG>StandardName</STRONG></DT>
<DD>The StandardName of the advertised Field. Must be a StandardName found in
       the  NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[Units]</STRONG></DT>
<DD>The Units of the advertised Field. Must be convertible to the canonical
       units specified in the NUOPC Field Dictionary for the specified
       StandardName.
       If omitted, the default is to use the canonical units associated with
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[LongName]</STRONG></DT>
<DD>The LongName of the advertised Field. NUOPC does not restrict the value
       of this variable.
       If omitted, the default is to use the LongName associated with 
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[ShortName]</STRONG></DT>
<DD>The ShortName of the advertised Field. NUOPC does not restrict the value
       of this variable.
       If omitted, the default is to use the ShortName associated with 
       the StandardName in the NUOPC Field Dictionary.
     
</DD>
<DT><STRONG>[name]</STRONG></DT>
<DD>The actual name of the advertised Field by which it is accessed in the
       State object. NUOPC does not restrict the value of this variable.
       If omitted, the default is to use the value of the ShortName.
     
</DD>
<DT><STRONG>[rc]</STRONG></DT>
<DD>Return code; equals <TT>ESMF_SUCCESS</TT> if there are no errors.
     
</DD>
</DL>

<P>

<P>

<H3><A NAME="SECTION000492700000000000000">
3.9.27 NUOPC_StateBuildStdList - Build lists of Field information from a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   recursive subroutine NUOPC_StateBuildStdList(state, stdAttrNameList, &amp;
     stdItemNameList, stdConnectedList, stdFieldList, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State),       intent(in)            :: state
     character(ESMF_MAXSTR), pointer               :: stdAttrNameList(:)
     character(ESMF_MAXSTR), pointer, optional     :: stdItemNameList(:)
     character(ESMF_MAXSTR), pointer, optional     :: stdConnectedList(:)
     type(ESMF_Field),       pointer, optional     :: stdFieldList(:)
     integer,                intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Constructs lists containing the StandardName, Field name, and connected 
     status of the Fields in the <TT>state</TT>. Returns this information in the
     list arguments. Recursively parses through nested States.

<P>
All pointer arguments present must enter this method unassociated. On 
     return, the deallocation of an associated pointer becomes the user
     responsibility. 

<P>

<P>

<H3><A NAME="SECTION000492800000000000000">
3.9.28 NUOPC_StateIsAllConnected - Check if all the Fields in a State are connected</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_StateIsAllConnected(state, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_StateIsAllConnected
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if all the Fields in <TT>state</TT> are connected.
     Otherwise returns <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION000492900000000000000">
3.9.29 NUOPC_StateIsAtTime - Check if all the Fields in a State are at the given Time</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_StateIsAtTime(state, time, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_StateIsAtTime
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     type(ESMF_Time),  intent(in)            :: time
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if all the Fields in <TT>state</TT> have a timestamp 
     that matches <TT>time</TT>. Otherwise returns <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION000493000000000000000">
3.9.30 NUOPC_StateIsFieldConnected - Test if Field in a State is connected</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_StateIsFieldConnected(state, fieldName, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_StateIsFieldConnected
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     character(*),     intent(in)            :: fieldName
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if Fields with name <TT>fieldName</TT> contained in 
     <TT>state</TT> is connected. Otherwise returns <TT>.false.</TT>. 

<P>

<P>

<H3><A NAME="SECTION000493100000000000000">
3.9.31 NUOPC_StateIsUpdated - Check if all the Fields in a State are marked as updated</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   function NUOPC_StateIsUpdated(state, count, rc)
</PRE><EM>RETURN VALUE:</EM>
<PRE>     logical :: NUOPC_StateIsUpdated
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     integer,          intent(out), optional :: count
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Returns <TT>.true.</TT> if all the Fields in <TT>state</TT> have their "Updated"
     Attribute set to "true". Otherwise returns <TT>.false.</TT>. The <TT>count</TT>
     argument returns how many of the FIelds have the Updated" Attribtue set to
     "true". 

<P>

<P>

<H3><A NAME="SECTION000493200000000000000">
3.9.32 NUOPC_StateRealizeField - Realize a previously advertised Field in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_StateRealizeField(state, field, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Field), intent(in)            :: field
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Realizes a previously advertised Field in <TT>state</TT>. 

<P>

<P>

<H3><A NAME="SECTION000493300000000000000">
3.9.33 NUOPC_StateSetTimestamp - Set a time stamp on all Fields in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_StateSetTimestamp(state, clock, selective, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(inout)         :: state
     type(ESMF_Clock), intent(in)            :: clock
     logical,          intent(in),  optional :: selective
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Sets the TimeStamp Attribute according to <TT>clock</TT> on all the Fields in 
     <TT>state</TT>. 

<P>

<P>

<H3><A NAME="SECTION000493400000000000000">
3.9.34 NUOPC_StateUpdateTimestamp - Update the timestamp on all the Fields in a State</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_StateUpdateTimestamp(state, rootPet, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_State), intent(in)            :: state
     integer,          intent(in)            :: rootPet
     integer,          intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Updates the TimeStamp Attribute for all the Fields on all the PETs in the
     current VM to the TimeStamp Attribute held by the Field instance on the 
     <TT>rootPet</TT>. 

<P>

<P>

<H3><A NAME="SECTION000493500000000000000">
3.9.35 NUOPC_TimePrint - Formatted print ot time information</A>
</H3>

<P>

<P><P>
<BR>
<I>INTERFACE:</I>
<PRE>   subroutine NUOPC_TimePrint(time, string, unit, rc)
</PRE><EM>ARGUMENTS:</EM>
<PRE>     type(ESMF_Time), intent(in)            :: time
     character(*),    intent(in),  optional :: string
     character(*),    intent(out), optional :: unit
     integer,         intent(out), optional :: rc
</PRE>
<I>DESCRIPTION:
<BR></I>

<P>
Write a formatted time with or without <TT>string</TT>
     to <TT>unit</TT>. If <TT>unit</TT> is present it must be an internal unit, i.e. a 
     string variable. If <TT>unit</TT> is not present then the output is written to
     the default external unit (typically that would be stdout).


<P>
<HR>
<!--Navigation Panel-->
<A NAME="tex2html189"
  HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html185"
  HREF="NUOPC_refdoc.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html179"
  HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html187"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html190"
  HREF="node5.html">About this document ...</A>
<B> Up:</B> <A NAME="tex2html186"
  HREF="NUOPC_refdoc.html">NUOPC_refdoc</A>
<B> Previous:</B> <A NAME="tex2html180"
  HREF="node3.html">2 Design and Implementation</A>
 &nbsp; <B>  <A NAME="tex2html188"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
<A HREF=mailto:esmf_support@list.woc.noaa.gov>esmf_support@list.woc.noaa.gov</A>
</ADDRESS>
</BODY>
</HTML>
